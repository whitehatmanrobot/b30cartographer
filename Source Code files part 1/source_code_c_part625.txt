ansceiver Types
extern const WCHAR c_szAfThicknet[];
extern const WCHAR c_szAfThinnet[];
extern const WCHAR c_szAfTp[];
extern const WCHAR c_szAfAuto[];

enum NetTransceiverType
{
    NTT_UKNOWN, NTT_THICKNET, NTT_THINNET, NTT_TP, NTT_AUTO
};

// Netcard upgrade specific
extern const WCHAR c_szAfPreUpgradeInstance[];

// ----------------------------------------------------------------------
// Identification Page related

extern const WCHAR c_szAfComputerName[];
extern const WCHAR c_szAfJoinWorkgroup[];
extern const WCHAR c_szAfJoinDomain[];

extern const WCHAR c_szAfDomainAdmin[];
extern const WCHAR c_szAfDomainAdminPassword[];


// ----------------------------------------------------------------------
// Protocols related

//TCPIP
extern const WCHAR c_szAfEnableSecurity[];
extern const WCHAR c_szAfEnableICMPRedirect[];
extern const WCHAR c_szAfDeadGWDetectDefault[];
extern const WCHAR c_szAfDontAddDefaultGatewayDefault[];

extern const WCHAR c_szAfIpAllowedProtocols[];
extern const WCHAR c_szAfTcpAllowedPorts[];
extern const WCHAR c_szAfUdpAllowedPorts[];

extern const WCHAR c_szDatabasePath[];
extern const WCHAR c_szAfForwardBroadcasts[];
extern const WCHAR c_szAfPPTPTcpMaxDataRetransmissions[];
extern const WCHAR c_szAfUseZeroBroadcast[];
extern const WCHAR c_szAfArpAlwaysSourceRoute[];
extern const WCHAR c_szAfArpCacheLife[];
extern const WCHAR c_szAfArpTRSingleRoute[];
extern const WCHAR c_szAfArpUseEtherSNAP[];
extern const WCHAR c_szAfDefaultTOS[];
extern const WCHAR c_szDefaultTTL[];
extern const WCHAR c_szEnableDeadGWDetect[];
extern const WCHAR c_szEnablePMTUBHDetect[];
extern const WCHAR c_szEnablePMTUDiscovery[];
extern const WCHAR c_szForwardBufferMemory[];
extern const WCHAR c_szHostname[];
extern const WCHAR c_szIGMPLevel[];
extern const WCHAR c_szKeepAliveInterval[];
extern const WCHAR c_szKeepAliveTime[];
extern const WCHAR c_szMaxForwardBufferMemory[];
extern const WCHAR c_szMaxForwardPending[];
extern const WCHAR c_szMaxNumForwardPackets[];
extern const WCHAR c_szMaxUserPort[];
extern const WCHAR c_szMTU[];
extern const WCHAR c_szNumForwardPackets[];
extern const WCHAR c_szTcpMaxConnectRetransmissions[];
extern const WCHAR c_szTcpMaxDataRetransmissions[];
extern const WCHAR c_szTcpNumConnections[];
extern const WCHAR c_szTcpTimedWaitDelay[];
extern const WCHAR c_szTcpUseRFC1122UrgentPointer[];
extern const WCHAR c_szDefaultGateway[];
extern const WCHAR c_szDomain[];
extern const WCHAR c_szEnableSecurityFilters[];
extern const WCHAR c_szNameServer[];
extern const WCHAR c_szMaxHashTableSize[];
extern const WCHAR c_szEnableAddrMaskReply[];
extern const WCHAR c_szPersistentRoutes[];
extern const WCHAR c_szArpCacheMinReferencedLife[];
extern const WCHAR c_szArpRetryCount[];
extern const WCHAR c_szTcpMaxConnectresponseRetransmissions[];
extern const WCHAR c_szTcpMaxDupAcks[];
extern const WCHAR c_szSynAttackProtect[];
extern const WCHAR c_szTCPMaxPortsExhausted[];
extern const WCHAR c_szTCPMaxHalfOpen[];
extern const WCHAR c_szTCPMaxHalfOpenRetried[];
extern const WCHAR c_szDontAddDefaultGateway[];
extern const WCHAR c_szPPTPFiltering[];
extern const WCHAR c_szDhcpClassId[];
extern const WCHAR c_szAfUseDomainNameDevolution[];
extern const WCHAR c_szSyncDomainWithMembership[];
extern const WCHAR c_szAfDisableDynamicUpdate[];
extern const WCHAR c_szAfEnableAdapterDomainNameRegistration[];

//NetBt
extern const WCHAR c_szBcastNameQueryCount[];
extern const WCHAR c_szBcastQueryTimeout[];
extern const WCHAR c_szCacheTimeout[];
extern const WCHAR c_szNameServerPort[];
extern const WCHAR c_szNameSrvQueryCount[];
extern const WCHAR c_szNameSrvQueryTimeout[];
extern const WCHAR c_szSessionKeepAlive[];
extern const WCHAR c_szSizeSmallMediumLarge[];
extern const WCHAR c_szBroadcastAddress[];
extern const WCHAR c_szEnableProxyRegCheck[];
extern const WCHAR c_szInitialRefreshTimeout[];
extern const WCHAR c_szLmhostsTimeout[];
extern const WCHAR c_szMaxDgramBuffering[];
extern const WCHAR c_szNodeType[];
extern const WCHAR c_szRandomAdapter[];
extern const WCHAR c_szRefreshOpCode[];
extern const WCHAR c_szSingleResponse[];
extern const WCHAR c_szWinsDownTimeout[];
extern const WCHAR c_szEnableProxy[];

//DNS
extern const WCHAR c_szAfDns[];
extern const WCHAR c_szAfDnsHostname[];
extern const WCHAR c_szAfDnsDomain[];
extern const WCHAR c_szAfDnsServerSearchOrder[];
extern const WCHAR c_szAfDnsSuffixSearchOrder[];

//DHCP
extern const WCHAR c_szAfDhcp[];
extern const WCHAR c_szAfIpaddress[];
extern const WCHAR c_szAfSubnetmask[];
extern const WCHAR c_szAfDefaultGateway[];
extern const WCHAR c_szAfBindToDhcpServer[];

//WINS
extern const WCHAR c_szAfWins[];
extern const WCHAR c_szAfWinsServerList[];
//extern const WCHAR c_szAfWinsPrimary[];
//extern const WCHAR c_szAfWinsSecondary[];
extern const WCHAR c_szAfScopeid[];
extern const WCHAR c_szAfEnableLmhosts[];
extern const WCHAR c_szAfImportLmhostsFile[];
extern const WCHAR c_szAfNetBIOSOptions[];

//IPX
extern const WCHAR c_szAfInternalNetworkNumber[];
extern const WCHAR c_szAfFrameType[];

// ----------------------------------------------------------------------
// Services

//MS_NetClient
extern const WCHAR c_szAfMsNetClient[];
extern const WCHAR c_szAfComputerBrowser[];
extern const WCHAR c_szAfBrowseDomains[];
extern const WCHAR c_szAfDefaultProvider[];
extern const WCHAR c_szAfNameServiceAddr[];
extern const WCHAR c_szAfNameServiceProtocol[];

//LanmanServer
extern const WCHAR c_szAfBrowserParameters[];
extern const WCHAR c_szAfNetLogonParameters[];

extern const WCHAR c_szAfLmServerShares[];
extern const WCHAR c_szAfLmServerParameters[];
extern const WCHAR c_szAfLmServerAutotunedParameters[];

extern const WCHAR c_szAfLmServerOptimization[];
extern const WCHAR c_szAfBroadcastToClients[];

extern const WCHAR c_szAfMinmemoryused[];
extern const WCHAR c_szAfBalance[];
extern const WCHAR c_szAfMaxthroughputforfilesharing[];
extern const WCHAR c_szAfMaxthrouputfornetworkapps[];

//TCP/IP
extern const WCHAR c_szAfIpAllowedProtocols[];
extern const WCHAR c_szAfTcpAllowedPorts[];
extern const WCHAR c_szAfUdpAllowedPorts[];

//RAS
extern const WCHAR c_szAfParamsSection[];

extern const WCHAR c_szAfPortSections[];
extern const WCHAR c_szAfPortname[];
extern const WCHAR c_szAfPortUsage[];
extern const WCHAR c_szAfPortUsageClient[];
extern const WCHAR c_szAfPortUsageServer[];
extern const WCHAR c_szAfPortUsageRouter[];

extern const WCHAR c_szAfSetDialinUsage[];

extern const WCHAR c_szAfForceEncryptedPassword[];
extern const WCHAR c_szAfForceEncryptedData[];
extern const WCHAR c_szAfMultilink[];
extern const WCHAR c_szAfRouterType[];

extern const WCHAR c_szAfDialinProtocols[];

extern const WCHAR c_szAfDialIn[];
extern const WCHAR c_szAfDialOut[];
extern const WCHAR c_szAfDialInOut[];

extern const WCHAR c_szAfNetbeui[];
extern const WCHAR c_szAfTcpip[];
extern const WCHAR c_szAfIpx[];

extern const WCHAR c_szAfNetbeuiClientAccess[];
extern const WCHAR c_szAfTcpipClientAccess[];
extern const WCHAR c_szAfIpxClientAccess[];
extern const WCHAR c_szAfNetwork[];
extern const WCHAR c_szAfThisComputer[];

extern const WCHAR c_szAfUseDhcp[];
extern const WCHAR c_szAfIpAddressStart[];
extern const WCHAR c_szAfIpAddressEnd[];
extern const WCHAR c_szAfExcludeAddress[];

extern const WCHAR c_szAfClientCanReqIpaddr[];
extern const WCHAR c_szAfAutoNetworkNumbers[];
extern const WCHAR c_szAfNetNumberFrom[];
extern const WCHAR c_szAfSameNetworkNumber[];
extern const WCHAR c_szAfClientReqNodeNumber[];
extern const WCHAR c_szAfWanNetPoolSize[];
extern const WCHAR c_szAfSecureVPN[];

//PPTP
extern const WCHAR c_szAfPptpEndpoints[];

//Bindings
extern const WCHAR c_szAfDisable[];
extern const WCHAR c_szAfEnable[];
extern const WCHAR c_szAfPromote[];
extern const WCHAR c_szAfDemote[];

extern const WCHAR c_szAfDhcpServerParameters[];
extern const WCHAR c_szAfDhcpServerConfiguration[];

extern const WCHAR c_szAfNWCWorkstationParameters[];
extern const WCHAR c_szAfNWCWorkstationShares[];
extern const WCHAR c_szAfNWCWorkstationDrives[];

#endif // _AFILESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kkcwinf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       C W I N F . H
//
//  Contents:   Declaration of class CWInfFile and other related classes
//
//  Notes:
//
//  Author:     kumarp 04/12/97 17:17:27
//
//----------------------------------------------------------------------------
#pragma once
#include "kkstl.h"

//----------------------------------------------------------------------------
// forward declarations and useful typedefs
//----------------------------------------------------------------------------
typedef unsigned __int64 QWORD;

class CWInfContext;
typedef CWInfContext &RCWInfContext;

class CWInfFile;
typedef CWInfFile *PCWInfFile, &RCWInfFile;

class CWInfSection;
typedef CWInfSection *PCWInfSection, &RCWInfSection;

class CWInfKey;
typedef CWInfKey *PCWInfKey, &RCWInfKey;

class CWInfLine;
typedef CWInfLine *PCWInfLine, &RCWInfLine;

// access mode for CWInfFile
enum WInfAccessMode { IAM_Read, IAM_Write };

// search mode for CWInfFile
enum WInfSearchMode { ISM_FromCurrentPosition, ISM_FromBeginning };

typedef list<PCWInfLine> WifLinePtrList;
typedef WifLinePtrList::iterator WifLinePtrListIter;

// ----------------------------------------------------------------------
// Class CWInfContext
//
// Inheritance:
//   none
//
// Purpose:
//   Stores context within a CWInfFile during reading or writing
//
// Hungarian: wix
// ----------------------------------------------------------------------

class CWInfContext
{
    friend class CWInfFile;

public:
    CWInfContext() { posSection = 0; posLine = 0; }

private:
    WifLinePtrListIter posSection;
    WifLinePtrListIter posLine;
};


// ----------------------------------------------------------------------
// Class CWInfContext
//
// Inheritance:
//   none
//
// Purpose:
//   Allows simultaneous reading from and writing to an INF/INI style file
//
// Hungarian: wif
// ----------------------------------------------------------------------

class CWInfFile
{
public:
    CWInfFile();
    ~CWInfFile();

            BOOL Init();
	virtual BOOL Create(IN PCWSTR pszFileName);
    virtual BOOL Create(IN FILE *fp);
    virtual BOOL Open(IN PCWSTR pszFileName);
    virtual BOOL Open(IN FILE *fp);
    virtual BOOL Close();
    virtual BOOL SaveAs(IN PCWSTR pszFileName);
    virtual BOOL SaveAsEx(IN PCWSTR pszFileName); // used by SysPrep
    virtual BOOL Flush();
    virtual BOOL FlushEx(); // used by SysPrep
    virtual PCWSTR FileName() const { return m_strFileName.c_str(); }

    virtual const CWInfContext CurrentReadContext() const { return m_ReadContext; }
    virtual void  SetReadContext(IN RCWInfContext cwic)
                                                          { m_ReadContext = cwic; }

    virtual const CWInfContext CurrentWriteContext() const { return m_WriteContext; }
    virtual void  SetWriteContext(IN RCWInfContext cwic)
                                                          { m_WriteContext = cwic; }

    //Functions for reading
    virtual PCWInfSection FindSection(IN PCWSTR pszSectionName,
                                      IN WInfSearchMode wsmMode=ISM_FromBeginning);
    virtual void SetCurrentReadSection(IN PCWInfSection pwisSection);
    virtual PCWInfSection CurrentReadSection() const;

    virtual PCWInfKey FindKey(IN PCWSTR pszKeyName,
                              IN WInfSearchMode wsmMode=ISM_FromCurrentPosition);
    virtual PCWInfKey FirstKey();
    virtual PCWInfKey NextKey();

    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings);
    virtual BOOL    GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &slList);
    virtual BOOL    GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue);
    virtual BOOL    GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue);
    virtual BOOL    GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue);

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault);
    virtual DWORD   GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault);
    virtual QWORD   GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault);


    //Functions for writing
    virtual void  GotoEnd();

    virtual PCWInfSection AddSectionIfNotPresent(IN PCWSTR pszSectionName);
    virtual PCWInfSection AddSection(IN PCWSTR pszSectionName);
    virtual void  GotoEndOfSection(PCWInfSection section);
    virtual PCWInfSection CurrentWriteSection() const;
            void RemoveSection(IN PCWSTR szSectionName);
            void RemoveSections(IN TStringList& slSections);

    virtual PCWInfKey AddKey(IN PCWSTR pszKeyName);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Value);
    virtual void AddKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue);
    virtual void AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value);
    virtual void AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Format, IN va_list arglist);
    virtual void AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues);

    virtual void AddComment(IN PCWSTR pszComment);
    virtual void AddRawLine(IN PCWSTR szText);
    virtual void AddRawLines(IN PCWSTR* pszLines, IN DWORD cLines);


protected:
    WifLinePtrList *m_plSections, *m_plLines;
    CWInfContext m_WriteContext, m_ReadContext;

    BOOL AddLine(IN const PCWInfLine ilLine);
    virtual void ParseLine(IN PCWSTR pszLine);

private:
    tstring m_strFileName;
    FILE*   m_fp;
};

// ----------------------------------------------------------------------
// Type of a line in a CWInfFile
//
// Hungarian: ilt
// ----------------------------------------------------------------------
enum InfLineTypeEnum { INF_UNKNOWN, INF_SECTION, INF_KEY, INF_COMMENT, INF_BLANK, INF_RAW };
typedef enum InfLineTypeEnum InfLineType;

// ----------------------------------------------------------------------
// Class CWInfLine
//
// Inheritance:
//   none
//
// Purpose:
//   Represents a line in a CWInfFile
//
// Hungarian: wil
// ----------------------------------------------------------------------

class CWInfLine
{
public:
    CWInfLine(InfLineType type) { m_Type = type; }

    virtual void GetText(tstring &text) const = 0;
    virtual void GetTextEx(tstring &text) const = 0; // used by SysPrep

    InfLineType Type() const { return m_Type; }

    virtual ~CWInfLine(){};

protected:
    InfLineType m_Type;
};

// ----------------------------------------------------------------------
// Class CWInfSection
//
// Inheritance:
//   CWInfLine
//
// Purpose:
//   Represents a section in a CWInfFile
//
// Hungarian: wis
// ----------------------------------------------------------------------

class CWInfSection : public CWInfLine
{
    friend class CWInfFile;

public:
    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep
    virtual PCWSTR Name() const { return m_Name.c_str(); }

    //Functions for reading
    virtual PCWInfKey FindKey(IN PCWSTR pszKeyName,
                  IN WInfSearchMode wsmMode=ISM_FromCurrentPosition);
    virtual PCWInfKey FirstKey();
    virtual PCWInfKey NextKey();


    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(IN PCWSTR pszKeyName, OUT TStringArray &saStrings);
    virtual BOOL    GetStringListValue(IN PCWSTR pszKeyName, OUT TStringList &slList);
    virtual BOOL    GetStringValue(IN PCWSTR pszKeyName, OUT tstring &strValue);
    virtual BOOL    GetIntValue(IN PCWSTR pszKeyName, OUT DWORD *pdwValue);
    virtual BOOL    GetQwordValue(IN PCWSTR pszKeyName, OUT QWORD *pqwValue);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, OUT BOOL *pfValue);

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszKeyName, IN PCWSTR pszDefault);
    virtual DWORD   GetIntValue(IN PCWSTR pszKeyName, IN DWORD dwDefault);
    virtual QWORD   GetQwordValue(IN PCWSTR pszKeyName, IN QWORD qwDefault);
    virtual BOOL    GetBoolValue(IN PCWSTR pszKeyName, IN BOOL fDefault);

    //Functions for writing
    virtual void GotoEnd();

    virtual PCWInfKey AddKey(IN PCWSTR pszKeyName);
    virtual void AddKey(IN PCWSTR pszKeyName, IN PCWSTR Value);
    virtual void AddKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddQwordKey(IN PCWSTR pszKeyName, IN QWORD qwValue);
    virtual void AddHexKey(IN PCWSTR pszKeyName, IN DWORD Value);
    virtual void AddBoolKey(IN PCWSTR pszKeyName, IN BOOL Value);
    virtual void AddKeyV(IN PCWSTR pszKeyName, IN PCWSTR Format, IN ...);
    virtual void AddKey(IN PCWSTR pszKeyName, IN const TStringList &slValues);

    virtual void AddComment(IN PCWSTR pszComment);
    virtual void AddRawLine(IN PCWSTR szLine);

protected:
    tstring m_Name;
    WifLinePtrListIter m_posLine, m_posSection;
    CWInfFile *m_Parent;

    CWInfSection(IN PCWSTR pszSectionName, IN PCWInfFile parent);
   ~CWInfSection();

};

// ----------------------------------------------------------------------
// Class CWInfKey
//
// Inheritance:
//   CWInfLine
//
// Purpose:
//   Represents a key=value line in a CWInfFile
//
// Hungarian: wik
// ----------------------------------------------------------------------

class CWInfKey : public CWInfLine
{
    friend class CWInfFile;

public:
    CWInfKey(IN PCWSTR pszKeyName);
    ~CWInfKey();
    static void Init();
    static void UnInit();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep

    PCWSTR Name() const { return m_Name.c_str(); }

    //Read values

    //these functions return the FALSE if value not found
    //or if it is in a wrong format
    virtual BOOL    GetStringArrayValue(OUT TStringArray &saStrings) const;
    virtual BOOL    GetStringListValue(OUT TStringList& slList) const;
    virtual BOOL    GetStringValue(OUT tstring& strValue) const;
    virtual BOOL    GetIntValue(OUT DWORD *pdwValue) const;
    virtual BOOL    GetQwordValue(OUT QWORD *pqwValue) const;
    virtual BOOL    GetBoolValue(OUT BOOL *pfValue) const;

    //these functions return the default value if value not found
    //or if it is in a wrong format
    virtual PCWSTR GetStringValue(IN PCWSTR pszDefault) const;
    virtual DWORD   GetIntValue(IN DWORD dwDefault) const;
    virtual QWORD   GetQwordValue(IN QWORD qwDefault) const;
    virtual BOOL    GetBoolValue(IN BOOL fDefault) const;

    //Write values
    virtual void SetValues(IN PCWSTR Format, va_list arglist);
    virtual void SetValues(IN PCWSTR Format, IN ...);
    virtual void SetValue(IN PCWSTR Value);
    virtual void SetValue(IN DWORD Value);
    virtual void SetQwordValue(IN QWORD Value);
    virtual void SetHexValue(IN DWORD Value);
    virtual void SetBoolValue(IN BOOL Value);
    virtual void SetValue(IN const TStringList &slValues);

protected:
    static WCHAR *m_Buffer;

private:
    tstring m_Name, m_Value;
    BOOL    m_fIsAListAndAlreadyProcessed;  // the value is a MULTI_SZ, will be
                                            // written out as a comma-separated
                                            // list, and has already been checked
                                            // to see if it has special chars and
                                            // needs to be surrounded by quotes.
};


// ----------------------------------------------------------------------
// Class CWInfComment
//
// Inheritance:
//   CWInfComment
//
// Purpose:
//   Represents a comment line in a CWInfFile
//
// Hungarian: wic
// ----------------------------------------------------------------------

class CWInfComment : public CWInfLine
{
public:
    CWInfComment(IN PCWSTR pszComment);
    ~CWInfComment();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep

protected:

private:
    tstring m_strCommentText;
};

// ----------------------------------------------------------------------
// Class CWInfRaw
//
// Inheritance:
//   CWInfRaw
//
// Purpose:
//   Represents a raw line in a CWInfFile
//
// Hungarian: wir
// ----------------------------------------------------------------------

class CWInfRaw : public CWInfLine
{
public:
    CWInfRaw(IN PCWSTR szText);
    ~CWInfRaw();

    virtual void GetText(tstring &text) const;
    virtual void GetTextEx(tstring &text) const; // used by SysPrep
protected:

private:
    tstring m_strText;
};


// ----------------------------------------------------------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kkstl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K S T L . H
//
//  Contents:
//
//  Notes:
//
//  Author:     kumarp
//
//----------------------------------------------------------------------------

#pragma once
#include "ncstring.h"

typedef list<PVOID> TPtrList;
typedef TPtrList::iterator TPtrListIter;

typedef list<tstring*> TStringList;
typedef TStringList::iterator TStringListIter;

typedef vector<BYTE> TByteArray;

typedef vector<tstring*> TStringArray;

// ----------------------------------------------------------------------

void FormatTString(IN OUT tstring& str, IN PCWSTR pszFormat, ...);

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN PCWSTR pszString)
{
    sl.push_back(new tstring(pszString));
}

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN const tstring* pstr)
{
    sl.push_back(new tstring(*pstr));
}

inline void AddAtEndOfStringList(IN TStringList& sl,
                                            IN const tstring& pstr)
{
    sl.push_back(new tstring(pstr));
}

inline void AddAtBeginningOfStringList(IN TStringList& sl,
                                                  IN const tstring& pstr)
{
    sl.push_front(new tstring(pstr));
}


BOOL FIsInStringList(IN const TStringList& sl, IN tstring& str,
                     OUT TStringListIter* pos=NULL);
BOOL FIsInStringList(IN const TStringList& sl, IN PCWSTR psz,
                     OUT TStringListIter* pos=NULL);

tstring* GetNthItem(IN TStringList& sl, IN DWORD dwIndex);

// ----------------------------------------------------------------------

inline TPtrListIter AddAtEndOfPtrList(IN TPtrList& pl, IN PVOID pv)
{
    return pl.insert(pl.end(), pv);
}


inline TPtrListIter GetIterAtBack(IN const TPtrList* ppl)
{
    TPtrListIter pliRet = ppl->end();
    pliRet--;
    return pliRet;
}

inline void EraseAll(IN TPtrList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

void EraseAndDeleteAll(IN TPtrList* ppl);
void EraseAndDeleteAll(IN TPtrList& ppl);

inline void EraseAll(IN TStringList* ppl)
{
    ppl->erase(ppl->begin(), ppl->end());
}

void EraseAndDeleteAll(IN TStringList* ppl);
void EraseAndDeleteAll(IN TStringList& ppl);

// ----------------------------------------------------------------------

void GetDataFromByteArray(IN const TByteArray& ba, OUT BYTE*& pb);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\kkutils.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       K K U T I L S . H
//
//  Contents:   Misc. helper functions
//
//  Notes:
//
//  Author:     kumarp   14 Jan 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "kkstl.h"

#ifndef NCAPI
#define NCAPI          extern "C" HRESULT __declspec(dllexport)
#endif

#ifdef ENABLETRACE
#define DefineFunctionName(name) static char __FUNCNAME__[] = name
#else
#define DefineFunctionName(name) (void) 0
#define __FUNCNAME__    ""
#endif

#define DeleteIfNotNull(p)  \
    delete p; \
    p = NULL;

#define ReturnHrIfFailedSz(hr,msg)  if (FAILED(hr)) \
                                    { \
                                       TraceError(msg, hr); \
                                       return hr; \
                                    }
#define ReturnHrIfFailed(hr)        if (FAILED(hr)) \
                                    { \
                                       TraceError(__FUNCNAME__, hr); \
                                       return hr; \
                                    }
#define ReturnErrorIf(condition,hr) if (condition) \
                                    { \
                                       TraceError(__FUNCNAME__, hr); \
                                       return hr; \
                                    }
#define ReturnError(hr)             if (1) { TraceFunctionError(hr); return hr; }
#define DoErrorCleanupAndReturnError(status_var,error_code) \
                                    { \
                                       status_var = error_code; \
                                       goto error_cleanup; \
                                    }
#define DoErrorCleanupAndReturnErrorIf(condition,status_var,error_code) \
                                    if (condition) \
                                    { \
                                       status_var = error_code; \
                                       goto error_cleanup; \
                                    }

#define TraceFunctionEntry(ttid)    TraceTag(ttid, "---------> entering %s", __FUNCNAME__)
#define TraceFunctionError(hr)      TraceError(__FUNCNAME__, hr)
#define TraceLastWin32ErrorInCurrentFunction() TraceLastWin32Error(__FUNCNAME__)
#define TraceWin32FunctionError(e)  TraceFunctionError(HRESULT_FROM_WIN32(e))

#define ReturnNULLIf(condition)     if (condition) return NULL
#define BreakIf(condition)          if (condition) break
#define ContinueIf(condition)       if (condition) continue
//#define ReturnFalseIfFailed(hr)     if ((hr) != S_OK) return FALSE
#define DoErrorCleanupIf(condition) if (condition) goto error_cleanup
#define AppendErrorAndReturnFalseIf(condition,e) if (condition) { AppendError(e); return FALSE;}

#define BenignAssert()              AssertSz(FALSE,"Benign Assert (this is not a bug): Click Ignore to continue...")

#define CR L"\n"

void AddOnlyOnceToStringList(IN TStringList* psl, IN PCWSTR pszString);
void ConvertDelimitedListToStringList(IN const tstring& strDelimitedList,
                      IN WCHAR chDelimiter,
                      OUT TStringList &slList);
void ConvertCommaDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList);
void ConvertSpaceDelimitedListToStringList(IN const tstring& strDelimitedList,
                                           OUT TStringList &slList);


void ConvertStringListToCommaList(IN const TStringList &slList,
                                  OUT tstring &strList);
void ConvertStringListToDelimitedList(IN const TStringList &slList,
                                      OUT tstring &strList, IN WCHAR chDelimiter);

BOOL IsBoolString(IN PCWSTR pszStr, OUT BOOL *pbValue);

BOOL UpgradingFromNT(IN DWORD dwUpgradeFlag);

BOOL FIsInStringArray(
    IN const PCWSTR* ppszStrings,
    IN DWORD cNumStrings,
    IN PCWSTR pszStringToFind,
    OUT UINT* puIndex=NULL);

HRESULT HrRegOpenServiceKey(IN PCWSTR pszServiceName,
                            REGSAM samDesired,
                            OUT HKEY* phKey);
HRESULT HrRegOpenServiceSubKey(IN PCWSTR pszServiceName,
                               IN PCWSTR pszSubKey,
                               REGSAM samDesired,
                               OUT HKEY* phKey);
BOOL FIsServiceKeyPresent(IN PCWSTR pszServiceName);

void AppendToPath(IN OUT tstring* pstrPath, IN PCWSTR pszItem);
void EraseAndDeleteAll(IN TStringArray* sa);
void ConvertDelimitedListToStringArray(IN const tstring& strDelimitedList,
                                       IN WCHAR chDelimiter,
                                       OUT TStringArray &saStrings);
void ConvertCommaDelimitedListToStringArray(IN const tstring& strDelimitedList,
                                            OUT TStringArray &saStrings);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\naming.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001.
//
//  File:       N A M I N G . H
//
//  Contents:   Generates Connection Names Automatically
//
//  Notes:
//
//  Author:     deonb    27 Feb 2001
//
//----------------------------------------------------------------------------

#pragma once

#include "nameres.h"
#include "netconp.h"

using namespace std;

class CIntelliName;
typedef BOOL FNDuplicateNameCheck(IN  const CIntelliName*        pIntelliName, 
                                  IN  LPCTSTR              szName, 
                                  OUT NETCON_MEDIATYPE*    pncm, 
                                  OUT NETCON_SUBMEDIATYPE* pncms);

class CIntelliName : CNetCfgDebug<CIntelliName>
{
    FNDuplicateNameCheck* m_pFNDuplicateNameCheck;
    HINSTANCE m_hInstance;

private:
    BOOL    NameExists(IN     LPCWSTR              szName, 
                       IN OUT NETCON_MEDIATYPE*    pncm, 
                       IN     NETCON_SUBMEDIATYPE* pncms) const;

    HRESULT GenerateNameRenameOnConflict(IN  REFGUID          guid, 
                                         IN  NETCON_MEDIATYPE ncm, 
                                         IN  DWORD            dwCharacteristics, 
                                         IN  LPCWSTR          szHintName, 
                                         IN  LPCWSTR          szHintType, 
                                         OUT LPWSTR *         szName) const;

    HRESULT GenerateNameFromResource(IN  REFGUID          guid, 
                                     IN  NETCON_MEDIATYPE ncm, 
                                     IN  DWORD            dwCharacteristics, 
                                     IN  LPCWSTR          szHint, 
                                     IN  UINT             uiNameID, 
                                     IN  UINT             uiTypeId, 
                                     OUT LPWSTR *         szName) const;
    
    BOOL    IsReservedName(LPCWSTR szName) const;

public:
    HRESULT HrGetPseudoMediaTypes(IN  REFGUID              guid, 
                                  OUT NETCON_MEDIATYPE *   pncm, 
                                  OUT NETCON_SUBMEDIATYPE* pncms) const;

    // Pass NULL to pFNDuplicateNameCheck for no Duplicate Check
    CIntelliName(IN  HINSTANCE hInstance, IN  FNDuplicateNameCheck *pFNDuplicateNameCheck);

    // Must LocalFree szName for these:
    HRESULT GenerateName(IN  REFGUID          guid, 
                         IN  NETCON_MEDIATYPE ncm, 
                         IN  DWORD            dwCharacteristics, 
                         IN  LPCWSTR          szHint, 
                         OUT LPWSTR *         szName) const;
};

BOOL IsMediaWireless(NETCON_MEDIATYPE ncm, const GUID &gdDevice);
BOOL IsMedia1394(NETCON_MEDIATYPE ncm, const GUID &gdDevice);

#ifndef _NTDDNDIS_
typedef ULONG NDIS_OID, *PNDIS_OID;
#endif
HRESULT HrQueryDeviceOIDByName(IN     LPCWSTR         szDeviceName,
                               IN     DWORD           dwIoControlCode,
                               IN     ULONG           Oid,
                               IN OUT LPDWORD         pnSize,
                               OUT    LPVOID          pbValue);

HRESULT HrQueryNDISAdapterOID(IN     REFGUID         guidId,
                              IN     NDIS_OID        Oid,
                              IN OUT LPDWORD         pnSize,
                              OUT    LPVOID          pbValue);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\lancmn.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       L A N C M N . H
//
//  Contents:   Declarations of LAN Connection related functions common
//              to the shell and netman.
//
//  Notes:
//
//  Author:     danielwe   7 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"
#include "netcon.h"
#include "netconp.h"
#include "iptypes.h"

EXTERN_C const CLSID CLSID_LanConnectionManager;

enum OCC_FLAGS
{
    OCCF_NONE                   = 0x0000,
    OCCF_CREATE_IF_NOT_EXIST    = 0x0001,
    OCCF_DELETE_IF_EXIST        = 0x0002,
};

HRESULT HrOpenConnectionKey(const GUID* pguid, PCWSTR pszGuid, REGSAM sam,
                            OCC_FLAGS occFlags, PCWSTR pszPnpId, HKEY *phkey);

HRESULT HrOpenHwConnectionKey(REFGUID guid, REGSAM sam, OCC_FLAGS occFlags,
                              HKEY *phkey);
HRESULT HrIsConnectionNameUnique(REFGUID guidExclude,
                                 PCWSTR szwName);
HRESULT HrPnccFromGuid(INetCfg *pnc, const GUID &refGuid,
                       INetCfgComponent **ppncc);

HRESULT HrIsConnection(INetCfgComponent *pncc);
HRESULT HrGetDeviceGuid(INetConnection *pconn, GUID *pguid);
BOOL FPconnEqualGuid(INetConnection *pconn, REFGUID guid);

HRESULT HrGetPseudoMediaTypeFromConnection(IN REFGUID guidConn, OUT NETCON_SUBMEDIATYPE *pncsm);

inline
BOOL
FIsDeviceFunctioning(ULONG ulProblem)
{
    // ulProblem is returned by calling CM_Get_DevNode_Status_Ex
    // or INetCfgComponent->GetDeviceStatus
    //
    // "Functioning" means the device is enabled and started with
    // no problem codes, or it is disabled and stopped with no
    // problem codes.

    return (ulProblem == 0) || (ulProblem == CM_PROB_DISABLED);
};

EXTERN_C HRESULT WINAPI HrPnpInstanceIdFromGuid(const GUID* pguid,
                                                PWSTR szwInstance,
                                                UINT cchInstance);

EXTERN_C HRESULT WINAPI HrGetPnpDeviceStatus(const GUID* pguid,
                                             NETCON_STATUS *pStatus);
EXTERN_C HRESULT WINAPI HrQueryLanMediaState(const GUID* pguid,
                                             BOOL* pfEnabled);

BOOL FIsMediaPresent(const GUID *pguid);
HRESULT HrGetDevInstStatus(DEVINST devinst, const GUID *pguid,
                           NETCON_STATUS *pStatus);

HRESULT HrGetRegInstanceKeyForAdapter(IN LPGUID pguidId, 
                                      OUT LPWSTR lpszRegInstance);
BOOL HasValidAddress(IN PIP_ADAPTER_INFO pAdapterInfo);
HRESULT HrGetAddressStatusForAdapter(IN LPCGUID pguidAdapter, 
                                     OUT BOOL* pbValidAddress);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncatlui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L U I . H
//
//  Contents:   UI common code relying on ATL.
//
//  Notes:
//
//  Author:     shaunco   13 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATLUI_H_
#define _NCATLUI_H_


NOTHROW
int
WINAPIV
NcMsgBox (
        HWND    hwnd,
        UINT    unIdCaption,
        UINT    unIdFormat,
        UINT    unStyle,
        ...);


#endif // _NCATLUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nameres.h ===
//+---------------------------------------------------------------------------
// Default names
#define IDS_DEFAULT_START                    1800
#define IDS_DEFAULT_VPNName                  IDS_DEFAULT_START + 1
#define IDS_DEFAULT_VPNName_Type             IDS_DEFAULT_START + 2
#define IDS_DEFAULT_PHONEName                IDS_DEFAULT_START + 3
#define IDS_DEFAULT_PHONEName_Type           IDS_DEFAULT_START + 4
#define IDS_DEFAULT_ISDNName                 IDS_DEFAULT_START + 5
#define IDS_DEFAULT_ISDNName_Type            IDS_DEFAULT_START + 6
#define IDS_DEFAULT_PPPOEName                IDS_DEFAULT_START + 7
#define IDS_DEFAULT_PPPOEName_Type           IDS_DEFAULT_START + 8
#define IDS_DEFAULT_IncomingName             IDS_DEFAULT_START + 9
#define IDS_DEFAULT_IncomingName_Type        IDS_DEFAULT_START + 10
#define IDS_DEFAULT_LANName                  IDS_DEFAULT_START + 11
#define IDS_DEFAULT_LANName_Type             IDS_DEFAULT_START + 12
#define IDS_DEFAULT_WirelessName             IDS_DEFAULT_START + 13
#define IDS_DEFAULT_WirelessName_Type        IDS_DEFAULT_START + 14
#define IDS_DEFAULT_BRIDGEName               IDS_DEFAULT_START + 15
#define IDS_DEFAULT_BRIDGEName_Type          IDS_DEFAULT_START + 16
#define IDS_DEFAULT_SAHLANName               IDS_DEFAULT_START + 17
#define IDS_DEFAULT_SAHLANName_Type          IDS_DEFAULT_START + 18
#define IDS_DEFAULT_SAHRASName               IDS_DEFAULT_START + 19
#define IDS_DEFAULT_SAHRASName_Type          IDS_DEFAULT_START + 20
#define IDS_DEFAULT_ATMName                  IDS_DEFAULT_START + 21
#define IDS_DEFAULT_ATMName_Type             IDS_DEFAULT_START + 22
#define IDS_DEFAULT_ELANName                 IDS_DEFAULT_START + 23
#define IDS_DEFAULT_ELANName_Type            IDS_DEFAULT_START + 24
#define IDS_DEFAULT_1394Name                 IDS_DEFAULT_START + 25
#define IDS_DEFAULT_1394Name_Type            IDS_DEFAULT_START + 26
#define IDS_TO_THE_INTERNET                  IDS_DEFAULT_START + 27
#define IDS_ON_THE_HOMENET                   IDS_DEFAULT_START + 28
#define IDS_DEFAULT_DIRECTName               IDS_DEFAULT_START + 29
#define IDS_DEFAULT_DIRECTName_Type          IDS_DEFAULT_START + 30

#define IDS_RESERVED_INCOMING                IDS_DEFAULT_IncomingName
#define IDS_RESERVED_NCW                     IDS_DEFAULT_START + 31
#define IDS_RESERVED_HNW                     IDS_DEFAULT_START + 32
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncatl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L . H
//
//  Contents:   Common code for use with ATL.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   22 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATL_H_
#define _NCATL_H_

#include "ncstring.h"

//
// This file should be included *after* your standard ATL include sequence.
//
//      #include <atlbase.h>
//      extern CComModule _Module;
//      #include <atlcom.h>
//      #include "ncatl.h"      <------
//
// We cannot directly include that sequence here because _Module may be
// derived from CComModule as opposed to an instance of it.
//

class CExceptionSafeComObjectLock
{
public:
    CExceptionSafeComObjectLock (CComObjectRootEx <CComObjectThreadModel>* pObj)
    {
        AssertH (pObj);
        m_pObj = pObj;
        TraceTag (ttidEsLock,
            "Entered critical section object of COM object 0x%08x",
            &m_pObj);
        pObj->Lock ();
    }

    ~CExceptionSafeComObjectLock ()
    {
        TraceTag (ttidEsLock,
            "Leaving critical section object of COM object 0x%08x",
            &m_pObj);

        m_pObj->Unlock ();
    }

protected:
    CComObjectRootEx <CComObjectThreadModel>* m_pObj;
};


//+---------------------------------------------------------------------------
//
//  Function:   HrCopyIUnknownArrayWhileLocked
//
//  Purpose:    Allocate and copy an array of IUnknown pointers from an ATL
//              CComDynamicUnkArray while holding the object which controls
//              the CComDynamicUnkArray locked.  This is needed by objects
//              which dispatch calls on a connection point's advise sink
//              to prevent the CComDynamicUnkArray from being modified (via
//              calls to Advise/Unadvise on other threads) while they are
//              dispatching.  An atomic copy is made so the dispatcher can
//              then make the lengthy callbacks without the need to hold
//              the owner object locked.
//
//  Arguments:
//      pObj  [in]  Pointer to object which has Lock/Unlock methods.
//      pVec  [in]  ATL array of IUnknown's to copy.
//      pcUnk [out] Address of returned count of IUnknown pointerss
//                  in *paUnk.
//      paUnk [out] Address of allocated pointer to the array of IUnknown
//                  pointers.
//
//  Returns:    S_OK or E_OUTOFMEMORY
//
//  Author:     shaunco   3 Dec 1998
//
//  Notes:      The returned count and array may be NULL when no IUnknowns
//              existed in the input array.  S_OK will be returned for this
//              case too, so be sure to check *pcUnk and *paUnk too.
//
inline
HRESULT
HrCopyIUnknownArrayWhileLocked (
    IN  CComObjectRootEx <CComObjectThreadModel>* pObj,
    IN  CComDynamicUnkArray* pVec,
    OUT ULONG* pcpUnk,
    OUT IUnknown*** papUnk)
{
    HRESULT hr = S_OK;
    IUnknown** ppUnkSrc;
    IUnknown** ppUnkDst;

    // Initialize the output parameters.
    //
    *pcpUnk = 0;
    *papUnk = NULL;

    pObj->Lock();

    // First, count the number of IUnknown's we need to copy.
    //
    ULONG cpUnk = 0;
    for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
    {
        if (ppUnkSrc && *ppUnkSrc)
        {
            cpUnk++;
        }
    }

    // Allocate space and copy the IUnknown's.  (Be sure to AddRef them.)
    //
    if (cpUnk)
    {
        hr = E_OUTOFMEMORY;
        ppUnkDst = (IUnknown**)MemAlloc (cpUnk * sizeof(IUnknown*));
        if (ppUnkDst)
        {
            hr = S_OK;

            *pcpUnk = cpUnk;
            *papUnk = ppUnkDst;

            for (ppUnkSrc = pVec->begin(); ppUnkSrc < pVec->end(); ppUnkSrc++)
            {
                if (ppUnkSrc && *ppUnkSrc)
                {
                    *ppUnkDst = *ppUnkSrc;
                    AddRefObj(*ppUnkDst);
                    ppUnkDst++;
                    cpUnk--;
                }
            }

            // We should have copied what we counted.
            //
            AssertH(0 == cpUnk);
        }
    }

    pObj->Unlock();

    TraceHr (ttidError, FAL, hr, FALSE, "HrCopyIUnknownArrayWhileLocked");
    return hr;
}


#define DECLARE_CLASSFACTORY_DEFERRED_SINGLETON(obj) DECLARE_CLASSFACTORY_EX(CComClassFactoryDeferredSingleton<obj>)

//+---------------------------------------------------------------------------
// Deferred Singleton Class Factory
//
template <class T>
class CComClassFactoryDeferredSingleton : public CComClassFactory
{
public:
    CComClassFactoryDeferredSingleton () : m_pObj(NULL) {}
    ~CComClassFactoryDeferredSingleton() { delete m_pObj; }

    // IClassFactory
    STDMETHOD(CreateInstance)(LPUNKNOWN pUnkOuter, REFIID riid, void** ppvObj)
    {
        HRESULT hr = E_POINTER;
        if (ppvObj != NULL)
        {
            // can't ask for anything other than IUnknown when aggregating
            //
            AssertH(!pUnkOuter || InlineIsEqualUnknown(riid));
            if (pUnkOuter && !InlineIsEqualUnknown(riid))
            {
                hr = CLASS_E_NOAGGREGATION;
            }
            else
            {
                // Need to protect m_pObj from being created more than once
                // by multiple threads calling this method simultaneously.
                // (I've seen this happen on multi-proc machines.)
                //
                Lock ();

                if (m_pObj)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    m_pObj = new CComObjectGlobal<T>;
                    if (m_pObj)
                    {
                        hr = m_pObj->m_hResFinalConstruct;
                    }
                }

                Unlock ();

                if (SUCCEEDED(hr))
                {
                    hr = m_pObj->QueryInterface(riid, ppvObj);
                }
            }
        }
        return hr;
    }
    CComObjectGlobal<T>* m_pObj;
};

// We have our own version of AtlModuleRegisterServer coded here
// because the former brings in oleaut32.dll so it can register
// type libraries.  We don't care to have a type library registered
// so we can avoid the whole the mess associated with oleaut32.dll.
//
inline
HRESULT
NcAtlModuleRegisterServer(
    _ATL_MODULE* pM
    )
{
    AssertH (pM);
    AssertH(pM->m_hInst);
    AssertH(pM->m_pObjMap);

    HRESULT hr = S_OK;

    for (_ATL_OBJMAP_ENTRY* pEntry = pM->m_pObjMap;
         pEntry->pclsid;
         pEntry++)
    {
        if (pEntry->pfnGetObjectDescription() != NULL)
        {
            continue;
        }

        hr = pEntry->pfnUpdateRegistry(TRUE);
        if (FAILED(hr))
        {
            break;
        }
    }

    TraceError ("NcAtlModuleRegisterServer", hr);
    return hr;
}

#ifdef __ATLCOM_H__
//+---------------------------------------------------------------------------
//
//  Function:   SzLoadIds
//
//  Purpose:    Loads the given string ID from the resource file.
//
//  Arguments:
//      unId [in]   ID of string resource to load.
//
//  Returns:    Read-only version of resource string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      1) You must be compiling with ATL support to use this function.
//              2) The returned string CANNOT be modified.
//              3) You must compile your RC file with the -N option for this
//                 to work properly.
//
inline
PCWSTR
SzLoadIds (
        UINT    unId)
{
    return SzLoadString (_Module.GetResourceInstance(), unId);
}
#endif  //!__ATLCOM_H__

#endif // _NCATL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncatlps.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C A T L P S . H
//
//  Contents:   Class definition for ATL-like property sheet page object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCATLPS_H_
#define _NCATLPS_H_

#include <prsht.h>

class CPropSheetPage : public CWindow, public CMessageMap
{
public:
    virtual ~CPropSheetPage();

    VOID SetChangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_CHANGED, (WPARAM)m_hWnd, 0);
    }
    VOID SetUnchangedFlag() const
    {
        ::SendMessage(GetParent(), PSM_UNCHANGED, (WPARAM)m_hWnd, 0);
    }

    virtual UINT UCreatePageCallbackHandler()
    {
        return TRUE;
    }

    virtual VOID DestroyPageCallbackHandler() {}


    HPROPSHEETPAGE  CreatePage(UINT unId, DWORD dwFlags,
                               PCWSTR pszHeaderTitle = NULL,
                               PCWSTR pszHeaderSubTitle = NULL,
                               PCWSTR pszTitle = NULL);

    static INT_PTR CALLBACK DialogProc(HWND hWnd, UINT uMsg,
                                       WPARAM wParam, LPARAM lParam);

    static UINT CALLBACK PropSheetPageProc(HWND hWnd, UINT uMsg,
                                           LPPROPSHEETPAGE ppsp);
};

#endif // _NCATLPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nccfgmgr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C C F G M G R.H
//
//  Contents:   Common code useful when using the Configuration Manager APIs.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   6 May 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCCFGMGR_H_
#define _NCCFGMGR_H_

#include "ncdefine.h"   // for NOTHROW

NOTHROW
HRESULT
HrFromConfigManagerError (
    CONFIGRET   cr,
    HRESULT     hrDefault);

#endif // _NCCFGMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C B A S E . H
//
//  Contents:   Basic common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCBASE_H_
#define _NCBASE_H_

#include "ncdefine.h"   // for NOTHROW

#define STACK_SIZE_DEFAULT  0

#ifdef DBG // Debug builds require larger stack commit sizes due to tracing
#define STACK_SIZE_TINY     65536
#define STACK_SIZE_SMALL    98304
#else
#define STACK_SIZE_TINY     32768
#define STACK_SIZE_SMALL    65536
#endif

#define STACK_SIZE_COMPACT  262144
#define STACK_SIZE_LARGE    1048576
#define STACK_SIZE_HUGE     5242880

NOTHROW
ULONG
AddRefObj (
    IUnknown* punk);

NOTHROW
ULONG
ReleaseObj (
    IUnknown* punk);


NOTHROW
DWORD
DwWin32ErrorFromHr (
    HRESULT hr);


inline
BOOL
FDwordWithinRange (
    DWORD   dwLower,
    DWORD   dw,
    DWORD   dwUpper)
{
    return ((dw >= dwLower) && (dw <= dwUpper));
}


NOTHROW
HRESULT
HrFromLastWin32Error ();


HRESULT
HrGetProcAddress (
    HMODULE     hModule,
    PCSTR       pszaFunction,
    FARPROC*    ppfn);

HRESULT
HrLoadLibAndGetProcs (
    PCWSTR          pszLibPath,
    UINT            cFunctions,
    const PCSTR*    apszaFunctionNames,
    HMODULE*        phmod,
    FARPROC*        apfn);

inline
HRESULT
HrLoadLibAndGetProc (
    PCWSTR      pszLibPath,
    PCSTR       pszaFunctionName,
    HMODULE*    phmod,
    FARPROC*    ppfn)
{
    return HrLoadLibAndGetProcs (pszLibPath, 1, &pszaFunctionName, phmod, ppfn);
}

HRESULT
__cdecl
HrGetProcAddressesV(
    HMODULE hModule, ...);

HRESULT
__cdecl
HrLoadLibAndGetProcsV(
    PCWSTR      pszLibPath,
    HMODULE*    phModule,
    ...);

HRESULT
HrCreateEventWithWorldAccess(PCWSTR pszName, BOOL fManualReset,
        BOOL fInitialState, BOOL* pfAlreadyExists, HANDLE* phEvent);

HRESULT
HrCreateMutexWithWorldAccess(PCWSTR pszName, BOOL fInitialOwner,
        BOOL* pfAlreadyExists, HANDLE* phMutex);

HRESULT
HrCreateInstanceBase (REFCLSID rclsid, DWORD dwClsContext, REFIID riid, LPVOID * ppv);

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateInstance
//
//  Purpose:    Creates a COM object and sets default proxy settings.
//
//  Arguments:
//      rclsid          [in]  See documentation for CoCreateInstance.
//      dwClsContext    [in]  ""
//      ppInter         [out] Typed interface pointer using templates.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
template <class Inter>
inline HRESULT
HrCreateInstance (
    REFCLSID rclsid,
    DWORD dwClsContext,
    Inter ** ppInter)
{
    return HrCreateInstanceBase(rclsid, dwClsContext, __uuidof(Inter), reinterpret_cast<void**>(ppInter));
}

HRESULT
HrQIAndSetProxyBlanketBase(IUnknown * pUnk, REFIID riid, void ** ppv);

//+---------------------------------------------------------------------------
//
//  Function:   HrQIAndSetProxyBlanket
//
//  Purpose:    Performs QueryInterface and sets default proxy settings.
//
//  Arguments:
//      pUnk            [in]  Interface pointer to perform QueryInterface on.
//      ppInter         [out] Typed interface pointer using templates.
//
//  Returns:    S_OK on success. An error code otherwise.
//
//  Author:     mbend   1 Mar 2000
//
template <class Inter>
inline HRESULT
HrQIAndSetProxyBlanket (
    IUnknown * pUnk,
    Inter ** ppInter)
{
    return HrQIAndSetProxyBlanketBase(pUnk, __uuidof(Inter), reinterpret_cast<void**>(ppInter));
}


#endif // _NCBASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nceh.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C E H . H
//
//  Contents:   Exception handling stuff.
//
//  Notes:
//
//  Author:     shaunco   27 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

// NC_TRY and NC_CATCH_ALL are #defined to allow easy replacement.  This
// is handy when evaulating SEH (__try, __except) vs. C++ EH (try, catch).
//
#define NC_TRY                  try 
#define NC_CATCH_NC_EXCEPTION   catch (SE_Exception)
#define NC_CATCH_BAD_ALLOC      catch (std::bad_alloc)
#define NC_CATCH_STD            catch (std::exception)
#define NC_CATCH_ALL            catch (...)
/*
#define NC_FINALLY              
*/

class SE_Exception
{
private:
    unsigned int m_nSE;
public:
    SE_Exception(unsigned int nSE) : m_nSE(nSE) {}
    SE_Exception() : m_nSE(0) {}
    ~SE_Exception() {}
    unsigned int getSeNumber() { return m_nSE; }
};

void __cdecl nc_trans_func( unsigned int uSECode, EXCEPTION_POINTERS* pExp );
void EnableCPPExceptionHandling();
void DisableCPPExceptionHandling();

// For DEBUG builds, don't catch anything.  This allows the debugger to locate
// the exact source of the exception.

/*
#ifdef DBG
*/

#define COM_PROTECT_TRY

#define COM_PROTECT_CATCH   ;

/*
#else // DBG

#define COM_PROTECT_TRY     __try

#define COM_PROTECT_CATCH   \
    __except (EXCEPTION_EXECUTE_HANDLER ) \
    { \
        hr = E_UNEXPECTED; \
    }

#endif // DBG
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nccom.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C C O M . H
//
//  Contents:   Common routines for dealing with COM.
//
//  Notes:
//
//  Author:     shaunco   25 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCCOM_H_
#define _NCCOM_H_

#include "ncdefine.h"   // for NOTHROW

HRESULT
HrCoTaskMemAlloc (
    ULONG   cb,
    VOID**  ppv);

HRESULT
HrCoTaskMemAllocAndDupSzLen (
    IN PCWSTR pszwSrc,
    IN ULONG cchSrc,
    OUT PWSTR* ppszwDst,
    IN ULONG cchMaxDest);

HRESULT
HrCoTaskMemAllocAndDupSz (
    IN  PCWSTR pszwSrc,
    OUT PWSTR* ppszwDst,
    IN  ULONG cchMaxDest);

VOID
NcSetProxyBlanket (
    IN IUnknown* pUnk);

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseIUnknownArray
//
//  Purpose:    Releases an array of IUnknown pointers.
//
//  Arguments:
//      cpunk [in]  count of pointers to release
//      apunk [in]  array of pointers to release
//
//  Returns:    Nothing
//
//  Author:     shaunco   23 Mar 1997
//
//  Notes:      Any of the pointers in the array can be NULL.
//
inline
NOTHROW
VOID
ReleaseIUnknownArray (
    ULONG       cpunk,
    IUnknown**  apunk)
{
    AssertH (apunk);

    while (cpunk--)
    {
        ReleaseObj (*apunk);
        apunk++;
    }
}

//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumIUnknown
//
//  Tenum is of type IEnumXXX (the enumeration interface)
//  Telt is of type XXX (the type of the element being enumerated)
//
//  HrNext(Telt* pelt) retreives next interface pointer and returns S_OK
//  if it is non-null.  S_FALSE is returned if *pelt is null (at end of list).
//  An error code will be returned for other failures (and *pelt will be
//  null of course.)
//
template <class Tenum, class Telt>
class CIEnumIter : CNetCfgDebug<CIEnumIter<Tenum, Telt> >
{
public:
    NOTHROW CIEnumIter (Tenum* penum);
    NOTHROW ~CIEnumIter () { ReleaseRemainingBatch (); }

    NOTHROW HRESULT HrNext(Telt* pelt);
    NOTHROW VOID    SetEnumerator(Tenum* penum)
                { AssertSzH(!m_penum, "Enumerator already set.");
                  m_penum = penum;
                  AssertSzH(m_penum, "Can't use a null enumerator."); }

protected:
    NOTHROW VOID ReleaseRemainingBatch ();

    Tenum*  m_penum;        // pointer to the enumerator.  not addref'd.
    Telt*   m_aelt;         // array of enumerated types.
    Telt*   m_peltNext;     // pointer to next type to be returned.
    ULONG   m_celtFetched;  // number of elements fetched.
    HRESULT m_hrLast;       // last error
};


//------------------------------------------------------------------------
// CIEnumIter - template iterator for IEnumXXX
//
template <class Tenum, class Telt>
inline CIEnumIter<Tenum, Telt>::CIEnumIter(Tenum* penum)
{
    m_penum         = penum;
    m_aelt          = NULL;
    m_peltNext      = NULL;
    m_celtFetched   = NULL;
    m_hrLast        = S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIEnumIter<Tenum, Telt>::HrNext
//
//  Purpose:    Returns the next item in the enumeration.
//
//  Arguments:
//      pelt [out]  Pointer to the returned elemnt.  Null if not available.
//
//  Returns:    S_OK if *pelt is valid.  S_FALSE if it is NULL.  Error
//              otherwise.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:
//
template <class Tenum, class Telt>
inline NOTHROW HRESULT CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt)
{
    AssertH(pelt);

    const ULONG c_celtBatch = 256;

    // If we failed for any reason before, return that failure.
    //
    if (FAILED(m_hrLast))
    {
        *pelt = NULL;
        goto error;
    }

    AssertSzH(m_penum, "m_penum is null.  Did you forget to call SetEnumerator()?");
    AssertSzH(c_celtBatch, "c_celtBatch can't be zero.");

    // If we already have the next interface pointer, and we're
    // not at the end of the batch, return it and advance.
    // This if should be caught most of the time.
    //
    if (m_peltNext && (m_peltNext < m_aelt + m_celtFetched))
    {
        *pelt = *m_peltNext;
        m_peltNext++;
    }

    // Otherwise, if we don't have the next interface pointer (first time),
    // or we're at the end of the batch, get the next batch and return
    // the first pointer in it.
    // This if should be caught the first time through.
    //
    else if (!m_peltNext || (m_celtFetched == c_celtBatch))
    {
        // Indicate that m_peltNext is invalid.
        //
        m_peltNext = NULL;

        // Free the old block of pointers
        MemFree(m_aelt);

        // Allocate the next block of pointers
        m_aelt = reinterpret_cast<Telt *>(MemAlloc(c_celtBatch * sizeof(Telt *)));
        if (!m_aelt)
        {
            *pelt = NULL;
            m_hrLast = E_OUTOFMEMORY;
            goto error;
        }

        AssertH (m_aelt);

        // Get the next batch.
        //
        m_hrLast = m_penum->Next(c_celtBatch, m_aelt, &m_celtFetched);

        // Make sure the implementor of Next is obeying the rules.
        AssertH (FImplies((S_OK == m_hrLast), (m_celtFetched == c_celtBatch)));
        AssertH (FImplies((SUCCEEDED(m_hrLast) && (0 == m_celtFetched)), (NULL == *m_aelt)));

        // If we were successful, set the next pointer and return
        // S_OK if we returned a valid pointer or S_FALSE if we
        // returned NULL.
        //
        if (SUCCEEDED(m_hrLast))
        {
            m_peltNext = m_aelt + 1;
            if (m_celtFetched)
            {
                *pelt = *m_aelt;
                m_hrLast = S_OK;
            }
            else
            {
                *pelt = NULL;
                m_hrLast = S_FALSE;
            }
        }
        else
        {
            *pelt = NULL;
        }
    }

    // Otherwise we've completely iterated the last batch and there are
    // no more batches.
    //
    else
    {
        AssertH(m_peltNext >= m_aelt + m_celtFetched);
        AssertH(m_celtFetched != c_celtBatch);

        *pelt = NULL;
        m_hrLast = S_FALSE;
    }

error:
    AssertH(FIff(S_OK == m_hrLast, NULL != *pelt));
    AssertH(FImplies(S_FALSE == m_hrLast, NULL == *pelt));

    TraceError("CIEnumIter<Tenum, Telt>::HrNext(Telt* pelt)",
               (S_FALSE == m_hrLast) ? S_OK : m_hrLast);
    return m_hrLast;
}

template <class Tenum, class Telt>
inline NOTHROW VOID CIEnumIter<Tenum, Telt>::ReleaseRemainingBatch ()
{
    // This needs to be run if the user doesn't completely iterate the
    // batch.  Finish releasing the interface pointers and free the batch.
    //
    if (m_peltNext && m_aelt)
    {
        while (m_peltNext < m_aelt + m_celtFetched)
        {
            ReleaseObj (*m_peltNext);
            m_peltNext++;
        }

        MemFree (m_aelt);
    }

    // If this method is ever called from anywhere other than just
    // the destructor, uncomment the following lines.
    // m_peltNext = NULL;
    // m_aelt = NULL;
}


#endif // _NCCOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncdefine.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N C D E F I N E . H
//
//  Contents:   Very generic defines for netcfg. Don't throw non-generic crap
//              in here! No iterators for NetCfgBindingPaths, etc. etc.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     jeffspr   20 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEFINE_H_
#define _NCDEFINE_H_

#define BEGIN_CONST_SECTION     data_seg(".rdata")
#define END_CONST_SECTION       data_seg()

#define celems(_x)          (sizeof(_x) / sizeof(_x[0]))

#ifdef NOTHROW
#undef NOTHROW
#endif
#define NOTHROW __declspec(nothrow)

// Defines for C source files including us.
//
#ifndef __cplusplus
#ifndef inline
#define inline  __inline
#endif
#endif


// Generic flags used when inserting elements into collections.
//
enum INS_FLAGS
{
    INS_ASSERT_IF_DUP   = 0x00000100,
    INS_IGNORE_IF_DUP   = 0x00000200,
    INS_APPEND          = 0x00000400,
    INS_INSERT          = 0x00000800,
    INS_SORTED          = 0x00001000,
    INS_NON_SORTED      = 0x00002000,
};


#endif // _NCDEFINE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncexcept.h ===
#define NETCFG_TRY try {
#define NETCFG_CATCH(hr) ; }  \
    catch (SE_Exception e) \
    { \
        hr = HRESULT_FROM_WIN32(e.getSeNumber()); \
        TraceException(hr, "SE_Exception"); \
    } \
    catch (std::bad_alloc a) \
    { \
        hr = E_OUTOFMEMORY; \
        TraceException(hr, "std::bad_alloc"); \
    } \
    catch (std::exception s) \
    { \
        hr = E_FAIL; \
        TraceException(hr, "std::exception"); \
    } \
    catch (HRESULT hrCaught) \
    { \
        hr = hrCaught; \
        TraceException(hr, "HRESULT"); \
    }
    
#define NETCFG_CATCH_NOHR ; } \
    catch (SE_Exception e) \
    { \
        TraceException(E_FAIL, "SE_Exception"); \
    } \
    catch (std::bad_alloc a) \
    { \
        TraceException(E_FAIL, "std::bad_alloc"); \
    } \
    catch (std::exception s) \
    { \
        TraceException(E_FAIL, "std::exception"); \
    } \
    catch (HRESULT hrCaught) \
    { \
        TraceException(E_FAIL, "HRESULT"); \
    }
    
#define NETCFG_CATCH_AND_RETHROW ; }  \
    catch (...) \
    { \
        TraceException(E_FAIL, "..."); \
        throw; \
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncerror.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C E R R O R . H
//
//  Contents:   NetCfg specific error codes.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCERROR_H_
#define _NCERROR_H_

#include <winerror.h>

//
// Error codes are arbitrarily numbered starting at A000.
//

const HRESULT NETSETUP_E_ANS_FILE_ERROR         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA002);
const HRESULT NETSETUP_E_NO_ANSWERFILE          = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA003);
const HRESULT NETSETUP_E_NO_EXACT_MATCH         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA004);
const HRESULT NETSETUP_E_AMBIGUOUS_MATCH        = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA005);

//
// error codes (A020 - A040) reserved for netcfg.dll
//

const HRESULT NETCFG_E_PSNRET_INVALID       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA041);
const HRESULT NETCFG_E_PSNRET_INVALID_NCPAGE= MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA042);

//
// Primarily join domain error codes but a few have crept into general use.
//
// Specifically: NETCFG_E_NAME_IN_USE and NETCFG_E_NOT_JOINED
//

const HRESULT NETCFG_E_ALREADY_JOINED       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA050);
const HRESULT NETCFG_E_NAME_IN_USE          = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA051);
const HRESULT NETCFG_E_NOT_JOINED           = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA052);
const HRESULT NETCFG_E_MACHINE_IS_DC        = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA053);
const HRESULT NETCFG_E_NOT_A_SERVER         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA054);
const HRESULT NETCFG_E_INVALID_ROLE         = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA055);
const HRESULT NETCFG_E_INVALID_DOMAIN       = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0xA056);

#endif // _NCERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncdebug.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C D E B U G . H
//
//  Contents:   Debug routines.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCDEBUG_H_
#define _NCDEBUG_H_

#include "dbgflags.h"       // For debugflags id definitions
#include "trace.h"

NOTHROW void InitializeDebugging (BOOL bDisableFaultInjection = TRUE);
NOTHROW void UnInitializeDebugging ();


//
//  Useful macros to use with Asserts.
//  Eg,     Assert(FImplies(sz, !*sz));
//          Assert(FIff(sz, cch));
//
#define FImplies(a,b)       (!(a) || (b))
#define FIff(a,b)           (!(a) == !(b))


//
//  "Normal" assertion checking.  Provided for compatibility with
//  imported code.
//
//      Assert(a)       Displays a message indicating the file and line number
//                      of this Assert() if a == 0.
//      AssertSz(a,b)   As Assert(); also displays the message b (which should
//                      be a string literal.)
//      SideAssert(a)   As Assert(); the expression a is evaluated even if
//                      asserts are disabled.
//
#undef AssertSz
#undef Assert


//+---------------------------------------------------------------------------
//
// DBG (checked) build
//
#ifdef DBG

VOID
DbgCheckPrematureDllUnload (
    PCSTR pszaDllName,
    UINT ModuleLockCount);

typedef VOID     (CALLBACK * PFNASSERTHOOK)(PCSTR, PCSTR, int);
VOID    WINAPI   SetAssertFn             (PFNASSERTHOOK);
BOOL    WINAPI   FInAssert               (VOID);
VOID    WINAPI   AssertSzFn              (PCSTR pszaMsg, PCSTR pszaFile, int nLine);
VOID    WINAPI   AssertSzFn              (PCSTR pszaMsg, PCSTR pszaFile, int nLine, PCSTR pszaFunc);
VOID    WINAPI   AssertSzFnWithDbgPrompt (BOOL fPromptIgnore, PCSTR pszaMsg, PCSTR pszaFile, int nLine, PCSTR pszaFunc);
VOID    CALLBACK DefAssertSzFn           (PCSTR pszaMsg, PCSTR pszaFile, int nLine);

#define Assert(a)       AssertSz(a, "Assert(" #a ")\r\n")
#define AssertSz(a,b)   if (!(a)) AssertSzFn(b, __FILE__, __LINE__);
#define AssertSzWithDbgPromptIgnore(a,b) if (!(a)) AssertSzFnWithDbgPrompt(TRUE, b, __FILE__, __LINE__, __FUNCTION__);
#define AssertSzWithDbgPromptRetry(a,b) if (!(a)) AssertSzFnWithDbgPrompt(FALSE, b, __FILE__, __LINE__, __FUNCTION__);

//#define Assert(exp)       if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, NULL)
//#define AssertSz(exp,msg) if (!(exp)) RtlAssert(#exp, __FILE__, __LINE__, msg)

#define AssertH         Assert
#define AssertSzH       AssertSz

void WINAPIV AssertFmt(BOOL fExp, PCSTR pszaFile, int nLine, PCSTR pszaFmt, ...);

#define AssertValidReadPtrSz(p,msg)     AssertSz(!IsBadReadPtr(p, sizeof(*p)),  msg)
#define AssertValidWritePtrSz(p,msg)    AssertSz(!IsBadWritePtr(p, sizeof(*p)), msg)
#define AssertValidReadPtr(p)           AssertValidReadPtrSz(p,"Bad read pointer:" #p)
#define AssertValidWritePtr(p)          AssertValidWritePtrSz(p,"Bad write pointer:" #p)

#define SideAssert(a)                   Assert(a)
#define SideAssertH(a)                  AssertH(a)
#define SideAssertSz(a,b)               AssertSz(a,b)
#define SideAssertSzH(a,b)              AssertSzH(a,b)
#define NYI(a)                          AssertSz(FALSE, "NYI: " a)
#define NYIH(a)                         AssertSzH(FALSE, "NYI: " a)


//+---------------------------------------------------------------------------
//
// !DBG (retail) build
//
#else

#define DbgCheckPrematureDllUnload(a,b) NOP_FUNCTION

#define AssertH(a)
#define AssertSzH(a,b)
#define Assert(a)
#define AssertSz(a,b)
#define AssertSzWithDbgPrompt(a,b)
#define AssertFmt                       NOP_FUNCTION
#define AssertValidReadPtrSz(p,msg)     NOP_FUNCTION
#define AssertValidWritePtrSz(p,msg)    NOP_FUNCTION
#define AssertValidReadPtr(p)           NOP_FUNCTION
#define AssertValidWritePtr(p)          NOP_FUNCTION

#define SideAssert(a)                   (a)
#define SideAssertH(a)                  (a)
#define SideAssertSz(a,b)               (a)
#define SideAssertSzH(a,b)              (a)
#define NYI(a)                          NOP_FUNCTION

#endif  // DBG


#endif // _NCDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncinf.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I N F . H
//
//  Contents:   ???
//
//  Notes:
//
//  Author:     ???
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCINF_H_
#define _NCINF_H_

typedef HRESULT (CALLBACK *PFNADDCALLBACK)      (HINF hinf, PCWSTR pszSection);
typedef HRESULT (CALLBACK *PFNREMOVECALLBACK)   (HINF hinf, PCWSTR pszSection);
typedef HRESULT (CALLBACK *PFNHRENTRYPOINT)     (PCWSTR, LPGUID);

HRESULT
HrProcessInfExtension (
    HINF                hinfInstallFile,
    PCWSTR              pszSectionName,
    PCWSTR              pszSuffix,
    PCWSTR              pszAddLabel,
    PCWSTR              pszRemoveLabel,
    PFNADDCALLBACK      pfnHrAdd,
    PFNREMOVECALLBACK   pfnHrRemove);

#endif //_NCINF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncipaddr.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C I P A D D R . H
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   11 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCIPADDR_H_
#define _NCIPADDR_H_

VOID
IpHostAddrToPsz(
    IN  DWORD   dwAddr,
    OUT PWSTR   pszBuffer);

DWORD
IpPszToHostAddr(
    IN  PCWSTR pszAddr);


#endif // _NCIPADDR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncmsz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M S Z . H
//
//  Contents:   Common multi-sz routines.
//
//  Notes:      Split out from ncstring.h and included by ncstring.h
//
//  Author:     shaunco   7 Jun 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMSZ_H_
#define _NCMSZ_H_

ULONG
CchOfMultiSzSafe (
    IN PCWSTR pmsz);

ULONG
CchOfMultiSzAndTermSafe (
    IN PCWSTR pmsz);

inline ULONG
CbOfMultiSzAndTermSafe (
    IN PCWSTR pmsz)
{
    return CchOfMultiSzAndTermSafe (pmsz) * sizeof(WCHAR);
}


BOOL
FGetSzPositionInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz,
    OUT DWORD* pdwIndex,
    OUT BOOL *pfDuplicatePresent,
    OUT DWORD* pcStrings);

BOOL
FIsSzInMultiSzSafe (
    IN PCWSTR psz,
    IN PCWSTR pmsz);

// flags for HrAddSzToMultiSz and RemoveSzFromMultiSz
const   DWORD   STRING_FLAG_ALLOW_DUPLICATES       =   0x00000001;
const   DWORD   STRING_FLAG_ENSURE_AT_FRONT        =   0x00000002;
const   DWORD   STRING_FLAG_ENSURE_AT_END          =   0x00000004;
const   DWORD   STRING_FLAG_ENSURE_AT_INDEX        =   0x00000008;
const   DWORD   STRING_FLAG_DONT_MODIFY_IF_PRESENT =   0x00000010;
const   DWORD   STRING_FLAG_REMOVE_SINGLE          =   0x00000020;
const   DWORD   STRING_FLAG_REMOVE_ALL             =   0x00000040;

HRESULT
HrAddSzToMultiSz (
    IN PCWSTR pszAddString,
    IN PCWSTR pmszIn,
    IN DWORD dwFlags,
    IN DWORD dwStringIndex,
    OUT PWSTR* ppmszOut,
    OUT BOOL* pfChanged);


HRESULT
HrCreateArrayOfStringPointersIntoMultiSz (
    IN PCWSTR     pmszSrc,
    OUT UINT*       pcStrings,
    OUT PCWSTR**   papsz);

VOID
RemoveSzFromMultiSz (
    IN PCWSTR psz,
    IN OUT PWSTR  pmsz,
    IN DWORD   dwFlags,
    OUT BOOL*   pfRemoved);

VOID
SzListToMultiSz (
    IN PCWSTR psz,
    OUT DWORD*  pcb,
    OUT PWSTR* ppszOut);


#endif // _NCMSZ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncnetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:
//
//  Contents:   Common routines for dealing with INetCfg interfaces.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCNETCFG_H_
#define _NCNETCFG_H_

#include "ncbase.h"
#include "nccom.h"
#include "ncstring.h"
#include "netcfgp.h"
#include "netcfgx.h"


BOOL
FClassGuidFromComponentId (
    PCWSTR          pszComponentId,
    const GUID**    ppguidClass);

BOOL
FInfFileFromComponentId (
    PCWSTR    pszComponentId,
    PWSTR     pszInfFile);

//+---------------------------------------------------------------------------
//
//  Function:   FEqualComponentId
//
//  Purpose:    Compares 2 components IDs to see if they are equal.
//
//  Arguments:
//      pszComp1 [in]    Name of first component ID.
//      pszComp2 [in]    Name of second compoennt ID.
//
//  Returns:    TRUE if component IDs are equal, FALSE if not.
//
//  Author:     danielwe   9 Apr 1997
//
//  Notes:      Current comparison is case-INSENSITIVE
//
inline
FEqualComponentId (
    PCWSTR pszComp1,
    PCWSTR pszComp2)
{
    return !lstrcmpiW(pszComp1, pszComp2);
}

BOOL
FGetInstanceGuidOfComponentFromAnswerFileMap (
    IN  PCWSTR  pszComponentId,
    OUT GUID*   pguid);

BOOL
FGetInstanceGuidOfComponentInAnswerFile (
    PCWSTR      pszComponentId,
    INetCfg*    pnc,
    LPGUID      pguid);

enum FIBN_FLAGS
{
    FIBN_NORMAL = 0x00000000,
    FIBN_PREFIX = 0x00000001
};
BOOL
FIsBindingName (
    PCWSTR                      pszName,
    DWORD                       dwFlags,
    INetCfgBindingInterface*    pncbi);


BOOL
FIsComponentId (
    PCWSTR              pszComponentId,
    INetCfgComponent*   pncc);


struct NETWORK_INSTALL_PARAMS
{
    DWORD   dwSetupFlags;
    DWORD   dwUpgradeFromBuildNo;
    PCWSTR  pszAnswerFile;
    PCWSTR  pszAnswerSection;
};


struct FILTER_INSTALL_PARAMS
{
    void *      pnccAdapter;
    void *      pnccFilter;
    tstring *   pstrInterface;
};

enum ARA_FLAGS
{
    ARA_ADD             = 0x01,
    ARA_REMOVE          = 0x02,
};
HRESULT
HrAddOrRemoveAdapter (
    INetCfg*            pnc,
    PCWSTR              pszComponentId,
    DWORD               dwFlags,
    OBO_TOKEN*          pOboToken,
    UINT                cInstances,
    INetCfgComponent**  ppncc);


HRESULT
HrCreateAndInitializeINetCfg (
    BOOL*       pfInitCom,
    INetCfg**   ppnc,
    BOOL        fGetWriteLock,
    DWORD       cmsTimeout,
    PCWSTR     pszwClientDesc,
    PWSTR*     ppszwClientDesc);

HRESULT
HrFindAndRemoveAllInstancesOfAdapter (
    INetCfg*    pnc,
    PCWSTR     pszwComponentId);

HRESULT
HrFindAndRemoveAllInstancesOfAdapters (
    INetCfg*        pnc,
    ULONG           cComponents,
    const PCWSTR*  apszwComponentId);

HRESULT
HrFindAndRemoveComponent (
    INetCfg*    pnc,
    const GUID* pguidClass,
    PCWSTR     pszwComponentId,
    OBO_TOKEN*  pOboToken);

HRESULT
HrFindAndRemoveComponents (
    INetCfg*        pnc,
    ULONG           cComponents,
    const GUID**    apguidClass,
    const PCWSTR*  apszwComponentId,
    OBO_TOKEN*      pOboToken);

HRESULT
HrFindAndRemoveComponentsOboComponent (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId,
    INetCfgComponent*   pnccObo);

HRESULT
HrFindAndRemoveComponentsOboUser (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId);


HRESULT
HrFindComponents (
    INetCfg*            pnc,
    ULONG               cComponents,
    const GUID**        apguidClass,
    const PCWSTR*      apszwComponentId,
    INetCfgComponent**  apncc);


HRESULT
HrGetBindingInterfaceComponents (
    INetCfgBindingInterface*    pncbi,
    INetCfgComponent**          ppnccUpper,
    INetCfgComponent**          ppnccLower);


HRESULT
HrGetLastComponentAndInterface (
    INetCfgBindingPath* pncbp,
    INetCfgComponent**  ppncc,
    PWSTR*             ppszwInterfaceName);


HRESULT
HrInstallComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID*                     pguidClass,
    PCWSTR                         pszwComponentId,
    OBO_TOKEN*                      pOboToken,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponents (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId,
    OBO_TOKEN*                      pOboToken);

HRESULT
HrInstallComponentsOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId,
    INetCfgComponent*               pnccObo);

HRESULT
HrInstallComponentsOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    ULONG                           cComponents,
    const GUID**                    apguidClass,
    const PCWSTR*                  apszwComponentId);

HRESULT
HrInstallComponentOboComponent (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    INetCfgComponent*               pnccObo,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponentOboSoftware(
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    PCWSTR                         pszwManufacturer,
    PCWSTR                         pszwProduct,
    PCWSTR                         pszwDisplayName,
    INetCfgComponent**              ppncc);

HRESULT
HrInstallComponentOboUser (
    INetCfg*                        pnc,
    const NETWORK_INSTALL_PARAMS*   pnip,
    const GUID&                     rguidClass,
    PCWSTR                         pszwComponentId,
    INetCfgComponent**              ppncc);


HRESULT
HrInstallRasIfNeeded (
    INetCfg*    pnc);


HRESULT
HrIsLanCapableAdapter (
    INetCfgComponent*   pncc);

HRESULT
HrIsLanCapableProtocol (
    INetCfgComponent*   pncc);

HRESULT
HrQueryNotifyObject (
    INetCfgComponent*   pncc,
    REFIID              riid,
    VOID**              ppvObject);

HRESULT
HrRemoveComponent (
    INetCfg*            pnc,
    INetCfgComponent*   pnccToRemove,
    OBO_TOKEN*          pOboToken,
    PWSTR *            pmszwRefs);

HRESULT
HrRemoveComponentOboComponent (
    INetCfg*            pnc,
    const GUID&         rguidClass,
    PCWSTR             pszwComponentId,
    INetCfgComponent*   pnccObo);

HRESULT
HrRemoveComponentOboSoftware (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszwComponentId,
    PCWSTR     pszwManufacturer,
    PCWSTR     pszwProduct,
    PCWSTR     pszwDisplayName);

HRESULT
HrRemoveComponentOboUser (
    INetCfg*    pnc,
    const GUID& rguidClass,
    PCWSTR     pszwComponentId);


HRESULT
HrUninitializeAndReleaseINetCfg (
    BOOL        fUninitCom,
    INetCfg*    pnc,
    BOOL        fHasLock = FALSE);

HRESULT
HrUninitializeAndUnlockINetCfg (
    INetCfg*    pnc);

HRESULT
HrRunWinsock2Migration();

HRESULT
HrNcRemoveComponent(INetCfg* pinc, const GUID& guidClass,
                    PCWSTR pszInstanceGuid);

EXTERN_C
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    IN INetCfg* pINetCfg,
    IN INetCfgInternalSetup* pInternalSetup,
    IN const NIQ_INFO* pInfo);

EXTERN_C
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection);


HRESULT
HrNcRegCreateComponentNetworkKeyForDevice(const GUID& guidClass, HKEY* phkey,
                                          PCWSTR pszInstanceGuid,
                                          PCWSTR pszPnpId);
HRESULT
HrNcRegCreateComponentNetworkKey(const GUID& guidClass, PHKEY phkeyComponent,
                                 PCWSTR pszInstanceGuid);

HRESULT
HrNcNotifyINetCfgAndConnectionWizardOfInstallation(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR pszPnpId,
    IN const GUID& InstanceGuid,
    IN NC_INSTALL_TYPE eType);

HRESULT
HrNcNotifyINetCfgAndConnectionWizardOfInstallation(HDEVINFO hdi,
        PSP_DEVINFO_DATA pdeid, PCWSTR pszwPnpId, PCWSTR pszInstanceGuid,
        NC_INSTALL_TYPE eType);

HRESULT
HrNcNotifyINetCfgOfRemoval(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                           PCWSTR pszwInstanceGuid);


struct COMPONENT_INFO
{
    PCWSTR         pszComponentId;
    const GUID *   pguidClass;
    PCWSTR         pszInfFile;
};

extern const COMPONENT_INFO*
PComponentInfoFromComponentId (
    PCWSTR pszComponentId);


//------------------------------------------------------------------------
// CIterNetCfgBindingPath - iterator for IEnumNetCfgBindingPath
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgComponent::EnumBindingPaths to get the enumerator.
//
class CIterNetCfgBindingPath : public CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*>
{
public:
    NOTHROW CIterNetCfgBindingPath (INetCfgComponent* pncc);
    NOTHROW ~CIterNetCfgBindingPath ()  { ReleaseObj(m_pebp); }

protected:
    IEnumNetCfgBindingPath* m_pebp;
};

//------------------------------------------------------------------------
// CIterNetCfgUpperBindingPath - iterator for IEnumNetCfgBindingPath
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgComponent::EnumUpperBindingPaths to get the enumerator.
//
class CIterNetCfgUpperBindingPath : public CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*>
{
public:
    NOTHROW CIterNetCfgUpperBindingPath (INetCfgComponent* pncc);
    NOTHROW ~CIterNetCfgUpperBindingPath () { ReleaseObj(m_pebp); }

protected:
    IEnumNetCfgBindingPath* m_pebp;
};


//------------------------------------------------------------------------
// CIterNetCfgBindingInterface - iterator for IEnumNetCfgBindingInterface
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgBindingPath::EnumBindingInterfaces to get the enumerator.
//
class CIterNetCfgBindingInterface : public CIEnumIter<IEnumNetCfgBindingInterface, INetCfgBindingInterface*>
{
public:
    NOTHROW CIterNetCfgBindingInterface (INetCfgBindingPath* pncbp);
    NOTHROW ~CIterNetCfgBindingInterface () { ReleaseObj(m_pebi); }

protected:
    IEnumNetCfgBindingInterface* m_pebi;
};


//------------------------------------------------------------------------
// CIterNetCfgComponent - iterator for IEnumNetCfgComponent
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetCfgClass::EnumComponents to get the enumerator.
//
class CIterNetCfgComponent : public CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*>
{
public:
    NOTHROW CIterNetCfgComponent (INetCfg* pnc, const GUID* pguid);
    NOTHROW CIterNetCfgComponent (INetCfgClass* pncclass);
    NOTHROW ~CIterNetCfgComponent () { ReleaseObj(m_pec); }

protected:
    IEnumNetCfgComponent* m_pec;
};

inline NOTHROW CIterNetCfgBindingPath::CIterNetCfgBindingPath(INetCfgComponent* pncc)
    : CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*> (NULL)
{
    AssertH(pncc);
    INetCfgComponentBindings* pnccb;

    // If EnumBindingPaths() fails, make sure ReleaseObj() won't die.
    m_pebp = NULL;

    m_hrLast = pncc->QueryInterface( IID_INetCfgComponentBindings, reinterpret_cast<LPVOID *>(&pnccb) );
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pnccb->EnumBindingPaths(EBP_BELOW, &m_pebp);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pebp);
        }
        ReleaseObj( pnccb );
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgBindingPath::CIterNetCfgBindingPath");
}

inline NOTHROW CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath(INetCfgComponent* pncc)
    : CIEnumIter<IEnumNetCfgBindingPath, INetCfgBindingPath*> (NULL)
{
    AssertH(pncc);
    INetCfgComponentBindings* pnccb;

    // If EnumBindingPaths() fails, make sure ReleaseObj() won't die.
    m_pebp = NULL;

    m_hrLast = pncc->QueryInterface( IID_INetCfgComponentBindings, reinterpret_cast<LPVOID *>(&pnccb) );
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pnccb->EnumBindingPaths(EBP_ABOVE, &m_pebp);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pebp);
        }
        ReleaseObj( pnccb );
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgUpperBindingPath::CIterNetCfgUpperBindingPath");
}

inline NOTHROW CIterNetCfgBindingInterface::CIterNetCfgBindingInterface(INetCfgBindingPath* pncbp)
    : CIEnumIter<IEnumNetCfgBindingInterface, INetCfgBindingInterface*> (NULL)
{
    AssertH(pncbp);

    // If EnumBindingInterfaces() fails, make sure ReleaseObj() won't die.
    m_pebi = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    m_hrLast = pncbp->EnumBindingInterfaces(&m_pebi);
    if (SUCCEEDED(m_hrLast))
    {
        SetEnumerator(m_pebi);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgBindingInterface::CIterNetCfgBindingInterface");
}

inline NOTHROW CIterNetCfgComponent::CIterNetCfgComponent(INetCfg* pnc, const GUID* pguid)
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
    AssertH(pnc);

    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    INetCfgClass* pncclass;
    m_hrLast = pnc->QueryNetCfgClass(pguid, IID_INetCfgClass,
                reinterpret_cast<void**>(&pncclass));
    if (SUCCEEDED(m_hrLast))
    {
        // Get the enumerator and set it for the base class.
        // Important to set m_hrLast so that if this fails, we'll also
        // fail any subsequent calls to HrNext.
        m_hrLast = pncclass->EnumComponents(&m_pec);
        if (SUCCEEDED(m_hrLast))
        {
            SetEnumerator(m_pec);
        }

        ReleaseObj(pncclass);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgComponent::CIterNetCfgComponent");
}

inline NOTHROW CIterNetCfgComponent::CIterNetCfgComponent(INetCfgClass* pncclass)
    : CIEnumIter<IEnumNetCfgComponent, INetCfgComponent*> (NULL)
{
    AssertH(pncclass);

    // If EnumComponents() fails, make sure ReleaseObj() won't die.
    m_pec = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    m_hrLast = pncclass->EnumComponents(&m_pec);
    if (SUCCEEDED(m_hrLast))
    {
        SetEnumerator(m_pec);
    }

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "CIterNetCfgComponent::CIterNetCfgComponent");
}

#endif // _NCNETCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncnetcon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C N E T C O N . H
//
//  Contents:   Common routines for dealing with the connections interfaces.
//
//  Notes:
//
//  Author:     shaunco   25 Jan 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCNETCON_H_
#define _NCNETCON_H_

#include "nccom.h"
#include "netconp.h"
#include "oleauto.h"

typedef enum tagNETCONPROPS_EX_FIELDS
{
    NCP_DWSIZE = 0,
    NCP_GUIDID,
    NCP_BSTRNAME,
    NCP_BSTRDEVICENAME,
    NCP_NCSTATUS,
    NCP_MEDIATYPE,
    NCP_SUBMEDIATYPE,
    NCP_DWCHARACTER,
    NCP_CLSIDTHISOBJECT,
    NCP_CLSIDUIOBJECT,
    NCP_BSTRPHONEORHOSTADDRESS,
    NCP_BSTRPERSISTDATA,
    NCP_MAX = NCP_BSTRPERSISTDATA,
    NCP_ELEMENTS = NCP_MAX + 1
} NETCONPROPS_EX_FIELDS;

BOOL
FAnyReasonToEnumerateConnectionsForShowIconInfo (
    VOID);

BOOL
FIsValidConnectionName(
    IN PCWSTR pszName);

VOID
FreeNetconProperties (
    IN NETCON_PROPERTIES* pProps);

HRESULT
HrGetConnectionPersistData (
    IN INetConnection* pConn,
    OUT BYTE** ppbData,
    OUT ULONG* pulSize,
    OUT CLSID* pclsid OPTIONAL);

HRESULT
HrGetConnectionFromPersistData (
    IN const CLSID& clsid,
    IN const BYTE* pbData,
    IN ULONG cbData,
    IN REFIID riid,
    OUT VOID** ppv);

//------------------------------------------------------------------------
// CIterNetCon - iterator for IEnumNetConnection
//
//  This class is is a simple wrapper around CIEnumIter with a call
//  to INetConnectionManager::EnumConnections to get the enumerator.
//
class CIterNetCon : public CIEnumIter<IEnumNetConnection, INetConnection*>
{
public:
    NOTHROW CIterNetCon (
        INetConnectionManager* pConMan,
        NETCONMGR_ENUM_FLAGS   Flags);

    NOTHROW ~CIterNetCon () { ReleaseObj (m_pEnum); }

    // Specialization to set the proxy blanket before returning
    NOTHROW HRESULT HrNext(INetConnection ** ppConnection);

protected:
    IEnumNetConnection* m_pEnum;
};

inline NOTHROW CIterNetCon::CIterNetCon (
    INetConnectionManager*  pConMan,
    NETCONMGR_ENUM_FLAGS    Flags
    )
    : CIEnumIter<IEnumNetConnection, INetConnection*> (NULL)
{
    AssertH (pConMan);

    // If EnumConnections() fails, make sure ReleaseObj() won't die.
    m_pEnum = NULL;

    // Get the enumerator and set it for the base class.
    // Important to set m_hrLast so that if this fails, we'll also
    // fail any subsequent calls to HrNext.
    //
    m_hrLast = pConMan->EnumConnections (Flags, &m_pEnum);

    TraceHr (ttidError, FAL, m_hrLast, FALSE,
        "INetConnectionManager->EnumConnections");

    if (SUCCEEDED(m_hrLast))
    {
        NcSetProxyBlanket (m_pEnum);

        SetEnumerator (m_pEnum);
    }
    TraceHr (ttidError, FAL, m_hrLast, FALSE, "CIterNetCon::CIterNetCon");
}

// Specialization to set the proxy blanket before returning
inline NOTHROW HRESULT CIterNetCon::HrNext(INetConnection ** ppConnection)
{
    HRESULT hr = CIEnumIter<IEnumNetConnection, INetConnection*>::HrNext(ppConnection);
    if(SUCCEEDED(hr) && *ppConnection) 
    {
        NcSetProxyBlanket(*ppConnection);
    }
    return hr;
}


VOID
SetOrQueryAtLeastOneLanWithShowIcon (
    IN BOOL fSet,
    IN BOOL fSetValue,
    OUT BOOL* pfQueriedValue);

HRESULT
HrSafeArrayFromNetConPropertiesEx (
   IN      NETCON_PROPERTIES_EX* pPropsEx,
   OUT     SAFEARRAY** ppsaProperties);

HRESULT HrNetConPropertiesExFromSafeArray(
    IN      SAFEARRAY* psaProperties,
    OUT     NETCON_PROPERTIES_EX** pPropsEx);

HRESULT HrFreeNetConProperties2(
    NETCON_PROPERTIES_EX* pPropsEx);

#endif // _NCNETCON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncmisc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M I S C . H
//
//  Contents:   Miscellaneious common code.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCMISC_H_
#define _NCMISC_H_

#include "ncdebug.h"    // for AssertH
#include "ncdefine.h"   // for NOTHROW


const WORD wWinNT351BuildNumber = 1057;
const WORD wWinNT4BuildNumber   = 1381;

#define WM_SELECTED_ALL        WM_USER+200

//+---------------------------------------------------------------------------
// CExceptionSafeLock takes advantage of automatic constructor/destructor
// action guaranteed by the compiler (if stack unwinding is turned on)
// to always ensure that a critical section is left if it has ever been
// entered.  The constructor of this class enters the critical section
// and destructor leaves it.  The critical section must have been initialized
// before this class can be used.
//
class CExceptionSafeLock : CNetCfgDebug<CExceptionSafeLock>
{
public:
    CExceptionSafeLock (CRITICAL_SECTION* pCritSec)
    {
        AssertH (pCritSec);

        m_pCritSec = pCritSec;
        EnterCriticalSection (pCritSec);

        //TraceTag (ttidEsLock, "Entered critical section 0x%08x", pCritSec);
    }

    ~CExceptionSafeLock ()
    {
        AssertH (m_pCritSec);

        //TraceTag (ttidEsLock, "Leaving critical section 0x%08x", &m_pCritSec);

        LeaveCriticalSection (m_pCritSec);
    }

protected:
    CRITICAL_SECTION* m_pCritSec;
};


BOOL
FInSystemSetup ();

#if defined(REMOTE_BOOT)
HRESULT HrIsRemoteBootMachine();
#endif

enum PRODUCT_FLAVOR
{
    PF_WORKSTATION  = 1,
    PF_SERVER       = 2,
};

NOTHROW
VOID
GetProductFlavor (
    const VOID*     pvReserved,
    PRODUCT_FLAVOR* ppf);

HRESULT
HrIsNetworkingInstalled ();

enum REGISTER_FUNCTION
{
    RF_REGISTER,
    RF_UNREGISTER,
};
HRESULT
HrRegisterOrUnregisterComObject (
        PCWSTR              pszDllPath,
        REGISTER_FUNCTION   rf);

inline
HRESULT
HrRegisterComObject (
        PCWSTR     pszDllPath)
{
    HRESULT hr = HrRegisterOrUnregisterComObject (pszDllPath, RF_REGISTER);
    TraceError("HrRegisterComObject", hr);
    return hr;
}

inline
HRESULT
HrUnregisterComObject (
        PCWSTR     pszDllPath)
{
    HRESULT hr = HrRegisterOrUnregisterComObject (pszDllPath, RF_UNREGISTER);
    TraceError("HrUnregisterComObject", hr);
    return hr;
}

DWORD
ScStopNetbios();

HRESULT HrEnableAndStartSpooler();
HRESULT HrCreateDirectoryTree(PWSTR pszPath, LPSECURITY_ATTRIBUTES psa);
HRESULT HrDeleteFileSpecification(PCWSTR pszFileSpec,
                                  PCWSTR pszDirectoryPath);
HRESULT HrDeleteDirectory(IN PCWSTR pszDir,
                          IN BOOL fContinueOnError);

VOID LowerCaseComputerName(PWSTR szName);

#endif // _NCMISC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncoc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C O C . H
//
//  Contents:   Optional component common library
//
//  Notes:
//
//  Author:     danielwe   18 Dec 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCOC_H
#define _NCOC_H

HRESULT HrProcessSNMPAddSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessSNMPRemoveSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessRegisterSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessUnregisterSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessAllINFExtensions(HINF hinfFile, PCWSTR szInstallSection);
HRESULT HrProcessAddShortcutSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessDelShortcutSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessPrintAddSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrProcessPrintRemoveSection(HINF hinfFile, PCWSTR szSection);
HRESULT HrAddPrintMonitor(PCWSTR szPrintMonitorName,
                          PCWSTR szPrintMonitorDLL);
HRESULT HrRemovePrintMonitor(PCWSTR szPrintMonitorName);
HRESULT HrAddPrintProc(PCWSTR szDLLName, PCWSTR szProc);
HRESULT HrRemovePrintProc(PCWSTR szProc);

#endif //!_NCOC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncmem.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C M E M . H
//
//  Contents:   Common memory management routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//              deonb      2 Jan 2002
//
//----------------------------------------------------------------------------

#ifndef _NCMEM_H_
#define _NCMEM_H_

#ifdef _XMEMORY_
#error "Include this file before any STL headers"
// Complain if <xmemory> is included before us, since we may be redefining the allocator from that file.
#endif

#ifdef USE_CUSTOM_STL_ALLOCATOR
// If using our custom allocator for STL, then remove STL's <xmemory> from the equation.
#define _XMEMORY_
#endif

#ifdef COMPILE_WITH_TYPESAFE_PRINTF
#define DEFINE_TYPESAFE_PRINTF(RETTYPE, printffunc, SZARG1) \
RETTYPE printffunc(SZARG1); \
template <class T1>  \
    RETTYPE printffunc(SZARG1, T1 t1)\
{ LPCVOID cast1 = (LPCVOID)t1; return 0; }\
template <class T1, class T2> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; return 0; }\
template <class T1, class T2, class T3> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2;  LPCVOID cast3 = (LPCVOID)t3; return 0; }\
template <class T1, class T2, class T3, class T4> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; return 0; }\
template <class T1, class T2, class T3, class T4, class T5> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; LPCVOID cast12= (LPCVOID)t12; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13> \
    RETTYPE printffunc(SZARG1, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; LPCVOID cast12= (LPCVOID)t12; LPCVOID cast13= (LPCVOID)t13; return 0; }

#define DEFINE_TYPESAFE_PRINTF2(RETTYPE, printffunc, SZARG1, SZARG2) \
RETTYPE printffunc(SZARG1, SZARG2); \
template <class T1>  \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1)\
{ LPCVOID cast1 = (LPCVOID)t1; return 0; } \
template <class T1, class T2> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; return 0; }\
template <class T1, class T2, class T3> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2;  LPCVOID cast3 = (LPCVOID)t3; return 0; }\
template <class T1, class T2, class T3, class T4> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; return 0; }\
template <class T1, class T2, class T3, class T4, class T5> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11;  LPCVOID cast12= (LPCVOID)t12; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13> \
    RETTYPE printffunc(SZARG1, SZARG2, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; LPCVOID cast12= (LPCVOID)t12; LPCVOID cast13= (LPCVOID)t13; return 0; }

#define DEFINE_TYPESAFE_PRINTF3(RETTYPE, printffunc, SZARG1, SZARG2, SZARG3) \
RETTYPE printffunc(SZARG1, SZARG2, SZARG3); \
template <class T1>  \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1)\
{ LPCVOID cast1 = (LPCVOID)t1; return 0; } \
template <class T1, class T2> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; return 0; }\
template <class T1, class T2, class T3> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2;  LPCVOID cast3 = (LPCVOID)t3; return 0; }\
template <class T1, class T2, class T3, class T4> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; return 0; }\
template <class T1, class T2, class T3, class T4, class T5> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; return 0; }\
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11;  LPCVOID cast12= (LPCVOID)t12; return 0; } \
template <class T1, class T2, class T3, class T4, class T5, class T6, class T7, class T8, class T9, class T10, class T11, class T12, class T13> \
    RETTYPE printffunc(SZARG1, SZARG2, SZARG3, T1 t1, T2 t2, T3 t3, T4 t4, T5 t5, T6 t6, T7 t7, T8 t8, T9 t9, T10 t10, T11 t11, T12 t12, T13 t13) \
{ LPCVOID cast1 = (LPCVOID)t1; LPCVOID cast2 = (LPCVOID)t2; LPCVOID cast3 = (LPCVOID)t3; LPCVOID cast4 = (LPCVOID)t4; LPCVOID cast5 = (LPCVOID)t5; LPCVOID cast6 = (LPCVOID)t6; LPCVOID cast7 = (LPCVOID)t7; LPCVOID cast8 = (LPCVOID)t8; LPCVOID cast9 = (LPCVOID)t9; LPCVOID cast10= (LPCVOID)t10; LPCVOID cast11= (LPCVOID)t11; LPCVOID cast12= (LPCVOID)t12; LPCVOID cast13= (LPCVOID)t13; return 0; }


#undef printf
DEFINE_TYPESAFE_PRINTF(int, safe_printf,     LPCSTR)
#define printf      safe_printf

#undef _stprintf
DEFINE_TYPESAFE_PRINTF(int, safe__stprintf,    LPCWSTR)
#define _stprintf   safe__stprintf

#undef wsprintf
DEFINE_TYPESAFE_PRINTF2(int, safe_wsprintf,  LPWSTR, LPCWSTR)
#define wsprintf    safe_wsprintf

#undef wsprintfW
DEFINE_TYPESAFE_PRINTF2(int, safe_wsprintfW,  LPWSTR, LPCWSTR)
#define wsprintfW    safe_wsprintfW

#undef swprintf
DEFINE_TYPESAFE_PRINTF2(int, safe_swprintf,  LPWSTR, LPCWSTR)
#define swprintf    safe_swprintf

#undef wsprintfA
DEFINE_TYPESAFE_PRINTF2(int, safe_wsprintfA,   LPSTR,  LPCSTR)
#define wsprintfA   safe_wsprintfA

#undef sprintf
DEFINE_TYPESAFE_PRINTF2(int, safe_sprintf,   LPSTR,  LPCSTR)
#define sprintf     safe_sprintf

#undef _snwprintf
DEFINE_TYPESAFE_PRINTF3(int, safe__snwprintf, LPWSTR, size_t, LPCWSTR)
#define _snwprintf  safe__snwprintf

#undef _snprintf
DEFINE_TYPESAFE_PRINTF3(int, safe__snprintf,  LPSTR,  size_t, LPCSTR)
#define _snprintf   safe__snprintf

#undef fprintf
DEFINE_TYPESAFE_PRINTF2(int, safe_fprintf,   void*,  LPCSTR)
#define fprintf     safe_fprintf

#undef fwprintf
DEFINE_TYPESAFE_PRINTF2(int, safe_fwprintf,  void*,  LPCWSTR)
#define fwprintf    safe_fwprintf

#pragma warning(disable: 4005) // Avoid "macro redefinition" errors. We should win.
#endif // COMPILE_WITH_TYPESAFE_PRINTF

#include <new>
#include <cstdlib>
#include <malloc.h> // for _alloca

VOID*
MemAlloc (
    size_t cb) throw();

VOID
MemFree (
    VOID* pv) throw();


// A simple wrapper around malloc that returns E_OUTOFMEMORY if the
// allocation fails.  Avoids having to explicitly do this at each
// call site of malloc.
//
HRESULT
HrMalloc (
    size_t  cb,
    PVOID*  ppv) throw();

// This CANNOT be an inline function.  If it is ever not inlined,
// the memory allocated will be destroyed.  (We're dealing with the stack
// here.)
//
#define PvAllocOnStack(_st)  _alloca(_st)

// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct throwonfail_t {};
extern const throwonfail_t throwonfail;

VOID*
__cdecl
operator new (
    size_t cb,
    const throwonfail_t&
    ) throw (std::bad_alloc);

// The matching operator delete is required to avoid C4291 (no matching operator delete found; memory will 
//     not be freed if initialization throws an exception)
// It is not needed to call this delete to free the memory allocated by operator new(size_t, const throwonfail&)
VOID
__cdecl
operator delete (
    void* pv,
    const throwonfail_t&) throw ();

// Define a structure so that we can overload operator new with a
// signature specific to our purpose.
//
struct extrabytes_t {};
extern const extrabytes_t extrabytes;

VOID*
__cdecl
operator new (
    size_t cb,
    const extrabytes_t&,
    size_t cbExtra) throw();

VOID
__cdecl
operator delete (
    VOID* pv,
    const extrabytes_t&,
    size_t cbExtra);

inline
void *  Nccalloc(size_t n, size_t s)
{
    return HeapAlloc (GetProcessHeap(), HEAP_ZERO_MEMORY, (n * s));
}

inline
void Ncfree(void * p)
{
    HeapFree (GetProcessHeap(), 0, p);
}

inline
void * Ncmalloc(size_t n)
{
    return HeapAlloc (GetProcessHeap(), 0, n);
}

inline
void * Ncrealloc(void * p, size_t n)
{
    return (NULL == p)
        ? HeapAlloc (GetProcessHeap(), 0, n)
        : HeapReAlloc (GetProcessHeap(), 0, p, n);
}

#define calloc  Nccalloc
#define free    Ncfree
#define malloc  Ncmalloc
#define realloc Ncrealloc

#ifdef USE_CUSTOM_STL_ALLOCATOR
    // Our implementation of the STL 'allocator' - STL's version of operator new.
    #pragma pack(push,8)
    #include <utility>

    #ifndef _FARQ       // specify standard memory model
        #define _FARQ
        #define _PDFT    ptrdiff_t
        #define _SIZT    size_t
    #endif
    
    // Need to define these since <xmemory> defines these, and we're forcing that header file
    // not to be included anymore.
    #define _POINTER_X(T, A)	T _FARQ *
    #define _REFERENCE_X(T, A)	T _FARQ &

    namespace std 
    {
        // TEMPLATE FUNCTION _Allocate. 
        // This needs to be implemented seperate from our nc_allocator.allocate (below), since the rest 
        // of the HP STL headers rely on this implementation to have the name _Allocate. This binds us 
        // to the HP STL implementation, but given the choice between just rewriting the allocator and 
        // implementing an entire STL for ourselves, it is better to just rewrite the allocator, albeit 
        // specific to one implementation of it.
        template<class T> inline
            T _FARQ *_Allocate(_PDFT nCount, T _FARQ *)
        {
            if (nCount < 0)
            {
                nCount = 0;
            }

            // Call our throwing form of operator new. This will throw a bad_alloc on failure.
            return ((T _FARQ *)operator new((_SIZT)nCount * sizeof (T), throwonfail)); 
        }

        // TEMPLATE FUNCTION _Construct
        // See comments for _Allocate
        template<class T1, class T2> inline
            void _Construct(T1 _FARQ *p, const T2& v)
        {
            // Placement new only. No memory allocation, hence no need to throw.
            new ((void _FARQ *)p) T1(v); 
        }

        // TEMPLATE FUNCTION _Destroy
        // See comments for _Allocate
        template<class T> 
            inline void _Destroy(T _FARQ *p)
        {
            (p)->~T(); // call the destructor
        }
    
        // FUNCTION _Destroy
        // See comments for _Allocate
        inline void _Destroy(char _FARQ *p)
        {
            (void *)p;
        }
    
        // FUNCTION _Destroy
        // See comments for _Allocate
        inline void _Destroy(wchar_t _FARQ *p)
        {
            (void *)p;
        }

        // TEMPLATE CLASS nc_allocator. 
        // Our allocator to be used by the STL internals for a type T class. The STL allocator is called:
        // 'allocator' and this class replaces that one.
        template<class T>
            class nc_allocator
        {
            public:
                typedef _SIZT size_type;
                typedef _PDFT difference_type;
                typedef T _FARQ *pointer;
                typedef const T _FARQ *const_pointer;
                typedef T _FARQ& reference;
                typedef const T _FARQ& const_reference;
                typedef T value_type;

                pointer address(reference x) const
                {
                    return (&x); 
                }

                const_pointer address(const_reference x) const
                {
                    return (&x); 
                }
                
                pointer allocate(size_type nCount, const void *)
                {
                    return (_Allocate((difference_type)nCount, (pointer)0)); 
                }
                
                char _FARQ *_Charalloc(size_type nCount)
                {
                    return (_Allocate((difference_type)nCount, (char _FARQ *)0)); 
                }
                
                void deallocate(void _FARQ *p, size_type)
                {
                    operator delete(p); 
                }
                
                void construct(pointer p, const T& v)
                {
                    _Construct(p, v); 
                }
                
                void destroy(pointer p)
                {
                    _Destroy(p); 
                }
                
                _SIZT max_size() const
                {
                    _SIZT nCount = (_SIZT)(-1) / sizeof (T);
                    return (0 < nCount ? nCount : 1); 
                }
        };

        template<class T, class U> inline
            bool operator == (const nc_allocator<T>&, const nc_allocator<U>&)
        {
            return (true); 
        }
        
        template<class T, class U> inline
            bool operator != (const nc_allocator<T>&, const nc_allocator<U>&)
        {
            return (false); 
        }

        // TEMPLATE CLASS nc_allocator. Our allocator to be used by the STL internals for a void allocation.
        template<> class _CRTIMP nc_allocator<void> 
        {
            public:
                typedef void T;
                typedef T _FARQ *pointer;
                typedef const T _FARQ *const_pointer;
                typedef T value_type;
        };

        #pragma pack(pop)
    }; // namespace std

    // Tell all of STL to use nc_allocator from now on instead of it's built-in allocator
    #define allocator nc_allocator

     // 
     // Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED. 
     // Consult your license regarding permissions and restrictions.
     //
     // This file is derived from software bearing the following
     // restrictions:
     // 
     // Copyright (c) 1994
     // Hewlett-Packard Company
     //
     // Permission to use, copy, modify, distribute and sell this
     // software and its documentation for any purpose is hereby
     // granted without fee, provided that the above copyright notice
     // appear in all copies and that both that copyright notice and
     // this permission notice appear in supporting documentation.
     // Hewlett-Packard Company makes no representations about the
     // suitability of this software for any purpose. It is provided
     // "as is" without express or implied warranty.
     //     
#endif // USE_CUSTOM_STL_ALLOCATOR

#endif // _NCMEM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncnbios.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C N B I O S . H
//
//  Contents:   NetBios Binding object definitions
//
//  Notes:
//
//  Author:     danielwe   14 Jul 1998
//
//----------------------------------------------------------------------------

#pragma once

//
// Structure of LANA MAP
//
// The Lana map is a simple structure that looks like this in memory:
//
//    Entry #0    Entry #1   .....   Entry #n
// |-----------|-----------| ..... |-----------|
// | 0x01 0x00 | 0x00 0x01 | ..... | 0x01 0x03 |
// |-----------|-----------| ..... |-----------|
//   EP0   LN0   EP1   LN1           EPn  LNn
//
// EP is "ExportPref" - means that when someone asks for the list of
// all Lana numbers, entries with a 0 here will not be returned.
//
// LN is the "Lana number" - see the IBM NetBIOS spec for details.
// Basically, this describes a single, unique network route which
// uses NetBIOS.
//
// Using the above example, Entry #0 has a lana number of 0 and WILL
// be returned during enumeration. Entry #1 has a lana number of 1
// and WILL NOT be returned.
//

struct LANA_ENTRY
{
    BYTE        bIsExported;
    BYTE        bLanaNum;
};

struct LANA_MAP
{
    DWORD           clmMap;         // number of entries in map
    LANA_ENTRY *    aleMap;         // array for each entry
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncperms.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P E R M S . H
//
//  Contents:   Common routines for dealing with permissions.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCPERMS_H_
#define _NCPERMS_H_

#include "ncdefine.h"   // for NOTHROW
#include "gpbase.h"

#ifdef DBG
extern DWORD g_dwDbgPermissionsFail; // Debug flag to force permissions to fail
#endif

// Apply Masks
typedef enum tagNCPERM_APPLY_TO
{
    APPLY_TO_ADMIN          = 0x00000001,
    APPLY_TO_NETCONFIGOPS   = 0x00000002,
    APPLY_TO_POWERUSERS     = 0x00000004,
    APPLY_TO_USER           = 0x00000008,
    APPLY_TO_GUEST          = 0x00000010,
    APPLY_TO_LOCATION       = 0x00010000,
    APPLY_TO_ALL_USERS      = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS | APPLY_TO_POWERUSERS | APPLY_TO_USER,
    APPLY_TO_OPS_OR_ADMIN   = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS,
    APPLY_TO_NON_ADMINS     = APPLY_TO_NETCONFIGOPS | APPLY_TO_USER | APPLY_TO_POWERUSERS,
    APPLY_TO_POWERUSERSPLUS = APPLY_TO_POWERUSERS | APPLY_TO_NETCONFIGOPS | APPLY_TO_ADMIN,
    APPLY_TO_EVERYBODY      = APPLY_TO_ALL_USERS | APPLY_TO_GUEST,
    APPLY_TO_ALL            = APPLY_TO_ADMIN | APPLY_TO_NETCONFIGOPS | APPLY_TO_POWERUSERS | APPLY_TO_USER | APPLY_TO_LOCATION
} NCPERM_APPLY_TO;

BOOL
FIsUserAdmin ();

BOOL 
FIsUserNetworkConfigOps ();

BOOL 
FIsUserPowerUser();

BOOL 
FIsUserGuest();

HRESULT
HrAllocateSecurityDescriptorAllowAccessToWorld (
    OUT PSECURITY_DESCRIPTOR*   ppSd);

HRESULT
HrEnablePrivilege (
    IN  PCWSTR pszPrivilegeName);

HRESULT
HrEnableAllPrivileges (
    OUT TOKEN_PRIVILEGES**  pptpOld);

HRESULT
HrRestorePrivileges (
    IN  TOKEN_PRIVILEGES*   ptpRestore);

// FHasPermission flags are defined in netconp.idl/.h
//
BOOL
FHasPermission(
    IN  ULONG   ulPermMask,
    IN  /*const*/ CGroupPolicyBase* pGPBase = NULL);

BOOL
FHasPermissionFromCache(
    IN  ULONG   ulPermMask);

VOID
RefreshAllPermission();

BOOL 
FProhibitFromAdmins();

BOOL
IsHNetAllowed(
    IN  DWORD dwPerm
    );

BOOL 
FIsPolicyConfigured(
    IN  DWORD ulPerm);

BOOL
IsSameNetworkAsGroupPolicies();

#endif // _NCPERMS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncpnp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P N P . H
//
//  Contents:   Common code for PnP.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   10 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCPNP_H_
#define _NCPNP_H_

#include "ndispnp.h"

HRESULT
HrSendServicePnpEvent (
        PCWSTR      pszService,
        DWORD       dwControl);

HRESULT
HrSendNdisPnpReconfig (
        UINT        uiLayer,
        PCWSTR      pszUpper,
        PCWSTR      pszLower    = NULL,
        PVOID       pvData      = NULL,
        DWORD       dwSizeData  = 0);

#endif // _NCPNP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncshell.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S H E L L . H
//
//  Contents:   Basic common code.
//
//  Notes:
//
//  Author:     anbrad  08  Jun 1999
//
//----------------------------------------------------------------------------

#pragma once

#ifndef _NCSHELL_H_
#define _NCSHELL_H_

#include <shlobj.h>
#include <shlobjp.h>

#ifndef PCONFOLDPIDLDEFINED
class PCONFOLDPIDL;
class PCONFOLDPIDLFOLDER;
#endif

VOID GenerateEvent(
    LONG            lEventId,
    const PCONFOLDPIDLFOLDER& pidlFolder,
    const PCONFOLDPIDL& pidlIn,
    LPCITEMIDLIST    pidlNewIn);

VOID GenerateEvent(
                   LONG          lEventId,
                   LPCITEMIDLIST pidlFolder,
                   LPCITEMIDLIST pidlIn,
                   LPCITEMIDLIST pidlNewIn);
#endif // _NCSHELL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncras.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R A S . H
//
//  Contents:   Common code for RAS connections.
//
//  Notes:
//
//  Author:     shaunco   20 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netconp.h"
#include <ras.h>
#include <rasuip.h>
#include <rasapip.h>
#include <rasuip.h>

VOID
RciFree (
    RASCON_INFO* pRasConInfo);

BOOL
FExistActiveRasConnections ();

HRESULT
HrRciGetRasConnectionInfo (
    IN INetConnection* pCon,
    OUT RASCON_INFO* pRasConInfo);

HRESULT
HrRasEnumAllActiveConnections (
    OUT RASCONN** ppRasConn,
    OUT DWORD* pcRasConn);

HRESULT
HrRasEnumAllActiveServerConnections (
    OUT RASSRVCONN** paRasSrvConn,
    OUT DWORD* pcRasSrvConn);

HRESULT
HrRasEnumAllEntriesWithDetails (
    IN PCWSTR pszPhonebook,
    OUT RASENUMENTRYDETAILS** paRasEntryDetails,
    OUT DWORD* pcRasEntryDetails);

HRESULT
HrFindRasConnFromGuidId (
    IN const GUID* pguid,
    OUT HRASCONN* phRasConn,
    OUT RASCONN* pRasConn OPTIONAL);

HRESULT
HrRasGetEntryProperties (
    IN PCWSTR pszPhonebook,
    IN PCWSTR pszEntry,
    OUT RASENTRY** ppRasEntry,
    OUT DWORD* pcbRasEntry);

HRESULT
HrRasGetSubEntryProperties (
    IN PCWSTR pszPhonebook,
    IN PCWSTR pszEntry,
    IN DWORD dwSubEntry,
    OUT RASSUBENTRY** ppRasSubEntry);

HRESULT
HrRasGetNetconStatusFromRasConnectStatus (
    IN HRASCONN hRasConn,
    OUT NETCON_STATUS* pStatus);

HRESULT
HrRasHangupUntilDisconnected (
    IN HRASCONN hRasConn);

HRESULT
HrNetConToSharedConnection (
    IN INetConnection* pCon,
    OUT LPRASSHARECONN prsc);

HRESULT
HrRasIsSharedConnection (
    IN LPRASSHARECONN prsc,
    OUT PBOOL pfShared);

#if 0

HRESULT
HrRasQueryLanConnTable (
    IN LPRASSHARECONN prsc,
    OUT NETCON_PROPERTIES** ppLanTable,
    OUT LPDWORD pdwLanCount);

HRESULT
HrRasShareConnection (
    IN LPRASSHARECONN prsc,
    IN GUID* pPrivateLanGuid OPTIONAL);

HRESULT
HrRasUnshareConnection (
    OUT PBOOL pfWasShared);

#endif

DWORD 
RasSrvTypeFromRasDeviceType(
    RASDEVICETYPE rdt
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncsetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S E T U P . H
//
//  Contents:   HRESULT wrappers for the Setup Api.
//
//  Notes:
//
//  Author:     shaunco   16 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSETUP_H_
#define _NCSETUP_H_

#include <setupapi.h>
#include "ncstring.h"

enum SD_DEID_FLAG_TYPE
{
    SDDFT_FLAGS,
    SDDFT_FLAGSEX,
};

enum SD_FLAGS_BINARY_OP
{
    SDFBO_AND,
    SDFBO_OR,
    SDFBO_XOR,
};


//+---------------------------------------------------------------------------
// Lower level wrappers
//

HRESULT
HrSetupCommitFileQueue                  (HWND hwndOwner, HSPFILEQ hfq,
                                         PSP_FILE_CALLBACK pfc, PVOID pvCtx);

HRESULT
HrSetupInitDefaultQueueCallbackEx       (HWND hwndOwner,
                                         HWND hwndAlternate,
                                         UINT uMsg,
                                         DWORD dwReserved1,
                                         PVOID dwReserved2,
                                         PVOID* ppvCtx);

HRESULT
HrSetupOpenFileQueue                    (HSPFILEQ* phfq);

HRESULT
HrSetupOpenInfFile                      (PCWSTR pszFileName,
                                         PCWSTR pszInfClass,
                                         DWORD dwInfStyle,
                                         UINT* punErrorLine,
                                         HINF* phinf);
HRESULT
HrSetupFindFirstLine                    (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         INFCONTEXT* pctx);
HRESULT
HrSetupFindNextLine                     (const INFCONTEXT& ctxIn,
                                         INFCONTEXT* pctxOut);
HRESULT
HrSetupFindNextMatchLine                (const INFCONTEXT& ctxIn,
                                         PCWSTR pszKey,
                                         INFCONTEXT* pctxOut);
HRESULT
HrSetupGetLineByIndex                   (HINF hinf,
                                         PCWSTR pszSection,
                                         DWORD dwIndex,
                                         INFCONTEXT* pctx);
HRESULT
HrSetupGetLineCount                     (HINF hinf,
                                         PCWSTR pszSection,
                                         ULONG* pulCount);
HRESULT
HrSetupGetBinaryField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         BYTE* pbBuf, DWORD cbBuf,
                                         DWORD* pbRequired);
HRESULT
HrSetupGetIntField                      (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         INT* pnValue);
HRESULT
HrSetupGetMultiSzField                  (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR pszBuf, DWORD cchBuf,
                                         DWORD* pcchRequired);
HRESULT
HrSetupGetMultiSzFieldWithAlloc         (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR* ppszBuf);
HRESULT
HrSetupGetStringField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         tstring* pstr);
HRESULT
HrSetupGetStringField                   (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         PWSTR pszBuf, DWORD cchBuf,
                                         DWORD* pcchRequired);

HRESULT
HrSetupScanFileQueueWithNoCallback      (HSPFILEQ hfq, DWORD dwFlags,
                                         HWND hwnd, PDWORD pdwResult);

VOID
SetupCloseInfFileSafe(HINF hinf);


//+---------------------------------------------------------------------------
// Intermediate functionality
//

HRESULT
HrSetupGetMultiSzFieldMapToDword        (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetStringFieldMapToDword         (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetStringFieldAsBool             (const INFCONTEXT& ctx,
                                         DWORD dwFieldIndex,
                                         BOOL* pfValue);

//+---------------------------------------------------------------------------
// Find first and get
//
HRESULT
HrSetupGetFirstDword                    (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstString                   (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         tstring* pstr);
HRESULT
HrSetupGetFirstMultiSzFieldWithAlloc    (HINF hinf, PCWSTR szSection,
                                         PCWSTR szKey, PWSTR *pszOut);
HRESULT
HrSetupGetFirstMultiSzMapToDword        (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstStringMapToDword         (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         const MAP_SZ_DWORD* aMapSzDword,
                                         UINT cMapSzDword,
                                         DWORD* pdwValue);
HRESULT
HrSetupGetFirstStringAsBool             (HINF hinf,
                                         PCWSTR pszSection,
                                         PCWSTR pszKey,
                                         BOOL* pfValue);

HRESULT
HrSetupGetInfInformation                (LPCVOID pvInfSpec,
                                         DWORD dwSearchControl,
                                         PSP_INF_INFORMATION* ppinfInfo);

HRESULT
HrSetupIsValidNt5Inf                    (HINF hinf);


HRESULT
HrSetupQueryInfVersionInformation       (PSP_INF_INFORMATION pinfInfo,
                                         UINT uiIndex, PCWSTR szKey,
                                         PWSTR* ppszInfo);

//+--------------------------------------------------------------------------
// SetupDi* wrappers and helpers
//

HRESULT
HrSetupCopyOemInf(IN const tstring& strSourceName,
      IN const tstring& strSourceMediaLocation, OPTIONAL
      IN DWORD dwSourceMediaType, IN DWORD dwCopyStyle,
      OUT tstring* pstrDestFilename, OPTIONAL
      OUT tstring* pstrDestFilenameComponent OPTIONAL);



HRESULT
HrSetupCopyOemInfBuffer(
    IN PCWSTR pszSourceName,
    IN PCWSTR pszSourceMediaLocation, OPTIONAL
    IN DWORD SourceMediaType,
    IN DWORD CopyStyle,
    OUT PWSTR pszDestFilename,
    IN DWORD cchDestFilename,
    OUT PWSTR* ppszDestFilenameComponent OPTIONAL);

HRESULT
HrSetupDiBuildDriverInfoList(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid,
                             IN DWORD dwDriverType);

HRESULT
HrSetupDiCallClassInstaller(DI_FUNCTION dif, HDEVINFO hdi,
                            PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiCreateDeviceInfo(IN HDEVINFO hdi, IN PCWSTR szDeviceName,
                          IN const GUID& guidClass, PCWSTR szDesc,
                          IN HWND hwndParent, IN DWORD dwFlags,
                          OUT PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiEnumDeviceInfo(IN HDEVINFO hdi, IN DWORD dwIndex,
                        PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiEnumDriverInfo(IN HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                        IN DWORD dwDriverType, IN DWORD dwIndex,
                        OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiSelectBestCompatDrv(IN     HDEVINFO         hdi,
                             IN OUT PSP_DEVINFO_DATA pdeid);


HRESULT
HrSetupDiGetClassDevs (
    IN const GUID* pguidClass, OPTIONAL
    IN PCWSTR pszEnumerator, OPTIONAL
    IN HWND hwndParent, OPTIONAL
    IN DWORD dwFlags,
    OUT HDEVINFO* phdi);


HRESULT
HrSetupDiGetDeviceInfoListClass(IN HDEVINFO hdi, OUT GUID* pGuid);

HRESULT
HrSetupDiGetDeviceInstanceId(IN HDEVINFO hdi,
                             IN PSP_DEVINFO_DATA pdeid,
                             OUT PWSTR pszId,
                             IN DWORD cchId,
                             OUT DWORD* cchRequired);

HRESULT
HrSetupDiInstallDevice(IN HDEVINFO hdi, IN OUT PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiOpenDevRegKey(IN HDEVINFO hdi,
                       IN PSP_DEVINFO_DATA pdeid, IN DWORD dwScope,
                       IN DWORD dwHwProfile, IN DWORD dwKeyType,
                       IN REGSAM samDesired, OUT HKEY* phkey);

HRESULT
HrSetupDiSetClassInstallParams(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                               IN PSP_CLASSINSTALL_HEADER pcih,
                               IN DWORD cbSize);

HRESULT
HrSetupDiGetFixedSizeClassInstallParams(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        PSP_CLASSINSTALL_HEADER pcih,
                                        int cbSize);

HRESULT
HrSetupDiGetSelectedDriver(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                           OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiGetDriverInfoDetail(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                             IN PSP_DRVINFO_DATA pdrid,
                             OUT PSP_DRVINFO_DETAIL_DATA* ppdridd);

HRESULT
HrSetupDiSetSelectedDriver(IN HDEVINFO hdi, IN PSP_DEVINFO_DATA pdeid,
                           IN OUT PSP_DRVINFO_DATA pdrid);

HRESULT
HrSetupDiCreateDevRegKey(IN HDEVINFO hdi,
                         IN PSP_DEVINFO_DATA pdeid, IN DWORD dwScope,
                         IN DWORD dwHwProfile, IN DWORD dwKeyType,
                         IN HINF hinf,
                         PCWSTR szInfSectionName,
                         OUT HKEY* phkey);


HRESULT
HrSetupDiGetActualSectionToInstall(IN HINF hinf,
                                   IN PCWSTR szSectionName,
                                   OUT tstring* pstrActualSectionName,
                                   OUT tstring* pstrExtension OPTIONAL);

HRESULT
HrSetupDiGetActualSectionToInstallWithAlloc(IN HINF hinf,
                                            IN PWSTR pszSection,
                                            OUT PWSTR* ppszActualSection,
                                            OUT PWSTR* ppszExtension OPTIONAL);


HRESULT
HrSetupDiGetActualSectionToInstallWithBuffer(
    IN  HINF hinf,
    IN  PCWSTR pszSection,
    OUT PWSTR  pszActualSection,
    IN  DWORD  cchActualSection,
    OUT DWORD* pcchRequired,
    OUT PWSTR* ppszExtension OPTIONAL);

HRESULT
HrSetupDiGetDeviceInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                OUT PSP_DEVINSTALL_PARAMS pdeip);

HRESULT
HrSetupDiGetDriverInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DRVINFO_DATA pdrid,
                                OUT PSP_DRVINSTALL_PARAMS pdrip);


void
SetupDiSetConfigFlags(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid, DWORD dwFlags,
                      SD_FLAGS_BINARY_OP eOp);

HRESULT
HrSetupDiSetDeviceInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DEVINSTALL_PARAMS pdeip);

HRESULT
HrSetupDiSetDriverInstallParams(IN const HDEVINFO hdi,
                                IN const PSP_DEVINFO_DATA pdeid, OPTIONAL
                                IN const PSP_DRVINFO_DATA pdrid,
                                IN const PSP_DRVINSTALL_PARAMS pdrip);

HRESULT
HrSetupDiSetDeipFlags(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                      DWORD dwFlags, SD_DEID_FLAG_TYPE eFlagType,
                      SD_FLAGS_BINARY_OP eOp);

HRESULT
HrSetupDiRemoveDevice(IN HDEVINFO hdi,
                      IN PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiOpenDeviceInfo(IN const HDEVINFO hdi,
                        IN PCWSTR szPnpInstanceId,
                        IN HWND hwndParent, IN DWORD dwOpenFlags,
                        OUT PSP_DEVINFO_DATA pdeid OPTIONAL);

HRESULT
HrSetupDiCreateDeviceInfoList(const GUID* pguidClass, HWND hwndParent,
                              HDEVINFO* phdi);

HRESULT
HrSetupDiGetDeviceName(IN HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                       OUT PWSTR* ppszName);

HRESULT
HrSetupDiSetDeviceName (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN PCWSTR szDeviceName);

HRESULT
HrSetupDiGetDeviceRegistryPropertyWithAlloc(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE** ppbBuffer);

HRESULT
HrSetupDiGetDeviceRegistryProperty(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN DWORD dwProperty,
    OUT DWORD* pdwRegType, OPTIONAL
    OUT BYTE* pbBuffer,
    IN DWORD cbBufferSize,
    OUT DWORD* pcbRequiredSize OPTIONAL
    );

HRESULT
HrSetupDiSetDeviceRegistryProperty(IN HDEVINFO hdi,
                                   IN OUT PSP_DEVINFO_DATA pdeid,
                                   IN DWORD dwProperty,
                                   IN const BYTE* pbBuffer,
                                   IN DWORD cbSize);
HRESULT
HrSetupDiSendPropertyChangeNotification(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                        DWORD dwStateChange, DWORD dwScope,
                                        DWORD dwProfileId);

BOOL
FSetupDiCheckIfRestartNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

HRESULT
HrSetupDiGetClassImageList(PSP_CLASSIMAGELIST_DATA pcild);

HRESULT
HrSetupDiDestroyClassImageList(PSP_CLASSIMAGELIST_DATA pcild);

VOID
SetupDiDestroyDeviceInfoListSafe(HDEVINFO hdi);

HRESULT
HrSetupDiGetClassImageIndex(PSP_CLASSIMAGELIST_DATA pcild,
                            const GUID* pguidClass, INT* pnIndex);


HRESULT
HrSetupDiGetParentWindow(IN const HDEVINFO hdi,
                         IN const PSP_DEVINFO_DATA pdeid,
                         OUT HWND* phwndParent);


HRESULT
HrSetupInstallFilesFromInfSection(HINF hinf, HINF hinfLayout, HSPFILEQ hfq,
                                  PCWSTR szSection, PCWSTR szSourcePath,
                                  UINT ulFlags);

HRESULT
HrSetupInstallFromInfSection(HWND hwnd, HINF hinf, PCWSTR szSection,
                             UINT ulFlags, HKEY hkey, PCWSTR szSource,
                             UINT ulCopyFlags, PSP_FILE_CALLBACK pfc,
                             PVOID pvCtx, HDEVINFO hdi,
                             PSP_DEVINFO_DATA pdeid);
HRESULT
HrSetupInstallServicesFromInfSection(HINF hinf, PCWSTR szSection,
                                     DWORD dwFlags);

HRESULT
HrFindDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR     pszwReferenceString,
    DWORD       dwFlagsAndAttributes,
    HANDLE*     phFile);

HRESULT
HrInstallSoftwareDeviceOnInterface (
    const GUID* pguidDeviceId,
    const GUID* pguidInterfaceId,
    PCWSTR     pszwReferenceString,
    BOOL        fForceInstall,
    PCWSTR     pszwInfFilename,
    HWND        hwndParent);

#if defined(REMOTE_BOOT)
HRESULT
HrIsRemoteBootAdapter(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);
#endif

//+---------------------------------------------------------------------------
//
//  Class:      CSetupInfFile
//
//  Purpose:    Handles operations on an INF file.
//
//  Justification:
//      This is a class instead of seperate functions to allow us to move
//      towards the error handling model associated with throwing exceptions.
//      That is, when one of these objects is declared on the stack, and
//      an exception is thrown, it will clean itself up.  (This object
//      does NOT explicitly throw any exceptions.)
//
class CSetupInfFile
{
public:
    CSetupInfFile   ();
    ~CSetupInfFile  ()  { EnsureClosed(); }

    void    Close   ();
    HRESULT HrOpen  (PCWSTR pszFileName, PCWSTR pszInfClass,
                     DWORD dwInfStyle, UINT* punErrorLine);

    HINF    Hinf ();

    HRESULT HrGetDword              (PCWSTR pszSection, PCWSTR pszKey,
                                     DWORD* pdwValue);
    HRESULT HrGetString             (PCWSTR pszSection, PCWSTR pszKey,
                                     tstring* pstr);
    HRESULT HrGetStringAsBool       (PCWSTR pszSection, PCWSTR pszKey,
                                     BOOL* pfValue);
    HRESULT HrGetStringMapToDword   (PCWSTR pszSection, PCWSTR pszKey,
                                     const MAP_SZ_DWORD* aMapSzDword,
                                     UINT cMapSzDword,
                                     DWORD* pdwValue);
    HRESULT HrGetMultiSzMapToDword  (PCWSTR pszSection, PCWSTR pszKey,
                                     const MAP_SZ_DWORD* aMapSzDword,
                                     UINT cMapSzDword,
                                     DWORD* pdwValue);

protected:
    void    EnsureClosed ();
    HINF    m_hinf;
};


inline CSetupInfFile::CSetupInfFile ()
{
    m_hinf = NULL;
}


inline
HRESULT CSetupInfFile::HrOpen (PCWSTR pszFileName, PCWSTR pszInfClass,
                               DWORD dwInfStyle, UINT* punErrorLine)
{
    AssertSzH (!m_hinf, "You must first close the previous one you opened.");
    return HrSetupOpenInfFile (pszFileName, pszInfClass, dwInfStyle,
                               punErrorLine, &m_hinf);
}

inline HINF CSetupInfFile::Hinf ()
{
    AssertSzH (m_hinf, "You must call HrOpen first.");
    return m_hinf;
}

inline
HRESULT CSetupInfFile::HrGetDword (PCWSTR pszSection, PCWSTR pszKey,
                                   DWORD* pdwValue)
{
    return HrSetupGetFirstDword (Hinf(), pszSection, pszKey, pdwValue);
}

inline
HRESULT CSetupInfFile::HrGetString (PCWSTR pszSection, PCWSTR pszKey,
                                    tstring* pstr)
{
    return HrSetupGetFirstString (Hinf(), pszSection, pszKey, pstr);
}

inline
HRESULT CSetupInfFile::HrGetStringAsBool (PCWSTR pszSection, PCWSTR pszKey,
                                          BOOL* pfValue)
{
    return HrSetupGetFirstStringAsBool (Hinf(), pszSection, pszKey, pfValue);
}

inline
HRESULT CSetupInfFile::HrGetStringMapToDword (PCWSTR pszSection, PCWSTR pszKey,
                                              const MAP_SZ_DWORD* aMapSzDword,
                                              UINT cMapSzDword,
                                              DWORD* pdwValue)
{
    return HrSetupGetFirstStringMapToDword (Hinf(), pszSection, pszKey,
                                            aMapSzDword, cMapSzDword, pdwValue);
}

inline
HRESULT CSetupInfFile::HrGetMultiSzMapToDword (PCWSTR pszSection, PCWSTR pszKey,
                                               const MAP_SZ_DWORD* aMapSzDword,
                                               UINT cMapSzDword,
                                               DWORD* pdwValue)
{
    return HrSetupGetFirstMultiSzMapToDword (Hinf(), pszSection, pszKey,
                                             aMapSzDword, cMapSzDword, pdwValue);
}

inline BOOL
IsValidHandle(HANDLE h)
{
    return (h && INVALID_HANDLE_VALUE != h);
}

// Moved from oemupgrd.h
//
HRESULT HrInstallFromInfSectionInFile(IN HWND    hwndParent,
                                      IN PCWSTR szInfName,
                                      IN PCWSTR szSection,
                                      IN HKEY    hkeyRelative,
                                      IN BOOL    fQuietInstall);

#endif // _NCSETUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncstl.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T L . H
//
//  Contents:   STL utilities.
//
//  Notes:      Pollute this under penalty of death.
//
//  Author:     shaunco   09 Oct 1997
//  Polluter:   deonb     2  Jan 2002.
//
//----------------------------------------------------------------------------

#ifndef _NCSTL_H_
#define _NCSTL_H_

#include "ncmem.h"
#include "list"
#include "vector"
#include "xstring"
#include "string"

using namespace std;

#if defined(USE_CUSTOM_STL_ALLOCATOR) && defined (_DLL)
#error You must statically link to the CRT to use the NetConfig custom STL Allocator
#endif

#ifdef COMPILE_WITH_TYPESAFE_PRINTF
    class CWideString : public wstring
    {
    public:
        CWideString();
        CWideString(WCHAR);
        CWideString(LPCWSTR);
        CWideString(LPCWSTR, size_type);
        CWideString(const CWideString&);
        CWideString(const wstring&);

        CWideString& operator=(const LPWSTR _S)
		    {return *this; }

	    CWideString& operator=(PCWSTR _S)
		    {return *this; }

    private:
        operator void*()
        {
            return this;
        }
    };
#else
    typedef wstring CWideString;
#endif

typedef CWideString tstring; 
typedef list<tstring*> ListStrings;

//+--------------------------------------------------------------------------
//
//  Funct:  DumpListStrings
//
//  Desc:   debug utility function to dump out the given list
//
//  Args:
//
//  Return: (void)
//
//  Notes:
//
// History: 1-Dec-97    SumitC      Created
//
//---------------------------------------------------------------------------
inline
PCWSTR
DumpListStrings(
    IN  const list<tstring *>&  lstr,
    OUT tstring*                pstrOut)
{
    WCHAR szBuf [1024];
    INT i;
    list<tstring *>::const_iterator iter;

    pstrOut->erase();

    for (iter = lstr.begin(), i = 1;
         iter != lstr.end();
         iter++, i++)
    {
        wsprintfW(szBuf, L"   %2i: %s\n", i, (*iter)->c_str());
        pstrOut->append(szBuf);
    }

    return pstrOut->c_str();
}


template<class T>
void
FreeCollectionAndItem (
    T& col)
{
    for(T::iterator iter = col.begin(); iter != col.end(); ++iter)
    {
        T::value_type pElem = *iter;
        delete pElem;
    }

    col.erase (col.begin(), col.end());
}


template<class T>
void
FreeVectorItem (
    vector<T>& v,
    UINT i)
{

    if ((v.size()>0) && (i<v.size()))
    {
       delete v[i];
       vector<T>::iterator iterItem = v.begin() + i;
       v.erase (iterItem);
    }
}


#endif // _NCSTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nctraceui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       N C T R A C E U I . H 
//
//  Contents:   Tracing Property sheet UI prototype
//
//  Notes:      
//
//  Author:     jeffspr   31 Aug 1998
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCTRACEUI_H_
#define _NCTRACEUI_H_

//---[ Prototypes ]-----------------------------------------------------------

HRESULT HrOpenTracingUI(HWND hwndOwner);

#endif // _NCTRACEUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncsvc.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S V C . H
//
//  Contents:   This file contains CService and CServiceManager, wrapper
//              classes to the Win32 Service APIs.
//
//  Notes:      Note that not all functionality is currently extended through
//              these classes.
//
//  Author:     mikemi   6 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCSVC_H_
#define _NCSVC_H_

//  DaveA - 4/21/00 - temporary hack to get bvts to work until final
//                    solution is found. 15 seconds was not long enough
//                    for the workstation and dependent services to stop.
//                    Bug 95996. Two minute timeout will be used instead.
const DWORD c_dwDefaultWaitServiceStop = 120000;

// NTRAID9:105797@20001201#deonb REBOOT: FPS ask for reboot when installing it.
// Changing service start timeout value to 60 seconds instead of 15 seconds as FPS
// requires more time to start all it's dependent services.
const DWORD c_dwDefaultWaitServiceStart = 60000;

struct CSFLAGS
{
    // These two fields define the 'control' to be applied.  NULL both
    // to not apply a control.
    //
    BOOL    fStart;     // TRUE to start the service.  FALSE to use dwControl.
    DWORD   dwControl;  // 0 to do nothing.  SERVICE_CONTROL_ flag otherwise.

    // These two fields define the wait behavior to be applied.  NULL both
    // to not apply a wait.
    //
    DWORD   dwMaxWaitMilliseconds;  // How long to wait in milliseconds.
                                    // Zero to not wait.
    DWORD   dwStateToWaitFor;       // Service state flag like SERVICE_STOPPED

    // If TRUE, ignore services that are demand start or disabled.
    //
    BOOL    fIgnoreDisabledAndDemandStart;
};

HRESULT
HrSvcQueryStatus (
    PCWSTR pszService,
    DWORD*  pdwState);

HRESULT
HrQueryServiceConfigWithAlloc (
    SC_HANDLE               hService,
    LPQUERY_SERVICE_CONFIG* ppConfig);

HRESULT
HrChangeServiceStartType (
    PCWSTR szServiceName,
    DWORD   dwStartType);

HRESULT
HrChangeServiceStartTypeOptional (
    PCWSTR szServiceName,
    DWORD   dwStartType);


class CService
{
    friend class CServiceManager;

public:
    CService()
    {
        _schandle = NULL;
    };

    ~CService()
    {
        Close();
    };

    VOID Close();

    HRESULT HrControl           (DWORD      dwControl);

    HRESULT HrRequestStop       ();

    HRESULT HrQueryServiceConfig (LPQUERY_SERVICE_CONFIG* ppConfig)
    {
        HRESULT hr = HrQueryServiceConfigWithAlloc (_schandle, ppConfig);
        TraceError ("CService::HrQueryServiceConfig", hr);
        return hr;
    }

    HRESULT HrQueryState        ( DWORD* pdwState );
    HRESULT HrQueryStartType    ( DWORD* pdwStartType );
    HRESULT HrSetStartType      ( DWORD dwStartType )
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                    SERVICE_NO_CHANGE,
                    dwStartType,
                    SERVICE_NO_CHANGE,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL))
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetImagePath(IN PCWSTR pszImagePath)
    {
        AssertH(pszImagePath);
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   pszImagePath,       // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   NULL,               // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   NULL))              // DisplayName
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetServiceRestartRecoveryOption(IN SERVICE_FAILURE_ACTIONS *psfa);

    HRESULT HrSetDependencies(IN PCWSTR mszDependencyList)
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   mszDependencyList,  // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   NULL))              // DisplayName
            return S_OK;
        else
            return ::HrFromLastWin32Error();
    }

    HRESULT HrSetDisplayName(IN PCWSTR mszDisplayName)
    {
        AssertH(_schandle != NULL );

        if (::ChangeServiceConfig( _schandle,
                                   SERVICE_NO_CHANGE,  // ServiceType
                                   SERVICE_NO_CHANGE,  // StartType
                                   SERVICE_NO_CHANGE,  // ErrorControl
                                   NULL,               // BinaryPathName
                                   NULL,               // LoadOredrGroup
                                   NULL,               // TagId
                                   NULL,               // Dependencies
                                   NULL,               // ServiceStartName
                                   NULL,               // Password
                                   mszDisplayName))    // DisplayName
        {
            return S_OK;
        }
        else
        {
            return ::HrFromLastWin32Error();
        }
    }

    HRESULT HrSetServiceObjectSecurity(
        SECURITY_INFORMATION    dwSecurityInformation,
        PSECURITY_DESCRIPTOR    lpSecurityDescriptor)
    {
        AssertH(_schandle != NULL );

        if (::SetServiceObjectSecurity( _schandle,
                dwSecurityInformation, lpSecurityDescriptor))
        {
            return S_OK;
        }
        else
        {
            return ::HrFromLastWin32Error();
        }
    }


private:
    SC_HANDLE _schandle;
};

enum CSLOCK
{
    NO_LOCK,
    WITH_LOCK,
};

class CServiceManager
{
public:
    CServiceManager()
    {
        _schandle = NULL;
        _sclock = NULL;
    };

    ~CServiceManager();

    SC_HANDLE Handle () const
    {
        return _schandle;
    }

    HRESULT HrOpen( CSLOCK eLock = NO_LOCK,
                    DWORD dwDesiredAccess = SC_MANAGER_ALL_ACCESS,
                    PCWSTR pszMachineName = NULL,
                    PCWSTR pszDatabaseName = NULL );

    HRESULT HrControlServicesAndWait (
        UINT            cServices,
        const PCWSTR*  apszServices,
        const CSFLAGS*  pFlags);

    HRESULT HrStartServicesNoWait (UINT cServices, const PCWSTR* apszServices);
    HRESULT HrStartServicesAndWait(UINT cServices, const PCWSTR* apszServices, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStart);
    HRESULT HrStopServicesNoWait  (UINT cServices, const PCWSTR* apszServices);
    HRESULT HrStopServicesAndWait (UINT cServices, const PCWSTR* apszServices, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStop);

    HRESULT HrStartServiceNoWait (PCWSTR pszService)
    {
        return HrStartServicesNoWait (1, &pszService);
    }

    HRESULT HrStartServiceAndWait(PCWSTR pszService, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStart)
    {
        return HrStartServicesAndWait (1, &pszService, dwWaitMilliseconds);
    }

    HRESULT HrStopServiceNoWait  (PCWSTR pszService)
    {
        return HrStopServicesNoWait (1, &pszService);
    }

    HRESULT HrStopServiceAndWait (PCWSTR pszService, DWORD dwWaitMilliseconds = c_dwDefaultWaitServiceStop)
    {
        return HrStopServicesAndWait (1, &pszService, dwWaitMilliseconds);
    }

    VOID Close();

    HRESULT HrLock();

    VOID Unlock();

    HRESULT HrQueryLocked (BOOL*    pfLocked);

    HRESULT HrOpenService (
                CService*   pcsService,
                PCWSTR     pszServiceName,
                CSLOCK      eLock = NO_LOCK,
                DWORD       dwScmAccess = SC_MANAGER_ALL_ACCESS,
                DWORD       dwSvcAccess = SERVICE_ALL_ACCESS);

    HRESULT HrCreateService (CService* pcsService,
            PCWSTR pszServiceName,
            PCWSTR pszDisplayName,
            DWORD dwServiceType,
            DWORD dwStartType,
            DWORD dwErrorControl,
            PCWSTR pszBinaryPathName,
            PCWSTR pslzDependencies = NULL,
            PCWSTR pszLoadOrderGroup = NULL,
            PDWORD pdwTagId = NULL,
            DWORD dwDesiredAccess = SERVICE_ALL_ACCESS,
            PCWSTR pszServiceStartName = NULL,
            PCWSTR pszPassword = NULL,
            PCWSTR pszDescription = NULL);

    enum SERVICE_START_CRITERIA
    {
        SERVICE_NO_CRITERIA,    // Start the service regardless
        SERVICE_ONLY_AUTO_START // Only start the service if it is of type
                                // Auto-Start
    };

    enum DEPENDENCY_ADDREMOVE
    {
        DEPENDENCY_ADD,
        DEPENDENCY_REMOVE
    };

    HRESULT HrAddServiceDependency(PCWSTR szServiceName, PCWSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_ADD);
    }

    HRESULT HrRemoveServiceDependency(PCWSTR szServiceName, PCWSTR szDependency)
    {
        return HrAddRemoveServiceDependency(szServiceName,
                                            szDependency,
                                            DEPENDENCY_REMOVE);
    }

    HRESULT HrAddRemoveServiceDependency(PCWSTR szServiceName,
                                         PCWSTR szDependency,
                                         DEPENDENCY_ADDREMOVE enumFlag);

private:
    SC_HANDLE _schandle;
    SC_LOCK   _sclock;
};

#endif // _NCSVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncstring.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C S T R I N G . H
//
//  Contents:   Common string routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncdebug.h"
#include "ncvalid.h"
#include "ncmsz.h"
#include "ncstl.h"


const int c_cchGuidWithTerm = 39; // includes terminating null
const int c_cbGuidWithTerm   = c_cchGuidWithTerm * sizeof(WCHAR);


inline ULONG CbOfSz         (PCWSTR psz)   { AssertH(psz); return wcslen (psz) * sizeof(WCHAR); }
inline ULONG CbOfSza        (PCSTR  psza)  { AssertH(psza); return strlen (psza) * sizeof(CHAR); }

inline ULONG CbOfSzAndTerm  (PCWSTR psz)   { AssertH(psz); return (wcslen (psz) + 1) * sizeof(WCHAR); }
inline ULONG CbOfSzaAndTerm (PCSTR  psza)  { AssertH(psza); return (strlen (psza) + 1) * sizeof(CHAR); }

ULONG CbOfSzSafe            (PCWSTR psz);
ULONG CbOfSzaSafe           (PCSTR  psza);

ULONG CbOfSzAndTermSafe     (PCWSTR psz);
ULONG CbOfSzaAndTermSafe    (PCSTR  psza);

ULONG
CchOfSzSafe (
    PCWSTR psz);

inline ULONG CchToCb        (ULONG cch)     { return cch * sizeof(WCHAR); }


struct MAP_SZ_DWORD
{
    PCWSTR pszValue;
    DWORD  dwValue;
};


PWSTR
PszAllocateAndCopyPsz (
    PCWSTR pszSrc);

extern const WCHAR c_szEmpty[];

template<class T>
VOID
ConvertStringToColString (
    IN  PCWSTR psz,
    IN  const WCHAR chSeparator,
    OUT T& coll)
{
    AssertSz(chSeparator, "Separator can not be \0");

    FreeCollectionAndItem(coll);

    if (NULL == psz)
    {
        return;
    }

    PWSTR  pszBuf = new WCHAR[wcslen(psz) + 1];

    wcscpy(pszBuf, psz);
    WCHAR* pchString = pszBuf;
    WCHAR* pchSeparator;
    while (*pchString)
    {
        pchSeparator = wcschr(pchString, chSeparator);
        if (pchSeparator)
        {
            *pchSeparator = 0;
        }

        if (*pchString)
        {
            coll.push_back(new tstring(pchString));
        }

        if (pchSeparator)
        {
            pchString = pchSeparator + 1;
        }
        else
        {
            break;
        }
    }

    delete [] pszBuf;
}


template<class T>
VOID
ConvertColStringToString (
    IN  const T& coll,
    IN  const WCHAR chSeparator,
    OUT tstring& str)
{
    AssertSz(chSeparator, "Separator can not be \0");

    if (chSeparator)
    {
        T::const_iterator iter = coll.begin();

        while (iter != coll.end())
        {
            str += (*iter)->c_str();

            ++iter;
            if (iter != coll.end())
            {
                str += chSeparator;
            }
        }
    }
}


DWORD
WINAPIV
DwFormatString (
    PCWSTR pszFmt,
    PWSTR  pszBuf,
    DWORD   cchBuf,
    ...);

DWORD
WINAPIV
DwFormatStringWithLocalAlloc (
    PCWSTR pszFmt,
    PWSTR* ppszBuf,
    ...);

enum NC_IGNORE_SPACES
{
    NC_IGNORE,
    NC_DONT_IGNORE,
};


BOOL
FFindStringInCommaSeparatedList (
    PCWSTR pszSubString,
    PCWSTR pszList,
    NC_IGNORE_SPACES eIgnoreSpaces,
    DWORD* pdwPosition);

enum NC_FIND_ACTION
{
    NC_NO_ACTION,
    NC_REMOVE_FIRST_MATCH,
    NC_REMOVE_ALL_MATCHES,
};

inline BOOL
FFindFirstMatch (
    NC_FIND_ACTION eAction)
{
    return (NC_NO_ACTION == eAction) || (NC_REMOVE_FIRST_MATCH == eAction);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsBstrEmpty
//
//  Purpose:    Determines if the given BSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsBstrEmpty (
    BSTR    bstr)
{
    return !(bstr && *bstr);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsStrEmpty
//
//  Purpose:    Determines if the given PCWSTR is "empty" meaning the pointer
//              is NULL or the string is 0-length.
//
//  Arguments:
//      bstr [in]   BSTR to check.
//
//  Returns:    TRUE if the BSTR is empty, FALSE if not.
//
//  Author:     danielwe   20 May 1997
//
//  Notes:
//
inline
BOOL
FIsStrEmpty (
    PCWSTR    psz)
{
    return !(psz && *psz);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsPrefix
//
//  Purpose:    Returns whether a string is a prefix of another string.
//
//  Arguments:
//      pszPrefix [in]   Potential prefix
//      pszString [in]   String that may begin with the prefix
//
//  Returns:    TRUE if given prefix string is a prefix of the target string.
//
//  Author:     danielwe   24 Mar 1997
//
//  Notes:      Uses CompareString with the default locale.
//
inline
BOOL
FIsPrefix (
    PCWSTR pszPrefix,
    PCWSTR pszString)
{
    Assert (pszPrefix);
    Assert (pszString);

    return (0 == _wcsnicmp(pszPrefix, pszString, wcslen(pszPrefix)));
}

BOOL
FIsSubstr (
    PCWSTR pszSubString,
    PCWSTR pszString);

HRESULT
HrAddStringToDelimitedSz (
    PCWSTR pszAddString,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    DWORD dwStringIndex,
    PWSTR* ppszOut);

HRESULT
HrRemoveStringFromDelimitedSz (
    PCWSTR pszRemove,
    PCWSTR pszIn,
    WCHAR chDelimiter,
    DWORD dwFlags,
    PWSTR* ppszOut);


//+---------------------------------------------------------------------------
//
//  Function:   template<class T> ColStringToMultiSz
//
//  Purpose:    Convert an STL collection of tstring pointers to a multi-sz.
//
//  Arguments:
//      listStr [in]    list of tstring pointers to put in the multi-sz.
//      ppszOut [out]   the returned multi-sz.
//
//  Returns:    nothing.
//
//  Author:     shaunco   10 Apr 1997
//
//  Notes:      The output multi-sz should be freed using delete.
//
template<class T>
VOID
ColStringToMultiSz (
    const T&    colStr,
    PWSTR*     ppszOut)
{
    Assert (ppszOut);

    // Count up the count of characters consumed by the list of strings.
    // This count includes the null terminator of each string.
    //
    T::const_iterator iter;
    UINT cch = 0;
    for (iter = colStr.begin(); iter != colStr.end(); iter++)
    {
        tstring* pstr = *iter;
        if (!pstr->empty())
        {
            cch += (UINT)(pstr->length() + 1);
        }
    }

    if (cch)
    {
        // Allocate the multi-sz.  Assumes new will throw on error.
        //
        PWSTR pszOut = new WCHAR [cch + 1];
        *ppszOut = pszOut;

        // Copy the strings to the multi-sz.
        //
        for (iter = colStr.begin(); iter != colStr.end(); iter++)
        {
            tstring* pstr = *iter;
            if (!pstr->empty())
            {
                lstrcpyW (pszOut, pstr->c_str());
                pszOut += pstr->length() + 1;
            }
        }

        // Null terminate the multi-sz.
        Assert (pszOut == *ppszOut + cch);
        *pszOut = 0;
    }
    else
    {
        *ppszOut = NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> DeleteColString
//
//  Purpose:    Empty a list of tstring and delete each tstring as it is
//              removed.
//
//  Arguments:
//      pcolstr [inout] Collection of tstring pointers to delete and empty
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
// template<class T>
// VOID
// DeleteColString (
//     T*  pcolstr)

VOID
DeleteColString (
     list<tstring*>* pcolstr);

VOID
DeleteColString (
     vector<tstring*>* pcolstr);

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> MultiSzToColString
//
//  Purpose:    Convert an multi-sz buffer to a STL collection of tstring
//              pointers.
//
//  Arguments:
//      pmsz    [in]    the multi-sz to convert (Can be NULL)
//      pcolstr [out]   list of tstring pointers to add allocated tstrings to
//
//  Returns:    nothing
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:      The output collection should be freed using DeleteColString.
//              This function will delete the collection list passed
//
template<class T>
VOID
MultiSzToColString (
    PCWSTR pmsz,
    T*      pcolstr)
{
    Assert (pcolstr);

    if (!pcolstr->empty())
    {
        DeleteColString (pcolstr);
    }

    if (pmsz)
    {
        while (*pmsz)
        {
            tstring* pstr = new tstring;
            if (pstr)
            {
                *pstr = pmsz;
                pcolstr->push_back (pstr);
            }
            // get the next string even if new failed
            pmsz += lstrlen (pmsz) + 1;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> RemoveDupsInColPtr
//
//  Purpose:    Remove all duplicate entries in an STL collection of pointers
//              to objects.
//
//  Arguments:
//      pcol [inout]    Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     mikemi   03 May 1997
//
//  Notes:      The objects pointed at should have a comparison operator
//
template<class T>
VOID
RemoveDupsInColPtr (
    T*  pcol)
{
    Assert (pcol);

    // remove duplicates
    //
    T::iterator     posItem;
    T::iterator     pos;
    T::value_type   pItem;
    T::value_type   p;

    posItem = pcol->begin();
    while (posItem != pcol->end())
    {
        pItem = *posItem;

        // for every other item, remove the duplicates
        pos = posItem;
        pos++;
        while (pos != pcol->end())
        {
            p = *pos;

            if ( *pItem == *p )
            {
                pos = pcol->erase( pos );
                delete p;
            }
            else
            {
                pos++;
            }
        }
        // increment afterwards due to fact that we are removing,
        // and otherwise could have removed the item it pointed to
        posItem++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   template<class T> CopyColPtr
//
//  Purpose:    Copies one collection of pointers into another.
//
//  Arguments:
//      pcolDest [out]  Collection of pointers to objects.
//      pcolSrc  [in]   Collection of pointers to objects.
//
//  Returns:    nothing
//
//  Author:     BillBe   13 Jun 1998
//
//  Notes:
//
template<class T>
VOID
CopyColPtr (T* pcolDest, const T& colSrc)
{
    Assert (pcolDest);

    T::iterator     posItem;

    // Clear out destination
    pcolDest->erase(pcolDest->begin(), pcolDest->end());

    // Go through each item in pcolSrc and add to pcolDest
    //
    posItem = colSrc.begin();
    while (posItem != colSrc.end())
    {
        pcolDest->push_back(*posItem);
        posItem++;
    }
}


PCWSTR
SzLoadStringPcch (
    HINSTANCE   hinst,
    UINT        unId,
    int*        pcch);

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//
//  Notes:      See SzLoadStringPcch()
//
inline
PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return SzLoadStringPcch(hinst, unId, &cch);
}

PSTR
SzaDupSza (
    IN PCSTR  pszaSrc);

PWSTR
SzDupSz (
    IN PCWSTR pszSrc);

#define GetNextCommaSeparatedToken(pStart, pEnd, cch)                   \
    pStart = pEnd;                                                      \
    while (*pStart && (*pStart == L' ' || *pStart == L','))   \
    {                                                                   \
        pStart++;                                                       \
    }                                                                   \
                                                                        \
    pEnd = pStart;                                                      \
    while (*pEnd && *pEnd != L' ' && *pEnd != L',')           \
    {                                                                   \
        pEnd++;                                                         \
    }                                                                   \
                                                                        \
    cch = (DWORD)(pEnd - pStart);

BOOL
FSubstringMatch (
    IN PCWSTR pStr1,
    IN PCWSTR pStr2,
    OUT const WCHAR** ppStart,
    OUT ULONG* pcch);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncreg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E G . H
//
//  Contents:   Common routines for dealing with the registry.
//
//  Notes:
//
//  Author:     danielwe   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCREG_H_
#define _NCREG_H_

#include "ncstring.h"

// constants for HrRegQueryStringAsUlong
const int c_nBase10 = 10;
const int c_nBase16 = 16;
const int c_cchMaxRegKeyLengthWithNull = 257;

const DWORD KEY_READ_WRITE_DELETE = KEY_READ | KEY_WRITE | DELETE;
const DWORD KEY_READ_WRITE = KEY_READ | KEY_WRITE;

HRESULT
HrRegAddStringToMultiSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN DWORD   dwFlags,
    IN DWORD   dwIndex);

HRESULT
HrRegAddStringToSz (
    IN PCWSTR  pszAddString,
    IN HKEY    hkeyRoot,
    IN PCWSTR  pszKeySubPath,
    IN PCWSTR  pszValueName,
    IN WCHAR   chDelimiter,
    IN DWORD   dwFlags,
    IN DWORD   dwStringIndex);

HRESULT
HrRegCopyHive (
    IN HKEY    hkeySrc,
    IN HKEY    hkeyDst);

HRESULT
HrRegCreateKeyEx (
    IN HKEY hkey,
    IN PCWSTR pszSubkey,
    IN DWORD dwOptions,
    IN REGSAM samDesired,
    IN LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    OUT PHKEY phkResult,
    OUT LPDWORD pdwDisposition);

HRESULT
HrRegDeleteKey (
    IN HKEY hkey,
    IN PCWSTR pszSubkey);

HRESULT
HrRegDeleteKeyTree (
    IN HKEY hkeyParent,
    IN PCWSTR pszRemoveKey);

HRESULT
HrRegDeleteValue (
    IN HKEY hkey,
    IN PCWSTR pszValueName);

HRESULT
HrRegEnumKey (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    IN DWORD cchSubkeyName);

HRESULT
HrRegEnumKeyEx (
    IN HKEY hkey,
    IN DWORD dwIndex,
    OUT PWSTR  pszSubkeyName,
    OUT LPDWORD pcchSubkeyName,
    OUT PWSTR  pszClass,
    OUT LPDWORD pcchClass,
    OUT FILETIME* pftLastWriteTime);

HRESULT
HrRegEnumValue (
    HKEY hkey,
    DWORD dwIndex,
    PWSTR  pszValueName,
    LPDWORD pcbValueName,
    LPDWORD pdwType,
    LPBYTE  pbData,
    LPDWORD pcbData);

HRESULT
HrRegOpenKeyEx (
    HKEY hkey,
    PCWSTR pszSubkey,
    REGSAM samDesired,
    PHKEY phkResult);

HRESULT
HrRegOpenKeyBestAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    PHKEY phkResult);

HRESULT
HrRegDuplicateKeyEx (
    HKEY hkey,
    REGSAM samDesired,
    PHKEY phkResult);



HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue);

HRESULT
HrRegQueryDword (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPDWORD pdwValue);

HRESULT
HrRegQueryExpandString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstrValue);

HRESULT
HrRegQueryInfoKey (
    HKEY        hkey,
    PWSTR       pszClass,
    LPDWORD     pcbClass,
    LPDWORD     pcSubKeys,
    LPDWORD     pcbMaxSubKeyLen,
    LPDWORD     pcbMaxClassLen,
    LPDWORD     pcValues,
    LPDWORD     pcbMaxValueNameLen,
    LPDWORD     pcbMaxValueLen,
    LPDWORD     pcbSecurityDescriptor,
    PFILETIME   pftLastWriteTime);

HRESULT
HrRegQueryStringAsUlong (
    HKEY        hkey,
    PCWSTR      pszValueName,
    int         nBase,
    ULONG*      pulValue);

HRESULT
HrRegQueryTypeString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    DWORD       dwType,
    tstring*    pstr);

HRESULT
HrRegQueryTypeSzBuffer (
    HKEY    hkey,
    PCWSTR  pszValueName,
    DWORD   dwType,
    PWSTR   pszData,
    DWORD*  pcbData);

HRESULT
HrRegQueryValueEx (
    HKEY        hkey,
    PCWSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE      pbData,
    LPDWORD     pcbData);

HRESULT
HrRegQueryValueWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    LPDWORD     pdwType,
    LPBYTE*     ppbBuffer,
    LPDWORD     pdwSize);


HRESULT HrRegGetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor,
    LPDWORD                 lpcbSecurityDescriptor
    );

HRESULT HrRegSetKeySecurity (
    HKEY                    hKey,
    SECURITY_INFORMATION    SecurityInformation,
    PSECURITY_DESCRIPTOR    pSecurityDescriptor
    );

inline
HRESULT
HrRegQueryString (
    HKEY        hkey,
    PCWSTR      pszValueName,
    tstring*    pstr)
{
    return HrRegQueryTypeString (hkey, pszValueName, REG_SZ, pstr);
}


HRESULT
HrRegQueryTypeWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    DWORD       dwType,
    LPBYTE*     ppbValue,
    DWORD*      pcbValue);

inline
HRESULT
HrRegQueryBinaryWithAlloc (
    HKEY    hkey,
    PCWSTR  pszValueName,
    LPBYTE* ppbValue,
    DWORD*  pcbValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_BINARY,
                ppbValue, pcbValue);
}


inline
HRESULT
HrRegQueryMultiSzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_MULTI_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQuerySzWithAlloc (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR*      pszValue)
{
    return HrRegQueryTypeWithAlloc (hkey, pszValueName, REG_SZ,
                (LPBYTE*)pszValue, NULL);
}

inline
HRESULT
HrRegQueryExpandSzBuffer (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_EXPAND_SZ,
                pszData, pcbData);
}

inline
HRESULT
HrRegQuerySzBuffer (
    HKEY        hkey,
    PCWSTR      pszValueName,
    PWSTR       pszData,
    DWORD*      pcbData)
{
    return HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_SZ,
                pszData, pcbData);
}

HRESULT HrRegSaveKey(HKEY hkey, PCWSTR szFileName,
                     LPSECURITY_ATTRIBUTES psa);

HRESULT HrRegSetValueEx (HKEY hkey,
                         PCWSTR szValueName,
                         DWORD dwType,
                         const BYTE *pbData,
                         DWORD cbData);

HRESULT HrRegRemoveStringFromSz(    PCWSTR      pszRemoveString,
                                    HKEY        hkeyRoot,
                                    PCWSTR      pszKeySubPath,
                                    PCWSTR      pszValueName,
                                    WCHAR       chDelimiter,
                                    DWORD       dwFlags );

HRESULT HrRegRemoveStringFromMultiSz (PCWSTR pszRemoveString,
                                      HKEY   hkeyRoot,
                                      PCWSTR pszKeySubPath,
                                      PCWSTR pszValueName,
                                      DWORD  dwFlags);

HRESULT HrRegRestoreKey(HKEY hkey, PCWSTR pszFileName, DWORD dwFlags);


HRESULT HrRegOpenAdapterKey(
        PCWSTR pszComponentName,
        BOOL fCreate,
        HKEY* phkey);

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetColString
//
//  Purpose:    Sets a multi-sz in the registry using the collection of strings
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      colstr       [in]    The collection of tstrings to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     mikemi   30 Apr 1997
//
//  Notes:
//
//---------------------------------------------------------------------------

// template<class T>
// HRESULT HrRegSetColString(HKEY hkey, PCWSTR pszValueName, const T& colstr);

// template<class T>
// HRESULT HrRegQueryColString( HKEY hkey, PCWSTR pszValueName, T* pcolstr );

HRESULT HrRegSetColString(IN HKEY hkey, IN PCWSTR pszValueName, IN const list<tstring*>& colstr);
HRESULT HrRegSetColString(IN HKEY hkey, IN PCWSTR pszValueName, IN const vector<tstring*>& colstr);

HRESULT HrRegQueryColString(IN HKEY hkey, IN PCWSTR pszValueName, OUT list<tstring*>* pcolstr );
HRESULT HrRegQueryColString(IN HKEY hkey, IN PCWSTR pszValueName, OUT vector<tstring*>* pcolstr );

HRESULT
HrRegSetBool (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN BOOL fValue);

HRESULT
HrRegSetDword (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwValue);

HRESULT
HrRegSetGuidAsSz (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN const GUID& guid);

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetMultiSz
//
//  Purpose:    Sets a multi-sz in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pszValue     [in]    The multi-sz to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetMultiSz (HKEY hkey, PCWSTR pszValueName, PCWSTR pszValue)
{
    return HrRegSetValueEx (
                hkey,
                pszValueName,
                REG_MULTI_SZ,
                (LPBYTE)pszValue,
                (CchOfMultiSzAndTermSafe (pszValue) * sizeof(WCHAR)));
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSz, HrRegSetString
//
//  Purpose:    Sets a string in the registry.  Assures that its type and
//              size are correct.  Easier to read than HrRegSetValueEx
//              with 5 parameters.  Type safe (no LPBYTE stuff).
//
//  Arguments:
//      hkey          [in]   The registry key.
//      pszValueName  [in]   The name of the value to set.
//      pszValue, str [in]   The string to set.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     shaunco   1 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetSz (HKEY hkey, PCWSTR pszValueName, PCWSTR pszValue)
{
    return HrRegSetValueEx (hkey, pszValueName, REG_SZ,
                            (LPBYTE)pszValue,
                            CbOfSzAndTermSafe (pszValue));
}

inline HRESULT HrRegSetString (HKEY hkey, PCWSTR pszValueName, const tstring& str)
{
    return HrRegSetSz (hkey, pszValueName, str.c_str());
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetBinary
//
//  Purpose:    Sets a binary value into the registry. Assures the type is
//              correct.
//
//  Arguments:
//      hkey         [in]    The registry key.
//      pszValueName [in]    The name of the value to set.
//      pbData       [in]    Buffer containing binary data to write.
//      cbData       [in]    Size of buffer in bytes.
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     danielwe   16 Apr 1997
//
//  Notes:
//
inline HRESULT HrRegSetBinary(HKEY hkey, PCWSTR pszValueName,
                              const BYTE *pbData, DWORD cbData)
{
    return HrRegSetValueEx(hkey, pszValueName, REG_BINARY,
                           pbData, cbData);
}

//+---------------------------------------------------------------------------
//
//  Function:   HrRegSetSzAsUlong
//
//  Purpose:    Writes the given ulong to the given registry value as a
//              REG_SZ.
//
//  Arguments:
//      hkey         [in] See Win32 docs.
//      pszValueName [in] See Win32 docs.
//      ulValue      [in] The value to write as a string
//      nBase        [in] The radix to convert the ulong from
//
//  Returns:    S_OK or an HRESULT_FROM_WIN32 error code.
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
inline
HRESULT
HrRegSetSzAsUlong (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN ULONG ulValue,
    IN int nBase)
{
    WCHAR szBuffer[33];

    // convert the value to a string using the specified base
    _ultow(ulValue, szBuffer, nBase);

    return HrRegSetSz(hkey, pszValueName, szBuffer);
}



//
//  Data structures
//

const HKEY      HKLM_SVCS       = (HKEY)(INT_PTR)(int)(0x80000007);

const DWORD     REG_MIN         = REG_QWORD;
const DWORD     REG_CREATE      = (REG_MIN + 1);
const DWORD     REG_BOOL        = (REG_MIN + 2);
const DWORD     REG_IP          = (REG_MIN + 3);
const DWORD     REG_FILE        = (REG_MIN + 4);
const DWORD     REG_HEX         = (REG_MIN + 5);

struct VALUETABLE
{
    // Name of value key
    PCWSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

struct REGBATCH
{
    // Location of the registry entry
    HKEY            hkey;
    PCWSTR          pszSubkey;
    PCWSTR          pszValueName;

    // Data and offset location
    DWORD           dwType;
    INT             cbOffset;

    // Default values
    BYTE*           pbDefault;
};

VOID
RegReadValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    OUT const BYTE* pbUserData,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValues (
    IN INT crvc,
    IN const REGBATCH* arb,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

HRESULT
HrRegWriteValueTable(
    IN HKEY hkeyRoot,
    IN INT cvt,
    IN const VALUETABLE* avt,
    IN const BYTE* pbUserData,
    IN DWORD dwOptions,
    IN REGSAM samDesired);

VOID
RegSafeCloseKey (
    IN HKEY hkey);

#endif // _NCREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncvalid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C V A L I D . H
//
//  Contents:   Generic validation functions.
//
//  Notes:
//
//  Author:     danielwe   19 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCVALID_H_
#define _NCVALID_H_


#define FBadInPtr(_p)           IsBadReadPtr(_p, sizeof(*_p))
#define FBadOutPtr(_p)          IsBadWritePtr(_p, sizeof(*_p))

#define FBadInPtrOptional(_p)   ((NULL != _p) && IsBadReadPtr(_p, sizeof(*_p)))
#define FBadOutPtrOptional(_p)  ((NULL != _p) && IsBadWritePtr(_p, sizeof(*_p)))


inline BOOL FBadInRefiid (REFIID riid)
{
    return IsBadReadPtr(&riid, sizeof(IID));
}


#endif // _NCVALID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\ncui.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C U I . H
//
//  Contents:   Common user interface routines.
//
//  Notes:
//
//  Author:     shaunco   24 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NCUI_H_
#define _NCUI_H_

#include "ncbase.h"

inline
HCURSOR
BeginWaitCursor ()
{
    return SetCursor(LoadCursor(NULL, IDC_WAIT));
}

inline
VOID
EndWaitCursor (
    HCURSOR hcurPrev)
{
    // BeginWaitCursor may return a NULL cursor.  This is just
    // a saftey net.
    //
    if (!hcurPrev)
    {
        hcurPrev = LoadCursor(NULL, IDC_ARROW);
    }
    SetCursor(hcurPrev);
}

// To get an automatic wait cursor, simply declare an instance
// of CWaitCursor.  The cursor will be restored when the instance is
// destroyed.  (i.e. declare it on the stack.)
//
class CWaitCursor
{
private:
    HCURSOR m_hcurPrev;

public:
    CWaitCursor  ()  { m_hcurPrev = BeginWaitCursor (); }
    ~CWaitCursor ()  { EndWaitCursor (m_hcurPrev); }
};


//
// Enables or disables a set of controls in a dialog.
//
// Use this when you're enabling/disabling more than about two controls.
// Be sure to declare the array of control ids as 'static const' if you can.
//
NOTHROW
VOID
EnableOrDisableDialogControls (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    BOOL fEnable);


//
// Map back and forth between a set of radio buttons and a DWORD value.
//
// Be sure to declare the array as 'static const' if you can.
//
struct RADIO_BUTTON_MAP
{
    INT     cid;        // control id of radio button
    DWORD   dwValue;    // value associated with this radio button
};

NOTHROW
BOOL
FMapRadioButtonToValue (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD*                  pdwValue);

NOTHROW
BOOL
FMapValueToRadioButton (
    HWND                    hDlg,
    INT                     crbm,
    const RADIO_BUTTON_MAP* arbm,
    DWORD                   dwValue,
    INT*                    pncid);

INT
GetIntegerFormat (
    LCID    Locale,
    PCWSTR pszValue,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format32bitInteger (
    UINT32  unValue,
    BOOL    fSigned,
    PWSTR  pszFormattedValue,
    INT     cchFormattedValue);

INT
Format64bitInteger (
    UINT64   ulValue,
    BOOL     fSigned,
    PWSTR   pszFormattedValue,
    INT      cchFormattedValue);

BOOL
SetDlgItemFormatted32bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT32  unValue,
    BOOL    fSigned);

BOOL
SetDlgItemFormatted64bitInteger (
    HWND    hDlg,
    INT     nIdDlgItem,
    UINT64  ulValue,
    BOOL    fSigned);

// dwFlags for HrNcQueryUserForRebootEx
//
// Combine both to get original behavior, or do one at a time to first prompt
// then second, actually reboot.
//
//#define QUFR_PROMPT 0x00000001
//#define QUFR_REBOOT 0x00000002

HRESULT
HrNcQueryUserForRebootEx (
    HWND        hwndParent,
    PCWSTR     pszCaption,
    PCWSTR     pszText,
    DWORD       dwFlags);

HRESULT
HrNcQueryUserForReboot (
    HINSTANCE   hinst,
    HWND        hwndParent,
    UINT        unIdCaption,
    UINT        unIdText,
    DWORD       dwFlags);

#ifdef _INC_SHELLAPI

HRESULT
HrShell_NotifyIcon (
    DWORD dwMessage,
    PNOTIFYICONDATA pData);

#endif // _INC_SHELLAPI

NOTHROW
LRESULT
LresFromHr (
    HRESULT hr);

NOTHROW
INT
WINAPIV
NcMsgBox (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


NOTHROW
INT
WINAPIV
NcMsgBoxWithVarCaption (
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    PCWSTR     szCaptionParam,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);

NOTHROW
INT
WINAPIV
NcMsgBoxWithWin32ErrorText (
    DWORD       dwError,
    HINSTANCE   hinst,
    HWND        hwnd,
    UINT        unIdCaption,
    UINT        unIdCombineFormat,
    UINT        unIdFormat,
    UINT        unStyle,
    ...);


VOID
SendDlgItemsMessage (
    HWND        hDlg,
    INT         ccid,
    const INT*  acid,
    UINT        unMsg,
    WPARAM      wParam,
    LPARAM      lParam);

VOID
SetDefaultButton(
    HWND hdlg,
    INT iddef);

struct CONTEXTIDMAP
{
    INT     idControl;
    DWORD   dwContextId;
    DWORD   dwContextIdJapan;
};
typedef const CONTEXTIDMAP * PCCONTEXTIDMAP;

VOID OnHelpGeneric(
    HWND hwnd,
    LPHELPINFO lphi,
    PCCONTEXTIDMAP pContextMap,
    BOOL bJpn,
    PCWSTR pszHelpFile);

#endif // _NCUI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\netsetup.h ===
#pragma once

EXTERN_C
HRESULT
WINAPI
HrGetAnswerFileParametersForNetCard(
    IN  HDEVINFO hdi,
    IN  PSP_DEVINFO_DATA pdeid,
    IN  PCWSTR pszServiceInstance,
    IN  const GUID*  pguidNetCardInstance,
    OUT PWSTR* ppszAnswerFile,
    OUT PWSTR* ppszAnswerSections);

EXTERN_C
HRESULT
WINAPI
HrOemUpgrade(
    IN HKEY hkeyDriver,
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSections);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\nsexports.h ===
#pragma once
#include "kkstl.h"

enum EPageDisplayMode;

typedef enum EUnattendWorkTypeTag
{
    UAW_Unknown,
    UAW_NetAdapters,
    UAW_NetProtocols,
    UAW_NetClients,
    UAW_NetServices,
    UAW_NetIdentification,
    UAW_NetBindings,
    UAW_RemoveNetComponents
} EUnattendWorkType;

EXTERN_C
HRESULT
WINAPI
HrDoUnattend (
    IN HWND hwndParent,
    IN  IUnknown * punk,
    IN  EUnattendWorkType uawType,
    OUT EPageDisplayMode *ppdm,
    OUT BOOL *pfAllowChanges);

typedef
VOID
(WINAPI *ProgressMessageCallbackFn) (
    IN PCWSTR szMessage,
    va_list arglist);

EXTERN_C
VOID
WINAPI
NetSetupSetProgressCallback (
    ProgressMessageCallbackFn pfn);


typedef
VOID
(WINAPI *NetSetupSetProgressCallbackFn) (
    IN ProgressMessageCallbackFn pfn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMENUS
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES
#define NETMAN

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windowsx.h>

#include <commdlg.h>
#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <shellapi.h>
#include <shlobj.h>     // must come before shlguid.h
#include <shlguid.h>
#include <stdio.h>
#include <wchar.h>

#include "ncstl.h"
#include "ncmem.h"

#include "algorithm"
#include "list"
#include "map"
#include "set"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\notifval.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       N O T I F V A L . H
//
//  Contents:   Validation routines for the INetCfgNotify interfaces.
//
//  Notes:
//
//  Author:     shaunco     11 Mar 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _NOTIFVAL_H_
#define _NOTIFVAL_H_

#include "ncvalid.h"
#include "netcfgn.h"

//+---------------------------------------------------------------------------
// INetCfgNotify
//

BOOL    FBadArgs_INetCfgNotify_Initialize(INetCfgComponent* a, INetCfg* b, BOOL c);
#define Validate_INetCfgNotify_Initialize(a, b, c) \
    if (FBadArgs_INetCfgNotify_Initialize(a, b, c)) \
        {   \
            TraceError("Validate_INetCfgNotify_Initialize", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgNotify_Initialize_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Initialize");


BOOL    FBadArgs_INetCfgNotify_ReadAnswerFile(PCWSTR c, PCWSTR d);
#define Validate_INetCfgNotify_ReadAnswerFile(c, d) \
    if (FBadArgs_INetCfgNotify_ReadAnswerFile(c, d)) \
        {   \
            TraceError("Validate_INetCfgNotify_ReadAnswerFile", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgNotify_ReadAnswerFile_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_ReadAnswerFile");


#define Validate_INetCfgNotify_Install(a)
#define Validate_INetCfgNotify_Install_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Install");


#define Validate_INetCfgNotify_Upgrade(a,b)
#define Validate_INetCfgNotify_Upgrade_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Upgrade");


#define Validate_INetCfgNotify_Removing_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Removing");


#define Validate_INetCfgNotify_Validate_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Validate");


#define Validate_INetCfgNotify_Cancel_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Cancel");

#define Validate_INetCfgNotify_Apply_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || (NETCFG_S_REBOOT == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgNotify_Apply");


//+---------------------------------------------------------------------------
// INetCfgProperties
//

BOOL    FBadArgs_INetCfgProperties_MergePropPages(DWORD* a, LPBYTE* b, UINT* c, HWND hwnd, PCWSTR *psz);
#define Validate_INetCfgProperties_MergePropPages(a, b, c, hwnd, psz)  \
    if (FBadArgs_INetCfgProperties_MergePropPages(a, b, c, hwnd, psz)) \
        {   \
            TraceError("Validate_INetCfgProperties_MergePropPages", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgProperties_MergePropPages_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_MergePropPages");

BOOL    FBadArgs_INetCfgProperties_ValidateProperties(HWND a);
#define Validate_INetCfgProperties_ValidateProperties(a) \
    if (FBadArgs_INetCfgProperties_ValidateProperties(a)) \
        {   \
            TraceError("Validate_INetCfgProperties_ValidateProperties", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgProperties_ValidateProperties_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_ValidateProperties");

#define Validate_INetCfgProperties_CancelProperties_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_CancelProperties");

#define Validate_INetCfgProperties_ApplyProperties_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from INetCfgProperties_ApplyProperties");


//+---------------------------------------------------------------------------
// INetCfgBindNotify
//
inline BOOL FBadNotifyFlags (DWORD a)
{
    return
        // Can't have pairs of flags at the same time that mean the opposite.
            ((a & NCN_ADD   ) && (a & NCN_REMOVE )) ||
            ((a & NCN_ENABLE) && (a & NCN_DISABLE)) ||

        // Can't remove and enable at the same time.
            ((a & NCN_REMOVE) && (a & NCN_ENABLE))  ||

        // Can't add without an enable or disable.
            ((a & NCN_ADD) && !(a & (NCN_ENABLE | NCN_DISABLE)));
}

inline BOOL FBadArgs_INetCfgBindNotify_QueryBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgBindNotify_QueryBindingPath(a, b) \
    if (FBadArgs_INetCfgBindNotify_QueryBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgBindNotify_QueryBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgBindNotify_QueryBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_DISABLE_QUERY == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgBindNotify_QueryBindingPath");


inline BOOL FBadArgs_INetCfgBindNotify_NotifyBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgBindNotify_NotifyBindingPath(a, b) \
    if (FBadArgs_INetCfgBindNotify_NotifyBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgBindNotify_NotifyBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgBindNotify_NotifyBindingPath");


//+---------------------------------------------------------------------------
// INetCfgSystemNotify
//

BOOL    FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(DWORD* a);
#define Validate_INetCfgSystemNotify_GetSupportedNotifications(a) \
    if (FBadArgs_INetCfgSystemNotify_GetSupportedNotifications(a)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_GetSupportedNotifications", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_GetSupportedNotifications_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_GetSupportedNotifications");


inline BOOL FBadArgs_INetCfgSystemNotify_SysQueryBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysQueryBindingPath(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysQueryBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysQueryBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysQueryBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_DISABLE_QUERY == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysQueryBindingPath");


inline BOOL FBadArgs_INetCfgSystemNotify_SysQueryComponent(DWORD a, INetCfgComponent* b)
{
    return FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysQueryComponent(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysQueryComponent(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysQueryComponent", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysQueryComponent_Return(hr) \
    AssertSz ((S_OK == hr) || (NETCFG_S_VETO_QUERY == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysQueryComponent");


inline BOOL FBadArgs_INetCfgSystemNotify_SysNotifyBindingPath(DWORD a, INetCfgBindingPath* b)
{
    return FBadNotifyFlags(a) || FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysNotifyBindingPath(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysNotifyBindingPath(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysNotifyBindingPath", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysNotifyBindingPath_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysNotifyBindingPath");


inline BOOL FBadArgs_INetCfgSystemNotify_SysNotifyComponent(DWORD a, INetCfgComponent* b)
{
    return FBadInPtr(b);
}
#define Validate_INetCfgSystemNotify_SysNotifyComponent(a, b) \
    if (FBadArgs_INetCfgSystemNotify_SysNotifyComponent(a, b)) \
        {   \
            TraceError("Validate_INetCfgSystemNotify_SysNotifyComponent", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_INetCfgSystemNotify_SysNotifyComponent_Return(hr) \
    AssertSz ((S_OK == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_INetCfgSystemNotify_SysNotifyComponent");


// ISupportErrorInfo

inline BOOL FBadArgs_ISupportErrorInfo_InterfaceSupportsErrorInfo(REFIID a)
{
    return FBadInRefiid(a);
}
#define Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo(a) \
    if (FBadArgs_ISupportErrorInfo_InterfaceSupportsErrorInfo(a)) \
        {   \
            TraceError("Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo", E_INVALIDARG); \
            return E_INVALIDARG; \
        }
#define Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo_Return(hr) \
    AssertSz ((S_OK == hr) || (S_FALSE == hr) || FAILED(hr), "Invalid HRESULT returned from Validate_ISupportErrorInfo_InterfaceSupportsErrorInfo");


#endif // _NOTIFVAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\pidlutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P I D L U T I L . H 
//
//  Contents:   Various PIDL utilities
//
//  Notes:      
//
//  Author:     jeffspr   1 Oct 1997
//
//----------------------------------------------------------------------------

#pragma once

// This avoids duplicate definitions with Shell PIDL functions
// and MUST BE DEFINED!
#define AVOID_NET_CONFIG_DUPLICATES

// #include <windows.h>
// #include <shlobj.h>

// These functions are so trivial & get called so often they should be inlined
// for ship.
//
#if DBG
LPITEMIDLIST 	ILNext(LPCITEMIDLIST pidl);
BOOL			ILIsEmpty(LPCITEMIDLIST pidl);
#else
#define ILNext(pidl) 	((LPITEMIDLIST) ((BYTE *)pidl + ((LPITEMIDLIST)pidl)->mkid.cb))
#define ILIsEmpty(pidl)	(!pidl || !((LPITEMIDLIST)pidl)->mkid.cb)
#endif

LPITEMIDLIST 	ILCreate(DWORD dwSize);
VOID            FreeIDL(LPITEMIDLIST pidl);
int				ILCompare(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
BOOL			ILIsSingleID(LPCITEMIDLIST pidl);
UINT			ILGetCID(LPCITEMIDLIST pidl);
UINT 			ILGetSizeCID(LPCITEMIDLIST pidl, UINT cid);
LPITEMIDLIST 	CloneIDLFirstCID(LPCITEMIDLIST pidl, UINT cid);
LPITEMIDLIST 	ILSkipCID(LPCITEMIDLIST pid, UINT cid);
BOOL			ILIsDesktopID(LPCITEMIDLIST pidl);

BOOL            ILIsEqual(LPITEMIDLIST pidl1, LPITEMIDLIST pidl2);

LPITEMIDLIST    CloneIDL(LPCITEMIDLIST pidl);

#ifdef PCONFOLDENTRY_DEFINED

HRESULT HrCloneRgIDL(
    const PCONFOLDPIDLVEC& rgpidl,
    BOOL            fFromCache,
    BOOL            fAllowNonCacheItems,
    PCONFOLDPIDLVEC& ppidl);
    
#endif

VOID FreeRgIDL(
    UINT            cidl,
    LPITEMIDLIST  * apidl);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\wizentry.h ===
#pragma once

#include "netcon.h"
EXTERN_C
HRESULT
WINAPI
NetSetupAddRasConnection (
    IN HWND hwnd,
    OUT INetConnection** ppConn);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\alanehlp.h ===
#define IDH_ELAN_NAME	30000501
#define IDH_ELAN_LIST	30000551
#define	IDH_ELAN_ADD	30000552
#define IDH_ELAN_EDIT	30000553
#define	IDH_ELAN_REMOVE	30000554

const DWORD g_aHelpIDs_IDD_ELAN_PROPERTIES[]=
{
	IDC_ELAN_NAME, IDH_ELAN_NAME,
	0, 0
};

const DWORD g_aHelpIDs_IDD_MAIN[]=
{
	IDC_ELAN_LIST, IDH_ELAN_LIST,
	IDC_ELAN_ADD, IDH_ELAN_ADD,
	IDC_ELAN_EDIT, IDH_ELAN_EDIT,
	IDC_ELAN_REMOVE, IDH_ELAN_REMOVE,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\tracetag.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E T A G . H
//
//  Contents:   Trace tag definitions for the Netcfg project
//
//  Notes:      B-flat, C-sharp
//
//  Author:     jeffspr   9 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _TRACETAG_H_
#define _TRACETAG_H_


// TraceTagIds are the identifiers for tracing areas, and are used in calls
// to TraceTag.  We need this defined outside of of ENABLETRACE so that
// calls to the TraceTag macro don't break when ENABLETRACE is not defined.
//
// Hungarian == ttid
//
enum TraceTagId
{
    ttidDefault         = 0,
    ttidAdvCfg,
    ttidAllocations,
    ttidAtmArps,
    ttidAtmLane,
    ttidAtmUni,
    ttidBeDiag,
    ttidBenchmark,
    ttidBrdgCfg,
    ttidClassInst,
    ttidConFoldEntry,
    ttidConman,
    ttidConnectionList,
    ttidDHCPServer,
    ttidDun,
    ttidError,
    ttidEsLock,
    ttidEvents,
    ttidGPNLA,
    ttidGuiModeSetup,
    ttidIcons,
    ttidInfExt,
    ttidInstallQueue,
    ttidISDNCfg,
    ttidLana,
    ttidLanCon,
    ttidLanUi,
    ttidMenus,
    ttidMSCliCfg,
    ttidNcDiag,
    ttidNetComm,
    ttidNetOc,
    ttidNetSetup,
    ttidNetUpgrade,
    ttidNetcfgBase,
    ttidNetCfgBind,
    ttidNetCfgPnp,
    ttidNotifySink,
    ttidNWClientCfg,
    ttidNWClientCfgFn,
    ttidRasCfg,
    ttidShellFolder,
    ttidShellFolderIface,
    ttidShellViewMsgs,
    ttidSrvrCfg,
    ttidStatMon,
    ttidSvcCtl,
    ttidSystray,
    ttidTcpip,
    ttidWanCon,
    ttidWizard,
    ttidWlbs, /* maiken 5.25.00 */
};


// Just for kicks
//
typedef enum TraceTagId TRACETAGID;

#ifdef ENABLETRACE

// Maximum sizes for the trace tag elements.
const int c_iMaxTraceTagShortName   = 16;
const int c_iMaxTraceTagDescription = 128;

// For each element in the tracetag list
//
struct TraceTagElement
{
    TRACETAGID  ttid;
    CHAR        szShortName[c_iMaxTraceTagShortName+1];
    CHAR        szDescription[c_iMaxTraceTagDescription+1];
    BOOL        fOutputDebugString;
    BOOL        fOutputToFile;
    BOOL        fVerboseOnly;
};

typedef struct TraceTagElement  TRACETAGELEMENT;

//---[ Externs ]--------------------------------------------------------------

extern TRACETAGELEMENT      g_TraceTags[];
extern const INT            g_nTraceTagCount;

#endif // ENABLETRACE

#endif  // _TRACETAG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\alaneobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A L A N E O B J . H
//
//  Contents:  Declaration of the CALaneCfg notify object model
//
//  Notes:
//
//  Author:     v-lcleet    01 Aug 97
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"
#include <laneinfo.h>

#define ELAN_NAME_LIMIT 32

enum ElanChangeType
{
    ADD_ELAN = ATMLANE_RECONFIG_OP_ADD_ELAN,
    DEL_ELAN = ATMLANE_RECONFIG_OP_DEL_ELAN,
    MOD_ELAN = ATMLANE_RECONFIG_OP_MOD_ELAN
};

//
//  CALaneCfgElanData
//

class CALaneCfgElanInfo
{
public:
    CALaneCfgElanInfo(VOID);

    VOID SetElanBindName(PCWSTR pszElanBindName);
    PCWSTR SzGetElanBindName(VOID);
    VOID SetElanDeviceName(PCWSTR pszElanDeviceName);
    PCWSTR SzGetElanDeviceName(VOID);
    VOID SetElanName(PCWSTR pszElanName);
    VOID SetElanName(PWSTR pszElanName);
    PCWSTR SzGetElanName(VOID);

    BOOL        m_fDeleted;
    BOOL        m_fNewElan;

    BOOL        m_fRemoveMiniportOnPropertyApply;
    BOOL        m_fCreateMiniportOnPropertyApply;

private:
    tstring     m_strElanBindName;
    tstring     m_strElanDeviceName;
    tstring     m_strElanName;
};

typedef list<CALaneCfgElanInfo*>   ELAN_INFO_LIST;

//
//  CALaneCfgAdapterInfo
//

class CALaneCfgAdapterInfo
{
public:
    CALaneCfgAdapterInfo(VOID);
    ~CALaneCfgAdapterInfo(VOID);

    VOID SetAdapterBindName(PCWSTR pszAdapterBindName);
    PCWSTR SzGetAdapterBindName(VOID);

    VOID SetAdapterPnpId(PCWSTR szAdapterBindName);
    PCWSTR SzGetAdapterPnpId(VOID);

    GUID    m_guidInstanceId;

    ELAN_INFO_LIST      m_lstElans;
    ELAN_INFO_LIST      m_lstOldElans;

    BOOL                m_fDeleted;

    // If the adapter has been added, removed, enabled or disabled.
    BOOL                m_fBindingChanged;

private:
    tstring             m_strAdapterBindName;
    tstring             m_strAdapterPnpId;
};

typedef list<CALaneCfgAdapterInfo*>   ATMLANE_ADAPTER_INFO_LIST;


//
// CALaneCfg
//
class ATL_NO_VTABLE CALaneCfg :
    public CComObjectRoot,
    public CComCoClass<CALaneCfg, &CLSID_CALaneCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
protected:
    CALaneCfg(VOID);
    ~CALaneCfg(VOID);

public:
    BEGIN_COM_MAP(CALaneCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CSkeleton)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ALANECFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

private:
    INetCfgComponent*           m_pncc;
    INetCfg*                    m_pnc;
    ATMLANE_ADAPTER_INFO_LIST   m_lstAdaptersPrimary;
    CALaneCfgAdapterInfo *      m_pAdapterSecondary;

    BOOL                        m_fDirty;
    BOOL                        m_fValid;
    BOOL                        m_fUpgrade;
    BOOL                        m_fNoElanInstalled;

    // Property sheet pages
    enum {c_cALanePages = 1};
    CPropSheetPage*             m_ppsp;

    // Context
    IUnknown * m_pUnkContext;
    tstring  m_strGuidConn;

// Utility functions
private:
    HRESULT HrNotifyBindingAdd(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrNotifyBindingRemove(
        INetCfgComponent* pnccAdapter,
        PCWSTR pszBindName);

    HRESULT HrLoadConfiguration();

    HRESULT HrLoadAdapterConfiguration(HKEY hkeyAdapterList,
            PWSTR szAdapterName);

    HRESULT HrLoadElanListConfiguration(HKEY hkeyAdapter,
            CALaneCfgAdapterInfo* pAdapterInfo);

    HRESULT HrLoadElanConfiguration(HKEY hkeyElanList,
            PWSTR szElanName, CALaneCfgAdapterInfo* pAdapterInfo);

    HRESULT HrFlushConfiguration();

    HRESULT HrFlushAdapterConfiguration(HKEY hkeyAdapterList,
            CALaneCfgAdapterInfo *pAdapterInfo);

    HRESULT HrFlushElanListConfiguration(HKEY hkeyAdapter,
            CALaneCfgAdapterInfo *pAdapterInfo);

    HRESULT HrFlushElanConfiguration(HKEY hkeyElanList,
            CALaneCfgElanInfo *pElanInfo);

    HRESULT HrRemoveMiniportInstance(PCWSTR pszBindNameToRemove);

    HRESULT HrFindNetCardInstance(PCWSTR pszBindNameToFind, INetCfgComponent **ppncc);

    VOID    HrMarkAllDeleted();

    VOID    UpdateElanDisplayNames();

    HRESULT HrSetConnectionContext();
    HRESULT HrALaneSetupPsh(HPROPSHEETPAGE** pahpsp);

    VOID    CopyAdapterInfoPrimaryToSecondary();
    VOID    CopyAdapterInfoSecondaryToPrimary();

    HRESULT HrReconfigLane(CALaneCfgAdapterInfo * pAdapterInfo);
    HRESULT HrNotifyElanChange(CALaneCfgAdapterInfo * pAdapterInfo,
                                          CALaneCfgElanInfo * pElanInfo,
                                          ElanChangeType elanChangeType);
    BOOL    FIsAdapterEnabled(const GUID* pguidId);
};

// some utility functions

void ClearElanList(ELAN_INFO_LIST *plstElans);
void ClearAdapterList(ATMLANE_ADAPTER_INFO_LIST *plstAdapters);
void ClearAdapterInfo(CALaneCfgAdapterInfo * pAdapterInfo);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\alaneobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A L A N E O B J . C P P
//
//  Contents:   Implementation of the CALaneCfg notify object model
//
//  Notes:
//
//  Author:     v-lcleet    01 Aug 97
//
//----------------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "alaneobj.h"
#include "alanepsh.h"
#include "ncreg.h"
#include "netconp.h"
#include "ncpnp.h"

#include "alanehlp.h"

static const WCHAR c_szAtmLane[]            = L"AtmLane";
static const WCHAR c_szElanList[]           = L"ElanList";
static const WCHAR c_szElanDevice[]         = L"Device";
static const WCHAR c_szElanName[]           = L"ElanName";

extern const WCHAR c_szDevice[];

extern const WCHAR c_szInfId_MS_AtmElan[];

const WCHAR c_szAtmAdapterPnpId[]          = L"AtmAdapterPnpId";

//
//  CALaneCfg
//
//  Constructor/Destructor methods
//

CALaneCfg::CALaneCfg(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_ppsp(NULL),
        m_pAdapterSecondary(NULL),
        m_pUnkContext(NULL)
{
    m_fDirty = FALSE;
    m_fValid = FALSE;
    m_fUpgrade = FALSE;
    m_fNoElanInstalled = TRUE;

    return;
}

CALaneCfg::~CALaneCfg(VOID)
{
    ClearAdapterList(&m_lstAdaptersPrimary);
    ClearAdapterInfo(m_pAdapterSecondary);

    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    delete m_ppsp;

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ?");
    ReleaseObj(m_pUnkContext) ;

    return;
}

//
//  CALaneCfg
//
//  INetCfgComponentControl interface methods
//

STDMETHODIMP CALaneCfg::Initialize (INetCfgComponent* pncc,
                                    INetCfg* pnc,
                                    BOOL fInstalling)
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_Initialize(pncc, pnc, fInstalling);

    // reference and save away the component and interface.
    AddRefObj(m_pncc = pncc);
    AddRefObj(m_pnc = pnc);

    // if not installing then load the current config from registry
    if (!fInstalling)
    {
        hr = HrLoadConfiguration();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CALaneCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::Validate ()
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fValid && m_fDirty)
    {
        UpdateElanDisplayNames();

        // flush out the registry and send reconfig notifications
        hr = HrFlushConfiguration();
    }
    else
    {
        // no change
        hr = S_FALSE;
    }

    TraceError("CALaneCfg::ApplyRegistryChanges",
        (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

//  INetCfgComponentSetup interface methods
//
STDMETHODIMP CALaneCfg::Install (DWORD dwSetupFlags)
{
    // mark configuration as valid (but empty)
    m_fValid = TRUE;

    return S_OK;
}

STDMETHODIMP CALaneCfg::Upgrade( DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo )
{
    // mark configuration as valid (but empty)
    m_fValid = TRUE;
    m_fUpgrade = TRUE;

    return S_OK;
}

STDMETHODIMP CALaneCfg::ReadAnswerFile (PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::Removing ()
{
    // mark everything for deletion
    (VOID) HrMarkAllDeleted();

    return S_OK;
}

//
//  CALaneCfg
//
//  INetCfgProperties interface methods
//

STDMETHODIMP CALaneCfg::QueryPropertyUi(IUnknown* pUnk)
{
    HRESULT hr = S_FALSE;

    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            // don't show UI
            hr = S_FALSE;
        }
    }

    TraceError("CALaneCfg::QueryPropertyUi", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CALaneCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages(pdwDefPages, pahpspPrivate,
                                              pcPages, hwndParent, pszStartPage);

    // Don't show any default pages
    *pdwDefPages = 0;
    *pcPages = 0;
    *pahpspPrivate = NULL;

    HPROPSHEETPAGE*     ahpsp   = NULL;
    HRESULT hr = HrALaneSetupPsh(&ahpsp);
    if (SUCCEEDED(hr))
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = c_cALanePages;
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CALaneCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CALaneCfg::ValidateProperties (HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::CancelProperties ()
{
    // throw away the secondary adapter list
    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    return S_OK;
}

STDMETHODIMP CALaneCfg::ApplyProperties ()
{
    HRESULT hr = S_OK;
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    ELAN_INFO_LIST::iterator    iterLstElans;
    CALaneCfgElanInfo *         pElanInfo;
    INetCfgComponent *          pnccAtmElan   = NULL;
    tstring     strAtmElan;

    // go thru the secondary adapter info and
    // add miniports for elans that were added and
    // remove miniports for elans that were deleted.

    // loop thru the elan list on this adapter

    BOOL bCommitNow = FALSE;

    for (iterLstElans = m_pAdapterSecondary->m_lstElans.begin();
            iterLstElans != m_pAdapterSecondary->m_lstElans.end();
            iterLstElans++)
    {
        pElanInfo = *iterLstElans;

        if (pElanInfo->m_fCreateMiniportOnPropertyApply)
        {
            bCommitNow = TRUE;

            //  create associated miniport
            hr = HrAddOrRemoveAdapter(m_pnc,
                        c_szInfId_MS_AtmElan, ARA_ADD,
                        NULL, 1, &pnccAtmElan);

            if (S_OK == hr)
            {
                // This is a new Elan
                pElanInfo->m_fNewElan = TRUE;

                //  BindName
                PWSTR pszTmpBindName;
                hr = pnccAtmElan->GetBindName(&pszTmpBindName);
                if (SUCCEEDED(hr))
                {
                    pElanInfo->SetElanBindName(pszTmpBindName);
                    CoTaskMemFree(pszTmpBindName);

                    //  Device param
                    strAtmElan = c_szDevice;
                    strAtmElan.append(pElanInfo->SzGetElanBindName());

                    pElanInfo->SetElanDeviceName(strAtmElan.c_str());
                }

                ReleaseObj(pnccAtmElan);
            }

            if (FAILED(hr))
            {
                TraceError("CALaneCfg::ApplyProperties, failed creating an Elan", hr);
                hr = S_OK;
            }
        }
        
        if (pElanInfo->m_fRemoveMiniportOnPropertyApply)
        {
            bCommitNow = TRUE;

            pElanInfo = *iterLstElans;

            hr = HrRemoveMiniportInstance(pElanInfo->SzGetElanBindName());

            if (FAILED(hr))
            {
                pElanInfo->m_fDeleted = FALSE;

                TraceError("CALaneCfg::ApplyProperties, failed removing an Elan", hr);
                hr = S_OK;
            }
        }
    }

    // all is well
    // copy secondary list to primary
    CopyAdapterInfoSecondaryToPrimary();
    m_fDirty = TRUE;


    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    if(bCommitNow && SUCCEEDED(hr))
    {
        hr = NETCFG_S_COMMIT_NOW;
    }

    TraceError("CALaneCfg::ApplyProperties", hr);
    return hr;
}

//
//  CALaneCfg
//
//  INetCfgBindNotify interface methods
//
STDMETHODIMP CALaneCfg::QueryBindingPath (DWORD dwChangeFlag,
                                          INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP CALaneCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                           INetCfgBindingPath* pncbp)
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    INetCfgComponent * pnccLastComponent;
    HRESULT hr = HrGetLastComponentAndInterface(pncbp,
                    &pnccLastComponent, NULL);

    if (S_OK == hr)
    {
        PWSTR pszBindName;
        hr = pnccLastComponent->GetBindName(&pszBindName);
        if (S_OK == hr)
        {
            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrNotifyBindingAdd(pnccLastComponent, pszBindName);
            }
            else if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrNotifyBindingRemove(pnccLastComponent, pszBindName);
            }
            else
            {
                // simply mark the adapter as binding changed so we don't
                // send Elan add\remove notifications (Raid #255910)

                // Get the adapter component's instance name
                CALaneCfgAdapterInfo *  pAdapterInfo;

                //  search the in-memory list for this adapter
                BOOL    fFound;
                ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
                for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
                        iterLstAdapters != m_lstAdaptersPrimary.end();
                        iterLstAdapters++)
                {
                    pAdapterInfo = *iterLstAdapters;

                    if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
                    {
                        fFound = TRUE;
                        break;
                    }
                }

                if (fFound)
                {
                    // mark it as changed
                    pAdapterInfo->m_fBindingChanged = TRUE;
                }
            }

            CoTaskMemFree (pszBindName);
        }

        ReleaseObj (pnccLastComponent);
    }

    TraceError("CALaneCfg::NotifyBindingPath", hr);
    return hr;
}

//
//  CALaneCfg
//
//  Private methods
//
HRESULT
CALaneCfg::HrNotifyBindingAdd (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    // $REVIEW(tongl 1/25/98): Added this: we should see if this adapter is
    // is already in our list but marked as for deletion. If so, simply unmark
    // the adapter and all of it's Elans. The Binding Add could be a fake one
    // when it is in uprade process.

    BOOL fFound;
    CALaneCfgAdapterInfo*  pAdapterInfo  = NULL;

    //  search the in-memory list for this adapter
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (!lstrcmpiW(pszBindName, pAdapterInfo->SzGetAdapterBindName()))
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound) // Add an old adapter back
    {
        Assert(pAdapterInfo->m_fDeleted);

        // mark it un-deleted
        pAdapterInfo->m_fDeleted = FALSE;

        if (m_fUpgrade)
        {
            // the Elans are not deleted, just mark them as un-deleted
            ELAN_INFO_LIST::iterator iterLstElans;
            for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                    iterLstElans!= pAdapterInfo->m_lstElans.end();
                    iterLstElans++)
            {
                Assert((*iterLstElans)->m_fDeleted);
                (*iterLstElans)->m_fDeleted = FALSE;
            }
        }
    }
    else
    {
        // if this is a new atm adapter

        //  Create a new in-memory adapter object
        pAdapterInfo = new CALaneCfgAdapterInfo;

        if (pAdapterInfo)
        {
            GUID guidAdapter;
            hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 
            if (S_OK == hr)
            {
                pAdapterInfo->m_guidInstanceId = guidAdapter;
            }

            // the adapter is newly added
            pAdapterInfo->m_fBindingChanged = TRUE;

            // Set the bind name of the adapter
            pAdapterInfo->SetAdapterBindName(pszBindName);

            // Set the PnpId of the adapter
            PWSTR pszPnpDevNodeId;
            hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
            if (S_OK == hr)
            {
                Assert(pszPnpDevNodeId);

                pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
                CoTaskMemFree(pszPnpDevNodeId);
            }

            //  Create a new in-memory elan object
            CALaneCfgElanInfo * pElanInfo;
            pElanInfo = new CALaneCfgElanInfo;

            if (pElanInfo)
            {
                pElanInfo->m_fNewElan = TRUE;

                //  Install a virtual miniport for a default ELAN
                INetCfgComponent*   pnccAtmElan;

                hr = HrAddOrRemoveAdapter(m_pnc, c_szInfId_MS_AtmElan,
                                          ARA_ADD, NULL, 1, &pnccAtmElan);

                if (SUCCEEDED(hr))
                {
                    Assert(pnccAtmElan);

                    //  Update the BindName
                    PWSTR pszElanBindName;
                    hr = pnccAtmElan->GetBindName(&pszElanBindName);
                    if (S_OK == hr)
                    {
                        pElanInfo->SetElanBindName(pszElanBindName);
                        CoTaskMemFree(pszElanBindName);
                    }

                    //  Update the Device param
                    tstring strAtmElan;
                    strAtmElan = c_szDevice;
                    strAtmElan.append(pElanInfo->SzGetElanBindName());

                    pElanInfo->SetElanDeviceName(strAtmElan.c_str());

                    //  Push the Elan onto the the adapter's list
                    pAdapterInfo->m_lstElans.push_back(pElanInfo);

                    //  Push the Adapter onto the adapter list
                    m_lstAdaptersPrimary.push_back(pAdapterInfo);

                    //  Mark the in-memory configuration dirty
                    m_fDirty = TRUE;

                    ReleaseObj(pnccAtmElan);
                }
            }
        }
    }

    TraceError("CALaneCfg::HrNotifyBindingAdd", hr);
    return hr;
}

HRESULT
CALaneCfg::HrNotifyBindingRemove (
    INetCfgComponent* pnccAdapter,
    PCWSTR pszBindName)
{
    HRESULT hr = S_OK;
    CALaneCfgAdapterInfo *  pAdapterInfo;

    //  search the in-memory list for this adapter
    BOOL    fFound;
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin(), fFound = FALSE;
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (!lstrcmpiW (pszBindName, pAdapterInfo->SzGetAdapterBindName()))
        {
            fFound = TRUE;
            break;
        }
    }

    if (fFound)
    {
        // mark it deleted
        pAdapterInfo->m_fDeleted = TRUE;

        // mark as binding changed
        pAdapterInfo->m_fBindingChanged = TRUE;

        // if this is upgrade, then mark all associated ELANs deleted
        // otherwise, delete them now
        HRESULT hrElan = S_OK;

        for (ELAN_INFO_LIST::iterator iterLstElans = pAdapterInfo->m_lstElans.begin();
             iterLstElans!= pAdapterInfo->m_lstElans.end();
             iterLstElans++)
        {
            if (!m_fUpgrade)
            {
                // Remove corresponding miniport.
                hrElan = HrRemoveMiniportInstance((*iterLstElans)->SzGetElanBindName());

                if (SUCCEEDED(hr))
                {
                    (*iterLstElans)->m_fDeleted = TRUE;
                }
                else
                {
                    TraceError("HrRemoveMiniportInstance failed", hrElan);
                    hrElan = S_OK;
                }
            }
        }

        // mark the in-memory configuration dirty
        m_fDirty = TRUE;
    }

    TraceError("CALaneCfg::HrNotifyBindingRemove", hr);
    return hr;
}

HRESULT CALaneCfg::HrLoadConfiguration()
{
    HRESULT     hr  = S_OK;

    // mark the memory version of the registy valid
    m_fValid = TRUE;

    // open adapter list subkey
    HKEY    hkeyAdapterList = NULL;

    // Try to open an existing key first.
    //
    hr = HrRegOpenAdapterKey(c_szAtmLane, FALSE, &hkeyAdapterList);
    if (FAILED(hr))
    {
        // Only on failure do we try to create it
        //
        hr = HrRegOpenAdapterKey(c_szAtmLane, TRUE, &hkeyAdapterList);
    }
    if (S_OK == hr)
    {
        WCHAR       szBuf[MAX_PATH+1];
        FILETIME    time;
        DWORD       dwSize;
        DWORD       dwRegIndex = 0;

        dwSize = celems(szBuf);
        while (S_OK == (hr = HrRegEnumKeyEx (hkeyAdapterList, dwRegIndex,
                szBuf, &dwSize, NULL, NULL, &time)))
        {
            Assert(szBuf);

            // load this adapter's config
            hr = HrLoadAdapterConfiguration (hkeyAdapterList, szBuf);
            if (S_OK != hr)
            {
                TraceTag (ttidAtmLane, "CALaneCfg::HrLoadConfiguration failed on adapter %S", szBuf);
                hr = S_OK;
            }

            // increment index and reset size variable
            dwRegIndex++;
            dwSize = celems (szBuf);
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey (hkeyAdapterList);
    }

    TraceError("CALaneCfg::HrLoadConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrLoadAdapterConfiguration(HKEY hkeyAdapterList,
                                              PWSTR pszAdapterName)
{
    HRESULT hr = S_OK;

    // load this adapter
    CALaneCfgAdapterInfo*   pAdapterInfo;
    pAdapterInfo = new CALaneCfgAdapterInfo;

    if (pAdapterInfo)
    {
        pAdapterInfo->SetAdapterBindName(pszAdapterName);
        m_lstAdaptersPrimary.push_back(pAdapterInfo);

        // open this adapter's subkey
        HKEY    hkeyAdapter = NULL;
        DWORD   dwDisposition;

        hr = HrRegCreateKeyEx(
                    hkeyAdapterList,
                    pszAdapterName,
                    REG_OPTION_NON_VOLATILE,
                    KEY_ALL_ACCESS,
                    NULL,
                    &hkeyAdapter,
                    &dwDisposition);

        if (S_OK == hr)
        {
            // load the PnpId
            INetCfgComponent*   pnccAdapter    = NULL;
            hr = HrFindNetCardInstance(pszAdapterName, &pnccAdapter);
            if (S_OK == hr)
            {
                PWSTR pszPnpDevNodeId;
                hr = pnccAdapter->GetPnpDevNodeId(&pszPnpDevNodeId);
                if (S_OK == hr)
                {
                    Assert(pszPnpDevNodeId);
                    pAdapterInfo->SetAdapterPnpId(pszPnpDevNodeId);
                    CoTaskMemFree(pszPnpDevNodeId);
                }

                GUID guidAdapter;
                hr = pnccAdapter->GetInstanceGuid(&guidAdapter); 
                if (S_OK == hr)
                {
                    pAdapterInfo->m_guidInstanceId = guidAdapter;
                }

                // load the ElanList
                hr = HrLoadElanListConfiguration(hkeyAdapter, pAdapterInfo);

                ReleaseObj(pnccAdapter);
            }
            else if (S_FALSE == hr)
            {
                // nromalize return
                hr = S_OK;
            }

            RegCloseKey(hkeyAdapter);
        }
    }

    TraceError("CALaneCfg::HrLoadAdapterConfiguration", hr);
    return hr;
}

HRESULT
CALaneCfg::HrLoadElanListConfiguration(
    HKEY hkeyAdapter,
    CALaneCfgAdapterInfo* pAdapterInfo)
{
    HRESULT hr;

    // open the ElanList subkey
    HKEY    hkeyElanList    = NULL;
    DWORD   dwDisposition;
    hr = HrRegCreateKeyEx(hkeyAdapter, c_szElanList, REG_OPTION_NON_VOLATILE,
            KEY_ALL_ACCESS, NULL, &hkeyElanList, &dwDisposition);

    if (S_OK == hr)
    {

        WCHAR       szBuf[MAX_PATH+1];
        FILETIME    time;
        DWORD       dwSize;
        DWORD       dwRegIndex = 0;

        dwSize = celems(szBuf);
        while(SUCCEEDED(hr = HrRegEnumKeyEx(hkeyElanList, dwRegIndex, szBuf,
                                            &dwSize, NULL, NULL, &time)))
        {
            Assert(szBuf);

            // load this ELAN's config
            hr = HrLoadElanConfiguration(hkeyElanList,
                                         szBuf,
                                         pAdapterInfo);
            if (S_OK != hr)
            {
                TraceTag(ttidAtmLane, "CALaneCfg::HrLoadConfiguration failed on Elan %S", szBuf);
                hr = S_OK;
            }
            else if (m_fNoElanInstalled)
            {
                m_fNoElanInstalled = FALSE;
            }

            // increment index and reset size variable
            dwRegIndex ++;
            dwSize = celems(szBuf);
        }

        if(hr == HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS))
            hr = S_OK;

        RegCloseKey(hkeyElanList);
    }

    TraceError("CALaneCfg::HrLoadElanListConfiguration", hr);
    return hr;
}

HRESULT
CALaneCfg::HrLoadElanConfiguration(
    HKEY hkeyElanList,
    PWSTR pszElan,
    CALaneCfgAdapterInfo* pAdapterInfo)
{
    HRESULT hr  = S_OK;

    do
    {
		// load this ELAN info
		CALaneCfgElanInfo * pElanInfo = NULL;
		pElanInfo = new CALaneCfgElanInfo;

		CALaneCfgElanInfo * pOldElanInfo = NULL;
		pOldElanInfo = new CALaneCfgElanInfo;

		if ((pElanInfo == NULL) ||
			(pOldElanInfo == NULL))
		{
			hr = E_OUTOFMEMORY;
			if (pElanInfo)
			{
				delete pElanInfo;
			}
			if (pOldElanInfo)
			{
				delete pOldElanInfo;
			}

			break;
        }

		pAdapterInfo->m_lstElans.push_back(pElanInfo);
		pElanInfo->SetElanBindName(pszElan);

		pAdapterInfo->m_lstOldElans.push_back(pOldElanInfo);
		pOldElanInfo->SetElanBindName(pszElan);

		// open the ELAN's key
		HKEY    hkeyElan    = NULL;
		DWORD   dwDisposition;
		hr = HrRegCreateKeyEx (hkeyElanList, pszElan, REG_OPTION_NON_VOLATILE,
				KEY_ALL_ACCESS, NULL, &hkeyElan, &dwDisposition);

		if (S_OK == hr)
		{
			// read the Device parameter
			PWSTR pszElanDevice;
			hr = HrRegQuerySzWithAlloc (hkeyElan, c_szElanDevice, &pszElanDevice);
			if (S_OK == hr)
			{
				// load the Device name
				pElanInfo->SetElanDeviceName(pszElanDevice);
				pOldElanInfo->SetElanDeviceName(pszElanDevice);
				MemFree (pszElanDevice);

				// read the ELAN Name parameter
				PWSTR pszElanName;
				hr = HrRegQuerySzWithAlloc (hkeyElan, c_szElanName, &pszElanName);
				if (SUCCEEDED(hr))
				{
					// load the ELAN name
					pElanInfo->SetElanName (pszElanName);
					pOldElanInfo->SetElanName (pszElanName);
					MemFree (pszElanName);
				}
			}
			RegCloseKey (hkeyElan);
		}
	}
	while (FALSE);

    TraceError ("CALaneCfg::HrLoadElanConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushConfiguration()
{
    HRESULT hr  = S_OK;
    HKEY    hkeyAdapterList = NULL;

    //  Open the "Adapters" list key
    hr = ::HrRegOpenAdapterKey(c_szAtmLane, TRUE, &hkeyAdapterList);

    if (S_OK == hr)
    {
        ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
        CALaneCfgAdapterInfo *  pAdapterInfo;

        HRESULT hrTmp;

        //  Iterate thru the adapters
        for (iterLstAdapters = m_lstAdaptersPrimary.begin();
             iterLstAdapters != m_lstAdaptersPrimary.end();
             iterLstAdapters++)
        {
            pAdapterInfo = *iterLstAdapters;

            //  Flush this adapter's configuration
            hrTmp = HrFlushAdapterConfiguration(hkeyAdapterList, pAdapterInfo);
            if (SUCCEEDED(hrTmp))
            {
                // Raid #255910: only send Elan change notification if the
                // binding to the physical adapter has not changed
                if (!pAdapterInfo->m_fBindingChanged)
                {
                    // Compare Elan list and send notifications
                    hrTmp = HrReconfigLane(pAdapterInfo);

                    if (FAILED(hrTmp))
                        hrTmp = NETCFG_S_REBOOT;
                }
            }
            else
            {
                TraceTag(ttidAtmLane,"HrFlushAdapterConfiguration failed for adapter %S", pAdapterInfo->SzGetAdapterBindName());
                hrTmp = S_OK;
            }

            if (S_OK ==hr)
                hr = hrTmp;
        }
        RegCloseKey(hkeyAdapterList);
    }

    if (hr != NETCFG_S_REBOOT) {
        TraceError("CALaneCfg::HrFlushConfiguration", hr);
    }

    return hr;
}

HRESULT CALaneCfg::HrFlushAdapterConfiguration(HKEY hkeyAdapterList,
                                               CALaneCfgAdapterInfo *pAdapterInfo)
{
    HRESULT hr  = S_OK;

    HKEY    hkeyAdapter     = NULL;
    DWORD   dwDisposition;

    if (pAdapterInfo->m_fDeleted)
    {
        //  Adapter is marked for deletion
        //  Delete this adapter's whole registry branch
        hr = HrRegDeleteKeyTree(hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName());
    }
    else
    {
        // open this adapter's subkey
        hr = HrRegCreateKeyEx(
                                hkeyAdapterList,
                                pAdapterInfo->SzGetAdapterBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyAdapter,
                                &dwDisposition);

        if (S_OK == hr)
        {
            //  Flush the ELAN configuration
            hr = HrFlushElanListConfiguration(hkeyAdapter, pAdapterInfo);

            RegCloseKey(hkeyAdapter);
        }
    }

    TraceError("CALaneCfg::HrFlushAdapterConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushElanListConfiguration(HKEY hkeyAdapter,
                                                CALaneCfgAdapterInfo *pAdapterInfo)
{
    HRESULT hr  = S_OK;

    HKEY    hkeyElanList    = NULL;
    DWORD   dwDisposition;

    //  Open the Elan list subkey
    hr = HrRegCreateKeyEx(
                            hkeyAdapter,
                            c_szElanList,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hkeyElanList,
                            &dwDisposition);

    if (S_OK == hr)
    {
        ELAN_INFO_LIST::iterator    iterLstElans;
        CALaneCfgElanInfo *         pElanInfo;

        // iterate thru the Elans
        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
             iterLstElans != pAdapterInfo->m_lstElans.end();
             iterLstElans++)
        {
            pElanInfo = *iterLstElans;

            hr = HrFlushElanConfiguration(hkeyElanList, pElanInfo);
            if (FAILED(hr))
            {
                TraceError("HrFlushElanConfiguration failure", hr);
                hr = S_OK;
            }

            // $REVIEW(tongl 9/9/98): write ATM adapter's pnp id to registry (#169025)
            if ((!pElanInfo->m_fDeleted) && (pElanInfo->m_fNewElan))
            {
                INetCfgComponent * pnccAtmElan;
                hr = HrFindNetCardInstance(pElanInfo->SzGetElanBindName(),
                                           &pnccAtmElan);
                if (S_OK == hr)
                {
                    HKEY hkeyElan = NULL;

                    hr = pnccAtmElan->OpenParamKey(&hkeyElan);
                    if (S_OK == hr)
                    {
                        Assert(hkeyElan);
                        HrRegSetSz(hkeyElan, c_szAtmAdapterPnpId,
                                    pAdapterInfo->SzGetAdapterPnpId());
                    }
                    RegSafeCloseKey(hkeyElan);
                }
                ReleaseObj(pnccAtmElan);
            }
        }

        RegCloseKey(hkeyElanList);
    }

    TraceError("CALaneCfg::HrFlushElanListConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrFlushElanConfiguration(HKEY hkeyElanList,
                                            CALaneCfgElanInfo *pElanInfo)
{
    HRESULT hr  = S_OK;
    
    if (pElanInfo->m_fDeleted)
    {
        PCWSTR szBindName = pElanInfo->SzGetElanBindName();

        if (lstrlenW(szBindName)) // only if the bindname is not empty
        {
            //  Elan is marked for deletion
            //  Delete this Elan's whole registry branch
            hr = HrRegDeleteKeyTree(hkeyElanList,
                                    pElanInfo->SzGetElanBindName());
        }
    }
    else
    {
        HKEY    hkeyElan = NULL;
        DWORD   dwDisposition;

        // open/create this Elan's key
        hr = HrRegCreateKeyEx(
                                hkeyElanList,
                                pElanInfo->SzGetElanBindName(),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hkeyElan,
                                &dwDisposition);

        if (S_OK == hr)
        {
            //  Write the Device parameter
            hr = HrRegSetSz(hkeyElan, c_szElanDevice,
                            pElanInfo->SzGetElanDeviceName());

            if (FAILED(hr))
            {
                TraceError("Failed save Elan device parameter", hr);
                hr = S_OK;
            }

            //  Write the ElanName parameter
            hr = HrRegSetSz(hkeyElan, c_szElanName,
                            pElanInfo->SzGetElanName());

            if (FAILED(hr))
            {
                TraceError("Failed save Elan name parameter", hr);
                hr = S_OK;
            }
        }
        RegSafeCloseKey(hkeyElan);
    }

    TraceError("CALaneCfg::HrFlushElanConfiguration", hr);
    return hr;
}

HRESULT CALaneCfg::HrRemoveMiniportInstance(PCWSTR pszBindNameToRemove)
{
    // Enumerate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    BOOL fFound = FALSE;

    INetCfgComponent* pnccAdapter;
    while ((!fFound) && SUCCEEDED(hr) &&
           S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        if (FIsComponentId(c_szInfId_MS_AtmElan, pnccAdapter))
        {
            //  Get the bindname of the miniport
            PWSTR pszBindName;
            hr = pnccAdapter->GetBindName(&pszBindName);

            if (S_OK == hr)
            {
                //  If the right one tell it to remove itself and end
                BOOL fRemove = !lstrcmpiW (pszBindName, pszBindNameToRemove);

                if (fRemove)
                {
                    fFound = TRUE;
                    hr = HrRemoveComponent( m_pnc, pnccAdapter, NULL, NULL);
                }

                CoTaskMemFree (pszBindName);
            }
        }
        ReleaseObj (pnccAdapter);
    }

    TraceError("CALaneCfg::HrRemoveMiniportInstance", hr);
    return hr;
}

HRESULT
CALaneCfg::HrFindNetCardInstance(
    PCWSTR             pszBindNameToFind,
    INetCfgComponent** ppncc)
{
    *ppncc = NULL;

    // Enumerate adapters in the system.
    //
    HRESULT hr = S_OK;
    CIterNetCfgComponent nccIter (m_pnc, &GUID_DEVCLASS_NET);
    BOOL fFound = FALSE;

    INetCfgComponent* pnccAdapter;
    while ((!fFound) && SUCCEEDED(hr) &&
           S_OK == (hr = nccIter.HrNext (&pnccAdapter)))
    {
        //  Get the bindname of the miniport
        PWSTR pszBindName;
        hr = pnccAdapter->GetBindName(&pszBindName);

        if (S_OK == hr)
        {
            //  If the right one tell it to remove itself and end
            fFound = !lstrcmpiW(pszBindName, pszBindNameToFind);
            CoTaskMemFree (pszBindName);

            if (fFound)
            {
                *ppncc = pnccAdapter;
            }
        }

        if (!fFound)
        {
            ReleaseObj (pnccAdapter);
        }
    }

    TraceHr(ttidError, FAL, hr, (S_FALSE == hr),
        "CALaneCfg::HrFindNetCardInstance", hr);
    return hr;
}

VOID CALaneCfg::HrMarkAllDeleted()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    ELAN_INFO_LIST::iterator            iterLstElans;

    // loop thru the adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        (*iterLstAdapters)->m_fDeleted = TRUE;

        // loop thru the ELAN list
        for (iterLstElans = (*iterLstAdapters)->m_lstElans.begin();
                iterLstElans != (*iterLstAdapters)->m_lstElans.end();
                iterLstElans++)
        {
            (*iterLstElans)->m_fDeleted = TRUE;
        }
    }

    return;
}

VOID CALaneCfg::UpdateElanDisplayNames()
{
    HRESULT hr = S_OK;

    // loop thru the adapter list
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        // loop thru the ELAN list
        ELAN_INFO_LIST::iterator    iterLstElans;
        CALaneCfgElanInfo * pElanInfo;

        for (iterLstElans = (*iterLstAdapters)->m_lstElans.begin();
                iterLstElans != (*iterLstAdapters)->m_lstElans.end();
                iterLstElans++)
        {
            pElanInfo = *iterLstElans;

            //  Update the miniport's display name with
            //  the ELAN name appended.
            INetCfgComponent*   pnccAtmElan   = NULL;
            hr = HrFindNetCardInstance(pElanInfo->SzGetElanBindName(),
                                       &pnccAtmElan);
            if (S_OK == hr)
            {
                PWSTR pszDisplayName;
                hr = pnccAtmElan->GetDisplayName(&pszDisplayName);
                if (S_OK == hr)
                {
                    tstring     strNewDisplayName;
                    int         pos;

                    strNewDisplayName = pszDisplayName;
                    pos = strNewDisplayName.find_last_of(L"(");
                    if (pos != strNewDisplayName.npos)
                        strNewDisplayName.resize(pos);
                    strNewDisplayName.append(L"(");

                    if (lstrlenW(pElanInfo->SzGetElanName()) > 0)
                    {
                        strNewDisplayName.append(pElanInfo->SzGetElanName());
                    }
                    else
                    {
                        strNewDisplayName.append(SzLoadIds(IDS_ALANECFG_UNSPECIFIEDNAME));
                    }

                    strNewDisplayName.append(L")");

                    (VOID)pnccAtmElan->SetDisplayName(strNewDisplayName.c_str());
                    CoTaskMemFree(pszDisplayName);
                }

                ReleaseObj(pnccAtmElan);
            }
        }
    }
}

HRESULT CALaneCfg::HrALaneSetupPsh(HPROPSHEETPAGE** pahpsp)
{
    HRESULT             hr      = S_OK;
    HPROPSHEETPAGE*     ahpsp   = NULL;

    AssertSz(pahpsp, "We must have a place to put prop sheets");

    // set connections context
    hr = HrSetConnectionContext();
    if SUCCEEDED(hr)
    {
        // copy the primary adapter list to the secondary adapters list
        CopyAdapterInfoPrimaryToSecondary();

        *pahpsp = NULL;

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE*)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE));
        if (ahpsp)
        {
            if (!m_ppsp)
                delete m_ppsp;

            // Allocate each of the CPropSheetPage objects
            m_ppsp = new CALanePsh(this, m_pAdapterSecondary, g_aHelpIDs_IDD_MAIN);

            // Create the actual PROPSHEETPAGE for each object.
            // This needs to be done regardless of whether the classes existed before.
            ahpsp[0] = m_ppsp->CreatePage(IDD_MAIN, PSP_DEFAULT);

            *pahpsp = ahpsp;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    TraceError("CALaneCfg::HrALaneSetupPsh", hr);
    return hr;
}

// Added by tongl at 12\11\97
HRESULT CALaneCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CALaneCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (S_OK == hr)
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);

        WCHAR szGuid[c_cchGuidWithTerm];
        INT cch = StringFromGUID2(guidConn, szGuid, c_cchGuidWithTerm);
        Assert(cch);
        m_strGuidConn = szGuid;
    }
    ReleaseObj(pLanConnUiInfo);

    TraceError("CALaneCfg::HrSetConnectionContext", hr);
    return hr;
}

VOID CALaneCfg::CopyAdapterInfoPrimaryToSecondary()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;

    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;
    CALaneCfgElanInfo *                 pElanInfoNew;

    // free any existing secondary data
    ClearAdapterInfo(m_pAdapterSecondary);
    m_pAdapterSecondary = NULL;

    // loop thru the primary adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        // create new and copy from primary
        if (FIsSubstr(m_strGuidConn.c_str(), pAdapterInfo->SzGetAdapterBindName()))
        {
            // we found a match
            m_pAdapterSecondary = new CALaneCfgAdapterInfo;

            m_pAdapterSecondary->m_guidInstanceId = pAdapterInfo-> m_guidInstanceId;
            m_pAdapterSecondary->m_fDeleted = pAdapterInfo->m_fDeleted;
            m_pAdapterSecondary->SetAdapterBindName(pAdapterInfo->SzGetAdapterBindName());
            m_pAdapterSecondary->SetAdapterPnpId(pAdapterInfo->SzGetAdapterPnpId());

            // loop thru the elan list on this adapter

            for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                    iterLstElans != pAdapterInfo->m_lstElans.end();
                    iterLstElans++)
            {
                pElanInfo = *iterLstElans;

                // create new and copy from primary
                pElanInfoNew = new CALaneCfgElanInfo;

                pElanInfoNew->SetElanBindName(pElanInfo->SzGetElanBindName());
                pElanInfoNew->SetElanDeviceName(pElanInfo->SzGetElanDeviceName());
                pElanInfoNew->SetElanName(pElanInfo->SzGetElanName());
                pElanInfoNew->m_fDeleted = pElanInfo->m_fDeleted;
                pElanInfoNew->m_fNewElan = pElanInfo->m_fNewElan;
                pElanInfoNew->m_fRemoveMiniportOnPropertyApply = FALSE;
                pElanInfoNew->m_fCreateMiniportOnPropertyApply = FALSE;

                // push onto new secondary adapter's elan list

                m_pAdapterSecondary->m_lstElans.push_back(pElanInfoNew);
            }
            break;
        }
    }

    Assert(m_pAdapterSecondary != NULL);
    return;
}

VOID CALaneCfg::CopyAdapterInfoSecondaryToPrimary()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;
    CALaneCfgAdapterInfo *              pAdapterInfoNew;
    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;
    CALaneCfgElanInfo *                 pElanInfoNew;

    // loop thru the primary adapter list
    for (iterLstAdapters = m_lstAdaptersPrimary.begin();
            iterLstAdapters != m_lstAdaptersPrimary.end();
            iterLstAdapters++)
    {
        pAdapterInfo = *iterLstAdapters;

        if (FIsSubstr(m_strGuidConn.c_str(), pAdapterInfo->SzGetAdapterBindName()))
        {
            pAdapterInfo->m_fDeleted = m_pAdapterSecondary->m_fDeleted;
            pAdapterInfo->SetAdapterBindName(m_pAdapterSecondary->SzGetAdapterBindName());
            pAdapterInfo->SetAdapterPnpId(m_pAdapterSecondary->SzGetAdapterPnpId());

            // rebuild Elan list
            ClearElanList(&pAdapterInfo->m_lstElans);

            // loop thru the elan list on this adapter
            for (iterLstElans = m_pAdapterSecondary->m_lstElans.begin();
                    iterLstElans != m_pAdapterSecondary->m_lstElans.end();
                    iterLstElans++)
            {
                pElanInfo = *iterLstElans;

                // create new and copy from secondary
                pElanInfoNew = new CALaneCfgElanInfo;

                pElanInfoNew->SetElanBindName(pElanInfo->SzGetElanBindName());
                pElanInfoNew->SetElanDeviceName(pElanInfo->SzGetElanDeviceName());
                pElanInfoNew->SetElanName(pElanInfo->SzGetElanName());
                pElanInfoNew->m_fDeleted = pElanInfo->m_fDeleted;
                pElanInfoNew->m_fNewElan = pElanInfo->m_fNewElan;
                pElanInfoNew->m_fRemoveMiniportOnPropertyApply = FALSE;
                pElanInfoNew->m_fCreateMiniportOnPropertyApply = FALSE;

                // add to adapter's elan list
                pAdapterInfo->m_lstElans.push_back(pElanInfoNew);
            }
            break;
        }
    }
    return;
}

HRESULT CALaneCfg::HrReconfigLane(CALaneCfgAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    // Note: if atm physical adapter is deleted, no notification of removing elan
    // is necessary. Lane protocol driver will know to delete all the elans
    // (confirmed above with ArvindM 3/12).

    // Raid #371343, don't send notification if ATM card not connected
    if ((!pAdapterInfo->m_fDeleted) && 
        FIsAdapterEnabled(&(pAdapterInfo->m_guidInstanceId)))  
    {
        ElanChangeType elanChangeType;

        // loop thru the elan list on this adapter
        ELAN_INFO_LIST::iterator    iterLstElans;

        for (iterLstElans = pAdapterInfo->m_lstElans.begin();
                iterLstElans != pAdapterInfo->m_lstElans.end();
                iterLstElans++)
        {
            CALaneCfgElanInfo * pElanInfo = *iterLstElans;

            // if this Elan is marked as for delete
            if (pElanInfo->m_fDeleted)
            {
                PCWSTR szBindName = pElanInfo->SzGetElanBindName();

                if (lstrlenW(szBindName)) // only if the bindname is not empty
                {
                    // notify deletion
                    elanChangeType = DEL_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);
                }
            }
            else
            {
                BOOL fFound = FALSE;

                ELAN_INFO_LIST::iterator    iterLstOldElans;

                // loop through the old elan list, see if we can find a match
                for (iterLstOldElans = pAdapterInfo->m_lstOldElans.begin();
                        iterLstOldElans != pAdapterInfo->m_lstOldElans.end();
                        iterLstOldElans++)
                {
                    CALaneCfgElanInfo * pOldElanInfo = * iterLstOldElans;

                    if (0 == lstrcmpiW(pElanInfo->SzGetElanBindName(),
                                      pOldElanInfo->SzGetElanBindName()))
                    {
                        // we found a match
                        fFound = TRUE;

                        // has the elan name changed ?
                        if (lstrcmpiW(pElanInfo->SzGetElanName(),
                                     pOldElanInfo->SzGetElanName()) != 0)
                        {
                            elanChangeType = MOD_ELAN;
                            hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                                    elanChangeType);
                        }
                    }
                }

                if (!fFound)
                {
                    elanChangeType = ADD_ELAN;
                    hr = HrNotifyElanChange(pAdapterInfo, pElanInfo,
                                            elanChangeType);

                    // Raid #384380: If no ELAN was installed, ignore the error
                    if ((S_OK != hr) &&(m_fNoElanInstalled))
                    {
                        TraceError("Adding ELAN failed but error ignored since there was no ELAN installed so LANE driver is not started, reset hr to S_OK", hr);
                        hr = S_OK;
                    }
                }
            }
        }
    }

    TraceError("CALaneCfg::HrReconfigLane", hr);
    return hr;
}

HRESULT CALaneCfg::HrNotifyElanChange(CALaneCfgAdapterInfo * pAdapterInfo,
                                      CALaneCfgElanInfo * pElanInfo,
                                      ElanChangeType elanChangeType)
{
    // ATMLANE_PNP_RECONFIG_REQUEST is defined in \nt\private\inc\laneinfo.h

    const DWORD dwBytes = sizeof(ATMLANE_PNP_RECONFIG_REQUEST) +
                          CbOfSzAndTerm (pElanInfo->SzGetElanBindName());

    ATMLANE_PNP_RECONFIG_REQUEST* pLaneReconfig;

    HRESULT hr = HrMalloc (dwBytes, (PVOID*)&pLaneReconfig);
    if (SUCCEEDED(hr))
    {
        pLaneReconfig->Version =1;
        pLaneReconfig->OpType = elanChangeType;
        pLaneReconfig->ElanKeyLength = lstrlenW(pElanInfo->SzGetElanBindName())+1;
        lstrcpyW(pLaneReconfig->ElanKey, pElanInfo->SzGetElanBindName());

        hr = HrSendNdisPnpReconfig( NDIS, c_szAtmLane,
                                    pAdapterInfo->SzGetAdapterBindName(),
                                    pLaneReconfig,
                                    dwBytes);
        if ( S_OK != hr)
        {
            TraceError("Notifying LANE of ELAN change returns failure, prompt for reboot ...", hr);
            hr = NETCFG_S_REBOOT;
        }

        MemFree (pLaneReconfig);
    }
    TraceError("CALaneCfg::HrNotifyElanChange", hr);
    return hr;
}

BOOL CALaneCfg::FIsAdapterEnabled(const GUID* pguidId)
{
    FARPROC pfnHrGetPnpDeviceStatus;
    HMODULE hNetman;

    HRESULT         hr = S_OK;
    NETCON_STATUS   ncStatus = NCS_CONNECTED;

    hr = HrLoadLibAndGetProc(L"netman.dll", "HrGetPnpDeviceStatus",
                             &hNetman, &pfnHrGetPnpDeviceStatus);

    if (SUCCEEDED(hr))
    {
        hr = (*(PHRGETPNPDEVICESTATUS)pfnHrGetPnpDeviceStatus)(
                pguidId, &ncStatus);

        FreeLibrary(hNetman);
    }

    return (NCS_CONNECTED == ncStatus);
}

//
//  CALaneCfgAdapterInfo
//

CALaneCfgAdapterInfo::CALaneCfgAdapterInfo(VOID)
{
    m_fDeleted = FALSE;
    m_fBindingChanged = FALSE;

    return;
}

CALaneCfgAdapterInfo::~CALaneCfgAdapterInfo(VOID)
{
    ClearElanList(&m_lstElans);
    ClearElanList(&m_lstOldElans);
    return;
}

VOID CALaneCfgAdapterInfo::SetAdapterBindName(PCWSTR pszAdapterBindName)
{
    m_strAdapterBindName = pszAdapterBindName;
    return;
}

PCWSTR CALaneCfgAdapterInfo::SzGetAdapterBindName(VOID)
{
    return m_strAdapterBindName.c_str();
}

VOID CALaneCfgAdapterInfo::SetAdapterPnpId(PCWSTR pszAdapterPnpId)
{
    m_strAdapterPnpId = pszAdapterPnpId;
    return;
}

PCWSTR CALaneCfgAdapterInfo::SzGetAdapterPnpId(VOID)
{
    return m_strAdapterPnpId.c_str();
}

//
//  CALaneCfgElanInfo
//

CALaneCfgElanInfo::CALaneCfgElanInfo(VOID)
{
    m_fDeleted = FALSE;
    m_fNewElan = FALSE;

    m_fCreateMiniportOnPropertyApply = FALSE;
    m_fRemoveMiniportOnPropertyApply = FALSE;
    return;
}

VOID CALaneCfgElanInfo::SetElanBindName(PCWSTR pszElanBindName)
{
    m_strElanBindName = pszElanBindName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanBindName(VOID)
{
    return m_strElanBindName.c_str();
}

VOID CALaneCfgElanInfo::SetElanDeviceName(PCWSTR pszElanDeviceName)
{
    m_strElanDeviceName = pszElanDeviceName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanDeviceName(VOID)
{
    return m_strElanDeviceName.c_str();
}

VOID CALaneCfgElanInfo::SetElanName(PCWSTR pszElanName)
{
    m_strElanName = pszElanName;
    return;
}

VOID CALaneCfgElanInfo::SetElanName(PWSTR pszElanName)
{
    m_strElanName = pszElanName;
    return;
}

PCWSTR CALaneCfgElanInfo::SzGetElanName(VOID)
{
    return m_strElanName.c_str();
}

// utility functions

void ClearElanList(ELAN_INFO_LIST *plstElans)
{
    ELAN_INFO_LIST::iterator            iterLstElans;
    CALaneCfgElanInfo *                 pElanInfo;

    for (iterLstElans = plstElans->begin();
            iterLstElans != plstElans->end();
            iterLstElans++)
    {
        pElanInfo = *iterLstElans;
        delete pElanInfo;
    }

    plstElans->clear();
    return;
}

void ClearAdapterList(ATMLANE_ADAPTER_INFO_LIST *plstAdapters)
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *              pAdapterInfo;
    ELAN_INFO_LIST::iterator            iterLstElans;

    for (iterLstAdapters = plstAdapters->begin();
            iterLstAdapters != plstAdapters->end();
            iterLstAdapters++)
    {

        pAdapterInfo = *iterLstAdapters;

        ClearElanList(&pAdapterInfo->m_lstElans);

        delete pAdapterInfo;
    }

    plstAdapters->clear();

    return;
}

void ClearAdapterInfo(CALaneCfgAdapterInfo * pAdapterInfo)
{
    ELAN_INFO_LIST::iterator            iterLstElans;

    if (pAdapterInfo)
    {
        ClearElanList(&pAdapterInfo->m_lstElans);
        delete pAdapterInfo;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\trace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       T R A C E . H
//
//  Contents:   Class definition for CTracing
//
//  Notes:
//
//  Author:     jeffspr   15 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "tracetag.h"
#include "algorithm"
#include "deque"
#include "map"

#define TAKEOWNERSHIP
// IN:  TakeOwnership means that we are handing a pointer to another API, and thus we're not freeing it (unless the API fails).
// OUT: TakeOwnership means that we are responsible for freeing a pointer passed to us.
#define WACKYAPI
// IN:  For Callback functions. WackyAPI means a pointer to non-const passed to us as an IN argument.

#ifdef ENABLETRACE

// This is needed for TraceHr, since we can't use a macro (vargs), but we
// need to get the file and line from the source.
#define FAL __FILE__,__LINE__,__FUNCTION__

// The Trace Stack functions
#if defined (_IA64_)
#include <ia64reg.h>

extern "C" unsigned __int64 __getReg(int whichReg);
extern "C" void __setReg(int whichReg, __int64 value);
#pragma intrinsic(__getReg)
#pragma intrinsic(__setReg)

#define GetR32 __getReg(CV_IA64_IntR32)
#define GetR33 __getReg(CV_IA64_IntR33)
#define GetR34 __getReg(CV_IA64_IntR34)
#endif // defined(_IA64_)

extern "C" void* _ReturnAddress(void);
#pragma intrinsic(_ReturnAddress)

extern LPCRITICAL_SECTION g_csTracing;

class CTracingIndent;

class CTracingFuncCall
{
public:
#if defined (_X86_) || defined (_AMD64_)
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD_PTR ReturnAddress, const DWORD_PTR dwFramePointer);
#elif defined (_IA64_) 
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, const DWORD_PTR ReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    CTracingFuncCall(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    
    CTracingFuncCall(const CTracingFuncCall& TracingFuncCall);
    ~CTracingFuncCall();

public:
    LPSTR   m_szFunctionName;
    LPSTR   m_szFunctionDName;
    LPSTR   m_szFile;
    DWORD_PTR m_ReturnAddress;

#if defined (_X86_)
    DWORD   m_arguments[3];
#elif defined (_IA64_ ) || defined (_AMD64_)
    __int64 m_arguments[3];
#else
    // ... add other processors here
#endif

    DWORD_PTR m_dwFramePointer;
    DWORD   m_dwThreadId;
    DWORD   m_dwLine;
    
    friend CTracingIndent;
};

class CTracingThreadInfo
{
public:
    CTracingThreadInfo();
    ~CTracingThreadInfo();

public:
    LPVOID m_pfnStack;
    DWORD m_dwLevel;
    DWORD m_dwThreadId;
    friend CTracingIndent;
};

class CTracingIndent
{
    LPSTR   m_szFunctionDName;
    DWORD_PTR m_dwFramePointer;
    BOOL    bFirstTrace;
    
public:
#if defined (_X86_) || defined (_AMD64_)
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const DWORD_PTR dwFramePointer);
#elif defined (_IA64_) 
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine, LPCVOID pReturnAddress, const __int64 Args1, const __int64 Args2, const __int64 Args3);
#else
    void AddTrace(LPCSTR szFunctionName, LPCSTR szFunctionDName, LPCSTR szFile, const DWORD dwLine);
#endif
    void RemoveTrace(LPCSTR szFunctionDName, const DWORD_PTR dwFramePointer);

    CTracingIndent();
    ~CTracingIndent();

    static CTracingThreadInfo* GetThreadInfo();
    static void FreeThreadInfo();
    static DWORD getspaces();
    static void TraceStackFn(TRACETAGID TraceTagId);
    static void TraceStackFn(IN OUT LPSTR szString, IN OUT LPDWORD pdwSize);
};


#define IDENT_ADD2(x) indent ## x
#define IDENT_ADD(x)  IDENT_ADD2(x)
#define __INDENT__ IDENT_ADD(__LINE__)

#define FP_ADD2(x) FP ## x
#define FP_ADD(x)  FP_ADD2(x)
#define __FP__ FP_ADD(__LINE__)

#if defined (_X86_)
#define AddTraceLevel \
    __if_not_exists(NetCfgFramePointer) \
    { \
        DWORD NetCfgFramePointer;  \
        BOOL fForceC4715Check = TRUE;  \
    } \
    if (fForceC4715Check) \
    { \
        __asm { mov NetCfgFramePointer, ebp }; \
    } \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), NetCfgFramePointer);
#elif defined (_IA64_) 
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), 0, 0, 0);

    // NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), GetR32, GetR33, GetR34);
    // ISSUE: GetR32, GetR33, GetR34 is inherently unsafe and can cause an STATUS_REG_NAT_CONSUMPTION exception
    // if a register is being read that has the NAT bit set. Removing this for now until the compiler
    // team provides a safe version of __getReg
#elif defined (_AMD64_)
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__, _ReturnAddress(), 0);
#else
#define AddTraceLevel \
    __if_not_exists(NetCfgIndent) \
    { \
        CTracingIndent NetCfgIndent; \
    } \
    NetCfgIndent.AddTrace(__FUNCTION__, __FUNCDNAME__, __FILE__, __LINE__);
#endif

// Trace error functions. The leaading _ is to establish the real function,
// while adding a new macro so we can add __FILE__ and __LINE__ to the output.
//
VOID    WINAPI   TraceErrorFn           (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr);
VOID    WINAPI   TraceErrorOptionalFn   (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, BOOL fOpt);
VOID    WINAPI   TraceErrorSkipFn       (PCSTR pszaFile, INT nLine, PCSTR psza, HRESULT hr, UINT c, ...);
VOID    WINAPIV  TraceLastWin32ErrorFn  (PCSTR pszaFile, INT nLine, PCSTR psza);

#define TraceError(sz, hr)                      TraceErrorFn(__FILE__, __LINE__, sz, hr);
#define TraceErrorOptional(sz, hr, _bool)       TraceErrorOptionalFn(__FILE__, __LINE__, sz, hr, _bool);
#define TraceErrorSkip1(sz, hr, hr1)            TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 1, hr1);
#define TraceErrorSkip2(sz, hr, hr1, hr2)       TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 2, hr1, hr2);
#define TraceErrorSkip3(sz, hr, hr1, hr2, hr3)  TraceErrorSkipFn(__FILE__, __LINE__, sz, hr, 3, hr1, hr2, hr3);
#define TraceLastWin32Error(sz)                 TraceLastWin32ErrorFn(__FILE__,__LINE__, sz);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceHrFn (
    TRACETAGID  ttid,
    PCSTR       pszaFile,
    INT         nLine,
    PCSTR       pszaFunc,
    HRESULT     hr,
    BOOL        fIgnore,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceTagFn (
    TRACETAGID  ttid,
    PCSTR       pszaFmt,
    ...);

VOID
WINAPIV
TraceFileFuncFn (
            TRACETAGID  ttid);



#define TraceFileFunc(ttidWhich) AddTraceLevel; TraceFileFuncFn(ttidWhich);
#define TraceStack(ttidWhich) AddTraceLevel; CTracingIndent::TraceStackFn(ttidWhich);
#define TraceStackToString(szString, nSize) AddTraceLevel; CTracingIndent::TraceStackFn(szString, nSize);

#ifdef COMPILE_WITH_TYPESAFE_PRINTF
DEFINE_TYPESAFE_PRINTF2(int, TraceTag,  TRACETAGID, LPCSTR)
DEFINE_TYPESAFE_PRINTF3(int, TraceHr,   TRACETAGID, LPCSTR, INT)
#else
#define TraceHr AddTraceLevel; TraceHrFn
#define TraceTag AddTraceLevel; TraceTagFn
#endif

#define TraceException(hr, szExceptionName) TraceHr(ttidError, FAL, hr, FALSE, "A (%s) exception occurred", szExceptionName);


LPCSTR DbgEvents(DWORD Event);
LPCSTR DbgEventManager(DWORD EventManager);
LPCSTR DbgNcm(DWORD ncm);
LPCSTR DbgNcs(DWORD ncs);
LPCSTR DbgNccf(DWORD nccf);
LPCSTR DbgNcsm(DWORD ncsm);

#else   // !ENABLETRACE

#define FAL                                         (void)0
#define TraceError(_sz, _hr)
#define TraceErrorOptional(_sz, _hr, _bool)
#define TraceErrorSkip1(_sz, _hr, _hr1)
#define TraceErrorSkip2(_sz, _hr, _hr1, _hr2)
#define TraceErrorSkip3(_sz, _hr, _hr1, _hr2, _hr3)
#define TraceLastWin32Error(_sz)
#define TraceHr                                       NOP_FUNCTION
#define TraceTag                                      NOP_FUNCTION
#define TraceFileFunc(ttidWhich)                      NOP_FUNCTION
#define TraceException(hr, szExceptionName)           NOP_FUNCTION
#define TraceStack(ttidWhich)                         NOP_FUNCTION
#define TraceStackToString(szString, nSize)           NOP_FUNCTION

#define DbgEvents(Event) ""
#define DbgEventManager(EventManager) ""
#define DbgNcm(ncm) ""
#define DbgNcs(ncs) ""
#define DbgNccf(nccf) ""
#define DbgNcsm(nccf) ""

#endif  // ENABLETRACE

#ifdef ENABLETRACE

//---[ Initialization stuff ]-------------------------------------------------

HRESULT HrInitTracing(BOOL bDisableFaultInjection);
HRESULT HrUnInitTracing();
HRESULT HrOpenTraceUI(HWND  hwndOwner);

#endif // ENABLETRACE

//#define ENABLELEAKDETECTION

#if (defined(ENABLETRACE) && defined(ENABLELEAKDETECTION))

template <class T> class CNetCfgDebug; // Fwd template to make this friendly to CObjectLeakTrack

//+---------------------------------------------------------------------------
//
//  class:      CObjectLeakTrack
//
//  Purpose:    Keep a list of all the CNetCfgDebug derived object instances and
//              dump these out on request
//
//  Author:     deonb  7 July 2001
//
//  Notes:      The data types in here are of type LPVOID in order to minimize
//              dependencies when including the trace header.
//  
class CObjectLeakTrack
{
public:
    CObjectLeakTrack();
    ~CObjectLeakTrack();
    void DumpAllocatedObjects(IN TRACETAGID TraceTagId, IN LPCSTR szClassName);
    BOOL AssertIfObjectsStillAllocated(IN LPCSTR szClassName);

protected: 
    // For these, pThis is really of type CNetCfgDebug<T> *. Since this should only ever be called
    // from CNetCfgDebug or ISSUE_knownleak, we are ok with the lack of compile-time type checking.
    void Insert(IN LPCVOID pThis, IN LPCSTR szdbgClassName, IN TAKEOWNERSHIP LPSTR pszConstructionStack);
    void Remove(IN LPCVOID pThis);

    friend class CNetCfgDebug;
    friend void RemoveKnownleakFn(LPCVOID pThis);

protected:
    LPVOID g_mapObjLeak; // This will actually be of type map<LPCVOID, pair<LPSTR, LPSTR> > ;
};

extern CObjectLeakTrack *g_pObjectLeakTrack; // The global list of NetConfig objects in the process.
                                             // Call DumpAllocatedObjects on this to dump out the objects.
void RemoveKnownleakFn(LPCVOID pThis);

//+---------------------------------------------------------------------------
//
//  class:      CNetCfgDebug
//
//  Purpose:    In order to debug instance leaks of your class instances, you can
//              derive your class from CNetCfgDebug. This adds no data members nor 
//              a v-table nor virtual functions to your class. It will add 
//              a constructor and destructor that will be called before & after yours
//              respectively, in order to keep track of your class instances.
//  
//              This will only happen on CHK builds. On FRE builds deriving from this
//              class has no effect, and is safe.
//
//  Author:     deonb  7 July 2001
//
//  Notes:      
//              This is s an ATL style parent template derive, e.g.:
//              CNetCfgDbg<parent>
//              e.g.
//              
//              class CConnectionManager : public ClassX, 
//                                         public classY,
//                                         public CNetCfgBase<CConnectionManager>
//
//              No other interaction with your class is needed. This will now automatically 
//              keep a list of all the instances allocated of this class (in debug mode), 
//              with a stack trace where they were allocated from. This is a Tracing
//              stack trace so it's only successful for functions inside the callstack which
//              actually used a TraceXxx statement (any trace statement) before they called
//              the child functions.
//
//              e.g. 
//              void X()
//              {
//                  TraceFileFunc(ttidSomething);
//                  void Y()
//                  {
//                      void Z()
//                      {
//                          TraceTag(ttidSomething, "allocation class");
//                          CConnectionManager *pConnectionManager = new CConnectionManager();
//                      }
//                      TraceTag(ttidSomething, "Z called");
//                  }
//              }
//  
//              This will spew the following when the process terminates (or when TraceAllocatedObjects is called):
//              ASSERT: "An object leak has been detected. Please attach a user or kernel mode debugger and hit 
//                       IGNORE to dump the offending stacks"
//              
//              The object of type 'class CConnectionManager' allocated at 0x7fe2345 has not been freed:
//                  it was constructed from the stack below: 
//              Z [EBP: 0x731d3128] 0x00000001 0x00000000 0x0000000a
//              X [EBP: 0x731d310f] 0x0000000f 0x0000000e 0x0000000a
//
//              (since Y() did not contain a trace statement before the call to Z() )
//
template <class T> 
class CNetCfgDebug
{
public:
    CNetCfgDebug()
    {
        if (FIsDebugFlagSet(dfidTrackObjectLeaks))
        {
            if (g_csTracing && g_pObjectLeakTrack)
            {
                EnterCriticalSection(g_csTracing);

                DWORD dwConstructionStackSize = 16384;
                LPSTR pszConstructionStack = new CHAR[dwConstructionStackSize];
                if (pszConstructionStack)
                {
                    TraceStackToString(pszConstructionStack, &dwConstructionStackSize);

                    if (dwConstructionStackSize < 16384)
                    {
                        // Reduce the amount of memory required
                        LPSTR szTemp = new CHAR[dwConstructionStackSize];
                        if (szTemp)
                        {
                            memcpy(szTemp, pszConstructionStack, dwConstructionStackSize);
                            delete[] pszConstructionStack;

                            pszConstructionStack = szTemp;
                        }
                    }
                    else
                    {
                        
                    }
                }

                TraceTag(ttidAllocations, "An object of type '%s' was allocated at '0x%08x'", typeid(T).name(), this);
                g_pObjectLeakTrack->Insert(this, typeid(T).name(), pszConstructionStack); // ok to insert if pszConstructionStack is NULL.

                LeaveCriticalSection(g_csTracing);
            }
        }
    };

    ~CNetCfgDebug()
    {
        if (FIsDebugFlagSet(dfidTrackObjectLeaks))
        {
            if (g_csTracing && g_pObjectLeakTrack)
            {
                EnterCriticalSection(g_csTracing);

                TraceTag(ttidAllocations, "An object of type '%s' was deleted at '0x%08x'", typeid(T).name(), this);
                g_pObjectLeakTrack->Remove(this);

                LeaveCriticalSection(g_csTracing);
            }
        }
    };
};

#define ISSUE_knownleak(pThis) RemoveKnownleakFn(pThis);

#define TraceAllocatedObjects(ttidWhich, ClassName) g_pObjectLeakTrack->DumpAllocatedObjects(ttidWhich, typeid(ClassName).name());
#define AssertIfAllocatedObjects(ClassName)         g_pObjectLeakTrack->AssertIfObjectsStillAllocated(typeid(ClassName).name());

#define TraceAllAllocatedObjects(ttidWhich) g_pObjectLeakTrack->DumpAllocatedObjects(ttidWhich, NULL);
#define AssertIfAnyAllocatedObjects()       g_pObjectLeakTrack->AssertIfObjectsStillAllocated(NULL);

#else // ENABLETRACE && ENABLELEAKDETECTION

template <class T> 
    class CNetCfgDebug
{
};

#define ISSUE_knownleak(pThis)                        NOP_FUNCTION
#define TraceAllocatedObjects(ttidWhich, ClassName) NOP_FUNCTION
#define AssertIfAllocatedObjects(ClassName)         NOP_FUNCTION

#define TraceAllAllocatedObjects(ttidWhich) NOP_FUNCTION
#define AssertIfAnyAllocatedObjects()       NOP_FUNCTION

#endif // ENABLETRACE && ENABLELEAKDETECTION
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\inc\stlxstdd.h ===
#pragma once
#ifndef _STLXSTDD_H_
#define _STLXSTDD_H_

//#ifndef _YVALS
//#include <yvals.h>
//#endif
//#include <cstddef>

#include <stddef.h>

/*
// Define _CRTIMP
#ifndef _CRTIMP
#ifdef  CRTDLL2
#define _CRTIMP __declspec(dllexport)
#else   // ndef CRTDLL2
#ifdef  _DLL
#define _CRTIMP __declspec(dllimport)
#else   // ndef _DLL
#define _CRTIMP
#endif  // _DLL
#endif  // CRTDLL2
#endif  // _CRTIMP
*/

#ifdef  _MSC_VER
#pragma pack(push,8)
#endif  /* _MSC_VER */


// begin yyvals.h include

//#pragma warning(4: 4018 4114 4146 4244 4245)
//#pragma warning(4: 4663 4664 4665)
//#pragma warning(disable: 4237 4514)

// 4284:
// return type for 'identifier::operator >' is not a UDT or reference to a
// UDT. Will produce errors if applied using infix notation
//
#pragma warning(disable: 4284)

// 4290: C++ Exception Specification ignored
// A function was declared using exception specification.
// At this time the implementation details of exception specification have
// not been standardized, and are accepted but not implemented in Microsoft
// Visual C++.
//
#pragma warning(disable: 4290)



// NAMESPACE
#if defined(__cplusplus)
#define _STD            std::
#define _STD_BEGIN      namespace std {
#define _STD_END        };
#define _STD_USING
#else
#define _STD            ::
#define _STD_BEGIN
#define _STD_END
#endif // __cplusplus

_STD_BEGIN

// TYPE bool
#if defined(__cplusplus)
typedef bool _Bool;
#endif // __cplusplus

// INTEGER PROPERTIES
#define _MAX_EXP_DIG    8   // for parsing numerics
#define _MAX_INT_DIG    32
#define _MAX_SIG_DIG    36

// STDIO PROPERTIES
#define _Filet _iobuf

#ifndef _FPOS_T_DEFINED
#define _FPOSOFF(fp)    ((long)(fp))
#endif // _FPOS_T_DEFINED

// NAMING PROPERTIES
#if defined(__cplusplus)
#define _C_LIB_DECL extern "C" {
#define _END_C_LIB_DECL }
#else
#define _C_LIB_DECL
#define _END_C_LIB_DECL
#endif // __cplusplus
#define _CDECL

/*
// CLASS _Lockit
#if defined(__cplusplus)
class _CRTIMP _Lockit
{   // lock while object in existence
public:
    #ifdef _MT
        #define _LOCKIT(x)  lockit x
        _Lockit();
        ~_Lockit();
    #else
        #define _LOCKIT(x)
        _Lockit()
        {
        }
        ~_Lockit()
        {
        }
    #endif // _MT
};
#endif // __cplusplus
*/

// MISCELLANEOUS MACROS
#define _L(c)   L##c
#define _Mbstinit(x)    mbstate_t x = {0}
#define _MAX    _cpp_max
#define _MIN    _cpp_min

// end yyvals.h include


// EXCEPTION MACROS
//#define _TRY_BEGIN              try {
//#define _CATCH(x)               } catch (x) {
//#define _CATCH_ALL              } catch (...) {
//#define _CATCH_END              }
#define _RAISE(x)               throw (x)
//#define _RERAISE                throw
#define _THROW0()               throw ()
#define _THROW1(x)              throw (x)
#define _THROW(x, y)            throw x(y)

// explicit KEYWORD
// BITMASK MACROS
#define _BITMASK(E, T)          typedef int T
#define _BITMASK_OPS(T)

// MISCELLANEOUS MACROS
#define _DESTRUCTOR(ty, ptr)    (ptr)->~ty()
#define _PROTECTED              public
#define _TDEF(x)                = x
#define _TDEF2(x, y)            = x, y
#define _CNTSIZ(iter)           ptrdiff_t
#define _TDEFP(x)
#define _STCONS(ty, name, val)  enum {name = val}

// TYPE DEFINITIONS
enum _Uninitialized
{
    _Noinit
};

// FUNCTIONS
/*_CRTIMP*/
void __cdecl _Nomemory();

_STD_END

#ifdef  _MSC_VER
#pragma pack(pop)
#endif  /* _MSC_VER */

#endif /* _STLXSTDD_H_ */

/*
 * Copyright (c) 1995 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\alanepsh.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A L A N E P S H . C P P
//
//  Contents:   Dialog box handling for the ATM LAN Emulation configuration.
//
//  Notes:
//
//  Author:     v-lcleet   08/10/1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "alaneobj.h"
#include "alanepsh.h"
#include "alanehlp.h"

#include "ncatlui.h"
#include <algorithm>

//
//  CALanePsh
//
//  Constructor/Destructor methods
//
CALanePsh::CALanePsh(CALaneCfg* palcfg, CALaneCfgAdapterInfo * pAdapterInfo,
                     const DWORD * adwHelpIDs)
{
    AssertSz(palcfg, "We don't have a CALaneCfg*");
    AssertSz(pAdapterInfo, "We don't have a CALaneCfgAdapterInfo *");

    m_palcfg        = palcfg;
    m_pAdapterInfo  = pAdapterInfo;

    m_adwHelpIDs      = adwHelpIDs;

    return;
}

CALanePsh::~CALanePsh(VOID)
{
    return;
}

LRESULT CALanePsh::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& bHandled)
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    m_fEditState = FALSE;

    // Get the Add ELAN button text
    WCHAR   szAddElan[16] = {0};
    GetDlgItemText(IDC_ELAN_ADD, szAddElan, celems(szAddElan));
    szAddElan[lstrlenW(szAddElan) - 3]; // remove ampersand

    m_strAddElan = szAddElan;

    //  get hwnd to the adapter and elan list
    // m_hAdapterList = GetDlgItem(IDC_ADAPTER_LIST);
    m_hElanList = GetDlgItem(IDC_ELAN_LIST);

    //  get hwnd to the three buttons
    m_hbtnAdd = GetDlgItem(IDC_ELAN_ADD);
    m_hbtnEdit = GetDlgItem(IDC_ELAN_EDIT);
    m_hbtnRemove = GetDlgItem(IDC_ELAN_REMOVE);

    //  fill in adapter list
    SendAdapterInfo();

    //  fill in elan list
    SendElanInfo();

    //  set the state of the buttons
    SetButtons();

    SetChangedFlag();

    return 0;
}

LRESULT CALanePsh::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CALanePsh::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CALanePsh::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE; // Allow page to lose active status

    // Check duplicate Elan names on the same ATM adapter
    int iDupElanName = CheckDupElanName();

    if (iDupElanName >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_LANE_TEXT, IDS_DUPLICATE_ELANNAME,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        err = TRUE;
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);

    return err;
}

int CALanePsh::CheckDupElanName()
{
    int ret = -1;
    int idx = 0;

    for(ELAN_INFO_LIST::iterator iterElan = m_pAdapterInfo->m_lstElans.begin();
        iterElan != m_pAdapterInfo->m_lstElans.end();
        iterElan++)
    {
        // skip deleted ones
        if (!(*iterElan)->m_fDeleted)
        {
            ELAN_INFO_LIST::iterator iterElanComp = iterElan;

            iterElanComp++;
            while (iterElanComp != m_pAdapterInfo->m_lstElans.end())
            {
                if (!(*iterElanComp)->m_fDeleted)
                {
                    if (!lstrcmpW( ((*iterElan)->SzGetElanName()),
                                   ((*iterElanComp)->SzGetElanName())))
                    {
                        // we find a duplicate name
                        ret = idx;
                        break;
                    }
                }

                iterElanComp++;
            }

            // duplicate name found
            if (ret >=0 )
                break;

            // move next
            idx ++;
        }
    }

    return ret;
}

LRESULT CALanePsh::OnAdd(WORD wNotifyCode, WORD wID,
                         HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo *     pElanInfo   = NULL;
    CElanPropertiesDialog * pDlgProp    = NULL;

    m_fEditState = FALSE;

    //  create a new ELAN info object
    pElanInfo = new CALaneCfgElanInfo;

    //  create the dialog object, passing in the new ELAN info ptr
    pDlgProp = new CElanPropertiesDialog(this, pElanInfo, g_aHelpIDs_IDD_ELAN_PROPERTIES);

    if (pElanInfo && pDlgProp)
    {
		//  see if user hit ADD
		if (pDlgProp->DoModal() == IDOK)
		{
			//  Push the Elan onto the the adapter's list
			m_pAdapterInfo->m_lstElans.push_back(pElanInfo);

			//  Mark it so miniport gets created if user hits OK/APPLY
			pElanInfo->m_fCreateMiniportOnPropertyApply = TRUE;
			pElanInfo = NULL;   // don't let cleanup delete it

			// refresh the ELAN list
			SendElanInfo();

			//  set the state of the buttons
			SetButtons();
		}
	}

	//  release objects as needed
    if (pElanInfo)
        delete pElanInfo;
    if (pDlgProp)
        delete pDlgProp;

    return 0;
}

LRESULT CALanePsh::OnEdit(WORD wNotifyCode, WORD wID,
                        HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo * pElanInfo;
    int idx;

    m_fEditState = TRUE;

    //  get index of current ELAN selection
    idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
    Assert(idx >= 0);

    //  get the ElanInfo pointer from the current selection
    pElanInfo = (CALaneCfgElanInfo *)::SendMessage(m_hElanList,
                                            LB_GETITEMDATA, idx, 0L);

    //  create the dialog, passing in the ELAN info ptr
    CElanPropertiesDialog * pDlgProp = new CElanPropertiesDialog(this, pElanInfo,
                                                                 g_aHelpIDs_IDD_ELAN_PROPERTIES);

    if (pDlgProp->DoModal() == IDOK)
    {
        // refresh the ELAN list
        SendElanInfo();
    }

    delete pDlgProp;
    return 0;
}


LRESULT CALanePsh::OnRemove(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& bHandled)
{
    CALaneCfgElanInfo * pElanInfo;
    int idx;

    //  get index of current ELAN selection
    idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
    Assert(idx >= 0);

    //  get the ElanInfo pointer from the current selection
    pElanInfo = (CALaneCfgElanInfo *)::SendMessage(m_hElanList,
                                                   LB_GETITEMDATA, idx, 0L);

    //  mark as deleted
    pElanInfo->m_fDeleted = TRUE;
    pElanInfo->m_fRemoveMiniportOnPropertyApply = TRUE;

    // RAID 31445: ATM:  AssertFail in \engine\remove.cpp line 180 
    //             when add & remove ELAN w/o committing changes.
    // mbend 20 May 2000
    //
    // Remove newly created adapters
    if (pElanInfo->m_fCreateMiniportOnPropertyApply)
    {
        ELAN_INFO_LIST::iterator iter = find(
            m_pAdapterInfo->m_lstElans.begin(), 
            m_pAdapterInfo->m_lstElans.end(),
            pElanInfo);

        Assert(m_pAdapterInfo->m_lstElans.end() != iter);
        m_pAdapterInfo->m_lstElans.erase(iter);

        delete pElanInfo;
    }

    // refresh the ELAN list
    SendElanInfo();

    //  set the state of the buttons
    SetButtons();

    return 0;
}

void CALanePsh::SendAdapterInfo()
{
    ATMLANE_ADAPTER_INFO_LIST::iterator iterLstAdapters;
    CALaneCfgAdapterInfo *  pAdapterInfo;

    return;
}

void CALanePsh::SendElanInfo()
{
    ELAN_INFO_LIST::iterator    iterLstElans;
    CALaneCfgElanInfo *         pElanInfo = NULL;

    // pAdapterInfo = GetSelectedAdapter();
    Assert (NULL != m_pAdapterInfo);

    ::SendMessage(m_hElanList, LB_RESETCONTENT, 0, 0L);

    // loop thru the ELANs
    for (iterLstElans = m_pAdapterInfo->m_lstElans.begin();
            iterLstElans != m_pAdapterInfo->m_lstElans.end();
            iterLstElans++)
    {
        int idx;
        pElanInfo = *iterLstElans;

        // only add to list if not deleted

        if (!pElanInfo->m_fDeleted)
        {

            // set name to "unspecified" or actual specified name
            if (0 == lstrlen(pElanInfo->SzGetElanName()))
            {
                idx = (int) ::SendMessage(m_hElanList, LB_ADDSTRING, 0,
                            (LPARAM)(SzLoadIds(IDS_ALANECFG_UNSPECIFIEDNAME)));
            }
            else
            {
                idx = (int) ::SendMessage(m_hElanList, LB_ADDSTRING, 0,
                            (LPARAM)((PCWSTR)(pElanInfo->SzGetElanName())));
            }

            // store pointer to ElanInfo with text
            if (idx != LB_ERR)
                ::SendMessage(m_hElanList, LB_SETITEMDATA, idx,
                        (LPARAM)(pElanInfo));
        }
    }

    //  select the first one

    ::SendMessage(m_hElanList, LB_SETCURSEL, 0, (LPARAM)0);

    return;
}

CALaneCfgElanInfo *CALanePsh::GetSelectedElan()
{
    int         nCount;
    int         idx;
    DWORD_PTR   dw;
    CALaneCfgElanInfo *pElanInfo = NULL;

    nCount = (int) ::SendMessage(m_hElanList, LB_GETCOUNT, 0, 0);
    if (nCount > 0)
    {
        idx = (int) ::SendMessage(m_hElanList, LB_GETCURSEL, 0, 0);
        if (LB_ERR != idx)
        {
            dw = ::SendMessage(m_hElanList, LB_GETITEMDATA, idx, (LPARAM)0);
            if (dw && ((DWORD_PTR)LB_ERR != dw))
            {
                pElanInfo = (CALaneCfgElanInfo *)dw;
            }
        }
    }
    return pElanInfo;
}

void CALanePsh::SetButtons()
{
    int     nCount;

    //  get count of Elans in list
    nCount = (int) ::SendMessage(m_hElanList, LB_GETCOUNT, 0, 0);

    if (!nCount)
    {
        // remove the default on the remove button, if any
        ::SendMessage(m_hbtnRemove, BM_SETSTYLE, (WPARAM)BS_PUSHBUTTON, TRUE );

        // move focus to Add button
        ::SetFocus(m_hbtnAdd);
    }

    //  enable/disable "Edit" and "Remove" buttons based existing Elans
    ::EnableWindow(m_hbtnEdit, !!nCount);
    ::EnableWindow(m_hbtnRemove, !!nCount);

    return;
}

//
//  CElanPropertiesDialog
//

CElanPropertiesDialog::CElanPropertiesDialog(CALanePsh * pCALanePsh,
                                             CALaneCfgElanInfo *pElanInfo,
                                             const DWORD * adwHelpIDs)
{
    m_pParentDlg = pCALanePsh;
    m_pElanInfo = pElanInfo;

    m_adwHelpIDs = adwHelpIDs;

    return;
}


LRESULT CElanPropertiesDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                            LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (m_pParentDlg->m_fEditState == FALSE)
        SetDlgItemText(IDOK, m_pParentDlg->m_strAddElan.c_str());

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog

    HWND hList = ::GetDlgItem(m_pParentDlg->m_hWnd, IDC_ELAN_LIST);
    RECT rect;

    ::GetWindowRect(hList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handle to the edit box
    m_hElanName = GetDlgItem(IDC_ELAN_NAME);

    // ELAN names have a 32 character limit
    ::SendMessage(m_hElanName, EM_SETLIMITTEXT, ELAN_NAME_LIMIT, 0);

    // fill in the edit box with the current elan's name
    ::SetWindowText(m_hElanName, m_pElanInfo->SzGetElanName());
    ::SendMessage(m_hElanName, EM_SETSEL, 0, -1);

    ::SetFocus(m_hElanName);

    return TRUE;
}

LRESULT CElanPropertiesDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                             LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CElanPropertiesDialog::OnHelp(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CElanPropertiesDialog::OnOk(WORD wNotifyCode, WORD wID,
                                    HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szElan[ELAN_NAME_LIMIT + 1];

    // Get the current name from the control and
    // store in the elan info
    ::GetWindowText(m_hElanName, szElan, ELAN_NAME_LIMIT + 1);

    m_pElanInfo->SetElanName(szElan);
    EndDialog(IDOK);

    return 0;
}

LRESULT CElanPropertiesDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\alanepsh.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A L A N E P S H . H
//
//  Contents:   Dialog box handling for ATM LAN Emulation configuration.
//
//  Notes:
//
//  Author:     v-lcleet   08/10/97
//
//----------------------------------------------------------------------------
#pragma once
#include "alaneobj.h"

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs); 

//
// Configuration Dialog
//

class CALanePsh: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CALanePsh)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive);

        COMMAND_ID_HANDLER(IDC_ELAN_ADD,        OnAdd);
        COMMAND_ID_HANDLER(IDC_ELAN_EDIT,       OnEdit);
        COMMAND_ID_HANDLER(IDC_ELAN_REMOVE,     OnRemove);

    END_MSG_MAP()

    CALanePsh(CALaneCfg* palcfg, CALaneCfgAdapterInfo * pAdapter, 
              const DWORD * adwHelpIDs = NULL);
    ~CALanePsh(VOID);

// Message handlers
public:

    LRESULT OnInitDialog (UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:

    void SendAdapterInfo();
    void SendElanInfo();

    CALaneCfgElanInfo *GetSelectedElan();
    void SetButtons();

    int CheckDupElanName();

    BOOL        m_fEditState;
    tstring     m_strAddElan;

private:
    CALaneCfg*                  m_palcfg;
    CALaneCfgAdapterInfo *      m_pAdapterInfo;

    const DWORD * m_adwHelpIDs;

    HWND    m_hElanList;
    HWND    m_hbtnAdd;
    HWND    m_hbtnEdit;
    HWND    m_hbtnRemove;

};

class CElanPropertiesDialog : public CDialogImpl<CElanPropertiesDialog>
{
public:

    enum { IDD = IDD_ELAN_PROPERTIES };

    BEGIN_MSG_MAP(CElanPropertiesDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,            OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,        OnCancel);
    END_MSG_MAP()

public:
    CElanPropertiesDialog(CALanePsh * pCALanePsh, CALaneCfgElanInfo *pElanInfo,
                          const DWORD * adwHelpIDs = NULL);
    ~CElanPropertiesDialog(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    HWND                m_hElanName;
    CALaneCfgElanInfo * m_pElanInfo;

    CALanePsh   * m_pParentDlg;
    const DWORD * m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\alanecfg\resource.h ===
#include <ncres.h>

#define IDS_ALANECFG_UNSPECIFIEDNAME     (IDS_NC_ALANECFG + 1)
#define IDS_MSFT_LANE_TEXT               (IDS_NC_ALANECFG + 2)
#define IDS_DUPLICATE_ELANNAME           (IDS_NC_ALANECFG + 3)

#define IDD_MAIN                        101
#define IDD_ELAN_PROPERTIES             102
#define IDC_ADAPTER_TEXT                1001
#define IDC_ELAN_GROUP                  1003
#define IDC_ELAN_LIST                   1004
#define IDC_ELAN_ADD                    1005
#define IDC_ELAN_EDIT                   1006
#define IDC_ELAN_REMOVE                 1007
#define IDC_ELAN_NAMETEXT               1008
#define IDC_ELAN_NAME                   1009
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atlkcfg\atlkhlp.h ===
// Copyright (c) 1999, Microsoft Corporation, all rights reserved.
//
// AppleTalk.h is used by atlkcfg.rc
// Help IDs file
//
// Created in Dev Studio
// 5-17-99 Carol Troup

#define IDH_CMB_GENERAL_ZONE	18000001 
#define IDH_CHK_GENERAL_DEFAULT	18000000

const DWORD g_aHelpIDs_DLG_ATLK_GENERAL[]=
{
        CHK_GENERAL_DEFAULT,IDH_CHK_GENERAL_DEFAULT,
        CMB_GENERAL_ZONE,IDH_CMB_GENERAL_ZONE,
        IDC_TXT_ZONELIST,IDH_CMB_GENERAL_ZONE,
        0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atlkcfg\atlkdlg.cpp ===
// ATlkDlg.cpp : Implementation of CATLKRoutingDlg and CATLKGeneralDlg

#include "pch.h"
#pragma hdrstop
#include "atlkobj.h"
#include "ncatlui.h"
#include "ncui.h"
#include "atlkhlp.h"

extern const WCHAR c_szDevice[];
extern const WCHAR c_szNetCfgHelpFile[];

const WCHAR c_chAmpersand = L'&';
const WCHAR c_chAsterisk  = L'*';
const WCHAR c_chColon     = L':';
const WCHAR c_chPeriod    = L'.';
const WCHAR c_chQuote     = L'\"';
const WCHAR c_chSpace     = L' ';

//
// Function:    PGetCurrentAdapterInfo
//
// Purpose:     Based on the currently selected item in the adapter combobox.
//              Extract and return the AdapterInfo *
//
// Parameters:  pATLKEnv [IN] - Enviroment block for this property page
//
// Returns:     CAdapterInfo *, Pointer to the adapter info if it exists,
//              NULL otherwise
//
static CAdapterInfo *PGetCurrentAdapterInfo(CATLKEnv * pATLKEnv)
{
    Assert(NULL != pATLKEnv);
    if (pATLKEnv->AdapterInfoList().empty())
    {
        return NULL;
    }
    else
    {
        return pATLKEnv->AdapterInfoList().front();
    }
}

//
// Function:    CATLKGeneralDlg::CATLKGeneralDlg
//
// Purpose:     ctor for the CATLKGeneralDlg class
//
// Parameters:  pmsc     - Ptr to the ATLK notification object
//              pATLKEnv - Ptr to the current ATLK configuration
//
// Returns:     nothing
//
CATLKGeneralDlg::CATLKGeneralDlg(CATlkObj *pmsc, CATLKEnv * pATLKEnv)
{
    m_pmsc              = pmsc;
    m_pATLKEnv          = pATLKEnv;
    Assert(NULL != m_pATLKEnv);
}

//
// Function:    CATLKGeneralDlg::~CATLKGeneralDlg
//
// Purpose:     dtor for the CATLKGeneralDlg class
//
// Parameters:  none
//
// Returns:     nothing
//
CATLKGeneralDlg::~CATLKGeneralDlg()
{
    // Don't free m_pmsc or m_pATLKEnv, they're borrowed only
}

//
// Function:    CATLKGeneralDlg::HandleChkBox
//
// Purpose:     Process the BN_PUSHBUTTON message for ATLK's General page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT CATLKGeneralDlg::HandleChkBox(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& bHandled)
{
    if (BN_CLICKED == wNotifyCode)
    {
        UINT uIsCheckBoxChecked;

        uIsCheckBoxChecked = IsDlgButtonChecked(CHK_GENERAL_DEFAULT);

        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE),
                     uIsCheckBoxChecked);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST),
                     uIsCheckBoxChecked);
    }

    return 0;
}

//
// Function:    CATLKGeneralDlg::OnInitDialog
//
// Purpose:     Process the WM_INITDIALOG message for ATLK's General page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT
CATLKGeneralDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                              LPARAM lParam, BOOL& bHandled)
{
    tstring        strDefPort;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);
    HWND           hwndChk = GetDlgItem(CHK_GENERAL_DEFAULT);
	HCURSOR        WaitCursor;

	WaitCursor = BeginWaitCursor();

    // If no adapters we're successfully added, disable everything
    if (NULL == pAI)
    {
        ::EnableWindow(hwndChk, FALSE);
        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST), FALSE);
        ::EnableWindow(::GetDlgItem(::GetParent(m_hWnd), IDOK), FALSE);
		EndWaitCursor(WaitCursor);	
        return 0L;
    }

    // Retain what we currently consider the "Default" adapter
    strDefPort = c_szDevice;
    strDefPort += pAI->SzBindName();
    if (0 == _wcsicmp(strDefPort.c_str(), m_pATLKEnv->SzDefaultPort()))
    {
        ::CheckDlgButton(m_hWnd, CHK_GENERAL_DEFAULT, 1);
        ::EnableWindow(hwndChk, FALSE);
    }
    else
    {
        // Disable the zone combo if the current adapter is not the
        // default adapter.
        ::EnableWindow(GetDlgItem(CMB_GENERAL_ZONE), FALSE);
        ::EnableWindow(GetDlgItem(IDC_TXT_ZONELIST), FALSE);
    }

    // danielwe: RAID #347398: Hide the checkbox completely if this is a
    // LocalTalk adapter.
    //
    if (pAI->DwMediaType() == MEDIATYPE_LOCALTALK)
    {
        ::ShowWindow(GetDlgItem(CHK_GENERAL_DEFAULT), SW_HIDE);
    }

    // Populate the Zone dialog
    RefreshZoneCombo();

    SetChangedFlag();

	EndWaitCursor(WaitCursor);
    return 1L;
}

//
// Function:    CATLKGeneralDlg::RefreshZoneCombo()
//
// Purpose:     Populate the Zone combo box with the supplied list of zones
//
// Parameters:  pAI - Adapter info
//
// Returns:     none
//
VOID CATLKGeneralDlg::RefreshZoneCombo()
{
    HWND           hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);
    INT            nIdx;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);

    if (NULL == pAI)
        return;         // No adapter selected, available

    ::SendMessage(hwndComboZones, CB_RESETCONTENT, 0, 0L);

    // Populate the Zone dialog
    if (!pAI->FSeedingNetwork() || !m_pATLKEnv->FRoutingEnabled())
    {
        // this port is not seeding the network
        // if we found a router on this port then add the found zone
        // list to the desired zone box. Else do nothing.
        if(pAI->FRouterOnNetwork())
        {
            if (pAI->LstpstrDesiredZoneList().empty())
                return;

            if (FALSE == FAddZoneListToControl(&pAI->LstpstrDesiredZoneList()))
                return;

            nIdx = (INT) ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT, -1,
                                 (LPARAM)m_pATLKEnv->SzDesiredZone());
            ::SendMessage(hwndComboZones, CB_SETCURSEL,
                          ((CB_ERR == nIdx) ? 0 : nIdx), 0L);
        }
    }
    else
    {
        // This port is seeding the network, populate the zone list with the
        // zones managed by this port.
        if (pAI->LstpstrZoneList().empty())
            return;

        if (FALSE == FAddZoneListToControl(&pAI->LstpstrZoneList()))
            return;

        nIdx = (INT) ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT,
                             -1, (LPARAM)m_pATLKEnv->SzDesiredZone());
        if (CB_ERR == nIdx)
            nIdx = (INT) ::SendMessage(hwndComboZones, CB_FINDSTRINGEXACT,
                                 -1, (LPARAM)pAI->SzDefaultZone());

        ::SendMessage(hwndComboZones, CB_SETCURSEL,
                      ((CB_ERR == nIdx) ? 0 : nIdx), 0L);
    }
}

//
// Function:    CATLKGeneralDlg::FAddZoneListToControl
//
// Purpose:     Populate the Zone combo box with the supplied list of zones
//
// Parameters:  plstpstr - Pointer to a list of pointers to tstrings
//
// Returns:     BOOL, TRUE if at least one zone was added to the combo box
//
BOOL CATLKGeneralDlg::FAddZoneListToControl(list<tstring*> * plstpstr)
{
    HWND hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);
    list<tstring*>::iterator iter;
    tstring * pstr;

    Assert(NULL != plstpstr);
    for (iter = plstpstr->begin();
         iter != plstpstr->end();
         iter++)
    {
        pstr = *iter;
        ::SendMessage(hwndComboZones, CB_ADDSTRING, 0, (LPARAM)pstr->c_str());
    }

    return (0 != ::SendMessage(hwndComboZones, CB_GETCOUNT, 0, 0L));
}

//
// Function:    CATLKGeneralDlg::OnOk
//
// Purpose:     Process the PSN_APPLY notification for the property page
//
// Parameters:  Standard ATL params
//
// Returns:     LRESULT, 0L
//
LRESULT
CATLKGeneralDlg::OnOk(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    INT            nIdx;
    CAdapterInfo * pAI = PGetCurrentAdapterInfo(m_pATLKEnv);
    HWND           hwndComboZones = GetDlgItem(CMB_GENERAL_ZONE);

    if (NULL == pAI)
    {
        return 0;
    }

    if (IsDlgButtonChecked(CHK_GENERAL_DEFAULT))
    {
        tstring        strPortName;

        // Retain adapter selection as the default port
        //
        strPortName = c_szDevice;
        strPortName += pAI->SzBindName();
        if (wcscmp(strPortName.c_str(), m_pATLKEnv->SzDefaultPort()))
        {
            m_pATLKEnv->SetDefaultPort(strPortName.c_str());
            m_pATLKEnv->SetDefAdapterChanged(TRUE);

            // Tell the user what checking the box means...
            //
            tstring str;
            str = SzLoadIds(IDS_ATLK_INBOUND_MSG1);
            str += SzLoadIds(IDS_ATLK_INBOUND_MSG2);
            ::MessageBox(m_hWnd, str.c_str(),
                         SzLoadIds(IDS_CAPTION_NETCFG), MB_OK);
        }
    }
    else
    {
        // If the check box is not checked then the zone combo is
        // disabled and its contents don't need to be retained.
        return 0;
    }

    // Retain the zone selection as the default zone
    nIdx = (INT) ::SendMessage(hwndComboZones, CB_GETCURSEL, 0, 0L);
    if (CB_ERR != nIdx)
    {
        WCHAR szBuf[MAX_ZONE_NAME_LEN + 1];
        if (CB_ERR != ::SendMessage(hwndComboZones, CB_GETLBTEXT, nIdx,
                                    (LPARAM)(PCWSTR)szBuf))
        {
            // If the new zone is different then the original, then
            // mark the adapter as dirty
            
            if (0 != _wcsicmp(szBuf, m_pATLKEnv->SzDesiredZone()))
            {
                // If the earlier desired zone was NOT NULL, only then
                // mark adapter dirty to request a PnP to the stack
                if (0 != _wcsicmp(c_szEmpty, m_pATLKEnv->SzDesiredZone()))
                {
                    pAI->SetDirty(TRUE);
                }
            }
            m_pATLKEnv->SetDesiredZone(szBuf);
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method: CATLKGeneralDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CATLKGeneralDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_ATLK_GENERAL != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_ATLK_GENERAL);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Method: CATLKGeneralDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CATLKGeneralDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_ATLK_GENERAL != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_ATLK_GENERAL);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atlkcfg\resource.h ===
#include <ncres.h>

// Dialog IDs
#define DLG_ATLK_GENERAL            2500   // == IDS_NS_ATLKCFG
#define DLG_ATLK_ROUTING            2501
#define DLG_ATLK_ADD_ZONE           2502

// String IDs
#define IDS_ATLK_CAPTION                (IDS_NC_ATLKCFG + 1)
#define IDS_ATLK_INSTALL_PENDING        (IDS_NC_ATLKCFG + 2)
#define IDS_ATLK_INBOUND_MSG1           (IDS_NC_ATLKCFG + 3)
#define IDS_ATLK_INBOUND_MSG2           (IDS_NC_ATLKCFG + 4)

// Control IDs
#define CMB_GENERAL_ZONE            100
#define CHK_GENERAL_DEFAULT         101
#define IDC_TXT_ZONELIST            102
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atlkcfg\atlkobj.cpp ===
// ATlkObj.cpp : Implementation of CATlkObj

#include "pch.h"
#pragma hdrstop
#include <atalkwsh.h>
#include "atlkobj.h"
#include "ncatlui.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncpnp.h"
#include "ncsvc.h"
#include <netconp.h>

extern const WCHAR c_szAdapterSections[];
//extern const WCHAR c_szAdapters[];
extern const WCHAR c_szBackslash[];
extern const WCHAR c_szDevice[];
extern const WCHAR c_szSpecificTo[];
extern const WCHAR c_szInfId_MS_NdisWanAtalk[];
extern const WCHAR c_szEmpty[];

// Registry Paths
static const WCHAR c_szAtlk[]                 = L"AppleTalk";
static const WCHAR c_szATLKParameters[]       = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters";
static const WCHAR c_szATLKAdapters[]         = L"System\\CurrentControlSet\\Services\\AppleTalk\\Parameters\\Adapters";

// Values under the Adapter component's "Parameters" key
static const WCHAR c_szMediaType[]            = L"MediaType";  //$ REVIEW duplicate string

// Values under AppleTalk\Parameters
static const WCHAR c_szDefaultPort[]          = L"DefaultPort";  // REG_SZ
static const WCHAR c_szDesiredZone[]          = L"DesiredZone";  // REG_SZ
static const WCHAR c_szEnableRouter[]         = L"EnableRouter"; // REG_DWORD

// Values under AppleTalk\Parameters\Adapters\<AdapterId>
static const WCHAR c_szAarpRetries[]          = L"AarpRetries";         // REG_DWORD
static const WCHAR c_szDdpCheckSums[]         = L"DdpCheckSums";        // REG_DWORD
static const WCHAR c_szDefaultZone[]          = L"DefaultZone";         // REG_SZ
static const WCHAR c_szNetworkRangeLowerEnd[] = L"NetworkRangeLowerEnd";// REG_DWORD
static const WCHAR c_szNetworkRangeUpperEnd[] = L"NetworkRangeUpperEnd";// REG_DWORD
static const WCHAR c_szPortName[]             = L"PortName";            // REG_SZ
static const WCHAR c_szRouterPramNode[]       = L"RouterPramNode";      // REG_DWORD
static const WCHAR c_szSeedingNetwork[]       = L"SeedingNetwork";      // REG_DWORD
static const WCHAR c_szUserPramNode1[]        = L"UserPramNode1";       // REG_DWORD
static const WCHAR c_szUserPramNode2[]        = L"UserPramNode2";       // REG_DWORD
static const WCHAR c_szZoneList[]             = L"ZoneList";            // REG_MULTI_SZ

// Useful default constant
const WCHAR c_chAt                            = L'@';
static const WCHAR c_dwZero                   = 0L;
static const WCHAR c_dwTen                    = 10L;
//static const WCHAR c_szMacPrint[]             = L"MacPrint";


// Declare structure for reading/writing AppleTalk\Parameters values
static const REGBATCH regbatchATLKParams[]    = {
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szDefaultPort, REG_SZ,
             offsetof(ATLK_PARAMS,szDefaultPort), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szDesiredZone, REG_SZ,
             offsetof(ATLK_PARAMS,szDesiredZone), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szATLKParameters, c_szEnableRouter, REG_DWORD,
             offsetof(ATLK_PARAMS,dwEnableRouter), (BYTE *)&c_szEmpty}};

static const REGBATCH regbatchATLKAdapters[]  = {
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szAarpRetries, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwAarpRetries), (BYTE *)&c_dwTen},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szDdpCheckSums, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwDdpCheckSums), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szNetworkRangeLowerEnd, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwNetworkRangeLowerEnd), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szNetworkRangeUpperEnd, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwNetworkRangeUpperEnd), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szRouterPramNode, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwRouterPramNode), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szSeedingNetwork, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwSeedingNetwork), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szUserPramNode1, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwUserPramNode1), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szUserPramNode2, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwUserPramNode2), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szMediaType, REG_DWORD,
             offsetof(ATLK_ADAPTER,m_dwMediaType), (BYTE *)&c_dwZero},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szDefaultZone, REG_SZ,
             offsetof(ATLK_ADAPTER,m_szDefaultZone), (BYTE *)&c_szEmpty},
            {HKEY_LOCAL_MACHINE, c_szEmpty, c_szPortName, REG_SZ,
             offsetof(ATLK_ADAPTER,m_szPortName), (BYTE *)&c_szEmpty}};

// Local utility functions
HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CAdapterInfo * pAI);

HRESULT HrPortNameFromAdapter(INetCfgComponent *pncc, tstring * pstr);

// Prototype from nwlnkcfg\nwlnkutl.h
HRESULT HrAnswerFileAdapterToPNCC(INetCfg *pnc, PCWSTR pszAdapterId,
                                  INetCfgComponent** ppncc);

//
// Function:    CATlkObj::CATlkObj
//
// Purpose:     ctor for the CATlkObj class
//
// Parameters:  none
//
// Returns:     none
//
CATlkObj::CATlkObj() : m_pNetCfg(NULL),
             m_pNCC(NULL),
             m_eInstallAction(eActUnknown),
             m_pspObj(NULL),
             m_pATLKEnv(NULL),
             m_pATLKEnv_PP(NULL),
             m_pUnkPropContext(NULL),
             m_nIdxAdapterSelected(CB_ERR),
             m_fAdapterListChanged(FALSE),
             m_fPropertyChange(FALSE),
             m_fFirstTimeInstall(FALSE)
{
}

//
// Function:    CATlkObj::CATlkObj
//
// Purpose:     dtor for the CATlkObj class
//
// Parameters:  none
//
// Returns:     none
//
CATlkObj::~CATlkObj()
{
    // Should always be cleaned up in advance of reach this dtor
    Assert(NULL == m_pATLKEnv_PP);

    ReleaseObj(m_pUnkPropContext);
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pNCC);
    CleanupPropPages();
    delete m_pATLKEnv;
}


// INetCfgNotify
STDMETHODIMP CATlkObj::Initialize ( INetCfgComponent* pnccItem,
                                    INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    ReleaseObj(m_pNCC);
    m_pNCC    = pnccItem;
    AddRefObj(m_pNCC);
    ReleaseObj(m_pNetCfg);
    m_pNetCfg = pNetCfg;
    AddRefObj(m_pNetCfg);
    m_fFirstTimeInstall = fInstalling;

    // Read the current configuration
    HRESULT hr = CATLKEnv::HrCreate(&m_pATLKEnv, this);

    TraceError("CATlkObj::Initialize",hr);
    return hr;
}

STDMETHODIMP CATlkObj::ReadAnswerFile(PCWSTR pszAnswerFile,
                    PCWSTR pszAnswerSection )
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );

    HRESULT hr = S_OK;

    m_eInstallAction = eActInstall;

    // Only process answer file and install sub-components if the answer file
    // is present.  If the answer file is not present we should already be installed.
    if (NULL != pszAnswerFile)
    {
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
    }

    TraceError("CATlkObj::ReadAnswerFile",hr);
    return hr;
}

//
// Function:    CATlkObj::HrProcessAnswerFile
//
// Purpose:     Process the answer file information, merging
//              its contents into the internal information
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATlkObj::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    TraceFileFunc(ttidDefault);

    CSetupInfFile   csif;
    BOOL            fValue;
    HRESULT         hr = S_OK;
    INFCONTEXT      infctx;
    tstring         str;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Read the property containing the list of adapter sections
    hr = ::HrSetupFindFirstLine(csif.Hinf(), pszAnswerSection,
                                c_szAdapterSections, &infctx);
    if (S_OK == hr)
    {
        DWORD dwIdx;
        DWORD dwCnt = SetupGetFieldCount(&infctx);

        // For each adapter in the list read the adapter information
        for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
        {
            hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
            if (FAILED(hr))
            {
                TraceError("CATlkObj::HrProcessAnswerFile - Failed to read adapter section name",hr);
                break;
            }

            hr = HrReadAdapterAnswerFileSection(&csif, str.c_str());
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    TraceTag(ttidDefault, "***Appletalk processing default port***");

    // Read the default port property (REG_SZ)
    hr = csif.HrGetString(pszAnswerSection, c_szDefaultPort, &str);
    if (SUCCEEDED(hr))
    {
        tstring strNew = str;

        // If the \device\ prefix is present, strip it off
        //
        if (0 == _wcsnicmp(str.c_str(), c_szDevice, wcslen(c_szDevice)))
        {
            strNew = ((PWSTR)str.c_str()) + wcslen(c_szDevice);
            TraceTag(ttidDefault, "Removing the device prefix. Device=%S",strNew.c_str());
        }

        // Convert the Adapter0x to \Device\{bind-name}
        INetCfgComponent* pncc = NULL;
        hr = ::HrAnswerFileAdapterToPNCC(PNetCfg(), strNew.c_str(), &pncc);
        if (S_OK == hr)
        {
            PWSTR pszBindName;
            hr = pncc->GetBindName(&pszBindName);
            ReleaseObj(pncc);
            if (FAILED(hr))
            {
                goto Error;
            }

            str = c_szDevice;
            str += pszBindName;

            CoTaskMemFree(pszBindName);

            TraceTag(ttidDefault, "Port located and configured");
            m_pATLKEnv->SetDefaultPort(str.c_str());
        }
    }

    TraceTag(ttidDefault, "***Appletalk finished processing default port***");

    // Read the default zone property (REG_SZ)
    hr = csif.HrGetString(pszAnswerSection, c_szDesiredZone, &str);
    if (SUCCEEDED(hr))
    {
        m_pATLKEnv->SetDesiredZone(str.c_str());
    }

    // Read the EnableRouter property (DWORD used as a boolean)
    hr = csif.HrGetStringAsBool(pszAnswerSection, c_szEnableRouter, &fValue);
    if (SUCCEEDED(hr))
    {
        m_pATLKEnv->EnableRouting(fValue);
    }

    // Determine the best default port overriding the recorded default only
    // if the default port cannot be found
    m_pATLKEnv->InitDefaultPort();

    hr = S_OK;
    m_fPropertyChange = TRUE;

Error:
    TraceError("CATlkObj::HrProcessAnswerFile", hr);
    return hr;
}

//
// Function:    CATlkObj::HrReadAdapterAnswerFileSection
//
// Purpose:     Read the adapter answer file section and create
//              the adapter info section if successful
//
// Parameters:
//
// Returns:
//
HRESULT
CATlkObj::HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                         PCWSTR pszSection)
{
    HRESULT           hr = S_OK;
    CAdapterInfo *    pAI = NULL;
    tstring           str;

    INetCfgComponent* pncc = NULL;

    // Read the SpecificTo adapter name
    hr = pcsif->HrGetString(pszSection, c_szSpecificTo, &str);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Search for the specified adapter in the set of existing adapters
    hr = ::HrAnswerFileAdapterToPNCC(PNetCfg(), str.c_str(), &pncc);
    if (FAILED(hr))
    {
        goto Error;
    }

    // if we found the adapter component object (pncc != NULL) process
    // the adapter section
    if (pncc)
    {
        DWORD       dwData;
        DWORD       dwDataUpper;
        INFCONTEXT  infctx;

        pAI = new CAdapterInfo();
        Assert(NULL != pAI);

        pAI->SetDirty(TRUE);

        // Get the adapter component info (media type, description, ...)
        hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Read the NetworkRangeUpperEnd
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeUpperEnd, &dwDataUpper);
        if (FAILED(hr))
        {
            dwDataUpper = pAI->DwQueryNetRangeUpper();
            TraceTag(ttidDefault, "CATlkObj::HrReadAdapterAnswerFileSection - Defaulting property %S",c_szNetworkRangeUpperEnd);
        }

        // Read the NetworkRangeLowerEnd
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeLowerEnd, &dwData);
        if (FAILED(hr))
        {
            dwData = pAI->DwQueryNetRangeLower();
            TraceTag(ttidDefault, "CATlkObj::HrReadAdapterAnswerFileSection - Defaulting property %S",c_szNetworkRangeLowerEnd);
        }

        pAI->SetAdapterNetRange(dwData, dwDataUpper);

        // Read the DefaultZone
        hr = pcsif->HrGetString(pszSection, c_szDefaultZone, &str);
        if (SUCCEEDED(hr))
        {
            pAI->SetDefaultZone(str.c_str());
        }

        // Read the SeedingNetwork
        hr = pcsif->HrGetDword(pszSection, c_szNetworkRangeLowerEnd, &dwData);
        if (SUCCEEDED(hr))
        {
            pAI->SetSeedingNetwork(!!dwData);
        }

        // Generate the PortName
        hr = ::HrPortNameFromAdapter(pncc, &str);
        if (FAILED(hr))
        {
            goto Error;
        }

        pAI->SetPortName(str.c_str());

        // Read the ZoneList
        hr = HrSetupFindFirstLine(pcsif->Hinf(), pszSection, c_szZoneList,
                                    &infctx);
        if (S_OK == hr)
        {
            DWORD dwIdx;
            DWORD dwCnt = SetupGetFieldCount(&infctx);

            // For each adapter in the list read the adapter information
            for (dwIdx=1; dwIdx <= dwCnt; dwIdx++)
            {
                hr = ::HrSetupGetStringField(infctx, dwIdx, &str);
                if (FAILED(hr))
                {
                    TraceError("CATlkObj::HrProcessAnswerFile - Failed to read adapter section name",hr);
                    goto Error;
                }

                if (!str.empty())
                {
                    pAI->LstpstrZoneList().push_back(new tstring(str));
                }
            }
        }

        pAI->SetDirty(TRUE);
        m_pATLKEnv->AdapterInfoList().push_back(pAI);
        MarkAdapterListChanged();
    }

    // Normalize any errors
    hr = S_OK;

Done:
    ReleaseObj(pncc);
    return hr;

Error:
    delete pAI;
    TraceError("CATlkObj::HrReadAdapterAnswerFileSection",hr);
    goto Done;
}

STDMETHODIMP CATlkObj::Install (DWORD)
{
    CAdapterInfo *  pAI;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    m_eInstallAction = eActInstall;

    // Mark all the initially detected adapters as dirty
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        pAI->SetDirty(TRUE);
    }
    return S_OK;
}

STDMETHODIMP CATlkObj::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CATlkObj::Validate ()
{
    return S_OK;
}

STDMETHODIMP CATlkObj::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CATlkObj::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    // Have any changes been validated?
    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrCommitInstall();
        if (SUCCEEDED(hr))
        {
            m_fFirstTimeInstall = FALSE;
            hr = HrAtlkReconfig();
        }
        break;
    case eActRemove:
        hr = HrCommitRemove();
        break;
    default:    // eActUnknown
        if (m_fAdapterListChanged || m_fPropertyChange)
        {
            // Update the registry if the adapter list changed
            Assert(NULL != m_pATLKEnv);
            hr = m_pATLKEnv->HrUpdateRegistry();
            if (SUCCEEDED(hr))
            {
                hr = HrAtlkReconfig();
            }
        }
        break;
    }

    TraceError("CATlkObj::ApplyRegistryChanges",hr);
    return hr;
}

// INetCfgProperties

STDMETHODIMP CATlkObj::SetContext(IUnknown * pUnk)
{
    ReleaseObj(m_pUnkPropContext);
    m_pUnkPropContext = pUnk;
    if (m_pUnkPropContext)
    {
        AddRefObj(m_pUnkPropContext);
    }

    return S_OK;
}

STDMETHODIMP CATlkObj::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;
    CAdapterInfo *  pAI = NULL;

    Assert(pahpspPrivate);
    Assert(NULL == *pahpspPrivate);    // Out param init done via Validate above
    *pcPages = 0;
    Assert(NULL != m_pATLKEnv);

    if (NULL != m_pATLKEnv_PP)
    {
        TraceError("CATlkObj::MergePropPages - multiple property page instances requested.", hr);
        return E_UNEXPECTED;
    }

    // AppleTalk requires "complete" installation before property changes are
    // allowed.  If we've just installed but Apply has not yet been pressed,
    // disallow property page display
    if (m_fFirstTimeInstall)
    {
        NcMsgBox(::GetFocus(), IDS_ATLK_CAPTION, IDS_ATLK_INSTALL_PENDING,
                 MB_OK | MB_ICONEXCLAMATION);
        return S_FALSE;
    }

    // Start with new property pages each time.
    CleanupPropPages();

    // Locate the adapter referenced in the connection we stashed away
    if (NULL != m_pUnkPropContext)
    {
        INetLanConnectionUiInfo * pLanConn = NULL;
        ATLK_ADAPTER_INFO_LIST::iterator iter;

        hr = m_pUnkPropContext->QueryInterface(IID_INetLanConnectionUiInfo,
                                               reinterpret_cast<LPVOID *>(&pLanConn));
        if (S_OK == hr)
        {
            GUID guid;
            hr = pLanConn->GetDeviceGuid(&guid);
            ReleaseObj(pLanConn);
            if (SUCCEEDED(hr))
            {
                // Find the adapter in our adapter list
                for (iter = m_pATLKEnv->AdapterInfoList().begin();
                     iter != m_pATLKEnv->AdapterInfoList().end();
                     iter++)
                {
                    CAdapterInfo * pAITmp = *iter;

                    if (guid == *pAITmp->PInstanceGuid())
                    {
                        // Copy the adapter data
                        hr = pAITmp->HrCopy(&pAI);
                        break;
                    }
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            // If no adapter in this connection or it's
            // disabled/hidden/deleted we show no pages
            if ((NULL == pAI) || pAI->FDeletePending() ||
                pAI->FDisabled() || pAI->FHidden())
            {
                Assert(0 == *pcPages);
                hr = S_FALSE;
                goto cleanup;
            }
        }
    }
    else
    {
        // m_pUnkPropContext should have been set first
        hr = E_UNEXPECTED;
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // Create a copy of the enviroment for property page usage
    hr = m_pATLKEnv->HrCopy(&m_pATLKEnv_PP);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(NULL != m_pATLKEnv_PP);
    Assert(NULL != pAI);

    // Query the zonelist every time, only for non-Seeding adapters.
    if (!pAI->FSeedingNetwork() || !m_pATLKEnv_PP->FRoutingEnabled())
    {
        (void) m_pATLKEnv->HrGetAppleTalkInfoFromNetwork(pAI);
    }

    // Add the adapter to the property sheet's list
    m_pATLKEnv_PP->AdapterInfoList().push_back(pAI);

    // Allocate the CPropSheetPage object for the "General" page
    m_pspObj = new CATLKGeneralDlg(this, m_pATLKEnv_PP);

    // Allocate a buffer large enough to hold the handle to the Appletalk config.
    // property page.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE));
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto cleanup;       // Alloc failed to no need to free ahpsp
    }

    // Create the actual PROPSHEETPAGE for each object.
    ahpsp[0] = m_pspObj->CreatePage(DLG_ATLK_GENERAL, 0);

    // Validate what we've created
    if (NULL == ahpsp[0])
    {
        hr = E_OUTOFMEMORY;
        goto Error;
    }
    else
    {
        *pahpspPrivate = (LPBYTE)ahpsp;
        *pcPages = 1;
    }

cleanup:
    TraceError("CATlkObj::MergePropPages", hr);
    return hr;

Error:
    CoTaskMemFree(ahpsp);
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;
    goto cleanup;
}

//
// Function:    CATlkObj::CleanupPropPages
//
// Purpose:
//
// Parameters:
//
// Returns:     nothing
//
VOID CATlkObj::CleanupPropPages()
{
    delete m_pspObj;
    m_pspObj = NULL;
}

//
// Function:    CATlkObj::ValidateProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::ValidateProperties (HWND)
{
    return S_OK;
}

//
// Function:    CATlkObj::CancelProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::CancelProperties ()
{
    // Discard any changes made via the property pages
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;
    return S_OK;
}

//
// Function:    CATlkObj::ApplyProperties
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
STDMETHODIMP CATlkObj::ApplyProperties ()
{
    // Extract the adapter info from the property sheet's
    // enviroment block
    Assert(!m_pATLKEnv_PP->AdapterInfoList().empty());
    CAdapterInfo * pAICurrent = m_pATLKEnv_PP->AdapterInfoList().front();
    m_pATLKEnv_PP->AdapterInfoList().pop_front();
    Assert(NULL != pAICurrent);

    // Remove the current adapter from the original enviroment
    CAdapterInfo * pAI;
    ATLK_ADAPTER_INFO_LIST::iterator iter;
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;
        if (0 == _wcsicmp(pAI->SzBindName(), pAICurrent->SzBindName()))
        {
            m_pATLKEnv->AdapterInfoList().erase(iter, iter);
            break;
        }
    }

    // Add pAICurrent to the base enviroment block
    m_pATLKEnv->AdapterInfoList().push_back(pAICurrent);

    // Update the base enviroment from the property sheet's enviroment
    m_pATLKEnv->SetDefaultMediaType(m_pATLKEnv_PP->DwDefaultAdaptersMediaType());
    m_pATLKEnv->EnableRouting(m_pATLKEnv_PP->FRoutingEnabled());
    m_pATLKEnv->SetDefaultPort(m_pATLKEnv_PP->SzDefaultPort());
    m_pATLKEnv->SetDesiredZone(m_pATLKEnv_PP->SzDesiredZone());
    m_pATLKEnv->SetRouterChanged(m_pATLKEnv_PP->FRouterChanged());
    m_pATLKEnv->SetDefAdapterChanged(m_pATLKEnv_PP->FDefAdapterChanged());

    // Delete the property pages enviroment block
    delete m_pATLKEnv_PP;
    m_pATLKEnv_PP = NULL;

    // Properties changed
    m_fPropertyChange = TRUE;
    return S_OK;
}


// INetCfgBindNotify

STDMETHODIMP
CATlkObj::QueryBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgBindNotify_QueryBindingPath( dwChangeFlag, pncbpItem );
    return S_OK;
}

STDMETHODIMP
CATlkObj::NotifyBindingPath (
    DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    HRESULT hr = S_OK;
    INetCfgComponent *pnccFound = NULL;

    Validate_INetCfgBindNotify_NotifyBindingPath( dwChangeFlag, pncbpItem );

    Assert(NULL != m_pATLKEnv);

    // Only Interested in lower binding Add's and Remove's
    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE | NCN_ENABLE | NCN_DISABLE))
    {
        CIterNetCfgBindingInterface ncbiIter(pncbpItem);
        INetCfgBindingInterface *pncbi;

        // Enumerate the binding interfaces looking for the last Adapter
        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            INetCfgComponent *pncc;

            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (GUID_DEVCLASS_NET == guidClass))
                {
                    ULONG ulStatus = 0;
                    hr = pncc->GetDeviceStatus(&ulStatus);

                    if(S_OK == hr)
                    {
                        ReleaseObj(pnccFound);
                        pnccFound = pncc;   // Transfer Ownership
                        pncc = NULL;
                    }
                    else
                    {
                        ReleaseObj(pncc);
                    }
                }
                else
                {
                    ReleaseObj(pncc);
                }
            }

            ReleaseObj(pncbi);
        }

        if (FAILED(hr))
        {
            goto Error;
        }

        // Did we find the Adapter?
        if (pnccFound)
        {
            BOOL                             fFound = FALSE;
            PWSTR                           pszBindName = NULL;
            CAdapterInfo *                   pAI;
            ATLK_ADAPTER_INFO_LIST::iterator iterAdapterInfo;

            Assert(NULL != m_pATLKEnv);
            ATLK_ADAPTER_INFO_LIST pAI_List = m_pATLKEnv->AdapterInfoList();

            hr = pnccFound->GetBindName(&pszBindName);
            if (S_OK != hr)
            {
                goto Error;
            }

            // Search the adapter list
            for (iterAdapterInfo = pAI_List.begin();
                 iterAdapterInfo != pAI_List.end();
                 iterAdapterInfo++)
            {
                pAI = *iterAdapterInfo;
                if (0 == lstrcmpiW(pszBindName, pAI->SzBindName()))
                {
                    fFound = TRUE;
                    break;
                }
            }

            Assert(NULL != pszBindName);
            CoTaskMemFree(pszBindName);

            // Apply the appropriate delta to the adapter list
            if (fFound && (dwChangeFlag & NCN_REMOVE))
            {
                // Delete the adapter from the list
                pAI->SetDeletePending(TRUE);
                m_fAdapterListChanged = TRUE;
            }
            else if (!fFound && (dwChangeFlag & NCN_ADD))
            {
                // Add the adapter to the list
                hr = m_pATLKEnv->HrAddAdapter(pnccFound);
                m_fAdapterListChanged = TRUE;
            }
            else if (fFound && (dwChangeFlag & NCN_ADD))
            {
                // Re-enable the adapters existance
                pAI->SetDeletePending(FALSE);
            }

            if (fFound)
            {
                if (dwChangeFlag & NCN_ENABLE)
                {
                    pAI->SetDisabled(FALSE);
                    m_fAdapterListChanged = TRUE;
                }
                else if (dwChangeFlag & NCN_DISABLE)
                {
                    pAI->SetDisabled(TRUE);
                    m_fAdapterListChanged = TRUE;
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = S_OK;      // Normalize return value
        }
    }

Error:
    ::ReleaseObj(pnccFound);
    TraceError("CATlkObj::NotifyBindingPath",hr);
    return hr;
}

//
// Function:    CATlkObj::HrCommitInstall
//
// Purpose:     Commit Installation registry changes to the registry
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
HRESULT CATlkObj::HrCommitInstall()
{
    HRESULT hr;

    Assert(NULL != m_pATLKEnv);
    hr = m_pATLKEnv->HrUpdateRegistry();

    TraceError("CATlkObj::HrCommitInstall",hr);
    return hr;
}

//
// Function:    CATlkObj::HrCommitRemove
//
// Purpose:     Remove from the registry settings which were created by this
//              component's installation.
//
// Parameters:  None
//
// Returns:     HRESULT, S_OK on success
//
//
HRESULT CATlkObj::HrCommitRemove()
{
    // Everything is removed via the inf file presently
    return S_OK;
}

//
// Function:    CATLKEnv::HrCreate
//
// Purpose:     Construct the AppleTalk Enviroment tracking object
//
// Paramaters:  ppATLKEnv [out] - AppleTalk Enviroment Object created
//              pmsc       [in] - AppleTalk notification object
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrCreate(CATLKEnv **ppATLKEnv, CATlkObj *pmsc)
{
    HRESULT hr = S_OK;
    CATLKEnv *pATLKEnv = NULL;

    *ppATLKEnv = NULL;

    // Construct the new enviroment object
    pATLKEnv = new CATLKEnv(pmsc);

	if (pATLKEnv == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Read AppleTalk Info
    hr = pATLKEnv->HrReadAppleTalkInfo();
    if (FAILED(hr))
    {
        goto Error;
    }

    *ppATLKEnv = pATLKEnv;

Done:
    return hr;

Error:
    TraceError("CATLKEnv::HrCreate",hr);
    delete pATLKEnv;
    goto Done;
}

//
// Function:    CATLKEnv::CATLKEnv
//
// Purpose:     ctor for the CATLKEnv class
//
// Parameters:  none
//
// Returns:     none
//
CATLKEnv::CATLKEnv(CATlkObj *pmsc) :
            m_pmsc(pmsc),
            m_fATrunning(FALSE),
            m_dwDefaultAdaptersMediaType(MEDIATYPE_ETHERNET),
            m_fRouterChanged(FALSE),
            m_fDefAdapterChanged(FALSE)
{
    ZeroMemory(&m_Params, sizeof(m_Params));
}

//
// Function:    CATLKEnv::~CATLKEnv
//
// Purpose:     dtor for the CATLKEnv class
//
// Parameters:  none
//
// Returns:     none
//
CATLKEnv::~CATLKEnv()
{
    // Cleanup the AppleTalk\Parameters internal data structure
    delete [] m_Params.szDefaultPort;
    delete [] m_Params.szDesiredZone;

    // Cleanup the contents of the Adapter Info List
    while (!m_lstpAdapters.empty())
    {
        delete m_lstpAdapters.front();
        m_lstpAdapters.pop_front();
    }
}

//
// Function:    CATLKEnv::HrCopy
//
// Purpose:     Creates a copy of the current Enviroment
//
// Parameters:  ppEnv [out] - If the function succeeds, ppEnv will contain a
//                            copy of the enviroment.
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrCopy(CATLKEnv **ppEnv)
{
    HRESULT hr = S_OK;
    CATLKEnv * pEnv;

    // Allocate a new enviroment object
    *ppEnv = NULL;
    pEnv = new CATLKEnv(m_pmsc);
    if (NULL != pEnv)
    {
        // Copy the members
        pEnv->m_fATrunning = m_fATrunning;
        pEnv->SetDefaultMediaType(DwDefaultAdaptersMediaType());
        pEnv->EnableRouting(FRoutingEnabled());
        pEnv->SetDefaultPort(SzDefaultPort());
        pEnv->SetDesiredZone(SzDesiredZone());
        pEnv->SetRouterChanged(FRouterChanged());
        pEnv->SetDefAdapterChanged(FDefAdapterChanged());

        *ppEnv = pEnv;
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    TraceError("CATLKEnv::HrCopy",hr);
    return S_OK;
}

//
// Function:    CATLKEnv::HrReadAppleTalkInfo
//
// Purpose:     Retrieve the AppleTalk registry Settings
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrReadAppleTalkInfo()
{
    HRESULT hr;

    // Read the AppleTalk\Parameters values
    RegReadValues(celems(regbatchATLKParams), regbatchATLKParams,
                  (BYTE *)&m_Params, KEY_READ);

    // Read info for each adapter listed under AppleTalk\Parameters\Adapters
    hr = HrGetAdapterInfo();

    TraceError("CATLKEnv::HrReadAppleTalkInfo",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrGetOneAdaptersInfo
//
// Purpose:     Retrieve the AppleTalk Adapter information for one adapter
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetOneAdaptersInfo(INetCfgComponent* pncc,
                                       CAdapterInfo **ppAI)
{
    HKEY            hkeyAdapterRoot = NULL;
    HKEY            hkeyAdapter = NULL;
    HRESULT         hr;
    INT             idx;
    CAdapterInfo *  pAI = NULL;
    REGBATCH        regbatch;
    tstring         strKey;
    tstring         strKeyPath = c_szATLKAdapters;

    *ppAI = NULL;

    // Construct the adapter info object
    pAI = new CAdapterInfo;

	if (pAI == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Get the adapter component info (media type, description, ...)
    hr = ::HrQueryAdapterComponentInfo(pncc, pAI);
    if (FAILED(hr))
    {
        goto Error;
    }

    hr = ::HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, strKeyPath.c_str(),
                          KEY_READ, &hkeyAdapterRoot);
    if (S_OK == hr)
    {
        strKey = pAI->SzBindName();

        // Try to open the key for this specific adapter
        hr = ::HrRegOpenKeyEx(hkeyAdapterRoot, pAI->SzBindName(),
                              KEY_READ, &hkeyAdapter);
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // We weren't able to find this in the registry, write it out
            // when we can (self repair)
            pAI->SetDirty(TRUE);
        }

        strKeyPath += c_szBackslash;
        strKeyPath += strKey.c_str();

        // If we located the key query the data
        if (S_OK == hr)
        {
            hr = HrRegQueryColString(hkeyAdapter, c_szZoneList,
                    &pAI->LstpstrZoneList());

            // Since CAdapterInfo defaults allocations, need to free
            // them before RegReadValues writes over them and causes a leak.
            //
            delete [] pAI->m_AdapterInfo.m_szDefaultZone;
            delete [] pAI->m_AdapterInfo.m_szPortName;
            pAI->m_AdapterInfo.m_szDefaultZone = NULL;
            pAI->m_AdapterInfo.m_szPortName = NULL;

            // Read the adapter information
            for (idx=0; idx<celems(regbatchATLKAdapters); idx++)
            {
                regbatch = regbatchATLKAdapters[idx];
                regbatch.pszSubkey = strKeyPath.c_str();

                RegReadValues(1, &regbatch, (BYTE *)pAI->PAdapterInfo(), KEY_READ);
            }
        }
    }

    if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr))
    {
        // Something other than a "not found" error
        goto Error;
    }

    // Normalize return value
    hr = S_OK;

    // If the port name was not found then generate one
    if (0 == wcslen(pAI->SzPortName()))
    {
        tstring str;
        hr = ::HrPortNameFromAdapter(pncc, &str);
        if (FAILED(hr))
        {
            goto Error;
        }

        pAI->SetPortName(str.c_str());
    }

    // Set the return value
    *ppAI = pAI;

Done:
    ::RegSafeCloseKey(hkeyAdapter);
    ::RegSafeCloseKey(hkeyAdapterRoot);
    return hr;

Error:
    TraceError("CATLKEnv::HrGetOneAdaptersInfo",hr);
    delete pAI;
    goto Done;
}

//
// Function:    CATLKEnv::HrGetAdapterInfo
//
// Purpose:     Retrieve the AppleTalk Adapter information
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetAdapterInfo()
{
    HRESULT           hr = S_OK;
    CAdapterInfo *    pAI = NULL;
    INetCfgComponent* pncc = NULL;
    INetCfgComponent* pnccUse = NULL;

    // Find each netcard, to do so, trace the bindings to their end
    // If the endpoint is a netcard then add it to the list
    CIterNetCfgBindingPath ncbpIter(m_pmsc->PNCComponent());
    INetCfgBindingPath*    pncbp;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = ncbpIter.HrNext (&pncbp))))
    {
        // Iterate the binding interfaces of this path.
        CIterNetCfgBindingInterface ncbiIter(pncbp);
        INetCfgBindingInterface* pncbi;

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = ncbiIter.HrNext (&pncbi))))
        {
            // Retrieve the lower component
            hr = pncbi->GetLowerComponent(&pncc);
            if (S_OK == hr)
            {
                GUID guidClass;

                // Is it an Adapter?
                hr = pncc->GetClassGuid(&guidClass);
                if ((S_OK == hr) && (guidClass == GUID_DEVCLASS_NET))
                {
                    ULONG ulStatus = 0;
                    hr = pncc->GetDeviceStatus(&ulStatus);
                    if(SUCCEEDED(hr))
                    {
                        ReleaseObj(pnccUse);
                        pnccUse = pncc;
                        pncc = NULL;
                    }
                    else
                    {
                        // Release the lower component
                        ReleaseObj(pncc);
                        hr = S_OK;
                        break;
                    }
                }
                else
                {
                    // Release the lower component
                    ReleaseObj(pncc);
                }
            }

            // Release the binding interface
            ReleaseObj (pncbi);
        }

        if (NULL != pnccUse)
        {
            // Query the Adapter information
            hr = HrGetOneAdaptersInfo(pnccUse, &pAI);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == pncbp->IsEnabled())
                {
                    pAI->SetDisabled(TRUE);
                }

                // Add this Adapter to the list
                m_lstpAdapters.push_back(pAI);
            }

            ReleaseObj(pnccUse);
            pnccUse = NULL;
        }

        // Release the binding path
        ReleaseObj (pncbp);
    }

    if (FAILED(hr))
    {
        goto Error;
    }

    // Initialize the default port, etc
    InitDefaultPort();

    // Normalize the HRESULT.  (i.e. don't return S_FALSE)
    hr = S_OK;

Error:
    TraceError("CATLKEnv::HrGetAdapterInfo",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrGetAppleTalkInfoFromNetwork
//
// Purpose:     ???
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrGetAppleTalkInfoFromNetwork(CAdapterInfo * pAI)
{
    SOCKADDR_AT    address;
    HRESULT        hr = S_FALSE;
    BOOL           fWSInitialized = FALSE;
    SOCKET         mysocket = INVALID_SOCKET;
    WSADATA        wsadata;
    DWORD          wsaerr = 0;
    tstring        strPortName;

    // Create the socket/bind
    wsaerr = WSAStartup(0x0101, &wsadata);
    if (0 != wsaerr)
    {
        goto Error;
    }

    // Winsock successfully initialized
    fWSInitialized = TRUE;

    mysocket = socket(AF_APPLETALK, SOCK_DGRAM, DDPPROTO_ZIP);
    if (INVALID_SOCKET == mysocket)
    {
        goto Error;
    }

    address.sat_family = AF_APPLETALK;
    address.sat_net = 0;
    address.sat_node = 0;
    address.sat_socket = 0;

    wsaerr = bind(mysocket, (struct sockaddr *)&address, sizeof(address));
    if (wsaerr != 0)
    {
        goto Error;
    }

    // Mark AppleTalk as running
    SetATLKRunning(TRUE);

    // For each known adapter, create a device name by merging the "\\device\\"
    // prefix and the adapter's bind name.
    strPortName = c_szDevice;
    strPortName += pAI->SzBindName();

    // Failures from query the zone list for a given adapter can be from
    // the adapter not connected to the network, zone seeder not running, etc.
    // Because we want to process all the adapters, we ignore these errors.
    (void)pAI->HrGetAndSetNetworkInformation(mysocket,strPortName.c_str());

    // Success, or at least not a critical failure
    hr = S_OK;

Done:
    if (INVALID_SOCKET != mysocket)
    {
        closesocket(mysocket);
    }

    if (fWSInitialized)
    {
        WSACleanup();
    }

    TraceError("CATLKEnv::HrGetAppleTalkInfoFromNetwork",(S_FALSE == hr ? S_OK : hr));
    return hr;

Error:
    wsaerr = ::WSAGetLastError();
    goto Done;
}

//
// Function:    CATLKEnv::HrAddAdapter
//
// Purpose:     Add and adapter to the list of currently bound adapters
//
// Parameters:  pnccFound - Notification object for the bound adapter to add
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrAddAdapter(INetCfgComponent * pnccFound)
{
    HRESULT        hr;
    CAdapterInfo * pAI = NULL;

    Assert(NULL != pnccFound);

    // Create an AdapterInfo instance for the adapter
    hr = HrGetOneAdaptersInfo(pnccFound, &pAI);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Add this Adapter to the list
    m_lstpAdapters.push_back(pAI);
    pAI->SetDirty(TRUE);

    // If there is now only one adapter in the list, update the defaults
    if (1 == m_lstpAdapters.size())
    {
        tstring str;
        str = c_szDevice;
        str += m_lstpAdapters.front()->SzBindName();
        SetDefaultPort(str.c_str());
        SetDefaultMediaType(m_lstpAdapters.front()->DwMediaType());
    }

Error:
    TraceError("CATLKEnv::HrAddAdapter",hr);
    return hr;
}

//
// Function:    CATLKEnv::SetDefaultPort
//
// Purpose:     Change the default port name
//
// Parameters:  psz [in] - The new default port name
//
// Returns:     HRESULT, S_OK on success
//
void CATLKEnv::SetDefaultPort(PCWSTR psz)
{
    Assert(psz);
    delete [] m_Params.szDefaultPort;
    m_Params.szDefaultPort = new WCHAR[wcslen(psz)+1];
    wcscpy(m_Params.szDefaultPort, psz);
}

//
// Function:    CATLKEnv::SetDesiredZone
//
// Purpose:     Change the desired zone
//
// Parameters:  sz [in] - The new desired zone
//
// Returns:     HRESULT, S_OK on success
//
void CATLKEnv::SetDesiredZone(PCWSTR psz)
{
    Assert(psz);
    delete [] m_Params.szDesiredZone;
    m_Params.szDesiredZone = new WCHAR[wcslen(psz)+1];
    wcscpy(m_Params.szDesiredZone, psz);
}

CAdapterInfo * CATLKEnv::PAIFindDefaultPort()
{
    CAdapterInfo *                   pAI = NULL;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // Find the default port
    //
    for (iter = m_lstpAdapters.begin();
         iter != m_lstpAdapters.end();
         iter++)
    {
        tstring        strPortName;

        pAI = *iter;

        // Retain adapter selection as the default port
        strPortName = c_szDevice;
        strPortName += pAI->SzBindName();

        if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
            pAI->IsRasAdapter())
        {
            continue;
        }

        if (0 == _wcsicmp(SzDefaultPort(), strPortName.c_str()))
        {
            return pAI;
        }
    }

    return NULL;
}

//
// Function:    CATLKEnv::HrUpdateRegistry
//
// Purpose:     Write the AppleTalk local (internal) data back to the registry
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrUpdateRegistry()
{
    HRESULT        hr = S_OK;
    CAdapterInfo * pAI = NULL;
    HKEY           hkeyAdapter;
    DWORD          dwDisposition;
    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // If the current default port is unavailable, find an alternate
    pAI = PAIFindDefaultPort();
    if (NULL == pAI)
    {
        InitDefaultPort();
        pAI = PAIFindDefaultPort();
    }

    // If the default adapter changed then three specific values for that
    //  adapter need to be reset to zero.
    //
    if (pAI && FDefAdapterChanged())
    {
        pAI->ZeroSpecialParams();
        pAI->SetDirty(TRUE);
    }

    // Commit the registry changes
    hr = ::HrRegWriteValues(celems(regbatchATLKParams), regbatchATLKParams,
                            (BYTE *)&m_Params, REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS);
    if (S_OK != hr)
    {
        goto Error;
    }

    // Create the Adapters key AppleTalk\Parameters\Adapters)
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szATLKAdapters,
                             REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                             &hkeyAdapter, &dwDisposition);
    if (S_OK == hr)
    {
        // Enumerate the bound adapters and write the internal adapter list
        for (iter = m_lstpAdapters.begin();
             (iter != m_lstpAdapters.end()) && (SUCCEEDED(hr));
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending())
            {
                // Remove the AppleTalk\Adapter\{bindname} tree
                hr = ::HrRegDeleteKeyTree(hkeyAdapter, pAI->SzBindName());
                if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hr))
                {
                    goto Error;
                }
            }
            else if (pAI->IsDirty())
            {
                hr = HrWriteOneAdapter(pAI);
            }
        }

        RegCloseKey (hkeyAdapter);
    }

Error:
    TraceError("CATLKEnv::HrUpdateRegistry",hr);
    return hr;
}

//
// Function:    CATLKEnv::HrWriteOneAdapter
//
// Purpose:     Write one adapter instance to the registry
//
// Parameters:  pAI [in] - The adapter to presist in the registry
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CATLKEnv::HrWriteOneAdapter(CAdapterInfo *pAI)
{
    DWORD    dwDisposition;
    HKEY     hkeyAdapter = NULL;
    HRESULT  hr;
    INT      idx;
    REGBATCH regbatch;
    tstring  str;

    str = c_szATLKAdapters;
    str += c_szBackslash;
    str += pAI->SzBindName();

    // Create the key described in str (AppleTalk\Parameters\Adapters\<adapter>)
    hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                            &hkeyAdapter, &dwDisposition);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Write out the adapter parameters
    for (idx = 0; idx < celems(regbatchATLKAdapters); idx++)
    {
        regbatch = regbatchATLKAdapters[idx];
        regbatch.pszSubkey = str.c_str();

        hr = ::HrRegWriteValues(1, &regbatch, (BYTE *)pAI->PAdapterInfo(),
                                REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Write out the zone list multi-sz (managed seperately)
    hr = ::HrRegSetColString(hkeyAdapter, c_szZoneList, pAI->LstpstrZoneList());

Error:
    ::RegSafeCloseKey(hkeyAdapter);
    TraceError("CATLKEnv::HrWriteOneAdapter",hr);
    return S_OK;
}

//
// Function:    CATLKEnv::DwMediaPriority
//
// Purpose:     When determining the appropriate adapter for use as the
//              "DefaultPort" certain mediatype's are faster.  So all
//              other things being equal, selecting a faster mediatype
//              benefits the user the most.
//
// Parameters:  dwMediaType [in] - MediaType used to determine priority ranking
//
// Returns:     DWORD, value (1-5) with the lowest value representing the
//                                 highest priority.
//
DWORD CATLKEnv::DwMediaPriority(DWORD dwMediaType)
{
    switch(dwMediaType)
    {
        case MEDIATYPE_ETHERNET:
            return 2;
        case MEDIATYPE_TOKENRING:
            return 3;
        case MEDIATYPE_FDDI:
            return 1;
        case MEDIATYPE_LOCALTALK:
            return 4;
        default:
            return 5;
    }
}

//
// Function:    CATLKEnv::InitDefaultPort
//
// Purpose:     Select a default port if none yet has been selected.  Retain
//              some select information for assisting in dialog display issues.
//
// Parameters:  none
//
// Returns:     nothing
//
void CATLKEnv::InitDefaultPort()
{
    CAdapterInfo * pAI = NULL;
    tstring        str;

    ATLK_ADAPTER_INFO_LIST::iterator iter;

    // If DefaultPort is set, does the associated adapter exist?
    if (wcslen(SzDefaultPort()))
    {
        // Search for the adapter in the list
        for (iter = AdapterInfoList().begin();
             iter != AdapterInfoList().end();
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
                pAI->IsRasAdapter())
            {
                pAI = NULL;
                continue;
            }

            str = c_szDevice;
            str += pAI->SzBindName();
            if (0 == wcscmp(str.c_str(), SzDefaultPort()))
            {
                break;
            }

            pAI = NULL;
        }
    }

    // If DefaultPort is not set locate the best candidate
    if (NULL == pAI)
    {
        CAdapterInfo * pAIBest = NULL;
        SetDefaultPort(c_szEmpty);

        // Search through the adapter list for the adapter
        // with the fastest media type.
        for (iter = AdapterInfoList().begin();
             iter != AdapterInfoList().end();
             iter++)
        {
            pAI = *iter;

            if (pAI->FDeletePending() || pAI->FDisabled() || pAI->FHidden() ||
                pAI->IsRasAdapter())
            {
                continue;
            }

            if ((NULL == pAIBest) ||
                (DwMediaPriority(pAIBest->DwMediaType()) >
                 DwMediaPriority(pAI->DwMediaType())))
            {
                SetDefAdapterChanged(TRUE);
                pAIBest = pAI;
            }
        }

        pAI = pAIBest;
    }

    if (NULL != pAI)
    {
        // retain the selected adapter as the default port
        str = c_szDevice;
        str += pAI->SzBindName();
        SetDefaultPort(str.c_str());

        // retain the default media type
        SetDefaultMediaType(pAI->DwMediaType());
    }
    else
    {
        SetDefaultPort(c_szEmpty);
    }
}

//
// Function:    CAdapterInfo::CAdapterInfo
//
// Purpose:     ctor for the CAdapters class
//
// Parameters:  none
//
// Returns:     nothing
//
CAdapterInfo::CAdapterInfo() :
    m_fDeletePending(FALSE),
    m_fDisabled(FALSE),
    m_fDirty(FALSE),
    m_fRasAdapter(FALSE),
    m_fRouterOnNetwork(FALSE),
    m_fZoneListValid(FALSE),
    m_dwNetworkUpper(0),
    m_dwNetworkLower(0),
    m_dwCharacteristics(0)
{
    ZeroMemory(&m_guidInstance, sizeof(m_guidInstance));

    // Initialize the AdapterInfo default values
    ZeroMemory(&m_AdapterInfo, sizeof(m_AdapterInfo));
    m_AdapterInfo.m_dwAarpRetries = c_dwTen;
    m_AdapterInfo.m_dwMediaType   = MEDIATYPE_ETHERNET;
    SetDefaultZone(c_szEmpty);
    SetPortName(c_szEmpty);
}

//
// Function:    CAdapterInfo::~CAdapterInfo
//
// Purpose:     ctor for the CAdapters class
//
// Parameters:  none
//
// Returns:     nothing
//
CAdapterInfo::~CAdapterInfo()
{
    // Cleanup the AppleTalk\Adapters\<adapter> internal data structure
    delete [] m_AdapterInfo.m_szDefaultZone;
    delete [] m_AdapterInfo.m_szPortName;

    DeleteColString(&m_lstpstrDesiredZoneList);
    DeleteColString(&m_lstpstrZoneList);
}

//
// Function:    CAdapterInfo::SetDefaultZone
//
// Purpose:     Set the default zone for this adapter
//
// Parameters:  sz - The new default zone
//
// Returns:     nothing
//
void CAdapterInfo::SetDefaultZone(PCWSTR psz)
{
    Assert(psz);
    delete [] m_AdapterInfo.m_szDefaultZone;
    m_AdapterInfo.m_szDefaultZone = NULL;
    m_AdapterInfo.m_szDefaultZone = new WCHAR[wcslen(psz)+1];
    wcscpy(m_AdapterInfo.m_szDefaultZone, psz);
}

//
// Function:    CAdapterInfo::SetPortName
//
// Purpose:     Set the port name for this adapter
//
// Parameters:  sz - The new port name
//
// Returns:     nothing
//
void CAdapterInfo::SetPortName(PCWSTR psz)
{
    Assert(psz);
    delete [] m_AdapterInfo.m_szPortName;
    m_AdapterInfo.m_szPortName = NULL;
    m_AdapterInfo.m_szPortName = new WCHAR[wcslen(psz)+1];
    wcscpy(m_AdapterInfo.m_szPortName, psz);
}

//
// Function:    CAdapterInfo::HrGetAndSetNetworkInformation
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
#define PARM_BUF_LEN    512
#define ASTERISK_CHAR   "*"

HRESULT
CAdapterInfo::HrGetAndSetNetworkInformation (
    SOCKET socket,
    PCWSTR pszDevName)
{
    HRESULT      hr = FALSE;
    CHAR         *pZoneBuffer = NULL;
    CHAR         *pDefParmsBuffer = NULL;
    CHAR         *pZoneListStart;
    INT          BytesNeeded ;
    WCHAR        *pwDefZone = NULL;
    tstring      strTmpZone;
    INT          ZoneLen = 0;
    DWORD        wsaerr = 0;
    CHAR         *pDefZone = NULL;

    PWSH_LOOKUP_ZONES                pGetNetZones;
    PWSH_LOOKUP_NETDEF_ON_ADAPTER    pGetNetDefaults;

    Assert(pszDevName);

    pZoneBuffer = new CHAR [ZONEBUFFER_LEN + sizeof(WSH_LOOKUP_ZONES)];
    Assert(pZoneBuffer);

	if (pZoneBuffer == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pGetNetZones = (PWSH_LOOKUP_ZONES)pZoneBuffer;

    wcscpy((WCHAR *)(pGetNetZones+1), pszDevName);

    BytesNeeded = ZONEBUFFER_LEN;

    wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_ZONES_ON_ADAPTER,
                        (char *)pZoneBuffer, &BytesNeeded);
    if (0 != wsaerr)
    {
        //$ REVIEW - error mapping
#ifdef DBG
        DWORD dwErr = WSAGetLastError();
        TraceTag(ttidError, "CAdapterInfo::HrGetAndSetNetworkInformation getsocketopt returned: %08X",dwErr);
#endif
        hr = E_UNEXPECTED;
        goto Error;
    }

    pZoneListStart = pZoneBuffer + sizeof(WSH_LOOKUP_ZONES);
    if (!lstrcmpA(pZoneListStart, ASTERISK_CHAR))
    {
        // Success, wildcard zone set.
        goto Done;
    }

    hr = HrConvertZoneListAndAddToPortInfo(pZoneListStart,
                                           ((PWSH_LOOKUP_ZONES)pZoneBuffer)->NoZones);
    if (FAILED(hr))
    {
        goto Error;
    }

    SetRouterOnNetwork(TRUE);

    //
    // Get the DefaultZone/NetworkRange Information
    pDefParmsBuffer = new CHAR[PARM_BUF_LEN+sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER)];
    Assert(pDefParmsBuffer);

	if (pDefParmsBuffer == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pGetNetDefaults = (PWSH_LOOKUP_NETDEF_ON_ADAPTER)pDefParmsBuffer;
    BytesNeeded = PARM_BUF_LEN + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);

    wcscpy((WCHAR*)(pGetNetDefaults+1), pszDevName);
    pGetNetDefaults->NetworkRangeLowerEnd = pGetNetDefaults->NetworkRangeUpperEnd = 0;

    wsaerr = getsockopt(socket, SOL_APPLETALK, SO_LOOKUP_NETDEF_ON_ADAPTER,
                        (char*)pDefParmsBuffer, &BytesNeeded);
    if (0 != wsaerr)
    {
#ifdef DBG
        DWORD dwErr = WSAGetLastError();
#endif
        hr = E_UNEXPECTED;
        goto Error;
    }

    // Save the default information to PORT_INFO
    SetExistingNetRange(pGetNetDefaults->NetworkRangeLowerEnd,
                        pGetNetDefaults->NetworkRangeUpperEnd);

    pDefZone  = pDefParmsBuffer + sizeof(WSH_LOOKUP_NETDEF_ON_ADAPTER);
    ZoneLen = lstrlenA(pDefZone) + 1;

    pwDefZone = new WCHAR [sizeof(WCHAR) * ZoneLen];
    Assert(NULL != pwDefZone);

	if (pwDefZone == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    mbstowcs(pwDefZone, pDefZone, ZoneLen);

    strTmpZone = pwDefZone;

    SetNetDefaultZone(strTmpZone.c_str());

    if (pZoneBuffer != NULL)
    {
        delete [] pZoneBuffer;
    }

    if (pwDefZone != NULL)
    {
        delete [] pwDefZone;
    }

    if (pDefParmsBuffer != NULL)
    {
        delete [] pDefParmsBuffer;
    }

Done:
Error:
    TraceError("CAdapterInfo::HrGetAndSetNetworkInformation",hr);
    return hr;
}

//
// Function:    CAdapterInfo::HrConvertZoneListAndAddToPortInfo
//
// Purpose:
//
// Parameters:
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CAdapterInfo::HrConvertZoneListAndAddToPortInfo(CHAR * szZoneList, ULONG NumZones)
{
    INT      cbAscii = 0;
    WCHAR    *pszZone = NULL;
    tstring  *pstr;

    Assert(NULL != szZoneList);
    DeleteColString(&m_lstpstrDesiredZoneList);

    while(NumZones--)
    {
        cbAscii = lstrlenA(szZoneList) + 1;

        pszZone = new WCHAR [sizeof(WCHAR) * cbAscii];
        Assert(NULL != pszZone);

		if (pszZone == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        mbstowcs(pszZone, szZoneList, cbAscii);

        pstr = new tstring(pszZone);
        Assert(NULL != pstr);

        m_lstpstrDesiredZoneList.push_back(pstr);
        szZoneList += cbAscii;

       delete [] pszZone;
    }

    return S_OK;
}

//
// Function:    CAdapterInfo::HrCopy
//
// Purpose:     Create a duplicate copy of 'this'
//
// Parameters:  ppAI [out] - if the function succeeds, ppAI will contain the
//                           copy of 'this'.
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CAdapterInfo::HrCopy(CAdapterInfo ** ppAI)
{
    CAdapterInfo *pAI;
    list<tstring*>::iterator iter;
    tstring * pstr;

    Assert(NULL != ppAI);

    // Create an adapter info structure
    pAI = new CAdapterInfo;
    Assert(pAI);

	if (pAI == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // Make a copy of everything
    pAI->SetDisabled(FDisabled());
    pAI->SetDeletePending(FDeletePending());
    pAI->SetCharacteristics(GetCharacteristics());
    pAI->SetMediaType(DwMediaType());
    pAI->SetBindName(SzBindName());
    pAI->SetDisplayName(SzDisplayName());
    pAI->SetNetDefaultZone(SzNetDefaultZone());
    pAI->SetRouterOnNetwork(FRouterOnNetwork());
    pAI->SetExistingNetRange(DwQueryNetworkLower(), DwQueryNetworkUpper());
    pAI->SetDirty(IsDirty());
    pAI->SetRasAdapter(IsRasAdapter());

    // Free the default data set by the constructor before overwriting it.
    // (this whole thing is not a very good approach.)
    //
    delete [] pAI->m_AdapterInfo.m_szDefaultZone;
    delete [] pAI->m_AdapterInfo.m_szPortName;

    pAI->m_AdapterInfo = m_AdapterInfo;

    // Cleanup the 'allocated' data cause by the bit copy
    // so that SetDefaultZone and SetPortName don't try to free bogus
    // stuff.  (more "programming by side-affect")
    //
    pAI->m_AdapterInfo.m_szDefaultZone = NULL;
    pAI->m_AdapterInfo.m_szPortName = NULL;

    // Now copy the 'allocated' data
    pAI->SetDefaultZone(SzDefaultZone());
    pAI->SetPortName(SzPortName());

    for (iter = LstpstrZoneList().begin();
         iter != LstpstrZoneList().end();
         iter++)
    {
        pstr = *iter;
        pAI->LstpstrZoneList().push_back(new tstring(pstr->c_str()));
    }

    for (iter = LstpstrDesiredZoneList().begin();
         iter != LstpstrDesiredZoneList().end();
         iter++)
    {
        pstr = *iter;
        pAI->LstpstrDesiredZoneList().push_back(new tstring(pstr->c_str()));
    }

    *ppAI = pAI;
    return S_OK;
}

//
// Function:    HrQueryAdapterComponentInfo
//
// Purpose:     Fill out an CAdapterInfo instance with the data retrieved
//              specifically from the component itself.
//
// Parameters:  pncc [in] - The component object (adapter) to query
//              pAI [in/out] - Where to place the queried info
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrQueryAdapterComponentInfo(INetCfgComponent *pncc,
                                    CAdapterInfo * pAI)
{
    PWSTR  psz = NULL;
    DWORD   dwCharacteristics;
    HRESULT hr;

    Assert(NULL != pncc);
    Assert(NULL != pAI);

    // Retrieve the component's name
    hr = pncc->GetBindName(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz && *psz);
    pAI->SetBindName(psz);
    CoTaskMemFree(psz);
    psz = NULL;

    hr = pncc->GetInstanceGuid(pAI->PInstanceGuid());
    if (FAILED(hr))
    {
        goto Error;
    }

    // Get the Adapter's display name
    hr = pncc->GetDisplayName(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz);
    pAI->SetDisplayName(psz);
    CoTaskMemFree(psz);
    psz = NULL;

    // Get the Component ID so we can check if this is a RAS adapter
    //
    hr = pncc->GetId(&psz);
    if (FAILED(hr))
    {
        goto Error;
    }

    Assert(psz && *psz);
    pAI->SetRasAdapter(0 == _wcsicmp(c_szInfId_MS_NdisWanAtalk, psz));
    CoTaskMemFree(psz);
    psz = NULL;

    // Failure is non-fatal
    hr = pncc->GetCharacteristics(&dwCharacteristics);
    if (SUCCEEDED(hr))
    {
        pAI->SetCharacteristics(dwCharacteristics);
    }

    // Get the media type (Optional key)
    {
        DWORD dwMediaType = MEDIATYPE_ETHERNET ;
        INetCfgComponentBindings* pnccBindings = NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  reinterpret_cast<void**>(&pnccBindings));
        if (S_OK == hr)
        {
            static const struct
            {
                PCWSTR pszInterface;
                DWORD   dwInterface;
                DWORD   dwFlags;
            } InterfaceMap[] = {{L"ethernet", MEDIATYPE_ETHERNET, NCF_LOWER},
                                {L"tokenring", MEDIATYPE_TOKENRING, NCF_LOWER},
                                {L"fddi", MEDIATYPE_FDDI, NCF_LOWER},
                                {L"localtalk", MEDIATYPE_LOCALTALK, NCF_LOWER},
                                {L"wan", MEDIATYPE_WAN, NCF_LOWER}};

            for (UINT nIdx=0; nIdx < celems(InterfaceMap); nIdx++)
            {
                hr = pnccBindings->SupportsBindingInterface(InterfaceMap[nIdx].dwFlags,
                                                            InterfaceMap[nIdx].pszInterface);
                if (S_OK == hr)
                {
                    dwMediaType = InterfaceMap[nIdx].dwInterface;
                    break;
                }
            }

            ::ReleaseObj(pnccBindings);
        }

        pAI->SetMediaType(dwMediaType);
        hr = S_OK;
    }

Error:
    TraceError("HrQueryAdapterComponentInfo",hr);
    return hr;
}

//
// Function:    HrPortNameFromAdapter
//
// Purpose:     Create a port name, for use as an adapters PortName
//
// Parameters:  pncc [in] - The component object (adapter) to query
//              pstr [in/out] - On success will contain the PortName
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrPortNameFromAdapter(INetCfgComponent *pncc, tstring * pstr)
{
    HRESULT hr;
    PWSTR psz;
    PWSTR pszBindName = NULL;
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize = sizeof(szComputerName) / sizeof(WCHAR);

    Assert(NULL != pstr);
    Assert(NULL != pncc);

    if (!GetComputerName(szComputerName, &dwSize))
    {
        hr = ::HrFromLastWin32Error();
        goto Error;
    }

    hr = pncc->GetBindName(&pszBindName);
    if (FAILED(hr))
    {
        goto Error;
    }

    // Replace the instances of '-' and '{' with '0' so the constructed
    // portname is of the form [a-zA-Z0-9]*@<Computer Name> and is less
    // than MAX_ZONE_NAME_LEN long.
    psz = pszBindName;
    while (*psz)
    {
        if ((*psz == L'-') || (*psz == L'{'))
        {
            *psz = L'0';
        }
        psz++;
    }

    *pstr = pszBindName;
    if (pstr->size() + 1 + dwSize > MAX_ZONE_NAME_LEN)
    {
        pstr->resize(MAX_ZONE_NAME_LEN - (dwSize + 1));
    }

    *pstr += c_chAt;
    *pstr += szComputerName;
    Assert( MAX_ZONE_NAME_LEN >= pstr->size());

Error:
    CoTaskMemFree(pszBindName);
    TraceError("HrPortNameFromAdapter",hr);
    return hr;
}

HRESULT CATlkObj::HrAtlkReconfig()
{
    CServiceManager csm;
    CService        svr;
    HRESULT         hr = S_OK;
    HRESULT         hrRet;
    BOOL            fDirty = FALSE;
    CAdapterInfo *  pAI;
    CAdapterInfo *  pAIDefault = NULL;
    ATLK_ADAPTER_INFO_LIST::iterator iter;
    ATALK_PNP_EVENT Config;

    if (m_pATLKEnv->AdapterInfoList().empty())
    {
        return hr;
    }

    ZeroMemory(&Config, sizeof(Config));

    // If routing changed notify appletalk and return.  No need to do the
    // per adapter notifications.
    if (m_pATLKEnv->FRouterChanged())
    {
        // notify atlk
        Config.PnpMessage = AT_PNP_SWITCH_ROUTING;
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, c_szEmpty,
                                      &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }

        m_pATLKEnv->SetRouterChanged(FALSE);

        return hr;
    }

    // Find the default adapter and also if any adapter's have changed
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;

        tstring strPortName = c_szDevice;
        strPortName += pAI->SzBindName();

        if (pAI->FDeletePending() || pAI->FDisabled())
        {
            continue;
        }

        // Locate the default port
        if (0 == _wcsicmp(strPortName.c_str(), m_pATLKEnv->SzDefaultPort()))
        {
            pAIDefault = pAI;
        }

        if (pAI->IsDirty())
        {
            fDirty = TRUE;
        }
    }

    if ((NULL != pAIDefault) && m_pATLKEnv->FDefAdapterChanged())
    {
        // notify atlk
        Config.PnpMessage = AT_PNP_SWITCH_DEFAULT_ADAPTER;
        hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, NULL,
                                      &Config, sizeof(ATALK_PNP_EVENT));
        if (FAILED(hrRet) &&
            (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
        {
            hr = NETCFG_S_REBOOT;
        }

        // Clear the dirty state
        m_pATLKEnv->SetDefAdapterChanged(FALSE);
        pAIDefault->SetDirty(FALSE);
    }

    Config.PnpMessage = AT_PNP_RECONFIGURE_PARMS;
    for (iter = m_pATLKEnv->AdapterInfoList().begin();
         iter != m_pATLKEnv->AdapterInfoList().end();
         iter++)
    {
        pAI = *iter;

        if (pAI->FDeletePending() || pAI->FDisabled())
        {
            continue;
        }

        if (pAI->IsDirty())
        {
            // Now submit the reconfig notification
            hrRet = HrSendNdisPnpReconfig(NDIS, c_szAtlk, pAI->SzBindName(),
                                          &Config, sizeof(ATALK_PNP_EVENT));
            if (FAILED(hrRet) &&
                (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) != hrRet))
            {
                hr = NETCFG_S_REBOOT;
            }

            // Clear the dirty state
            pAI->SetDirty(FALSE);
        }
    }

    TraceError("CATLKObj::HrAtlkReconfig",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atlkcfg\atlkobj.h ===
#pragma once
#include <ncxbase.h>
#include <ncatlps.h>
#include <nceh.h>
#include <ncsetup.h>
#include <notifval.h>
#include <winsock2.h>
#include "resource.h"

extern const WCHAR c_szEmpty[];

// AppleTalk Globally visible strings
extern const WCHAR c_chAt;

// Define the possible media types (Used also as array indices)
#define MEDIATYPE_ETHERNET      1
#define MEDIATYPE_TOKENRING     2
#define MEDIATYPE_FDDI          3
#define MEDIATYPE_WAN           4
#define MEDIATYPE_LOCALTALK     5

#define MAX_ZONES           255
#define ZONELISTSIZE        2048
#define MAX_ZONE_NAME_LEN   32
#define MAX_RANGE_ALLOWED   65279
#define MIN_RANGE_ALLOWED   1
#define ZONEBUFFER_LEN      32*255

// Seed Info  Validation returns
#define NO_SEED_INFO        0x0
#define VALID_SEED_INFO     0x1
#define INVALID_SEED_INFO   0x2

typedef enum
{
    AT_PNP_SWITCH_ROUTING = 0,
    AT_PNP_SWITCH_DEFAULT_ADAPTER,
    AT_PNP_RECONFIGURE_PARMS
} ATALK_PNP_MSGTYPE;

typedef struct _ATALK_PNP_EVENT
{
    ATALK_PNP_MSGTYPE   PnpMessage;
} ATALK_PNP_EVENT, *PATALK_PNP_EVENT;

// Class Forwards
class CATlkObj;
class CATLKEnv;
class CAdapterInfo;

// Define a structure for reading/writing all information necessary about an adapter
typedef struct
{
    DWORD  m_dwAarpRetries;
    DWORD  m_dwDdpCheckSums;
    DWORD  m_dwNetworkRangeLowerEnd;
    DWORD  m_dwNetworkRangeUpperEnd;
    DWORD  m_dwRouterPramNode;
    DWORD  m_dwSeedingNetwork;
    DWORD  m_dwUserPramNode1;
    DWORD  m_dwUserPramNode2;
    DWORD  m_dwMediaType;
    WCHAR* m_szDefaultZone;
    WCHAR* m_szPortName;
} ATLK_ADAPTER;

typedef list<CAdapterInfo *> ATLK_ADAPTER_INFO_LIST;

// Class:   CAdapters
//
// Purpose: Contain all information necessary about a single adapter instance
//
class CAdapterInfo
{
friend class CATLKEnv;
public:
    CAdapterInfo();
    ~CAdapterInfo();

    // Make a duplicate copy of 'this'
    HRESULT HrCopy(CAdapterInfo ** ppAI);

    void          SetDeletePending(BOOL f) {m_fDeletePending = f;}
    BOOL          FDeletePending() {return m_fDeletePending;}

    void          SetDisabled(BOOL f) {m_fDisabled = f;}
    BOOL          FDisabled() {return m_fDisabled;}

    void          SetCharacteristics(DWORD dw) {m_dwCharacteristics = dw;}
    DWORD         GetCharacteristics() {return m_dwCharacteristics;}
    BOOL          FHidden() {return !!(NCF_HIDDEN & m_dwCharacteristics);}

    void          SetMediaType(DWORD dw)     {m_AdapterInfo.m_dwMediaType = dw;}
    DWORD         DwMediaType()              {return m_AdapterInfo.m_dwMediaType;}

    void          SetDisplayName(PCWSTR psz) {m_strDisplayName = psz;}
    PCWSTR        SzDisplayName()            {return m_strDisplayName.c_str();}

    void          SetBindName(PCWSTR psz)    {m_strBindName = psz;}
    PCWSTR        SzBindName()               {return m_strBindName.c_str();}

    ATLK_ADAPTER* PAdapterInfo()             {return &m_AdapterInfo;}

    void          SetPortName(PCWSTR psz);
    PCWSTR        SzPortName()               {return m_AdapterInfo.m_szPortName ?
                                                     m_AdapterInfo.m_szPortName :
                                                     c_szEmpty;}

    void          SetDefaultZone(PCWSTR psz);
    PCWSTR        SzDefaultZone()            {return m_AdapterInfo.m_szDefaultZone ?
                                                     m_AdapterInfo.m_szDefaultZone :
                                                     c_szEmpty;}

    list<tstring*> &LstpstrZoneList()         {return m_lstpstrZoneList;}
    list<tstring*> &LstpstrDesiredZoneList()  {return m_lstpstrDesiredZoneList;}

    void          SetSeedingNetwork(BOOL fSeeding)
                                    {m_AdapterInfo.m_dwSeedingNetwork = (fSeeding ? 1 : 0);}
    DWORD         FSeedingNetwork() {return (1 == m_AdapterInfo.m_dwSeedingNetwork);}

    void          SetRouterOnNetwork(BOOL f) {m_fRouterOnNetwork = f;}
    BOOL          FRouterOnNetwork()         {return m_fRouterOnNetwork;}

    void          SetExistingNetRange(DWORD dwLower, DWORD dwUpper)
                                             {m_dwNetworkLower = dwLower;
                                              m_dwNetworkUpper = dwUpper;}
    DWORD         DwQueryNetworkUpper() {return m_dwNetworkUpper;}
    DWORD         DwQueryNetworkLower() {return m_dwNetworkLower;}

    void          SetAdapterNetRange(DWORD dwLower, DWORD dwUpper)
                                     {m_AdapterInfo.m_dwNetworkRangeLowerEnd = dwLower;
                                      m_AdapterInfo.m_dwNetworkRangeUpperEnd = dwUpper;}
    DWORD         DwQueryNetRangeUpper() {return m_AdapterInfo.m_dwNetworkRangeUpperEnd;}
    DWORD         DwQueryNetRangeLower() {return m_AdapterInfo.m_dwNetworkRangeLowerEnd;}

    void          SetNetDefaultZone(PCWSTR psz) {m_strNetDefaultZone = psz;}
    PCWSTR        SzNetDefaultZone() {return m_strNetDefaultZone.c_str();}

    HRESULT       HrConvertZoneListAndAddToPortInfo(CHAR * szZoneList, ULONG NumZones);
    HRESULT       HrGetAndSetNetworkInformation(SOCKET, PCWSTR);

    VOID          SetInstanceGuid(GUID guid) {memcpy(&m_guidInstance, &guid, sizeof(GUID));}
    GUID *        PInstanceGuid()   {return &m_guidInstance;}

    BOOL          IsDirty() {return m_fDirty;}
    VOID          SetDirty(BOOL f) {m_fDirty = f;}

    BOOL          IsRasAdapter() {return m_fRasAdapter;}
    VOID          SetRasAdapter(BOOL f) {m_fRasAdapter = f;}

    VOID          ZeroSpecialParams() {m_AdapterInfo.m_dwUserPramNode1 = 0;
                                       m_AdapterInfo.m_dwUserPramNode2 = 0;
                                       m_AdapterInfo.m_dwRouterPramNode = 0; }

    // m_guidInstance is the instance guid of the adapter
    GUID              m_guidInstance;

    // m_lstpstrZoneList is the REG_MULTI_SZ value found under
    // AppleTalk\Parameters\Adapters\<adapter>\ZoneList
    list<tstring*>    m_lstpstrZoneList;

    // Desired zone will be choosen from this list
    list<tstring*>    m_lstpstrDesiredZoneList;

    // m_AdapterInfo is the collection of values found under
    // AppleTalk\Parameters\Adapters\<adapter> with the exception of the
    // ZoneList : REG_MULTI_SZ value which is stored in m_lstpstrZoneList above.
    ATLK_ADAPTER      m_AdapterInfo;

private:
    // m_fDisabled is a boolean that, when TRUE, indicates this adapter
    // is currently disabled
    BOOL              m_fDisabled;

    // If true, this adapter's info has changed
    BOOL              m_fDirty;

    // m_fDeletePending is a boolean that, when TRUE, indicates this adapter
    // is being removed from the adapter list (eventually)
    BOOL              m_fDeletePending;

    // If true, the zone list contents are considered valid
    BOOL              m_fZoneListValid;

    // If true, this adapter exposes ndiswanatlk
    BOOL              m_fRasAdapter;

    // m_dwCharacteristics contains the adapter's characteristic settings
    DWORD             m_dwCharacteristics;

    // m_strBindName is the BindName for the adapter
    tstring           m_strBindName;

    // m_strDisplayName is the display name of the adapter
    tstring           m_strDisplayName;

    // Default zone returned by stack
    tstring           m_strNetDefaultZone;

    // Router network state
    BOOL              m_fRouterOnNetwork;

    DWORD             m_dwNetworkUpper;          // existing network # returned by stack
    DWORD             m_dwNetworkLower;          // existing network # returned by stack
};

// Define a structure for reading/writing AppleTalk\Parameters values
typedef struct
{
    DWORD  dwEnableRouter;
    WCHAR* szDefaultPort;
    WCHAR* szDesiredZone;
} ATLK_PARAMS;

// Class:   CATLKEnv
//
// Purpose: Contains the "Known" enviroment state regarding AppleTalk Params/Settings
//
class CATLKEnv
{
private:
    CATLKEnv(CATlkObj *pmsc);

public:
    // Automatic two-phase constructor
    static HRESULT HrCreate(CATLKEnv **, CATlkObj *);
    ~CATLKEnv();

    HRESULT HrCopy(CATLKEnv **ppEnv);

    HRESULT HrReadAppleTalkInfo();
    HRESULT HrGetAppleTalkInfoFromNetwork(CAdapterInfo * pAI);
    HRESULT HrGetAdapterInfo();
    HRESULT HrGetOneAdaptersInfo(INetCfgComponent*, CAdapterInfo **);
    HRESULT HrAddAdapter(INetCfgComponent * pnccFound);

    void    SetDefaultPort(PCWSTR psz);
    PCWSTR  SzDefaultPort()             {return (NULL != m_Params.szDefaultPort ?
                                                 m_Params.szDefaultPort :
                                                 c_szEmpty);}

    void    SetDesiredZone(PCWSTR psz);
    PCWSTR  SzDesiredZone()             {return (NULL != m_Params.szDesiredZone ?
                                                 m_Params.szDesiredZone :
                                                 c_szEmpty);}

    DWORD   DwDefaultAdaptersMediaType()  {return m_dwDefaultAdaptersMediaType;}
    void    SetDefaultMediaType(DWORD dw) {m_dwDefaultAdaptersMediaType = dw;}

    void    EnableRouting(BOOL f)         {m_Params.dwEnableRouter = (f ? 1 : 0);}
    BOOL    FRoutingEnabled()             {return (1 == m_Params.dwEnableRouter);}

    ATLK_ADAPTER_INFO_LIST &AdapterInfoList() {return m_lstpAdapters;}

    BOOL    FIsAppleTalkRunning() {return m_fATrunning;}
    void    SetATLKRunning(BOOL fRunning) {m_fATrunning = fRunning;}

    HRESULT HrUpdateRegistry();
    HRESULT HrWriteOneAdapter(CAdapterInfo *pAI);
    DWORD   DwMediaPriority(DWORD dwMediaType);
    void    InitDefaultPort();

    BOOL    FRouterChanged() {return m_fRouterChanged;}
    VOID    SetRouterChanged(BOOL f) {m_fRouterChanged = f;}

    BOOL    FDefAdapterChanged() {return m_fDefAdapterChanged;}
    VOID    SetDefAdapterChanged(BOOL f) {m_fDefAdapterChanged = f;}

    CAdapterInfo * PAIFindDefaultPort();

    ATLK_ADAPTER_INFO_LIST m_lstpAdapters;

private:
    CATlkObj *             m_pmsc;
    BOOL                   m_fRouterChanged;
    BOOL                   m_fDefAdapterChanged;
    BOOL                   m_fATrunning;
    DWORD                  m_dwDefaultAdaptersMediaType;
    ATLK_PARAMS            m_Params;
};

// Class:   CATLKGeneralDlg
//
// Purpose: Manage the "General" property page
//
class CATLKGeneralDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CATLKGeneralDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        COMMAND_ID_HANDLER(CHK_GENERAL_DEFAULT, HandleChkBox)
    END_MSG_MAP()

    CATLKGeneralDlg(CATlkObj *pmsc, CATLKEnv * pATLKEnv);
    ~CATLKGeneralDlg();

    LRESULT HandleChkBox(WORD wNotifyCode, WORD wID,
                         HWND hWndCtl, BOOL& bHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(INT idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    BOOL           FAddZoneListToControl(list<tstring*> * plstpstr);
    VOID           RefreshZoneCombo();

private:
    CATlkObj *      m_pmsc;
    CATLKEnv *      m_pATLKEnv;
};


/////////////////////////////////////////////////////////////////////////////
// CATlkObj

class ATL_NO_VTABLE CATlkObj :
    public CComObjectRoot,
    public CComCoClass<CATlkObj, &CLSID_CATlkObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentPropertyUi,
    public INetCfgComponentNotifyBinding
{
public:
    CATlkObj();
    ~CATlkObj();

    BEGIN_COM_MAP(CATlkObj)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CATlkObj)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ATLKCFG)

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

    // INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFromBuildNo) {return S_OK;}
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

    // INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

    INetCfg          * PNetCfg() {return m_pNetCfg;}
    INetCfgComponent * PNCComponent() {return m_pNCC;}
    HRESULT HrCommitInstall();
    HRESULT HrCommitRemove();
    CATLKEnv * PATLKEnv() {return m_pATLKEnv;}

    VOID MarkAdapterListChanged() {m_fAdapterListChanged = TRUE;};

private:
    VOID CleanupPropPages();
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                PCWSTR pszAnswerSection);
    HRESULT HrReadAdapterAnswerFileSection(CSetupInfFile * pcsif,
                                           PCWSTR pszSection);
    HRESULT HrAtlkReconfig();

private:
    INetCfgComponent* m_pNCC;
    INetCfg*          m_pNetCfg;
    INSTALLACTION     m_eInstallAction;
    CPropSheetPage *  m_pspObj;
    CATLKEnv *        m_pATLKEnv;
    CATLKEnv *        m_pATLKEnv_PP;            // Used by prop pages only
    IUnknown *        m_pUnkPropContext;
    INT               m_nIdxAdapterSelected;    // Used by Prop Pages only
    BOOL              m_fAdapterListChanged;
    BOOL              m_fPropertyChange;
    BOOL              m_fFirstTimeInstall;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\arpsdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S D L G . C P P
//
//  Contents:   CArpsPage declaration
//
//  Notes:
//
//  Author:     tongl   2 Feb 1998
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "arpsobj.h"
#include "arpsdlg.h"
#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"
//#include "resource.h"
#include "atmcommon.h"

#include "atmhelp.h"

//
// CArpsPage
//

CArpsPage::CArpsPage(CArpsCfg * pArpscfg, const DWORD * adwHelpIDs)
{
    Assert(pArpscfg);
    m_pArpscfg = pArpscfg;
    m_adwHelpIDs = adwHelpIDs;

    m_pAdapterInfo = pArpscfg->GetSecondMemoryAdapterInfo();

    m_fEditState = FALSE;
    m_fModified = FALSE;
}

CArpsPage::~CArpsPage()
{
}

LRESULT CArpsPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    RECT rect;
    LV_COLUMN lvCol = {0};    // list view column structure

    // initialize registered atm address list view
    ::GetClientRect(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &rect);
    lvCol.mask = LVCF_FMT | LVCF_WIDTH;
    lvCol.fmt = LVCFMT_LEFT;
    lvCol.cx = rect.right;

    ListView_InsertColumn(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), 0, &lvCol);

    // initialize report view of multicast address list view
    int index, iNewItem;

    // Calculate column width
    ::GetClientRect(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &rect);
    int colWidth = (rect.right/c_nColumns);

    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column
    lvCol.cx = colWidth;       // width of column in pixels

    // Add the two columns and header text.
    for (index = 0; index < c_nColumns; index++)
    {
        // column header text
        if (0 == index) // first column
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_FROM);
        }
        else
        {
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_IPADDRESS_TO);
        }

        iNewItem = ListView_InsertColumn(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR),
                                         index, &lvCol);

        AssertSz((iNewItem == index), "Invalid item inserted to list view !");
    }

    m_hRegAddrs.m_hListView = GetDlgItem(IDC_LVW_ARPS_REG_ADDR);
    m_hRegAddrs.m_hAdd      = GetDlgItem(IDC_PSH_ARPS_REG_ADD);
    m_hRegAddrs.m_hEdit     = GetDlgItem(IDC_PSH_ARPS_REG_EDT);
    m_hRegAddrs.m_hRemove   = GetDlgItem(IDC_PSH_ARPS_REG_RMV);

    m_hMulAddrs.m_hListView = GetDlgItem(IDC_LVW_ARPS_MUL_ADDR);
    m_hMulAddrs.m_hAdd      = GetDlgItem(IDC_PSH_ARPS_MUL_ADD);
    m_hMulAddrs.m_hEdit     = GetDlgItem(IDC_PSH_ARPS_MUL_EDT);
    m_hMulAddrs.m_hRemove   = GetDlgItem(IDC_PSH_ARPS_MUL_RMV);

    // do this last
    SetRegisteredAtmAddrInfo();
    SetMulticastIpAddrInfo();

    return 0;
}

LRESULT CArpsPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CArpsPage::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CArpsPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CArpsPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE;

    // Update the in memory with what's in the UI
    UpdateInfo();

    // Check duplicate ATM address
    int iDupRegAddr = CheckDupRegAddr();

    if (iDupRegAddr >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_DUPLICATE_REG_ADDR,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ListView_SetItemState(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), iDupRegAddr,
                              LVIS_SELECTED, LVIS_SELECTED);
        err = TRUE;
    }

    // Check overlapped IP address range
    if (!err)
    {
        int iOverlappedIpRange = CheckOverlappedIpRange();
        if (iOverlappedIpRange >=0)
        {
            NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_OVERLAP_MUL_ADDR,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ListView_SetItemState(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), iOverlappedIpRange,
                                  LVIS_SELECTED, LVIS_SELECTED);

            err = TRUE;
        }
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CArpsPage::OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    NM_LISTVIEW *   pnmlv = reinterpret_cast<NM_LISTVIEW *>(pnmh);
    Assert(pnmlv);

    // Reset the buttons based on the changed selection
    if (idCtrl == IDC_LVW_ARPS_REG_ADDR)
    {
        SetButtons(m_hRegAddrs);
    }
    else if (idCtrl == IDC_LVW_ARPS_MUL_ADDR)
    {
        SetButtons(m_hMulAddrs);
    }

    return 0;
}

int CArpsPage::CheckDupRegAddr()
{
    int ret = -1;
    int idx = 0;

    for(VECSTR::iterator iterAtmAddr = m_pAdapterInfo->m_vstrRegisteredAtmAddrs.begin();
        iterAtmAddr != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end();
        iterAtmAddr ++)
    {
        VECSTR::iterator iterAtmAddrComp = iterAtmAddr;

        iterAtmAddrComp ++;
        while (iterAtmAddrComp != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end())
        {
            if (**iterAtmAddr == **iterAtmAddrComp)
            {
                // we find a duplicate address
                ret = idx;
                break;
            }

            iterAtmAddrComp++;
        }

        // duplicate address found
        if (ret >=0 )
        {
            break;
        }

        // move next
        idx ++;
    }

    return ret;
}

int CArpsPage::CheckOverlappedIpRange()
{
    int ret = -1;
    int idx = 0;

    for(VECSTR::iterator iterIpRange = m_pAdapterInfo->m_vstrMulticastIpAddrs.begin();
        iterIpRange != m_pAdapterInfo->m_vstrMulticastIpAddrs.end();
        iterIpRange ++)
    {
        tstring strUpperIp;
        GetUpperIp( **iterIpRange, &strUpperIp);

        VECSTR::iterator iterIpRangeComp = iterIpRange;

        iterIpRangeComp ++;
        while (iterIpRangeComp != m_pAdapterInfo->m_vstrMulticastIpAddrs.end())
        {
            tstring strLowerIpComp;
            GetLowerIp( **iterIpRangeComp, &strLowerIpComp);

            if (strUpperIp >= strLowerIpComp)
            {
                // we find an overlapped range
                ret = idx;
                break;
            }

            iterIpRangeComp++;
        }

        // duplicate address found
        if (ret >=0 )
        {
            break;
        }

        // move next
        idx ++;
    }
    return ret;
}

LRESULT CArpsPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_pArpscfg->SetSecondMemoryModified();

    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CArpsPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CArpsPage::OnAddRegisteredAddr(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CAtmAddrDlg * pDlgAddr = new CAtmAddrDlg(this, g_aHelpIDs_IDD_ARPS_REG_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgAddr->m_strNewAtmAddr = m_strRemovedAtmAddr;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));

        // insert the new item at the end of list
        LV_ITEM lvItem;

        lvItem.mask = LVIF_TEXT;
        lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
        lvItem.state = 0;

        lvItem.iItem=nCount;
        lvItem.iSubItem=0;
        lvItem.pszText= (PWSTR)(m_strRemovedAtmAddr.c_str());

        int ret = ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        // empty strings, this removes the saved address from RemoveAtmAddr
        m_strRemovedAtmAddr = c_szEmpty;

        SetButtons(m_hRegAddrs);
        PageModified();
    }

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnEditRegisteredAddr(WORD wNotifyCode, WORD wID,
                                        HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    CAtmAddrDlg * pDlgAddr = new CAtmAddrDlg(this, g_aHelpIDs_IDD_ARPS_REG_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // get the user selection
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR),
                                            -1, LVNI_SELECTED);
    if (itemSelected != -1)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        // save off the removed address
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        pDlgAddr->m_strNewAtmAddr = buf;

        // See if the address is edited & address changed
        if ((pDlgAddr->DoModal() == IDOK) && (m_strRemovedAtmAddr != buf))
        {
            // delete the old address
            ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), itemSelected);

            // replace the item with the new address
            lvItem.mask = LVIF_TEXT | LVIF_PARAM;
            lvItem.lParam =0;
            lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
            lvItem.state = 0;

            lvItem.iItem=itemSelected;
            lvItem.iSubItem=0;
            lvItem.pszText= (PWSTR)(m_strRemovedAtmAddr.c_str());

            ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

            PageModified();
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT, IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this registered address
    m_strRemovedAtmAddr = c_szEmpty;

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnRemoveRegisteredAddr(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR buf[MAX_ATM_ADDRESS_LENGTH+1];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = buf;
        lvItem.cchTextMax = celems(buf);

        // save off the removed address and delete it from the listview
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        m_strRemovedAtmAddr = buf;
        ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), itemSelected);

        SetButtons(m_hRegAddrs);

        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

LRESULT CArpsPage::OnAddMulticastAddr(WORD wNotifyCode, WORD wID,
                                      HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = FALSE;

    CIpAddrRangeDlg * pDlgAddr = new CIpAddrRangeDlg(this, g_aHelpIDs_IDD_ARPS_MUL_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgAddr->m_strNewIpRange = m_strRemovedIpRange;

    // See if the address is added
    if (pDlgAddr->DoModal() == IDOK)
    {
        LvInsertIpRangeInOrder(pDlgAddr->m_strNewIpRange);

        // empty strings, this removes the saved address from RemoveIP
        pDlgAddr->m_strNewIpRange = c_szEmpty;

        SetButtons(m_hMulAddrs);
        PageModified();
    }
    m_strRemovedIpRange = pDlgAddr->m_strNewIpRange;

    delete pDlgAddr;
    return 0;
}

LRESULT CArpsPage::OnEditMulticastAddr(WORD wNotifyCode, WORD wID,
                                       HWND hWndCtl, BOOL& fHandled)
{
    m_fEditState = TRUE;

    CIpAddrRangeDlg * pDlgAddr = new CIpAddrRangeDlg(this, g_aHelpIDs_IDD_ARPS_MUL_ADDR);

	if (pDlgAddr == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // get the user selection
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR),
                                            -1, LVNI_SELECTED);
    if (itemSelected != -1)
    {
        WCHAR szBuf[IPRANGE_LIMIT];

        // save off the removed address and delete it from the listview
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // lower ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        pDlgAddr->m_strNewIpRange = szBuf;
        pDlgAddr->m_strNewIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        pDlgAddr->m_strNewIpRange += szBuf;

        // See if the address is edited & address changed
        if ((pDlgAddr->DoModal() == IDOK) && (pDlgAddr->m_strNewIpRange != szBuf))
        {
            // delete the old address
            ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), itemSelected);

            // insert new one
            LvInsertIpRangeInOrder(pDlgAddr->m_strNewIpRange);

            // empty strings, this removes the saved address from RemoveIP
            pDlgAddr->m_strNewIpRange = c_szEmpty;

            PageModified();
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    // don't save this IP range
    m_strRemovedIpRange = c_szEmpty;

    delete pDlgAddr;
    return 0;
}

void CArpsPage::LvInsertIpRangeInOrder(tstring& strNewIpRange)
{
    tstring strLowerIp;
    GetLowerIp(strNewIpRange, &strLowerIp);

    int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));

    // find the index to insert the new item
    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    WCHAR buf[IPRANGE_LIMIT];
    lvItem.pszText = buf;
    lvItem.cchTextMax = celems(buf);

    for (int iItem =0; iItem <nCount; iItem++)
    {
        lvItem.iItem = iItem;
        lvItem.iSubItem = 0;
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        Assert(buf);

        if (strLowerIp < buf)
        {
            break;
        }
    }

    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    // lower IP address
    lvItem.iItem=iItem;
    lvItem.iSubItem=0;
    lvItem.pszText= (PWSTR)(strLowerIp.c_str());
    SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_INSERTITEM, 0, (LPARAM)&lvItem);

    // upper IP address
    tstring strUpperIp;
    GetUpperIp(strNewIpRange, &strUpperIp);

    lvItem.iItem=iItem;
    lvItem.iSubItem=1;
    lvItem.pszText= (PWSTR)(strUpperIp.c_str());
    SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_SETITEMTEXT, iItem, (LPARAM)&lvItem);
}

LRESULT CArpsPage::OnRemoveMulticastAddr(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    // get the current selected item and remove it
    int itemSelected = ListView_GetNextItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), -1,
                                            LVNI_SELECTED);

    if (itemSelected != -1)
    {
        WCHAR szBuf[IPRANGE_LIMIT];

        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);

        // save off the removed address
        // lower ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 0;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        m_strRemovedIpRange = szBuf;
        m_strRemovedIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = itemSelected;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        m_strRemovedIpRange += szBuf;

        // delete it from the list view
        ListView_DeleteItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), itemSelected);

        SetButtons(m_hMulAddrs);

        PageModified();
    }
    else
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_ARPS_TEXT,
                 IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }

    return 0;
}

void CArpsPage::SetRegisteredAtmAddrInfo()
{
    BOOL ret = ListView_DeleteAllItems(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    int iItem =0;

    for (VECSTR::iterator iterAtmAddr = m_pAdapterInfo->m_vstrRegisteredAtmAddrs.begin();
         iterAtmAddr != m_pAdapterInfo->m_vstrRegisteredAtmAddrs.end();
         iterAtmAddr ++)
    {
        if ((**iterAtmAddr) == c_szEmpty)
        {
            continue;
        }

        lvItem.iItem=iItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)((*iterAtmAddr)->c_str());
        lvItem.cchTextMax = celems((*iterAtmAddr)->c_str());

        int ret = ListView_InsertItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        iItem++;
    }

    // now set the button states
    SetButtons(m_hRegAddrs);
}

void CArpsPage::SetMulticastIpAddrInfo()
{
    BOOL ret = ListView_DeleteAllItems(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));
    Assert(ret);

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;
    lvItem.lParam =0;
    lvItem.stateMask = LVIS_FOCUSED | LVIS_SELECTED;
    lvItem.state = 0;

    int iItem =0;
    tstring strIpLower;
    tstring strIpUpper;

    for (VECSTR::iterator iterIpAddrRange = m_pAdapterInfo->m_vstrMulticastIpAddrs.begin();
         iterIpAddrRange != m_pAdapterInfo->m_vstrMulticastIpAddrs.end();
         iterIpAddrRange ++)
    {
        if ((**iterIpAddrRange) == c_szEmpty)
        {
            continue;
        }

        GetLowerIp((**iterIpAddrRange), &strIpLower);
        GetUpperIp((**iterIpAddrRange), &strIpUpper);

        // Add the lower IP address
        lvItem.iItem=iItem;
        lvItem.iSubItem=0;
        lvItem.pszText=(PWSTR)(strIpLower.c_str());

        SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_INSERTITEM, iItem, (LPARAM)&lvItem);

        // Add the upper IP address
        lvItem.iItem=iItem;
        lvItem.iSubItem=1;
        lvItem.pszText=(PWSTR)(strIpUpper.c_str());

        // sub-item can not be inserted by ListView_InsertItem
        SendDlgItemMessage(IDC_LVW_ARPS_MUL_ADDR, LVM_SETITEMTEXT, iItem, (LPARAM)&lvItem);

        iItem++;
    }
    SetButtons(m_hMulAddrs);
}

void CArpsPage::SetButtons(HandleGroup& handles)
{
    INT iSelected = ListView_GetNextItem(handles.m_hListView, -1, LVNI_SELECTED);
    if (iSelected == -1) // Nothing selected or list empty
    {
        ::EnableWindow(handles.m_hEdit,   FALSE);
        ::EnableWindow(handles.m_hRemove, FALSE);

        ::SetFocus(handles.m_hListView);
    }
    else
    {
        ::EnableWindow(handles.m_hEdit,   TRUE);
        ::EnableWindow(handles.m_hRemove, TRUE);
    }
}

void CArpsPage::UpdateInfo()
{
    int i;

    // Update Registered ATM address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrRegisteredAtmAddrs);

    int nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_REG_ADDR));
    WCHAR szAtmAddr[MAX_ATM_ADDRESS_LENGTH+1];

    LV_ITEM lvItem;
    lvItem.mask = LVIF_TEXT;

    for (i=0; i< nCount; i++)
    {
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.pszText = szAtmAddr;
        lvItem.cchTextMax = celems(szAtmAddr);

        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_REG_ADDR), &lvItem);

        m_pAdapterInfo->m_vstrRegisteredAtmAddrs.push_back(new tstring(szAtmAddr));
    }

    // Update Multicast IP address
    FreeCollectionAndItem(m_pAdapterInfo->m_vstrMulticastIpAddrs);

    nCount = ListView_GetItemCount(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR));
    WCHAR szBuf[IPRANGE_LIMIT];
    tstring strIpRange;

    for (i=0; i< nCount; i++)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_TEXT;

        // lower ip
        lvItem.iItem = i;
        lvItem.iSubItem = 0;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        strIpRange = szBuf;
        strIpRange += c_chSeparator;

        // upper ip
        lvItem.iItem = i;
        lvItem.iSubItem = 1;
        lvItem.pszText = szBuf;
        lvItem.cchTextMax = celems(szBuf);
        ListView_GetItem(GetDlgItem(IDC_LVW_ARPS_MUL_ADDR), &lvItem);

        strIpRange += szBuf;

        m_pAdapterInfo->m_vstrMulticastIpAddrs.push_back(new tstring(strIpRange.c_str()));
    }
}

//
// CAtmAddrDlg
//

CAtmAddrDlg::CAtmAddrDlg(CArpsPage * pAtmArpsPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg = pAtmArpsPage;
    m_adwHelpIDs = adwHelpIDs;

    m_hOkButton = 0;
}

LRESULT CAtmAddrDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& fHandled)
{
    // change the "Ok" button to "Add" if we are not editing
    if (FALSE == m_pParentDlg->m_fEditState)
    {
        SetDlgItemText(IDOK, L"Add");
    }

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    RECT rect;

    HWND hwndList = m_pParentDlg->m_hRegAddrs.m_hListView;
    Assert(hwndList);
    ::GetWindowRect(hwndList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);
    m_hEditBox  =  GetDlgItem(IDC_EDT_ARPS_REG_Address);

    // ATM addresses have a 40 character limit + separaters
    ::SendMessage(m_hEditBox, EM_SETLIMITTEXT,
        MAX_ATM_ADDRESS_LENGTH + (MAX_ATM_ADDRESS_LENGTH / 2), 0);

    // add the address that was just removed
    if (m_strNewAtmAddr.size())
    {
        ::SetWindowText(m_hEditBox, m_strNewAtmAddr.c_str());
        ::SendMessage(m_hEditBox, EM_SETSEL, 0, -1);
        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        ::EnableWindow(m_hOkButton, FALSE);
    }

    ::SetFocus(m_hEditBox);
    return 0;
}

LRESULT CAtmAddrDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CAtmAddrDlg::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CAtmAddrDlg::OnOk(WORD wNotifyCode, WORD wID,
                          HWND hWndCtl, BOOL& fHandled)
{
    WCHAR szAtmAddress[MAX_ATM_ADDRESS_LENGTH+1];

    // Get the current address from the control and
    // add them to the adapter if valid
    ::GetWindowText(m_hEditBox, szAtmAddress, MAX_ATM_ADDRESS_LENGTH+1);

    int i, nId;

    if (! FIsValidAtmAddress(szAtmAddress, &i, &nId))
    {   // If invalid ATM address, we pop up a message box and set focus
        // back to the edit box

        // REVIEW(tongl): report first invalid character in mesg box
        NcMsgBox(m_hWnd, IDS_MSFT_ARPS_TEXT, IDS_INVALID_ATM_ADDRESS,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_ARPS_REG_Address));
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // Add new address
    {
        m_pParentDlg->m_strRemovedAtmAddr = szAtmAddress;
    }
    else // if edit, see if string is having a diferent value now
    {
        if (m_pParentDlg->m_strRemovedAtmAddr != szAtmAddress)
        {
            m_pParentDlg->m_strRemovedAtmAddr = szAtmAddress; // update save addresses
        }
        else
        {
            EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CAtmAddrDlg::OnCancel(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CAtmAddrDlg::OnChange(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    WCHAR buf[2];

    // Enable or disable the "Ok" button
    // based on whether the edit box is empty

    if (::GetWindowText(m_hEditBox, buf, celems(buf)) == 0)
    {
        ::EnableWindow(m_hOkButton, FALSE);
    }
    else
    {
        ::EnableWindow(m_hOkButton, TRUE);
    }

    return 0;
}

//
//  CIpAddrRangeDlg
//
CIpAddrRangeDlg::CIpAddrRangeDlg( CArpsPage * pAtmArpsPage, const DWORD* adwHelpIDs)
{
    m_pParentDlg = pAtmArpsPage;
    m_hOkButton = 0;

    m_adwHelpIDs = adwHelpIDs;
}

LRESULT CIpAddrRangeDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    // change the ok button to add if we are not editing
    if (FALSE == m_pParentDlg->m_fEditState)
    {
        SetDlgItemText(IDOK, L"Add");
    }

    // Set the position of the pop up dialog to be right over the listbox
    // on parent dialog
    RECT rect;

    HWND hwndList = m_pParentDlg->m_hMulAddrs.m_hListView;
    Assert(hwndList);
    ::GetWindowRect(hwndList, &rect);
    SetWindowPos(NULL,  rect.left, rect.top, 0,0,
                                SWP_NOZORDER|SWP_NOSIZE|SWP_NOACTIVATE);

    // Save handles to the "Ok" button and the edit box
    m_hOkButton =  GetDlgItem(IDOK);

    // create ip controls
    m_ipLower.Create(m_hWnd,IDC_ARPS_MUL_LOWER_IP);
    m_ipUpper.Create(m_hWnd,IDC_ARPS_MUL_UPPER_IP);

    // add the address that was just removed
    if (m_strNewIpRange.size())
    {
        GetLowerIp(m_strNewIpRange, &m_strNewIpLower);
        GetUpperIp(m_strNewIpRange, &m_strNewIpUpper);

        Assert(m_strNewIpLower.size()>0);
        Assert(m_strNewIpUpper.size()>0);

        m_ipLower.SetAddress(m_strNewIpLower.c_str());
        m_ipUpper.SetAddress(m_strNewIpUpper.c_str());

        ::EnableWindow(m_hOkButton, TRUE);
    }
    else
    {
        m_strNewIpLower = c_szEmpty;
        m_strNewIpUpper = c_szEmpty;

        // the ip and subnet are blank, so there's nothing to save
        ::EnableWindow(m_hOkButton, FALSE);
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnContextMenu(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnHelp(UINT uMsg, WPARAM wParam,
                                       LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnOk(WORD wNotifyCode, WORD wID,
                              HWND hWndCtl, BOOL& fHandled)
{
    tstring strIpLower;
    tstring strIpUpper;

    // Get the current address from the control and add them to the adapter if valid
    m_ipLower.GetAddress(&strIpLower);
    m_ipUpper.GetAddress(&strIpUpper);

    if (!IsValidIpRange(strIpLower, strIpUpper))
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_ARPS_TEXT,
                 IDS_INCORRECT_IPRANGE,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        ::SetFocus(m_ipLower);
        return 0;
    }

    if (m_pParentDlg->m_fEditState == FALSE) // when adding a new range
    {
        // Get the current address from the control and add them to the adapter if valid
        MakeIpRange(strIpLower, strIpUpper, &m_strNewIpRange);
        EndDialog(IDOK);
    }
    else // if editing an existing range
    {
        if ((strIpLower != m_strNewIpLower)||(strIpUpper != m_strNewIpUpper))
        {
            MakeIpRange(strIpLower, strIpUpper, &m_strNewIpRange);
            EndDialog(IDOK);
        }
        else
        {
            // no change
            EndDialog(IDCANCEL);
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnCancel(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CIpAddrRangeDlg::OnChangeLowerIp(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        if (m_ipLower.IsBlank() || m_ipUpper.IsBlank())
        {
            ::EnableWindow(m_hOkButton, FALSE);
        }
        else
        {
            ::EnableWindow(m_hOkButton, TRUE);
        }

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnChangeUpperIp(WORD wNotifyCode, WORD wID,
                                         HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
    case EN_CHANGE:
        if (m_ipLower.IsBlank() || m_ipUpper.IsBlank())
        {
            ::EnableWindow(m_hOkButton, FALSE);
        }
        else
        {
            ::EnableWindow(m_hOkButton, TRUE);
        }

        break;

    default:
        break;
    }

    return 0;
}

LRESULT CIpAddrRangeDlg::OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\advdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      A D V D L G . C P P
//
//  Contents:  PVC advanced property pages message handler implementation
//
//  Notes:
//
//  Author:     tongl   1 Mar, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
//#include "atmcommon.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"

const int MAX_FIELD_LENGTH = 3;

const DWORD c_dwUserSpecProtocol = 16;
const WCHAR c_szUserSpecProtocol[] = L"16";

const DWORD c_dwUserSpecHighLayer = 1;
const WCHAR c_szUserSpecHighLayer[] = L"1";

const DWORD c_dwFieldHigh = 255;
const DWORD c_dwFieldLow  = 0;

enum Location
{
    LOCAL,
    DEST
};

void InitBroadbandInfo(HWND hDlg);

void SetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location);
void SetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD dwProtocol, DWORD dwUserSpecValue);
void SetHighLayerInfo(HWND hDlg, DWORD dwHighLayerInfoType,
                      tstring & strHighLayerInfo);

void GetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location);
void GetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD * pdwProtocol, DWORD * pdwUserSpecValue);
void GetHighLayerInfo(HWND hDlg, DWORD * pdwHighLayerInfoType,
                      tstring * pstrHighLayerInfo);

void OnLayer2EdtChange(HWND hDlg);
void OnLayer2SelChange(HWND hDlg);

void OnLayer3EdtChange(HWND hDlg);
void OnLayer3SelChange(HWND hDlg);

void OnHighLayerEdtChange(HWND hDlg);
void OnHighLayerSelChange(HWND hDlg);

void GetNumFromString(PWSTR pszBuf, DWORD * dwNum);

BOOL InvalidBroadbandInfo(HWND hDlg);
BOOL IsValidCmbSelection(HWND hDlg, int nIDDlgItemCombo);
BOOL IsValidDwordField(HWND hDlg, int nIDDlgItemEdit);
BOOL IsValidBinaryField(HWND hDlg, int nIDDlgItemEdit, int nMaxBytes);

//
// CPvcLocalPage
//

// Constructors/Destructors
CPvcLocalPage::CPvcLocalPage(CPVCMainDialog * pParentDlg,
                             CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs)
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcLocalPage::~CPvcLocalPage()
{
}

// Command handlers
LRESULT CPvcLocalPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Add strings to the combo boxes
    InitBroadbandInfo(m_hWnd);

    // Now set the value based on what's in our data structure
    SetBroadbandInfo(m_hWnd, m_pPvcInfo, LOCAL);

    return 0;
}

LRESULT CPvcLocalPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcLocalPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcLocalPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_pParentDlg->m_fPropShtOk = TRUE;

    GetBroadbandInfo(m_hWnd, m_pPvcInfo, LOCAL);

    // did any field change ?
    if ((m_pPvcInfo->m_dwLocalLayer2Protocol    != m_pPvcInfo->m_dwOldLocalLayer2Protocol) ||
        (m_pPvcInfo->m_dwLocalUserSpecLayer2    != m_pPvcInfo->m_dwOldLocalUserSpecLayer2) ||
        (m_pPvcInfo->m_dwLocalLayer3Protocol    != m_pPvcInfo->m_dwOldLocalLayer3Protocol) ||
        (m_pPvcInfo->m_dwLocalUserSpecLayer3    != m_pPvcInfo->m_dwOldLocalUserSpecLayer3) ||
        (m_pPvcInfo->m_dwLocalLayer3IPI         != m_pPvcInfo->m_dwOldLocalLayer3IPI) ||
        (m_pPvcInfo->m_strLocalSnapId           != m_pPvcInfo->m_strOldLocalSnapId) ||
        (m_pPvcInfo->m_dwLocalHighLayerInfoType != m_pPvcInfo->m_dwOldLocalHighLayerInfoType) ||
        (m_pPvcInfo->m_strLocalHighLayerInfo    != m_pPvcInfo->m_strOldLocalHighLayerInfo)
       )
    {
       m_pParentDlg->m_fPropShtModified = TRUE;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // check that all values are valid
    BOOL err = InvalidBroadbandInfo(m_hWnd);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcLocalPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcLocalPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcLocalPage::OnLayer2(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer2EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer2SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnLayer3(WORD wNotifyCode, WORD wID,
                                HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer3EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer3SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcLocalPage::OnHighLayer(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnHighLayerEdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnHighLayerSelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

//
// CPvcDestPage
//

// Constructors/Destructors
CPvcDestPage::CPvcDestPage(CPVCMainDialog * pParentDlg,
                           CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs)
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcDestPage::~CPvcDestPage()
{
}

// Command handlers
LRESULT CPvcDestPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    // Add strings to the combo boxes
    InitBroadbandInfo(m_hWnd);

    // Now set the value based on what's in our data structure
    SetBroadbandInfo(m_hWnd, m_pPvcInfo, DEST);

    return 0;
}

LRESULT CPvcDestPage::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcDestPage::OnHelp(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcDestPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    m_pParentDlg->m_fPropShtOk = TRUE;

    GetBroadbandInfo(m_hWnd, m_pPvcInfo, DEST);

    // did any field change ?
    if ((m_pPvcInfo->m_dwDestnLayer2Protocol    != m_pPvcInfo->m_dwOldDestnLayer2Protocol) ||
        (m_pPvcInfo->m_dwDestnUserSpecLayer2    != m_pPvcInfo->m_dwOldDestnUserSpecLayer2) ||
        (m_pPvcInfo->m_dwDestnLayer3Protocol    != m_pPvcInfo->m_dwOldDestnLayer3Protocol) ||
        (m_pPvcInfo->m_dwDestnUserSpecLayer3    != m_pPvcInfo->m_dwOldDestnUserSpecLayer3) ||
        (m_pPvcInfo->m_dwDestnLayer3IPI         != m_pPvcInfo->m_dwOldDestnLayer3IPI) ||
        (m_pPvcInfo->m_strDestnSnapId           != m_pPvcInfo->m_strOldDestnSnapId) ||
        (m_pPvcInfo->m_dwDestnHighLayerInfoType != m_pPvcInfo->m_dwOldDestnHighLayerInfoType) ||
        (m_pPvcInfo->m_strDestnHighLayerInfo    != m_pPvcInfo->m_strOldDestnHighLayerInfo)
       )
    {
       m_pParentDlg->m_fPropShtModified = TRUE;
    }

    return 0;
}

LRESULT CPvcDestPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    // check that all values are valid
    BOOL err = InvalidBroadbandInfo(m_hWnd);

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcDestPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcDestPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

// Control notification handlers
LRESULT CPvcDestPage::OnLayer2(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer2EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer2SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcDestPage::OnLayer3(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnLayer3EdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnLayer3SelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}

LRESULT CPvcDestPage::OnHighLayer(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& fHandled)
{
    switch(wNotifyCode)
    {
        case CBN_EDITCHANGE:
            OnHighLayerEdtChange(m_hWnd);
            break;

        case CBN_SELCHANGE:
            OnHighLayerSelChange(m_hWnd);
            break;

        default:
            break;
    }

    return 0;
}



//+---------------------------------------------------------------------------
//
//  Member:     AtmEditSubclassProc
//
//  Purpose:    Subclass proc for hex number edit controls.  The
//              subclassing forces only correct input
//
//  Author:     [from scottbri 28-Apr-1997]
//
STDAPI AtmEditSubclassProc( HWND hwnd, UINT wMsg, WPARAM wParam, LPARAM lParam )
{
    WNDPROC pAtmEditProc = (WNDPROC)GetWindowLongPtr(hwnd, GWLP_USERDATA);

    if ((wMsg == WM_CHAR) &&
        !(((WCHAR)wParam >= L'0' && (WCHAR)wParam <= L'9') ||
          ((WCHAR)wParam >= L'a' && (WCHAR)wParam <= L'f') ||
          ((WCHAR)wParam >= L'A' && (WCHAR)wParam <= L'F') ||
          ((WCHAR)wParam == VK_BACK)))
    {
        MessageBeep(MB_ICONEXCLAMATION);
        return 0L;
    }

    return (HRESULT)CallWindowProc( pAtmEditProc, hwnd, wMsg, wParam, lParam );
}

//
// Common utility functions shared by both local and destination dialogs
//
void InitBroadbandInfo(HWND hDlg)
{
    HWND hwndTmp;

    // layer2 protocol: IDC_CMB_PVC_Layer2
    static const int nrgLayer2Ids[] = { IDS_PVC_Any,
                                        IDS_PVC_Absent,
                                        IDS_PVC_Layer2_1,
                                        IDS_PVC_Layer2_2,
                                        IDS_PVC_Layer2_6,
                                        IDS_PVC_Layer2_7,
                                        IDS_PVC_Layer2_8,
                                        IDS_PVC_Layer2_9,
                                        IDS_PVC_Layer2_10,
                                        IDS_PVC_Layer2_11,
                                        IDS_PVC_Layer2_12,
                                        IDS_PVC_Layer2_13,
                                        IDS_PVC_Layer2_14,
                                        IDS_PVC_Layer2_16,
                                        IDS_PVC_Layer2_17 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_Layer2, celems(nrgLayer2Ids), nrgLayer2Ids);

    // layer3 protocol: IDC_CMB_PVC_Layer3
    static const int nrgLayer3Ids[] = { IDS_PVC_Any,
                                        IDS_PVC_Absent,
                                        IDS_PVC_Layer3_6,
                                        IDS_PVC_Layer3_7,
                                        IDS_PVC_Layer3_8,
                                        IDS_PVC_Layer3_9,
                                        IDS_PVC_Layer3_10,
                                        IDS_PVC_Layer3_11,
                                        IDS_PVC_Layer3_16 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_Layer3, celems(nrgLayer3Ids), nrgLayer3Ids);

    // high layer type: IDC_CMB_PVC_High_Type
    static const int nrgHighLayerIds[] = {  IDS_PVC_Any,
                                            IDS_PVC_Absent,
                                            IDS_PVC_HighLayer_0,
                                            IDS_PVC_HighLayer_1,
                                            IDS_PVC_HighLayer_3 };

    InitComboWithStringArray(hDlg, IDC_CMB_PVC_High_Type,
                             celems(nrgHighLayerIds), nrgHighLayerIds);

    // set length limits for edit boxes
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_User_Layer2, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_User_Layer3, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);
    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_Layer3_IPI, EM_SETLIMITTEXT, MAX_FIELD_LENGTH, 0);

    hwndTmp = GetDlgItem(hDlg, IDC_EDT_PVC_SNAP_ID);

    // Subclass the edit control to allow only hex digits
    ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp, GWLP_WNDPROC));
    ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

    ::SendDlgItemMessage(hDlg, IDC_EDT_PVC_SNAP_ID, EM_SETLIMITTEXT, c_nSnapIdMaxBytes*2, 0);
    ::SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Value, EM_SETLIMITTEXT, c_nHighLayerInfoMaxBytes*2, 0);
}

void SetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location)
{
    // layer2 protocol and user specified value
    DWORD dwLayer2Protocol;
    DWORD dwUserSpecLayer2;

    if (location == LOCAL)
    {
        dwLayer2Protocol = pPvcInfo->m_dwLocalLayer2Protocol;
        dwUserSpecLayer2 = pPvcInfo->m_dwLocalUserSpecLayer2;
    }
    else
    {
        dwLayer2Protocol = pPvcInfo->m_dwDestnLayer2Protocol;
        dwUserSpecLayer2 = pPvcInfo->m_dwDestnUserSpecLayer2;
    }

    SetProtocolInfo(hDlg, IDC_CMB_PVC_Layer2, IDC_EDT_PVC_User_Layer2,
                    dwLayer2Protocol, dwUserSpecLayer2);

    // layer3 protocol and user specified value
    DWORD dwLayer3Protocol;
    DWORD dwUserSpecLayer3;

    if (location == LOCAL)
    {
        dwLayer3Protocol = pPvcInfo->m_dwLocalLayer3Protocol;
        dwUserSpecLayer3 = pPvcInfo->m_dwLocalUserSpecLayer3;
    }
    else
    {
        dwLayer3Protocol = pPvcInfo->m_dwDestnLayer3Protocol;
        dwUserSpecLayer3 = pPvcInfo->m_dwDestnUserSpecLayer3;
    }

    SetProtocolInfo(hDlg, IDC_CMB_PVC_Layer3, IDC_EDT_PVC_User_Layer3,
                    dwLayer3Protocol, dwUserSpecLayer3);


    // Layer3 IPI
    DWORD dwLayer3IPI;
    if (location == LOCAL)
    {
        dwLayer3IPI = pPvcInfo->m_dwLocalLayer3IPI;
    }
    else
    {
        dwLayer3IPI = pPvcInfo->m_dwDestnLayer3IPI;
    }

    SetDwordEdtField(hDlg, dwLayer3IPI, IDC_EDT_PVC_Layer3_IPI);

    // Snap ID
    if (location == LOCAL)
    {
        SetDlgItemText(hDlg,IDC_EDT_PVC_SNAP_ID, pPvcInfo->m_strLocalSnapId.c_str());
    }
    else
    {
        SetDlgItemText(hDlg,IDC_EDT_PVC_SNAP_ID, pPvcInfo->m_strDestnSnapId.c_str());
    }

    // High layer
    DWORD    dwHighLayerInfoType;
    tstring  strHighLayerInfo;

    if (location == LOCAL)
    {
        dwHighLayerInfoType = pPvcInfo->m_dwLocalHighLayerInfoType;
        strHighLayerInfo = pPvcInfo->m_strLocalHighLayerInfo;
    }
    else
    {
        dwHighLayerInfoType = pPvcInfo->m_dwDestnHighLayerInfoType;
        strHighLayerInfo = pPvcInfo->m_strDestnHighLayerInfo;
    }

    SetHighLayerInfo(hDlg, dwHighLayerInfoType, strHighLayerInfo);
}

void SetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD dwProtocol, DWORD dwUserSpecValue)
{
    if ( FIELD_ANY == dwProtocol)
    {
        SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, (LPARAM)(0), 0);
    }
    else if ( FIELD_ABSENT == dwProtocol)
    {
        SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, (LPARAM)(1), 0);
    }
    else if (FIELD_UNSET != dwProtocol)
    {
        WCHAR szBuf[MAX_FIELD_LENGTH+1];
        wsprintfW(szBuf, c_szItoa, dwProtocol);

        tstring strBuf = szBuf;

        // attached the separator '-'
        strBuf+= c_chSeparator;

        // see if the value is one of the pre-defined protocol
        int nIdx = (int)SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRING, -1,
                                      (LPARAM)strBuf.c_str());

        if (CB_ERR == nIdx) // not one of the pre-defined protocols
        {
            SetDlgItemText(hDlg, nIDDlgItemCombo, szBuf);
        }
        else
        {
            SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_SETCURSEL, nIdx, 0L);
        }
    }

    if (dwProtocol == c_dwUserSpecProtocol)
    {
        SetDwordEdtField(hDlg, dwUserSpecValue, nIDDlgItemEdit);
    }
    else
    {
        ::EnableWindow(::GetDlgItem(hDlg,nIDDlgItemEdit), FALSE);
    }
}

void SetHighLayerInfo(HWND hDlg, DWORD dwHighLayerInfoType, tstring & strHighLayerInfo)
{
    if ( FIELD_ANY == dwHighLayerInfoType)
    {
        SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, (LPARAM)(0), 0);
    }
    else if ( FIELD_ABSENT == dwHighLayerInfoType)
    {
        SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, (LPARAM)(1), 0);
    }
    else if ( FIELD_UNSET != dwHighLayerInfoType)
    {
        WCHAR szBuf[MAX_FIELD_LENGTH+1];
        wsprintfW(szBuf, c_szItoa, dwHighLayerInfoType);

        tstring strBuf = szBuf;

        // attached the separator '-'
        strBuf+= c_chSeparator;

        // see if the value is one of the pre-defined protocol
        int nIdx = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_FINDSTRING, -1,
                                      (LPARAM)strBuf.c_str());

        if (CB_ERR == nIdx) // not one of the pre-defined protocols
        {
            SetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf);
        }
        else
        {
            SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_SETCURSEL, nIdx, 0L);
        }
    }

    if (dwHighLayerInfoType == c_dwUserSpecHighLayer)
    {
        HWND    hwndTmp;

        hwndTmp = GetDlgItem(hDlg, IDC_CMB_PVC_High_Value);

        // Subclass the edit control to allow only hex digits
        ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp,
                                        GWLP_WNDPROC));
        ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

        SetDlgItemText(hDlg, IDC_CMB_PVC_High_Value, strHighLayerInfo.c_str());
    }
    else
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
        ::EnableWindow(::GetDlgItem(hDlg,IDC_TXT_PVC_Value), FALSE);
    }
}

void GetBroadbandInfo(HWND hDlg, CPvcInfo * pPvcInfo, Location location)
{
    // layer2 protocol and user specified value
    DWORD * pdwLayer2Protocol;
    DWORD * pdwUserSpecLayer2;

    if (location == LOCAL)
    {
        pdwLayer2Protocol = &(pPvcInfo->m_dwLocalLayer2Protocol);
        pdwUserSpecLayer2 = &(pPvcInfo->m_dwLocalUserSpecLayer2);
    }
    else
    {
        pdwLayer2Protocol = &(pPvcInfo->m_dwDestnLayer2Protocol);
        pdwUserSpecLayer2 = &(pPvcInfo->m_dwDestnUserSpecLayer2);
    }

    GetProtocolInfo(hDlg, IDC_CMB_PVC_Layer2, IDC_EDT_PVC_User_Layer2,
                    pdwLayer2Protocol, pdwUserSpecLayer2);

    // layer3 protocol and user specified value
    DWORD * pdwLayer3Protocol;
    DWORD * pdwUserSpecLayer3;

    if (location == LOCAL)
    {
        pdwLayer3Protocol = &(pPvcInfo->m_dwLocalLayer3Protocol);
        pdwUserSpecLayer3 = &(pPvcInfo->m_dwLocalUserSpecLayer3);
    }
    else
    {
        pdwLayer3Protocol = &(pPvcInfo->m_dwDestnLayer3Protocol);
        pdwUserSpecLayer3 = &(pPvcInfo->m_dwDestnUserSpecLayer3);
    }

    GetProtocolInfo(hDlg, IDC_CMB_PVC_Layer3, IDC_EDT_PVC_User_Layer3,
                    pdwLayer3Protocol, pdwUserSpecLayer3);

    // Layer3 IPI
    DWORD * pdwLayer3IPI;
    if (location == LOCAL)
    {
        pdwLayer3IPI = &(pPvcInfo->m_dwLocalLayer3IPI);
    }
    else
    {
        pdwLayer3IPI = &(pPvcInfo->m_dwDestnLayer3IPI);
    }

    GetDwordEdtField(hDlg, pdwLayer3IPI, IDC_EDT_PVC_Layer3_IPI);

    // Snap ID
    WCHAR   szSnapId[MAX_PATH];
    GetDlgItemText(hDlg, IDC_EDT_PVC_SNAP_ID, szSnapId, celems(szSnapId));
    if (location == LOCAL)
    {
        pPvcInfo->m_strLocalSnapId = szSnapId;
    }
    else
    {
        pPvcInfo->m_strDestnSnapId = szSnapId;
    }

    // High layer
    DWORD * pdwHighLayerInfoType;
    tstring * pstrHighLayerInfo;

    if (location == LOCAL)
    {
        pdwHighLayerInfoType = &(pPvcInfo->m_dwLocalHighLayerInfoType);
        pstrHighLayerInfo = &(pPvcInfo->m_strLocalHighLayerInfo);
    }
    else
    {
        pdwHighLayerInfoType = &(pPvcInfo->m_dwDestnHighLayerInfoType);
        pstrHighLayerInfo = &(pPvcInfo->m_strDestnHighLayerInfo);
    }

    GetHighLayerInfo(hDlg, pdwHighLayerInfoType, pstrHighLayerInfo);
}

void GetProtocolInfo(HWND hDlg, int nIDDlgItemCombo, int nIDDlgItemEdit,
                     DWORD * pdwProtocol, DWORD * pdwUserSpecValue)
{
    WCHAR szBuf[MAX_PATH];

    int nlen = GetDlgItemText(hDlg, nIDDlgItemCombo, szBuf, MAX_PATH);
    if (nlen==0)
    {
        // empty protocol2 field
        *pdwProtocol = FIELD_UNSET;
        *pdwUserSpecValue = FIELD_UNSET;

    }
    else
    {
        int nIdx = (int)SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (0 == nIdx)
        {
            *pdwProtocol = FIELD_ANY;
            *pdwUserSpecValue = 0;
        }
        else if (1 == nIdx)
        {
            *pdwProtocol = FIELD_ABSENT;
            *pdwUserSpecValue = 0;
        }
        else
        {
            GetNumFromString(szBuf, pdwProtocol);

            *pdwUserSpecValue = 0;
            if (*pdwProtocol == c_dwUserSpecProtocol)
            {
                GetDwordEdtField(hDlg, pdwUserSpecValue, nIDDlgItemEdit);
            }
        }
    }
}

void GetHighLayerInfo(HWND hDlg, DWORD * pdwHighLayerInfoType, tstring * pstrHighLayerInfo)
{
    WCHAR szBuf[MAX_PATH];

    *pstrHighLayerInfo = c_szEmpty;

    int nlen = GetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf, MAX_PATH);
    if (nlen==0)
    {
        // empty field
        *pdwHighLayerInfoType = FIELD_UNSET;
    }
    else
    {
        int nIdx = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (0 == nIdx)
        {
            *pdwHighLayerInfoType = FIELD_ANY;
        }
        else if (1 == nIdx)
        {
            *pdwHighLayerInfoType = FIELD_ABSENT;
        }
        else
        {
            GetNumFromString(szBuf, pdwHighLayerInfoType);
            if (*pdwHighLayerInfoType == c_dwUserSpecHighLayer)
            {
                WCHAR   szHighLayerInfo[MAX_PATH];
                GetDlgItemText(hDlg, IDC_CMB_PVC_High_Value,
                               szHighLayerInfo, celems(szHighLayerInfo));

                *pstrHighLayerInfo = szHighLayerInfo;
            }
        }
    }
}

void OnLayer2EdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_Layer2, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecProtocol))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
        }
    }
}

void OnLayer2SelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer2, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer2, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecProtocol)
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer2), FALSE);
            }
        }
    }
}

void OnLayer3EdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_Layer3, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecProtocol))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
        }
    }
}

void OnLayer3SelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer3, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_Layer3, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecProtocol)
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3), FALSE);
            }
        }
    }
}

void OnHighLayerEdtChange(HWND hDlg)
{
    // get the current value in the control,
    // and see if we should enable or disable the edit box for user specified value
    WCHAR szBuf[MAX_PATH];
    GetDlgItemText(hDlg, IDC_CMB_PVC_High_Type, szBuf, MAX_PATH);

    if (!(*szBuf))
    {
        ::EnableWindow(::GetDlgItem(hDlg, IDC_CMB_PVC_High_Value), FALSE);
        ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
    }
    else
    {
        // the string has to be equal to the specific number
        if (0 == wcscmp(szBuf, c_szUserSpecHighLayer))
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), TRUE);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), TRUE);
        }
        else
        {
            ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
            ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
        }
    }
}

void OnHighLayerSelChange(HWND hDlg)
{
    // get the index of the new selection
    int idx = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        // get the string of the current selection
        WCHAR szBuf[MAX_PATH];
        int len = (int)SendDlgItemMessage(hDlg, IDC_CMB_PVC_High_Type, CB_GETLBTEXT,
                                     (LPARAM)(idx), (WPARAM)(PCWSTR)szBuf);

        if ((len != CB_ERR) && (len>0))
        {
            DWORD dwNum;
            GetNumFromString(szBuf, &dwNum);

            if (dwNum == c_dwUserSpecHighLayer)
            {
                HWND    hwndTmp;

                hwndTmp = GetDlgItem(hDlg, IDC_CMB_PVC_High_Value);

                // Subclass the edit control to allow only hex digits
                ::SetWindowLongPtr(hwndTmp, GWLP_USERDATA, ::GetWindowLongPtr(hwndTmp,
                                                GWLP_WNDPROC));
                ::SetWindowLongPtr(hwndTmp, GWLP_WNDPROC, (LONG_PTR)AtmEditSubclassProc);

                ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), TRUE);
                ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), TRUE);
            }
            else
            {
                ::EnableWindow(::GetDlgItem(hDlg,IDC_CMB_PVC_High_Value), FALSE);
                ::EnableWindow(::GetDlgItem(hDlg, IDC_TXT_PVC_Value), FALSE);
            }
        }
    }
}

void GetNumFromString(PWSTR pszBuf, DWORD * pdwNum)
{
    *pdwNum=0;

    WCHAR * pch;
    pch = pszBuf;

    while ((*pch >= L'0') && (*pch <= L'9'))
    {
        *pdwNum = (*pdwNum*10) + (*pch - L'0');
        pch++;
    }
}

BOOL InvalidBroadbandInfo(HWND hDlg)
{
    BOOL err = FALSE;

    // layer2 protocol & value
    if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_Layer2))
    {
        NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer2_Protocol,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        SetFocus(GetDlgItem(hDlg, IDC_CMB_PVC_Layer2));
        err = TRUE;
    }
    else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg, IDC_EDT_PVC_User_Layer2))))
    {
        if (!IsValidDwordField(hDlg, IDC_EDT_PVC_User_Layer2))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer2_UserSpec,
             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg, IDC_EDT_PVC_User_Layer2));
            err = TRUE;
        }
    }

    // layer3 protocol & value
    if (!err)
    {
        if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_Layer3))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_Protocol,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_Layer3));
            err = TRUE;
        }
        else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3))))
        {
            if (!IsValidDwordField(hDlg, IDC_EDT_PVC_User_Layer2))
            {
                NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_UserSpec,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                SetFocus(GetDlgItem(hDlg,IDC_EDT_PVC_User_Layer3));
                err = TRUE;
            }
        }
    }

    //Layer3 IPI
    if (!err)
    {
        if (!IsValidDwordField(hDlg, IDC_EDT_PVC_Layer3_IPI))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Layer3_IPI,
             MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_EDT_PVC_Layer3_IPI));
            err = TRUE;
        }
    }

    // SnapId
    if (!IsValidBinaryField(hDlg, IDC_EDT_PVC_SNAP_ID, c_nSnapIdMaxBytes))
    {
        NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_SnapId,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        SetFocus(GetDlgItem(hDlg, IDC_EDT_PVC_SNAP_ID));
        err = TRUE;
    }

    // High layer info
    if (!err)
    {
        if (!IsValidCmbSelection(hDlg, IDC_CMB_PVC_High_Type))
        {
            NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_Highlayer_Type,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_High_Type));

            err = TRUE;
        }
        else if ((!err) && (IsWindowEnabled(GetDlgItem(hDlg,IDC_CMB_PVC_High_Value))))
        {
            if (!IsValidBinaryField(hDlg, IDC_CMB_PVC_High_Value, c_nHighLayerInfoMaxBytes))
            {
                NcMsgBox(hDlg, IDS_MSFT_UNI_TEXT, IDS_INVALID_HighLayerValue,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

                SetFocus(GetDlgItem(hDlg,IDC_CMB_PVC_High_Value));
                err = TRUE;
            }
        }
    }
    return err;
}

BOOL IsValidCmbSelection(HWND hDlg, int nIDDlgItemCombo)
{
    BOOL ret = TRUE;

    WCHAR szBuf[MAX_PATH];

    int nlen = GetDlgItemText(hDlg, nIDDlgItemCombo, szBuf, MAX_PATH);
    if (nlen > 0) // empty string is ok
    {
        int nIdx = (int)SendDlgItemMessage(hDlg, nIDDlgItemCombo, CB_FINDSTRINGEXACT, -1,
                                      (LPARAM)(PCWSTR)szBuf);

        if (nIdx == CB_ERR) // any string in the selection is ok
        {
            DWORD dwProtocol;

            GetNumFromString(szBuf, &dwProtocol);

#pragma warning(push)
#pragma warning(disable:4296)
            if ((dwProtocol > c_dwFieldHigh) || (dwProtocol < c_dwFieldLow))
            {
                ret = FALSE;
            }
#pragma warning(pop)
        }
    }

    return ret;
}

BOOL IsValidDwordField(HWND hDlg, int nIDDlgItemEdit)
{
    BOOL ret = TRUE;

    DWORD dwValue;
    GetDwordEdtField(hDlg, &dwValue, nIDDlgItemEdit);

    if (FIELD_UNSET != dwValue) // empty field is ok
    {

#pragma warning(push)
#pragma warning(disable:4296)
        if ((dwValue > c_dwFieldHigh) || (dwValue < c_dwFieldLow))
        {
            ret = FALSE;
        }
#pragma warning(pop)
    }

    return ret;
}

BOOL IsValidBinaryField(HWND hDlg, int nIDDlgItemEdit, int nMaxBytes)
{
    BOOL ret = TRUE;

    WCHAR   szBuff[MAX_PATH];
    GetDlgItemText(hDlg, nIDDlgItemEdit, szBuff, celems(szBuff));

    //length
    int nlen = wcslen(szBuff);

    if (nlen % 2) // must be even number of hex digits
    {
        ret = FALSE;
    }
    else
    {
        if ((szBuff[0] == L'0') &&
            ((szBuff[1] == L'x') || (szBuff[1] == L'X')))
        {
            nlen -= 2;
        }

        if (nlen > nMaxBytes*2)
        {
            ret = FALSE;
        }
    }

    if (ret)
    {
        int i=0;
        nlen = wcslen(szBuff);
        if ((szBuff[0] == L'0') &&
            ((szBuff[1] == L'x') || (szBuff[1] == L'X')))
        {
            i = 2;
        }

        while (i<nlen)
        {
            if (((szBuff[i] >= L'0') && (szBuff[i] <= L'9')) ||
                ((szBuff[i] >= L'a') && (szBuff[i] <= L'f')) ||
                ((szBuff[i] >= L'A') && (szBuff[i] <= L'F')))
            {
                i++;
            }
            else
            {
                ret = FALSE;
                break;
            }
        }
    }

    return ret;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\arpsdlg.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S D L G . H
//
//  Contents:   CArpsPage declaration
//
//  Notes:
//
//  Author:     tongl   2 Feb 1998
//
//-----------------------------------------------------------------------

#pragma once
#include "ncxbase.h"
#include "ncatlps.h"
#include "ipctrl.h"

const int c_nColumns =2;
const int IPRANGE_LIMIT = 66;

struct HandleGroup
{
    HWND    m_hListView;
    HWND    m_hAdd;
    HWND    m_hEdit;
    HWND    m_hRemove;
};

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs); 

//
// CArpsPage
//
class CArpsPage : public CPropSheetPage
{
public:
    // Declare the message map
    BEGIN_MSG_MAP(CArpsPage)
        // Initialize dialog
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // List view handlers
        NOTIFY_CODE_HANDLER(LVN_ITEMCHANGED, OnItemChanged)

        // Control message handlers
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_ADD,    OnAddRegisteredAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_EDT,    OnEditRegisteredAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_REG_RMV,    OnRemoveRegisteredAddr);

        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_ADD,    OnAddMulticastAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_EDT,    OnEditMulticastAddr);
        COMMAND_ID_HANDLER(IDC_PSH_ARPS_MUL_RMV,    OnRemoveMulticastAddr);

    END_MSG_MAP()

    // Constructors/Destructors
    CArpsPage(CArpsCfg * pArpscfg, const DWORD * phelpIDs = NULL);
    ~CArpsPage();

// Interface
public:

    // message map functions
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    LRESULT OnItemChanged(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    // command ID handlers
    LRESULT OnAddRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveRegisteredAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnAddMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnEditMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnRemoveMulticastAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CAtmAddrDlg;
    friend class CIpAddrRangeDlg;

// Implementation
private:

    CArpsCfg *      m_pArpscfg;
    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;

    CArpsAdapterInfo *  m_pAdapterInfo;

    HandleGroup m_hRegAddrs;
    HandleGroup m_hMulAddrs;

    BOOL m_fEditState;
    tstring m_strRemovedAtmAddr;
    tstring m_strRemovedIpRange;

    // Inlines
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}
    void PageModified() {
                            m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    // help functions
    void SetRegisteredAtmAddrInfo();
    void SetMulticastIpAddrInfo();

    void SetButtons(HandleGroup& handles);
    void LvInsertIpRangeInOrder(tstring& strNewIpRange);

    void UpdateInfo();

    int CheckDupRegAddr();
    int CheckOverlappedIpRange();
};

//
//  CAtmAddrDlg
//
class CAtmAddrDlg : public CDialogImpl<CAtmAddrDlg>
{
public:

    enum { IDD = IDD_ARPS_REG_ADDR };

    BEGIN_MSG_MAP(CAtmAddrDlg)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_EDT_ARPS_REG_Address, OnChange);
    END_MSG_MAP()

public:
    CAtmAddrDlg(CArpsPage * pAtmArpsPage, const DWORD* pamhidsHelp = NULL);
    ~CAtmAddrDlg(){};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    friend class CArpsPage;

private:
    HWND m_hOkButton;     // this is the IDOK button, the text of the button changes
                          // with the context.
    HWND m_hEditBox;      // this is the edit box for the ATM address

    CArpsPage * m_pParentDlg;

    tstring m_strNewAtmAddr;

    const DWORD*    m_adwHelpIDs;
//    HINSTANCE       m_hInstance;
};

//
//  CIpAddrRangeDlg
//
class CIpAddrRangeDlg : public CDialogImpl<CIpAddrRangeDlg>
{
public:

    enum { IDD = IDD_ARPS_MUL_ADDR };

    BEGIN_MSG_MAP(CIpAddrRangeDlg)

        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_ARPS_MUL_LOWER_IP, OnChangeLowerIp)
        COMMAND_ID_HANDLER(IDC_ARPS_MUL_UPPER_IP, OnChangeUpperIp)
        NOTIFY_CODE_HANDLER(IPN_FIELDCHANGED, OnIpFieldChange)

    END_MSG_MAP()
//
public:
    CIpAddrRangeDlg( CArpsPage * pAtmArpsPage,
                     const DWORD* pamhidsHelp = NULL);
    ~CIpAddrRangeDlg(){};

// Dialog creation overides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnChangeLowerIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnChangeUpperIp(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    BOOL InitDialog();

    friend class CArpsPage;

public:
    IpControl   m_ipLower;
    IpControl   m_ipUpper;

private:

    // this is the IDOK button, the text of the button changes
    // with the context.
    HWND m_hOkButton;

    CArpsPage * m_pParentDlg;

    tstring m_strNewIpRange;
    tstring m_strNewIpLower;
    tstring m_strNewIpUpper;

    const DWORD*    m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\arpsobj.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S O B J . C P P
//
//  Contents:   CArpsCfg interface method function implementation
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "arpsdlg.h"
#include "atmutil.h"
#include "atmcommon.h"
#include "ncstl.h"
#include "netconp.h"

#include "ncpnp.h"

static const WCHAR c_szAtmarps[] = L"Atmarps";

CArpsCfg::CArpsCfg()
{
    m_pnccArps  = NULL;
    m_fSaveRegistry = FALSE;
    m_fReconfig = FALSE;
    m_fSecondMemoryModified = FALSE;
    m_fRemoving = FALSE;

    m_pSecondMemoryAdapterInfo = NULL;

    m_strGuidConn = c_szEmpty;
    m_pUnkContext = NULL;

    m_arps = NULL;
}

CArpsCfg::~CArpsCfg()
{
    ReleaseObj(m_pnccArps);
    FreeCollectionAndItem(m_listAdapters);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ? Not a bug in ARPS config.");
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext) ;

    delete m_arps;
}

// INetCfgComponentControl
STDMETHODIMP CArpsCfg::Initialize (INetCfgComponent* pnccItem,
                                   INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    HRESULT hr = S_OK;

    // Save in the data members the pointer to the
    // INetCfgComponent
    AssertSz(!m_pnccArps, "CArpsCfg::m_pnccArps not initialized!");
    m_pnccArps = pnccItem;
    AssertSz(m_pnccArps, "Component pointer is NULL!");
    AddRefObj(m_pnccArps);

    // Initialize in memory state
    if (!fInstalling)
    {
        hr = HrLoadSettings();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CArpsCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::Validate ( )
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fSaveRegistry && !m_fRemoving)
    {
        hr = HrSaveSettings();

        if (SUCCEEDED(hr) && m_fReconfig)
        {
            HRESULT hrReconfig;

            // send reconfig notification if parameter has changed
            for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {
                if ((*iterAdapter)->m_fDeleted)
                    continue;

                if ( ((*iterAdapter)->m_dwSapSelector !=
                      (*iterAdapter)->m_dwOldSapSelector) ||
                     !fIsSameVstr((*iterAdapter)->m_vstrRegisteredAtmAddrs,
                                  (*iterAdapter)->m_vstrOldRegisteredAtmAddrs) ||
                     !fIsSameVstr((*iterAdapter)->m_vstrMulticastIpAddrs,
                                  (*iterAdapter)->m_vstrOldMulticastIpAddrs))
                {
                    hrReconfig  = HrSendNdisPnpReconfig(NDIS, c_szAtmarps,
                                                        (*iterAdapter)->m_strBindName.c_str(),
                                                        NULL, 0);
                    if (FAILED(hrReconfig))
                    {
                        TraceTag(ttidAtmArps,"Notifying Atm ARP server of parameter change returns failure, prompt for reboot ...");
                        hr = NETCFG_S_REBOOT;
                    }
                }
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CArpsCfg::ApplyRegistryChanges", (S_FALSE == hr)? S_OK : hr);
    return hr;
}

// INetCfgComponentSetup
STDMETHODIMP CArpsCfg::Install (DWORD dwSetupFlags)
{
    m_fSaveRegistry = TRUE;
    m_fRemoving = FALSE;
    return S_OK;
}

STDMETHODIMP CArpsCfg::Upgrade( DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo )
{
    return S_FALSE;
}

STDMETHODIMP CArpsCfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::Removing ()
{
    m_fRemoving = TRUE;
    return S_OK;
}

// INetCfgBindNotify

STDMETHODIMP CArpsCfg::QueryBindingPath (DWORD dwChangeFlag,
                                         INetCfgBindingPath* pncbpItem )
{
    // OK to bind request
    return S_OK;
}

STDMETHODIMP CArpsCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                          INetCfgBindingPath* pncbp )
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    // We handle NCN_ADD and NCN_REMOVE only:
    // NCN_ADD:     if item not on list, add a new item
    //
    // NCN_REMOVE:  if item already on list, remove the item

    // We do this in NotifyBindingPath because we only want to do this
    // once for each binding change between arps and the card.
    // If NotifyBindingInterface was used, we will get notified multiple
    // times if the interface is on multiple paths.

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath(dwChangeFlag, pncbp);

    INetCfgComponent * pnccLastComponent;

    hr = HrGetLastComponentAndInterface(pncbp, &pnccLastComponent, NULL);

    if (SUCCEEDED(hr))
    {
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET), "Why the last component on the path is not an adapter?");

        if (IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET))
        {
            // If we are adding/removing cards, set m_fSaveRegistry
            // so we apply the changes to registry
            if ((dwChangeFlag & NCN_ADD) || (dwChangeFlag & NCN_REMOVE))
                m_fSaveRegistry = TRUE;

            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrAddAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_ENABLE)
            {
                hr = HrBindAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_DISABLE)
            {
                hr = HrUnBindAdapter(pnccLastComponent);
            }

            if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrRemoveAdapter(pnccLastComponent);
            }
        }
        ReleaseObj (pnccLastComponent);
    }

    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CArpsCfg::NotifyBindingPath", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CArpsCfg::QueryPropertyUi(IUnknown* pUnk) 
{
    HRESULT hr = S_FALSE;
    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            hr = S_FALSE;
        }
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    HRESULT hr = S_OK;

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    hr = HrSetConnectionContext();

    if SUCCEEDED(hr)
    {
        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;
        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);

        }
    }
    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CArpsCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CArpsCfg::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CArpsCfg::CancelProperties()
{
    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    return S_OK;
}

STDMETHODIMP CArpsCfg::ApplyProperties()
{
    HRESULT hr = S_OK;

    if(!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    if (!m_fReconfig)
        m_fReconfig = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        hr = HrSaveAdapterInfo();
    }

    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    TraceError("CArpsCfg::ApplyProperties", hr);
    return hr;
}

//
// CArpsAdapterInfo
//
CArpsAdapterInfo & CArpsAdapterInfo::operator=(const CArpsAdapterInfo & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    m_strBindName = info.m_strBindName;

    m_BindingState = info.m_BindingState;

    m_dwSapSelector = info.m_dwSapSelector;
    m_dwOldSapSelector = info.m_dwOldSapSelector;

    CopyColString(&m_vstrRegisteredAtmAddrs, info.m_vstrRegisteredAtmAddrs);
    CopyColString(&m_vstrOldRegisteredAtmAddrs, info.m_vstrOldRegisteredAtmAddrs);

    CopyColString(&m_vstrMulticastIpAddrs, info.m_vstrMulticastIpAddrs);
    CopyColString(&m_vstrOldMulticastIpAddrs, info.m_vstrOldMulticastIpAddrs);

    m_fDeleted = info.m_fDeleted;

    return *this;
}

HRESULT CArpsAdapterInfo::HrSetDefaults(PCWSTR pszBindName)
{
    HRESULT hr = S_OK;

    AssertSz(pszBindName, "NULL BindName passed to CArpsAdapterInfo::HrSetDefaults.");

    m_strBindName = pszBindName;

    m_BindingState = BIND_UNSET;

    // SAP selector
    m_dwSapSelector = c_dwDefSapSel;
    m_dwOldSapSelector = c_dwDefSapSel;

    // registered atm address
    FreeCollectionAndItem(m_vstrRegisteredAtmAddrs);
    m_vstrRegisteredAtmAddrs.push_back(new tstring(c_szDefRegAddrs));
    CopyColString(&m_vstrOldRegisteredAtmAddrs, m_vstrRegisteredAtmAddrs);

    // multicast ip address
    FreeCollectionAndItem(m_vstrMulticastIpAddrs);
    m_vstrMulticastIpAddrs.push_back(new tstring(c_szDefMCAddr1));
    m_vstrMulticastIpAddrs.push_back(new tstring(c_szDefMCAddr2));
    CopyColString(&m_vstrOldMulticastIpAddrs, m_vstrMulticastIpAddrs);

    m_fDeleted = FALSE;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\arpsfunc.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S F U N C . C P P
//
//  Contents:   CArpsCfg help member function implementation
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "arpsdlg.h"
#include "atmutil.h"
#include "ncreg.h"
#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

#include "netconp.h"
#include "atmhelp.h"

extern const WCHAR c_szAdapters[];

//
// Load cards on bind path to m_listAdapters on Initialize
//
HRESULT CArpsCfg::HrLoadSettings()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccArps);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of arps to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            NULL);
        if (SUCCEEDED(hr))
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS
            GUID    ClassGuid;

            // What type is it?
            hr = pnccNetComponent->GetClassGuid(&ClassGuid);
            if (SUCCEEDED(hr))
            {
                // Is it a netcard?
                if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET))
                {
                    hr = HrAddAdapter(pnccNetComponent);

                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled ??
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (hr == S_OK)
                        {   // bind the card in our data strucutres
                            hr = HrBindAdapter(pnccNetComponent);
                        }
                        else if (hr == S_FALSE)
                        {
                            hr = HrUnBindAdapter(pnccNetComponent);
                        }

                        // Now load cofigurable parameters
                        if (SUCCEEDED(hr))
                        {
                            HKEY hkeyArpsParam;

                            hr = m_pnccArps->OpenParamKey(&hkeyArpsParam);
                            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                            {
                                hr = S_OK;
                            }
                            else if (SUCCEEDED(hr))
                            {
                                Assert(hkeyArpsParam);
                                hr = HrLoadArpsRegistry(hkeyArpsParam);

                                RegCloseKey(hkeyArpsParam);
                            }
                        }
                    }
                }
            }
            ReleaseObj(pnccNetComponent);
        }
        ReleaseObj(pncbp);
    }
    AssertSz(!pncbp, "BindingPath wasn't released");

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CArpsCfg::HrLoadSettings", hr);
    return hr;
}

// Load registry settings for configurable parameters into memory
HRESULT CArpsCfg::HrLoadArpsRegistry(HKEY hkeyArpsParam)
{
    HRESULT hr = S_OK;

    HKEY    hkeyAdapters = NULL;
    hr = HrRegOpenKeyEx(hkeyArpsParam, c_szAdapters,
                        KEY_READ, &hkeyAdapters);

    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        HKEY    hkeyAdapterParam = NULL;

        for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
            iterAdapter != m_listAdapters.end();
            iterAdapter ++)
        {
            // Open the AtmArps\Adapters to get per adapter ARPS settings
            hr = HrRegOpenKeyEx(hkeyAdapters,
                                (*iterAdapter)->m_strBindName.c_str(),
                                KEY_READ, &hkeyAdapterParam);

            if (hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
            {
                hr = S_OK;
            }
            else if (S_OK == hr)
            {
                TraceTag(ttidAtmArps, "CArpsCfg::HrLoadArpsRegistry");
                TraceTag(ttidAtmArps, "Adapter: %S", (*iterAdapter)->m_strBindName.c_str());

                HRESULT hrTmp = S_OK;

                // Sap selecter
                hrTmp = HrRegQueryDword(hkeyAdapterParam,
                                       c_szSapSel,
                                       &((*iterAdapter)->m_dwSapSelector));

                (*iterAdapter)->m_dwOldSapSelector = (*iterAdapter)->m_dwSapSelector;

                hr = hrTmp;

                // Registered addresses
                hrTmp = HrRegQueryColString(hkeyAdapterParam,
                                           c_szRegAddrs,
                                           &((*iterAdapter)->m_vstrRegisteredAtmAddrs));

                // Save the registry value in old address
                CopyColString(&((*iterAdapter)->m_vstrOldRegisteredAtmAddrs),
                              (*iterAdapter)->m_vstrRegisteredAtmAddrs);

                if (S_OK == hr)
                {
                    hr = hrTmp;
                }

                // Multicast addresses
                hrTmp = HrRegQueryColString(hkeyAdapterParam,
                                           c_szMCAddrs,
                                           &((*iterAdapter)->m_vstrMulticastIpAddrs));

                CopyColString(&((*iterAdapter)->m_vstrOldMulticastIpAddrs),
                              (*iterAdapter)->m_vstrMulticastIpAddrs);

                if (S_OK == hr)
                {
                    hr = hrTmp;
                }
            }

            RegSafeCloseKey(hkeyAdapterParam);
            hkeyAdapterParam = NULL;
        }
    }
    RegSafeCloseKey(hkeyAdapters);

    TraceError("CArpsCfg::HrLoadArpsRegistry", hr);
    return hr;
}

//
// Update registry with info in m_listAdapters on Apply
//
HRESULT CArpsCfg::HrSaveSettings()
{
    HRESULT hr = S_OK;
    HKEY hkeyArpsParam = NULL;

    hr = m_pnccArps->OpenParamKey(&hkeyArpsParam);

    if (S_OK == hr)
    {
        HKEY hkeyAdapters = NULL;
        DWORD dwDisposition;

        // Create or open the "Adapters" key under "Services\Atmarps\Parameters"
        hr = HrRegCreateKeyEx(hkeyArpsParam,
                              c_szAdapters,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyAdapters,
                              &dwDisposition);

        if (S_OK == hr)
        {
            Assert(hkeyAdapters);
            HRESULT hrTmp = S_OK;

            if (dwDisposition == REG_OPENED_EXISTING_KEY)
            { // if the "adapters" key existed, there might be some old cards
              // Cleanup subkeys for adapters that are not in our memory structure

                VECSTR vstrAdapters;
                hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters, &vstrAdapters);

                if SUCCEEDED(hrTmp)
                {
                    for (size_t i=0; i<vstrAdapters.size(); i++)
                    {
                        BOOL fFound = FALSE;
                        for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                             iterAdapter != m_listAdapters.end();
                             iterAdapter ++)
                        {
                            if ((*iterAdapter)->m_strBindName == vstrAdapters[i]->c_str())
                            {
                                fFound = TRUE;
                                break;
                            }
                        }

                        if ((!fFound) || ((*iterAdapter)->m_fDeleted))
                        {
                            hrTmp = HrRegDeleteKeyTree(hkeyAdapters,
                                                       vstrAdapters[i]->c_str());
                            if SUCCEEDED(hr)
                                hr = hrTmp;
                        }
                    }
                }
            }

            // Save adapter info in memory state to registry
            for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {

                if ((*iterAdapter)->m_fDeleted)
                    continue;

                HKEY    hkeyAdapterParam;

                // Create specific card bindname key under
                // "Services\Atmarps\Parameters\Adapters\<card bind name>"
                hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                         ((*iterAdapter)->m_strBindName).c_str(),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hkeyAdapterParam,
                                         &dwDisposition);
                if(SUCCEEDED(hr))
                    hr = hrTmp;

                if(SUCCEEDED(hrTmp))
                {
                    /*
                    hrTmp = HrSetDefaultAdapterParam(hkeyAdapterParam);

                    if SUCCEEDED(hr)
                        hr = hrTmp;
                    */

                    // Sap selecter
                    hrTmp = HrRegSetDword(hkeyAdapterParam,
                                          c_szSapSel,
                                          (*iterAdapter)->m_dwSapSelector);
                    if SUCCEEDED(hr)
                        hr = hrTmp;

                    // Registered addresses
                    hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              c_szRegAddrs,
                                              (*iterAdapter)->m_vstrRegisteredAtmAddrs);

                    if SUCCEEDED(hr)
                        hr = hrTmp;

                    // Multicast addresses
                    hrTmp = HrRegSetColString(hkeyAdapterParam,
                                              c_szMCAddrs,
                                              (*iterAdapter)->m_vstrMulticastIpAddrs);

                    if SUCCEEDED(hr)
                        hr = hrTmp;
                }
                RegSafeCloseKey(hkeyAdapterParam);
            }
        }
        RegSafeCloseKey(hkeyAdapters);
    }
    RegSafeCloseKey(hkeyArpsParam);

    TraceError("CArpsCfg::HrSaveSettings", hr);
    return hr;
}

//
// Adding a card
//
HRESULT CArpsCfg::HrAddAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pncc->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    // check if the adapter already existsed and marked as deleted,
    // if so, just unmark it

    BOOL fFound = FALSE;

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            Assert((*iterAdapter)->m_fDeleted);
            (*iterAdapter)->m_fDeleted = FALSE;

            fFound = TRUE;
            break;
        }
    }

    if (!fFound) // add a new item
    {
        CArpsAdapterInfo * pAdapterInfo = new CArpsAdapterInfo;
        pAdapterInfo->HrSetDefaults(pszwBindName);

        // create a new item for the ARPS_ADAPT_INFO list
        m_listAdapters.push_back(pAdapterInfo);
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrAddAdapter", hr);
    return hr;
}

//
// Removing a card
//
HRESULT CArpsCfg::HrRemoveAdapter(INetCfgComponent * pncc)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pncc->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    // mark the adapter as removed
    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_fDeleted = TRUE;
        }
    }
    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrRemoveAdapter", hr);
    return hr;
}

HRESULT CArpsCfg::HrBindAdapter(INetCfgComponent * pnccAdapter)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_BindingState = BIND_ENABLE;
            break;
        }
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrBindAdapter", hr);
    return hr;
}

HRESULT CArpsCfg::HrUnBindAdapter(INetCfgComponent * pnccAdapter)
{
    HRESULT hr = S_OK;

    PWSTR pszwBindName = NULL;
    hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    for (ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszwBindName)
        {
            (*iterAdapter)->m_BindingState = BIND_DISABLE;
            break;
        }
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CArpsCfg::HrUnBindAdapter", hr);
    return hr;
}

// Called by CArpsCfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CArpsCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CArpsCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);
        ReleaseObj(pLanConnUiInfo);

        WCHAR szGuid[c_cchGuidWithTerm];

        BOOL fSucceeded = StringFromGUID2(guidConn,
                                          szGuid,
                                          c_cchGuidWithTerm);
        Assert(fSucceeded);
        m_strGuidConn = szGuid;
    }

    TraceError("CArpsCfg::HrSetConnectionContext", hr);
    return hr;
}

// Called by CArpsCfg::MergePropPages
// Allocate property pages
HRESULT CArpsCfg::HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;
    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryModified = FALSE;

    // Copy adapter specific info: enabled cards only !!
    hr = HrLoadAdapterInfo();

    // If we have found the matching adapter
    if SUCCEEDED(hr)
    {
        cPages = 1;

        delete m_arps;
        m_arps = new CArpsPage(this, g_aHelpIDs_IDD_ARPS_PROP);

		if (m_arps == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;

        ahpsp[cPages++] = m_arps->CreatePage(IDD_ARPS_PROP, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if we don't have any bound cards, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_ARPS_TEXT,
                 IDS_ARPS_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CArpsCfg::HrSetupPropSheets", hr);
    return hr;
}

// Called by CArpsCfg::HrSetupPropSheets
// Creates the second memory adapter info from the first memory structure
// Note: Bound cards only
HRESULT CArpsCfg::HrLoadAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
        {
            // enabled LAN adapter
            if ((*iterAdapter)->m_BindingState == BIND_ENABLE)
            {
                m_pSecondMemoryAdapterInfo = new CArpsAdapterInfo;

				if (m_pSecondMemoryAdapterInfo == NULL)
				{
					return(ERROR_NOT_ENOUGH_MEMORY);
				}

                *m_pSecondMemoryAdapterInfo = **iterAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CArpsCfg::HrLoadAdapterInfo", hr);
    return hr;
}

// Called by CArpsCfg::ApplyProperties
// Saves the second memory state back into the first
HRESULT CArpsCfg::HrSaveAdapterInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    for(ARPS_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if(m_pSecondMemoryAdapterInfo->m_strBindName == (*iterAdapter)->m_strBindName)
        {
            // The card can not get unbound while in the properties UI !
            Assert((*iterAdapter)->m_BindingState == BIND_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BIND_ENABLE);

            **iterAdapter = *m_pSecondMemoryAdapterInfo;
            hr = S_OK;
            break;
        }
    }

    AssertSz((S_OK == hr),
             "Adapter in second memory not found in first memory!");

    TraceError("CArpsCfg::HrSaveAdapterInfo", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\atmhelp.h ===
#define IDH_ARPS_MUL_LOWER_IP	30000001
#define IDH_ARPS_MUL_UPPER_IP	30000003
#define IDH_LVW_ARPS_REG_ADDR	30000051
#define IDH_PSH_ARPS_REG_ADD	30000052
#define IDH_PSH_ARPS_REG_EDT	30000053
#define IDH_PSH_ARPS_REG_RMV	30000054
#define IDH_LVW_ARPS_MUL_ADDR	30000057
#define IDH_PSH_ARPS_MUL_ADD	30000058
#define IDH_PSH_ARPS_MUL_EDT	30000059
#define IDH_PSH_ARPS_MUL_RMV	30000060
#define IDH_EDT_ARPS_REG_Address	30000101
#define IDH_CMB_PVC_Layer2	30000153
#define IDH_EDT_PVC_User_Layer2	30000155
#define IDH_CMB_PVC_Layer3	30000157
#define IDH_EDT_PVC_User_Layer3	30000159
#define IDH_EDT_PVC_Layer3_IPI	30000161
#define IDH_EDT_PVC_SNAP_ID	30000163
#define IDH_CMB_PVC_High_Type	30000166
#define IDH_CMB_PVC_High_Value	30000168
#define IDH_CMB_PVC_Layer2_2	30000203
#define IDH_CMB_PVC_Layer3_2	30000207
#define IDH_CMB_PVC_High_Type_2	30000216
#define IDH_EDT_PVC_Name	30000252
#define IDH_EDT_PVC_VPI	30000254
#define IDH_EDT_PVC_VCI	30000256
#define IDH_CMB_PVC_AAL	30000258
#define IDH_CMB_PVC_Type	30000261
#define IDH_CHK_PVC_CallAddr	30000262
#define IDH_EDT_PVC_CallAddr	30000263
#define IDH_CHK_PVC_AnswerAddr	30000264
#define IDH_EDT_PVC_AnswerAddr	30000265
#define IDH_PBN_PVC_Advanced	30000266
#define IDH_EDT_PVC_TRANS_PEAK	30000302
#define IDH_EDT_PVC_TRANS_AVG	30000304
#define IDH_EDT_PVC_TRANS_BURST	30000306
#define IDH_EDT_PVC_TRANS_MAX_SIZE	30000308
#define IDH_CMB_PVC_TRANS_SERVICE	30000310
#define IDH_EDT_PVC_RECEIVE_PEAK	30000313
#define IDH_EDT_PVC_RECEIVE_AVG	30000315
#define IDH_EDT_PVC_RECEIVE_BURST	30000317
#define IDH_EDT_PVC_RECEIVE_MAX_SIZE	30000319
#define IDH_CMB_PVC_RECEIVE_SERVICE	30000321
#define IDH_LVW_PVC_LIST	30000351
#define IDH_PBN_PVC_Add	30000352
#define IDH_PBN_PVC_Remove	30000353
#define IDH_PBN_PVC_Properties	30000354


const DWORD g_aHelpIDs_IDD_ARPS_MUL_ADDR[]=
{
	IDC_ARPS_MUL_LOWER_IP, IDH_ARPS_MUL_LOWER_IP,
	IDC_ARPS_MUL_UPPER_IP, IDH_ARPS_MUL_UPPER_IP,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ARPS_PROP[]=
{
	IDC_LVW_ARPS_REG_ADDR, IDH_LVW_ARPS_REG_ADDR,
	IDC_PSH_ARPS_REG_ADD, IDH_PSH_ARPS_REG_ADD,
	IDC_PSH_ARPS_REG_EDT, IDH_PSH_ARPS_REG_EDT,
	IDC_PSH_ARPS_REG_RMV, IDH_PSH_ARPS_REG_RMV,
	IDC_LVW_ARPS_MUL_ADDR, IDH_LVW_ARPS_MUL_ADDR,
	IDC_PSH_ARPS_MUL_ADD, IDH_PSH_ARPS_MUL_ADD,
	IDC_PSH_ARPS_MUL_EDT, IDH_PSH_ARPS_MUL_EDT,
	IDC_PSH_ARPS_MUL_RMV, IDH_PSH_ARPS_MUL_RMV,
	0, 0
};

const DWORD g_aHelpIDs_IDD_ARPS_REG_ADDR[]=
{
	IDC_EDT_ARPS_REG_Address, IDH_EDT_ARPS_REG_Address,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Dest[]=
{
	IDC_CMB_PVC_Layer2, IDH_CMB_PVC_Layer2,
	IDC_EDT_PVC_User_Layer2, IDH_EDT_PVC_User_Layer2,
	IDC_CMB_PVC_Layer3, IDH_CMB_PVC_Layer3,
	IDC_EDT_PVC_User_Layer3, IDH_EDT_PVC_User_Layer3,
	IDC_EDT_PVC_Layer3_IPI, IDH_EDT_PVC_Layer3_IPI,
	IDC_EDT_PVC_SNAP_ID, IDH_EDT_PVC_SNAP_ID,
	IDC_CMB_PVC_High_Type, IDH_CMB_PVC_High_Type,
	IDC_CMB_PVC_High_Value, IDH_CMB_PVC_High_Value,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Local[]=
{
	IDC_CMB_PVC_Layer2, IDH_CMB_PVC_Layer2_2,
	IDC_EDT_PVC_User_Layer2, IDH_EDT_PVC_User_Layer2,
	IDC_CMB_PVC_Layer3, IDH_CMB_PVC_Layer3_2,
	IDC_EDT_PVC_User_Layer3, IDH_EDT_PVC_User_Layer3,
	IDC_EDT_PVC_Layer3_IPI, IDH_EDT_PVC_Layer3_IPI,
	IDC_EDT_PVC_SNAP_ID, IDH_EDT_PVC_SNAP_ID,
	IDC_CMB_PVC_High_Type, IDH_CMB_PVC_High_Type_2,
	IDC_CMB_PVC_High_Value, IDH_CMB_PVC_High_Value,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Main[]=
{
	IDC_EDT_PVC_Name, IDH_EDT_PVC_Name,
	IDC_EDT_PVC_VPI, IDH_EDT_PVC_VPI,
	IDC_EDT_PVC_VCI, IDH_EDT_PVC_VCI,
	IDC_CMB_PVC_AAL, IDH_CMB_PVC_AAL,
	IDC_CMB_PVC_Type, IDH_CMB_PVC_Type,
	IDC_CHK_PVC_CallAddr, IDH_CHK_PVC_CallAddr,
	IDC_EDT_PVC_CallAddr, IDH_EDT_PVC_CallAddr,
	IDC_CHK_PVC_AnswerAddr, IDH_CHK_PVC_AnswerAddr,
	IDC_EDT_PVC_AnswerAddr, IDH_EDT_PVC_AnswerAddr,
	IDC_PBN_PVC_Advanced, IDH_PBN_PVC_Advanced,
	0,0
};

const DWORD g_aHelpIDs_IDD_PVC_Traffic[]=
{
	IDC_EDT_PVC_TRANS_PEAK, IDH_EDT_PVC_TRANS_PEAK,
	IDC_EDT_PVC_TRANS_AVG, IDH_EDT_PVC_TRANS_AVG,
	IDC_EDT_PVC_TRANS_BURST, IDH_EDT_PVC_TRANS_BURST,
	IDC_EDT_PVC_TRANS_MAX_SIZE, IDH_EDT_PVC_TRANS_MAX_SIZE,
	IDC_CMB_PVC_TRANS_SERVICE, IDH_CMB_PVC_TRANS_SERVICE,
	IDC_EDT_PVC_RECEIVE_PEAK, IDH_EDT_PVC_RECEIVE_PEAK,
	IDC_EDT_PVC_RECEIVE_AVG, IDH_EDT_PVC_RECEIVE_AVG,
	IDC_EDT_PVC_RECEIVE_BURST, IDH_EDT_PVC_RECEIVE_BURST,
	IDC_EDT_PVC_RECEIVE_MAX_SIZE, IDH_EDT_PVC_RECEIVE_MAX_SIZE,
	IDC_CMB_PVC_RECEIVE_SERVICE, IDH_CMB_PVC_RECEIVE_SERVICE,
	0,0
};

const DWORD g_aHelpIDs_IDD_UNI_PROP[]=
{
	IDC_LVW_PVC_LIST, IDH_LVW_PVC_LIST,
	IDC_PBN_PVC_Add, IDH_PBN_PVC_Add,
	IDC_PBN_PVC_Remove, IDH_PBN_PVC_Remove,
	IDH_PBN_PVC_Properties, IDH_PBN_PVC_Properties,
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\arpsobj.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A R P S O B J . H
//
//  Contents:   CArpsCfg declaration
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "atmutil.h"
#include "resource.h"

// Reg key value names for parameters
static const WCHAR c_szSapSel[] = L"Selector";
static const WCHAR c_szRegAddrs[] = L"RegisteredAddresses";
static const WCHAR c_szMCAddrs[] = L"MulticastAddresses";

// Default parameter values
static const c_dwDefSapSel = 0;
static const WCHAR c_szDefRegAddrs[] =
            L"4700790001020000000000000000A03E00000200";
#pragma warning( disable : 4125 )
static const WCHAR c_szDefMCAddr1[] = L"224.0.0.1-239.255.255.255";
static const WCHAR c_szDefMCAddr2[] = L"255.255.255.255-255.255.255.255";
#pragma warning( default : 4125 )

//
// parameter data structure
//

class CArpsAdapterInfo
{
public:

    CArpsAdapterInfo() {};
    ~CArpsAdapterInfo(){};

    CArpsAdapterInfo &  operator=(const CArpsAdapterInfo & AdapterInfo);  // copy operator
    HRESULT HrSetDefaults(PCWSTR pszBindName);

    // the adapter's binding state
    AdapterBindingState    m_BindingState;

    // Instance Guid of net card
    tstring m_strBindName;

    // SAP selector
    DWORD m_dwSapSelector;
    DWORD m_dwOldSapSelector;

    // Registered ATM Address
    VECSTR m_vstrRegisteredAtmAddrs;
    VECSTR m_vstrOldRegisteredAtmAddrs;

    // Multicast IP address
    VECSTR m_vstrMulticastIpAddrs;
    VECSTR m_vstrOldMulticastIpAddrs;

    // flags
    BOOL    m_fDeleted;
};

typedef list<CArpsAdapterInfo*> ARPS_ADAPTER_LIST;

/////////////////////////////////////////////////////////////////////////////
// ArpsCfg

class ATL_NO_VTABLE CArpsCfg :
    public CComObjectRoot,
    public CComCoClass<CArpsCfg, &CLSID_CArpsCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentPropertyUi
{
public:
    CArpsCfg();
    ~CArpsCfg();

    BEGIN_COM_MAP(CArpsCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CArpsCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_ARPSCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// help functions
    CArpsAdapterInfo * GetSecondMemoryAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    }

    void SetSecondMemoryModified()
    {
        m_fSecondMemoryModified = TRUE;
    }

// Private state info and help functions
private:

    // Place to keep corresponding component object, i.e. ATMARPS
    INetCfgComponent    *m_pnccArps;

    // Place to keep the pointer to UI context
    IUnknown * m_pUnkContext;

    // (STL) List of adapter info structures
    ARPS_ADAPTER_LIST    m_listAdapters;

    // Guid of the current connection
    tstring m_strGuidConn;

    // Second memory adapter info structures
    CArpsAdapterInfo *   m_pSecondMemoryAdapterInfo;

    // Do we need to update registry on Apply
    BOOL    m_fSaveRegistry;
    BOOL    m_fReconfig;
    BOOL    m_fSecondMemoryModified;
    BOOL    m_fRemoving;

    // property page
    class CArpsPage * m_arps;

    // Update registry with contents of m_listAdapters
    HRESULT HrSaveSettings();

    HRESULT HrLoadSettings();
    HRESULT HrLoadArpsRegistry(HKEY hkey);

    // Set the default parameter values to registry
    HRESULT HrSetDefaultAdapterParam(HKEY hkey);

    // Handling add or remove a card in memory
    HRESULT HrAddAdapter(INetCfgComponent * pncc);
    HRESULT HrRemoveAdapter(INetCfgComponent * pncc);

    HRESULT HrBindAdapter(INetCfgComponent * pnccAdapter);
    HRESULT HrUnBindAdapter(INetCfgComponent * pnccAdapter);

    HRESULT HrSetConnectionContext();

    HRESULT HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    // load and save adapter parameters to second memory
    HRESULT HrLoadAdapterInfo();
    HRESULT HrSaveAdapterInfo();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\atmutil.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A T M U T I L . C P P
//
//  Contents:   Utility function declaration
//
//  Notes:
//
//  Author:     tongl   3 Feb 1997
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "atmutil.h"
#include "ncmisc.h"
//#include "ncreg.h"
#include "ncstl.h"

void GetLowerIp(tstring& strIpRange, tstring * pstrLowerIp)
{
    size_t iSeparator = strIpRange.find(c_chSeparator);
    if(iSeparator != tstring::npos)
    {
        // get the first half of the string
        *pstrLowerIp = strIpRange.substr(0, iSeparator);
    }

    return;
}

void GetUpperIp(tstring& strIpRange, tstring * pstrUpperIp)
{
    size_t iSeparator = strIpRange.find(c_chSeparator);
    if(iSeparator != tstring::npos)
    {
        // get the first half of the string
        *pstrUpperIp = strIpRange.substr(iSeparator+1);
    }

    return;
}

BOOL IsValidIpRange(tstring& strIpLower, tstring& strIpUpper)
{
    if (strIpLower > strIpUpper)
        return FALSE;
    else
        return TRUE;
}

void MakeIpRange(tstring& strIpLower, tstring& strIpUpper, tstring * pstrNewIpRange)
{
    tstring strNewIpRange = strIpLower;
    strNewIpRange += c_chSeparator;
    strNewIpRange += strIpUpper;

    *pstrNewIpRange = strNewIpRange;

    return;
}

void InitComboWithStringArray(HWND hDlg, int nIDDlgItem,
                              int csid, const int*  asid)
{
    while (csid--)
    {
        SendDlgItemMessage(hDlg, nIDDlgItem, CB_ADDSTRING,
                           0, (LPARAM)((PWSTR) SzLoadIds(* asid++)));
    }
}

void ConvertBinaryToHexString(BYTE * pbData, DWORD cbData, tstring * pstrData)
{
    Assert(pstrData);
    Assert(pbData);

    tstring strData = c_szEmpty;
    WCHAR szByte[3];

    while (cbData>0)
    {
        ConvertByteToSz(pbData, szByte);
        strData += szByte;

        pbData ++;
        cbData --;
    }

    *pstrData = strData;
}

void ConvertByteToSz(BYTE * pbData, PWSTR pszByte)
{
    // high 4 bits
    BYTE bHighData = *pbData;
    bHighData &= 0xF0;
    bHighData >>= 4;
    pszByte[0] = (bHighData < 10) ? L'0'+bHighData : L'A'+(bHighData-10);

    // low 4 bits
    BYTE bLowData = *pbData;
    bLowData &= 0x0F;
    pszByte[1] = (bLowData < 10) ? L'0'+bLowData : L'A'+(bLowData-10);

    // terminater.
    pszByte[2] = L'\0';
}

void ConvertHexCharToByte(WCHAR ch, BYTE * pByte)
{
    *pByte =0;

    if ((ch >= L'0') && (ch <= L'9'))
        *pByte = ch-L'0';
    else if ((ch >= L'A') && (ch <= L'F'))
        *pByte = ch-L'A'+10;
    else if ((ch >= L'a') && (ch <= L'f'))
        *pByte = ch-L'a'+10;
    else
        AssertSz(FALSE, "Invalid hex character.");
}

void ConvertHexStringToBinaryWithAlloc(PCWSTR pszData, LPBYTE * ppbData, LPDWORD pcbData)
{
    // Initialize the output parameters.
    *ppbData = NULL;
    *pcbData = 0;

    LPBYTE  pbBuffer = NULL;
    DWORD   cbBuffer = wcslen(pszData)/2;
    const WCHAR * pChar = pszData;

    if ((*pszData == L'0') &&
        ((*(pszData+1) == L'x') || (*(pszData+1) == L'X')))
    {
        cbBuffer -=2;
        pChar +=2;
    }

    if (cbBuffer)
    {
        pbBuffer = new BYTE[cbBuffer];

		if (pbBuffer == NULL)
		{
            AssertSz(FALSE, "new returned a NULL pointer");
			return;
		}

        BYTE * pByte = pbBuffer;

        if (pByte != NULL)
        {
			while (*pChar)
			{
				*pByte=0;

				BYTE bData;

				// first 4 bits
				ConvertHexCharToByte(*pChar, &bData);
				bData <<= 4;
				*pByte |= bData;
				pChar++;

				// second 4 bits
				ConvertHexCharToByte(*pChar, &bData);
				*pByte |= bData;
				pChar++;

				pByte++;
			}
		}
    }

    *ppbData = pbBuffer;
    *pcbData = cbBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\atmutil.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A T M U T I L . H
//
//  Contents:   Utility function declaration
//
//  Notes:
//
//  Author:     tongl   12 Mar 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ncxbase.h"

typedef vector<tstring *>   VECSTR;

static const WCHAR  c_chSeparator  = L'-';

enum AdapterBindingState
{
    BIND_ENABLE,
    BIND_DISABLE,
    BIND_UNSET
};

HRESULT HrLoadSubkeysFromRegistry(const HKEY hkeyParam,
                                  OUT VECSTR * const pvstrAdapters);

VOID GetNodeNum(PCWSTR pszIpAddress, DWORD ardw[4]);

void GetLowerIp(tstring& strIpRange, tstring * pstrLowerIp);
void GetUpperIp(tstring& strIpRange, tstring * pstrUpperIp);

BOOL IsValidIpRange(tstring& strIpLower, tstring& strIpUpper);

void MakeIpRange(tstring& strIpLower, tstring& strIpUpper, tstring * pstrNewIpRange);

void ConvertBinaryToHexString(BYTE * pbData, DWORD cbData, tstring * pstrData);
void ConvertByteToSz(BYTE * pbData, PWSTR pszByte);
void ConvertHexStringToBinaryWithAlloc(PCWSTR pszParamInHex, LPBYTE * ppbData, LPDWORD pcbData);

template<class T>
void CopyColString(T * colDest, const T & colSrc)
{
    FreeCollectionAndItem(*colDest);
    colDest->reserve(colSrc.size());

    for(T::const_iterator iter = colSrc.begin(); iter != colSrc.end(); ++iter)
    {
        colDest->push_back(new tstring(**iter));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\aunidlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I D L G . C P P
//
//  Contents:   ATMUNI call manager dialogbox message handler implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"

#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

#include "atmhelp.h"

const int c_nColumns =3;
const int c_nMAX_PVC_ID_LEN =10;
//
// CUniPage
//
CUniPage::CUniPage(CAtmUniCfg * pAtmUniCfg, const DWORD * adwHelpIDs)
{
    Assert(pAtmUniCfg);
    m_patmunicfg = pAtmUniCfg;
    m_adwHelpIDs = adwHelpIDs;

    m_pAdapterInfo = pAtmUniCfg->GetSecondMemoryAdapterInfo();
    m_fModified = FALSE;
}

CUniPage::~CUniPage()
{
}

LRESULT CUniPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& bHandled)
{
    // initialize PVC name list view
    int nIndex;
    m_hPVCList = GetDlgItem(IDC_LVW_PVC_LIST);

    // Calculate column width
    RECT rect;

    ::GetClientRect(m_hPVCList, &rect);
    int colWidth = (rect.right/(c_nColumns*2));

    // set the column header
    // The mask specifies that the fmt, width and pszText members
    // of the structure are valid
    LV_COLUMN lvCol = {0};
    lvCol.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ;
    lvCol.fmt = LVCFMT_LEFT;   // left-align column

    // Add the two columns and header text.
    for (nIndex = 0; nIndex < c_nColumns; nIndex++)
    {
        // column header text
        if (0 == nIndex) // first column
        {
            lvCol.cx = colWidth*4;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_NAME);
        }
        else if (1 == nIndex)
        {
            lvCol.cx = colWidth;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_VPI);
        }
        else if (2 == nIndex)
        {
            lvCol.cx = colWidth;
            lvCol.pszText = (PWSTR) SzLoadIds(IDS_PVC_VCI);
        }

        int iNewItem = ListView_InsertColumn(GetDlgItem(IDC_LVW_PVC_LIST),
                                             nIndex, &lvCol);

        AssertSz((iNewItem == nIndex), "Invalid item inserted to list view !");
    }

    // insert existing PVCs into the list view
    int idx =0;

    for (PVC_INFO_LIST::iterator iterPvc = m_pAdapterInfo->m_listPVCs.begin();
         iterPvc != m_pAdapterInfo->m_listPVCs.end();
         iterPvc ++)
    {
        if ((*iterPvc)->m_fDeleted)
            continue;

        InsertNewPvc(*iterPvc, idx);
        idx++;
    }

    // select the first item
    ListView_SetItemState(GetDlgItem(IDC_LVW_PVC_LIST), 0, LVIS_SELECTED, LVIS_SELECTED);

    SetButtons();
    return 0;
}

LRESULT CUniPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CUniPage::OnHelp(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CUniPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL nResult = PSNRET_NOERROR;

    if (!IsModified())
    {
        ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
        return nResult;
    }

    m_patmunicfg->SetSecondMemoryModified();
    SetModifiedTo(FALSE);   // this page is no longer modified

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, nResult);
    return nResult;
}

LRESULT CUniPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE;

    // Error checking: unique Vci\Vpi pair
    int iDupPvcIdx = CheckDupPvcId();

    if (iDupPvcIdx >=0)
    {
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_DUPLICATE_PVC,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ListView_SetItemState(GetDlgItem(IDC_LVW_PVC_LIST), iDupPvcIdx,
                              LVIS_SELECTED, LVIS_SELECTED);
        err = TRUE;
    }

    return err;
}

int CUniPage::CheckDupPvcId()
{
    int ret = -1;
    int idx = 0;

    for(PVC_INFO_LIST::iterator iterPvc = m_pAdapterInfo->m_listPVCs.begin();
        iterPvc != m_pAdapterInfo->m_listPVCs.end();
        iterPvc ++)
    {
        if ((*iterPvc)->m_fDeleted)
            continue;

        PVC_INFO_LIST::iterator iterPvcComp = iterPvc;

        iterPvcComp ++;
        while (iterPvcComp != m_pAdapterInfo->m_listPVCs.end())
        {
            if (!(*iterPvcComp)->m_fDeleted)
            {
                if ( ((*iterPvc)->m_dwVpi == (*iterPvcComp)->m_dwVpi) &&
                     ((*iterPvc)->m_dwVci == (*iterPvcComp)->m_dwVci))
                {
                    // we find a duplicate address
                    ret = idx;
                    break;
                }
            }
            iterPvcComp++;
        }

        // duplicate address found
        if (ret >=0 )
            break;

        // move next
        idx ++;
    }

    return ret;
}

LRESULT CUniPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CUniPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CUniPage::OnAddPVC(WORD wNotifyCode, WORD wID,
                           HWND hWndCtl, BOOL& bHandled)
{
    // make a new PVC Info structure and pass to the dialog
    tstring strNewPvcId;
    GetNewPvcId(m_pAdapterInfo, &strNewPvcId);

    CPvcInfo * pDlgPvcInfo = new CPvcInfo(strNewPvcId.c_str());

	if (pDlgPvcInfo == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    pDlgPvcInfo->m_dwPVCType = PVC_CUSTOM;
    pDlgPvcInfo->SetDefaults(PVC_CUSTOM);

    CPVCMainDialog * pPvcMainDlg = new CPVCMainDialog(this, pDlgPvcInfo,
                                                      g_aHelpIDs_IDD_PVC_Main);
	if (pPvcMainDlg == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    if (pPvcMainDlg->DoModal() == IDOK)
    {
        // add the new PVC
        m_pAdapterInfo->m_listPVCs.push_back(pDlgPvcInfo);

        int nCount = ListView_GetItemCount(m_hPVCList);

        // insert the new item at the end of list
        InsertNewPvc(pDlgPvcInfo, nCount);

        SetButtons();
        PageModified();
    }
    else
    {
        delete pDlgPvcInfo;
    }

    delete pPvcMainDlg;
    return 0;
}

LRESULT CUniPage::OnPVCProperties(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    // mark the PVC as deleted and from the list view
    // get the current selected item and remove it
    int iSelected = ListView_GetNextItem(m_hPVCList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(m_hPVCList, &lvItem))
        {
            CPvcInfo * pPvcInfo = NULL;

            pPvcInfo = reinterpret_cast<CPvcInfo *>(lvItem.lParam);

            if (pPvcInfo)
            {
                CPvcInfo * pDlgPvcInfo = new CPvcInfo(pPvcInfo->m_strPvcId.c_str());

                if (pDlgPvcInfo)
                {
					*pDlgPvcInfo = *pPvcInfo;

					CPVCMainDialog * pPvcMainDlg = new CPVCMainDialog(this, pDlgPvcInfo,
  																	g_aHelpIDs_IDD_PVC_Main);

					if (pPvcMainDlg->DoModal() == IDOK)
					{
						// update PVC info
						*pPvcInfo = *pDlgPvcInfo;

						// update the list view
						UpdatePvc(pDlgPvcInfo, iSelected);

						// set the new state of the Add\Remove\Property buttons
						SetButtons();

						if (pPvcMainDlg->m_fDialogModified)
							PageModified();
					}

					delete pDlgPvcInfo;

					delete pPvcMainDlg;
				}
            }
        }
    }
    else // no current selection
    {
        NcMsgBox(::GetActiveWindow(), IDS_MSFT_UNI_TEXT, IDS_NO_ITEM_SELECTED,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
    }
    return 0;
}

LRESULT CUniPage::OnRemovePVC(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    // get the selected PVC, make a copy and pass to the dialog
    int iSelected = ListView_GetNextItem(m_hPVCList, -1, LVNI_SELECTED);

    if (iSelected != -1)
    {
        LV_ITEM lvItem;
        lvItem.mask = LVIF_PARAM;
        lvItem.iItem = iSelected;
        lvItem.iSubItem = 0;

        if (ListView_GetItem(m_hPVCList, &lvItem))
        {
            CPvcInfo * pPvcInfo = NULL;

            pPvcInfo = reinterpret_cast<CPvcInfo *>(lvItem.lParam);
            if (pPvcInfo)
            {
                // mark as deleted
                pPvcInfo->m_fDeleted = TRUE;

                // delete from list view
                ListView_DeleteItem(m_hPVCList, iSelected);
            }
        }

        SetButtons();
        PageModified();
    }

    return 0;
}

LRESULT CUniPage::OnPVCListChange(WORD wNotifyCode, WORD wID,
                                  HWND hWndCtl, BOOL& bHandled)
{
    return 0;
}

void CUniPage::InsertNewPvc(CPvcInfo * pPvcInfo, int idx)
{
    LV_ITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT | LVIF_PARAM;

    int ret;

    // name
    lvItem.iItem = idx;
    lvItem.iSubItem=0;
    lvItem.lParam = reinterpret_cast<LPARAM>(pPvcInfo);
    lvItem.pszText = (PWSTR)(pPvcInfo->m_strName.c_str());

    ret = ListView_InsertItem(m_hPVCList, &lvItem);

    // VPI
    lvItem.iItem = idx;
    lvItem.iSubItem=1;

    WCHAR szVpi[MAX_VPI_LENGTH];
    wsprintfW(szVpi, c_szItoa, pPvcInfo->m_dwVpi);
    lvItem.pszText = szVpi;

    SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VCI
    lvItem.iItem = idx;
    lvItem.iSubItem=2;

    WCHAR szVci[MAX_VCI_LENGTH];
    wsprintfW(szVci, c_szItoa, pPvcInfo->m_dwVci);
    lvItem.pszText = szVci;

    SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);
}

void CUniPage::UpdatePvc(CPvcInfo * pPvcInfo, int idx)
{
    LV_ITEM lvItem = {0};
    lvItem.mask = LVIF_TEXT;

    LRESULT ret;

    // name
    lvItem.iItem = idx;
    lvItem.iSubItem=0;
    lvItem.pszText = (PWSTR)(pPvcInfo->m_strName.c_str());

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VPI
    lvItem.iItem = idx;
    lvItem.iSubItem=1;

    WCHAR szVpi[MAX_VPI_LENGTH];
    wsprintfW(szVpi, c_szItoa, pPvcInfo->m_dwVpi);
    lvItem.pszText = szVpi;

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);

    // VCI
    lvItem.iItem = idx;
    lvItem.iSubItem=2;

    WCHAR szVci[MAX_VCI_LENGTH];
    wsprintfW(szVci, c_szItoa, pPvcInfo->m_dwVci);
    lvItem.pszText = szVci;

    ret = SendDlgItemMessage(IDC_LVW_PVC_LIST, LVM_SETITEMTEXT, idx, (LPARAM)&lvItem);
}

void CUniPage::SetButtons()
{
    int nCount = ListView_GetItemCount(m_hPVCList);

    if (nCount == 0)
        ::SetFocus(m_hPVCList);

    ::EnableWindow(GetDlgItem(IDC_PBN_PVC_Remove), nCount);
    ::EnableWindow(GetDlgItem(IDC_PBN_PVC_Properties), nCount);

}

void CUniPage::GetNewPvcId(CUniAdapterInfo * pAdapterInfo,
                           tstring * pstrNewPvcId)
{
    Assert(pstrNewPvcId);

    tstring strPvcId;
    WCHAR szPvcId[c_nMAX_PVC_ID_LEN];

    int uiPvcNum = pAdapterInfo->m_listPVCs.size();
    _itow(uiPvcNum, szPvcId, 10);
    strPvcId = c_szPVC;
    strPvcId += szPvcId;

    while (!IsUniquePvcId(pAdapterInfo, strPvcId))
    {
        uiPvcNum++;
        _itow(uiPvcNum, szPvcId, 10);
        strPvcId = c_szPVC;
        strPvcId += szPvcId;
    }

    *pstrNewPvcId = strPvcId;
}

BOOL CUniPage::IsUniquePvcId(CUniAdapterInfo * pAdapterInfo,
                             tstring& strNewPvcId)
{
    BOOL fUnique = TRUE;

    for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
         iterPvcInfo != pAdapterInfo->m_listPVCs.end();
         iterPvcInfo++)
    {
        if (strNewPvcId == (*iterPvcInfo)->m_strName)
        {
            fUnique = FALSE;
            break;
        }
    }
    return fUnique;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\aunidlg.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I D L G . H
//
//  Contents:   ATMUNI call manager dialogbox message handler declaration
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------
#pragma once
#include "ncxbase.h"
#include "ncatlps.h"

class CPvcInfo;

const WCHAR c_szItoa[] = L"%d";

const int MAX_VPI_LENGTH = 3;
const int MAX_VCI_LENGTH = 4;

void InitComboWithStringArray(HWND hwndDlg, int nIDDlgItem,
                              int csid, const int*  asid);

void SetDwordEdtField(HWND hDlg, DWORD dwData, int nIDDlgItem);
void GetDwordEdtField(HWND hDlg, DWORD * pdwData, int nIDDlgItem);

void ShowContextHelp(HWND hDlg, UINT uCommand, const DWORD*  pdwHelpIDs);

// ATM UNI Property Dialog
class CUniPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CUniPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Message handlers for the push buttons
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Add, OnAddPVC)
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Remove, OnRemovePVC)
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Properties, OnPVCProperties)

        // Message handlers for the PVC list view
        COMMAND_ID_HANDLER(IDC_LVW_PVC_LIST, OnPVCListChange)
    END_MSG_MAP()

    // Constructors/Destructors
    CUniPage(CAtmUniCfg * pAtmUniCfg, const DWORD * padwHelpIDs = NULL);
    ~CUniPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // command handlers
    LRESULT OnAddPVC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemovePVC(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnPVCProperties(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT OnPVCListChange(WORD wNotifyCode, WORD wID,
                            HWND hWndCtl, BOOL& bHandled);

private:
    BOOL IsModified() {return m_fModified;}
    void SetModifiedTo(BOOL bState) {m_fModified = bState;}

    void PageModified() {
                            m_fModified = TRUE;
                            PropSheet_Changed(GetParent(), m_hWnd);
                        }

    void SetButtons();
    void GetNewPvcId(CUniAdapterInfo * pAdapterInfo, tstring * pstrNewPvcId);
    BOOL IsUniquePvcId(CUniAdapterInfo * pAdapterInfo, tstring& strNewPvcId);

    void InsertNewPvc(CPvcInfo * pPvcInfo, int idx);
    void UpdatePvc(CPvcInfo * pPvcInfo, int idx);

    int CheckDupPvcId();

    // data members
    CAtmUniCfg *m_patmunicfg;
    CUniAdapterInfo *   m_pAdapterInfo;
    HWND    m_hPVCList;

    BOOL            m_fModified;
    const DWORD*    m_adwHelpIDs;
};

// The main PVC dialog
class CPVCMainDialog : public CDialogImpl<CPVCMainDialog>
{
public:

    enum { IDD = IDD_PVC_Main };

    BEGIN_MSG_MAP(CPVCMainDialog)
        MESSAGE_HANDLER(WM_INITDIALOG,  OnInitDialog);
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);

        COMMAND_ID_HANDLER(IDOK,        OnOk);
        COMMAND_ID_HANDLER(IDCANCEL,    OnCancel);

        COMMAND_ID_HANDLER(IDC_CMB_PVC_Type,        OnType);
        COMMAND_ID_HANDLER(IDC_CHK_PVC_CallAddr,    OnSpecifyCallAddr);
        COMMAND_ID_HANDLER(IDC_CHK_PVC_AnswerAddr,  OnSpecifyAnswerAddr);
        COMMAND_ID_HANDLER(IDC_PBN_PVC_Advanced,    OnAdvanced);

    END_MSG_MAP()

public:

    CPVCMainDialog(CUniPage * pUniPage,
                   CPvcInfo *  pPvcInfo,
                   const DWORD* padwHelpIDs = NULL);
    ~CPVCMainDialog();

// Dialog creation overrides
public:

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

    LRESULT OnType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSpecifyCallAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnSpecifyAnswerAddr(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnAdvanced(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

public:
    BOOL    m_fDialogModified;

    BOOL    m_fPropShtOk;
    BOOL    m_fPropShtModified;

private:

    // The PVC we are adding or modifying
    CPvcInfo *   m_pPvcInfo ;

    // The current application type of the PVC
    PVCType m_CurType;

    // We save the pointer to the parent dialog
    CUniPage *      m_pParentDlg;
    const DWORD*    m_adwHelpIDs;

    class CPvcQosPage   * m_pQosPage;
    class CPvcLocalPage * m_pLocalPage;
    class CPvcDestPage  * m_pDestPage;

    // help functions
    void InitInfo();
    void SetInfo();

    void UpdateInfo();

    HRESULT HrDoPvcPropertySheet(CPvcInfo * pPvcInfoDlg);
    HRESULT HrSetupPropPages(CPvcInfo * pPvcInfoDlg, HPROPSHEETPAGE ** pahpsp, INT * pcPages);
};

class CPvcQosPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcQosPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)
    END_MSG_MAP()

    // Constructors/Destructors
    CPvcQosPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcQosPage();

public:
    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

private:
    void SetQosServiceCategory(ATM_SERVICE_CATEGORY dwServiceType, int nIDDlgItem);
    void GetQosServiceCategory(ATM_SERVICE_CATEGORY * pdwServiceType, int nIDDlgItem);

    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};

class CPvcLocalPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcLocalPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control notification handlers
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer2,      OnLayer2);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer3,      OnLayer3);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_High_Type,   OnHighLayer);

    END_MSG_MAP()

    // Constructors/Destructors
    CPvcLocalPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcLocalPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

    // Control notification handlers
    LRESULT OnLayer2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLayer3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnHighLayer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:
    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};

class CPvcDestPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CPvcDestPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
        MESSAGE_HANDLER(WM_HELP, OnHelp)

        // Property page notification message handlers
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
        NOTIFY_CODE_HANDLER(PSN_SETACTIVE, OnActive)
        NOTIFY_CODE_HANDLER(PSN_RESET, OnCancel)

        // Control notification handlers
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer2,      OnLayer2);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_Layer3,      OnLayer3);
        COMMAND_ID_HANDLER(IDC_CMB_PVC_High_Type,   OnHighLayer);
    END_MSG_MAP()

    // Constructors/Destructors
    CPvcDestPage(CPVCMainDialog * pParentDlg, CPvcInfo * pPvcInfo, const DWORD * padwHelpIDs = NULL);
    ~CPvcDestPage();

    // Command handlers
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

    // notify handlers for the property page
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);

     // Control notification handlers
    LRESULT OnLayer2(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnLayer3(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);
    LRESULT OnHighLayer(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& fHandled);

private:

    // data
    CPVCMainDialog * m_pParentDlg;
    CPvcInfo    *    m_pPvcInfo;
    const DWORD *    m_adwHelpIDs;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\aunifunc.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I F U N C . C P P
//
//  Contents:   CAtmUniCfg help member function implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "aunidlg.h"
#include "atmutil.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncatlui.h"
//#include "ncui.h"

#include "netconp.h"
#include "atmhelp.h"

extern const WCHAR c_szAdapters[];

//
// Load cards on bind path to m_listAdapters on Initialize
//
HRESULT CAtmUniCfg::HrLoadSettings()
{
    HRESULT hr = S_OK;

    CIterNetCfgBindingPath      ncbpIter(m_pnccUni);
    INetCfgBindingPath *        pncbp;

    // Go through all binding paths in search of uni call mgr to netcard bindings
    while(SUCCEEDED(hr) && (hr = ncbpIter.HrNext(&pncbp)) == S_OK)
    {
        INetCfgComponent * pnccNetComponent;
        hr = HrGetLastComponentAndInterface(pncbp,
                                            &pnccNetComponent,
                                            NULL);
        if SUCCEEDED(hr)
        {
            Assert(pnccNetComponent);

            // The last component should be of NET CLASS
            GUID    ClassGuid;

            // What type is it?
            hr = pnccNetComponent->GetClassGuid(&ClassGuid);
            if (SUCCEEDED(hr))
            {
                // Is it a netcard?
                if (IsEqualGUID(ClassGuid, GUID_DEVCLASS_NET))
                {
                    hr = HrAddAdapter(pnccNetComponent);

                    if (SUCCEEDED(hr))
                    {
                        // Is the binding enabled ??
                        hr = pncbp->IsEnabled();

                        // hr == S_OK if the card is enabled (ie: bound)
                        if (S_OK == hr)
                        {   // bind the card in our data strucutres
                            hr = HrBindAdapter(pnccNetComponent);
                        }
                        else if (S_FALSE == hr)
                        {
                            hr = HrUnBindAdapter(pnccNetComponent);
                        }
                    }
                }
            }

            ReleaseObj(pnccNetComponent);
        }
        ReleaseObj(pncbp);
    }
    AssertSz(!pncbp, "BindingPath wasn't released");

    if (hr == S_FALSE) // We just got to the end of the loop
        hr = S_OK;

    TraceError("CAtmUniCfg::HrLoadSettings", hr);
    return hr;
}

//
// Update registry with info in m_listAdapters on Apply
//
HRESULT CAtmUniCfg::HrSaveSettings()
{
    HRESULT hr = S_OK;
    HKEY hkeyUniParam = NULL;

    hr = m_pnccUni->OpenParamKey(&hkeyUniParam);

    if SUCCEEDED(hr)
    {
        HKEY hkeyAdapters = NULL;
        DWORD dwDisposition;

        // Create or open the "Adapters" key under "Services\Atmuni\Parameters"
        hr = HrRegCreateKeyEx(hkeyUniParam,
                              c_szAdapters,
                              REG_OPTION_NON_VOLATILE,
                              KEY_ALL_ACCESS,
                              NULL,
                              &hkeyAdapters,
                              &dwDisposition);

        if SUCCEEDED(hr)
        {
            Assert(hkeyAdapters);
            HRESULT hrTmp = S_OK;

            if (dwDisposition == REG_OPENED_EXISTING_KEY)
            { // if the "adapters" key existed, there might be some old cards
              // Cleanup subkeys for adapters that are not in our memory structure

                VECSTR vstrAdapters;
                hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapters, &vstrAdapters);

                if SUCCEEDED(hrTmp)
                {
                    for (VECSTR::iterator iterRegKey = vstrAdapters.begin();
                         iterRegKey != vstrAdapters.end();
                         iterRegKey ++)
                    {
                        BOOL fFound = FALSE;
                        for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                             iterAdapter != m_listAdapters.end();
                             iterAdapter ++)
                        {
                            if ((*iterAdapter)->m_strBindName == (*iterRegKey)->c_str())
                            {
                                fFound = TRUE;
                                break;
                            }
                        }

                        if ((!fFound) ||
                            ( fFound && ((*iterAdapter)->m_fDeleted)))
                        {
                            hrTmp = HrRegDeleteKeyTree(hkeyAdapters,
                                                       (*iterRegKey)->c_str());
                            if SUCCEEDED(hr)
                                hr = hrTmp;
                        }
                    }
                }
            }

            // Save adapter info in memory state to registry
            for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {

                if ((*iterAdapter)->m_fDeleted)
                    continue;

                HKEY    hkeyAdapterParam;

                // Create specific card bindname key under
                // "Services\Atmuni\Parameters\Adapters\<card bind name>"
                hrTmp = HrRegCreateKeyEx(hkeyAdapters,
                                         (*iterAdapter)->m_strBindName.c_str(),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         NULL,
                                         &hkeyAdapterParam,
                                         &dwDisposition);
                if(SUCCEEDED(hrTmp))
                    hr = hrTmp;

                if(SUCCEEDED(hrTmp))
                {

                #if 0
                    // $REVIEW(tongl 4/27/98): Per ArvindM, we should no longer
                    // write these to registry.

                    // save defaults for SVC parameters for new adapters
                    if (dwDisposition != REG_OPENED_EXISTING_KEY)
                    {
                        hrTmp = HrSaveDefaultSVCParam(hkeyAdapterParam);

                        if SUCCEEDED(hr)
                            hr = hrTmp;
                    }
                #endif

                    // Now update any PVC parameters
                    // Only need to update PVC parameters for the Adapter of the
                    // current connection, and if changes are made through the UI
                    if (m_fUIParamChanged)
                    {
                        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
                        {
                            if ((*iterAdapter)->m_listPVCs.size() > 0)
                            {
                                hrTmp = HrSaveAdapterPVCRegistry(hkeyAdapterParam, *iterAdapter);
                                if SUCCEEDED(hr)
                                    hr = hrTmp;
                            }
                        }
                    }
                }
                RegSafeCloseKey(hkeyAdapterParam);
            }
        }
        RegSafeCloseKey(hkeyAdapters);
    }
    RegSafeCloseKey(hkeyUniParam);

    TraceError("CAtmUniCfg::HrSaveSettings", hr);
    return hr;
}

// Adding a card
HRESULT CAtmUniCfg::HrAddAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(pAdapterInfo->m_fDeleted, "Trying to add a card that already exists on binding path");
        pAdapterInfo->m_fDeleted = FALSE;
    }
    else  // Add a new item
    {
        // create a new item
        m_listAdapters.push_back(new CUniAdapterInfo);
        m_listAdapters.back()->SetDefaults(pszwBindName);
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrAddAdapter", hr);
    return hr;
}

// Removing a card
HRESULT CAtmUniCfg::HrRemoveAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz( SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to remove a card that does not exists on binding path");
    }
    else  // remove the card
    {
        // mark the adapter as for removal
        pAdapterInfo->m_fDeleted = TRUE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrRemoveAdapter", hr);
    return hr;
}

// Set binding state to enabled
HRESULT CAtmUniCfg::HrBindAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to bind a card that does not exists on binding path");
    }
    else  // bind the adapter
    {
        pAdapterInfo->m_BindingState = BIND_ENABLE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrBindAdapter", hr);
    return hr;
}

// Set binding state to disabled
HRESULT CAtmUniCfg::HrUnBindAdapter(INetCfgComponent * pnccAdapter)
{
    PWSTR pszwBindName = NULL;
    HRESULT hr = pnccAdapter->GetBindName(&pszwBindName);

    AssertSz(SUCCEEDED(hr), "Net card on binding path with no bind path name!!");

    CUniAdapterInfo * pAdapterInfo = NULL;
    if (!fIsAdapterOnList(pszwBindName, &pAdapterInfo))
    {
        AssertSz(FALSE, "Trying to unbind a card that does not exists on binding path");
    }
    else  // unbind the adapter
    {
        pAdapterInfo->m_BindingState = BIND_DISABLE;
    }

    CoTaskMemFree(pszwBindName);

    TraceError("CAtmUniCfg::HrUnBindAdapter", hr);
    return hr;
}

//
// Save default values of non-configurable params to registry
//
HRESULT CAtmUniCfg::HrSaveDefaultSVCParam(HKEY hkey)
{
    HRESULT hr = S_OK;

    PRODUCT_FLAVOR pf;
    // NT server and workstation has different default values
    GetProductFlavor(NULL, &pf);
    AssertSz( ((pf == PF_WORKSTATION) || (pf == PF_SERVER)),
              "Invalid product flavor.");

    HRESULT hrTmp = S_OK;
    switch (pf)
    {
    case PF_WORKSTATION:
        hr = HrRegSetDword(hkey,c_szMaxActiveSVCs,c_dwWksMaxActiveSVCs);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxSVCsInProgress,c_dwWksMaxSVCsInProgress);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPMPSVCs,c_dwWksMaxPMPSVCs);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxActiveParties,c_dwWksMaxActiveParties);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPartiesInProgress,c_dwWksMaxPartiesInProgress);
        if SUCCEEDED(hr)
            hr = hrTmp;

        break;

    case PF_SERVER:
        hr = HrRegSetDword(hkey,c_szMaxActiveSVCs,c_dwSrvMaxActiveSVCs);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxSVCsInProgress,c_dwSrvMaxSVCsInProgress);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPMPSVCs,c_dwSrvMaxPMPSVCs);
        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxActiveParties,c_dwSrvMaxActiveParties);

        if SUCCEEDED(hr)
            hr = hrTmp;

        hr = HrRegSetDword(hkey,c_szMaxPartiesInProgress,c_dwSrvMaxPartiesInProgress);
        if SUCCEEDED(hr)
            hr = hrTmp;

        break;
    }

    TraceError("CAtmUniCfg::HrSaveDefaultSVCParam", hr);
    return hr;
}

// Checks if a card is on m_listAdapters
BOOL CAtmUniCfg::fIsAdapterOnList(PCWSTR pszBindName, CUniAdapterInfo ** ppAdapterInfo)
{

    BOOL fRet = FALSE;
    *ppAdapterInfo = NULL;

    for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
         iterAdapter != m_listAdapters.end();
         iterAdapter ++)
    {
        if ((*iterAdapter)->m_strBindName == pszBindName)
        {
            fRet = TRUE;
            *ppAdapterInfo = *iterAdapter;

            break;
        }
    }

    return fRet;
}

// Called by CAtmUniCfg::MergePropPages
// Set the context in which the UI is brought up
HRESULT CAtmUniCfg::HrSetConnectionContext()
{
    AssertSz(m_pUnkContext, "Invalid IUnknown pointer passed to CAtmUniCfg::SetContext?");

    if (!m_pUnkContext)
        return E_FAIL;

    HRESULT hr = S_OK;
    GUID guidConn;

    // Is this a lan connection ?
    INetLanConnectionUiInfo * pLanConnUiInfo;
    hr = m_pUnkContext->QueryInterface( IID_INetLanConnectionUiInfo,
                                        reinterpret_cast<LPVOID *>(&pLanConnUiInfo));
    if (SUCCEEDED(hr))
    {
        // yes, lan connection
        pLanConnUiInfo->GetDeviceGuid(&guidConn);
        ReleaseObj(pLanConnUiInfo);

        WCHAR szGuid[c_cchGuidWithTerm];

        BOOL fSucceeded = StringFromGUID2(guidConn,
                                          szGuid,
                                          c_cchGuidWithTerm);
        Assert(fSucceeded);
        m_strGuidConn = szGuid;
    }

    TraceError("CAtmUniCfg::HrSetConnectionContext", hr);
    return hr;
}


// Called by CAtmUniCfg::MergePropPages
// Inits the prop sheet page objects and creates the pages to be returned to
// the installer object.
HRESULT CAtmUniCfg::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT * pcPages)
{
    HRESULT hr = S_OK;

    // initialize output parameters
    *pahpsp = NULL;
    *pcPages = 0;

    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    m_fSecondMemoryModified = FALSE;

    // If PVC info has not been read from registry yet, load them
    if (!m_fPVCInfoLoaded)
    {
        hr = HrLoadPVCRegistry();
        m_fPVCInfoLoaded = TRUE;
    }

    if SUCCEEDED(hr)
    {
        // Copy PVC info of the corrent adapter to second memory
        hr = HrLoadAdapterPVCInfo();
    }

    // If we have found the matching adapter
    if SUCCEEDED(hr)
    {
        cPages = 1;

        delete m_uniPage;
        m_uniPage = new CUniPage(this, g_aHelpIDs_IDD_UNI_PROP);

        // Allocate a buffer large enough to hold the handles to all of our
        // property pages.
        ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                                 * cPages);
        if (!ahpsp)
        {
            hr = E_OUTOFMEMORY;
            goto err;
        }

        cPages =0;
        ahpsp[cPages++] = m_uniPage->CreatePage(IDD_UNI_PROP, 0);

        *pahpsp = ahpsp;
        *pcPages = cPages;
    }
    else // if the adapter is not bound, pop-up message box and don't show UI
    {
        NcMsgBox(::GetActiveWindow(),
                 IDS_MSFT_UNI_TEXT,
                 IDS_UNI_NO_BOUND_CARDS,
                 MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        AssertSz((0== *pcPages), "Invalid page number when no bound cards");
        AssertSz((NULL == *pahpsp), "Invalid page array pointer when no bound cards");
    }

err:

    TraceError("CAtmUniCfg::HrSetupPropSheets", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\auniobj.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I O B J . C P P
//
//  Contents:   CAtmUniCfg interface method function implementation
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop
#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "ncstl.h"

#include "aunidlg.h"
#include "netconp.h"

#include "ncpnp.h"

static const WCHAR c_szAtmuni[] = L"Atmuni";

extern const WCHAR c_szInfId_MS_RawWan[];

/////////////////////////////////////////////////////////////////////////////
//

CAtmUniCfg::CAtmUniCfg()
: m_pnc(NULL),
  m_pnccUni(NULL),
  m_pnccRwan(NULL),
  m_fSaveRegistry(FALSE),
  m_fUIParamChanged(FALSE),
  m_fSecondMemoryModified(FALSE),
  m_fPVCInfoLoaded(FALSE),
  m_strGuidConn(c_szEmpty),
  m_pUnkContext(NULL),
  m_pSecondMemoryAdapterInfo(NULL),
  m_uniPage(NULL)
{
}

CAtmUniCfg::~CAtmUniCfg()
{
    ReleaseObj(m_pnc);
    ReleaseObj(m_pnccUni);
    ReleaseObj(m_pnccRwan);
    FreeCollectionAndItem(m_listAdapters);

    // Just a safty check to make sure the context is released.
    AssertSz((m_pUnkContext == NULL), "Why is context not released ? Not a bug in ATM UNI config.");
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext) ;

    delete m_uniPage;
}


// INetCfgComponentControl
STDMETHODIMP CAtmUniCfg::Initialize (INetCfgComponent* pncc,
                                     INetCfg* pNetCfg,
                                     BOOL fInstalling )
{
    HRESULT hr = S_OK;

    Validate_INetCfgNotify_Initialize(pncc, pNetCfg, fInstalling);

    AssertSz(pNetCfg, "NetCfg pointer is NULL!");

    m_pnc = pNetCfg;
    AddRefObj(m_pnc);

    AssertSz(pncc, "Component pointer is NULL!");

    m_pnccUni = pncc;
    AddRefObj(m_pnccUni);

    // Get a copy of the ATMRwan and store in our object
    hr = m_pnc->FindComponent(c_szInfId_MS_RawWan, &m_pnccRwan);

    if (S_FALSE == hr) // RWan not found
    {
        if (!fInstalling) // Trace the error, RWan should be installed
        {
            TraceError("CAtmUniCfg::Initialize - ATMRwan has not been installed yet", hr);
        }
        else // We are ok since ATMUNI will install ATMRwan
        {
            hr = S_OK;
        }
    }

    // Construct the in memory structure (m_listAdapters) by
    // iterating through the binding path
    if (!fInstalling)
    {
        hr = HrLoadSettings();
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CAtmUniCfg::Initialize", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::Validate ()
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    if (m_fSaveRegistry)
    {
        hr = HrSaveSettings();

        if (SUCCEEDED(hr) && m_fUIParamChanged)
        {
            // send reconfig notification if parameter has changed
            for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
                 iterAdapter != m_listAdapters.end();
                 iterAdapter ++)
            {
                if ((*iterAdapter)->m_fDeleted)
                    continue;

                if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
                {
                    HRESULT hrReconfig;

                    hrReconfig  = HrSendNdisPnpReconfig(NDIS, c_szAtmuni,
                                                        (*iterAdapter)->m_strBindName.c_str(),
                                                        NULL, 0);
                    if (FAILED(hrReconfig))
                    {
                        TraceTag(ttidAtmUni,"Notifying Atm UNI Call manager of parameter change returns failure, prompt for reboot ...");
                        hr = NETCFG_S_REBOOT;
                    }
                    break;
                }
            }
        }
    }
    else
    {
        // no change
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CAtmUniCfg::ApplyRegistryChanges", (S_FALSE == hr)? S_OK : hr);
    return hr;
}

// INetCfgComponentSetup
STDMETHODIMP CAtmUniCfg::Install (DWORD dwSetupFlags)
{
    m_fSaveRegistry = TRUE;

    // Just in case it was installed already, we need to release
    // m_pnccRwan before we overwrite it.
    //
    ReleaseObj (m_pnccRwan);

    // Install the ATM Rawwan protocol on behalf of ATMUNI
    HRESULT hr = HrInstallComponentOboComponent( m_pnc, NULL,
                                                 GUID_DEVCLASS_NETTRANS,
                                                 c_szInfId_MS_RawWan,
                                                 m_pnccUni,
                                                 &m_pnccRwan);

    TraceError("CAtmUniCfg::Install", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::Upgrade(DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo )
{
    return S_FALSE;
}

STDMETHODIMP CAtmUniCfg::ReadAnswerFile(PCWSTR pszAnswerFile,
                                        PCWSTR pszAnswerSection)
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::Removing ()
{
    // Remove ATMRwan protocol
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                               GUID_DEVCLASS_NETTRANS,
                                               c_szInfId_MS_RawWan,
                                               m_pnccUni);

    TraceError("CAtmUniCfg::Removing", hr);
    return hr;
}

// INetCfgBindNotify

STDMETHODIMP CAtmUniCfg::QueryBindingPath (DWORD dwChangeFlag,
                                           INetCfgBindingPath* pncbpItem )
{
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::NotifyBindingPath (DWORD dwChangeFlag,
                                            INetCfgBindingPath* pncbp )
{
    Assert(!(dwChangeFlag & NCN_ADD && dwChangeFlag & NCN_REMOVE));
    Assert(!(dwChangeFlag & NCN_ENABLE && dwChangeFlag & NCN_DISABLE));

    // If we are told to add a card, we must be told at the same time whether the
    // binding is enabled or disabled
    Assert(FImplies((dwChangeFlag & NCN_ADD),
                    ((dwChangeFlag & NCN_ENABLE)||(dwChangeFlag & NCN_DISABLE))));

    // We handle NCN_ADD and NCN_REMOVE only (for Beta1):
    // NCN_ADD:     if item not on list, add a new item
    // NCN_REMOVE:  if item already on list, remove the item

    HRESULT hr = S_OK;

    Validate_INetCfgBindNotify_NotifyBindingPath (dwChangeFlag,pncbp);

    INetCfgComponent * pnccLastComponent;
    hr = HrGetLastComponentAndInterface(pncbp,
            &pnccLastComponent, NULL);

    if SUCCEEDED(hr)
    {
        GUID guidNetClass;
        hr = pnccLastComponent->GetClassGuid (&guidNetClass);

        AssertSz(IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET),
            "Why the last component on the path is not an adapter?");

        // Is this a net card ?
        if (SUCCEEDED(hr) && IsEqualGUID(guidNetClass, GUID_DEVCLASS_NET))
        {
            // If we are adding/removing cards, set m_fSaveRegistry
            // so we apply the changes to registry

            if (dwChangeFlag & NCN_ADD)
            {
                hr = HrAddAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_ENABLE)
            {
                hr = HrBindAdapter(pnccLastComponent);
            }

            if(dwChangeFlag & NCN_DISABLE)
            {
                hr = HrUnBindAdapter(pnccLastComponent);
            }

            if (dwChangeFlag & NCN_REMOVE)
            {
                hr = HrRemoveAdapter(pnccLastComponent);
            }
        }
        ReleaseObj (pnccLastComponent);
    }
    Validate_INetCfgBindNotify_NotifyBindingPath_Return(hr);

    TraceError("CAtmUniCfg::NotifyBindingPath", hr);
    return hr;
}

// INetCfgProperties
STDMETHODIMP CAtmUniCfg::QueryPropertyUi (IUnknown* pUnk)
{
    HRESULT hr = S_FALSE;
    if (pUnk)
    {
        // Is this a lan connection ?
        INetLanConnectionUiInfo * pLanConnUiInfo;
        hr = pUnk->QueryInterface( IID_INetLanConnectionUiInfo,
                                   reinterpret_cast<LPVOID *>(&pLanConnUiInfo));

        if(FAILED(hr))
        {
            hr = S_FALSE;
        }
    }

    TraceError("CAtmUniCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::SetContext(IUnknown * pUnk)
{
    HRESULT hr = S_OK;

    // release previous context, if any
    if (m_pUnkContext)
        ReleaseObj(m_pUnkContext);
    m_pUnkContext = NULL;

    if (pUnk) // set the new context
    {
        m_pUnkContext = pUnk;
        m_pUnkContext->AddRef();
    }

    TraceError("CArpsCfg::SetContext", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::MergePropPages (
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)

{
    HRESULT hr = S_OK;

    // Initialize output parameter
    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    // We don't want any default pages to be shown
    *pdwDefPages = 0;
    *pcPages = NULL;
    *pahpspPrivate = NULL;

    // get the connection context in which we are bringing up the UI
    hr = HrSetConnectionContext();

    if SUCCEEDED(hr)
    {
        // Initialize the common controls library
        INITCOMMONCONTROLSEX icc;
        icc.dwSize = sizeof(icc);
        icc.dwICC  = ICC_INTERNET_CLASSES;

        SideAssert(InitCommonControlsEx(&icc));

        hr = HrSetupPropSheets(&ahpsp, &cPages);
        if (SUCCEEDED(hr))
        {
            *pahpspPrivate = (LPBYTE)ahpsp;
            *pcPages = cPages;
        }
        else
        {
            *pcPages = 0;
            CoTaskMemFree(ahpsp);
        }
    }
    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CAtmUniCfg::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CAtmUniCfg::ValidateProperties (HWND hwndSheet)
{
    // all error checking are done in the UI
    return S_OK;
}

STDMETHODIMP CAtmUniCfg::CancelProperties ()
{
    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    return S_OK;
}

STDMETHODIMP CAtmUniCfg::ApplyProperties ()
{
    HRESULT hr = S_OK;

    if(!m_fSaveRegistry)
        m_fSaveRegistry = m_fSecondMemoryModified;

    if(!m_fUIParamChanged)
        m_fUIParamChanged = m_fSecondMemoryModified;

    // Copy info from second memory state to first memory state
    if (m_fSecondMemoryModified)
    {
        hr = HrSaveAdapterPVCInfo();
    }

    // Release second memory info
    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    Validate_INetCfgProperties_ApplyProperties_Return(hr);

    TraceError("CAtmUniCfg::ApplyProperties", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\pvcdata.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D A T A. C P P
//
//  Contents:   PVC parameters
//
//  Notes:
//
//  Author:     tongl   20 Feb, 1998
//
//-----------------------------------------------------------------------
#include "pch.h"
#pragma hdrstop

#include "arpsobj.h"
#include "auniobj.h"
#include "atmutil.h"
#include "ncstl.h"
#include "pvcdata.h"

#include "ncreg.h"

extern const WCHAR c_szAdapters[];

void SetPvcDwordParam(HKEY hkeyAdapterPVCId,
                      PCWSTR pszParamName,
                      DWORD dwParam)
{
    HRESULT hrTmp;

    if (FIELD_UNSET == dwParam)
    {
        // delete the value
        hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                 pszParamName);
    }
    else
    {
        // save the value
        hrTmp = HrRegSetDword(hkeyAdapterPVCId, pszParamName, dwParam);
    }

    TraceTag(ttidAtmUni, "SetPvcDword Failed on %S", pszParamName);
}

void SetPvcBinaryParamFromString(HKEY hkeyAdapterPVCId,
                                 PCWSTR pszParamName,
                                 PCWSTR pszData)
{
    HRESULT hrTmp;

    if (!(*pszData)) // empty string
    {
        // delete the value
        hrTmp = HrRegDeleteValue(hkeyAdapterPVCId, pszParamName);
    }
    else
    {
        // convert to binary
        BYTE * pbData = NULL;
        DWORD  cbData = 0;

        ConvertHexStringToBinaryWithAlloc(pszData, &pbData, &cbData);

        // save the value
        hrTmp = HrRegSetBinary(hkeyAdapterPVCId, pszParamName, pbData, cbData);

        delete pbData;
    }

    TraceTag(ttidAtmUni, "SetPvcBinaryParamFromString Failed on %S", pszParamName);
}

// Load PVC settings for the current adapter from registry to first memory
HRESULT CAtmUniCfg::HrLoadPVCRegistry()
{
    HRESULT hr = S_OK;

    HKEY hkeyUniParam;
    hr = m_pnccUni->OpenParamKey(&hkeyUniParam);
    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        Assert(hkeyUniParam);

        // find the adapter we want to load
        for (UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
             iterAdapter != m_listAdapters.end();
             iterAdapter ++)
        {
            if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
            {
                // found the adapter we want to load ...
                // open the adapters subkey
                HKEY    hkeyAdapters = NULL;
                hr = HrRegOpenKeyEx(hkeyUniParam, c_szAdapters,
                                    KEY_READ, &hkeyAdapters);

                if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                    hr = S_OK;
                else if(SUCCEEDED(hr))
                {
                    Assert(hkeyAdapters);
                    HKEY hkeyAdapterParam = NULL;
                    hr = HrRegOpenKeyEx(hkeyAdapters,
                                        (*iterAdapter)->m_strBindName.c_str(),
                                        KEY_READ, &hkeyAdapterParam);

                    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                        hr = S_OK;
                    else if(SUCCEEDED(hr))
                    {
                        Assert(hkeyAdapterParam);
                        HrLoadAdapterPVCRegistry(hkeyAdapterParam, *iterAdapter);
                    }
                    RegSafeCloseKey(hkeyAdapterParam);
                }
                RegSafeCloseKey(hkeyAdapters);
                break;
            }
        }
    }
    RegSafeCloseKey(hkeyUniParam);

    TraceError("CAtmUniCfg::HrLoadPVCRegistry", hr);
    return hr;
}

HRESULT CAtmUniCfg::HrLoadAdapterPVCRegistry(HKEY hkeyAdapterParam,
                                             CUniAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    Assert(hkeyAdapterParam);
    Assert(pAdapterInfo);

    // there should not have been any PVC on the list
    Assert(pAdapterInfo->m_listPVCs.size() ==0);

    // open the PVC subkey and enumerate the PVCs under that
    HKEY hkeyAdapterPVC = NULL;
    hr = HrRegOpenKeyEx(hkeyAdapterParam,
                        c_szPVC,
                        KEY_READ,
                        &hkeyAdapterPVC);

    if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
        hr = S_OK;
    else if(SUCCEEDED(hr))
    {
        Assert(hkeyAdapterPVC);

        // enumerate the sub keys, and create a CPvcInfo object for each PVC
        VECSTR vstrPVCIdList;
        hr = HrLoadSubkeysFromRegistry(hkeyAdapterPVC, &vstrPVCIdList);

        // now load parameters for each PVC
        for (VECSTR::iterator iterPvcId = vstrPVCIdList.begin();
             iterPvcId != vstrPVCIdList.end();
             iterPvcId ++)
        {
            HKEY hkeyAdapterPVCId = NULL;
            hr = HrRegOpenKeyEx(hkeyAdapterPVC,
                                (*iterPvcId)->c_str(),
                                KEY_READ,
                                &hkeyAdapterPVCId);

            if(hr == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
                hr = S_OK;
            else if(SUCCEEDED(hr))
            {
                CPvcInfo * pNewPVC = new CPvcInfo((*iterPvcId)->c_str());

                if (pNewPVC)
                {
					pAdapterInfo->m_listPVCs.push_back(pNewPVC);

					HRESULT hrTmp = S_OK;

					// Get the PVC Type
					DWORD dwType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId,
											c_szPVCType,
											&dwType);

					if (hrTmp == HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND))
					{
						pNewPVC->m_dwPVCType = PVC_CUSTOM;
						hrTmp = S_OK;
					}
					else if SUCCEEDED(hrTmp)
					{
						Assert( (dwType == PVC_ATMARP) ||
								(dwType == PVC_PPP_ATM_CLIENT) ||
								(dwType == PVC_PPP_ATM_SERVER) ||
								(dwType == PVC_CUSTOM));

						switch(dwType)
						{
						case PVC_ATMARP:
							pNewPVC->m_dwPVCType = PVC_ATMARP;
							break;

						case PVC_PPP_ATM_CLIENT:
							pNewPVC->m_dwPVCType = PVC_PPP_ATM_CLIENT;
							break;

						case PVC_PPP_ATM_SERVER:
							pNewPVC->m_dwPVCType = PVC_PPP_ATM_SERVER;
							break;

						default:
							pNewPVC->m_dwPVCType = PVC_CUSTOM;
							break;
						}
					}
					else
					{
						TraceError("Failed reading PVCType", hrTmp);
						hrTmp = S_OK;

						pNewPVC->m_dwPVCType = PVC_CUSTOM;
					}

					// set the default values for the type
					pNewPVC->SetDefaults(pNewPVC->m_dwPVCType);

					// now read any existing value from the registry
					// pvc name
					tstring strName;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szPVCName, &strName);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strName = strName;

					// VPI (required), if failed, default to 0
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szVpi, &(pNewPVC->m_dwVpi));

					// VCI (required), if failed, default to 0
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szVci, &(pNewPVC->m_dwVci));

					// AAL Type
					DWORD dwAALType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szAALType, &dwAALType);
					if SUCCEEDED(hrTmp)
					{
						switch (dwAALType)
						{
						/* $REVIEW(tongl 2/23/98): Per ArvindM, only AAL5 is supported in NT5
						case AAL_TYPE_AAL0:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL0;
							break;
	
						case AAL_TYPE_AAL1:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL1;
							break;
	
						case AAL_TYPE_AAL34:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL34;
							break;
						*/
	
						case AAL_TYPE_AAL5:
							pNewPVC->m_dwAAL = AAL_TYPE_AAL5;
							break;
	
						default:
							AssertSz(FALSE, "Invalid AAL type.");
							pNewPVC->m_dwAAL = AAL_TYPE_AAL5;
						}
					}
	
					// Local address
					tstring strCallingAddr;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szCallingParty, &strCallingAddr);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strCallingAddr = strCallingAddr;
	
					// Destination address
					tstring strCalledAddr;
					hrTmp = HrRegQueryString(hkeyAdapterPVCId, c_szCalledParty, &strCalledAddr);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_strCalledAddr = strCalledAddr;
	
					// Flags
					DWORD dwFlags;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szFlags, &dwFlags);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwFlags = dwFlags;
	
					// Quality Info
					// TransmitPeakCellRate
					DWORD dwTransmitPeakCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitPeakCellRate,
											&dwTransmitPeakCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitPeakCellRate = dwTransmitPeakCellRate*c_iCellSize/c_iKbSize;
	
					// TransmitAvgCellRate
					DWORD dwTransmitAvgCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitAvgCellRate,
											&dwTransmitAvgCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitAvgCellRate = dwTransmitAvgCellRate*c_iCellSize/c_iKbSize;
	
					// TransmitByteBurstLength
					DWORD dwTransmitByteBurstLength;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitByteBurstLength,
											&dwTransmitByteBurstLength);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitByteBurstLength = dwTransmitByteBurstLength;
	
					// TransmitMaxSduSize
					DWORD dwTransmitMaxSduSize;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitMaxSduSize,
											&dwTransmitMaxSduSize);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwTransmitMaxSduSize = dwTransmitMaxSduSize;
	
					// TransmitServiceCategory
					DWORD dwTransmitServiceCategory;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szTransmitServiceCategory,
											&dwTransmitServiceCategory);
					if SUCCEEDED(hrTmp)
					{
						switch(dwTransmitServiceCategory)
						{
						case ATM_SERVICE_CATEGORY_CBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_CBR;
                        break;

						case ATM_SERVICE_CATEGORY_VBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_VBR;
							break;
	
						case ATM_SERVICE_CATEGORY_UBR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;
							break;
	
						case ATM_SERVICE_CATEGORY_ABR:
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_ABR;
							break;
	
						default:
							AssertSz(FALSE, "Invalid service category.");
							pNewPVC->m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;
						}
					}
	
					// ReceivePeakCellRate
					DWORD dwReceivePeakCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceivePeakCellRate,
											&dwReceivePeakCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceivePeakCellRate = dwReceivePeakCellRate*c_iCellSize/c_iKbSize;
	
					// ReceiveAvgCellRate
					DWORD dwReceiveAvgCellRate;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveAvgCellRate,
											&dwReceiveAvgCellRate);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveAvgCellRate = dwReceiveAvgCellRate*c_iCellSize/c_iKbSize;
	
					// ReceiveByteBurstLength
					DWORD dwReceiveByteBurstLength;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveByteBurstLength,
											&dwReceiveByteBurstLength);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveByteBurstLength = dwReceiveByteBurstLength;
	
					// ReceiveMaxSduSize
					DWORD dwReceiveMaxSduSize;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveMaxSduSize,
											&dwReceiveMaxSduSize);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwReceiveMaxSduSize = dwReceiveMaxSduSize;
	
					// ReceiveServiceCategory
					DWORD dwReceiveServiceCategory;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szReceiveServiceCategory,
											&dwReceiveServiceCategory);
					if SUCCEEDED(hrTmp)
					{
						switch(dwReceiveServiceCategory)
						{
						case ATM_SERVICE_CATEGORY_CBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_CBR;
							break;
	
						case ATM_SERVICE_CATEGORY_VBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_VBR;
							break;
	
						case ATM_SERVICE_CATEGORY_UBR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;
							break;
	
						case ATM_SERVICE_CATEGORY_ABR:
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_ABR;
							break;
	
						default:
							AssertSz(FALSE, "Invalid service category.");
							pNewPVC->m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;
						}
					}
	
					// Local BLLI & BHLI
					DWORD dwLocalLayer2Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer2Protocol,
											&dwLocalLayer2Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer2Protocol = dwLocalLayer2Protocol;
	
					DWORD dwLocalUserSpecLayer2;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalUserSpecLayer2,
											&dwLocalUserSpecLayer2);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalUserSpecLayer2 = dwLocalUserSpecLayer2;
	
					DWORD dwLocalLayer3Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer3Protocol,
											&dwLocalLayer3Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer3Protocol = dwLocalLayer3Protocol;
	
					DWORD dwLocalUserSpecLayer3;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalUserSpecLayer3,
											&dwLocalUserSpecLayer3);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalUserSpecLayer3 = dwLocalUserSpecLayer3;
	
					DWORD dwLocalLayer3IPI;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalLayer3IPI,
											&dwLocalLayer3IPI);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalLayer3IPI = dwLocalLayer3IPI;
	
					BYTE *  pbLocalSnapId = NULL;
					DWORD   cbLocalSnapId = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szLocalSnapId,
  													&pbLocalSnapId, &cbLocalSnapId);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbLocalSnapId >0) &&
 						(cbLocalSnapId <= c_nSnapIdMaxBytes))
					{
						ConvertBinaryToHexString(pbLocalSnapId, cbLocalSnapId,
 												&(pNewPVC->m_strLocalSnapId));
						MemFree(pbLocalSnapId);
					}
	
					DWORD dwLocalHighLayerInfoType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szLocalHighLayerInfoType,
											&dwLocalHighLayerInfoType);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwLocalHighLayerInfoType = dwLocalHighLayerInfoType;
	
					BYTE *  pbLocalHighLayerInfo = NULL;
					DWORD   cbLocalHighLayerInfo = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szLocalHighLayerInfo,
  													&pbLocalHighLayerInfo, &cbLocalHighLayerInfo);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbLocalHighLayerInfo >0) &&
 						(cbLocalHighLayerInfo <= c_nHighLayerInfoMaxBytes))
					{
						ConvertBinaryToHexString(pbLocalHighLayerInfo, cbLocalHighLayerInfo,
 												&(pNewPVC->m_strLocalHighLayerInfo));
						MemFree(pbLocalHighLayerInfo);
					}
	
					// Destination BLLI and BHLI
					DWORD dwDestnLayer2Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer2Protocol,
											&dwDestnLayer2Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer2Protocol = dwDestnLayer2Protocol;
	
					DWORD dwDestnUserSpecLayer2;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnUserSpecLayer2,
											&dwDestnUserSpecLayer2);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnUserSpecLayer2 = dwDestnUserSpecLayer2;
	
					DWORD dwDestnLayer3Protocol;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer3Protocol,
											&dwDestnLayer3Protocol);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer3Protocol = dwDestnLayer3Protocol;
	
					DWORD dwDestnUserSpecLayer3;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnUserSpecLayer3,
											&dwDestnUserSpecLayer3);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnUserSpecLayer3 = dwDestnUserSpecLayer3;
	
					DWORD dwDestnLayer3IPI;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnLayer3IPI,
											&dwDestnLayer3IPI);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnLayer3IPI = dwDestnLayer3IPI;
	
					BYTE *  pbDestnSnapId = NULL;
					DWORD   cbDestnSnapId = 0;
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szDestnSnapId,
  													&pbDestnSnapId, &cbDestnSnapId);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbDestnSnapId >0) &&
 						(cbDestnSnapId <= c_nSnapIdMaxBytes))
					{
						ConvertBinaryToHexString(pbDestnSnapId, cbDestnSnapId,
 												&(pNewPVC->m_strDestnSnapId));
						MemFree(pbDestnSnapId);
					}
	
					DWORD dwDestnHighLayerInfoType;
					hrTmp = HrRegQueryDword(hkeyAdapterPVCId, c_szDestnHighLayerInfoType,
											&dwDestnHighLayerInfoType);
					if SUCCEEDED(hrTmp)
						pNewPVC->m_dwDestnHighLayerInfoType = dwDestnHighLayerInfoType;
	
					BYTE *  pbDestnHighLayerInfo = NULL;
					DWORD   cbDestnHighLayerInfo = 0;
	
					hrTmp = HrRegQueryBinaryWithAlloc(hkeyAdapterPVCId, c_szDestnHighLayerInfo,
  													&pbDestnHighLayerInfo, &cbDestnHighLayerInfo);
	
					if ( SUCCEEDED(hrTmp) &&
 						(cbDestnHighLayerInfo >0) &&
 						(cbDestnHighLayerInfo <= c_nHighLayerInfoMaxBytes))
					{
						ConvertBinaryToHexString(pbDestnHighLayerInfo, cbDestnHighLayerInfo,
 												&(pNewPVC->m_strDestnHighLayerInfo));
						MemFree(pbDestnHighLayerInfo);
					}
	
					// Now initialize the "Old" values
					pNewPVC->ResetOldValues();
				}
			}
            RegSafeCloseKey(hkeyAdapterPVCId);
        }
    }
    RegSafeCloseKey(hkeyAdapterPVC);

    TraceError("CAtmUniCfg::HrLoadAdapterPVCRegistry", hr);
    return hr;
}

// Save PVC specific settings to registry
HRESULT CAtmUniCfg::HrSaveAdapterPVCRegistry(HKEY hkeyAdapterParam,
                                             CUniAdapterInfo * pAdapterInfo)
{
    HRESULT hr = S_OK;

    Assert(hkeyAdapterParam);
    Assert(pAdapterInfo);

    // open the PVC subkey and enumerate the PVCs under that
    HKEY  hkeyAdapterPVC = NULL;
    DWORD dwDisposition;
    hr = HrRegCreateKeyEx(hkeyAdapterParam,
                             c_szPVC,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hkeyAdapterPVC,
                             &dwDisposition);
    if(SUCCEEDED(hr))
    {
        Assert(hkeyAdapterPVC);

        if (dwDisposition == REG_OPENED_EXISTING_KEY)
        {
            // clean up deleted PVCs
            HRESULT hrTmp = S_OK;

            // enumerate the sub keys, and create a CPvcInfo object for each PVC
            VECSTR vstrPVCIdList;
            hrTmp = HrLoadSubkeysFromRegistry(hkeyAdapterPVC, &vstrPVCIdList);
            if SUCCEEDED(hrTmp)
            {
                for (VECSTR::iterator iterPvcId = vstrPVCIdList.begin();
                     iterPvcId != vstrPVCIdList.end();
                     iterPvcId ++)
                {
                    BOOL fFound = FALSE;

                    for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
                         iterPvcInfo != pAdapterInfo->m_listPVCs.end();
                         iterPvcInfo ++)
                    {
                        if ((*iterPvcInfo)->m_fDeleted)
                            continue;

                        if (**iterPvcId == (*iterPvcInfo)->m_strPvcId)
                        {
                            fFound = TRUE;
                            break;
                        }
                    }

                    if (!fFound)
                    {
                        hrTmp = HrRegDeleteKeyTree(hkeyAdapterPVC,
                                                   (*iterPvcId)->c_str());
                    }
                }
            }
        }

        // save new or updated pvcs
        for (PVC_INFO_LIST::iterator iterPvcInfo = pAdapterInfo->m_listPVCs.begin();
             iterPvcInfo != pAdapterInfo->m_listPVCs.end();
             iterPvcInfo ++)
        {
            if ((*iterPvcInfo)->m_fDeleted)
                continue;

            HRESULT hrTmp = S_OK;

            // Create the subkey
            HKEY  hkeyAdapterPVCId = NULL;
            hrTmp = HrRegCreateKeyEx(hkeyAdapterPVC,
                                     (*iterPvcInfo)->m_strPvcId.c_str(),
                                     REG_OPTION_NON_VOLATILE,
                                     KEY_ALL_ACCESS,
                                     NULL,
                                     &hkeyAdapterPVCId,
                                     &dwDisposition);
            if(SUCCEEDED(hrTmp))
            {
                Assert(hkeyAdapterPVCId);

                // PVC type
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szPVCType,
                                      (*iterPvcInfo)->m_dwPVCType);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // pvc name
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szPVCName,
                                       (*iterPvcInfo)->m_strName);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // VPI
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szVpi,
                                      (*iterPvcInfo)->m_dwVpi);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // VCI
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szVci,
                                      (*iterPvcInfo)->m_dwVci);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // AAL Type
                hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szAALType,
                                      (*iterPvcInfo)->m_dwAAL);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Local address
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szCallingParty,
                                       (*iterPvcInfo)->m_strCallingAddr);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Destination address
                hrTmp = HrRegSetString(hkeyAdapterPVCId, c_szCalledParty,
                                       (*iterPvcInfo)->m_strCalledAddr);
                if SUCCEEDED(hr)
                    hr = hrTmp;

                // Flags
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwFlags)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId, c_szFlags);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szFlags,
                                          (*iterPvcInfo)->m_dwFlags);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // Quality Info
                // TransmitPeakCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitPeakCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitPeakCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitPeakCellRate,
                                          (*iterPvcInfo)->m_dwTransmitPeakCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitAvgCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitAvgCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitAvgCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitAvgCellRate,
                                          (*iterPvcInfo)->m_dwTransmitAvgCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitByteBurstLength
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitByteBurstLength)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitByteBurstLength);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitByteBurstLength,
                                          (*iterPvcInfo)->m_dwTransmitByteBurstLength);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitMaxSduSize
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwTransmitMaxSduSize)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szTransmitMaxSduSize);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szTransmitMaxSduSize,
                                          (*iterPvcInfo)->m_dwTransmitMaxSduSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // TransmitServiceCategory
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szTransmitServiceCategory,
                                      (*iterPvcInfo)->m_dwTransmitServiceCategory);
                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceivePeakCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceivePeakCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceivePeakCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceivePeakCellRate,
                                          (*iterPvcInfo)->m_dwReceivePeakCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveAvgCellRate
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveAvgCellRate)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveAvgCellRate);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveAvgCellRate,
                                          (*iterPvcInfo)->m_dwReceiveAvgCellRate*c_iKbSize/c_iCellSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveByteBurstLength
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveByteBurstLength)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveByteBurstLength);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveByteBurstLength,
                                          (*iterPvcInfo)->m_dwReceiveByteBurstLength);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveMaxSduSize
                if (FIELD_UNSET == (*iterPvcInfo)->m_dwReceiveMaxSduSize)
                {
                    // delete the value
                    hrTmp = HrRegDeleteValue(hkeyAdapterPVCId,
                                             c_szReceiveMaxSduSize);
                }
                else
                {
                    // save the value
                    hrTmp = HrRegSetDword(hkeyAdapterPVCId, c_szReceiveMaxSduSize,
                                          (*iterPvcInfo)->m_dwReceiveMaxSduSize);
                }

                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // ReceiveServiceCategory
                hrTmp = HrRegSetDword(hkeyAdapterPVCId,
                                      c_szReceiveServiceCategory,
                                      (*iterPvcInfo)->m_dwReceiveServiceCategory);
                if SUCCEEDED(hrTmp)
                    hr = hrTmp;

                // Local BLLI & BHLI
                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer2Protocol,
                                 (*iterPvcInfo)->m_dwLocalLayer2Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalUserSpecLayer2,
                                 (*iterPvcInfo)->m_dwLocalUserSpecLayer2);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer3Protocol,
                                 (*iterPvcInfo)->m_dwLocalLayer3Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalUserSpecLayer3,
                                 (*iterPvcInfo)->m_dwLocalUserSpecLayer3);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalLayer3IPI,
                                 (*iterPvcInfo)->m_dwLocalLayer3IPI);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szLocalSnapId,
                                            (*iterPvcInfo)->m_strLocalSnapId.c_str());

                SetPvcDwordParam(hkeyAdapterPVCId, c_szLocalHighLayerInfoType,
                                 (*iterPvcInfo)->m_dwLocalHighLayerInfoType);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szLocalHighLayerInfo,
                                            (*iterPvcInfo)->m_strLocalHighLayerInfo.c_str());

                // Destination BLLI and BHLI info
                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer2Protocol,
                                 (*iterPvcInfo)->m_dwDestnLayer2Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnUserSpecLayer2,
                                 (*iterPvcInfo)->m_dwDestnUserSpecLayer2);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer3Protocol,
                                 (*iterPvcInfo)->m_dwDestnLayer3Protocol);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnUserSpecLayer3,
                                 (*iterPvcInfo)->m_dwDestnUserSpecLayer3);

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnLayer3IPI,
                                 (*iterPvcInfo)->m_dwDestnLayer3IPI);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szDestnSnapId,
                                            (*iterPvcInfo)->m_strDestnSnapId.c_str());

                SetPvcDwordParam(hkeyAdapterPVCId, c_szDestnHighLayerInfoType,
                                 (*iterPvcInfo)->m_dwDestnHighLayerInfoType);

                SetPvcBinaryParamFromString(hkeyAdapterPVCId, c_szDestnHighLayerInfo,
                                            (*iterPvcInfo)->m_strDestnHighLayerInfo.c_str());
            }
            RegSafeCloseKey(hkeyAdapterPVCId);
        }
    }
    RegSafeCloseKey(hkeyAdapterPVC);

    TraceError("CAtmUniCfg::HrSaveAdapterPVCRegistry", hr);
    return hr;
}

// load adapter PVC parameters from first memory to second memory
HRESULT CAtmUniCfg::HrLoadAdapterPVCInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    delete m_pSecondMemoryAdapterInfo;
    m_pSecondMemoryAdapterInfo = NULL;

    for(UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if (FIsSubstr(m_strGuidConn.c_str(), (*iterAdapter)->m_strBindName.c_str()))
        {
            // enabled LAN adapter
            if ((*iterAdapter)->m_BindingState == BIND_ENABLE)
            {
                m_pSecondMemoryAdapterInfo = new CUniAdapterInfo;

				if (m_pSecondMemoryAdapterInfo == NULL)
				{
					continue;
				}

                *m_pSecondMemoryAdapterInfo = **iterAdapter;
                hr = S_OK;
            }
        }
    }

    AssertSz((S_OK == hr), "Can not raise UI on a disabled or non-exist adapter !");
    TraceError("CAtmUniCfg::HrLoadAdapterInfo", hr);
    return hr;
}

// save adapter PVC parameters from second memory to first memory
HRESULT CAtmUniCfg::HrSaveAdapterPVCInfo()
{
    HRESULT hr = HRESULT_FROM_WIN32(ERROR_NO_MATCH);

    for(UNI_ADAPTER_LIST::iterator iterAdapter = m_listAdapters.begin();
        iterAdapter != m_listAdapters.end();
        iterAdapter++)
    {
        if(m_pSecondMemoryAdapterInfo->m_strBindName == (*iterAdapter)->m_strBindName)
        {
            // The card can not get unbound while in the properties UI !
            Assert((*iterAdapter)->m_BindingState == BIND_ENABLE);
            Assert(m_pSecondMemoryAdapterInfo->m_BindingState == BIND_ENABLE);

            **iterAdapter = *m_pSecondMemoryAdapterInfo;
            hr = S_OK;
            break;
        }
    }

    AssertSz((S_OK == hr), "Adapter in second memory not found in first memory!");

    TraceError("CAtmUniCfg::HrSaveAdapterInfo", hr);
    return hr;
}

// CPvcInfo
CPvcInfo::CPvcInfo(PCWSTR pszPvcId)
{
    m_strPvcId = pszPvcId;
    m_fDeleted = FALSE;
}

CPvcInfo::~CPvcInfo()
{
}

// copy operator
CPvcInfo &  CPvcInfo::operator=(const CPvcInfo & info)
{
    Assert(this != &info);
    Assert(m_strPvcId == info.m_strPvcId);

    if (this == &info)
        return *this;

    m_fDeleted = info.m_fDeleted;

    m_dwPVCType = info.m_dwPVCType;
    m_dwOldPVCType = info.m_dwOldPVCType;

    m_strName = info.m_strName;
    m_strOldName = info.m_strOldName;

    m_dwVpi = info.m_dwVpi;
    m_dwOldVpi = info.m_dwOldVpi;

    m_dwVci = info.m_dwVci;
    m_dwOldVci = info.m_dwOldVci;

    m_dwAAL = info.m_dwAAL;
    m_dwOldAAL = info.m_dwOldAAL;

    m_strCallingAddr = info.m_strCallingAddr;
    m_strOldCallingAddr = info.m_strOldCallingAddr;

    m_strCalledAddr = info.m_strCalledAddr;
    m_strOldCalledAddr = info.m_strOldCalledAddr;

    m_dwFlags = info.m_dwFlags;

    m_dwTransmitPeakCellRate = info.m_dwTransmitPeakCellRate;
    m_dwOldTransmitPeakCellRate = info.m_dwOldTransmitPeakCellRate;

    m_dwTransmitAvgCellRate = info.m_dwTransmitAvgCellRate;
    m_dwOldTransmitAvgCellRate = info.m_dwOldTransmitAvgCellRate;

    m_dwTransmitByteBurstLength = info.m_dwTransmitByteBurstLength;
    m_dwOldTransmitByteBurstLength = info.m_dwOldTransmitByteBurstLength;

    m_dwTransmitMaxSduSize = info.m_dwTransmitMaxSduSize;
    m_dwOldTransmitMaxSduSize = info.m_dwOldTransmitMaxSduSize;

    m_dwTransmitServiceCategory = info.m_dwTransmitServiceCategory;
    m_dwOldTransmitServiceCategory = info.m_dwOldTransmitServiceCategory;

    m_dwReceivePeakCellRate = info.m_dwReceivePeakCellRate;
    m_dwOldReceivePeakCellRate = info.m_dwOldReceivePeakCellRate;

    m_dwReceiveAvgCellRate = info.m_dwReceiveAvgCellRate;
    m_dwOldReceiveAvgCellRate = info.m_dwOldReceiveAvgCellRate;

    m_dwReceiveByteBurstLength = info.m_dwReceiveByteBurstLength;
    m_dwOldReceiveByteBurstLength = info.m_dwOldReceiveByteBurstLength;

    m_dwReceiveMaxSduSize = info.m_dwReceiveMaxSduSize;
    m_dwOldReceiveMaxSduSize = info.m_dwOldReceiveMaxSduSize;

    m_dwReceiveServiceCategory = info.m_dwReceiveServiceCategory;
    m_dwOldReceiveServiceCategory = info.m_dwOldReceiveServiceCategory;

    // BLLI & BHLI
    m_dwLocalLayer2Protocol = info.m_dwLocalLayer2Protocol;
    m_dwOldLocalLayer2Protocol = info.m_dwOldLocalLayer2Protocol;

    m_dwLocalUserSpecLayer2 = info.m_dwLocalUserSpecLayer2;
    m_dwOldLocalUserSpecLayer2 = info.m_dwOldLocalUserSpecLayer2;

    m_dwLocalLayer3Protocol = info.m_dwLocalLayer3Protocol;
    m_dwOldLocalLayer3Protocol = info.m_dwOldLocalLayer3Protocol;

    m_dwLocalUserSpecLayer3 = info.m_dwLocalUserSpecLayer3;
    m_dwOldLocalUserSpecLayer3 = info.m_dwOldLocalUserSpecLayer3;

    m_dwLocalLayer3IPI = info.m_dwLocalLayer3IPI;
    m_dwOldLocalLayer3IPI = info.m_dwOldLocalLayer3IPI;

    m_strLocalSnapId    = info.m_strLocalSnapId;
    m_strOldLocalSnapId = info.m_strOldLocalSnapId;

    m_dwLocalHighLayerInfoType = info.m_dwLocalHighLayerInfoType;
    m_dwOldLocalHighLayerInfoType = info.m_dwOldLocalHighLayerInfoType;

    m_strLocalHighLayerInfo = info.m_strLocalHighLayerInfo;
    m_strOldLocalHighLayerInfo = info.m_strOldLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = info.m_dwDestnLayer2Protocol;
    m_dwOldDestnLayer2Protocol = info.m_dwOldDestnLayer2Protocol;

    m_dwDestnUserSpecLayer2 = info.m_dwDestnUserSpecLayer2;
    m_dwOldDestnUserSpecLayer2 = info.m_dwOldDestnUserSpecLayer2;

    m_dwDestnLayer3Protocol = info.m_dwDestnLayer3Protocol;
    m_dwOldDestnLayer3Protocol = info.m_dwOldDestnLayer3Protocol;

    m_dwDestnUserSpecLayer3 = info.m_dwDestnUserSpecLayer3;
    m_dwOldDestnUserSpecLayer3 = info.m_dwOldDestnUserSpecLayer3;

    m_dwDestnLayer3IPI = info.m_dwDestnLayer3IPI;
    m_dwOldDestnLayer3IPI = info.m_dwOldDestnLayer3IPI;

    m_strDestnSnapId    = info.m_strDestnSnapId;
    m_strOldDestnSnapId = info.m_strOldDestnSnapId;

    m_dwDestnHighLayerInfoType = info.m_dwDestnHighLayerInfoType;
    m_dwOldDestnHighLayerInfoType = info.m_dwOldDestnHighLayerInfoType;

    m_strDestnHighLayerInfo = info.m_strDestnHighLayerInfo;
    m_strOldDestnHighLayerInfo = info.m_strOldDestnHighLayerInfo;

    return *this;
}

void CPvcInfo::SetDefaults(PVCType type)
{
    m_dwPVCType = type;
    m_fDeleted = FALSE;

    m_strName = (PWSTR) SzLoadIds(IDS_PVC_UNSPECIFIED_NAME);
    m_dwAAL = AAL_TYPE_AAL5;

    m_dwVpi = 0;
    m_dwVci = FIELD_UNSET;

    SetTypeDefaults(type);
    ResetOldValues();
}

void CPvcInfo::SetTypeDefaults(PVCType type)
{
    // set more specific defaults for each type
    m_dwPVCType = type;

    switch (m_dwPVCType)
    {
    case PVC_ATMARP:
        SetDefaultsForAtmArp();
        break;

    case PVC_PPP_ATM_CLIENT:
        SetDefaultsForPPPOut();
        break;

    case PVC_PPP_ATM_SERVER:
        SetDefaultsForPPPIn();
        break;

    case PVC_CUSTOM:
        SetDefaultsForCustom();
        break;
    }
}

void CPvcInfo::SetDefaultsForAtmArp()
{
    m_dwPVCType = PVC_ATMARP;

    // addresses
    m_strCallingAddr = c_szDefaultCallingAtmAddr;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags        = 2;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = c_dwDefTransmitByteBurstLength;
    m_dwTransmitMaxSduSize      = c_dwDefTransmitMaxSduSize;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = c_dwDefTransmitByteBurstLength;
    m_dwReceiveMaxSduSize      = c_dwDefTransmitMaxSduSize;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = 12;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = 12;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForPPPOut()
{
    m_dwPVCType = PVC_PPP_ATM_CLIENT;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr = c_szDefaultCalledAtmAddr;

    // Flags
    m_dwFlags        = 4;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = 4096;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = 4096;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = 11;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 207;
    m_strDestnHighLayerInfo = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForPPPIn()
{
    m_dwPVCType = PVC_PPP_ATM_SERVER;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags        = 2;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = 4096;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = 4096;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ABSENT;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = 11;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 207;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ABSENT;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ABSENT;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ABSENT;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::SetDefaultsForCustom()
{
    m_dwPVCType = PVC_CUSTOM;

    // addresses
    m_strCallingAddr = c_szEmpty;
    m_strCalledAddr  = c_szEmpty;

    // Flags
    m_dwFlags      = FIELD_UNSET;

    // Quality Info
    m_dwTransmitPeakCellRate    = FIELD_UNSET;
    m_dwTransmitAvgCellRate     = FIELD_UNSET;
    m_dwTransmitByteBurstLength = FIELD_UNSET;
    m_dwTransmitMaxSduSize      = FIELD_UNSET;
    m_dwTransmitServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    m_dwReceivePeakCellRate    = FIELD_UNSET;
    m_dwReceiveAvgCellRate     = FIELD_UNSET;
    m_dwReceiveByteBurstLength = FIELD_UNSET;
    m_dwReceiveMaxSduSize      = FIELD_UNSET;
    m_dwReceiveServiceCategory = ATM_SERVICE_CATEGORY_UBR;

    // Local BLLI & BHLI
    m_dwLocalLayer2Protocol = FIELD_ANY;
    m_dwLocalUserSpecLayer2 = 0;
    m_dwLocalLayer3Protocol = FIELD_ANY;
    m_dwLocalUserSpecLayer3 = 0;
    m_dwLocalLayer3IPI  = 0;
    m_strLocalSnapId = c_szEmpty;

    m_dwLocalHighLayerInfoType = FIELD_ANY;
    m_strLocalHighLayerInfo = c_szEmpty;

    // Destination BLLI and BHLI info
    m_dwDestnLayer2Protocol = FIELD_ANY;
    m_dwDestnUserSpecLayer2 = 0;
    m_dwDestnLayer3Protocol = FIELD_ANY;
    m_dwDestnUserSpecLayer3 = 0;
    m_dwDestnLayer3IPI = 0;
    m_strDestnSnapId = c_szEmpty;

    m_dwDestnHighLayerInfoType = FIELD_ANY;
    m_strDestnHighLayerInfo = c_szEmpty;
}

void CPvcInfo::ResetOldValues()
{
    m_dwOldPVCType = m_dwPVCType;
    m_strOldName = m_strName;

    m_dwOldVpi = m_dwVpi;
    m_dwOldVci = m_dwVci;

    m_dwOldAAL = m_dwAAL;

    m_strOldCallingAddr = m_strCallingAddr;
    m_strOldCalledAddr  = m_strCalledAddr;

    // Quality Info
    m_dwOldTransmitPeakCellRate     = m_dwTransmitPeakCellRate;
    m_dwOldTransmitAvgCellRate      = m_dwTransmitAvgCellRate;
    m_dwOldTransmitByteBurstLength  = m_dwTransmitByteBurstLength;
    m_dwOldTransmitMaxSduSize       = m_dwTransmitMaxSduSize;
    m_dwOldTransmitServiceCategory  = m_dwTransmitServiceCategory;

    m_dwOldReceivePeakCellRate     = m_dwReceivePeakCellRate;
    m_dwOldReceiveAvgCellRate      = m_dwReceiveAvgCellRate;
    m_dwOldReceiveByteBurstLength  = m_dwReceiveByteBurstLength;
    m_dwOldReceiveMaxSduSize       = m_dwReceiveMaxSduSize;
    m_dwOldReceiveServiceCategory  = m_dwReceiveServiceCategory;

    // Local BLLI & BHLI
    m_dwOldLocalLayer2Protocol = m_dwLocalLayer2Protocol;
    m_dwOldLocalUserSpecLayer2 = m_dwLocalUserSpecLayer2;
    m_dwOldLocalLayer3Protocol = m_dwLocalLayer3Protocol;
    m_dwOldLocalUserSpecLayer3 = m_dwLocalUserSpecLayer3;
    m_dwOldLocalLayer3IPI  = m_dwLocalLayer3IPI;
    m_strOldLocalSnapId = m_strLocalSnapId;

    m_dwOldLocalHighLayerInfoType = m_dwLocalHighLayerInfoType;
    m_strOldLocalHighLayerInfo = m_strLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    m_dwOldDestnLayer2Protocol = m_dwDestnLayer2Protocol;
    m_dwOldDestnUserSpecLayer2 = m_dwDestnUserSpecLayer2;
    m_dwOldDestnLayer3Protocol = m_dwDestnLayer3Protocol;
    m_dwOldDestnUserSpecLayer3 = m_dwDestnUserSpecLayer3;
    m_dwOldDestnLayer3IPI = m_dwDestnLayer3IPI;
    m_strOldDestnSnapId = m_strDestnSnapId;

    m_dwOldDestnHighLayerInfoType = m_dwDestnHighLayerInfoType;
    m_strOldDestnHighLayerInfo = m_strDestnHighLayerInfo;
}

// CUniAdapterInfo
CUniAdapterInfo &  CUniAdapterInfo::operator=(const CUniAdapterInfo & info)
{
    Assert(this != &info);

    if (this == &info)
        return *this;

    // the adapter's binding state
    m_strBindName = info.m_strBindName;
    m_BindingState = info.m_BindingState;
    m_fDeleted = info.m_fDeleted;

    FreeCollectionAndItem(m_listPVCs);

    for (PVC_INFO_LIST::iterator iterPVCInfo = info.m_listPVCs.begin();
         iterPVCInfo != info.m_listPVCs.end();
         iterPVCInfo ++)
    {
        CPvcInfo * pNewPvc = new CPvcInfo((*iterPVCInfo)->m_strPvcId.c_str());

		if (pNewPvc == NULL)
		{
			continue;
		}

        *pNewPvc = **iterPVCInfo;
        m_listPVCs.push_back(pNewPvc);
    }

    return *this;
}

void CUniAdapterInfo::SetDefaults(PCWSTR pszBindName)
{
    m_strBindName = pszBindName;
    m_BindingState = BIND_UNSET;
    FreeCollectionAndItem(m_listPVCs);

    m_fDeleted = FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\resource.h ===
#include "ncres.h"

#define IDS_DESC_COMOBJ_AUNICFG         IDS_NC_ATMCFG + 0
#define IDS_DESC_COMOBJ_ARPSCFG         IDS_NC_ATMCFG + 1
#define IDS_DESC_COMOBJ_RWANCFG         IDS_NC_ATMCFG + 2
#define IDS_MSFT_ARPS_TEXT              IDS_NC_ATMCFG + 3
#define IDS_ARPS_NO_BOUND_CARDS         IDS_NC_ATMCFG + 4
#define IDS_IPADDRESS_FROM              IDS_NC_ATMCFG + 5
#define IDS_IPADDRESS_TO                IDS_NC_ATMCFG + 6
#define IDS_NO_ITEM_SELECTED            IDS_NC_ATMCFG + 7
#define IDS_INVALID_ATM_ADDRESS         IDS_NC_ATMCFG + 8
#define IDS_INCORRECT_IPRANGE           IDS_NC_ATMCFG + 9

#define IDS_MSFT_UNI_TEXT               IDS_NC_ATMCFG + 10
#define IDS_UNI_NO_BOUND_CARDS          IDS_NC_ATMCFG + 11
#define IDS_PVC_UNSPECIFIED_NAME        IDS_NC_ATMCFG + 12
#define IDS_PVC_AAL5                    IDS_NC_ATMCFG + 13
#define IDS_PVC_ATMARP                  IDS_NC_ATMCFG + 14
#define IDS_PVC_PPP_ATM_CLIENT          IDS_NC_ATMCFG + 15
#define IDS_PVC_PPP_ATM_SERVER          IDS_NC_ATMCFG + 16
#define IDS_PVC_CUSTOM                  IDS_NC_ATMCFG + 17

#define IDS_DUPLICATE_REG_ADDR          IDS_NC_ATMCFG + 18
#define IDS_OVERLAP_MUL_ADDR            IDS_NC_ATMCFG + 19

#define IDS_PVC_NAME                    IDS_NC_ATMCFG + 20
#define IDS_PVC_VPI                     IDS_NC_ATMCFG + 21
#define IDS_PVC_VCI                     IDS_NC_ATMCFG + 22
#define IDS_INVALID_VPI                 IDS_NC_ATMCFG + 23
#define IDS_INVALID_VCI                 IDS_NC_ATMCFG + 24
#define IDS_INVALID_Calling_Address     IDS_NC_ATMCFG + 25
#define IDS_INVALID_Called_Address      IDS_NC_ATMCFG + 26
#define IDS_ADV_PVC_HEADER              IDS_NC_ATMCFG + 27

#define IDS_PVC_Layer2_1                IDS_NC_ATMCFG + 31
#define IDS_PVC_Layer2_2                IDS_NC_ATMCFG + 32
#define IDS_PVC_Layer2_6                IDS_NC_ATMCFG + 33
#define IDS_PVC_Layer2_7                IDS_NC_ATMCFG + 34
#define IDS_PVC_Layer2_8                IDS_NC_ATMCFG + 35
#define IDS_PVC_Layer2_9                IDS_NC_ATMCFG + 36
#define IDS_PVC_Layer2_10               IDS_NC_ATMCFG + 37
#define IDS_PVC_Layer2_11               IDS_NC_ATMCFG + 38
#define IDS_PVC_Layer2_12               IDS_NC_ATMCFG + 39
#define IDS_PVC_Layer2_13               IDS_NC_ATMCFG + 40
#define IDS_PVC_Layer2_14               IDS_NC_ATMCFG + 41
#define IDS_PVC_Layer2_16               IDS_NC_ATMCFG + 42
#define IDS_PVC_Layer2_17               IDS_NC_ATMCFG + 43

#define IDS_PVC_Layer3_6                IDS_NC_ATMCFG + 44
#define IDS_PVC_Layer3_7                IDS_NC_ATMCFG + 45
#define IDS_PVC_Layer3_8                IDS_NC_ATMCFG + 46
#define IDS_PVC_Layer3_9                IDS_NC_ATMCFG + 47
#define IDS_PVC_Layer3_10               IDS_NC_ATMCFG + 48
#define IDS_PVC_Layer3_11               IDS_NC_ATMCFG + 49
#define IDS_PVC_Layer3_16               IDS_NC_ATMCFG + 50
     
#define IDS_PVC_HighLayer_0             IDS_NC_ATMCFG + 51
#define IDS_PVC_HighLayer_1             IDS_NC_ATMCFG + 52
#define IDS_PVC_HighLayer_3             IDS_NC_ATMCFG + 53

#define IDS_PVC_Any                     IDS_NC_ATMCFG + 54
#define IDS_PVC_Absent                  IDS_NC_ATMCFG + 55

#define IDS_PVC_CBR                     IDS_NC_ATMCFG + 56
#define IDS_PVC_VBR                     IDS_NC_ATMCFG + 57
#define IDS_PVC_UBR                     IDS_NC_ATMCFG + 58
#define IDS_PVC_ABR                     IDS_NC_ATMCFG + 59

#define IDS_INVALID_Layer2_Protocol     IDS_NC_ATMCFG + 60
#define IDS_INVALID_Layer2_UserSpec     IDS_NC_ATMCFG + 61
#define IDS_INVALID_Layer3_Protocol     IDS_NC_ATMCFG + 62
#define IDS_INVALID_Layer3_UserSpec     IDS_NC_ATMCFG + 63
#define IDS_INVALID_Layer3_IPI          IDS_NC_ATMCFG + 64
#define IDS_INVALID_Highlayer_Type      IDS_NC_ATMCFG + 65
#define IDS_INVALID_SnapId              IDS_NC_ATMCFG + 66
#define IDS_INVALID_HighLayerValue      IDS_NC_ATMCFG + 67

#define IDS_INVALID_QOS_VALUE           IDS_NC_ATMCFG + 68

#define IDS_DUPLICATE_PVC               IDS_NC_ATMCFG + 70

#define IDD_ARPS_PROP                   1000
#define IDD_ARPS_REG_ADDR               1001
#define IDD_ARPS_MUL_ADDR               1002
#define IDD_UNI_PROP                    1003
#define IDD_PVC_Main                    1004
#define IDD_PVC_Traffic                 1005
#define IDD_PVC_Local                   1006
#define IDD_PVC_Dest                    1007

// ARP server property page
#define IDC_LVW_ARPS_REG_ADDR           210
#define IDC_PSH_ARPS_REG_ADD            211
#define IDC_PSH_ARPS_REG_EDT            212
#define IDC_PSH_ARPS_REG_RMV            213
#define IDC_LVW_ARPS_MUL_ADDR           214
#define IDC_PSH_ARPS_MUL_ADD            215
#define IDC_PSH_ARPS_MUL_EDT            216
#define IDC_PSH_ARPS_MUL_RMV            217
#define IDC_EDT_ARPS_REG_Address        218
#define IDC_ARPS_MUL_LOWER_IP           219
#define IDC_ARPS_MUL_UPPER_IP           220

// UNI property page
#define IDC_LVW_PVC_LIST                230
#define IDC_PBN_PVC_Add                 231
#define IDC_PBN_PVC_Remove              232
#define IDC_PBN_PVC_Properties          233

// PVC Main page
#define IDC_EDT_PVC_Name                235
#define IDC_EDT_PVC_VPI                 236
#define IDC_EDT_PVC_VCI                 237
#define IDC_CMB_PVC_AAL                 238

#define IDC_CMB_PVC_Type                239
#define IDC_CHK_PVC_CallAddr            240
#define IDC_EDT_PVC_CallAddr            241
#define IDC_CHK_PVC_AnswerAddr          242
#define IDC_EDT_PVC_AnswerAddr          243

#define IDC_PBN_PVC_Advanced            244

// PVC Advanced page: Traffic Page
#define IDC_EDT_PVC_TRANS_PEAK          250
#define IDC_EDT_PVC_TRANS_AVG           251
#define IDC_EDT_PVC_TRANS_BURST         252
#define IDC_EDT_PVC_TRANS_MAX_SIZE      253
#define IDC_CMB_PVC_TRANS_SERVICE       254

#define IDC_EDT_PVC_RECEIVE_PEAK        255
#define IDC_EDT_PVC_RECEIVE_AVG         256
#define IDC_EDT_PVC_RECEIVE_BURST       257
#define IDC_EDT_PVC_RECEIVE_MAX_SIZE    258
#define IDC_CMB_PVC_RECEIVE_SERVICE     259

// PVC Advanced page: Local & Dest BLLI & BHLI
#define IDC_CMB_PVC_Layer2              260                    
#define IDC_EDT_PVC_User_Layer2         261
#define IDC_CMB_PVC_Layer3              262
#define IDC_EDT_PVC_User_Layer3         263
#define IDC_EDT_PVC_Layer3_IPI          264
#define IDC_EDT_PVC_SNAP_ID             265

#define IDC_CMB_PVC_High_Type           266
#define IDC_CMB_PVC_High_Value          267
#define IDC_TXT_PVC_Value               268
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\qosdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:      Q O S D L G . C P P
//
//  Contents:  PVC Qos property pages message handler implementation
//
//  Notes:
//
//  Author:     tongl   1 Mar, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
//#include "atmcommon.h"

#include "ncatlui.h"
#include "ncstl.h"
//#include "ncui.h"

const int MAX_QOS_SPEED = 6;
const int MAX_QOS_SIZE  = 5;
const int MAX_DATA = 65535;

//
// CPvcQosPage
//

CPvcQosPage::CPvcQosPage(CPVCMainDialog * pParentDlg,
                         CPvcInfo * pPvcInfo, const DWORD * adwHelpIDs )
{
    Assert(pPvcInfo);
    Assert(pParentDlg);

    m_pParentDlg = pParentDlg;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;
}

CPvcQosPage::~CPvcQosPage()
{
}

// Command handlers
LRESULT CPvcQosPage::OnInitDialog(UINT uMsg, WPARAM wParam,
                                  LPARAM lParam, BOOL& bHandled)
{
    // set length limit

    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_PEAK), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_AVG), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_PEAK), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_AVG), EM_SETLIMITTEXT, MAX_QOS_SPEED, 0);

    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_BURST), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_TRANS_MAX_SIZE), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_BURST), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_RECEIVE_MAX_SIZE), EM_SETLIMITTEXT, MAX_QOS_SIZE, 0);

    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitPeakCellRate,       IDC_EDT_PVC_TRANS_PEAK);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitAvgCellRate,        IDC_EDT_PVC_TRANS_AVG);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitByteBurstLength,    IDC_EDT_PVC_TRANS_BURST);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwTransmitMaxSduSize,         IDC_EDT_PVC_TRANS_MAX_SIZE);

    SetQosServiceCategory(m_pPvcInfo->m_dwTransmitServiceCategory, IDC_CMB_PVC_TRANS_SERVICE);

    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceivePeakCellRate,        IDC_EDT_PVC_RECEIVE_PEAK);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveAvgCellRate,         IDC_EDT_PVC_RECEIVE_AVG);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveByteBurstLength,     IDC_EDT_PVC_RECEIVE_BURST);
    SetDwordEdtField(m_hWnd, m_pPvcInfo->m_dwReceiveMaxSduSize,          IDC_EDT_PVC_RECEIVE_MAX_SIZE);

    SetQosServiceCategory(m_pPvcInfo->m_dwReceiveServiceCategory, IDC_CMB_PVC_RECEIVE_SERVICE);

    // reset the "old" value so we know if anythign has changed
    m_pPvcInfo->m_dwOldTransmitPeakCellRate     = m_pPvcInfo->m_dwTransmitPeakCellRate;
    m_pPvcInfo->m_dwOldTransmitAvgCellRate      = m_pPvcInfo->m_dwTransmitAvgCellRate;
    m_pPvcInfo->m_dwOldTransmitByteBurstLength  = m_pPvcInfo->m_dwTransmitByteBurstLength;
    m_pPvcInfo->m_dwOldTransmitMaxSduSize       = m_pPvcInfo->m_dwTransmitMaxSduSize;
    m_pPvcInfo->m_dwOldTransmitServiceCategory  = m_pPvcInfo->m_dwTransmitServiceCategory;

    m_pPvcInfo->m_dwOldReceivePeakCellRate      = m_pPvcInfo->m_dwReceivePeakCellRate;
    m_pPvcInfo->m_dwOldReceiveAvgCellRate       = m_pPvcInfo->m_dwReceiveAvgCellRate;
    m_pPvcInfo->m_dwOldReceiveByteBurstLength   = m_pPvcInfo->m_dwReceiveByteBurstLength;
    m_pPvcInfo->m_dwOldReceiveMaxSduSize        = m_pPvcInfo->m_dwReceiveMaxSduSize;
    m_pPvcInfo->m_dwOldReceiveServiceCategory   = m_pPvcInfo->m_dwReceiveServiceCategory;

    return 0;
}

void CPvcQosPage::SetQosServiceCategory(ATM_SERVICE_CATEGORY dwServiceType, int nIDDlgItem)
{
    // insert the selections
    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_CBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_VBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_UBR)));

    SendDlgItemMessage(nIDDlgItem,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_ABR)));

    // set the current selection
    int idx =0;

    switch(dwServiceType)
    {
    case ATM_SERVICE_CATEGORY_CBR:
        idx =0;
        break;

    case ATM_SERVICE_CATEGORY_VBR:
        idx =1;
        break;

    case ATM_SERVICE_CATEGORY_UBR:
        idx =2;
        break;

    case ATM_SERVICE_CATEGORY_ABR:
        idx =3;
        break;
    }

    SendDlgItemMessage(nIDDlgItem, CB_SETCURSEL, (LPARAM)(idx), 0);
}

LRESULT CPvcQosPage::OnContextMenu(UINT uMsg, WPARAM wParam,
                                   LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPvcQosPage::OnHelp(UINT uMsg, WPARAM wParam,
                            LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

// notify handlers for the property page
LRESULT CPvcQosPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitPeakCellRate),       IDC_EDT_PVC_TRANS_PEAK);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitAvgCellRate),        IDC_EDT_PVC_TRANS_AVG);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitByteBurstLength),    IDC_EDT_PVC_TRANS_BURST);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwTransmitMaxSduSize),         IDC_EDT_PVC_TRANS_MAX_SIZE);

    GetQosServiceCategory(&(m_pPvcInfo->m_dwTransmitServiceCategory), IDC_CMB_PVC_TRANS_SERVICE);

    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceivePeakCellRate),        IDC_EDT_PVC_RECEIVE_PEAK);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveAvgCellRate),         IDC_EDT_PVC_RECEIVE_AVG);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveByteBurstLength),     IDC_EDT_PVC_RECEIVE_BURST);
    GetDwordEdtField(m_hWnd, &(m_pPvcInfo->m_dwReceiveMaxSduSize),          IDC_EDT_PVC_RECEIVE_MAX_SIZE);

    GetQosServiceCategory(&(m_pPvcInfo->m_dwReceiveServiceCategory), IDC_CMB_PVC_RECEIVE_SERVICE);

    m_pParentDlg->m_fPropShtOk = TRUE;

    // did any qos field change ?
    if ((m_pPvcInfo->m_dwTransmitPeakCellRate   != m_pPvcInfo->m_dwOldTransmitPeakCellRate) ||
        (m_pPvcInfo->m_dwTransmitAvgCellRate    != m_pPvcInfo->m_dwOldTransmitAvgCellRate) ||
        (m_pPvcInfo->m_dwTransmitByteBurstLength!= m_pPvcInfo->m_dwOldTransmitByteBurstLength) ||
        (m_pPvcInfo->m_dwTransmitMaxSduSize     != m_pPvcInfo->m_dwOldTransmitMaxSduSize) ||
        (m_pPvcInfo->m_dwTransmitServiceCategory!= m_pPvcInfo->m_dwOldTransmitServiceCategory) ||

        (m_pPvcInfo->m_dwReceivePeakCellRate != m_pPvcInfo->m_dwOldReceivePeakCellRate) ||
        (m_pPvcInfo->m_dwReceiveAvgCellRate != m_pPvcInfo->m_dwOldReceiveAvgCellRate) ||
        (m_pPvcInfo->m_dwReceiveByteBurstLength != m_pPvcInfo->m_dwOldReceiveByteBurstLength) ||
        (m_pPvcInfo->m_dwReceiveMaxSduSize != m_pPvcInfo->m_dwOldReceiveMaxSduSize) ||
        (m_pPvcInfo->m_dwReceiveServiceCategory != m_pPvcInfo->m_dwOldReceiveServiceCategory)
       )
        m_pParentDlg->m_fPropShtModified = TRUE;

    return 0;
}

void CPvcQosPage::GetQosServiceCategory(ATM_SERVICE_CATEGORY * pdwServiceType, int nIDDlgItem)
{
    // set the current selection
    int idx = (int)SendDlgItemMessage(nIDDlgItem, CB_GETCURSEL, (LPARAM)(0), 0);

    if (idx != CB_ERR)
    {
        switch(idx)
        {
        case 0:
            *pdwServiceType = ATM_SERVICE_CATEGORY_CBR;
            break;

        case 1:
            *pdwServiceType = ATM_SERVICE_CATEGORY_VBR;
            break;

        case 2:
            *pdwServiceType = ATM_SERVICE_CATEGORY_UBR;
            break;

        case 3:
            *pdwServiceType = ATM_SERVICE_CATEGORY_ABR;
            break;
        }
    }
}

LRESULT CPvcQosPage::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    BOOL err = FALSE; // Allow page to lose active status

    // (#293160): Max Burst lengths and Max Data Sizes are limited to 65535
    // disable all buttons on this dialog
    static const int nrgIdc[] = {IDC_EDT_PVC_TRANS_BURST,
                                 IDC_EDT_PVC_TRANS_MAX_SIZE,
                                 IDC_EDT_PVC_RECEIVE_BURST,
                                 IDC_EDT_PVC_RECEIVE_MAX_SIZE
                                };
    int ccid = celems(nrgIdc);
    const INT* pId=nrgIdc;

    DWORD dwData;

    while (ccid--)
    {
        GetDwordEdtField(m_hWnd, &dwData, *pId);
        if ((dwData != FIELD_UNSET) && (dwData > MAX_DATA))
        {
            // we pop up a message box and set focus to the edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_QOS_VALUE,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(*pId));
            err = TRUE;
            break;
        }
        pId++;
    }

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, err);
    return err;
}

LRESULT CPvcQosPage::OnActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

LRESULT CPvcQosPage::OnCancel(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    return 0;
}

void SetDwordEdtField(HWND hDlg, DWORD dwData, int nIDDlgItem)
{
    if (dwData != FIELD_UNSET)
    {
        WCHAR szBuf[MAX_PATH];
        wsprintfW(szBuf, c_szItoa, dwData);
        SetDlgItemText(hDlg, nIDDlgItem, szBuf);
    }
}

void GetDwordEdtField(HWND hDlg, DWORD * pdwData, int nIDDlgItem)
{
    WCHAR szBuf[MAX_PATH];

    GetDlgItemText(hDlg, nIDDlgItem, szBuf, MAX_PATH);
    if (*szBuf ==0) // empty string
    {
        *pdwData = FIELD_UNSET;
    }
    else
    {
        *pdwData = _wtoi(szBuf);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\auniobj.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A U N I O B J . H
//
//  Contents:   CAtmUniCfg interface declaration
//
//  Notes:
//
//  Author:     tongl   21 Mar 1997
//
//-----------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"
#include "atmutil.h"
#include "pvcdata.h"

// Constants
static const WCHAR c_szPVC[] = L"PVC";

// Reg key value names ( non-configurable parameters )
static const WCHAR c_szMaxActiveSVCs[]          = L"MaxActiveSVCs";
static const WCHAR c_szMaxSVCsInProgress[]      = L"MaxSVCsInProgress";
static const WCHAR c_szMaxPMPSVCs[]             = L"MaxPMPSVCs";
static const WCHAR c_szMaxActiveParties[]       = L"MaxActiveParties";
static const WCHAR c_szMaxPartiesInProgress[]   = L"MaxPartiesInProgress";

// Default Reg key values ( non-configurable parameters )
static const c_dwWksMaxActiveSVCs = 256;
static const c_dwSrvMaxActiveSVCs = 1024;

static const c_dwWksMaxSVCsInProgress = 8;
static const c_dwSrvMaxSVCsInProgress = 32;

static const c_dwWksMaxPMPSVCs = 32;
static const c_dwSrvMaxPMPSVCs = 64;

static const c_dwWksMaxActiveParties = 64;
static const c_dwSrvMaxActiveParties = 512;

static const c_dwWksMaxPartiesInProgress = 8;
static const c_dwSrvMaxPartiesInProgress = 32;

// number of property sheet pages
static const INT c_cUniPages = 1;

/////////////////////////////////////////////////////////////////////////////
// CAtmUniCfg

class ATL_NO_VTABLE CAtmUniCfg :
    public CComObjectRoot,
    public CComCoClass<CAtmUniCfg, &CLSID_CAtmUniCfg>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentPropertyUi
{
public:
    CAtmUniCfg();
    ~CAtmUniCfg();

    BEGIN_COM_MAP(CAtmUniCfg)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()

    // DECLARE_NOT_AGGREGATABLE(CAtmUniCfg)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_AUNICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)         (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)         (DWORD dwSetupFlags,
                                 DWORD dwUpgradeFomBuildNo );
    STDMETHOD (ReadAnswerFile)  (PCWSTR pszAnswerFile,
                                 PCWSTR pszAnswerSection);
    STDMETHOD (Removing)();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk);
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk);
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

// help functions
    CUniAdapterInfo * GetSecondMemoryAdapterInfo()
    {
        return m_pSecondMemoryAdapterInfo;
    }

    void SetSecondMemoryModified()
    {
        m_fSecondMemoryModified = TRUE;
    }

private:
    // Place to keep the INetCfg pointer
    INetCfg * m_pnc;

    // Place to keep corresponding component object
    INetCfgComponent *  m_pnccUni;
    INetCfgComponent *  m_pnccRwan;

    // Place to keep the pointer to UI context
    IUnknown * m_pUnkContext;

    // (STL) List of adapter info structures
    UNI_ADAPTER_LIST    m_listAdapters;

    // Guid of the current connection
    tstring m_strGuidConn;

    // Second memory adapter info structures
    CUniAdapterInfo *   m_pSecondMemoryAdapterInfo;

    // Do we need to update registry on Apply
    BOOL    m_fSaveRegistry;
    BOOL    m_fUIParamChanged;

    BOOL    m_fSecondMemoryModified;

    // property page
    class CUniPage * m_uniPage;

    // Load parameters from registry
    HRESULT HrLoadSettings();

    // Save parameters to registry
    HRESULT HrSaveSettings();

    // Add/Remove adapters from first memory state
    HRESULT HrAddAdapter(INetCfgComponent * pncc);
    HRESULT HrRemoveAdapter(INetCfgComponent * pncc);

    HRESULT HrBindAdapter(INetCfgComponent * pnccAdapter);
    HRESULT HrUnBindAdapter(INetCfgComponent * pnccAdapter);

    // Set defaults for statis parameters
    HRESULT HrSaveDefaultSVCParam(HKEY hkey);

    // Check if a card guid string is on m_listAdapters
    BOOL fIsAdapterOnList(PCWSTR pszBindName, CUniAdapterInfo ** ppAdapterInfo);

    HRESULT HrSetConnectionContext();

    HRESULT HrSetupPropSheets(HPROPSHEETPAGE ** pahpsp, INT * pcPages);

    // Have we already load PVC info into memory
    BOOL    m_fPVCInfoLoaded;

    // load and save adapter PVC info to first memory
    HRESULT HrLoadPVCRegistry();
    HRESULT HrLoadAdapterPVCRegistry(HKEY hkeyAdapterParam, CUniAdapterInfo * pAdapterInfo);
    HRESULT HrSaveAdapterPVCRegistry(HKEY hkeyAdapterParam, CUniAdapterInfo * pAdapterInfo);

    // load and save adapter parameters to second memory
    HRESULT HrLoadAdapterPVCInfo();
    HRESULT HrSaveAdapterPVCInfo();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\pvcdata.h ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D A T A. H
//
//  Contents:   PVC parameters
//
//  Notes:
//
//  Author:     tongl   20 Feb, 1998
//
//-----------------------------------------------------------------------
#pragma once

#define FIELD_ANY           ((ULONG)0xffffffff)
#define FIELD_ABSENT        ((ULONG)0xfffffffe)

#define FIELD_UNSET         ((ULONG)0xfffffffd)

const int c_iCellSize = 48;
const int c_iKbSize = 1000;

const DWORD c_dwDefTransmitByteBurstLength = 9188;
const DWORD c_dwDefTransmitMaxSduSize = 9188;

static const WCHAR c_szDefaultCallingAtmAddr[] =
            L"0000000000000000000000000000000000000001";
static const WCHAR c_szDefaultCalledAtmAddr[] =
            L"0000000000000000000000000000000000000000";

const int MAX_VPI = 255;
const int MIN_VCI = 32;
const int MAX_VCI = 1023;

const int c_nSnapIdMaxBytes = 5;
const int c_nHighLayerInfoMaxBytes = 8;

enum PVCType
{
    PVC_ATMARP =1,
    PVC_PPP_ATM_CLIENT =2,
    PVC_PPP_ATM_SERVER =3,
    PVC_CUSTOM =4
};

enum AALType
{
    // AAL_TYPE_AAL0= 1,
    // AAL_TYPE_AAL1= 2,
    // AAL_TYPE_AAL34= 4,
    AAL_TYPE_AAL5= 8
};

// ATM Service Category
enum ATM_SERVICE_CATEGORY
{
    ATM_SERVICE_CATEGORY_CBR = 1,   // Constant Bit Rate
    ATM_SERVICE_CATEGORY_VBR = 2,   // Variable Bit Rate
    ATM_SERVICE_CATEGORY_UBR = 4,   // Unspecified Bit Rate
    ATM_SERVICE_CATEGORY_ABR = 8    // Available Bit Rate
};

void SetPvcDwordParam(HKEY hkeyAdapterPVCId,
                      PCWSTR pszParamName,
                      DWORD dwParam);

class CPvcInfo
{
public:
    CPvcInfo(PCWSTR pszPvcId);
    ~CPvcInfo();

    CPvcInfo &  operator=(const CPvcInfo & PvcInfo);  // copy operator
    void SetDefaults(PVCType type);
    void SetTypeDefaults(PVCType type);

    void SetDefaultsForAtmArp();
    void SetDefaultsForPPPOut();
    void SetDefaultsForPPPIn();
    void SetDefaultsForCustom();

    void ResetOldValues();

    // the registry key where this PVC is stored
    tstring m_strPvcId;

    // this PVC has been deleted
    BOOL m_fDeleted;

    // PVC_TYPE
    PVCType   m_dwPVCType;
    PVCType   m_dwOldPVCType;

    // Required Attributes
    tstring m_strName;      // PVC display name
    tstring m_strOldName;

    DWORD   m_dwVpi;
    DWORD   m_dwOldVpi;

    DWORD   m_dwVci;
    DWORD   m_dwOldVci;

    AALType   m_dwAAL;
    AALType   m_dwOldAAL;

    // Matching creteria
    tstring m_strCallingAddr;
    tstring m_strOldCallingAddr;

    tstring m_strCalledAddr;
    tstring m_strOldCalledAddr;

    // Flags
    DWORD   m_dwFlags;

    // Quality Info
    DWORD m_dwTransmitPeakCellRate;
    DWORD m_dwOldTransmitPeakCellRate;

    DWORD m_dwTransmitAvgCellRate;
    DWORD m_dwOldTransmitAvgCellRate;

    DWORD m_dwTransmitByteBurstLength;
    DWORD m_dwOldTransmitByteBurstLength;

    DWORD m_dwTransmitMaxSduSize;
    DWORD m_dwOldTransmitMaxSduSize;

    ATM_SERVICE_CATEGORY m_dwTransmitServiceCategory;
    ATM_SERVICE_CATEGORY m_dwOldTransmitServiceCategory;

    DWORD m_dwReceivePeakCellRate;
    DWORD m_dwOldReceivePeakCellRate;

    DWORD m_dwReceiveAvgCellRate;
    DWORD m_dwOldReceiveAvgCellRate;

    DWORD m_dwReceiveByteBurstLength;
    DWORD m_dwOldReceiveByteBurstLength;

    DWORD m_dwReceiveMaxSduSize;
    DWORD m_dwOldReceiveMaxSduSize;

    ATM_SERVICE_CATEGORY m_dwReceiveServiceCategory;
    ATM_SERVICE_CATEGORY m_dwOldReceiveServiceCategory;

    // Local BLLI and BHLI info
    DWORD m_dwLocalLayer2Protocol;
    DWORD m_dwOldLocalLayer2Protocol;

    DWORD m_dwLocalUserSpecLayer2;
    DWORD m_dwOldLocalUserSpecLayer2;

    DWORD m_dwLocalLayer3Protocol;
    DWORD m_dwOldLocalLayer3Protocol;

    DWORD m_dwLocalUserSpecLayer3;
    DWORD m_dwOldLocalUserSpecLayer3;

    DWORD m_dwLocalLayer3IPI;
    DWORD m_dwOldLocalLayer3IPI;

    tstring m_strLocalSnapId;
    tstring m_strOldLocalSnapId;

    DWORD m_dwLocalHighLayerInfoType;
    DWORD m_dwOldLocalHighLayerInfoType;

    tstring m_strLocalHighLayerInfo;
    tstring m_strOldLocalHighLayerInfo;

    // Destination BLLI and BHLI info
    DWORD m_dwDestnLayer2Protocol;
    DWORD m_dwOldDestnLayer2Protocol;

    DWORD m_dwDestnUserSpecLayer2;
    DWORD m_dwOldDestnUserSpecLayer2;

    DWORD m_dwDestnLayer3Protocol;
    DWORD m_dwOldDestnLayer3Protocol;

    DWORD m_dwDestnUserSpecLayer3;
    DWORD m_dwOldDestnUserSpecLayer3;

    DWORD m_dwDestnLayer3IPI;
    DWORD m_dwOldDestnLayer3IPI;

    tstring m_strDestnSnapId;
    tstring m_strOldDestnSnapId;

    DWORD m_dwDestnHighLayerInfoType;
    DWORD m_dwOldDestnHighLayerInfoType;

    tstring m_strDestnHighLayerInfo;
    tstring m_strOldDestnHighLayerInfo;
};

typedef list<CPvcInfo*>  PVC_INFO_LIST;

//
// ATMUNI Call Manager Property structure
// holds adapter specific PVC parameters (configurable ) and state
//

class CUniAdapterInfo
{
public:
    CUniAdapterInfo(){};
    ~CUniAdapterInfo(){};

    CUniAdapterInfo &  operator=(const CUniAdapterInfo & AdapterInfo);  // copy operator
    void SetDefaults(PCWSTR pszBindName);

    // the adapter's binding state
    AdapterBindingState    m_BindingState;

    // Instance Guid of net card
    tstring m_strBindName;

    PVC_INFO_LIST   m_listPVCs;

    // flags
    BOOL    m_fDeleted;
};

typedef list<CUniAdapterInfo*> UNI_ADAPTER_LIST;

// Constants
// Registry key names

static const WCHAR c_szPVCType[] = L"PVCType";
static const WCHAR c_szPVCName[] = L"PVCName";

// main page
static const WCHAR c_szVpi[]            = L"Vpi";
static const WCHAR c_szVci[]            = L"Vci";
static const WCHAR c_szAALType[]        = L"AALType";
static const WCHAR c_szCallingParty[]   = L"CallingParty";
static const WCHAR c_szCalledParty[]    = L"CalledParty";

// flags
static const WCHAR c_szFlags[] = L"Flags";

// qos
static const WCHAR c_szTransmitPeakCellRate[]       = L"TransmitPeakCellRate";
static const WCHAR c_szTransmitAvgCellRate[]        = L"TransmitAvgCellRate";
static const WCHAR c_szTransmitByteBurstLength[]    = L"TransmitByteBurstLength";
static const WCHAR c_szTransmitMaxSduSize[]         = L"TransmitMaxSduSize";
static const WCHAR c_szTransmitServiceCategory[]    = L"TransmitServiceCategory";

static const WCHAR c_szReceivePeakCellRate[]        = L"ReceivePeakCellRate";
static const WCHAR c_szReceiveAvgCellRate[]         = L"ReceiveAvgCellRate";
static const WCHAR c_szReceiveByteBurstLength[]     = L"ReceiveByteBurstLength";
static const WCHAR c_szReceiveMaxSduSize[]          = L"ReceiveMaxSduSize";
static const WCHAR c_szReceiveServiceCategory[]     = L"ReceiveServiceCategory";

// BLLI & BHLI
static const WCHAR c_szLocalLayer2Protocol[]        = L"LocalLayer2Protocol";
static const WCHAR c_szLocalUserSpecLayer2[]        = L"LocalUserSpecLayer2";
static const WCHAR c_szLocalLayer3Protocol[]        = L"LocalLayer3Protocol";
static const WCHAR c_szLocalUserSpecLayer3[]        = L"LocalUserSpecLayer3";
static const WCHAR c_szLocalLayer3IPI[]             = L"LocalLayer3IPI";
static const WCHAR c_szLocalSnapId[]                = L"LocalSnapId";

static const WCHAR c_szLocalHighLayerInfoType[]     = L"LocalHighLayerInfoType";
static const WCHAR c_szLocalHighLayerInfo[]         = L"LocalHighLayerInfo";

static const WCHAR c_szDestnLayer2Protocol[]        = L"DestnLayer2Protocol";
static const WCHAR c_szDestnUserSpecLayer2[]        = L"DestnUserSpecLayer2";
static const WCHAR c_szDestnLayer3Protocol[]        = L"DestnLayer3Protocol";
static const WCHAR c_szDestnUserSpecLayer3[]        = L"DestnUserSpecLayer3";
static const WCHAR c_szDestnLayer3IPI[]             = L"DestnLayer3IPI";
static const WCHAR c_szDestnSnapId[]                = L"DestnSnapId";

static const WCHAR c_szDestnHighLayerInfoType[]     = L"DestnHighLayerInfoType";
static const WCHAR c_szDestnHighLayerInfo[]         = L"DestnHighLayerInfo";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\atmcfg\pvcdlg.cpp ===
//-----------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P V C D L G . C P P
//
//  Contents:   PVC main dialog message handler implementation
//
//  Notes:
//
//  Author:     tongl   23 Feb, 1998
//
//-----------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "auniobj.h"
#include "atmutil.h"
#include "aunidlg.h"
#include "atmcommon.h"
#include "pvcdata.h"

#include "ncatlui.h"
#include "ncstl.h"
#include "ncui.h"

#include "atmhelp.h"

CPVCMainDialog::CPVCMainDialog( CUniPage * pUniPage,
                                CPvcInfo *  pPvcInfo,
                                const DWORD* adwHelpIDs)
{
    Assert(pUniPage);
    Assert(pPvcInfo);

    m_pParentDlg = pUniPage;
    m_pPvcInfo = pPvcInfo;
    m_adwHelpIDs = adwHelpIDs;

    m_fDialogModified = FALSE;

    m_fPropShtOk = FALSE;
    m_fPropShtModified = FALSE;

    m_pQosPage    = NULL;
    m_pLocalPage  = NULL;
    m_pDestPage   = NULL;
}

CPVCMainDialog::~CPVCMainDialog()
{
    if (m_pQosPage != NULL)
	{
		delete (m_pQosPage);
	}

    if (m_pLocalPage != NULL)
	{
		delete (m_pLocalPage);
	}

    if (m_pDestPage != NULL)
	{
		delete (m_pDestPage);
	}
}

LRESULT CPVCMainDialog::OnInitDialog(UINT uMsg, WPARAM wParam,
                                     LPARAM lParam, BOOL& fHandled)
{
    m_CurType = m_pPvcInfo->m_dwPVCType;

    InitInfo();
    SetInfo();
    return 0;
}

LRESULT CPVCMainDialog::OnContextMenu(UINT uMsg, WPARAM wParam,
                                      LPARAM lParam, BOOL& fHandled)
{
    ShowContextHelp(m_hWnd, HELP_CONTEXTMENU, m_adwHelpIDs);
    return 0;
}

LRESULT CPVCMainDialog::OnHelp(UINT uMsg, WPARAM wParam,
                               LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ShowContextHelp(static_cast<HWND>(lphi->hItemHandle), HELP_WM_HELP,
                        m_adwHelpIDs);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnOk(WORD wNotifyCode, WORD wID,
                             HWND hWndCtl, BOOL& fHandled)
{
    // load the info from the controls to memory structure
    UpdateInfo();

    // make sure vpi, vci are in their range
    if (m_pPvcInfo->m_dwVpi > MAX_VPI)
    {
        // we pop up a message box and set focus to the vpi edit box
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_VPI,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_PVC_VPI));
        return 0;
    }

    if ((m_pPvcInfo->m_dwVci<MIN_VCI) || (m_pPvcInfo->m_dwVci>MAX_VCI))
    {
        // we pop up a message box and set focus to the vpi edit box
        NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_VCI,
                                MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

        ::SetFocus(GetDlgItem(IDC_EDT_PVC_VCI));
        return 0;
    }

    // make sure calling and called atm addresses are correct in format
    int i, nId;

    if (m_pPvcInfo->m_strCallingAddr != c_szEmpty)
    {
        if (!FIsValidAtmAddress((PWSTR)m_pPvcInfo->m_strCallingAddr.c_str(), &i, &nId))
        {
            // we pop up a message box and set focus to the calling address edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_Calling_Address,
                                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(IDC_EDT_PVC_AnswerAddr));
            return 0;
        }
    }

    if (m_pPvcInfo->m_strCalledAddr != c_szEmpty)
    {
        if (!FIsValidAtmAddress((PWSTR)m_pPvcInfo->m_strCalledAddr.c_str(), &i, &nId))
        {
            // we pop up a message box and set focus to the calling address edit box
            NcMsgBox(m_hWnd, IDS_MSFT_UNI_TEXT, IDS_INVALID_Called_Address,
                                    MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);

            ::SetFocus(GetDlgItem(IDC_EDT_PVC_CallAddr));
            return 0;
        }
    }

    // set the modified bit
    if (!m_fDialogModified)
    {
        if ((m_pPvcInfo->m_dwVpi != m_pPvcInfo->m_dwOldVpi) ||
            (m_pPvcInfo->m_dwVci != m_pPvcInfo->m_dwOldVci) ||
            (m_pPvcInfo->m_dwAAL != m_pPvcInfo->m_dwOldAAL) ||
            (m_pPvcInfo->m_strCallingAddr != m_pPvcInfo->m_strCallingAddr) ||
            (m_pPvcInfo->m_strCalledAddr  != m_pPvcInfo->m_strOldCalledAddr)
           )
        {
            m_fDialogModified = TRUE;
        }
    }

    EndDialog(IDOK);
    return 0;
}

LRESULT CPVCMainDialog::OnCancel(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    EndDialog(IDCANCEL);
    return 0;
}

LRESULT CPVCMainDialog::OnType(WORD wNotifyCode, WORD wID,
                               HWND hWndCtl, BOOL& fHandled)
{
    // $REVIEW(tongl 2/27/98): confirmed this behaviour with ArvindM
    // When type changes, we reset all the type related defaults
    // to match the new type ...

    // get the new selection
    int idx = (int)SendDlgItemMessage(IDC_CMB_PVC_Type, CB_GETCURSEL, (LPARAM)(0), 0);
    if (idx != CB_ERR)
    {
        if (idx != m_CurType-1) // type has changed
        {
            UpdateInfo();
            m_CurType = (PVCType)(idx+1);
            m_pPvcInfo->SetTypeDefaults(m_CurType);

            // update the UI
            SetInfo();
        }
    }
    return 0;
}

LRESULT CPVCMainDialog::OnSpecifyCallAddr(WORD wNotifyCode, WORD wID,
                                          HWND hWndCtl, BOOL& fHandled)
{
    if (IsDlgButtonChecked(IDC_CHK_PVC_CallAddr))
    {
        // enable the calling address control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), TRUE);
    }
    else
    {
        // disable the control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), FALSE);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnSpecifyAnswerAddr(WORD wNotifyCode, WORD wID,
                                            HWND hWndCtl, BOOL& fHandled)
{
    if (IsDlgButtonChecked(IDC_CHK_PVC_AnswerAddr))
    {
        // enable the calling address control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), TRUE);
    }
    else
    {
        // disable the control
        ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), FALSE);
    }

    return 0;
}

LRESULT CPVCMainDialog::OnAdvanced(WORD wNotifyCode, WORD wID,
                                   HWND hWndCtl, BOOL& fHandled)
{
    switch (wNotifyCode)
    {
    case BN_CLICKED:
    case BN_DOUBLECLICKED:

        // Make a copy of the current PVC info and pass to the
        // advanced property sheet pages

        // get what's in the main UI to in memory structure
        UpdateInfo();

        CPvcInfo * pPvcInfoDlg = new CPvcInfo(m_pPvcInfo->m_strPvcId.c_str());

        if (pPvcInfoDlg)
        {
			*pPvcInfoDlg = *m_pPvcInfo;

			// Bring up the advanced PVC property sheet
			HRESULT hr = HrDoPvcPropertySheet(pPvcInfoDlg);
			if (S_OK == hr)
			{
				if (m_fPropShtOk && m_fPropShtModified)
				{
					// Something changed, so mark the page as modified
					m_fDialogModified = TRUE;

					// Reset values
					m_fPropShtOk = FALSE;
					m_fPropShtModified = FALSE;

					// Update second memory info structure
					*m_pPvcInfo = *pPvcInfoDlg;
				}
			}

			delete pPvcInfoDlg;
        }
        break;
    }

    return 0;
}

HRESULT CPVCMainDialog::HrDoPvcPropertySheet(CPvcInfo * pPvcInfoDlg)
{
    Assert(pPvcInfoDlg);
    HRESULT hr = S_OK;

    HPROPSHEETPAGE *ahpsp = NULL;
    int cPages = 0;

    // Create property pages
    hr = HrSetupPropPages(pPvcInfoDlg, &ahpsp, &cPages);
    if (SUCCEEDED(hr))
    {
        // Show the property sheet
        PROPSHEETHEADER psh = {0};

        psh.dwSize = sizeof(PROPSHEETHEADER);
        psh.dwFlags = PSH_NOAPPLYNOW;
        psh.hwndParent = ::GetActiveWindow();
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszIcon = NULL;
        psh.pszCaption = (PWSTR)SzLoadIds(IDS_ADV_PVC_HEADER);
        psh.nPages = cPages;
        psh.phpage = ahpsp;

        INT_PTR iRet = PropertySheet(&psh);
        if (-1 == iRet)
        {
            hr = HrFromLastWin32Error();
        }

        CoTaskMemFree(ahpsp);
    }

    TraceError("CPVCMainDialog::DoPropertySheet", hr);
    return hr;
}

HRESULT CPVCMainDialog::HrSetupPropPages( CPvcInfo * pPvcInfoDlg,
                                          HPROPSHEETPAGE ** pahpsp,
                                          INT * pcPages)
{
    HRESULT hr = S_OK;

    *pahpsp = NULL;
    *pcPages = 0;

    int cPages = 0;
    HPROPSHEETPAGE *ahpsp = NULL;

    delete (m_pQosPage);
    m_pQosPage    = NULL;

    delete (m_pLocalPage);
    m_pLocalPage  = NULL;

    delete (m_pDestPage);
    m_pDestPage   = NULL;

    // Set up the property pages
    m_pQosPage = new CPvcQosPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Traffic);
    if (!m_pQosPage)
    {
        return E_OUTOFMEMORY;
    }

    cPages = 1;

    if (m_pPvcInfo->m_dwPVCType == PVC_CUSTOM)
    {
        m_pLocalPage  = new CPvcLocalPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Local);
        if (!m_pLocalPage)
        {
            return E_OUTOFMEMORY;
        }

        m_pDestPage   = new CPvcDestPage(this, pPvcInfoDlg, g_aHelpIDs_IDD_PVC_Dest);
        if (!m_pDestPage)
        {
            return E_OUTOFMEMORY;
        }

        cPages = 3;
    }

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)* cPages);
    if (!ahpsp)
    {
        return E_OUTOFMEMORY;
    }

    cPages =0;

    ahpsp[cPages++] = m_pQosPage->CreatePage(IDD_PVC_Traffic, 0);

    if (m_pPvcInfo->m_dwPVCType == PVC_CUSTOM)
    {
        ahpsp[cPages++] = m_pLocalPage->CreatePage(IDD_PVC_Local, 0);
        ahpsp[cPages++] = m_pDestPage->CreatePage(IDD_PVC_Dest, 0);
    }

    *pahpsp = ahpsp;
    *pcPages = cPages;

    return hr;
}

void CPVCMainDialog::InitInfo()
{
    // set limits & selections to the controls

    // PVC name
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_Name), EM_SETLIMITTEXT, MAX_PATH, 0);

    // VPI
    // length limit
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_VPI), EM_SETLIMITTEXT, MAX_VPI_LENGTH, 0);

    // VCI
    // length limit
    ::SendMessage(GetDlgItem(IDC_EDT_PVC_VCI), EM_SETLIMITTEXT, MAX_VCI_LENGTH, 0);

    // AAL TYpe
    // $REVIEW(tongl 2/24/98): per ArvindM, only AAL5 is supported in NT5
    SendDlgItemMessage(IDC_CMB_PVC_AAL,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_AAL5)));

    // PVC_TYPE
    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_ATMARP)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_PPP_ATM_CLIENT)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_PPP_ATM_SERVER)));

    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_ADDSTRING, 0, (LPARAM)((PWSTR) SzLoadIds(IDS_PVC_CUSTOM)));
}

void CPVCMainDialog::SetInfo()
{
    // Name
    SetDlgItemText(IDC_EDT_PVC_Name, m_pPvcInfo->m_strName.c_str());

    // VPI
    WCHAR szVpi[MAX_VPI_LENGTH+1];
    wsprintfW(szVpi, c_szItoa, m_pPvcInfo->m_dwVpi);
    SetDlgItemText(IDC_EDT_PVC_VPI, szVpi);

    // VCI
    if (FIELD_UNSET != m_pPvcInfo->m_dwVci)
    {
        WCHAR szVci[MAX_VCI_LENGTH+1];
        wsprintfW(szVci, c_szItoa, m_pPvcInfo->m_dwVci);
        SetDlgItemText(IDC_EDT_PVC_VCI, szVci);
    }

    // AAL TYpe
    SendDlgItemMessage(IDC_CMB_PVC_AAL,
                       CB_SETCURSEL, (LPARAM)(0), 0);

    // PVC_TYPE
    SendDlgItemMessage(IDC_CMB_PVC_Type,
                       CB_SETCURSEL, (LPARAM)(m_pPvcInfo->m_dwPVCType-1), 0);

    // calling addresses
    BOOL fAddrSpecified = (m_pPvcInfo->m_strCalledAddr != c_szEmpty);

    ::EnableWindow(GetDlgItem(IDC_CHK_PVC_CallAddr), TRUE);
    CheckDlgButton(IDC_CHK_PVC_CallAddr, fAddrSpecified);

    ::EnableWindow(GetDlgItem(IDC_EDT_PVC_CallAddr), fAddrSpecified);

    if (fAddrSpecified)
    {
        SetDlgItemText(IDC_EDT_PVC_CallAddr, m_pPvcInfo->m_strCalledAddr.c_str());
    }

    // answering address
    fAddrSpecified = (m_pPvcInfo->m_strCallingAddr != c_szEmpty);

    ::EnableWindow(GetDlgItem(IDC_CHK_PVC_AnswerAddr), TRUE);
    CheckDlgButton(IDC_CHK_PVC_AnswerAddr, fAddrSpecified);

    ::EnableWindow(GetDlgItem(IDC_EDT_PVC_AnswerAddr), fAddrSpecified);

    if (fAddrSpecified)
    {
        SetDlgItemText(IDC_EDT_PVC_AnswerAddr, m_pPvcInfo->m_strCallingAddr.c_str());
    }

    // disable the calling address\answer address controls if the type is ATMARP
    // Bug #179335
    if (m_pPvcInfo->m_dwPVCType == PVC_ATMARP)
    {
        // disable all controls on this doalog
        static const int nrgIdc[] = {IDC_CHK_PVC_CallAddr,
                                     IDC_EDT_PVC_CallAddr,
                                     IDC_CHK_PVC_AnswerAddr,
                                     IDC_EDT_PVC_AnswerAddr};

        EnableOrDisableDialogControls(m_hWnd, celems(nrgIdc), nrgIdc, FALSE);
    }
}

// Update the in memory structure with what's in the dialog
void CPVCMainDialog::UpdateInfo()
{
    WCHAR szBuf[MAX_PATH];

    // Name
    GetDlgItemText(IDC_EDT_PVC_Name, szBuf, MAX_PATH);
    m_pPvcInfo->m_strName = szBuf;

    // VPI
    GetDlgItemText(IDC_EDT_PVC_VPI, szBuf, MAX_VPI_LENGTH+1);
    m_pPvcInfo->m_dwVpi = _wtoi(szBuf);

    // VCI
    GetDlgItemText(IDC_EDT_PVC_VCI, szBuf, MAX_VCI_LENGTH+1);
    if (*szBuf ==0) // empty string
    {
        m_pPvcInfo->m_dwVci = FIELD_UNSET;
    }
    else
    {
        m_pPvcInfo->m_dwVci = _wtoi(szBuf);
    }

    // current selection
    int idx = (int)SendDlgItemMessage(IDC_CMB_PVC_Type, CB_GETCURSEL, (LPARAM)(0), 0);
    if (idx != CB_ERR)
    {
        m_pPvcInfo->m_dwPVCType = (PVCType)(idx+1);
    }

    // calling addresses
    if (!IsDlgButtonChecked(IDC_CHK_PVC_CallAddr))
    {
        m_pPvcInfo->m_strCalledAddr = c_szEmpty;
    }
    else
    {
        GetDlgItemText(IDC_EDT_PVC_CallAddr, szBuf, MAX_ATM_ADDRESS_LENGTH+1);
        m_pPvcInfo->m_strCalledAddr = szBuf;
    }

    // answering address
    if (!IsDlgButtonChecked(IDC_CHK_PVC_AnswerAddr))
    {
        m_pPvcInfo->m_strCallingAddr = c_szEmpty;
    }
    else
    {
        GetDlgItemText(IDC_EDT_PVC_AnswerAddr, szBuf, MAX_ATM_ADDRESS_LENGTH+1);
        m_pPvcInfo->m_strCallingAddr = szBuf;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\brdgcfg\brdgobj.cpp ===
#include "pch.h"
#pragma hdrstop

#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>
#include <netcfgx.h>

#include "brdgobj.h"
#include "trace.h"
#include "ncbase.h"
#include "ncmem.h"
#include "ncreg.h"

// =================================================================
// string constants
//
const WCHAR c_szSBridgeNOParams[]           = L"System\\CurrentControlSet\\Services\\BridgeMP";
const WCHAR c_szSBridgeDeviceValueName[]    = L"Device";
const WCHAR c_szSBridgeDevicePrefix[]       = L"\\Device\\";
const WCHAR c_szSBrigeMPID[]                = L"ms_bridgemp";

// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::CBridgeNO
//
// Purpose:   constructor for class CBridgeNO
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBridgeNO::CBridgeNO(VOID) :
        m_pncc(NULL),
        m_pnc(NULL),
        m_eApplyAction(eBrdgActUnknown)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::CBridgeNO()" );
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::~CBridgeNO
//
// Purpose:   destructor for class CBridgeNO
//
// Arguments: None
//
// Returns:   None
//
// Notes:
//
CBridgeNO::~CBridgeNO(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::~CBridgeNO()" );

    // release interfaces if acquired
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);
}

// =================================================================
// INetCfgNotify
//
// The following functions provide the INetCfgNotify interface
// =================================================================


// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Initialize
//
// Purpose:   Initialize the notify object
//
// Arguments:
//    pnccItem    [in]  pointer to INetCfgComponent object
//    pnc         [in]  pointer to INetCfg object
//    fInstalling [in]  TRUE if we are being installed
//
// Returns:
//
// Notes:
//
STDMETHODIMP CBridgeNO::Initialize(INetCfgComponent* pnccItem,
        INetCfg* pnc, BOOL fInstalling)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::Initialize()" );

    // save INetCfg & INetCfgComponent and add refcount
    m_pncc = pnccItem;
    m_pnc = pnc;

    AddRefObj( m_pncc );
    AddRefObj( m_pnc );

    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::ReadAnswerFile
//
// Purpose:   Read settings from answerfile and configure the bridge
//
// Arguments:
//    pszAnswerFile    [in]  name of AnswerFile
//    pszAnswerSection [in]  name of parameters section
//
// Returns:
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::ReadAnswerFile(PCWSTR pszAnswerFile,
        PCWSTR pszAnswerSection)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::ReadAnswerFile()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Install
//
// Purpose:   Do operations necessary for install.
//
// Arguments:
//    dwSetupFlags [in]  Setup flags
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the config. actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::Install(DWORD dw)
{
    //
    // Remember that we're installing. If the user doesn't cancel, we'll actually perform
    // our work in ApplyRegistryChanges().
    //
    TraceTag( ttidBrdgCfg, "CBridgeNO::Install()" );
    m_eApplyAction = eBrdgActInstall;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::Removing
//
// Purpose:   Do necessary cleanup when being removed
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     Dont do anything irreversible (like modifying registry) yet
//            since the removal is actually complete only when Apply is called!
//
STDMETHODIMP CBridgeNO::Removing(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::Removing()" );
    m_eApplyAction = eBrdgActRemove;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::CancelChanges
//
// Purpose:   Cancel any changes made to internal data
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::CancelChanges(VOID)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::CancelChanges()" );
    m_eApplyAction = eBrdgActUnknown;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::ApplyRegistryChanges
//
// Purpose:   Apply changes.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:     We can make changes to registry etc. here.
//
STDMETHODIMP CBridgeNO::ApplyRegistryChanges(VOID)
{
    HRESULT             hr = S_OK;

    TraceTag( ttidBrdgCfg, "CBridgeNO::ApplyRegistryChanges()" );

    //
    // We only do work on install
    //
    if( m_eApplyAction == eBrdgActInstall )
    {
        INetCfgComponent    *pNetCfgComp;

        TraceTag( ttidBrdgCfg, "Attempting to write device name in CBridgeNO::ApplyRegistryChanges()" );
        hr = m_pnc->FindComponent( c_szSBrigeMPID, &pNetCfgComp );

        if( SUCCEEDED ( hr) )
        {
            LPWSTR          wszBindName;

            hr = pNetCfgComp->GetBindName(&wszBindName);

            if( SUCCEEDED(hr) )
            {
                UINT        BindNameLen, PrefixLen;
                LPWSTR      wszDeviceName;

                // Get enough memory to build a string with the device prefix and the bind name
                // concatenated
                BindNameLen = wcslen(wszBindName);
                PrefixLen = wcslen(c_szSBridgeDevicePrefix);
                wszDeviceName = (WCHAR*)malloc( sizeof(WCHAR) * (BindNameLen + PrefixLen + 1) );

                if( wszDeviceName != NULL )
                {
                    HKEY        hkeyServiceParams;

                    // Create the concatenated string
                    wcscpy( wszDeviceName, c_szSBridgeDevicePrefix );
                    wcscat( wszDeviceName, wszBindName );

                    // Create the reg key where we need to stash the device name
                    hr = HrRegCreateKeyEx( HKEY_LOCAL_MACHINE, c_szSBridgeNOParams, REG_OPTION_NON_VOLATILE,
                                           KEY_ALL_ACCESS, NULL, &hkeyServiceParams, NULL );

                    if( SUCCEEDED(hr)  )
                    {
                        // Write out the device name
                        hr = HrRegSetSz( hkeyServiceParams, c_szSBridgeDeviceValueName, wszDeviceName );

                        if( FAILED(hr)  )
                        {
                            TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "HrRegSetSz failed in CBridgeNO::ApplyRegistryChanges()");
                        }

                        RegCloseKey( hkeyServiceParams );
                    }
                    else
                    {
                        TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "HrRegCreateKeyEx failed in CBridgeNO::ApplyRegistryChanges()");
                    }

                    free( wszDeviceName );
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "malloc failed in CBridgeNO::ApplyRegistryChanges()");
                }

                CoTaskMemFree( wszBindName );
            }
            else
            {
                TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "pNetCfgComp->GetBindName failed in CBridgeNO::ApplyRegistryChanges()");
            }

            pNetCfgComp->Release();
        }
        else
        {
            TraceHr( ttidBrdgCfg, FAL, hr, FALSE, "m_pnc->FindComponent failed in CBridgeNO::ApplyRegistryChanges()");
        }
    }

    // Paranoia
    m_eApplyAction = eBrdgActUnknown;

    return hr;
}

STDMETHODIMP
CBridgeNO::ApplyPnpChanges(
    IN INetCfgPnpReconfigCallback* pICallback)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::ApplyPnpChanges()" );
    return S_OK;
}

// =================================================================
// INetCfgSystemNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::GetSupportedNotifications
//
// Purpose:   Tell the system which notifications we are interested in
//
// Arguments:
//    pdwNotificationFlag [out]  pointer to NotificationFlag
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::GetSupportedNotifications(
        OUT DWORD* pdwNotificationFlag)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::GetSupportedNotifications()" );
    *pdwNotificationFlag = NCN_ADD | NCN_ENABLE | NCN_UPDATE | NCN_BINDING_PATH;
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysQueryBindingPath
//
// Purpose:   Allow or veto formation of a binding path
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysQueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    HRESULT         hr = S_OK;
    BOOLEAN         bReject = FALSE;

    TraceTag( ttidBrdgCfg, "CBridgeNO::SysQueryBindingPath()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysNotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbpItem    [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysNotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbpItem)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::SysNotifyBindingPath()" );
    return S_OK;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::SysNotifyComponent
//
// Purpose:   System tells us by calling this function which
//            component has undergone a change (installed/removed)
//
// Arguments:
//    dwChangeFlag [in]  type of system change
//    pncc         [in]  pointer to INetCfgComponent object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::SysNotifyComponent(DWORD dwChangeFlag,
        INetCfgComponent* pncc)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::SysNotifyComponent()" );
    return S_OK;
}

// =================================================================
// INetCfgBindNotify
// =================================================================

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::QueryBindingPath
//
// Purpose:   Allow or veto a binding path involving us
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbi        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::QueryBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::QueryBindingPath()" );

    // The bridge protocol should never be enabled by default; it
    // should only be enabled programatically by the implementation
    // of our UI code which allows the activation of the bridge.
    return NETCFG_S_DISABLE_QUERY;
}

// ----------------------------------------------------------------------
//
// Function:  CBridgeNO::NotifyBindingPath
//
// Purpose:   System tells us by calling this function which
//            binding path involving us has just been formed.
//
// Arguments:
//    dwChangeFlag [in]  type of binding change
//    pncbp        [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
STDMETHODIMP CBridgeNO::NotifyBindingPath(DWORD dwChangeFlag,
        INetCfgBindingPath* pncbp)
{
    TraceTag( ttidBrdgCfg, "CBridgeNO::NotifyBindingPath()" );
    return S_OK;
}

// ------------ END OF NOTIFY OBJECT FUNCTIONS --------------------
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\brdgcfg\brdgobj.h ===
#pragma once

#include <ncxclsid.h>
#include <notifval.h>
#include "resource.h"

// What type of config change the user/system is performing
enum BridgeConfigAction {eBrdgActUnknown, eBrdgActInstall, eBrdgActRemove, eBrdgActPropertyUI};

class CBridgeNO :
    public CComObjectRoot,
    public CComCoClass<CBridgeNO, &CLSID_CBridgeObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyBinding,
    public INetCfgComponentNotifyGlobal
{
public:
    CBridgeNO(VOID);
    ~CBridgeNO(VOID);

    BEGIN_COM_MAP(CBridgeNO)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyBinding)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_BRIDGECFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR szAnswerFile,
                                     PCWSTR szAnswerSections);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Removing)            ();

// INetCfgNotifyBinding
    STDMETHOD (QueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (NotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    INetCfgComponent*   m_pncc;
    INetCfg*            m_pnc;
    BridgeConfigAction  m_eApplyAction;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\brdgcfg\resource.h ===
//#include <ncres.h>

#pragma once

#define IDR_REG_BRIDGECFG         40002
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dhcpscfg\dhcpsdef.h ===
// Only allow single inclusion of this file.
#pragma once

#define DHCP_ADMIN_MSC_NAME     L"dhcpadmn.msc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dhcpscfg\dhcpsobj.h ===
//
// D H C P S O B J . H
//
// Declaration of CDHCPServer and helper functions
//

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <ncsetup.h>
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
// DHCPServer

class ATL_NO_VTABLE CDHCPServer :
    public CComObjectRoot,
    public CComCoClass<CDHCPServer, &CLSID_CDHCPServer>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup
{
public:
    CDHCPServer();
    ~CDHCPServer();

    BEGIN_COM_MAP(CDHCPServer)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CDHCPServer)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_DHCPSCFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback) { return S_OK; }
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Removing)            ();

    // Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActUnknown, eActInstall, eActRemove};

// Private state info
private:
    INSTALLACTION       m_eInstallAction;
    BOOL                m_fUnattend;        // Are we installed unattended?
    INetCfgComponent *  m_pncc;             // Place to keep my component
    INetCfg *           m_pnc;              // Place to keep my component
    BOOL                m_fUpgrade;         // TRUE if we are upgrading with
                                            // an answer file

    tstring             m_strParamsRestoreFile;
    tstring             m_strConfigRestoreFile;

    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrProcessDhcpServerSolutionsParams(CSetupInfFile  * pcsif, PCWSTR pszAnswerSection);
    HRESULT HrWriteDhcpOptionInfo(HKEY hkeyDhcpCfg);
    HRESULT HrWriteDhcpSubnets(HKEY hkeyDhcpCfg, PCWSTR szSubnet, PCWSTR szStartIp,
                               DWORD dwEndIp, DWORD dwSubnetMask, DWORD dwLeaseDuration,
                               DWORD dwDnsServer, PCWSTR szDomainName);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrWriteUnattendedKeys();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dhcpscfg\resource.h ===
#include <ncres.h>

// String resources
#define IDS_DESC_COMOBJ_DHCPSCFG            IDS_NC_DHCPCFG + 0
#define IDS_DHCP_OPTION_006_NAME            IDS_NC_DHCPCFG + 1
#define IDS_DHCP_OPTION_006_COMMENT         IDS_NC_DHCPCFG + 2
#define IDS_DHCP_OPTION_015_NAME            IDS_NC_DHCPCFG + 3
#define IDS_DHCP_OPTION_015_COMMENT         IDS_NC_DHCPCFG + 4
#define IDS_DHCP_SUBNET_NAME                IDS_NC_DHCPCFG + 5
#define IDS_DHCP_SUBNET_COMMENT             IDS_NC_DHCPCFG + 6
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dll\implinc.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       I M P L I N C . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   25 Nov 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

// Include ATL's implementation.  Substitute _ASSERTE with our Assert.
//
#ifdef _ASSERTE
#undef _ASSERTE
#define _ASSERTE Assert
#endif

#include <atlimpl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dhcpscfg\dhcpsobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D H C P S O B J . C P P
//
//  Contents:   Implementation of the CDHCPServer notify object
//
//  Notes:
//
//  Author:     jeffspr   31 May 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "dhcpsobj.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncnetcfg.h"
#include "ncipaddr.h"
#include <dhcpapi.h>

extern const WCHAR c_szInfId_MS_DHCPServer[];
extern const WCHAR c_szAfDhcpServerConfiguration[];
extern const WCHAR c_szAfDhcpServerParameters[];


//---[ Constants ]------------------------------------------------------------

static const WCHAR c_szDHCPServerServicePath[]  = L"System\\CurrentControlSet\\Services\\DHCPServer";
static const WCHAR c_szDHCPServerParamPath[]    = L"System\\CurrentControlSet\\Services\\DHCPServer\\Parameters";
static const WCHAR c_szDHCPServerConfigPath[]   = L"System\\CurrentControlSet\\Services\\DHCPServer\\Configuration";
static const WCHAR c_szOptionInfo[]             = L"OptionInfo";
static const WCHAR c_szSubnets[]                = L"Subnets";
static const WCHAR c_szIpRanges[]               = L"IpRanges";
static const WCHAR c_szSubnetOptions[]          = L"SubnetOptions";

static const WCHAR c_szDHCPServerUnattendRegSection[]   = L"DHCPServer_Unattend";

const WCHAR c_szStartIp[]       = L"StartIp";
const WCHAR c_szEndIp[]         = L"EndIp";
const WCHAR c_szSubnetMask[]    = L"SubnetMask";
const WCHAR c_szLeaseDuration[] = L"LeaseDuration";
const WCHAR c_szDnsServer[]     = L"DnsServer";
const WCHAR c_szDomainName[]    = L"DomainName";



// Destructor
//

CDHCPServer::CDHCPServer()
{
    // Initialize member variables.
    m_pnc            = NULL;
    m_pncc           = NULL;
    m_eInstallAction = eActUnknown;
    m_fUpgrade       = FALSE;
    m_fUnattend      = FALSE;
}

CDHCPServer::~CDHCPServer()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    // Release KEY handles here.
}

//
// INetCfgNotify
//

STDMETHODIMP CDHCPServer::Initialize(   INetCfgComponent *  pnccItem,
                                        INetCfg *           pnc,
                                        BOOL                fInstalling)
{
    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "m_pncc NULL in CDHCPServer::Initialize");
    AssertSz(m_pnc, "m_pnc NULL in CDHCPServer::Initialize");

    // Addref the config objects
    //
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
// Function:  HrRestoreRegistrySz
//
// Purpose:   Restore a subkey from the specified file
//
// Arguments:
//    hkeyBase   [in]  handle of basekey
//    pszSubKey  [in]  subkey to restore
//    pszRegFile [in]  name of file to restore from
//
// Returns:   S_OK on success, otherwise an error code
//
// Author:    kumarp 16-September-98
//
// Notes:     This should be moved to common code
//
HRESULT
HrRestoreRegistrySz (
    IN HKEY   hkeyBase,
    IN PCWSTR pszSubKey,
    IN PCWSTR pszRegFile)
{
    Assert(hkeyBase);
    AssertValidReadPtr(pszSubKey);
    AssertValidReadPtr(pszRegFile);

    HRESULT hr;
    HKEY hkey = NULL;
    DWORD dwDisp;

    TraceTag(ttidDHCPServer, "restoring subkey '%S' from file '%S'",
             pszSubKey, pszRegFile);

    hr = HrEnablePrivilege (SE_RESTORE_NAME);
    if (S_OK == hr)
    {
        // Ensure key is there by creating it
        //
        hr = HrRegCreateKeyEx (hkeyBase, pszSubKey, REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE_DELETE, NULL, &hkey, &dwDisp);
        if (S_OK == hr)
        {
            // Restore the old settings
            //
            hr = HrRegRestoreKey (hkey, pszRegFile, 0);

            RegCloseKey (hkey);
        }
    }

    TraceError ("HrRestoreRegistrySz", hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrRestoreRegistry
//
//  Purpose:    Restores the contents of the registry for this component
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 error if failed, otherwise S_OK
//
//  Author:     jeffspr   13 Aug 1997
//
//  Notes:
//
HRESULT CDHCPServer::HrRestoreRegistry()
{
    HRESULT hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::HrRestoreRegistry()");

    // If we have a "configuration" key restore file
    //
    if (!m_strConfigRestoreFile.empty())
    {
        // We always want to continue, so ignore the return code
        //
        (void) HrRestoreRegistrySz(HKEY_LOCAL_MACHINE,
                                   c_szDHCPServerConfigPath,
                                   m_strConfigRestoreFile.c_str());
    }
    else
    {
        TraceTag(ttidDHCPServer, "DHCP Server Params restore file doesn't exist");
    }

    // If we have a params restore file
    //
    if (!m_strParamsRestoreFile.empty())
    {
        // We always want to continue, so ignore the return code
        //
        (void) HrRestoreRegistrySz(HKEY_LOCAL_MACHINE,
                                   c_szDHCPServerParamPath,
                                   m_strParamsRestoreFile.c_str());
    }
    else
    {
        TraceTag(ttidDHCPServer, "DHCP Server Params restore file doesn't exist");
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrRestoreRegistry");
    return hr;
}

HRESULT CDHCPServer::HrWriteUnattendedKeys()
{
    HRESULT                 hr          = S_OK;
    HKEY                    hkeyService = NULL;
    const COMPONENT_INFO *  pci         = NULL;

    Assert(m_fUnattend);

    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                        c_szDHCPServerServicePath,
                        KEY_READ_WRITE_DELETE,
                        &hkeyService);
    if (SUCCEEDED(hr))
    {
        Assert(hkeyService);

        pci = PComponentInfoFromComponentId(c_szInfId_MS_DHCPServer);
        if (pci)
        {
            CSetupInfFile   csif;

            // Open the answer file.
            hr = csif.HrOpen(pci->pszInfFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
            if (SUCCEEDED(hr))
            {
                // Install the unattend params
                //
                hr = HrSetupInstallFromInfSection (
                    NULL,
                    csif.Hinf(),
                    c_szDHCPServerUnattendRegSection,
                    SPINST_REGISTRY,
                    hkeyService,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL);
            }
        }
        RegCloseKey(hkeyService);
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrWriteUnattendedKeys");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrWriteDhcpOptionInfo
//
//  Purpose:    Write to the registry the Dhcp OptionInfo data.
//
//  Arguments:
//              hkeyConfig
//
//  Returns:    S_OK if successful, Reg API error otherwise.
//
//  Notes:
//
HRESULT CDHCPServer::HrWriteDhcpOptionInfo(HKEY hkeyConfig)
{
    HRESULT hr;
    DWORD   dwDisposition;
    HKEY    hkeyOptionInfo = NULL;

    typedef struct
    {
        const WCHAR * pcszOptionKeyName;
        const WCHAR * pcszOptionName;
        const WCHAR * pcszOptionComment;
        DWORD         dwOptionType;
        DWORD         dwOptionId;
        DWORD         cbBinData;
        DWORD       * pdwBinData;
    } OIDATA;

    OIDATA OiData[2];

    DWORD BinData006[] = {0x14, 0x4, 0x1, 0x0, 0x0};
    DWORD BinData015[] = {0x18, 0x5, 0x1, 0x0, 0x2, 0x0};

    OiData[0].pcszOptionKeyName = L"006";
    OiData[0].pcszOptionName    = SzLoadIds(IDS_DHCP_OPTION_006_NAME);    // DNS Servers
    OiData[0].pcszOptionComment = SzLoadIds(IDS_DHCP_OPTION_006_COMMENT); // Array of DNS Servers, by preference
    OiData[0].dwOptionType      = 0x1;
    OiData[0].dwOptionId        = 0x6;
    OiData[0].cbBinData         = celems(BinData006) * sizeof(BinData006[0]);
    OiData[0].pdwBinData        = BinData006;
    OiData[1].pcszOptionKeyName = L"015";
    OiData[1].pcszOptionName    = SzLoadIds(IDS_DHCP_OPTION_015_NAME);    // DNS Domain Name
    OiData[1].pcszOptionComment = SzLoadIds(IDS_DHCP_OPTION_015_COMMENT); // Domainname for client resolutions
    OiData[1].dwOptionType      = 0x0;
    OiData[1].dwOptionId        = 0xf;
    OiData[1].cbBinData         = celems(BinData015) * sizeof(BinData015[0]);
    OiData[1].pdwBinData        = BinData015;

    hr = ::HrRegCreateKeyEx(hkeyConfig, c_szOptionInfo,
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ, NULL,
                            &hkeyOptionInfo, &dwDisposition);
    if (SUCCEEDED(hr))
    {
        for (UINT idx=0;
             (idx<celems(OiData)) && SUCCEEDED(hr);
             idx++)
        {
            HKEY hkey = NULL;

            hr = ::HrRegCreateKeyEx(hkeyOptionInfo, OiData[idx].pcszOptionKeyName,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ_WRITE, NULL,
                                    &hkey, &dwDisposition);
            if (SUCCEEDED(hr))
            {
                (VOID)::HrRegSetString(hkey, L"OptionName",
                                       OiData[idx].pcszOptionName);
                (VOID)::HrRegSetString(hkey, L"OptionComment",
                                       OiData[idx].pcszOptionComment);
                (VOID)::HrRegSetDword(hkey, L"OptionType",
                                      OiData[idx].dwOptionType);
                (VOID)::HrRegSetDword(hkey, L"OptionId",
                                      OiData[idx].dwOptionId);
                (VOID)::HrRegSetBinary(hkey, L"OptionValue",
                                      (const BYTE *)OiData[idx].pdwBinData,
                                      OiData[idx].cbBinData);

                RegCloseKey(hkey);
            }
        }

        RegCloseKey(hkeyOptionInfo);
    }

    TraceError("HrWriteDhcpOptionInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrWriteDhcpSubnets
//
//  Purpose:    Write to the registry the Dhcp Subnet data.
//
//  Arguments:
//      hkeyDhcpCfg
//      pszSubnet
//      pszStartIp
//      dwEndIp
//      dwSubnetMask
//      dwLeaseDuration
//      dwDnsServer
//      pszDomainName
//
//  Returns:    S_OK if successful, Reg API error otherwise.
//
//  Notes:
//
HRESULT
CDHCPServer::HrWriteDhcpSubnets (
    HKEY   hkeyDhcpCfg,
    PCWSTR pszSubnet,
    PCWSTR pszStartIp,
    DWORD  dwEndIp,
    DWORD  dwSubnetMask,
    DWORD  dwLeaseDuration,
    DWORD  dwDnsServer,
    PCWSTR pszDomainName)
{
    DWORD   dwDisposition;
    HRESULT hr;
    HKEY    hkeySubnets = NULL;

    hr = HrRegCreateKeyEx(hkeyDhcpCfg, c_szSubnets, REG_OPTION_NON_VOLATILE,
            KEY_READ, NULL, &hkeySubnets, &dwDisposition);

    if (S_OK == hr)
    {
        HKEY hkey10Dot = NULL;
        hr = HrRegCreateKeyEx(hkeySubnets, pszSubnet, REG_OPTION_NON_VOLATILE,
                KEY_READ_WRITE, NULL, &hkey10Dot, &dwDisposition);
        if (S_OK == hr)
        {
            HKEY hkeySubnetOptions = NULL;
            HKEY hkeyIpRanges = NULL;

            (VOID)HrRegSetString(hkey10Dot, L"SubnetName",
                                   SzLoadIds(IDS_DHCP_SUBNET_NAME));    // DHCP Server Scope
            (VOID)HrRegSetString(hkey10Dot, L"SubnetComment",
                                   SzLoadIds(IDS_DHCP_SUBNET_COMMENT)); // Scope used to offer clients address
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetState", 0x0);
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetAddress",
                                  IpPszToHostAddr(pszSubnet));
            (VOID)HrRegSetDword(hkey10Dot, L"SubnetMask", dwSubnetMask);

            hr = HrRegCreateKeyEx(hkey10Dot, c_szIpRanges,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ, NULL,
                                    &hkeyIpRanges, &dwDisposition);
            if (S_OK == hr)
            {
                HKEY hkeyStartIp = NULL;
                hr = HrRegCreateKeyEx(hkeyIpRanges, pszStartIp,
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkeyStartIp, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkeyStartIp, L"RangeFlags", 0x1);
                    (VOID)HrRegSetDword(hkeyStartIp, L"StartAddress",
                                          IpPszToHostAddr(pszStartIp));
                    (VOID)HrRegSetDword(hkeyStartIp, L"EndAddress",
                                          dwEndIp);

                    RegCloseKey(hkeyStartIp);
                }

                RegCloseKey(hkeyIpRanges);
            }

            // Create subnets options key
            //
            hr = HrRegCreateKeyEx(hkey10Dot, c_szSubnetOptions,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_READ_WRITE, NULL,
                                    &hkeySubnetOptions, &dwDisposition);
            if (S_OK == hr)
            {
                HKEY hkey051 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"051",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey051, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey051, L"OptionId", 0x33);

                    DWORD rgdwLease[] = {0x14, 0x2, 0x1, 0x0, 0x0};
                    rgdwLease[celems(rgdwLease) - 1] = dwLeaseDuration;
                    (VOID)HrRegSetBinary(hkey051,
                                          L"OptionValue",
                                          (const BYTE *)rgdwLease,
                                          sizeof(rgdwLease));

                    RegCloseKey(hkey051);
                }

                HKEY hkey006 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"006",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey006, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey006, L"OptionId", 0x6);

                    DWORD rgdwDnsServer[] = {0x14, 0x4, 0x1, 0x0, 0x0};
                    rgdwDnsServer[celems(rgdwDnsServer) - 1] = dwDnsServer;
                    (VOID)::HrRegSetBinary(hkey006,
                                          L"OptionValue",
                                          (const BYTE *)rgdwDnsServer,
                                          sizeof(rgdwDnsServer));

                    RegCloseKey(hkey006);
                }

                HKEY hkey015 = NULL;
                hr = HrRegCreateKeyEx(hkeySubnetOptions, L"015",
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_READ_WRITE, NULL,
                                        &hkey015, &dwDisposition);
                if (S_OK == hr)
                {
                    (VOID)HrRegSetDword(hkey015, L"OptionId", 0xf);

                    UINT uLen = 0x18 + 2 * lstrlenW(pszDomainName);
                    LPBYTE pb = (LPBYTE)MemAlloc(uLen);
                    if (pb)
                    {
                        ZeroMemory(pb, uLen);

                        DWORD *pdw = (DWORD *)pb;
                        pdw[0] = uLen;
                        pdw[1] = 0x5;
                        pdw[2] = 0x1;
                        pdw[3] = 0x0;
                        pdw[4] = 2 * (1 + lstrlenW(pszDomainName));

                        lstrcpyW((PWSTR)&pdw[5], pszDomainName);

                        (VOID)::HrRegSetBinary(hkey015, L"OptionValue",
                                               (const BYTE *)pb, uLen);
                        MemFree(pb);
                    }

                    RegCloseKey(hkey015);
                }

                RegCloseKey(hkeySubnetOptions);
            }

            RegCloseKey(hkey10Dot);
        }

        RegCloseKey(hkeySubnets);
    }

    TraceError("HrWriteDhcpSubnets", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrProcessDhcpServerSolutionsParams
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pcsif              [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Answerfile section in the
//                                    file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Notes:
//
HRESULT
CDHCPServer::HrProcessDhcpServerSolutionsParams (
    IN CSetupInfFile * pcsif,
    IN PCWSTR pszAnswerSection)
{
    HRESULT hr;
    tstring str;
    tstring strStartIp;
    tstring strSubnet;

    hr = pcsif->HrGetString(pszAnswerSection, c_szSubnets, &strSubnet);
    if (SUCCEEDED(hr))
    {
        hr = pcsif->HrGetString(pszAnswerSection, c_szStartIp, &strStartIp);
        if (SUCCEEDED(hr))
        {
            hr = pcsif->HrGetString(pszAnswerSection, c_szEndIp, &str);
            if (SUCCEEDED(hr))
            {
                DWORD dwEndIp = IpPszToHostAddr(str.c_str());

                hr = pcsif->HrGetString(pszAnswerSection, c_szSubnetMask, &str);
                if (SUCCEEDED(hr))
                {
                    DWORD dwSubnetMask = IpPszToHostAddr(str.c_str());

                    hr = pcsif->HrGetString(pszAnswerSection, c_szDnsServer, &str);
                    if (SUCCEEDED(hr))
                    {
                        DWORD dwLeaseDuration;
                        DWORD dwDnsServer = IpPszToHostAddr(str.c_str());

                        hr = pcsif->HrGetDword(pszAnswerSection, c_szLeaseDuration,
                                               &dwLeaseDuration);
                        if (SUCCEEDED(hr))
                        {
                            hr =  pcsif->HrGetString(pszAnswerSection,
                                                     c_szDomainName, &str);
                            if (SUCCEEDED(hr) && lstrlenW(str.c_str()))
                            {
                                HKEY  hkeyDhcpCfg = NULL;
                                DWORD dwDisposition;

                                // Write the registry data
                                //
                                hr = ::HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                                                        c_szDHCPServerConfigPath,
                                                        REG_OPTION_NON_VOLATILE,
                                                        KEY_READ_WRITE, NULL,
                                                        &hkeyDhcpCfg, &dwDisposition);
                                if (SUCCEEDED(hr))
                                {
                                    hr = HrWriteDhcpOptionInfo(hkeyDhcpCfg);
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = HrWriteDhcpSubnets(hkeyDhcpCfg,
                                                                strSubnet.c_str(),
                                                                strStartIp.c_str(),
                                                                dwEndIp,
                                                                dwSubnetMask,
                                                                dwLeaseDuration,
                                                                dwDnsServer,
                                                                str.c_str());
                                    }

                                    RegCloseKey(hkeyDhcpCfg);
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    // If there are any params missing, so be it
    //
    if ((SPAPI_E_SECTION_NOT_FOUND == hr) ||
        (SPAPI_E_LINE_NOT_FOUND == hr) ||
        (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr))
    {
        hr = S_OK;
    }

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessDhcpServerSolutionsParams");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CDHCPServer::HrProcessAnswerFile
//
//  Purpose:    Handles necessary processing of contents of the answer file.
//
//  Arguments:
//      pszAnswerFile      [in]   Filename of answer file for upgrade.
//      pszAnswerSection   [in]   Answer file section in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, setup API error otherwise.
//
//  Author:     jeffspr   8 May 1997
//
//  Notes:
//
HRESULT
CDHCPServer::HrProcessAnswerFile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    HRESULT         hr          = S_OK;

    CSetupInfFile   csif;

    TraceTag(ttidDHCPServer, "CDHCPServer::HrProcessAnswerFile()");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile -- HrOpen failed()");

        hr = S_OK;
        goto Exit;
    }

    // Restore portions of the registry based on file names from the answer
    // file

    // Get restore file for "Parameters" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfDhcpServerParameters,
                          &m_strParamsRestoreFile);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile - Error restoring "
                   "Parameters key");

        // oh well, just continue
        hr = S_OK;
    }

    // Get restore file for "Configuration" key
    hr = csif.HrGetString(pszAnswerSection, c_szAfDhcpServerConfiguration,
                          &m_strConfigRestoreFile);
    if (FAILED(hr))
    {
        TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile - Error restoring "
                   "Config key");

        // oh well, just continue
        hr = S_OK;
    }

    // Server Solutions has some parameters that need to be plumbed into the registry
    // for their unattended install scenarios
    //
    hr = HrProcessDhcpServerSolutionsParams(&csif, pszAnswerSection);

Exit:
    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::HrProcessAnswerFile");
    return hr;
}

STDMETHODIMP CDHCPServer::ReadAnswerFile(
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::ReadAnswerFile()");

    // don't call Validate_INetCfgNotify_ReadAnswerFile here, as the netoc
    // installer for this will intentionally call it with NULL params. The
    // Validate macro actually causes a return E_INVALIDARG in this case.

    // We're being installed unattended
    //
    m_fUnattend = TRUE;

    TraceTag(ttidDHCPServer, "Answerfile: %S",
        pszAnswerFile ? pszAnswerFile : L"<none>");
    TraceTag(ttidDHCPServer, "Answersection: %S",
        pszAnswerSection ? pszAnswerSection : L"<none>");

    // If we're not already installed, do the work.
    //
    if (pszAnswerFile && pszAnswerSection)
    {
        // Process the actual answer file (read our sections)
        //
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceHr(ttidDHCPServer, FAL, NETSETUP_E_ANS_FILE_ERROR, FALSE,
                "CDHCPServer::ReadAnswerFile - Answer file has errors. Defaulting "
                "all information as if answer file did not exist.");
            hr = S_OK;
        }

    }

    Validate_INetCfgNotify_ReadAnswerFile_Return(hr);

    TraceHr(ttidDHCPServer, FAL, hr, FALSE, "CDHCPServer::ReadAnswerFile");
    return hr;
}

STDMETHODIMP CDHCPServer::Install(DWORD dwSetupFlags)
{
    TraceTag(ttidDHCPServer, "CDHCPServer::Install()");

    Validate_INetCfgNotify_Install(dwSetupFlags);

    m_eInstallAction = eActInstall;

    TraceTag(ttidDHCPServer, "dwSetupFlags = %d", dwSetupFlags);
    TraceTag(ttidDHCPServer, "NSF_WINNT_WKS_UPGRADE = %x", NSF_WINNT_WKS_UPGRADE);
    TraceTag(ttidDHCPServer, "NSF_WINNT_SVR_UPGRADE = %x", NSF_WINNT_SVR_UPGRADE);

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        TraceTag(ttidDHCPServer, "This is indeed an upgrade");
        m_fUpgrade = TRUE;
    }
    else
    {
        TraceTag(ttidDHCPServer, "This is NOT an upgrade");
    }

    return S_OK;
}

STDMETHODIMP CDHCPServer::Removing()
{
    m_eInstallAction = eActRemove;

    return S_OK;
}

STDMETHODIMP CDHCPServer::Validate()
{
    return S_OK;
}

STDMETHODIMP CDHCPServer::CancelChanges()
{
    return S_OK;
}

STDMETHODIMP CDHCPServer::ApplyRegistryChanges()
{
    HRESULT     hr = S_OK;

    TraceTag(ttidDHCPServer, "CDHCPServer::ApplyRegistryChanges()");

    TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Unattend: %d", m_fUnattend);
    TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Upgrade: %d", m_fUpgrade);

    if (m_eInstallAction == eActInstall)
    {
        TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- Installing");
        // We used to only do this on upgrade, now we'll do it all the time.
        // If there's no answerfile info for the restore files, then we
        // won't do anything, and life will still be fine.
        //
        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                "CDHCPServer::ApplyRegistryChanges - HrRestoreRegistry non-fatal error");
            hr = S_OK;
        }

        if (m_fUnattend && !m_fUpgrade)
        {

// I'm if 0'ing this out for now. All of this work was done to appease Ram Cherala
// and whoever asked him to do the same for SP4. Now we're hearing from Ye Gu that
// we don't even want this code on normal NT4/NT5. Who knows what the desire will
// be in the future.
//
#if 0
            hr = HrWriteUnattendedKeys();
            if (FAILED(hr))
            {
                TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                    "CDHCPServer::ApplyRegistryChanges - HrWriteUnattendedKeys non-fatal error");
                hr = S_OK;
            }
#endif
        }

        // Bug #153298: Mark as upgrade so DS info is upgraded
        if (m_fUpgrade)
        {
            DHCP_MARKUPG_ROUTINE    pfnDhcpMarkUpgrade;
            HMODULE                 hmod;

            hr = HrLoadLibAndGetProc(L"dhcpssvc.dll",
                                     "DhcpMarkUpgrade",
                                     &hmod,
                                     (FARPROC *)&pfnDhcpMarkUpgrade);
            if (SUCCEEDED(hr))
            {
                TraceTag(ttidDHCPServer, "Upgrading DS info...");
                pfnDhcpMarkUpgrade();
                FreeLibrary(hmod);
            }
            else
            {
                TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                    "CDHCPServer::ApplyRegistryChanges - Failed to upgrade DS info. Non-fatal");
                hr = S_OK;
            }
        }
    }
    else if (m_eInstallAction == eActRemove)
    {
        TraceTag(ttidDHCPServer, "ApplyRegistryChanges -- removing");

        // RAID #154380: Clean up DS before uninstalling
        {
           DHCP_CLEAR_DS_ROUTINE    pfnDhcpDsClearHostServerEntries;
           HMODULE                  hmod;

           hr = HrLoadLibAndGetProc(L"dhcpsapi.dll",
                                    "DhcpDsClearHostServerEntries",
                                    &hmod,
                                    (FARPROC *)&pfnDhcpDsClearHostServerEntries);
           if (SUCCEEDED(hr))
           {
               TraceTag(ttidDHCPServer, "Removing DS info...");
               pfnDhcpDsClearHostServerEntries();
               FreeLibrary(hmod);
           }
           else
           {
               TraceHr(ttidDHCPServer, FAL, hr, FALSE,
                   "CDHCPServer::ApplyRegistryChanges - Failed to remove DS info. Non-fatal");
               hr = S_OK;
           }
        }
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceHr(ttidDHCPServer, FAL, hr, (hr == S_FALSE), "CDHCPServer::ApplyRegistryChanges");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dll\dllmain.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       D L L M A I N . C P P
//
//  Contents:   Entry points for netcfgx.dll
//
//  Notes:
//
//  Author:     shaunco   23 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncxbase.h"

// Include support for all of the COM objects
#include "..\alanecfg\alaneobj.h"
#include "..\atlkcfg\atlkobj.h"
#include "..\atmcfg\arpsobj.h"
#include "..\atmcfg\auniobj.h"
#include "..\brdgcfg\brdgobj.h"
#include "..\dhcpscfg\dhcpsobj.h"
#include "..\msclicfg\mscliobj.h"
#include "..\nbfcfg\nbfobj.h"
#include "..\engine\inetcfg.h"
#include "..\nwclicfg\nwcliobj.h"
#include "..\nwlnkcfg\nwlnkipx.h"
#include "..\nwlnkcfg\nwlnknb.h"
#include "..\rascfg\rasobj.h"
#include "..\sapcfg\sapobj.h"
#include "..\srvrcfg\srvrobj.h"
#include "..\tcpipcfg\tcpipobj.h"
#include "..\wlbscfg\wlbs.h"

// Network class installer
#include "..\engine\dihook.h"

// Net class prop page providers
#include "netpages.h"

#define INITGUID
#include "ncxclsid.h"


// Global
CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_CALaneCfg,   CALaneCfg)
    OBJECT_ENTRY(CLSID_CATlkObj,    CATlkObj)
    OBJECT_ENTRY(CLSID_CArpsCfg,    CArpsCfg)
    OBJECT_ENTRY(CLSID_CAtmUniCfg,  CAtmUniCfg)
    OBJECT_ENTRY(CLSID_CBridgeObj,  CBridgeNO)
    OBJECT_ENTRY(CLSID_CDHCPServer, CDHCPServer)
    OBJECT_ENTRY(CLSID_CL2tp,       CL2tp)
    OBJECT_ENTRY(CLSID_CMSClient,   CMSClient)
    OBJECT_ENTRY(CLSID_CNWClient,   CNWClient)
    OBJECT_ENTRY(CLSID_CNbfObj,     CNbfObj)
    OBJECT_ENTRY(CLSID_CNdisWan,    CNdisWan)
    OBJECT_ENTRY(CLSID_CNetCfg,     CImplINetCfg)
    OBJECT_ENTRY(CLSID_CNwlnkIPX,   CNwlnkIPX)
    OBJECT_ENTRY(CLSID_CNwlnkNB,    CNwlnkNB)
    OBJECT_ENTRY(CLSID_CPppoe,      CPppoe)
    OBJECT_ENTRY(CLSID_CPptp,       CPptp)
    OBJECT_ENTRY(CLSID_CRasCli,     CRasCli)
    OBJECT_ENTRY(CLSID_CRasSrv,     CRasSrv)
    OBJECT_ENTRY(CLSID_CSAPCfg,     CSAPCfg)
    OBJECT_ENTRY(CLSID_CSrvrcfg,    CSrvrcfg)
    OBJECT_ENTRY(CLSID_CSteelhead,  CSteelhead)
    OBJECT_ENTRY(CLSID_CTcpipcfg,   CTcpipcfg)
    OBJECT_ENTRY(CLSID_CWLBS,       CWLBS)
END_OBJECT_MAP()


//+---------------------------------------------------------------------------
// DLL Entry Point
//
EXTERN_C
BOOL
WINAPI
DllMain (
    HINSTANCE   hInstance,
    DWORD       dwReason,
    LPVOID   /* lpReserved */)
{
    if (DLL_PROCESS_ATTACH == dwReason)
    {
#ifndef DBG
        DisableThreadLibraryCalls (hInstance);
#endif
        EnableCPPExceptionHandling(); // Translate any SEH exceptions into CPP exceptions.

        InitializeDebugging();
        _Module.Init (ObjectMap, hInstance);
    }
    else if (DLL_PROCESS_DETACH == dwReason)
    {
        DbgCheckPrematureDllUnload ("netcfgx.dll", _Module.GetLockCount());
        _Module.Term ();
        UnInitializeDebugging();

        DisableCPPExceptionHandling(); // Disable translation of SEH exceptions into CPP exceptions.
    }
#ifdef DBG
    else if (dwReason == DLL_THREAD_DETACH)
    {
        CTracingIndent::FreeThreadInfo();        
    }
#endif

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(VOID)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
   // The check is to works around an ATL problem where AtlModuleGetClassObject will AV
    // if _Module.m_pObjMap == NULL
    if (_Module.m_pObjMap) 
    {
        return _Module.GetClassObject(rclsid, riid, ppv);
    }
    else
    {
        return E_FAIL;
    }
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(VOID)
{
    BOOL fCoUninitialize = TRUE;

    HRESULT hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = NcAtlModuleRegisterServer (&_Module);

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "netcfgx!DllRegisterServer");
    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(VOID)
{
    _Module.UnregisterServer();

    return S_OK;
}

#if DBG

const char * SzDifToString(DI_FUNCTION dif)
{
    switch(dif) 
    {
    case DIF_SELECTDEVICE: return "DIF_SELECTDEVICE";
    case DIF_INSTALLDEVICE: return "DIF_INSTALLDEVICE";
    case DIF_ASSIGNRESOURCES: return "DIF_ASSIGNRESOURCES";
    case DIF_PROPERTIES: return "DIF_PROPERTIES";
    case DIF_REMOVE: return "DIF_REMOVE";
    case DIF_FIRSTTIMESETUP: return "DIF_FIRSTTIMESETUP";
    case DIF_FOUNDDEVICE: return "DIF_FOUNDDEVICE";
    case DIF_SELECTCLASSDRIVERS: return "DIF_SELECTCLASSDRIVERS";
    case DIF_VALIDATECLASSDRIVERS: return "DIF_VALIDATECLASSDRIVERS";
    case DIF_INSTALLCLASSDRIVERS: return "DIF_INSTALLCLASSDRIVERS";
    case DIF_CALCDISKSPACE: return "DIF_CALCDISKSPACE";
    case DIF_DESTROYPRIVATEDATA: return "DIF_DESTROYPRIVATEDATA";
    case DIF_VALIDATEDRIVER: return "DIF_VALIDATEDRIVER";
    case DIF_MOVEDEVICE: return "DIF_MOVEDEVICE";
    case DIF_DETECT: return "DIF_DETECT";
    case DIF_INSTALLWIZARD: return "DIF_INSTALLWIZARD";
    case DIF_DESTROYWIZARDDATA: return "DIF_DESTROYWIZARDDATA";
    case DIF_PROPERTYCHANGE: return "DIF_PROPERTYCHANGE";
    case DIF_ENABLECLASS: return "DIF_ENABLECLASS";
    case DIF_DETECTVERIFY: return "DIF_DETECTVERIFY";
    case DIF_INSTALLDEVICEFILES: return "DIF_INSTALLDEVICEFILES";
    case DIF_UNREMOVE: return "DIF_UNREMOVE";
    case DIF_SELECTBESTCOMPATDRV: return "DIF_SELECTBESTCOMPATDRV";
    case DIF_ALLOW_INSTALL: return "DIF_ALLOW_INSTALL";
    case DIF_REGISTERDEVICE: return "DIF_REGISTERDEVICE";
    case DIF_NEWDEVICEWIZARD_PRESELECT: return "DIF_NEWDEVICEWIZARD_PRESELECT";
    case DIF_NEWDEVICEWIZARD_SELECT: return "DIF_NEWDEVICEWIZARD_SELECT";
    case DIF_NEWDEVICEWIZARD_PREANALYZE: return "DIF_NEWDEVICEWIZARD_PREANALYZE";
    case DIF_NEWDEVICEWIZARD_POSTANALYZE: return "DIF_NEWDEVICEWIZARD_POSTANALYZE";
    case DIF_NEWDEVICEWIZARD_FINISHINSTALL: return "DIF_NEWDEVICEWIZARD_FINISHINSTALL";
    case DIF_UNUSED1: return "DIF_UNUSED1";
    case DIF_INSTALLINTERFACES: return "DIF_INSTALLINTERFACES";
    case DIF_DETECTCANCEL: return "DIF_DETECTCANCEL";
    case DIF_REGISTER_COINSTALLERS: return "DIF_REGISTER_COINSTALLERS";
    case DIF_ADDPROPERTYPAGE_ADVANCED: return "DIF_ADDPROPERTYPAGE_ADVANCED";
    case DIF_ADDPROPERTYPAGE_BASIC: return "DIF_ADDPROPERTYPAGE_BASIC";
    case DIF_RESERVED1: return "DIF_RESERVED1";
    case DIF_TROUBLESHOOTER: return "DIF_TROUBLESHOOTER";
    case DIF_POWERMESSAGEWAKE: return "DIF_POWERMESSAGEWAKE";
    case DIF_ADDREMOTEPROPERTYPAGE_ADVANCED: return "DIF_ADDREMOTEPROPERTYPAGE_ADVANCED";
    default: return "Unknown DI_FUNCTION - update SzDifToString()";
    }
}

#endif // DBG

//+--------------------------------------------------------------------------
//
//  Function:   NetClassInstaller
//
//  Purpose:    This function is called by SetupApi for a variety of
//              functions defined by dif.
//              See SetupDiCallClassInstaller in the SetupApi documentation
//              for more information.
//
//  Arguments:
//      dif   [in] See Device Installer documentation
//      hdi   [in]
//      pdeid [in] if dif == DIF_INSTALLDEVICE, this parameter is not
//                      optional.
//
//
//  Returns:    Win32/Device Installer error code
//
//  Author:     BillBe   24 Nov 1996
//
//  Notes:
//
EXTERN_C
DWORD
__stdcall
NetClassInstaller (
    DI_FUNCTION         dif,
    HDEVINFO            hdi,
    PSP_DEVINFO_DATA    pdeid)
{
#if DBG
    TraceTag(ttidNetcfgBase, "NetClassInstaller: dif=0x%08X (%s)", dif, SzDifToString(dif));
#endif

    DWORD dwRet = ERROR_DI_DO_DEFAULT;
    NC_TRY
    {
        HRESULT hr = _HrNetClassInstaller (dif, hdi, pdeid);

        // Convert errors that can be converted otherwise
        // leave error as is and Device Installer Api will treat is as
        // a generic failure
        //
        if (FAILED(hr))
        {
            DWORD dwFac = HRESULT_FACILITY(hr);
            if ((FACILITY_SETUPAPI == dwFac) || (FACILITY_WIN32 == dwFac))
            {
                dwRet = DwWin32ErrorFromHr (hr);
            }
            else
            {
                dwRet = ERROR_GEN_FAILURE;
            }
        }
        else
        {
            dwRet = NO_ERROR;
        }

    }
    NC_CATCH_BAD_ALLOC
    {
        dwRet = ERROR_NOT_ENOUGH_MEMORY;
    }
    TraceTag(ttidNetcfgBase, "NetClassInstaller Exiting. Result %X", dwRet);
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ModemClassCoInstaller
//
//  Purpose:    Implements the co-installer for modem devices.
//
//  Arguments:
//      dif         [in]        See Device Installer Api documentation.
//      hdi         [in]
//      pdeid       [in]
//      pContext    [inout]
//
//  Returns:    See Device Installer Api documentation.
//
//  Author:     shaunco   6 May 1997
//
//  Notes:
//
EXTERN_C
DWORD
__stdcall
ModemClassCoInstaller (
    DI_FUNCTION                 dif,
    HDEVINFO                    hdi,
    PSP_DEVINFO_DATA            pdeid,
    PCOINSTALLER_CONTEXT_DATA   pContext)
{
    AssertSz (pContext, "ModemClassCoInstaller: Hey! How about some context "
                        "data?");

    TraceTag (ttidRasCfg, "ModemClassCoInstaller: dif=0x%08X %s",
              dif,
              (pContext->PostProcessing) ? "(post processing)" : "");


    // If we're post processing for anything and the install result from
    // the class installer indicates an error, propagate this error and
    // take no action.
    //
    if (pContext->PostProcessing && (NO_ERROR != pContext->InstallResult))
    {
        TraceTag (ttidRasCfg, "ModemClassCoInstaller: taking no action. "
                "propagating pContext->InstallResult = 0x%08X",
                pContext->InstallResult);
        return pContext->InstallResult;
    }

    DWORD dwRet = NO_ERROR;
    if (!FInSystemSetup())
    {
        NC_TRY
        {
            HRESULT hr = HrModemClassCoInstaller (dif, hdi, pdeid, pContext);

            // Convert errors that can be converted otherwise
            // return generic faliure.
            //
            if (FAILED(hr))
            {
                DWORD dwFac = HRESULT_FACILITY(hr);
                if ((FACILITY_SETUPAPI == dwFac) || (FACILITY_WIN32 == dwFac))
                {
                    dwRet = DwWin32ErrorFromHr (hr);
                }
                else
                {
                    dwRet = ERROR_GEN_FAILURE;
                }
            }
        }
        NC_CATCH_BAD_ALLOC
        {
            dwRet = ERROR_NOT_ENOUGH_MEMORY;
        }
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   NetPropPageProvider
//
//  Purpose:
//
//  Arguments:
//      ppspr   [in]   See Win32 ExtensionPropSheetPageProc fcn for info
//      lpfn    [in]
//      lParama [in]
//
//  Returns:    See Win32ExtensionPropSheetPageProc
//
//  Author:     billbe 24 June 1997
//
//  Notes:
//
EXTERN_C
BOOL
__stdcall
NetPropPageProvider(
    PSP_PROPSHEETPAGE_REQUEST   ppspr,
    LPFNADDPROPSHEETPAGE        lpfnAddPage,
    LPARAM                      lParam)
{
    Assert(ppspr);
    Assert(lpfnAddPage);

    TraceTag(ttidNetcfgBase, "NetPropPageProvider called");
    // Assume we can't handle the request
    BOOL            bSuccess = FALSE;
    HPROPSHEETPAGE  hpspAdvanced = NULL;
    HPROPSHEETPAGE  hpspIsdn = NULL;

    // Only supply the property page if we there is a specific device
    // in other words, don't do it if properties on the general Net class
    // is being requested.
    // Also, we only respond to the advanced device properties request

    HRESULT hr = S_OK;

    if ((ppspr->DeviceInfoData) &&
            (SPPSR_ENUM_ADV_DEVICE_PROPERTIES == ppspr->PageRequested))
    {
        // Get the advanced page ready for hand off to the requestor
        hr = HrGetAdvancedPage(ppspr->DeviceInfoSet, ppspr->DeviceInfoData,
                &hpspAdvanced);

        if (SUCCEEDED(hr))
        {
            if (lpfnAddPage(hpspAdvanced, lParam))
            {
                // We successfully made the hand off to the requestor
                // Now we reset our handle so we don't try to free it
                hpspAdvanced = NULL;
                bSuccess = TRUE;
            }

            // clean up if needed
            if (hpspAdvanced)
            {
                DestroyPropertySheetPage(hpspAdvanced);
            }
        }

        // Get the isdn page ready for hand off to the requestor
        //

        // We don't need to save the hr value from the last so we can reuse
        hr = HrGetIsdnPage(ppspr->DeviceInfoSet, ppspr->DeviceInfoData,
                &hpspIsdn);

        if (SUCCEEDED(hr))
        {
            if (lpfnAddPage(hpspIsdn, lParam))
            {
                // We successfully made the hand off to the requestor
                // Now we reset our handle so we don't try to free it
                hpspIsdn = NULL;
                bSuccess = TRUE;
            }

            // clean up if needed
            if (hpspIsdn)
            {
                DestroyPropertySheetPage(hpspIsdn);
            }
        }

    }

    return bSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dll\exports.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       E X P O R T S . C P P
//
//  Contents:   Exported functions from NETCFG.DLL
//
//  Notes:
//
//  Author:     danielwe   5 Dec 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"

#define REGSTR_PATH_SVCHOST     L"Software\\Microsoft\\Windows NT\\CurrentVersion\\Svchost"

HRESULT
HrPrepareForSvchostEnum (
    IN     PCWSTR                   pszService,
    IN OUT CServiceManager*         pscm,
    IN OUT CService*                psvc,
    OUT    LPQUERY_SERVICE_CONFIG*  ppOriginalConfig,
    OUT    HKEY*                    phkeySvchost,
    OUT    PWSTR*                   ppszValueNameBuffer,
    OUT    DWORD*                   pcchValueNameBuffer,
    OUT    PWSTR*                   ppmszValueBuffer,
    OUT    DWORD*                   pcbValueBuffer)
{
    // Initialize the output parameters.
    //
    *ppOriginalConfig    = NULL;
    *phkeySvchost        = NULL;
    *ppszValueNameBuffer = NULL;
    *pcchValueNameBuffer = 0;
    *ppmszValueBuffer    = NULL;
    *pcbValueBuffer      = 0;

    const DWORD dwScmAccess = STANDARD_RIGHTS_REQUIRED |
                              SC_MANAGER_CONNECT       |
                              SC_MANAGER_LOCK;

    const DWORD dwSvcAccess = STANDARD_RIGHTS_REQUIRED |
                              SERVICE_QUERY_CONFIG     |
                              SERVICE_CHANGE_CONFIG;

    // Open the service and lock the service database so we can change
    // the service's configuration.
    //
    HRESULT hr = pscm->HrOpenService (
                        psvc,
                        pszService,
                        WITH_LOCK,
                        dwScmAccess,
                        dwSvcAccess);
    if (SUCCEEDED(hr))
    {
        // Query the service's current configuration in the event we
        // need to revert what we set.
        //
        LPQUERY_SERVICE_CONFIG pOriginalConfig;
        hr = psvc->HrQueryServiceConfig (&pOriginalConfig);
        if (SUCCEEDED(hr))
        {
            // Open the svchost software key and query information
            // about it like the length of the longest value name
            // and longest value.
            //
            HKEY hkeySvchost;
            hr = HrRegOpenKeyEx (
                    HKEY_LOCAL_MACHINE, REGSTR_PATH_SVCHOST,
                    KEY_READ | KEY_SET_VALUE,
                    &hkeySvchost);

            if (SUCCEEDED(hr))
            {
                DWORD cchMaxValueNameLen;
                DWORD cbMaxValueLen;

                LONG lr = RegQueryInfoKeyW (hkeySvchost,
                            NULL,   // lpClass
                            NULL,   // lpcbClass
                            NULL,   // lpReserved
                            NULL,   // lpcSubKeys
                            NULL,   // lpcbMaxSubKeyLen
                            NULL,   // lpcbMaxClassLen
                            NULL,   // lpcValues
                            &cchMaxValueNameLen,
                            &cbMaxValueLen,
                            NULL,   // lpcbSecurityDescriptor
                            NULL    // lpftLastWriteTime
                            );
                hr = HRESULT_FROM_WIN32 (lr);
                if (SUCCEEDED(hr))
                {
                    // Make sure the name buffer length (in bytes) is a
                    // multiple of sizeof(WCHAR).  This is because we expect
                    // to use RegEnumValue which accepts and returns buffer
                    // size in characters.  We tell it the the buffer
                    // capacity (in characters) is count of bytes divided
                    // by sizeof(WCHAR).  So, to avoid any round off
                    // error (which would not occur in our favor) we make
                    // sure that the buffer size is a multiple of
                    // sizeof(WCHAR).
                    //
                    INT cbFraction = cbMaxValueLen % sizeof(WCHAR);
                    if (cbFraction)
                    {
                        cbMaxValueLen += sizeof(WCHAR) - cbFraction;
                    }

                    // Need room for the null terminator as RegQueryInfoKey
                    // doesn't return it.
                    //
                    cchMaxValueNameLen++;

                    // Allocate buffers for the longest value name and value
                    // data for our caller to use.
                    //
                    PWSTR pszValueNameBuffer = (PWSTR)
                                MemAlloc (cchMaxValueNameLen * sizeof(WCHAR));

                    PWSTR pmszValueBuffer = (PWSTR) MemAlloc (cbMaxValueLen);

                    if ((pszValueNameBuffer != NULL) && 
						(pmszValueBuffer != NULL))
                    {
                        *ppOriginalConfig    = pOriginalConfig;
                        *phkeySvchost        = hkeySvchost;

                        *ppszValueNameBuffer = pszValueNameBuffer;
                        *pcchValueNameBuffer = cchMaxValueNameLen;

                        *ppmszValueBuffer    = pmszValueBuffer;
                        *pcbValueBuffer      = cbMaxValueLen;

                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }

                if (FAILED(hr))
                {
                    RegCloseKey (hkeySvchost);
                }
            }

            if (FAILED(hr))
            {
                MemFree (pOriginalConfig);
            }
        }
    }
    TraceError ("HrPrepareForSvchostEnum", hr);
    return hr;
}

STDAPI
SvchostChangeSvchostGroup (
    PCWSTR pszService,
    PCWSTR pszNewGroup
    )
{
    Assert (pszService);
    Assert (pszNewGroup);

    static const WCHAR c_pszBasePath [] =
        L"%SystemRoot%\\System32\\svchost.exe -k ";

    // Validate the new group name by making sure it doesn't exceed
    // MAX_PATH when combined with the base path.
    //
    if (!pszService  || !pszNewGroup  ||
        !*pszService || !*pszNewGroup ||
        (lstrlenW (c_pszBasePath) + lstrlenW (pszNewGroup) > MAX_PATH))
    {
        return E_INVALIDARG;
    }

    // Form the new image path based on the base path and the new group
    // name.
    //
    WCHAR pszImagePath [MAX_PATH + 1];
    lstrcpyW (pszImagePath, c_pszBasePath);
    lstrcatW (pszImagePath, pszNewGroup);

    // Need to change the ImagePath of the service as well as the
    // Svchost Group values.  The implementation tries to ensure that
    // both of these changes are made or neither of them are made.
    //

    // Prepare for the enumeration by setting up a few pieces of information
    // first.  HrPrepareForSvchostEnum sets up all of these variables.
    //
    // SCM is opened and locked, pszService is opened for config change.
    //
    CServiceManager         scm;
    CService                svc;

    // pszService's current configration is obtained in the event we
    // need to rollback, we'll use this info to reset the ImagePath.
    //
    LPQUERY_SERVICE_CONFIG  pOriginalConfig;

    // hkeySvcHost is opened at REGSTR_PATH_SVCHOST and is used to
    // enumerate the values under it.
    //
    HKEY                    hkeySvcHost;

    // These buffers are allocated so that RegEnumValue will have a place
    // to store what was enumerated.
    //
    PWSTR  pszValueNameBuffer;
    DWORD   cchValueNameBuffer;
    PWSTR  pmszValueBuffer;
    DWORD   cbValueBuffer;

    HRESULT hr = HrPrepareForSvchostEnum (
                    pszService,
                    &scm,
                    &svc,
                    &pOriginalConfig,
                    &hkeySvcHost,
                    &pszValueNameBuffer,
                    &cchValueNameBuffer,
                    &pmszValueBuffer,
                    &cbValueBuffer);
    if (SUCCEEDED(hr))
    {
        // Set the new image path of the service.
        //
        hr = svc.HrSetImagePath (pszImagePath);
        if (SUCCEEDED(hr))
        {
            // fAddNewValue will be set to FALSE if we've found an existing
            // group name value.
            //
            BOOL fAddNewValue = TRUE;
            BOOL fChanged;

            // Now perform the enumeration.  For each value enumerated,
            // make sure the service name is included in the multi-sz
            // for the valuename that matches the new group name.  For all
            // other values, make sure the service name is not included
            // in the multi-sz.
            //
            DWORD dwIndex = 0;
            do
            {
                DWORD dwType;
                DWORD cchValueName = cchValueNameBuffer;
                DWORD cbValue      = cbValueBuffer;

                hr = HrRegEnumValue (hkeySvcHost, dwIndex,
                        pszValueNameBuffer, &cchValueName,
                        &dwType,
                        (LPBYTE)pmszValueBuffer, &cbValue);

                if (SUCCEEDED(hr) && (REG_MULTI_SZ == dwType))
                {
                    // If we find a value that matches the group name,
                    // make sure the service is a part of the mutli-sz
                    // value.
                    //
                    if (0 == lstrcmpiW (pszNewGroup, pszValueNameBuffer))
                    {
                        // Since we found an existing group name, we don't
                        // need to add a new one.
                        //
                        fAddNewValue = FALSE;

                        PWSTR pmszNewValue;

                        hr = HrAddSzToMultiSz (pszService,
                                pmszValueBuffer,
                                STRING_FLAG_DONT_MODIFY_IF_PRESENT |
                                STRING_FLAG_ENSURE_AT_END,
                                0,
                                &pmszNewValue,
                                &fChanged);

                        if (SUCCEEDED(hr) && fChanged)
                        {
                            hr = HrRegSetMultiSz (hkeySvcHost,
                                    pszNewGroup,
                                    pmszNewValue);

                            MemFree (pmszNewValue);
                        }
                    }

                    // Otherwise, since the value does not match the group
                    // name, make sure the service is NOT part of the
                    // mutli-sz value.
                    //
                    else
                    {
                        RemoveSzFromMultiSz (pszService,
                            pmszValueBuffer, STRING_FLAG_REMOVE_ALL,
                            &fChanged);

                        if (fChanged)
                        {
                            hr = HrRegSetMultiSz (hkeySvcHost,
                                    pszValueNameBuffer,
                                    pmszValueBuffer);
                        }
                    }
                }
                else if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                    break;
                }

                dwIndex++;
            }
            while (S_OK == hr);

            // If we need to add a new group name, do so.
            //
            if (SUCCEEDED(hr) && fAddNewValue)
            {
                // Add pszService to a empty multi-sz.  This has the effect
                // of creating a multi-sz from a single string.
                //
                PWSTR pmszNewValue;

                hr = HrAddSzToMultiSz (pszService,
                        NULL,
                        STRING_FLAG_ENSURE_AT_END, 0,
                        &pmszNewValue, &fChanged);
                if (S_OK == hr)
                {
                    // We know that it should have been added, so assert
                    // that the multi-sz "changed".
                    //
                    Assert (fChanged);

                    // Add the new value by setting the multi-sz in the
                    // registry.
                    //
                    hr = HrRegSetMultiSz (hkeySvcHost,
                            pszNewGroup,
                            pmszNewValue);

                    MemFree (pmszNewValue);
                }
            }
        }

        RegCloseKey (hkeySvcHost);

        MemFree (pmszValueBuffer);
        MemFree (pszValueNameBuffer);
        MemFree (pOriginalConfig);
    }
    TraceError ("SvchostChangeSvchostGroup", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\dll\version.h ===
#pragma once

#include <ntverp.h>
#include <winver.h>

#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT2_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Network Configuration Objects"
#define VER_INTERNALNAME_STR            "netcfgx.dll"

#include <common.ver>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\adapter.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       A D A P T E R. C P P
//
//  Contents:   Class installer functions for eumerated devices.
//
//  Notes:
//
//  Author:     billbe   11 Nov 1996
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "netcomm.h"


VOID
CiSetFriendlyNameIfNeeded(IN const COMPONENT_INSTALL_INFO &cii);

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetBusInfoFromInf
//
//  Purpose:    Finds an adapter's bus information as listed in its inf
//                  file.
//
//  Arguments:
//      hinfFile        [in] A handle to the component's inf file
//      szSectionName   [in] The inf section to search in
//      peBusType       [out] The bus type of the adapter
//      pulAdapterId    [out] The AdapterId of the adapter (Eisa and Mca)
//      pulAdapterMask  [out] The AdapterMask of the adapter (Eisa)
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
HRESULT
HrCiGetBusInfoFromInf (HINF hinfFile, COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT hr = S_OK;
    if (InterfaceTypeUndefined == pcii->BusType)
    {
        // Find the inf line that contains BusType and retrieve it
        DWORD dwBusType;
        hr = HrSetupGetFirstDword(hinfFile, pcii->pszSectionName,
                L"BusType", &dwBusType);

        if (S_OK == hr)
        {
            pcii->BusType = EInterfaceTypeFromDword(dwBusType);
        }
        else
        {
            TraceTag (ttidError, "Inf missing BusType field.");
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetBusInfoFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallEnumeratedComponent
//
//  Purpose:    This function completes the install of an enumerated
//                      device.
//
//  Arguments:
//      hinf          [in] SetupApi handle to an inf file
//      hkeyInstance  [in] The registry instance key of the adapter
//                          during inf processing.
//      pcai           [in] A structure containing the component information
//                            See compinst.h for definition
//      hwndParent    [in] The handle to the parent, for displaying UI
//      hdi           [in] See Device Installer Api for more info
//      pdeid         [in] See Device Installer Api for more info
//
//  Returns:    HRESULT. S_OK if successful and no restart required,
//                          NETCFG_S_REBOOT if a reboot is required,
//                          or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
HRESULT
HrCiInstallEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN const COMPONENT_INSTALL_INFO& cii)
{
    Assert (IsValidHandle (hinf));
    Assert (hkeyInstance);
    Assert (IsValidHandle (cii.hdi));
    Assert (cii.pdeid);

    HRESULT hr;

    // Because adapters can share descriptions, we may need to append
    // instance info so the user and other apps can differentiate.
    //
    // If the following fcn fails, we can still go on and
    // install the adapter.
    CiSetFriendlyNameIfNeeded (cii);

    // Is this a PCI multiport adapter where each port has the same
    // PnP Id? This is indicated by the inf value Port1DeviceNumber or
    // Port1FunctionNumber in the main section.
    //
    if (PCIBus == cii.BusType)
    {
        INFCONTEXT ctx;
        DWORD dwPortNumber;
        BOOL fUseDeviceNumber;
        DWORD dwFirstPort;

        hr = HrSetupGetFirstDword (hinf, cii.pszSectionName,
                L"Port1DeviceNumber", &dwFirstPort);

        if (S_OK == hr)
        {
            // The port number is based on the device number.
            fUseDeviceNumber = TRUE;
        }
        else
        {
            hr = HrSetupGetFirstDword (hinf, cii.pszSectionName,
                    L"Port1FunctionNumber", &dwFirstPort);

            if (S_OK == hr)
            {
                // The port number is based on the function number.
                fUseDeviceNumber = FALSE;
            }
        }

        if (S_OK == hr)
        {
            // We have a mapping so now we need to get the address of the
            // device (device and function number).
            //

            DWORD dwAddress;
            hr = HrSetupDiGetDeviceRegistryProperty(cii.hdi, cii.pdeid,
                    SPDRP_ADDRESS, NULL, (BYTE*)&dwAddress, sizeof(dwAddress),
                    NULL);

            if (S_OK == hr)
            {
                // Use our mapping to get the correct port number.
                //
                DWORD dwPortLocation;

                dwPortLocation = fUseDeviceNumber ?
                        HIWORD(dwAddress) : LOWORD(dwAddress);

                // Make sure the port location (either device or
                // function number) is greater than or equal to the first
                // port number, otherwise we will get a bogus port number.
                //
                if (dwPortLocation >= dwFirstPort)
                {
                    dwPortNumber = dwPortLocation - dwFirstPort + 1;

                    // Now store the port number in the device key for internal
                    // consumption.
                    HKEY hkeyDev;
                    hr = HrSetupDiCreateDevRegKey (cii.hdi, cii.pdeid,
                            DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL, &hkeyDev);

                    if (S_OK == hr)
                    {
                        (VOID) HrRegSetDword (hkeyDev, L"Port", dwPortNumber);

                        RegCloseKey (hkeyDev);
                    }

                    // Store the port in the driver key for public
                    // consumption.
                    //
                    (VOID) HrRegSetDword (hkeyInstance, L"Port",
                            dwPortNumber);
                }
            }
        }
        else
        {
            // No mapping available, so we won't display port number.
            hr = S_OK;
        }
    }

    // Update any advanced parameters that do not have a current value
    // with a default.
    UpdateAdvancedParametersIfNeeded (cii.hdi, cii.pdeid);

    // On fresh installs, INetCfg will be starting this adapter,
    // so we have to make sure we don't.
    //
    if (!cii.fPreviouslyInstalled)
    {
        (VOID) HrSetupDiSetDeipFlags (cii.hdi, cii.pdeid, DI_DONOTCALLCONFIGMG,
                SDDFT_FLAGS, SDFBO_OR);
    }

    // Now finish the install of the adapter.
    //

    TraceTag(ttidClassInst, "Calling SetupDiInstallDevice");
#ifdef ENABLETRACE
    CBenchmark bmrk;
    bmrk.Start("SetupDiInstallDevice");
#endif //ENABLETRACE

    hr = HrSetupDiInstallDevice (cii.hdi, cii.pdeid);

#ifdef ENABLETRACE
    bmrk.Stop();
    TraceTag(ttidBenchmark, "%s : %s seconds",
    bmrk.SznDescription(), bmrk.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

    if (!cii.fPreviouslyInstalled)
    {
        (VOID) HrSetupDiSetDeipFlags (cii.hdi, cii.pdeid, DI_DONOTCALLCONFIGMG,
                SDDFT_FLAGS, SDFBO_XOR);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
        "HrCiInstallEnumeratedComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegOpenKeyFromEnumDevs
//
//  Purpose:    Enumerates through each device in an HDEVINFO and returns an
//              hkey to its driver key.
//
//  Arguments:
//      hdi        [in]     See Device Installer Api
//      dwIndex    [inout] The index of the device to retrieve
//      samDesired [in]     The access level of the hkey
//      phkey      [out]    The device's driver key
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   13 Jun 1997
//
//  Notes:
//
HRESULT
HrCiRegOpenKeyFromEnumDevs(HDEVINFO hdi, DWORD* pIndex, REGSAM samDesired,
                           HKEY* phkey)
{
    Assert(IsValidHandle(hdi));
    Assert (phkey);

    // Initialize output parameter.
    *phkey = NULL;

    SP_DEVINFO_DATA deid;
    HRESULT         hr;

    // enumerate through the devices
    while ((S_OK == (hr = HrSetupDiEnumDeviceInfo(hdi, *pIndex, &deid))))
    {
        // open the adapter's instance key
        HRESULT hrT;

        hrT = HrSetupDiOpenDevRegKey(hdi, &deid, DICS_FLAG_GLOBAL,
                    0, DIREG_DRV, samDesired, phkey);
        if (S_OK == hrT)
        {
            break;
        }
        else
        {
            // If the key does not exists this is a phantom device,
            // (or if this device is hosed, we want to ignore it too)
            // move on to the next one and delete this one from
            // our list
            (*pIndex)++;
            (VOID)SetupDiDeleteDeviceInfo(hdi, &deid);
        }
    }

    TraceHr (ttidError, FAL, hr,
            HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr,
            "HrCiRegOpenKeyFromEnumDevs");
    return hr;
}

///////////////Legacy NT4 app support///////////////////////////////////

VOID
AddOrRemoveLegacyNt4AdapterKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID* pInstanceGuid,
    IN PCWSTR pszDescription,
    IN LEGACY_NT4_KEY_OP Op)
{
    Assert (IsValidHandle (hdi));
    Assert (pdeid);
    Assert (FImplies ((LEGACY_NT4_KEY_ADD == Op), pInstanceGuid));
    Assert (FImplies ((LEGACY_NT4_KEY_ADD == Op), pszDescription));

    extern const WCHAR c_szRegKeyNt4Adapters[];
    const WCHAR c_szRegValDescription[] = L"Description";
    const WCHAR c_szRegValServiceName[] = L"ServiceName";

    PWSTR pszDriver;
    HRESULT hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (
            hdi, pdeid, SPDRP_DRIVER, NULL, (BYTE**)&pszDriver);

    if (S_OK == hr)
    {
        PWSTR pszNumber = wcsrchr (pszDriver, L'\\');
        if (pszNumber && *(++pszNumber))
        {
            PWSTR pszStopString;
            ULONG Instance = 0;
            HKEY hkeyAdapters;

            Instance = wcstoul (pszNumber, &pszStopString, c_nBase10);

            // The NT4 key was one based so increment the instance number.
            Instance++;

            DWORD Disp;
            hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNt4Adapters,
                    0, KEY_WRITE, NULL, &hkeyAdapters, &Disp);

            if (S_OK == hr)
            {
                WCHAR szInstanceNumber [12];
                _snwprintf (szInstanceNumber, celems(szInstanceNumber) - 1,
                        L"%d", Instance);

                HKEY hkeyInstance;

                if (LEGACY_NT4_KEY_ADD == Op)
                {
                    hr = HrRegCreateKeyEx (hkeyAdapters, szInstanceNumber, 0,
                            KEY_WRITE, NULL, &hkeyInstance, NULL);

                    if (S_OK == hr)
                    {
                        WCHAR szGuid[c_cchGuidWithTerm];
                        StringFromGUID2 (*pInstanceGuid, szGuid,
                                         c_cchGuidWithTerm);
                        hr = HrRegSetValueEx (hkeyInstance,
                                c_szRegValServiceName, REG_SZ,
                                (const BYTE*)szGuid, sizeof (szGuid));
                        TraceHr (ttidError, FAL, hr, FALSE,
                                 "AddAdapterToNt4Key: Setting Service Name "
                                 "in legacy registry");

                        hr = HrRegSetValueEx (hkeyInstance,
                                c_szRegValDescription, REG_SZ,
                                (const BYTE*)pszDescription,
                                CbOfSzAndTerm (pszDescription));
                        TraceHr (ttidError, FAL, hr, FALSE,
                                 "AddAdapterToNt4Key: Setting Description in "
                                 "legacy registry");

                        RegCloseKey (hkeyInstance);
                    }
                }
                else
                {
                    hr = HrRegDeleteKey (hkeyAdapters, szInstanceNumber);

                }

                RegCloseKey (hkeyAdapters);
            }
        }

        delete [] pszDriver;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\adapter.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       A D A P T E R . H
//
//  Contents:   Net class installer functions for eumerated devices.
//
//  Notes:
//
//  Author:     billbe   11 Nov 1996
//
//---------------------------------------------------------------------------

#pragma once

#include "compdefs.h"
#include "ncsetup.h"

struct COMPONENT_INSTALL_INFO;

HRESULT
HrCiGetBusInfoFromInf (
    IN HINF hinfFile,
    OUT COMPONENT_INSTALL_INFO* pcii);

struct ADAPTER_OUT_PARAMS
{
    OUT GUID    InstanceGuid;
    OUT DWORD   dwCharacter;
};

struct ADAPTER_REMOVE_PARAMS
{
    IN BOOL     fBadDevInst;
    IN BOOL     fNotifyINetCfg;
};


//+--------------------------------------------------------------------------
//
//  Function:   EInterfaceTypeFromDword
//
//  Purpose:    Safely converts a dword to the enumerated type INTERFACE_TYPE
//
//  Arguments:
//      dwBusType [in] The bus type of the adapter
//
//  Returns:    INTERFACE_TYPE. See ntioapi.h for more info.
//
//  Author:     billbe   28 Jun 1997
//
//  Notes:
//
inline INTERFACE_TYPE
EInterfaceTypeFromDword(DWORD dwBusType)
{
    INTERFACE_TYPE eBusType;

    if (dwBusType < MaximumInterfaceType)
    {
        // Since dwBusType is less than MaximumInterfaceType, we can safely
        // cast dwBusType to the enumerated value.
        //
        eBusType = static_cast<INTERFACE_TYPE>(dwBusType);
    }
    else
    {
        eBusType = InterfaceTypeUndefined;
    }

    return eBusType;
}

HRESULT
HrCiInstallEnumeratedComponent(HINF hinf, HKEY hkeyInstance,
                               IN const COMPONENT_INSTALL_INFO& cii);

inline void
CiSetReservedField(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                   const VOID* pvInfo)
{
    AssertH(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    deip.ClassInstallReserved = reinterpret_cast<ULONG_PTR>(pvInfo);
    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);
}

inline void
CiClearReservedField(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    AssertH(IsValidHandle(hdi));

    SP_DEVINSTALL_PARAMS deip;
    (void) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
    deip.ClassInstallReserved = NULL;
    (void) HrSetupDiSetDeviceInstallParams(hdi, pdeid, &deip);
}

HRESULT
HrCiRemoveEnumeratedComponent(IN const COMPONENT_INSTALL_INFO cii);

HRESULT
HrCiRegOpenKeyFromEnumDevs(HDEVINFO hdi, DWORD* pIndex, REGSAM samDesired,
                           HKEY* phkey);

inline HRESULT
HrCiFilterOutPhantomDevs(HDEVINFO hdi)
{
    DWORD   dwIndex = 0;
    HRESULT hr;
    HKEY    hkey;

    // This call eliminates phantom devices
    while (SUCCEEDED(hr = HrCiRegOpenKeyFromEnumDevs(hdi, &dwIndex, KEY_READ,
            &hkey)))
    {
        // We don't need the hkey; we just wanted the phantoms removed
        RegCloseKey (hkey);
        // on to the next
        dwIndex++;
    }

    // No more items is not really an error
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    return hr;
}


// Device friendly name functions and types.
//

enum DM_OP
{
    DM_ADD,
    DM_DELETE,
};

HRESULT
HrCiUpdateDescriptionIndexList(NETCLASS Class, PCWSTR pszDescription,
        DM_OP eOp, ULONG* pulIndex);


//////////////Legacy NT4 App support//////////////////////////

enum LEGACY_NT4_KEY_OP
{
    LEGACY_NT4_KEY_ADD,
    LEGACY_NT4_KEY_REMOVE,
};

VOID
AddOrRemoveLegacyNt4AdapterKey (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID* pInstanceGuid,
    IN PCWSTR pszDescription,
    IN LEGACY_NT4_KEY_OP Op);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\bindings.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       B I N D I N G S . C P P
//
//  Contents:   The basic datatypes for binding objects.  Bindpaths are
//              ordered collections of component pointers.  Bindsets
//              are a collection of bindpaths.  This module implements
//              the operations that are valid on binpaths and bindsets.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "bindings.h"
#include "complist.h"
#include "diagctx.h"
#include "nceh.h"

//+---------------------------------------------------------------------------
// CBindPath -
//

bool
CBindPath::operator< (
    const CBindPath& OtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    
    const_iterator iterThis;
    const_iterator iterOther;
    NETCLASS Class;
    NETCLASS OtherClass;

    for (iterThis = begin(), iterOther = OtherPath.begin();
         (iterThis != end()) && (iterOther != OtherPath.end());
         iterThis++, iterOther++)
    {
        Class = (*iterThis)->Class();
        OtherClass = (*iterOther)->Class();

        if (Class > OtherClass)
        {
            return TRUE;
        }
        else if (Class < OtherClass)
        {
            return FALSE;
        }
    }

    return size() > OtherPath.size();
}

bool
CBindPath::operator> (
    const CBindPath& OtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iterThis;
    const_iterator iterOther;
    NETCLASS Class;
    NETCLASS OtherClass;

    for (iterThis = begin(), iterOther = OtherPath.begin();
         (iterThis != end()) && (iterOther != OtherPath.end());
         iterThis++, iterOther++)
    {
        Class = (*iterThis)->Class();
        OtherClass = (*iterOther)->Class();

        if (Class < OtherClass)
        {
            return TRUE;
        }
        else if (Class > OtherClass)
        {
            return FALSE;
        }
    }

    return size() < OtherPath.size();
}

BOOL
CBindPath::FAllComponentsLoadedOkayIfLoadedAtAll () const
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (this);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->Ext.FLoadedOkayIfLoadedAtAll())
        {
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
CBindPath::FGetPathToken (
    OUT PWSTR pszToken,
    IN OUT ULONG* pcchToken) const
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iter;
    const CComponent* pComponent;
    ULONG cchIn;
    ULONG cch;
    BOOL fFirstTime;

    Assert (this);
    Assert (pcchToken);

    if (pszToken)
    {
        *pszToken = 0;
    }
    cchIn = *pcchToken;
    cch = 0;

    for (iter = begin(), fFirstTime = TRUE; iter != end(); iter++)
    {
        if (!fFirstTime)
        {
            cch += 2;
            if (pszToken && (cch <= cchIn))
            {
                wcscat (pszToken, L"->");
            }
        }
        else
        {
            fFirstTime = FALSE;
        }

        pComponent = *iter;
        Assert (pComponent);

        cch += wcslen (pComponent->PszGetPnpIdOrInfId());
        if (pszToken && (cch <= cchIn))
        {
            wcscat (pszToken, pComponent->PszGetPnpIdOrInfId());
        }
    }

    *pcchToken = cch;
    return cch <= cchIn;
}

BOOL
CBindPath::FIsSameBindPathAs (
    IN const CBindPath* pOtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    UINT unThisSize;
    UINT unOtherSize;
    UINT cb;

    Assert (this);
    Assert (pOtherPath);

    unThisSize = this->size();
    unOtherSize = pOtherPath->size();

    if ((0 == unThisSize) || (0 == unOtherSize) || (unThisSize != unOtherSize))
    {
        return FALSE;
    }

    // Sizes are non-zero and equal.  Compare the data.
    //
    cb = (UINT)((BYTE*)(end()) - (BYTE*)(begin()));
    Assert (cb == unThisSize * sizeof(CComponent*));

    return (0 == memcmp (
                    (BYTE*)(this->begin()),
                    (BYTE*)(pOtherPath->begin()),
                    cb));
}

BOOL
CBindPath::FIsSubPathOf (
    IN const CBindPath* pOtherPath) const
{
    TraceFileFunc(ttidNetCfgBind);
    UINT unThisSize;
    UINT unOtherSize;
    UINT unSkipComponents;
    UINT cb;

    Assert (this);
    Assert (pOtherPath);

    unThisSize = this->size();
    unOtherSize = pOtherPath->size();

    if ((0 == unThisSize) || (0 == unOtherSize) || (unThisSize >= unOtherSize))
    {
        return FALSE;
    }

    // This size is less than other.  Compare the data starting at the
    // component pointer in the other path that will have the same depth
    // as this path.
    //
    cb = (UINT)((BYTE*)(end()) - (BYTE*)(begin()));

    // The component pointer in the other path that we start comparing at
    // is at an offset equal to the difference in path sizes.
    //
    // e.g. other path: a->b->c->d->e  size=5
    //       this path:       c->d->e  size=3
    // start comparing after skipping 5-3=2 components of the other path
    //
    Assert (unOtherSize > unThisSize);
    unSkipComponents = unOtherSize - unThisSize;

    return (0 == memcmp (
                    (BYTE*)(this->begin()),
                    (BYTE*)(pOtherPath->begin() + unSkipComponents),
                    cb));
}

HRESULT
CBindPath::HrAppendBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pBindPath);

    NC_TRY
    {
        insert (end(), pBindPath->begin(), pBindPath->end());
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrAppendBindPath");
    return hr;
}

HRESULT
CBindPath::HrAppendComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (!FContainsComponent (pComponent));

    NC_TRY
    {
        push_back (const_cast<CComponent*>(pComponent));
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrAppendComponent");
    return hr;
}

HRESULT
CBindPath::HrGetComponentsInBindPath (
    IN OUT CComponentList* pComponents) const
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (this);
    Assert (pComponents);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponents->HrInsertComponent (pComponent,
                INS_IGNORE_IF_DUP | INS_SORTED);

        if (S_OK != hr)
        {
            TraceHr (ttidError, FAL, hr, FALSE,
                "CBindPath::HrGetComponentsInBindPath");
            return hr;
        }
    }
    return S_OK;
}

HRESULT
CBindPath::HrInsertComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (!FContainsComponent (pComponent));

    NC_TRY
    {
        insert (begin(), const_cast<CComponent*>(pComponent));
        DbgVerifyBindpath ();
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindPath::HrInsertComponent");
    return hr;
}

HRESULT
CBindPath::HrReserveRoomForComponents (
    IN UINT cComponents)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    NC_TRY
    {
        reserve (cComponents);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindPath::HrReserveRoomForComponents");
    return hr;
}

#if DBG
VOID
CBindPath::DbgVerifyBindpath ()
{
    TraceFileFunc(ttidNetCfgBind);
    const_iterator iter;
    const_iterator iterOther;
    const CComponent* pComponent;
    const CComponent* pOtherComponent;

    Assert (this);

    // Make sure the bindpath does not contain any duplicate component
    // pointers.
    //
    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        for (iterOther = begin(); iterOther != end(); iterOther++)
        {
            pOtherComponent = *iterOther;
            Assert (pOtherComponent);

            if (iter == iterOther)
            {
                continue;
            }

            Assert (pComponent != pOtherComponent);
        }
    }
}
#endif


//+---------------------------------------------------------------------------
// CBindingSet -
//

VOID
CBindingSet::Printf (
    TRACETAGID ttid,
    PCSTR pszPrefixLine) const
{
    TraceFileFunc(ttidNetCfgBind);
    WCHAR  pszBuf [1024];
    WCHAR* pch;
    ULONG  cch;

    Assert (this);

    if (pszPrefixLine)
    {
        g_pDiagCtx->Printf (ttid, pszPrefixLine);
    }

    const CBindPath* pBindPath;
    INT nIndex = 1;

    for (pBindPath = begin(); pBindPath != end(); pBindPath++, nIndex++)
    {
        pch = pszBuf + wsprintfW (pszBuf, L"%2i: ", nIndex);

        cch = celems(pszBuf) - wcslen(pszBuf) - 1;
        if (pBindPath->FGetPathToken (pch, &cch))
        {
            g_pDiagCtx->Printf (ttid, "%S\n", pszBuf);
        }
    }
}

BOOL
CBindingSet::FContainsBindPath (
    IN const CBindPath* pBindPathToCheckFor) const
{
    TraceFileFunc(ttidNetCfgBind);
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pBindPathToCheckFor);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        if (pBindPath->FIsSameBindPathAs (pBindPathToCheckFor))
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
CBindingSet::FContainsComponent (
    IN const CComponent* pComponent) const
{
    TraceFileFunc(ttidNetCfgBind);
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pComponent);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        if (pBindPath->FContainsComponent (pComponent))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CBindingSet::HrAppendBindingSet (
    IN const CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pSrcPath;

    Assert (this);
    Assert (pBindSet);

    hr = S_OK;

    NC_TRY
    {
        for (pSrcPath = pBindSet->begin();
             pSrcPath != pBindSet->end();
             pSrcPath++)
        {
            if (!FContainsBindPath (pSrcPath))
            {
                insert (end(), *pSrcPath);
            }
        }
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrAppendBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrAddBindPath (
    IN const CBindPath* pBindPath,
    IN DWORD dwFlags)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pBindPath);
    Assert (!pBindPath->FIsEmpty());
    Assert ((dwFlags & INS_ASSERT_IF_DUP) || (dwFlags & INS_IGNORE_IF_DUP));
    Assert ((dwFlags & INS_APPEND) || (dwFlags & INS_INSERT));
    Assert (!(INS_SORTED & dwFlags) && !(INS_NON_SORTED & dwFlags));

    if (FContainsBindPath (pBindPath))
    {
        // If the caller didn't tell us to ignore duplicates, we assert
        // if there is one because it is bad, bad, bad to have duplicate
        // bindpaths in the set.
        //
        // If we have a dup, we want the caller to be aware that it
        // is possible, and pass us the flag telling us to ignore it.
        // Otherwise, we assert to let them know. (And we still ignore
        // it.)
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        return S_OK;
    }

    NC_TRY
    {
        // Either insert the bindpath or append it.
        //
        iterator iter = begin();

        if (dwFlags & INS_APPEND)
        {
            iter = end();
        }

        insert (iter, *pBindPath);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrAddBindPath");
    return hr;
}

HRESULT
CBindingSet::HrAddBindPathsInSet1ButNotInSet2 (
    IN const CBindingSet* pSet1,
    IN const CBindingSet* pSet2)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pSet1);
    Assert (pSet2);
    Assert ((this != pSet1) && (this != pSet2));

    hr = S_OK;

    for (pBindPath  = pSet1->begin();
         pBindPath != pSet1->end();
         pBindPath++)
    {
        if (pSet2->FContainsBindPath (pBindPath))
        {
            continue;
        }

        hr = HrAddBindPath (pBindPath, INS_IGNORE_IF_DUP | INS_APPEND);
        if (S_OK != hr)
        {
            break;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrAddBindPathsInSet1ButNotInSet2");
    return hr;
}

HRESULT
CBindingSet::HrCopyBindingSet (
    IN const CBindingSet* pSourceSet)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    Assert (this);
    Assert (pSourceSet);

    NC_TRY
    {
        *this = *pSourceSet;
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CBindingSet::HrCopyBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrGetAffectedComponentsInBindingSet (
    IN OUT CComponentList* pComponents) const
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;
    const CBindPath* pBindPath;

    Assert (this);
    Assert (pComponents);

    hr = S_OK;

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        hr = pComponents->HrInsertComponent (pBindPath->POwner(),
                INS_IGNORE_IF_DUP | INS_SORTED);

        if (S_OK != hr)
        {
            break;
        }

        // For bindpaths from a protocol to an adpater, we want to
        // add the adapter to the component list because it will need
        // to have its upper bind changed.
        //
        if (pBindPath->CountComponents() == 2)
        {
            const CComponent* pAdapter;

            pAdapter = pBindPath->PLastComponent();
            if (FIsEnumerated (pAdapter->Class()))
            {
                hr = pComponents->HrInsertComponent (pAdapter,
                        INS_IGNORE_IF_DUP | INS_SORTED);

                if (S_OK != hr)
                {
                    break;
                }
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrGetAffectedComponentsInBindingSet");
    return hr;
}

HRESULT
CBindingSet::HrReserveRoomForBindPaths (
    IN UINT cBindPaths)
{
    TraceFileFunc(ttidNetCfgBind);
    HRESULT hr;

    NC_TRY
    {
        reserve (cBindPaths);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CBindingSet::HrReserveRoomForBindPaths");
    return hr;
}

VOID
CBindingSet::RemoveBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pScan;

    for (pScan = begin(); pScan != end(); pScan++)
    {
        if (pScan->FIsSameBindPathAs (pBindPath))
        {
            erase (pScan);
            return;
        }
    }
}

VOID
CBindingSet::RemoveBindPathsWithComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pBindPath;

    Assert (this);
    Assert (pComponent);

    pBindPath = begin();
    while (pBindPath != end())
    {
        if (pBindPath->FContainsComponent(pComponent))
        {
            erase (pBindPath);
        }
        else
        {
            pBindPath++;
        }
    }
}

VOID
CBindingSet::RemoveSubpaths ()
{
    TraceFileFunc(ttidNetCfgBind);
    CBindPath* pCandidate;
    CBindPath* pBindPath;

    Assert (this);

    for (pBindPath = begin(); pBindPath != end(); pBindPath++)
    {
        pCandidate = begin();

        while (pCandidate != end())
        {
            if (pCandidate->FIsSubPathOf (pBindPath))
            {
                // FIsSubPathOf returns FALSE when asked if a bindpath
                // is a subpath of itself.  (Set-theorectially, this is
                // incorrect, but having it return FALSE for this case
                // prevents us from having to make another check.
                //
                Assert (pCandidate != pBindPath);

                erase (pCandidate);

                // If erasing a bindpath that occurs before the current
                // outer loop enumerator, we need to back it up because
                // the erase would move everything up by one, but we still
                // want to finish the inner loop for this current outer
                // bindpath.
                //
                if (pCandidate < pBindPath)
                {
                    pBindPath--;
                }
            }
            else
            {
                pCandidate++;
            }
        }
    }
}

VOID
CBindingSet::SortForPnpBind ()
{
    TraceFileFunc(ttidNetCfgBind);
    // Sort where bindpaths closes to the adapters come first.
    //
    sort<iterator> (begin(), end(), greater<CBindPath>());
}

VOID
CBindingSet::SortForPnpUnbind ()
{
    TraceFileFunc(ttidNetCfgBind);
    // Sort where bindpaths furthest from the adapters come first.
    //
    sort<iterator> (begin(), end(), less<CBindPath>());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\classinst.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C L A S S I N S T . H
//
//  Contents:   Defines the interface between the binding engine and the
//              network class installer.
//
//  Notes:
//
//  Author:     billbe   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "install.h"
#include "ncsetup.h"
#include <ntioapi.h>

struct COMPONENT_INSTALL_INFO
{
    NETCLASS                            Class;
    PCWSTR                              pszInfId;
    PCWSTR                              pszInfFile;
    HWND                                hwndParent;
    GUID                                InstanceGuid;
    BOOL                                fPreviouslyInstalled;
    DWORD                               dwCharacter;
    PCWSTR                              pszSectionName;
    PCWSTR                              pszDescription;
    PCWSTR                              pszPnpId;
    HDEVINFO                            hdi;
    PSP_DEVINFO_DATA                    pdeid;
    INTERFACE_TYPE                      BusType;
    BOOL                                fRemoteBoot;
};

HRESULT
HrCiGetClassAndInfFileOfInfId (
    IN PCWSTR pszInfId,
    OUT NETCLASS* pClass,
    OUT PWSTR pszInfFile);   // Must be _MAX_PATH long

HRESULT
HrCiIsInstalledComponent(
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey);

HRESULT
HrCiInstallComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent,
    OUT DWORD* pdwNewCharacter);

HRESULT
HrCiInstallFilterDevice (
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId,
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN class CFilterDevice** ppFilterDevice);

HRESULT
HrCiInstallFromInfSection(
    IN HINF hinfFile,
    IN PCWSTR pszInfSectionName,
    IN HKEY hkeyRelative,
    IN HWND hwndParent,
    IN DWORD dwInstallFlags);

HRESULT
HrCiRemoveComponent (
    IN const CComponent* pComponent,
    OUT tstring* pstrRemoveSection OPTIONAL);

HRESULT
HrCiRemoveFilterDevice (
    IN HDEVINFO hdi,
    IN SP_DEVINFO_DATA* pdeid);


HRESULT
HrCiPrepareSelectDeviceDialog(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);

HRESULT
HrCiRemoveNonEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN NETCLASS eClass,
    IN const GUID& InstanceGuid);


HRESULT
HrCiGetDriverInfo (
    IN     HDEVINFO hdi,
    IN OUT PSP_DEVINFO_DATA pdeid,
    IN     const GUID& guidClass,
    IN     PCWSTR pszInfId,
    IN     PCWSTR pszInfFile OPTIONAL);

HRESULT
HrCiGetDriverDetail(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    OUT PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd);


HRESULT
HrCiSelectComponent(
    IN NETCLASS Class,
    IN HWND hwndParent,
    IN const CI_FILTER_INFO* pcfi,
    OUT COMPONENT_INSTALL_PARAMS** ppParams);

HRESULT
HrCiInstallComponentInternal(
    IN OUT COMPONENT_INSTALL_INFO* pcii);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\comp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P . C P P
//
//  Contents:   The module implements the operations that are valid on
//              network component datatypes.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "icomp.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncstring.h"
#include "ncmem.h"
#include "util.h"

// NULL entries means we don't use the network subtree for that class.
//
const PCWSTR MAP_NETCLASS_TO_NETWORK_SUBTREE[] =
{
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e972-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{6BDD1FC5-810F-11D0-BEC7-08002BE2092F}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e975-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e973-e325-11ce-bfc1-08002be10318}",
    L"System\\CurrentControlSet\\Control\\Network\\{4d36e974-e325-11ce-bfc1-08002be10318}",
    NULL,
    NULL
};

// map of NETCLASS enum to GUIDs for class
//
const GUID* MAP_NETCLASS_TO_GUID[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_INFRARED,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETCLIENT,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_UNKNOWN,
    &GUID_DEVCLASS_UNKNOWN
};

const WCHAR c_szTempNetcfgStorageForUninstalledEnumeratedComponent[] =
    L"System\\CurrentControlSet\\Control\\Network\\Uninstalled\\";

//static
HRESULT
CComponent::HrCreateInstance (
    IN const BASIC_COMPONENT_DATA* pData,
    IN DWORD dwFlags,
    IN const OBO_TOKEN* pOboToken, OPTIONAL
    OUT CComponent** ppComponent)
{
    ULONG cbInfId;
    ULONG cbPnpId;

    Assert (pData);
    Assert (pData->pszInfId && *pData->pszInfId);
    Assert (FIsValidNetClass(pData->Class));
    Assert (FImplies(FIsEnumerated(pData->Class),
                pData->pszPnpId && *pData->pszPnpId));
    Assert (FImplies(pData->pszPnpId, *pData->pszPnpId));
    Assert (FImplies(pData->dwDeipFlags, FIsEnumerated(pData->Class)));
    Assert ((CCI_DEFAULT == dwFlags) ||
            (CCI_ENSURE_EXTERNAL_DATA_LOADED == dwFlags));
    Assert (GUID_NULL != pData->InstanceGuid);

    cbInfId = CbOfSzAndTerm (pData->pszInfId);
    cbPnpId = CbOfSzAndTermSafe (pData->pszPnpId);

    HRESULT hr = E_OUTOFMEMORY;
    CComponent* pComponent = new(extrabytes, cbInfId + cbPnpId) CComponent;
    if (pComponent)
    {
        hr = S_OK;
        ZeroMemory (pComponent, sizeof(CComponent));

        pComponent->m_InstanceGuid  = pData->InstanceGuid;
        pComponent->m_Class         = pData->Class;
        pComponent->m_dwCharacter   = pData->dwCharacter;
        pComponent->m_dwDeipFlags   = pData->dwDeipFlags;

        pComponent->m_pszInfId = (PCWSTR)(pComponent + 1);
        wcscpy ((PWSTR)pComponent->m_pszInfId, pData->pszInfId);
        _wcslwr ((PWSTR)pComponent->m_pszInfId);

        AddOrRemoveDontExposeLowerCharacteristicIfNeeded (pComponent);

        if (cbPnpId)
        {
            pComponent->m_pszPnpId = (PCWSTR)((BYTE*)pComponent->m_pszInfId
                                                + cbInfId);
            wcscpy ((PWSTR)pComponent->m_pszPnpId, pData->pszPnpId);
        }

        if (dwFlags & CCI_ENSURE_EXTERNAL_DATA_LOADED)
        {
            // Let's ensure we can successfully read all of the external
            // data that the component's INF dumped under the instance
            // key.  Failure here means the INF wasn't proper in some
            // way required for us to consider this a valid component.
            //
            hr = pComponent->Ext.HrEnsureExternalDataLoaded ();
        }

        if ((S_OK == hr) && pOboToken)
        {
            // Add a reference by the obo token if we were given one.
            //
            hr = pComponent->Refs.HrAddReferenceByOboToken (pOboToken);
        }

        if (S_OK != hr)
        {
            delete pComponent;
            pComponent = NULL;
        }
    }

    *ppComponent = pComponent;

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrCreateAndInitializeInstance");
    return hr;
}

CComponent::~CComponent()
{
    // If we have a cached INetCfgComponent interface, we need to tell it
    // that we (as the component it represents) no longer exist.  Then we
    // need to release the interface, of course.
    //
    ReleaseINetCfgComponentInterface ();
    if(m_hinf)
    {
        SetupCloseInfFile (m_hinf);
    }
}

VOID
CComponent::ReleaseINetCfgComponentInterface ()
{
    Assert (this);

    if (m_pIComp)
    {
        Assert (this == m_pIComp->m_pComponent);
        m_pIComp->m_pComponent = NULL;
        ReleaseObj (m_pIComp->GetUnknown());
        m_pIComp = NULL;
    }
}

INetCfgComponent*
CComponent::GetINetCfgComponentInterface () const
{
    Assert (this);
    Assert (m_pIComp);
    return m_pIComp;
}

BOOL
CComponent::FCanDirectlyBindToFilter ( 
    IN const WCHAR* const pszFilterMediaTypes,
    IN const WCHAR* const pszLowerExclude) const
{
    BOOL fCanBind = TRUE;

    // if pszFilterMediaType is not null, then it must have a substring
    // match with the adapters LowerRange.

    if (pszFilterMediaTypes)
    {
        fCanBind = FSubstringMatch (pszFilterMediaTypes, Ext.PszLowerRange(), 
                      NULL, NULL);
    }

    // if the LowerExclude is not null, it must not have a substring match with 
    // the upper range of the adapter.

    if (fCanBind && pszLowerExclude)
    {
        fCanBind = !FSubstringMatch (pszLowerExclude, Ext.PszUpperRange(), 
                       NULL, NULL);
    }

    return fCanBind;
}

BOOL
CComponent::FCanDirectlyBindTo (
    IN const CComponent* pLower,
    OUT const WCHAR** ppStart,
    OUT ULONG* pcch) const
{
    BOOL fCanBind;

    // If this component is a filter and the lower is an adapter,
    // they can bind (by definition) unless the adapter has an upper range
    // that is excluded by the filter.
    //
    if (FIsFilter() && FIsEnumerated(pLower->Class()))
    {
        // See if the filter's attributes - FilterMediaTypes and LowerExclude
        // allow it to bind to the adapter.
        //
        fCanBind = pLower->FCanDirectlyBindToFilter(Ext.PszFilterMediaTypes(),
                       Ext.PszLowerExclude());

        // If the filter can bind to the adapter, and the caller wants
        // the interface name, it will be the first interface the adapter
        // supports.
        //
        if (fCanBind && ppStart && pcch)
        {
            PCWSTR pStart;
            PCWSTR pEnd;

            pStart = pLower->Ext.PszUpperRange();
            Assert (pStart);

            while (*pStart && (*pStart == L' ' || *pStart == L','))
            {
                pStart++;
            }

            pEnd = pStart;
            while (*pEnd && *pEnd != L' ' && *pEnd != L',')
            {
                pEnd++;
            }

            *ppStart = pStart;
            *pcch = (ULONG)(pEnd - pStart);
        }
    }
    else
    {
        fCanBind = FSubstringMatch (
                    Ext.PszLowerRange(),
                    pLower->Ext.PszUpperRange(), ppStart, pcch);
    }

    return fCanBind;
}

BOOL
CComponent::FIsBindable () const
{
    return (0 != _wcsicmp(L"nolower", Ext.PszLowerRange())) ||
           (0 != _wcsicmp(L"noupper", Ext.PszUpperRange()));
}

BOOL
CComponent::FIsWanAdapter () const
{
    Assert (this);

    return (NC_NET == Class()) &&
            FSubstringMatch (Ext.PszLowerRange(), L"wan", NULL, NULL);
}

HRESULT
CComponent::HrGetINetCfgComponentInterface (
    IN CImplINetCfg* pINetCfg,
    OUT INetCfgComponent** ppIComp)
{
    HRESULT hr = S_OK;

    Assert (this);
    Assert (pINetCfg);
    Assert (ppIComp);

    // Caller's are responsible for ensuring that if an interface is about
    // to be handed out, and the external data has been loaded, that the
    // data has been loaded successfully.  If we handed out an interface
    // and the data was NOT loaded successfully, it just means we are doomed
    // to fail later when the client of the interface calls a method that
    // requires that data.
    //
    Assert (Ext.FLoadedOkayIfLoadedAtAll());

    // If we don't yet have the cached INetCfgComponent for ourself,
    // create it and hang onto a reference.
    //
    if (!m_pIComp)
    {
        hr = CImplINetCfgComponent::HrCreateInstance (
                pINetCfg, this, &m_pIComp);
    }

    // AddRef and return a copy for the caller.
    //
    if (S_OK == hr)
    {
        AddRefObj (m_pIComp->GetUnknown());
        *ppIComp = m_pIComp;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrGetINetCfgComponentInterface");
    return hr;
}

HRESULT
CComponent::HrOpenDeviceInfo (
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut) const
{
    HRESULT hr;

    Assert (this);
    Assert (phdiOut);
    Assert (pdeidOut);

    hr = ::HrOpenDeviceInfo (
            Class(),
            m_pszPnpId,
            phdiOut,
            pdeidOut);

    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
        "CComponent::HrOpenDeviceInfo (%S)", m_pszPnpId);
    return hr;
}

HRESULT
CComponent::HrOpenInstanceKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL) const
{
    HRESULT hr;

    Assert (this);
    Assert (phkey);

    hr = HrOpenComponentInstanceKey (
            Class(),
            m_InstanceGuid,
            m_pszPnpId,
            samDesired,
            phkey,
            phdiOut,
            pdeidOut);

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "CComponent::HrOpenInstanceKey (%S)", PszGetPnpIdOrInfId());
    return hr;
}

HRESULT
CComponent::HrOpenServiceKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey) const
{
    HRESULT hr;
    WCHAR szServiceSubkey [_MAX_PATH];

    Assert (this);
    Assert (phkey);
    Assert (FHasService());

    *phkey = NULL;

    wcscpy (szServiceSubkey, REGSTR_PATH_SERVICES);
    wcscat (szServiceSubkey, L"\\");
    wcscat (szServiceSubkey, Ext.PszService());

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            szServiceSubkey,
            samDesired,
            phkey);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrOpenServiceKey (%S)", Ext.PszService());
    return hr;
}

HRESULT
CComponent::HrStartOrStopEnumeratedComponent (
    IN DWORD dwFlag /* DICS_START or DICS_STOP */) const
{
    HRESULT hr;
    HDEVINFO  hdi;
    SP_DEVINFO_DATA deid;

    Assert (this);
    Assert (FIsEnumerated(Class()));
    Assert ((DICS_START == dwFlag) || (DICS_STOP == dwFlag));

    hr = HrOpenDeviceInfo (&hdi, &deid);
    if (S_OK == hr)
    {
        if (m_dwDeipFlags)
        {
            TraceTag (ttidBeDiag,
                "Using SP_DEVINSTALL_PARAMS.Flags = 0x%08x for %S",
                m_dwDeipFlags,
                m_pszPnpId);

            (VOID) HrSetupDiSetDeipFlags (
                        hdi, &deid,
                        m_dwDeipFlags, SDDFT_FLAGS, SDFBO_OR);
        }

        // $HACK  SetupDi does not honor the DI_DONOTCALLCONFIGMG flag
        // so we can't call it if it is set. If we don't start the device
        // we will return NETCFG_S_REBOOT.
        //
        hr = NETCFG_S_REBOOT;
        if (!(DI_DONOTCALLCONFIGMG & m_dwDeipFlags))
        {
            hr = HrSetupDiSendPropertyChangeNotification (
                    hdi, &deid,
                    dwFlag,
                    DICS_FLAG_CONFIGSPECIFIC,
                    0);
        }

        SetupDiDestroyDeviceInfoList (hdi);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrStartOrStopEnumeratedComponent (%S)", m_pszPnpId);
    return hr;
}

//-----------------------------------------------------------------------
// A convenience method to get the handle to the components inf file.
// If the file has been opened previously, the cached handle is returned.
// Otherwise, the file is opened and the handle is returned.

HRESULT
CComponent::HrOpenInfFile(
    OUT HINF* phinf) const
{
    HRESULT hr = S_OK;
    HKEY  hkeyInstance = NULL;
    WCHAR szInfPath[_MAX_PATH];
    DWORD cbPath = sizeof (szInfPath);

    Assert(phinf);
    *phinf = NULL;

    if (NULL == m_hinf)
    {
        hr = HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

        if (S_OK == hr)
        {
            hr = HrRegQuerySzBuffer (hkeyInstance, L"InfPath", szInfPath, &cbPath);

            if (S_OK == hr)
            {
                // open the component's inf file
                hr = HrSetupOpenInfFile (szInfPath, NULL, INF_STYLE_WIN4,
                         NULL, &m_hinf);
            }
            RegSafeCloseKey (hkeyInstance);
        }
    }
    *phinf = m_hinf;

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponent::HrOpenInfFile (%S)", PszGetPnpIdOrInfId());

    return hr;
}

NETCLASS
NetClassEnumFromGuid (
    const GUID& guidClass)
{
    NETCLASS Class;

    if (GUID_DEVCLASS_NET == guidClass)
    {
        Class = NC_NET;
    }
    else if (GUID_DEVCLASS_INFRARED == guidClass)
    {
        Class = NC_INFRARED;
    }
    else if (GUID_DEVCLASS_NETTRANS == guidClass)
    {
        Class = NC_NETTRANS;
    }
    else if (GUID_DEVCLASS_NETCLIENT == guidClass)
    {
        Class = NC_NETCLIENT;
    }
    else if (GUID_DEVCLASS_NETSERVICE == guidClass)
    {
        Class = NC_NETSERVICE;
    }
    else
    {
        Class = NC_INVALID;
    }

    return Class;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\comp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P . H
//
//  Contents:   The basic datatype for a network component.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"
#include "comprefs.h"
#include "ecomp.h"
#include "ncstring.h"
#include "netcfgx.h"
#include "notify.h"

// Flags used when creating a CComponent instance.
//
enum CCI_FLAGS
{
    CCI_DEFAULT                     = 0x00000000,
    CCI_ENSURE_EXTERNAL_DATA_LOADED = 0x00000001,
};


class CComponent : public CNetCfgDebug<CComponent>
{
friend class CExternalComponentData;
friend class CImplINetCfgComponent;

public:
    // The instance guid of the component.  Assigned by the class installer
    // when the component is installed.  The instance guid of a component
    // can NEVER change once it is installed.
    //
    GUID        m_InstanceGuid;

private:
    // The class of the component.  It is private so that folks are forced
    // to use the Class() access method which asserts that the value is
    // in an allowable range.  The class for a component can NEVER change
    // once it is installed.
    //
    NETCLASS    m_Class;

    // Member to store the handle to the inf file of this component.
    // This is used to avoid the expense of opening the inf file more than
    // once over the lifetime of the component.
    //
    mutable HINF m_hinf;

public:
    // The characteristics of the component.  A combination of NCF_
    // flags defined in netcfgx.idl.  The characteristics of a component
    // can NEVER change once it is installed.
    //
    DWORD       m_dwCharacter;

    // The INF ID of the component. e.g. ms_tcpip.  The INF ID of a component
    // can NEVER change once it is installed.
    //
    PCWSTR      m_pszInfId;

    // The PnP Instance ID of the component.  This is only
    // valid for components that are considered of class NET.  It can
    // NEVER change once the component is installed.
    //
    PCWSTR      m_pszPnpId;

    // This is the interface to the component's external data.  External data
    // is under the instance key.
    //
    CExternalComponentData  Ext;

    // This is the interface to the component's optional notify object.
    //
    CNotifyObjectInterface  Notify;

    // This is the interface to the component's references.  i.e. who
    // has installed this component.
    //
    CComponentReferences    Refs;

    // This is a cached copy (addref'd) of this component's
    // INetCfgComponent interface.  It is created via
    // HrGetINetCfgComponentInterface on the first call.
    //
    class CImplINetCfgComponent* m_pIComp;

    // Valid for NCF_FILTER components only.  This is the
    // ordinal position that this filter gets within the range of
    // filter classes.  See filtdevs.h for more info.
    //
    DWORD m_dwFilterClassOrdinal;

    // Valid for enumerated components only.  This is the
    // SP_DEVINSTALL_PARAMS.Flags value the class installer was told to
    // use when installing the device.  We need to honor this when starting
    // it.
    //
    DWORD m_dwDeipFlags;

    // When removing non-enumerated components, this string will hold
    // the name of the remove section valid in this component's INF.
    // We need to process this remove section (for delete files) after
    // we release the notify object so that the component has a chance to
    // properly delete the notify object dll.
    //
    tstring m_strRemoveSection;

private:
    // Declare all constructors private so that no one except
    // HrCreateInstance can create instances of this class.
    //
    CComponent() {}

public:
    ~CComponent();

    NETCLASS
    Class() const
    {
        AssertH (FIsValidNetClass(m_Class));
        return m_Class;
    }

    BOOL
    FCanDirectlyBindToFilter( 
        IN const WCHAR* const pszFilterMediaTypes,
        IN const WCHAR* const pszLowerExclude ) const;

    BOOL
    FCanDirectlyBindTo (
        IN const CComponent* pLower,
        OUT const WCHAR** ppStart,
        OUT ULONG* pcch) const;

    BOOL
    FHasService() const
    {
        return (Ext.PszService()) ? TRUE : FALSE;
    }

    BOOL
    FIsBindable () const;

    BOOL
    FIsFilter () const
    {
        return m_dwCharacter & NCF_FILTER;
    }

    BOOL
    FIsWanAdapter () const;

    HINF
    GetCachedInfFile () const
    {
        return m_hinf;
    }

    HRESULT
    HrOpenInfFile (OUT HINF* phinf) const;

    void
    CloseInfFile () const
    {
        Assert(m_hinf);
        SetupCloseInfFile (m_hinf);
        m_hinf = NULL;
    }

    static
    HRESULT
    HrCreateInstance (
        IN const BASIC_COMPONENT_DATA* pData,
        IN DWORD dwFlags /* CCI_FLAGS */,
        IN const OBO_TOKEN* pOboToken, OPTIONAL
        OUT CComponent** ppComponent);

    HRESULT
    HrGetINetCfgComponentInterface (
        IN class CImplINetCfg* pINetCfg,
        OUT INetCfgComponent** ppIComp);

    INetCfgComponent*
    GetINetCfgComponentInterface () const;

    VOID
    ReleaseINetCfgComponentInterface ();

    HRESULT
    HrOpenDeviceInfo (
        OUT HDEVINFO* phdiOut,
        OUT SP_DEVINFO_DATA* pdeidOut) const;

    HRESULT
    HrOpenInstanceKey (
        IN REGSAM samDesired,
        OUT HKEY* phkey,
        OUT HDEVINFO* phdiOut OPTIONAL,
        OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL) const;

    HRESULT
    HrOpenServiceKey (
        IN REGSAM samDesired,
        OUT HKEY* phkey) const;

    HRESULT
    HrStartOrStopEnumeratedComponent (
        IN DWORD dwFlag /* DICS_START or DICS_STOP */) const;

    PCWSTR
    PszGetPnpIdOrInfId () const
    {
        AssertH (FIsValidNetClass(m_Class));
        AssertH (FImplies(FIsEnumerated(m_Class),
                 m_pszPnpId && *m_pszPnpId));

        if (!m_pszPnpId)
        {
            AssertH (m_pszInfId && *m_pszInfId);
            return m_pszInfId;
        }

        AssertH (m_pszPnpId && *m_pszPnpId);
        return m_pszPnpId;
    }

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\complist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P L I S T . H
//
//  Contents:   The basic datatype for a collection of component pointers.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"

class CComponent;

// A component list is a collection of pointers to components.
//
class CComponentList : public CNetCfgDebug<CComponentList>, 
                       public vector<CComponent*>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    Count () const
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FComponentInList (
        IN const CComponent* pComponent) const
    {
        AssertH (this);
        AssertH (pComponent);

        return (find (begin(), end(), pComponent) != end());
    }

    VOID
    FreeComponentsNotInOtherComponentList (
        IN const CComponentList* pOtherList);

    HRESULT
    HrCopyComponentList (
        IN const CComponentList* pSourceList);

    HRESULT
    HrAddComponentsInList1ButNotInList2 (
        IN const CComponentList* pList1,
        IN const CComponentList* pList2);

    HRESULT
    HrInsertComponent (
        IN const CComponent* pComponent,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrReserveRoomForComponents (
        IN UINT cComponents);

    CComponent*
    PFindComponentByBindForm (
        IN NETCLASS Class OPTIONAL,
        IN PCWSTR pszBindForm) const;

    CComponent*
    PFindComponentByBindName (
        IN NETCLASS Class OPTIONAL,
        IN PCWSTR pszBindName) const;

    CComponent*
    PFindComponentByInstanceGuid (
        IN const GUID* pInstanceGuid) const;

    CComponent*
    PFindComponentByInfId (
        IN PCWSTR pszInfId,
        IN OUT ULONG* pulIndex OPTIONAL) const;

    CComponent*
    PFindComponentByPnpId (
        IN PCWSTR pszPnpId) const;

    CComponent*
    PGetComponentAtIndex (
        IN UINT unIndex) const
    {
        AssertH (this);

        return (unIndex < size()) ? (*this)[unIndex] : NULL;
    }

    VOID
    RemoveComponent (
        IN const CComponent* pComponent);

    UINT
    UnGetIndexOfComponent (
        IN const CComponent* pComponent) const
    {
        AssertH (this);

        const_iterator iter = find (begin(), end(), pComponent);
        AssertH (iter != end());
        AssertH ((UINT)(iter - begin()) < size());

        return (UINT)(iter - begin());
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\complist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P L I S T . C P P
//
//  Contents:   Implements the basic datatype for a collection of component
//              pointers.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "bindings.h"
#include "complist.h"
#include "nceh.h"
#include "stable.h"

VOID
CComponentList::FreeComponentsNotInOtherComponentList (
    IN const CComponentList* pOtherList)
{
    Assert (this);
    Assert (pOtherList);

    CComponentList::iterator iter;
    CComponent* pComponent;

    iter = begin();
    while (iter != end())
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pOtherList->FComponentInList (pComponent))
        {
            erase (iter);
            delete pComponent;
        }
        else
        {
            iter++;
        }
    }
}

HRESULT
CComponentList::HrCopyComponentList (
    IN const CComponentList* pSourceList)
{
    HRESULT hr;

    Assert (this);
    Assert (pSourceList);

    NC_TRY
    {
        *this = *pSourceList;
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CComponentList::HrCopyComponentList");
    return hr;
}

HRESULT
CComponentList::HrAddComponentsInList1ButNotInList2 (
    IN const CComponentList* pList1,
    IN const CComponentList* pList2)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    CComponent* pComponent;

    Assert (this);
    Assert (pList1);
    Assert (pList2);

    hr = S_OK;

    for (iter = pList1->begin(); iter != pList1->end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pList2->FComponentInList (pComponent))
        {
            continue;
        }

        hr = HrInsertComponent (pComponent, INS_IGNORE_IF_DUP | INS_SORTED);
        if (S_OK != hr)
        {
            break;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentList::HrAddComponentsInList1ButNotInList2");
    return hr;
}

HRESULT
CComponentList::HrInsertComponent (
    IN const CComponent* pComponent,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;

    Assert (this);
    Assert (pComponent);
    Assert (dwFlags);
    Assert ((dwFlags & INS_ASSERT_IF_DUP) || (dwFlags & INS_IGNORE_IF_DUP));
    Assert ((dwFlags & INS_SORTED) || (dwFlags & INS_NON_SORTED));
    Assert (!(INS_APPEND & dwFlags) && !(INS_INSERT & dwFlags));

    if (FComponentInList (pComponent))
    {
        // If the caller didn't tell us to ignore duplicates, we assert
        // if there is one because it is bad, bad, bad to have duplicate
        // components in the list.
        //
        // If we have a dup, we want the caller to be aware that it
        // is possible, and pass us the flag telling us to ignore it.
        // Otherwise, we assert to let them know. (And we still ignore
        // it.)
        Assert (dwFlags & INS_IGNORE_IF_DUP);

        return S_OK;
    }

    // Assert there is not already a component in the list with the
    // same instance guid.
    //
    Assert (!PFindComponentByInstanceGuid (&pComponent->m_InstanceGuid));

    iterator iter = end();

    if (dwFlags & INS_SORTED)
    {
        // For 'cleanliness sake', keep the components sorted
        // in class order.
        //
        for (iter = begin(); iter != end(); iter++)
        {
            if ((UINT)pComponent->Class() >= (UINT)(*iter)->Class())
            {
                break;
            }
        }
    }

    NC_TRY
    {
        insert (iter, const_cast<CComponent*>(pComponent));
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CComponentList::HrInsertComponent");
    return hr;
}

HRESULT
CComponentList::HrReserveRoomForComponents (
    IN UINT cComponents)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cComponents);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentList::HrReserveRoomForComponents");
    return hr;
}

CComponent*
CComponentList::PFindComponentByBindForm (
    IN NETCLASS Class OPTIONAL,
    IN PCWSTR pszBindForm) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszBindForm && *pszBindForm);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Having a bindform is optional.  Skip those who don't have one.
        //
        if (!pComponent->Ext.PszBindForm())
        {
            continue;
        }

        // Skip components that don't match the class optionally
        // specified by the caller.
        //
        if (FIsValidNetClass(Class) && (Class != pComponent->Class()))
        {
            continue;
        }

        Assert (pComponent->Ext.PszBindForm());

        if (0 == _wcsicmp (pszBindForm, pComponent->Ext.PszBindForm()))
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByBindName (
    IN NETCLASS Class OPTIONAL,
    IN PCWSTR pszBindName) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszBindName && *pszBindName);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip components that don't match the class optionally
        // specified by the caller.
        //
        if (FIsValidNetClass(Class) && (Class != pComponent->Class()))
        {
            continue;
        }

        Assert (pComponent->Ext.PszBindName());

        if (0 == _wcsicmp (pszBindName, pComponent->Ext.PszBindName()))
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByInstanceGuid (
    IN const GUID* pInstanceGuid) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pInstanceGuid);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (*pInstanceGuid == pComponent->m_InstanceGuid)
        {
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByInfId (
    IN PCWSTR pszInfId,
    IN OUT ULONG* pulIndex OPTIONAL) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszInfId && *pszInfId);

    iter = begin();
    if (pulIndex && (*pulIndex <= size()))
    {
        iter = begin() + *pulIndex;
        Assert (iter <= end());
    }

    for (; iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);
        Assert (pComponent->m_pszInfId && *pComponent->m_pszInfId);

        if (0 == _wcsicmp (pszInfId, pComponent->m_pszInfId))
        {
            if (pulIndex)
            {
                Assert (iter >= begin());
                *pulIndex = (ULONG)(iter - begin());
            }
            return pComponent;
        }
    }

    return NULL;
}

CComponent*
CComponentList::PFindComponentByPnpId (
    IN PCWSTR pszPnpId) const
{
    const_iterator  iter;
    CComponent*     pComponent;

    Assert (this);
    Assert (pszPnpId && *pszPnpId);

    for (iter = begin(); iter != end(); iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->m_pszPnpId)
        {
            continue;
        }

        Assert (pComponent->m_pszPnpId && *pComponent->m_pszPnpId);

        if (0 == _wcsicmp (pszPnpId, pComponent->m_pszPnpId))
        {
            return pComponent;
        }
    }

    return NULL;
}

VOID
CComponentList::RemoveComponent (
    IN const CComponent* pComponent)
{
    iterator iter;

    Assert (this);
    Assert (pComponent);

    iter = find (begin(), end(), pComponent);

    // Component should be found.
    //
    Assert (iter != end());

    erase (iter);

    // Should not be any dups.  If there are, the list
    // is bogus to begin with.
    //
    Assert (end() == find (begin(), end(), pComponent));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\classinst.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C L A S S I N S T . C P P
//
//  Contents:   Defines the interface between the binding engine and the
//              network class installer.
//
//  Notes:
//
//  Author:     billbe   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "filtdev.h"
#include "netcfg.h"
#include "iatl.h"
#include "lockdown.h"
#include "ncatl.h"
#include "ncoc.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "ncwins.h"
#include "persist.h"
#include "provider.h"
#include "resource.h"
#include "util.h"


// HrRegisterNotificationDll functions
enum ciRegisterDllFunction {CIRDF_REGISTER, CIRDF_UNREGISTER};

// The temporary key used for dumping a component's registry entries. This is used
// during the pruning of inapplicable protocols and filter services from the select 
// dialog.
static const WCHAR c_szRegKeyTemp[] = 
                        L"System\\CurrentControlSet\\Control\\Network\\FTempKey";

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegDeleteComponentNetworkKey
//
//  Purpose:    This function deletes the component key strInstanceGuid
//                  (and its subkeys) under the Network\<guidClass> tree.
//
//  Arguments:
//      Class            [in] The class of the component
//      pszInstanceGuid  [in] The instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRegDeleteComponentNetworkKey (
    IN NETCLASS Class,
    IN PCWSTR pszInstanceGuid)
{
    HRESULT hr = S_OK;
    HKEY    hkeyClass = NULL;

    PCWSTR pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];

    // Open the proper class key in the Network tree
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, pszNetworkSubtreePath,
            KEY_WRITE, &hkeyClass);

    // Delete the instance key tree
    //
    if (S_OK == hr)
    {
        hr = HrRegDeleteKeyTree(hkeyClass, pszInstanceGuid);
        RegSafeCloseKey(hkeyClass);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegDeleteComponentKey");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegisterNotificationDll
//
//  Purpose:    Registers or Unregisters a component's notification dll with
//                  COM
//
//  Arguments:
//      hkeyInstance [in] The handle to the instance key for the component
//      crdf         [in] CIRDF_REGISTER if we are registering,
//                              CIRDF_UNREGISTER if we are unregistering
//
//  Returns:    HRESULT. S_OK on if dll is successfully registered,
//                          S_FALSE, if the component has no dll to
//                          register, error code otherwise
//
//  Author:     billbe   23 Mar 1997
//
//  Notes:
//
HRESULT
HrCiRegisterNotificationDll(
    IN HKEY hkeyInstance,
    IN ciRegisterDllFunction crdf)
{
    Assert(hkeyInstance);

    HKEY hkeyNdi;
    HRESULT hr;

    // Open the ndi key in the component's instance key so we can get the
    // Dll path.
    hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);
    if (S_OK == hr)
    {
        // Get the notification dll path
        tstring strDllPath;
        hr = HrRegQueryString (hkeyNdi, L"ComponentDLL", &strDllPath);

        if (S_OK == hr)
        {
            TraceTag (ttidClassInst,
                    "Attempting to (un)register notification dll '%S'",
                    strDllPath.c_str());
            hr = (CIRDF_REGISTER == crdf) ?
                    HrRegisterComObject (strDllPath.c_str()) :
                        HrUnregisterComObject (strDllPath.c_str());
        }
        else
        {
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // The presence of the value is optional, so return
                // S_OK if it was not found
                hr = S_OK;
            }
        }
        RegCloseKey (hkeyNdi);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegisterNotificationDll");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallServices
//
//  Purpose:    Processes any Inf service sections using strInfSection as a
//                  base name
//
//  Arguments:
//      hinfFile      [in] A handle to the inf file
//      pszInfSection [in] The base section name
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   2 Apr 1997
//
//  Notes: See SetupInstallServicesFromInfSection in SetupApi for more
//          info.
//
HRESULT
HrCiInstallServices(
    IN HINF hinfFile,
    IN PCWSTR pszInfSection)
{
    Assert (IsValidHandle(hinfFile));
    Assert (pszInfSection && *pszInfSection);

    BOOL fSuccess;
    WCHAR szServiceSection[_MAX_PATH];

    // append .Services to the section name
    //
    swprintf (szServiceSection, L"%s.%s", pszInfSection,
            INFSTR_SUBKEY_SERVICES);

    // Process the Services section
    fSuccess = SetupInstallServicesFromInfSection (hinfFile,
                    szServiceSection, 0);
    if (!fSuccess)
    {
        // Since the section is optional, we can ignore
        // ERROR_SECTION_NOT_FOUND
        if (ERROR_SECTION_NOT_FOUND == GetLastError())
        {
            fSuccess = TRUE;
        }
    }

    // Any errors must be converted
    HRESULT hr = S_OK;
    if (!fSuccess)
    {
        hr = HrFromLastWin32Error();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrCiInstallServices (%S)", szServiceSection);
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallFromInfSection
//
//  Purpose:    A wrapper function for SetupInstallFromInfSection. This
//              function handles setting up the copy files process for
//              SetupInstallFromInfSection as well.
//
//  Arguments:
//      hinfFile            [in] A handle to the inf file to install from
//      pszInfSectionName   [in] The section to install
//      hkeyRelative        [in] The key that will be used as the section's
//                                  HKR
//      hwndParent          [in] The HWND to the parent window, used for UI
//      dwInstallFlags      [in] See SetupInstallFromInfSection for info on
//                               these flags
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   4 Apr 1997
//
//  Notes: See SetupApi documentation for more info on
//              SetupInstallFromInfSection and
//              SetupInstallFilesFromInfSection
//
HRESULT
HrCiInstallFromInfSection(
    IN HINF hinfFile,
    IN PCWSTR pszInfSectionName,
    IN HKEY hkeyRelative,
    IN HWND hwndParent,
    IN DWORD dwInstallFlags)
{
    Assert (IsValidHandle (hinfFile));
    Assert (pszInfSectionName && *pszInfSectionName);

    HRESULT hr = S_OK;

    if (dwInstallFlags & SPINST_FILES)
    {
        // The next three variables are used for SetupApi's copy files process
        PSP_FILE_CALLBACK pfc;
        PVOID pvCtx;
        HSPFILEQ hfq;

        // If the inf file has a layout entry in its version section
        // we need to append its information for proper locations
        // of any files we need to copy.  If the call fails we can
        // still install, it just means the prompt for files will not
        // have the correct directory to begin with
        (VOID) SetupOpenAppendInfFile (NULL, hinfFile, NULL);

        // We need to create our own file queue so we can scan all the
        // files to be copied.  Scanning before committing our queue will
        // prompt the user if the files already exist in the destination
        //
        hr = HrSetupOpenFileQueue (&hfq);
        if (S_OK == hr)
        {
            BOOL fInGuiModeSetup = FInSystemSetup();

            hr = HrSetupInstallFilesFromInfSection (hinfFile, NULL, hfq,
                    pszInfSectionName, NULL, 0);

            // Set the default callback context
            // If the we are in system setup, we need to make sure the
            // callback doesn't display UI
            //
            if (S_OK == hr)
            {
                hr = HrSetupInitDefaultQueueCallbackEx (hwndParent,
                        (fInGuiModeSetup ? (HWND)INVALID_HANDLE_VALUE : NULL),
                        0, 0, NULL, &pvCtx);

                if (S_OK == hr)
                {
                    // Not doing anything special so use SetupApi default
                    // handler for file copy.
                    pfc = SetupDefaultQueueCallback;

                    // Scan the queue to see if the files are already in the
                    // destination and if so, prune them out.
                    DWORD dwScanResult;
                    hr = HrSetupScanFileQueueWithNoCallback (hfq,
                            SPQ_SCAN_FILE_VALIDITY |
                            SPQ_SCAN_PRUNE_COPY_QUEUE, hwndParent,
                            &dwScanResult);

                    // Now commit the queue so any files needing to be
                    // copied, will be.  If the scan result is 1 then there
                    // is nothing to commit.
                    //
                    if ((S_OK == hr) && (1 != dwScanResult))
                    {
                        hr = HrSetupCommitFileQueue (hwndParent, hfq, pfc, pvCtx);
                    }

                    // We need to release the default context and close our
                    // file queue
                    //
                    SetupTermDefaultQueueCallback (pvCtx);
                    SetupCloseFileQueue (hfq);
                }
            }
        }
    }

    if ((S_OK == hr) && (dwInstallFlags & ~SPINST_FILES))
    {
        Assert (hkeyRelative);

        // Now we run all sections but CopyFiles
        hr = HrSetupInstallFromInfSection (hwndParent, hinfFile,
                pszInfSectionName, (dwInstallFlags & ~SPINST_FILES),
                hkeyRelative, NULL, 0, NULL, NULL, NULL, NULL);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
            "HrCiInstallFromInfSection");
    return hr;

}



//+--------------------------------------------------------------------------
//
//  Function:   HrCiDoCompleteSectionInstall
//
//  Purpose:    Runs all relevant sections of an inf file using strSection
//                   as the base section name.
//
//  Arguments:
//      hinfFile      [in] SetupApi handle to an inf file
//      hkeyRelative  [in] The registry key that will be the HKR
//                         key during inf processing.
//      pszSection    [in] Section name to install
//      hwndParent    [in] The handle to the parent, for
//                                   displaying UI
//      fEnumerated   [in] TRUE if this component is PnP enumerated
//                         FALSE otherwise
//
//  Returns:    HRESULT. S_OK if sucessful, error code otherwise
//
//  Author:     billbe   15 Apr 1997
//
//  Notes:
//
HRESULT
HrCiDoCompleteSectionInstall(
    IN HINF hinfFile,
    IN HKEY hkeyRelative,
    IN PCWSTR pszSection,
    IN HWND hwndParent,
    IN BOOL fEnumerated)
{
    Assert (IsValidHandle (hinfFile));
    Assert (FImplies (!fEnumerated, hkeyRelative));

    HRESULT hr = S_OK;

    // Only do this if there is a section name to work with
    if (pszSection && *pszSection)
    {
        // If this is an enumerated device, the service section and
        // the copy files section will be processed by the Device Installer
        // fcn SetupDiInstallDevice so we can exclude it from the following
        // calls.  But we do some processing based on registry and log config
        // entries so we will pre-run the registry section for enumerated
        // devices and exclude the others
        //

        // Run the section found using hkeyRelative as the HKR
        hr = HrCiInstallFromInfSection (hinfFile, pszSection,
                hkeyRelative, hwndParent,
                (fEnumerated ? (SPINST_REGISTRY | SPINST_LOGCONFIG) :
                        SPINST_ALL & ~SPINST_REGSVR));

        if (!fEnumerated)
        {
            // We need to run the Services section and
            // check for Winsock dependency if they aren't specified to be
            // excluded.
            //
            // Note:  Other sections may be added later.  The default is to
            // run all sections not listed in dwExcludeSectionFlags
            //
            if (S_OK == hr)
            {
                // run services section if it exists
                hr = HrCiInstallServices (hinfFile, pszSection);
                if (S_OK == hr)
                {
                    // Bug #383239: Wait till services are installed before
                    // running the RegisterDlls section
                    //
                    hr = HrCiInstallFromInfSection (hinfFile, pszSection,
                                                    hkeyRelative, hwndParent,
                                                    SPINST_REGSVR);
                }
            }

        }

        if (S_OK == hr)
        {

            //sb This part can be called for either add or remove. We
            //sb are moving only the remove part forward. This should
            //sb still be performed for add.
            //
            // Determine if a .Winsock section exists for the
            // section specified in szActualSection

            PCWSTR pszSubSection = wcsstr(pszSection, L".Remove");

            if(!pszSubSection || wcscmp(pszSubSection, L".Remove"))
            {
                hr = HrAddOrRemoveWinsockDependancy (hinfFile, pszSection);
            }

            // These other extensions are undocumented and some have been
            // added by external groups.  We don't want any of them
            // processed for enumerated components.
            //
            if ((S_OK == hr) && !fEnumerated)
            {
                // Process the additional INF extensions (SNMP Agent,
                // PrintMonitors, etc.)
                //
                hr = HrProcessAllINFExtensions (hinfFile, pszSection);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
            "HrCiDoCompleteSectionInstall");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiRemoveNonEnumeratedComponent
//
//  Purpose:    This will run the remove section and delete the network
//                  instance key for the component if necessary.  This
//                  function is called for partially (i.e. failed install)
//                  and fully installed components
//
//  Arguments:
//      hinf              [in] The handle to the component's inf file
//      hkeyInstance      [in] The handle to the component's instance key
//      Class             [in] The class of the component
//      InstanceGuid      [in] The instance guid of the component
//      pstrRemoveSection [out] Optional pointer to a tstring which receives
//                              the remove section name.
//
//  Returns:    HRESULT. S_OK if successful, NETCFG_S_REBOOT if successful
//                  but a reboot is required, or an error code otherwise
//
//  Author:     billbe   10 Dec 1996
//              Revised  27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRemoveNonEnumeratedComponent(
    IN HINF hinf,
    IN HKEY hkeyInstance,
    IN NETCLASS Class,
    IN const GUID& InstanceGuid,
    OUT tstring* pstrRemoveSection OPTIONAL)
{
    Assert (IsValidHandle (hinf));
    Assert (IsValidHandle (hkeyInstance));

    static const WCHAR c_szRemoveSectionSuffix[] = L".Remove";

    // We get the remove section name and process all relevant sections
    // We also try to unregister any Notify objects available
    //
    WCHAR szRemoveSection[_MAX_PATH];
    DWORD cbBuffer = sizeof (szRemoveSection);
    HRESULT hr = HrRegQuerySzBuffer (hkeyInstance, REGSTR_VAL_INFSECTION,
                    szRemoveSection, &cbBuffer);

    if (S_OK == hr)
    {
        wcscat (szRemoveSection, c_szRemoveSectionSuffix);
        if (pstrRemoveSection)
        {
            pstrRemoveSection->assign(szRemoveSection);
        }
        hr = HrCiDoCompleteSectionInstall (hinf, hkeyInstance,
                szRemoveSection, NULL, NULL);
    }
    // Whether unregistering the notify object is successful or not,
    // we must fully remove the component.
    (VOID) HrCiRegisterNotificationDll (hkeyInstance, CIRDF_UNREGISTER);

    // Now we need to remove the component key in the Network tree
    // We need to do this regardless of any previous errors
    // so we don't need the return value.
    WCHAR szGuid[c_cchGuidWithTerm];
    StringFromGUID2 (InstanceGuid, szGuid, c_cchGuidWithTerm);
    (VOID) HrCiRegDeleteComponentNetworkKey (Class, szGuid);

    // if all went well, set the return value based on whether a reboot
    // is required or not or any error from HrRegisterNotificationDll.
    //
    if (S_FALSE == hr)
    {
        // S_FALSE is okay but should not be returned by this fcn.
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRemoveNonEnumeratedComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiRemoveComponent
//
//  Purpose:    Called from INetCfg, this will uninstall a network component.
//
//  Arguments:
//      pComponent        [in] The component to uninstall.
//      pstrRemoveSection [out] Optional pointer to a tstring which receives
//                              the remove section name.
//
//  Returns:    HRESULT. S_OK if successful, NETCFG_S_REBOOT if successful
//                  but a reboot is required, or an error code otherwise
//
//  Author:     billbe   10 Dec 1996
//              Revised  27 Apr 1997
//
//  Notes:
//
HRESULT
HrCiRemoveComponent(
    IN const CComponent* pComponent,
    OUT tstring* pstrRemoveSection OPTIONAL)
{
    Assert (pComponent);

    HINF hinf = NULL;
    HDEVINFO hdi = NULL;
    SP_DEVINFO_DATA deid;
    HKEY hkeyInstance = NULL;
    HRESULT hr = S_OK;

    // If this is an enumerated net class component, then we need to
    // create the Device Installer structures for HrSetupDiRemoveDevice
    //
    if (FIsEnumerated (pComponent->Class()))
    {
        if (pComponent->m_dwCharacter & NCF_PHYSICAL)
        {
            // The binding engine calls us to remove physical devices
            // only when we need to potentially cleanup the information
            // we saved away when the class installer removed the device.
            // This happens when the class installer is told to remove
            // the device (which it does) and then notifies the binding
            // engine to remove it from its data structures.  The binding
            // engine then calls this method to cleanup this info we
            // set so that the binding engine could notify components of
            // its removal.
            //
            // We can also be called here when a physical component is
            // removed (with the binding engine write lock held by someone)
            // and then readded immediately.  The new component will get
            // the same PnpId as the removed one but the bindng engine still
            // has the removed component in its structures.  When this
            // condition is detected, the binding engine will remove the
            // old instance (by calling us here).  In this case, if we were
            // to open the device info on pComponent->m_pszPnpId, we'd open
            // the new instance that was added.  We don't want to do this.
            // We just want to cleanup any of the information that we set
            // for the binding engine when we first removed the device.
            //

            HKEY hkeyComponent;
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    c_szTempNetcfgStorageForUninstalledEnumeratedComponent,
                    KEY_WRITE, &hkeyComponent);

            if (S_OK == hr)
            {
                WCHAR szGuid[c_cchGuidWithTerm];
                INT cch = StringFromGUID2 (pComponent->m_InstanceGuid, szGuid,
                        c_cchGuidWithTerm);

                Assert (c_cchGuidWithTerm == cch);

                (VOID) HrRegDeleteKeyTree (hkeyComponent, szGuid);
                RegCloseKey (hkeyComponent);
            }
        }
        else
        {
            // Create a device info list
            hr = HrOpenDeviceInfo (pComponent->Class(),
                    pComponent->m_pszPnpId, &hdi, &deid);

            if (S_OK == hr)
            {
                // removals must go through device installer
                // hook (NetClassInstaller).  The function we are
                // in can only be called if the caller has the write lock
                // so we need to indicate this to the device installer hook
                // through our reserved data.
                ADAPTER_REMOVE_PARAMS arp = {0};
                CiSetReservedField (hdi, &deid, &arp);

                // removals must go through device installer
                // hook (NetClassInstaller).
                hr = HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, &deid);

                // clear the reserved field so we don't delete it later
                CiClearReservedField (hdi, &deid);

                if (S_OK == hr)
                {
                    hr = FSetupDiCheckIfRestartNeeded (hdi, &deid) ?
                            NETCFG_S_REBOOT : S_OK;
#ifdef ENABLETRACE
                    if (NETCFG_S_REBOOT == hr)
                    {
                        TraceTag (ttidClassInst, "***********************************"
                                "**************************************************");

                        TraceTag (ttidClassInst, "The component %S needs a reboot "
                                "in order to function", pComponent->m_pszPnpId);

                        TraceTag (ttidClassInst, "***********************************"
                            "**************************************************");
                    }
#endif //ENABLETRACE
                }
                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }
    else
    {
        // For non enumerated components, the instance key is the
        // component key
        hr = pComponent->HrOpenInstanceKey (KEY_ALL_ACCESS, &hkeyInstance,
                NULL, NULL);

        if (S_OK == hr)
        {
            if (NC_NETCLIENT == pComponent->Class ())
            {
                hr = HrCiDeleteNetProviderInfo (hkeyInstance, NULL, NULL);
            }


            if (S_OK == hr)
            {
                hr = pComponent->HrOpenInfFile(&hinf);

                if( S_OK == hr )
                {
                    // Remove the component
                    hr = HrCiRemoveNonEnumeratedComponent ( hinf,
                            hkeyInstance, pComponent->Class(),
                            pComponent->m_InstanceGuid,
                            pstrRemoveSection);
                }
            }
        }

        RegSafeCloseKey (hkeyInstance);
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
            "HrCiRemoveComponent (%S)", pComponent->PszGetPnpIdOrInfId());
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetDriverInfo
//
//  Purpose:    Finds a component's driver information (in the inf file) and
//              creates a Device Info Data structure containing that
//              information as the structure's selected driver.
//              (see Device Installer Api for more info).
//
//  Arguments:
//      hdi        [in] See Device Installer Api documentation for more info.
//      pdeid      [in, out] See Device Installer Api documentation for
//                    more info. Should be allocated by caller, but empty.
//      guidClass  [in] The class guid for the component.
//      pszInfId   [in] The id of the component as found in its inf.
//      pszInfFile [in] Optional. The inf file for the component.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiGetDriverInfo (
    IN     HDEVINFO hdi,
    IN OUT PSP_DEVINFO_DATA pdeid,
    IN     const GUID& guidClass,
    IN     PCWSTR pszInfId,
    IN     PCWSTR pszInfFile OPTIONAL)
{
    HRESULT hr;

    Assert (IsValidHandle (hdi));
    Assert (pdeid);
    Assert (pszInfId);

    // Copy the Id since we may need to change it.
    //
    WCHAR szId[_MAX_PATH];
    wcscpy (szId, pszInfId);

    // We cannot generate ids via HrSetupDiCreateDeviceInfo if they contain
    // slashes (e.g. Eisa\*pnp0232), so we need to convert any slashes in
    // the instance id to ampersands.
    //
    int iPos = 0;
    while (szId[iPos])
    {
        if (L'\\' == szId[iPos])
        {
            szId[iPos] = L'&';
        }
        ++iPos;
    }

    // First, create a [temporary] device info. This will be used to
    // find the component's Inf file.
    hr = HrSetupDiCreateDeviceInfo (hdi, szId, guidClass, NULL, NULL,
            DICD_GENERATE_ID, pdeid);

    if (S_OK == hr)
    {
        // In order to find the Inf file, Device Installer Api needs the
        // component id which it calls the Hardware id.
        //

        // We need to include an extra null since this registry value is a
        // multi-sz
        //
        wcsncpy (szId, pszInfId, iPos);
        szId[iPos + 1] = 0;

        hr = HrSetupDiSetDeviceRegistryProperty (hdi, pdeid, SPDRP_HARDWAREID,
                (const BYTE*)szId, CbOfSzAndTerm (szId) + sizeof(WCHAR));

        if (S_OK == hr)
        {
            // Get the install params and set the class for compat flag
            // This will use the device's class guid as a filter when
            // searching through infs, speeding things up.  We can also
            // let Device Installer Api know that we want to use a single
            // inf. if we can't get the params and set it it isn't an error
            // since it only slows things down a bit
            //
            SP_DEVINSTALL_PARAMS deip;
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
            if (S_OK == hr)
            {
                deip.FlagsEx |= DI_FLAGSEX_USECLASSFORCOMPAT;

                // If we were not given an inf file to use...
                // We have a map of known components and their inf files.
                // If this component is in the map then we can set the
                // driver path in the device info data and
                // set the enumerate a single inf flag.  This will
                // cause the device installer to just look at the specified
                // inf file for the driver node.
                //

                // We only do this if the node doesn't already have a file
                // name set.
                //
                if (!(*deip.DriverPath))
                {
                    if (pszInfFile && *pszInfFile)
                    {
                        wcscpy (deip.DriverPath, pszInfFile);
                    }
                    else
                    {
                        FInfFileFromComponentId (pszInfId, deip.DriverPath);
                    }
                }

                if (*deip.DriverPath)
                {

                    TraceTag (ttidClassInst, "Class Installer was given %S "
                             "as a filename for %S", deip.DriverPath,
                             pszInfId);
                    deip.Flags |= DI_ENUMSINGLEINF;

                    if ((0 == _wcsicmp(L"netrasa.inf", deip.DriverPath)) ||
                        (0 == _wcsicmp(L"netpsa.inf",  deip.DriverPath)))
                    {
                        deip.Flags |= DI_NOFILECOPY;
                    }
                }

                // For non-device classes, we need to allow excluded
                // drivers in order to get any driver list returned.
                if (!FIsEnumerated (guidClass))
                {
                    deip.FlagsEx |= DI_FLAGSEX_ALLOWEXCLUDEDDRVS;
                }

                (VOID) HrSetupDiSetDeviceInstallParams (hdi, pdeid, &deip);
            }

            // Now we let Device Installer Api build a driver list based on
            // the information we have given so far.  This will result in the
            // Inf file being found if it exists in the usual Inf directory
            //
#ifdef ENABLETRACE
    CBenchmark bmrk;
    bmrk.Start ("SetupDiBuildDriverInfoList");
#endif //ENABLETRACE

            hr = HrSetupDiBuildDriverInfoList (hdi, pdeid,
                    SPDIT_COMPATDRIVER);
#ifdef ENABLETRACE
    bmrk.Stop();
    TraceTag (ttidBenchmark, "%s : %s seconds",
            bmrk.SznDescription(), bmrk.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

            if (S_OK == hr)
            {
                // HrSetupDiSelectBestCompatDrv finds and selects the best
                // driver for the device.
                //
                SP_DRVINFO_DATA drid;
                hr = HrSetupDiSelectBestCompatDrv(hdi, pdeid);

                if (HRESULT_FROM_SETUPAPI(ERROR_NO_COMPAT_DRIVERS) == hr)
                {
                    // Make the ERROR_NO_COMPAT_DRIVERS case look like what
                    // it really means -- the requested component's driver
                    // info (i.e. inf) could not be found.
                    //
                    hr = SPAPI_E_NO_DRIVER_SELECTED;
                }
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                // We couldn't find an inf file which means we cannot
                // selected the driver for this component.
                //
                hr = SPAPI_E_NO_DRIVER_SELECTED;
            }
        }

        // if anything failed, we should remove the device node we created
        if (FAILED(hr))
        {
            (VOID) SetupDiDeleteDeviceInfo (hdi, pdeid);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetDriverInfo");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetClassAndInfFileOfInfId
//
//  Purpose:    Finds a component's class and inf file.
//
//  Arguments:
//      pszInfId   [in]  The Id of the component as found in its Inf.
//      pClass     [out] The class of the component.
//      pszInfFile [out] The filename of the component's inf
//                       (must be _MAX_PATH long).
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   16 Mar 1998
//
//  Notes:
//
HRESULT
HrCiGetClassAndInfFileOfInfId (
    IN PCWSTR pszInfId,
    OUT NETCLASS* pClass,
    OUT PWSTR pszInfFile)   // Must be _MAX_PATH long
{
    HRESULT hr;
    const COMPONENT_INFO* pCompInfo;
    HDEVINFO hdi;

    Assert (pszInfId && *pszInfId);
    Assert (pClass);
    Assert (pszInfFile);

    hr = S_OK;

    // First, try the fast route by seeing if it's in our internal map.
    //
    pCompInfo = PComponentInfoFromComponentId (pszInfId);
    if (pCompInfo)
    {
        *pClass = NetClassEnumFromGuid (*pCompInfo->pguidClass);

        if (FIsValidNetClass (*pClass))
        {
            wcsncpy (pszInfFile, pCompInfo->pszInfFile, _MAX_PATH);
            pszInfFile [_MAX_PATH - 1] = 0;
        }
        else
        {
            hr = SPAPI_E_INVALID_CLASS;
        }
    }
    else
    {
        // Create a device info list.
        //
        hr = HrSetupDiCreateDeviceInfoList (NULL, NULL, &hdi);
        if (S_OK == hr)
        {
            SP_DEVINFO_DATA deid;

            // Get the driver info for the component and set it as the
            // selected driver
            //
            hr = HrCiGetDriverInfo (hdi, &deid, GUID_NULL, pszInfId, NULL);
            if (S_OK == hr)
            {
                SP_DRVINFO_DATA drid;

                // Get the selected driver.
                //
                hr = HrSetupDiGetSelectedDriver (hdi, &deid, &drid);
                if (S_OK == hr)
                {
                    // Set the class output parameter from the dev info data
                    // structure (HrGetDriverInfo updates this field if a driver
                    // was found)
                    //
                    *pClass = NetClassEnumFromGuid (deid.ClassGuid);

                    if (!FIsValidNetClass (*pClass))
                    {
                        hr = SPAPI_E_INVALID_CLASS;
                    }
                    else
                    {
                        PSP_DRVINFO_DETAIL_DATA pdridd;

                        // Now get the driver's detailed information
                        //
                        hr = HrCiGetDriverDetail (hdi, &deid, &drid,
                                                 &pdridd);
                        if (S_OK == hr)
                        {
                            // Get the inf filename and set the
                            // output parameter.
                            //
                            wcsncpy (pszInfFile, pdridd->InfFileName,
                                _MAX_PATH);
                            pszInfFile[_MAX_PATH - 1] = 0;

                            MemFree (pdridd);
                        }
                    }
                }
            }
            SetupDiDestroyDeviceInfoList (hdi);
        }
    }

    if (S_OK != hr)
    {
        *pClass = NC_INVALID;
        *pszInfFile = 0;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetClassAndInfFileOfInfId");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetDriverDetail
//
//  Purpose:    Creates and fills a PSP_DRVINFO_DETAIL_DATA structure
//                  with detailed information about the pDevInfoData's
//                  selected driver
//
//  Arguments:
//      hdi     [in] See Device Installer Api documentation for more info
//      pdeid   [in] See Device Installer Api documentation for more info
//                          This value is NULL for non-physical net
//                          components.
//      pdrid   [in] See Device Installer Api documentation for more info
//      ppdridd [out] See Device Installer Api documentation for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiGetDriverDetail (
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid OPTIONAL,
    OUT PSP_DRVINFO_DATA pdrid,
    OUT PSP_DRVINFO_DETAIL_DATA* ppdridd)
{
    Assert(IsValidHandle(hdi));
    Assert(pdrid);
    Assert(ppdridd);

    // initialize pdrid and set its cbSize field
    ZeroMemory (pdrid, sizeof (SP_DRVINFO_DATA));
    pdrid->cbSize = sizeof (SP_DRVINFO_DATA);

    HRESULT hr = S_OK;

    *ppdridd = NULL;

    // Get the selected driver for the component
    hr = HrSetupDiGetSelectedDriver (hdi, pdeid, pdrid);
    if (S_OK == hr)
    {
        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail (hdi, pdeid, pdrid, ppdridd);
    }

    // clean up on failure
    if (FAILED(hr))
    {
        if (*ppdridd)
        {
            MemFree (*ppdridd);
            *ppdridd = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetDriverDetail");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiRegSetComponentInformation
//
//  Purpose:    Stores component information under the instance key of
//                  the component.
//
//  Arguments:
//      hkeyInstance [in] Component's instance registry key.
//      pcii         [in] Component's information to store in hkeyInstance.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   11 Mar 1997
//
//  Notes:
//
HRESULT
HrCiRegSetComponentInformation(
    IN HKEY hkeyInstance,
    IN COMPONENT_INSTALL_INFO* pcii)
{
    Assert(hkeyInstance);
    Assert(pcii);

    HRESULT hr = S_OK;

    BOOL fIsEnumerated = FIsEnumerated (pcii->Class);

    // Store the characteristics, inf path, and main
    // install section for the component
    //

    hr = HrRegSetDword (hkeyInstance, L"Characteristics", pcii->dwCharacter);

    if (FAILED(hr))
    {
        goto exit;
    }

    if (!fIsEnumerated)
    {
        hr = HrRegSetSz (hkeyInstance, L"InfPath" /*REGSTR_VAL_INFPATH*/,
                pcii->pszInfFile);

        if (FAILED(hr))
        {
            goto exit;
        }

        hr = HrRegSetSz (hkeyInstance, L"InfSection"/*REGSTR_VAL_INFSECTION*/,
                pcii->pszSectionName);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // For non-enumerated components, store description into the registry.
    //
    if (!fIsEnumerated)
    {
        hr = HrRegSetSz (hkeyInstance, L"Description", pcii->pszDescription);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    // If this component is already installed, then there is no need to write
    // the following information
    //
    if (FIsEnumerated (pcii->Class) && !pcii->fPreviouslyInstalled &&
                FIsPhysicalAdapter (pcii->Class, pcii->dwCharacter) &&
                (InterfaceTypeUndefined != pcii->BusType))
    {
        hr = HrRegSetSzAsUlong (hkeyInstance, L"BusType",
                pcii->BusType, c_nBase10);

        if (FAILED(hr))
        {
            goto exit;
        }
    }

    hr = HrRegSetSz (hkeyInstance, L"ComponentId", pcii->pszInfId);

exit:

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRegSetComponentInformation");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateInstanceKey
//
//  Purpose:    Creates an instance key for the component.  For enumerated
//                devices, this is
//                HKLM\System\CCS\Control\Class\<net guid>\<instance id>
//                For non-enumerated components, this is under
//                HKLM\System\CCS\Control\Network\<Class Guid>\<Instance Guid>
//
//  Arguments:
//      pcii          [inout] Component install info structure.
//      phkeyInstance [out]   The component's registry instance key.
//
//  Returns:    HRESULT
//
//  Author:     billbe   22 Mar 1997
//
//  Notes:
//
HRESULT
HrCiCreateInstanceKey(
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkeyInstance)
{
    Assert (pcii);
    Assert (phkeyInstance);
    Assert (FImplies (FIsEnumerated (pcii->Class),
                    IsValidHandle (pcii->hdi) && pcii->pdeid));

    HRESULT hr = S_OK;

    // initialize the HKEY parameter
    *phkeyInstance = NULL;

    // Create the instance key for this component under the
    // Network\<net guid> tree.  This will be the component's
    // instance key for all but physical net class components.  Their
    // instance key is created by Device Installer Api and lives under the
    // Pnp Net Class driver tree.

    // If the object is an enumerated component then we let
    // the Device Installer api do the work
    //
    if (FIsEnumerated (pcii->Class))
    {

        // We need to create the adapter's driver key under
        // the Pnp Net Class Driver tree.
        //

        hr = HrSetupDiCreateDevRegKey (pcii->hdi,
                pcii->pdeid, DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                NULL, NULL, phkeyInstance);
    }
    else
    {
        // Not a physical net adapter so the component key is
        // the instance key

        // First, create the instance GUID
        hr = CoCreateGuid (&pcii->InstanceGuid);

        // Now create the key
        if (S_OK == hr)
        {
            WCHAR szInstanceKeyPath[_MAX_PATH];

            CreateInstanceKeyPath (pcii->Class, pcii->InstanceGuid,
                    szInstanceKeyPath);

            hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
                     szInstanceKeyPath,
                     REG_OPTION_NON_VOLATILE,
                     KEY_ALL_ACCESS,
                     NULL,
                     phkeyInstance,
                     NULL);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiCreateInstanceKey");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetPropertiesFromInf
//
//  Purpose:    Retrieves a set of the component's proerties from the inf
//                  file.
//
//  Arguments:
//      hinfFile [in] A handle to the component's inf file
//      pcii     [inout] The component info structure
//                       See compinfo.h for more info
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   14 Jun 1997
//
//  Notes:
//
HRESULT
HrCiGetPropertiesFromInf (
    IN HINF hinfFile,
    IN OUT COMPONENT_INSTALL_INFO* pcii)
{
    Assert (IsValidHandle (hinfFile));
    Assert (pcii);
    Assert (pcii->pszSectionName);

    // Find the inf line that contains Characteristics and retrieve it

    HRESULT hr = HrSetupGetFirstDword (hinfFile, pcii->pszSectionName,
            L"Characteristics", &pcii->dwCharacter);

    if ((S_OK == hr) &&
            (FIsPhysicalAdapter(pcii->Class, pcii->dwCharacter)))
    {
        hr = HrCiGetBusInfoFromInf (hinfFile, pcii);
    }
#ifdef DBG
    else if (FAILED(hr))
    {
        TraceTag(ttidError, "Inf contains no Characteristics field");
    }
#endif // DBG

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetPropertiesFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiIsInstalledComponent
//
//  Purpose:    Checks if the component is already installed
//
//
//  Arguments:
//      pcici  [in] A structure containing the component information
//                       See compinst.h for definition
//      phkey  [out] The registry instance key of the adapter
//                     during inf processing. only set if fcn returns S_OK
//
//  Returns:    HRESULT - S_OK if the component is already installed
//                        S_FALSE if the component is not already installed
//                        A win32 converted error otherwise
//
//  Author:     billbe   17 Sep 1997
//
//  Notes:
//
HRESULT
HrCiIsInstalledComponent (
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey)
{
    HRESULT hr;

    Assert(pcii);

    if (phkey)
    {
        *phkey = NULL;
    }

    // If this is an enumerated component, we just check for NetCfgInstanceId
    // in the instance (driver) key.
    //
    if (FIsEnumerated (pcii->Class))
    {
        HKEY hkey;
        hr = HrSetupDiOpenDevRegKey (pcii->hdi, pcii->pdeid, DICS_FLAG_GLOBAL,
                0, DIREG_DRV, KEY_ALL_ACCESS, &hkey);

        if (S_OK == hr)
        {
            WCHAR szGuid[c_cchGuidWithTerm];
            DWORD cbGuid = sizeof (szGuid);
            hr = HrRegQuerySzBuffer (hkey, L"NetCfgInstanceId", szGuid,
                    &cbGuid);

            if (S_OK == hr)
            {
                IIDFromString (szGuid, &pcii->InstanceGuid);
                if (phkey)
                {
                    *phkey = hkey;
                }
            }
            else
            {
                RegCloseKey (hkey);
                hr = S_FALSE;
            }
        }
        else if ((SPAPI_E_KEY_DOES_NOT_EXIST == hr) ||
                (SPAPI_E_DEVINFO_NOT_REGISTERED == hr))

        {
            TraceTag(ttidClassInst, "Component is not known by Net Config");
            hr = S_FALSE;
        }
    }
    else
    {
        // For non-enumerated components, we check the netcfg "config blob" to
        // determine if this component is isntalled.
        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

        if (S_OK == hr)
        {
            CComponent* pComponent;
            pComponent = NetConfig.Core.Components.
                    PFindComponentByInfId(pcii->pszInfId, NULL);

            if (pComponent)
            {
                pcii->InstanceGuid = pComponent->m_InstanceGuid;
                if (phkey)
                {
                    hr = pComponent->HrOpenInstanceKey(KEY_ALL_ACCESS, phkey,
                            NULL, NULL);
                }
            }
            else
            {
                hr = S_FALSE;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr, "HrCiIsInstalledComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateInstanceKeyAndProcessMainInfSection
//
//  Purpose:    Processes a component's main inf section and
//              storing, in the registry, any extra information needed for
//              component initialization
//
//  Arguments:
//      hinf  [in] Handle to the component's inf file.
//      pcii  [inout] Will be filled with information about the
//                    component.
//      phkey [out] Handle to the component's registry instance key.
//
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 Nov 1996
//
//  Notes:
//
HRESULT
HrCiCreateInstanceKeyAndProcessMainInfSection(
    IN HINF hinf,
    IN COMPONENT_INSTALL_INFO* pcii,
    OUT HKEY* phkey)
{
#if defined(REMOTE_BOOT)
    GUID c_guidRemoteBoot;
    static const WCHAR c_szRemoteBootAdapterGuid[] =
            L"{54C7D140-09EF-11D1-B25A-F5FE627ED95E}";

    DEFINE_GUID(c_guidRemoteBoot, 0x54c7d140, 0x09ef, 0x11d1, 0xb2, 0x5a, 0xf5, 0xfe, 0x62, 0x7e, 0xd9, 0x5e);
#endif // defined(REMOTE_BOOT)

    Assert (IsValidHandle (hinf));
    Assert (pcii);
    Assert (phkey);

    // The properties retrieved here will be written to the registry
    // later.
    HRESULT hr = HrCiGetPropertiesFromInf (hinf, pcii);

    if (S_OK == hr)
    {
        BOOL fEnumerated = FIsEnumerated (pcii->Class);

        // If this component is enumerated, then we need to know if it
        // is a remote boot adapter.
        if (fEnumerated)
        {
            Assert (IsValidHandle (pcii->hdi));
            Assert (pcii->pdeid);

#if defined(REMOTE_BOOT)
            // If this adapter is a remote boot adapter, then we have
            // to use a pre-determined GUID
            //
            if (S_OK == HrIsRemoteBootAdapter(pcii->hdi, pcii->pdeid))
            {
                pcai->m_fRemoteBoot = TRUE;
                pcii->InstanceGuid = c_guidRemoteBoot;
            }
#endif // defined(REMOTE_BOOT)

        }

        // Is this a fresh install or a reinstall?
        hr = HrCiIsInstalledComponent(pcii, phkey);

        if (S_FALSE == hr)
        {
            hr = S_OK;

            // Fresh install
            //

            if (S_OK == hr)
            {
                // For non-physical components, the relative key will
                // be the driver instance key which is under the class
                // branch of the Network key. Its form is
                // <Class GUID>/<instance GUID>.
                // For physical components, the key is under
                // the Pnp class driver tree. The next call will
                // create this key

                hr = HrCiCreateInstanceKey(pcii, phkey);

                if (fEnumerated)
                {
                    // If  we don't have an instance
                    // guid (i.e. not remote boot adapter),
                    // get one
                    if (GUID_NULL == pcii->InstanceGuid)
                    {
                        hr = CoCreateGuid(&pcii->InstanceGuid);
#ifdef ENABLETRACE
                        WCHAR szGuid[c_cchGuidWithTerm];
                        StringFromGUID2(pcii->InstanceGuid, szGuid,
                                c_cchGuidWithTerm);
                        TraceTag(ttidClassInst, "NetCfg Instance Guid %S "
                                "generated for %S",
                                 szGuid,
                                 pcii->pszInfId);
#endif // ENABLETRACE
                    }
                }
            }
        }
        else if (S_OK == hr)
        {
            // This component is being reinstalled
            pcii->fPreviouslyInstalled = TRUE;
        }

        if (S_OK == hr)
        {
            // Now that the instance key is created, we need to run
            // the main inf sections
            //
            hr = HrCiDoCompleteSectionInstall(hinf, *phkey,
                    pcii->pszSectionName,
                    pcii->hwndParent, fEnumerated);

            // On failure of fresh installs, remove components
            if (FAILED(hr) && !pcii->fPreviouslyInstalled)
            {
                if (!fEnumerated)
                {
                    HrCiRemoveNonEnumeratedComponent (hinf, *phkey,
                        pcii->Class, pcii->InstanceGuid, NULL);
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiCreateInstanceKeyAndProcessMainInfSection");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiDoOemFileCopyIfNeeded
//
//  Purpose: Calls HrSetupCopyOemInf if strInfPath is not already in the
//              inf directory.  This will copy an Oem inf to the inf
//              directory with a new name.
//
//  Arguments:
//      pszInfPath [in]  Path to the inf file
//      pszNewName [out] The new name of the copied inf file
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 May 1997
//
//  Notes:
//
HRESULT
HrCiDoOemFileCopyIfNeeded(
    IN PCWSTR pszInfPath,
    OUT PWSTR pszNewName)
{
    Assert (pszInfPath);
    Assert (pszNewName);

    HRESULT hr = S_OK;
    WCHAR szInfDir[_MAX_PATH] = {0};

    // fill buffer with path to %windir%
    GetSystemWindowsDirectory (szInfDir, _MAX_PATH);

    // the inf directory is %windir%\inf
    //
    wcscat (szInfDir, L"\\");
    wcscat (szInfDir, L"Inf");

    // Extract the directory from the filename
    //
    PWSTR pszEnd = wcsrchr (pszInfPath, L'\\');
    DWORD cch;
    if (pszEnd)
    {
        cch = (DWORD)(pszEnd - pszInfPath);
    }
    else
    {
        cch = wcslen (pszInfPath);
    }

    // if the inf is not already in the inf directory, copy it there
    //
    if ((cch != wcslen (szInfDir)) ||
            (0 != _wcsnicmp (pszInfPath, szInfDir, cch)))
    {
        WCHAR szDestFilePath[_MAX_PATH];
        PWSTR pszDestFilename;
        hr = HrSetupCopyOemInfBuffer (pszInfPath, NULL, SPOST_PATH, 0,
                szDestFilePath, _MAX_PATH, &pszDestFilename);

        if (S_OK == hr)
        {
            wcscpy (pszNewName, pszDestFilename);
        }
    }
    else
    {
        // The inf is already in the right directory so just copy the
        // current filename component.
        if (pszEnd)
        {
            wcscpy (pszNewName, pszEnd + 1);
        }
        else
        {
            wcscpy (pszNewName, pszInfPath);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDoOemFileCopyIfNeeded");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallNonEnumeratedComponent
//
//  Purpose:    This function completes the installation of a non-enumerated
//                  component
//
//  Arguments:
//      hinf [in] SetupApi handle to an inf file
//      hkey [in] The registry instance key of the adapter
//                during inf processing.
//      pcii [in] A structure containing the component information
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:
//
HRESULT
HrCiInstallNonEnumeratedComponent (
    IN HINF hinf,
    IN HKEY hkey,
    IN COMPONENT_INSTALL_INFO* pcii)
{
    // Register the notification dll for this component,
    // if it exists.
    HRESULT hr = HrCiRegisterNotificationDll(hkey, CIRDF_REGISTER);

    // Device Installer Api handles OEM files for
    // enumerated components in InstallDevice
    // Since this component is non-enumerated
    // we need to handle any oem files
    // manually.
    //

    // Copy the inf file if needed then store
    // the new inf name
    // Note: if the inf file does not need to
    // be copied, the new name will be the
    // old name without the directory info.
    //

    if (S_OK == hr)
    {
        WCHAR szNewName[_MAX_PATH];;
        hr = HrCiDoOemFileCopyIfNeeded (pcii->pszInfFile, szNewName);
        if (S_OK == hr)
        {
            // set the new path value in the registry.
            hr = HrRegSetSz (hkey, REGSTR_VAL_INFPATH, szNewName);

            if ((S_OK == hr) && (NC_NETCLIENT == pcii->Class))
            {
                // if this is a network client, do appropriate processing.
                hr = HrCiAddNetProviderInfo (hinf, pcii->pszSectionName,
                        hkey, pcii->fPreviouslyInstalled);
            }
        }
    }

    // On failures of first time installs, remove the component.
    //
    if (FAILED(hr) && !pcii->fPreviouslyInstalled)
    {
        TraceTag (ttidClassInst, "Install canceled. Removing...");
        (VOID) HrCiRemoveNonEnumeratedComponent (hinf, hkey, pcii->Class,
                pcii->InstanceGuid, NULL);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallNonEnumeratedComponent");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallComponentInternal
//
//  Purpose: Installs a component
//
//  Arguments:
//      pcii [in, out] Will be filled with information about the
//                     component.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   15 Nov 1996
//
//  Notes:
//
HRESULT
HrCiInstallComponentInternal (
    IN OUT COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT hr = S_OK;
    HINF hinfInstallFile = NULL;
    HKEY hkeyInstance = NULL;

    TraceTag (ttidClassInst, "Installing %S from %S",
              pcii->pszInfId, pcii->pszInfFile);

    // Open the component's inf file.
    hr = HrSetupOpenInfFile (pcii->pszInfFile, NULL, INF_STYLE_WIN4,
            NULL, &hinfInstallFile);

    // Continue only if we have opened the file.
    if (S_OK == hr)
    {
        // The section we have currently might need to be decorated
        // with OS and Platform specific suffixes.  The next call
        // will return the actual decorated section name or our
        // current section name if the decorated one does not exist.
        //

        // Store the original section name pointer so we can restore
        // it after we have finished.
        PCWSTR pszOriginalSectionName = pcii->pszSectionName;

        // Now we get the actual section name.
        //
        WCHAR szActualSection[_MAX_PATH];
        hr = HrSetupDiGetActualSectionToInstallWithBuffer (hinfInstallFile,
                pcii->pszSectionName, szActualSection, _MAX_PATH, NULL,
                NULL);

        if (S_OK == hr)
        {
            pcii->pszSectionName = szActualSection;
            hr = HrCiCreateInstanceKeyAndProcessMainInfSection (
                hinfInstallFile, pcii, &hkeyInstance);

            if (S_OK == hr)
            {
                // Set up the registry with the component info.
                hr = HrCiRegSetComponentInformation (hkeyInstance, pcii);

                if (S_OK == hr)
                {
                    // We do different things during install based
                    // on whether PnP knows about the component
                    // (i.e. enumerated) or not.

                    if (FIsEnumerated (pcii->Class))
                    {
                        hr = HrCiInstallEnumeratedComponent (
                                hinfInstallFile, hkeyInstance, *pcii);
                    }
                    else
                    {
                        hr = HrCiInstallNonEnumeratedComponent (
                               hinfInstallFile, hkeyInstance, pcii);
                    }
                }
                RegSafeCloseKey(hkeyInstance);
            }
            // set the section name back
            pcii->pszSectionName = pszOriginalSectionName;
        }
        SetupCloseInfFile(hinfInstallFile);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallComponentInternal");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCallClassInstallerToInstallComponent
//
//  Purpose:    This function invokes the class installer to install an
//              enumerated component.
//
//  Arguments:
//      hdi   [in] See Device Installer docs for more info.
//      pdeid [in]
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise
//
//  Author:     billbe   28 Apr 1997
//
//  Notes:  This should only be called while the INetCfg lock is held.
//
HRESULT
HrCiCallClassInstallerToInstallComponent(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    HRESULT hr;

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // We need to register the device before we do any work on it.
    hr = HrSetupDiCallClassInstaller (DIF_REGISTERDEVICE, hdi, pdeid);

    if (S_OK == hr)
    {
        // Check if we can install of this component. i.e. is the inf
        // a valid Windows 2000 inf.
        hr = HrSetupDiCallClassInstaller (DIF_ALLOW_INSTALL, hdi, pdeid);

        if (S_OK == hr)
        {
            BOOL fFileCopy = TRUE;
            SP_DEVINSTALL_PARAMS deip;

            // Fu fu fu: SetupApi is ignoring DI_NOFILECOPY so we'll overcome
            // their shortcomings and do it ourselves.
            //
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
            if (S_OK == hr)
            {
                if (deip.Flags & DI_NOFILECOPY)
                {
                    fFileCopy = FALSE;
                }
            }

            if (fFileCopy)
            {
                // Install needed files.
                hr = HrSetupDiCallClassInstaller (DIF_INSTALLDEVICEFILES, hdi,
                        pdeid);
            }

            if (S_OK == hr)
            {
                // Now that all files have been copied, we need to set the
                // no file copy flag.  Otherwise, setupapi will try to copy
                // files at each dif code.  This results in multiple (1 per
                // dif code) unsigned driver popups if the driver was
                // unsigned.
                // We'll only do this if the no copy file flag wasn't already
                // set. i.e. if fFileCopy is TRUE.
                //
                if (fFileCopy)
                {
                    // An error here isn't bad enough to stop installation.
                    //
                    HRESULT hrTemp;
                    hrTemp = HrSetupDiSetDeipFlags (hdi, pdeid, DI_NOFILECOPY,
                            SDDFT_FLAGS, SDFBO_OR);

                    TraceHr (ttidError, FAL, hrTemp, FALSE,
                            "HrCiCallClassInstallerToInstallComponent: "
                             "HrSetupDiSetDeipFlags");
                }

                // Device co-installers need to be registered at this point
                // so they can do work.
                hr = HrSetupDiCallClassInstaller (DIF_REGISTER_COINSTALLERS,
                        hdi, pdeid);

                if (S_OK == hr)
                {
                    hr = HrSetupDiCallClassInstaller (DIF_INSTALLINTERFACES,
                            hdi, pdeid);

                    if (S_OK == hr)
                    {
                        hr = HrSetupDiCallClassInstaller (DIF_INSTALLDEVICE,
                                hdi, pdeid);
                    }
                }
            }
        }

        // If we failed for any reason, we need to clean up since
        // we initiated this install.
        if (FAILED(hr))
        {
            ADAPTER_REMOVE_PARAMS arp;
            arp.fBadDevInst = TRUE;
            arp.fNotifyINetCfg = FALSE;

            CiSetReservedField (hdi, pdeid, &arp);
            HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, pdeid);
            CiClearReservedField (hdi, pdeid);

        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiCallClassInstallerToInstallComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiInstallComponent
//
//  Purpose:    This function takes a Network Component's Id and its class
//              guid and gathers the information needed by
//              HrCiInstallComponent. Since it is called from INetCfg, we
//              have the write lock
//
//  Arguments:
//      Params [in] Component install params. See install.h
//      ppComponent [out] A created CComponent representing the installed
//                        component.
//      pdwNewCharacter [out] Optional pointer to a DWORD to receive the
//                            characteristics of the component.
//
//  Returns:    HRESULT. S_OK is successful, NETCFG_S_REBOOT if a reboot is
//                      needed to start the device, or an error code
//
//  Author:     billbe   16 Mar 1997
//
//  Notes:
//
HRESULT
HrCiInstallComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent,
    OUT DWORD* pdwNewCharacter)
{
    Assert (FIsValidNetClass (Params.Class));
    Assert (Params.pszInfId && *Params.pszInfId);
    Assert (!Params.pComponent);

    HRESULT hr = S_OK;
    HDEVINFO hdi = NULL;
    SP_DEVINFO_DATA deid;
    const GUID* pguidClass = MAP_NETCLASS_TO_GUID[Params.Class];

    if (ppComponent)
    {
        *ppComponent = NULL;
    }
    if (pdwNewCharacter)
    {
        *pdwNewCharacter = 0;
    }

    // If we're about to install the component, it better not be in
    // lockdown.
    //
    Assert (!FIsComponentLockedDown (Params.pszInfId));

    // First create a device info set
    hr = HrSetupDiCreateDeviceInfoList (pguidClass, NULL, &hdi);

    if (S_OK == hr)
    {
        // This will create an node in the enum tree for this component.
        // If it is enumerated, we will register it which will make
        // it persist.  If non-enumerated, we will not register it and
        // the node will be deleted in the call to SetDiDestroyDeviceInfoList.
        //
        hr = HrCiGetDriverInfo (hdi, &deid, *pguidClass,
                Params.pszInfId, Params.pszInfFile);

        // Get the driver info for the component
        if (S_OK == hr)
        {
            BASIC_COMPONENT_DATA Data = {0};
            Data.Class = Params.Class;
            Data.pszInfId = Params.pszInfId;

            if (FIsEnumerated (Params.Class))
            {
                // If the component is enumerated, we will need a place to
                // store its pnp id.
                WCHAR szPnpId[MAX_DEVICE_ID_LEN];
                ADAPTER_OUT_PARAMS AdapterOutParams;

                ZeroMemory (&AdapterOutParams, sizeof(AdapterOutParams));

                // Net class components have to go through the device
                // installer hook (aka NetClassInstaller)
                //

                if (FInSystemSetup())
                {
                    // if we are in GUI mode we need to make the
                    // device install quiet and always copy from
                    // the source location even if the files are
                    // already present. We also need to set
                    // the in system setup flag.  This is what
                    // syssetup would do if it initiated the install
                    // so INetCfg initiated installs must do the same.
                    //
                    // We should also set the parent hwnd.
                    //

                    SP_DEVINSTALL_PARAMS deip;
                    HRESULT hrTemp = HrSetupDiGetDeviceInstallParams (
                            hdi, &deid, &deip);

                    if (S_OK == hr)
                    {
                        deip.hwndParent = Params.hwndParent;
                        deip.Flags |= DI_QUIETINSTALL | DI_FORCECOPY;
                        deip.FlagsEx |= DI_FLAGSEX_IN_SYSTEM_SETUP;

                        hrTemp = HrSetupDiSetDeviceInstallParams (
                                hdi, &deid, &deip);
                    }

                    TraceHr (ttidError, FAL, hrTemp, FALSE, "Error "
                            "getting and setting device params.");
                }

                CiSetReservedField (hdi, &deid, &AdapterOutParams);

                // Officially call the class installer to install
                // this device
                //
                hr = HrCiCallClassInstallerToInstallComponent (hdi, &deid);

                CiClearReservedField (hdi, &deid);

                Data.dwCharacter = AdapterOutParams.dwCharacter;
                Data.InstanceGuid = AdapterOutParams.InstanceGuid;

                if (S_OK == hr)
                {
                    hr = HrSetupDiGetDeviceInstanceId (hdi, &deid, szPnpId,
                            MAX_DEVICE_ID_LEN, NULL);

                    if (S_OK == hr)
                    {
                        Data.pszPnpId = szPnpId;
                    }
                }
            }
            else // Non-net class components
            {
                COMPONENT_INSTALL_INFO cii;
                PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
                SP_DRVINFO_DATA drid;

                // Now get the driver's detailed information
                hr = HrCiGetDriverDetail (hdi, &deid, &drid, &pdridd);

                if (S_OK == hr)
                {
                    ZeroMemory (&cii, sizeof(cii));
                    cii.Class = Params.Class;
                    cii.pszInfId = Params.pszInfId;
                    cii.pszInfFile = pdridd->InfFileName;
                    cii.hwndParent = Params.hwndParent;
                    cii.pszDescription = drid.Description;
                    cii.pszSectionName = pdridd->SectionName;

                    HINF hinf;
                    hr = HrSetupOpenInfFile (pdridd->InfFileName, NULL,
                            INF_STYLE_WIN4, NULL, &hinf);

                    if (S_OK == hr)
                    {
                        // Make sure this is an NT5 inf network inf
                        //
                        hr = HrSetupIsValidNt5Inf (hinf);
                        SetupCloseInfFile (hinf);
                    }

                    if (S_OK == hr)
                    {
                        hr = HrCiInstallComponentInternal (&cii);
                        if (S_OK == hr)
                        {
                            Data.InstanceGuid = cii.InstanceGuid;
                            Data.dwCharacter = cii.dwCharacter;
                        }
                    }
                    MemFree (pdridd);
                }
            }

            if ((S_OK == hr) && ppComponent) // !previously installed
            {
                CComponent* pComponent;

                hr = CComponent::HrCreateInstance (
                        &Data,
                        CCI_ENSURE_EXTERNAL_DATA_LOADED,
                        Params.pOboToken,
                        &pComponent);

                if (S_OK == hr)
                {
                    *ppComponent = pComponent;
                }
            }

            if ((S_OK == hr) && pdwNewCharacter)
            {
                *pdwNewCharacter = Data.dwCharacter;
            }
        }

        SetupDiDestroyDeviceInfoList(hdi);
    }


#ifdef ENABLETRACE
    if (S_OK == hr)
    {
        TraceTag(ttidClassInst, "Component now installed!");
    }
#endif //ENABLETRACE

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrCiInstallComponent (%S)", Params.pszInfId);
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   SetBadDriverFlagIfNeededInList
//
//  Purpose: Enumerates a driver list setting the DNF_BAD_DRIVER flag
//           in every node that has a DNF_EXCLUDEFROMLIST flag.
//
//  Arguments:
//      hdi      [in] See Device Installer Api documentaion for details
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   24 Nov 1998
//
//  Notes: SetupDi forces us to use the DNF_BAD_DRIVER flag for non-netdevice
//         classes if we want to exclude them from the select device dialog.
//         This means to non-netclass components that
//         DNF_BAD_DRIVER = DNF_EXCLUDEFROMLIST.
//
VOID
SetBadDriverFlagIfNeededInList(HDEVINFO hdi)
{
    Assert(IsValidHandle(hdi));

    HRESULT                 hr = S_OK;
    SP_DRVINSTALL_PARAMS    drip;
    SP_DRVINFO_DATA         drid;
    DWORD                   dwIndex = 0;

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        hr = HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

        if (S_OK == hr)
        {
            // If the driver already has the bad driver flag set,
            // go on to the next one.
            if (drip.Flags & DNF_BAD_DRIVER)
            {
                continue;
            }

            // If the driver has the exclude flag set, then set the
            // bad driver flag.
            if (drip.Flags & DNF_EXCLUDEFROMLIST)
            {
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams(hdi, NULL, &drid,
                        &drip);
            }
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "SetBadDriverFlagIfNeededInList");
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiExcludeNonNetClassDriverFromSelectUsingInfId
//
//  Purpose: Locates a driver in a driver list and sets its exclude from
//              select flag.
//
//  Arguments:
//      hdi      [in] See Device Installer Api documentaion for details
//      pszInfId [in] The INF id of the component to exclude
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   29 Oct 1998
//
//  Notes:
//
HRESULT
HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId)
{
    Assert(IsValidHandle(hdi));
    Assert(pszInfId);

    HRESULT                 hr = S_OK;
    SP_DRVINSTALL_PARAMS    drip;
    SP_DRVINFO_DATA         drid;
    PSP_DRVINFO_DETAIL_DATA pdridd;
    DWORD                   dwIndex = 0;

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo (hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        (VOID) HrSetupDiGetDriverInstallParams (hdi, NULL, &drid, &drip);

        // If the driver is already excluded for some other reason
        // don't bother trying to determine if it should be excluded.
        // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
        // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
        if (drip.Flags & DNF_BAD_DRIVER)
        {
            continue;
        }

        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail (hdi, NULL, &drid, &pdridd);

        if (S_OK == hr)
        {
            // If the IDs match, exclude it from the dialog
            //
            if (0 == lstrcmpiW (pdridd->HardwareID, pszInfId))
            {
                // Non-device drivers can't use DNF_EXCLUDEFROMLIST
                // and must use DNF_BAD_DRIVER.
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams (hdi, NULL,
                        &drid, &drip);
            }
            MemFree (pdridd);
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrCiExcludeNonNetClassDriverFromSelectUsingInfId");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   ExcludeLockedDownComponents
//
//  Purpose:    A callback function compatible with EnumLockedDownComponents
//              that is used to exclude locked down components from
//              selection.  Called from HrCiPrepareSelectDeviceDialog.
//              This call back is called for each locked down component.
//
//  Arguments:
//      pszInfId     [in] the INF ID to exclude.
//      pvCallerData [in] the HDEVINFO cast to PVOID
//
//  Returns:    nothing
//
//  Author:     shaunco   24 May 1999
//
//  Notes:      The callback interface was chosen so that the class installer
//              is not burdended with the details of how/where the locked
//              down components are implemented.
//
VOID
CALLBACK
ExcludeLockedDownComponents (
    IN PCWSTR pszInfId,
    IN PVOID pvCallerData)
{
    Assert (pszInfId && *pszInfId);
    Assert (pvCallerData);

    HDEVINFO hdi = (HDEVINFO)pvCallerData;

    HrCiExcludeNonNetClassDriverFromSelectUsingInfId (hdi, pszInfId);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiBuildExcludedDriverList
//
//  Purpose: Non-Net class components can only be installed once
//              So we need to iterate through the installed
//              components, find their matching driver node in
//              a Device Installer Api built driver list for the class,
//              and set their exclude from select flag.  This list
//              will then be given to SetupDiSelectDevice which
//              will not display the nodes with the exclude flag set.
//
//  Arguments:
//      hdi       [in] See Device Installer Api documentaion for details
//      guidClass [in] The class of components to build a driver list for
//      pNetCfg   [out] The current network configuration (i.e. what is
//                      installed).
//
//  Returns:    HRESULT. S_OK
//
//  Author:     billbe   10 Dec 1996
//
//  Notes:  Device Installer Api builds the driver list by rummaging
//              through the inf directory and finding the components
//              that are in files with the same class guid as the
//              HDEVINFO.  This is the same processing done
//              in SetupDiSelectDevice, but the process is
//              not repeated twice because we will give the
//              list we built here to SetupDiSelectDevice.
//
HRESULT
HrCiBuildExcludedDriverList(
    IN HDEVINFO hdi,
    IN NETCLASS Class,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;

    Assert(IsValidHandle(hdi));
    Assert(pNetConfig);

    // This might take some time.  We are doing the same work as
    // SetupDiSelectDevice would do. When we are done, we will
    // hand the driver list to SetupDiSelectDevice so it won't
    // need to rummage through the inf directory
    //
    CWaitCursor wc;

    // For non-device classes, we need to allow excluded drivers
    // in order to get a list returned.
    hr = HrSetupDiSetDeipFlags(hdi, NULL,
                    DI_FLAGSEX_ALLOWEXCLUDEDDRVS,
                    SDDFT_FLAGSEX, SDFBO_OR);

    if (S_OK == hr)
    {
#ifdef ENABLETRACE
        CBenchmark bmrk;
        bmrk.Start("SetupDiBuildDriverInfoList");
#endif //ENABLETRACE

        hr = HrSetupDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER);

#ifdef ENABLETRACE
        bmrk.Stop();
        TraceTag(ttidBenchmark, "%s : %s seconds",
                bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
#endif //ENABLETRACE
    }

    // Go through the network configuration and hide already installed
    // components.  Note: We only do this the first time.  We show installed
    // components if the user selects Have Disk on the dialog.
    CComponent* pComponent;
    CComponentList::const_iterator iter;

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (Class == pComponent->Class())
        {
            // Hide the driver
            hr = HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
                    hdi, pComponent->m_pszInfId);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiBuildExcludedDriverList");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiSelectComponent
//
//  Purpose:    This function displays the Select Device dialog for the
//              class of components specified by guidClass.  Once the
//              component has been selected, it is installed.. Since
//              this fcn is called from INetCfg, we have the write lock.
//
//  Arguments:
//      Class           [in] The class of components to display in the
//                              Select Device dialog
//      hwndParent      [in] The HWND of the parent window, used to display
//                              the UI
//      pcfi            [in] A structure used to determine what
//                              components should be filtered out of
//                              the select dialog (defined in netcfg.h)
//      ppParams        [out] Params used to install the component.
//
//  Returns:    HRESULT. S_OK if successful, S_FALSE if the component
//                        selected is being reinstalled instead of fresh
//                        installed, an error code otherwise
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:  Filtering is only performed when selecting protocols,
//              services, and clients.
//
HRESULT
HrCiSelectComponent(
    IN NETCLASS Class,
    IN HWND hwndParent,
    IN const CI_FILTER_INFO* pcfi,
    OUT COMPONENT_INSTALL_PARAMS** ppParams)
{
    Assert (ppParams);
    Assert (!FIsEnumerated (Class));

    HRESULT hr;
    HDEVINFO hdi;

    // We need to create a DeviceInfoSet item to use the SelectDevice dialog.
    hr = HrSetupDiCreateDeviceInfoList(
            MAP_NETCLASS_TO_GUID[Class], hwndParent, &hdi);

    if (S_OK == hr)
    {
        // call the class installer to bring up the select device dialog
        // for enumerated components.  This will notify any coinstallers
        //

        // This will be a map of component ids to instance guids
        // for all installed components of Class.
        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            hr = HrCiBuildExcludedDriverList (hdi, Class, &NetConfig);
        }

        if (S_OK == hr)
        {
            // Store the filter info in the hdi
            CiSetReservedField(hdi, NULL, pcfi);

            // We want the Have disk button, but if the call fails we can
            // still continue
            (VOID) HrSetupDiSetDeipFlags(hdi, NULL, DI_SHOWOEM,
                                         SDDFT_FLAGS, SDFBO_OR);

            // Bring up the dialog
            hr = HrSetupDiCallClassInstaller(DIF_SELECTDEVICE, hdi, NULL);

            if (S_OK == hr)
            {
                SP_DRVINFO_DATA drid;
                PSP_DRVINFO_DETAIL_DATA pdridd;

                // Now get the driver's detailed information
                hr = HrCiGetDriverDetail (hdi, NULL, &drid, &pdridd);

                if (S_OK == hr)
                {
                    DWORD cbInfId = CbOfSzAndTerm(pdridd->HardwareID);
                    DWORD cbInfFile = CbOfSzAndTerm(pdridd->InfFileName);

                    // Create a component install params structure so we
                    // can install the component.
                    hr = E_OUTOFMEMORY;
                    *ppParams = new (extrabytes, cbInfId + cbInfFile)
                            COMPONENT_INSTALL_PARAMS;

                    if (*ppParams)
                    {
                        ZeroMemory (*ppParams,
                                sizeof (COMPONENT_INSTALL_PARAMS));

                        (*ppParams)->Class = Class;
                        (*ppParams)->hwndParent = hwndParent;
                        (*ppParams)->pszInfId = (PCWSTR)(*ppParams + 1);
                        wcscpy ((PWSTR)(*ppParams)->pszInfId,
                                pdridd->HardwareID);

                        (*ppParams)->pszInfFile =
                                (PCWSTR)((BYTE*)(*ppParams)->pszInfId +
                                         cbInfId);

                        wcscpy ((PWSTR)(*ppParams)->pszInfFile,
                                pdridd->InfFileName);

                        hr = S_OK;
                    }
                    MemFree (pdridd);
                }
            }

            // Clear the field so we don't try to destroy it later
            // via DIF_DESTROYPRIVATEDATA
            CiClearReservedField(hdi, NULL);
        }
        SetupDiDestroyDeviceInfoList(hdi);
    }

    TraceHr (ttidError, FAL, hr, HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr,
            "HrCiSelectComponent");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiHideIrrelevantRasProtocols
//
//  Purpose:    Hides protocols from the SelectDevice dialog that RAS does
//                  not interact with.
//
//  Arguments:
//      hdi        [in] Contains a list of available drivers.
//                          See Device Installer Api documentation for
//                          more info
//      eFilter    [in] Either FC_RASSRV or FC_RASCLI.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   18 May 1998
//
//  Notes:
//
HRESULT
HrCiHideIrrelevantRasProtocols (
    IN HDEVINFO hdi,
    IN CI_FILTER_COMPONENT eFilter)
{
    DWORD                   dwIndex = 0;
    SP_DRVINFO_DATA         drid;
    SP_DRVINSTALL_PARAMS    drip;
    PSP_DRVINFO_DETAIL_DATA pdridd;
    HRESULT                 hr;

    extern const WCHAR c_szInfId_MS_AppleTalk[];
    extern const WCHAR c_szInfId_MS_NetMon[];
    extern const WCHAR c_szInfId_MS_NWIPX[];
    extern const WCHAR c_szInfId_MS_TCPIP[];

    static const WCHAR* const c_aszServerProtocols[] = {
        c_szInfId_MS_AppleTalk,
        c_szInfId_MS_NetMon,
        c_szInfId_MS_NWIPX,
        c_szInfId_MS_TCPIP
    };

    static const WCHAR* const c_aszClientProtocols[] = {
        c_szInfId_MS_NetMon,
        c_szInfId_MS_NWIPX,
        c_szInfId_MS_TCPIP
    };

    Assert ((FC_RASSRV == eFilter) || (FC_RASCLI == eFilter));

    const WCHAR* const* aszProtocols;
    DWORD cProtocols;

    // What we show as available protocols to install differs between
    // ras server and ras client (aka Incoming connectoid and Dial-up).
    //
    if (FC_RASSRV == eFilter)
    {
        aszProtocols = c_aszServerProtocols;
        cProtocols = celems(c_aszServerProtocols);

    }
    else
    {
        aszProtocols = c_aszClientProtocols;
        cProtocols = celems(c_aszClientProtocols);
    }

    // Enumerate each driver in hdi
    while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
            SPDIT_CLASSDRIVER, dwIndex++, &drid)))
    {
        (VOID) HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

        // If the driver is already excluded for some other reason
        // don't bother trying to determine if it should be excluded
        // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
        // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
        if (drip.Flags & DNF_BAD_DRIVER)
        {
            continue;
        }

        // Get driver detail info
        hr = HrSetupDiGetDriverInfoDetail(hdi, NULL, &drid, &pdridd);

        if (S_OK == hr)
        {
            // go through the list of relevant protocols to find which
            // ones can be shown
            //

            // Assume we are going to hide this protocol
            BOOL fHideProtocol = TRUE;
            for (DWORD i = 0; i < cProtocols; i++)
            {
                // If the protocol is on the guest list, we won't boot
                // it out
                //
                if (0 == _wcsicmp(aszProtocols[i], pdridd->HardwareID))
                {
                    fHideProtocol = FALSE;
                }
            }

            if (fHideProtocol)
            {
                // exclude from select
                // Note that setupdi forces us to use DNF_BAD_DRIVER to
                // exclude non-device drivers rather than using
                // DNF_EXCLUDEFROMLIST.
                drip.Flags |= DNF_BAD_DRIVER;
                (VOID) HrSetupDiSetDriverInstallParams(hdi, NULL,
                        &drid, &drip);
            }
            MemFree (pdridd);
        }
    }

    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiHideIrrelevantRasProtocols");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiHideIrrelevantDrivers
//
//  Purpose:    Enumerates a driver list, opening each driver file and
//                  processing its registry entries into a temporary key.
//                  The lower range of each driver is then examined for
//                  a match with pszUpperRange.  If no match is
//                  found, the driver's DNF_BAD_DRIVER flag is set
//                  which will prevent it from being shown in the
//                  Select Device Dialog
//
//  Arguments:
//      hdi           [in] Contains a list of available drivers.
//                          See Device Installer Api documentation for
//                          more info
//      pszUpperRange [in] The upper range will be used to hide irrelevant
//                         drivers.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   7 May 1998
//
//  Notes:
//
HRESULT
HrCiHideIrrelevantDrivers(
    IN HDEVINFO hdi,
    IN PCWSTR pszUpperRange)
{
    Assert(IsValidHandle(hdi));
    Assert(pszUpperRange);

    // Create a temporary key so we can process each protocol's
    // registry entries in an effort to get its supported
    // lower range of interfaces
    HKEY hkeyTemp;
    HRESULT hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyTemp,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkeyTemp, NULL);

    if (S_OK == hr)
    {
        DWORD                   dwIndex = 0;
        SP_DRVINFO_DATA         drid;
        SP_DRVINSTALL_PARAMS    drip;
        HKEY                    hkeyInterfaces;

        // Enumerate each driver in hdi
        while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
                SPDIT_CLASSDRIVER, dwIndex++, &drid)))
        {
            (VOID) HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

            // If the driver is already excluded for some other reason
            // don't bother trying to determine if it should be exluded.
            // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
            // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
            if (drip.Flags & DNF_BAD_DRIVER)
            {
                continue;
            }

            // Get driver detail info
            PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
            hr = HrSetupDiGetDriverInfoDetail(hdi, NULL, &drid, &pdridd);

            if (S_OK == hr)
            {
                HINF hinf = NULL;
                // Open the driver inf
                hr = HrSetupOpenInfFile(pdridd->InfFileName,
                        NULL, INF_STYLE_WIN4, NULL, &hinf);

                WCHAR szActual[_MAX_PATH];
                if (S_OK == hr)
                {
                    // Get the actual install section name (i.e. with
                    // os/platform extension if it exists)
                    hr = HrSetupDiGetActualSectionToInstallWithBuffer (hinf,
                            pdridd->SectionName, szActual, _MAX_PATH, NULL,
                            NULL);

                    if (S_OK == hr)
                    {
                        // Run the registry sections into the temporary key
                        hr = HrCiInstallFromInfSection(hinf, szActual,
                                hkeyTemp, NULL, SPINST_REGISTRY);
                    }
                }

                if (S_OK == hr)
                {
                    // Open the interfaces key of the driver
                    hr = HrRegOpenKeyEx(hkeyTemp, L"Ndi\\Interfaces",
                            KEY_ALL_ACCESS, &hkeyInterfaces);

                    if (S_OK == hr)
                    {
                        PWSTR pszLowerRange = NULL;

                        // Read the lower interfaces value.
                        //
                        hr = HrRegQuerySzWithAlloc (hkeyInterfaces,
                                L"LowerRange", &pszLowerRange);

                        // If we succeeded in reading the list and
                        // there is no match with one of the upper
                        // interfaces...
                        if ((S_OK == hr) &&
                                !FSubstringMatch (pszUpperRange,
                                        pszLowerRange, NULL, NULL))
                        {
                            // exclude from select
                            drip.Flags |= DNF_BAD_DRIVER;
                            (VOID) HrSetupDiSetDriverInstallParams(hdi,
                                    NULL, &drid, &drip);
                        }

                        // Clear lower interface list for next component
                        MemFree(pszLowerRange);

                        RegDeleteValue (hkeyInterfaces, L"LowerRange");
                        RegCloseKey(hkeyInterfaces);
                    }
                }
                SetupCloseInfFileSafe(hinf);
                MemFree (pdridd);
            }
        }

        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey(hkeyTemp);
        HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyTemp);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiHideIrrelevantDrivers");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiHideIrrelevantFilterServices
//
//  Purpose:    Enumerates a driver list, opening each driver file and
//              processing its registry entries into a temporary key.
//              Only filter services are filtered here. If the component is
//              a filter service (characteristics|NCF_FILTER)
//              the FilterMediaTypes and the LowerExclude attributes are examined
//              to see if the filter service can bind to the adapter. The filter 
//              services which cannot bind to the adapter are culled from  
//              the select dialog
//
//  Arguments:
//      hdi           [in] Contains a list of available drivers.
//                         See Device Installer Api documentation for
//                         more info
//      pAdapter      [in] Pointer to a CComponent object representing the
//                         adapter for which filter services are to be hidden.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     sumeetb  October 17, 2001
//
//  Notes:
//
HRESULT
HrCiHideIrrelevantFilterServices(
    IN HDEVINFO hdi,
    IN const CComponent * const pAdapter)
{
    Assert(IsValidHandle(hdi));
    Assert(pAdapter);

    // Create a temporary key so we can process each filter's
    // registry entries in an effort to get its FilterMediaTypes and
    // LowerExclude attributes

    HKEY hkeyTemp;
    HRESULT hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyTemp,
            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
            &hkeyTemp, NULL);

    if (S_OK == hr)
    {
        DWORD                   dwIndex = 0;
        SP_DRVINFO_DATA         drid;
        SP_DRVINSTALL_PARAMS    drip;
        HKEY                    hkeyInterfaces;

        // Enumerate each driver in hdi
        while (S_OK == (hr = HrSetupDiEnumDriverInfo(hdi, NULL,
                SPDIT_CLASSDRIVER, dwIndex++, &drid)))
        {
            BOOL fCanBind = TRUE;

            (VOID) HrSetupDiGetDriverInstallParams(hdi, NULL, &drid, &drip);

            // If the driver is already excluded for some other reason
            // don't bother trying to determine if it should be excluded.
            // Note that setupdi forces us to use DNF_BAD_DRIVER to exclude
            // non-device drivers rather than using DNF_EXCLUDEFROMLIST.
            if (drip.Flags & DNF_BAD_DRIVER)
            {
                continue;
            }

            // Get driver detail info
            PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
            hr = HrSetupDiGetDriverInfoDetail(hdi, NULL, &drid, &pdridd);

            if (S_OK == hr)
            {
                HINF hinf = NULL;
                // Open the driver inf
                hr = HrSetupOpenInfFile(pdridd->InfFileName,
                        NULL, INF_STYLE_WIN4, NULL, &hinf);

                if (S_OK == hr)
                {
                    WCHAR szActual[_MAX_PATH];
                    // Get the actual install section name (i.e. with
                    // os/platform extension if it exists)
                    hr = HrSetupDiGetActualSectionToInstallWithBuffer (hinf,
                            pdridd->SectionName, szActual, _MAX_PATH, NULL,
                            NULL);

                    if (S_OK == hr)
                    {
                        DWORD dwCharacteristics = 0;

                        hr = HrSetupGetFirstDword (hinf, szActual, 
                                L"Characteristics", &dwCharacteristics);
                        
                        if (S_OK == hr )
                        {
                            if (dwCharacteristics & NCF_FILTER)
                            {
                                // it is a filter. 
                                // Run the registry sections into the temporary key
                                hr = HrCiInstallFromInfSection(hinf, szActual,
                                        hkeyTemp, NULL, SPINST_REGISTRY);
                                
                                if (S_OK == hr)
                                {
                                    hr = HrRegOpenKeyEx(hkeyTemp, L"Ndi\\Interfaces", 
                                            KEY_ALL_ACCESS, &hkeyInterfaces);
                                
                                    if (S_OK == hr)
                                    {
                                        // check filter attributes - FilterMediaTypes and
                                        // LowerExclude to see if the filter can bind to 
                                        // the adapter

                                        PWSTR pszFilterMediaTypes = NULL;
                                        PWSTR pszLowerExclude     = NULL;

                                        (VOID) HrRegQuerySzWithAlloc (hkeyInterfaces,
                                           L"FilterMediaTypes", &pszFilterMediaTypes);
                                        (VOID) HrRegQuerySzWithAlloc (hkeyInterfaces,
                                           L"LowerExclude", &pszLowerExclude);

                                        fCanBind = pAdapter->FCanDirectlyBindToFilter(
                                                      pszFilterMediaTypes,
                                                      pszLowerExclude);

                                        MemFree(pszFilterMediaTypes);
                                        MemFree(pszLowerExclude);

                                        // clean up the relevant keys from the 
                                        // registry for the filter
                                        RegDeleteValue (hkeyInterfaces, L"FilterMediaTypes");
                                        RegDeleteValue (hkeyInterfaces, L"LowerExclude");
                                        RegCloseKey(hkeyInterfaces);
                                    }   // end open Interface key
                                }       // end install from inf section
                            }           // end if filter
                        }               // end get Characteristics
                    }                   // end get actual install section.
                    SetupCloseInfFileSafe(hinf);
                }   // end open inf file
                
                if (!fCanBind)
                {
                    drip.Flags |= DNF_BAD_DRIVER;
                    (VOID) HrSetupDiSetDriverInstallParams(hdi, NULL, &drid, &drip);
                }
                MemFree (pdridd);
            }   // end get driver detail
        }       // end while
        
        if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
        {
            hr = S_OK;
        }
        RegCloseKey(hkeyTemp);
        HrRegDeleteKeyTree(HKEY_LOCAL_MACHINE, c_szRegKeyTemp);
    }   // end create temp key
    TraceHr (ttidError, FAL, hr, FALSE, "HrCiHideIrrelevantFilterServices");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiSetSelectDeviceDialogStrings
//
//  Purpose:    This function sets the strings displayed in the Select Device
//                  dialog based on the class of devices being selected.
//
//  Arguments:
//      hdi         [in] See Device Installer Api
//      pdeid       [in]
//      guidClass   [in] The class of device being selected
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:
//
HRESULT
HrCiSetSelectDeviceDialogStrings(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid,
    IN const GUID& guidClass)
{
    Assert(IsValidHandle(hdi));

    SP_SELECTDEVICE_PARAMS  sdep;

    // The strings used in the dialog are specified through the
    // SP_SELECTDEVICE_PARAMS structure
    //
    HRESULT hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
           (PSP_CLASSINSTALL_HEADER)&sdep, sizeof(sdep));

    if (FAILED(hr))
    {
        // If the error is ERROR_NO_CLASSINSTALL_PARAMS then this function
        // didn't really fail since it is possible
        if (SPAPI_E_NO_CLASSINSTALL_PARAMS == hr)
        {
            hr = S_OK;
        }
    }
    else if (DIF_SELECTDEVICE != sdep.ClassInstallHeader.InstallFunction)
    {
        TraceTag(ttidClassInst, "Incorrect function in Class Install Header "
                 "Expected DIF_SELECTDEVICE, got %lX",
                 sdep.ClassInstallHeader.InstallFunction);
    }


    BOOL fHaveDiskShown = FALSE;
    if (S_OK == hr)
    {
        // Get the install params and check if the DI_SHOWOEM flag is set
        // if so, the Have Disk button will be shown
        //
        SP_DEVINSTALL_PARAMS deip;
        // If the call fails we can still go on unfazed.
        (VOID) HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        if (deip.Flags & DI_SHOWOEM)
        {
            fHaveDiskShown = TRUE;
        }

        // Now we set the strings based on the type of component we are
        // selecting
        if (GUID_DEVCLASS_NETCLIENT == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICECLIENTTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICECLIENTLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICECLIENTINSTRUCTIONS));

        }
        else if (GUID_DEVCLASS_NETSERVICE == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICESERVICETITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICESERVICELISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICESERVICEINSTRUCTIONS));

        }
        else if (GUID_DEVCLASS_NETTRANS == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEPROTOCOLTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEPROTOCOLLISTLABEL));

            wcscpy (sdep.Instructions,
                SzLoadIds (IDS_SELECTDEVICEPROTOCOLINSTRUCTIONS));
        }
        else if (GUID_DEVCLASS_NET == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEADAPTERTITLE));

            wcscpy (sdep.SubTitle,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERSUBTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICEADAPTERINSTRUCTIONS));
        }
        else if (GUID_DEVCLASS_INFRARED == guidClass)
        {
            wcscpy (sdep.Title, SzLoadIds (IDS_SELECTDEVICEINFRAREDTITLE));

            wcscpy (sdep.SubTitle,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDSUBTITLE));

            wcscpy (sdep.ListLabel,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDLISTLABEL));

            wcscpy (sdep.Instructions,
                    SzLoadIds (IDS_SELECTDEVICEINFRAREDINSTRUCTIONS));
        }
        else
        {
            // We should never get here
            AssertSz(FALSE, "Invalid Class");
        }

        // If the Have Disk button is shown, we need to add instructions for
        // it
        if (fHaveDiskShown)
        {
            wcscat (sdep.Instructions, SzLoadIds (IDS_HAVEDISK_INSTRUCTIONS));
        }

        sdep.ClassInstallHeader.InstallFunction = DIF_SELECTDEVICE;

        // Now we update the parameters.
        hr = HrSetupDiSetClassInstallParams (hdi, pdeid,
                (PSP_CLASSINSTALL_HEADER)&sdep,
                sizeof(SP_SELECTDEVICE_PARAMS));
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiSetSelectDeviceDialogStrings");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiPrepareSelectDeviceDialog
//
//  Purpose:    Sets the strings that will appear in the Select Device
//                  dialog based on class type.  Also, filters out components
//                  based on filtering criteria (note: only for non-net
//                  class components
//
//  Arguments:
//      hdi    [in] See Device Installer Api documentation for more info
//      pdeid  [in]
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   26 Jun 1997
//
//  Notes:
//
HRESULT
HrCiPrepareSelectDeviceDialog(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));

    GUID                guidClass;
    CI_FILTER_INFO*     pcfi;
    HRESULT             hr = S_OK;
    static const WCHAR  c_szNetwareInfId[] = L"MS_NwClient";
    static const WCHAR  c_szQosInfId[] = L"MS_PSched";

    if (pdeid)
    {
        // Get the class guid from the specified device element
        guidClass = pdeid->ClassGuid;
    }
    else
    {
        // otherwise, get it from the hdi
        hr = HrSetupDiGetDeviceInfoListClass (hdi, &guidClass);
    }

    if ((S_OK == hr) && !FIsEnumerated (guidClass))
    {
        // This might take some time.  We are doing the same work as
        // SetupDiSelectDevice would do. When we are done, we will
        // hand the driver list to SetupDiSelectDevice so it won't
        // need to rummage through the inf directory
        //
        CWaitCursor wc;

        // For non-device classes, we need to allow excluded drivers
        // in order to get a list returned.
        hr = HrSetupDiSetDeipFlags(hdi, NULL,
                        DI_FLAGSEX_ALLOWEXCLUDEDDRVS,
                        SDDFT_FLAGSEX, SDFBO_OR);

        if (S_OK == hr)
        {
    #ifdef ENABLETRACE
            CBenchmark bmrk;
            bmrk.Start("SetupDiBuildDriverInfoList");
    #endif //ENABLETRACE

            // If we have already built a driver list, this will return
            // immediately.
            //
            hr = HrSetupDiBuildDriverInfoList(hdi, NULL, SPDIT_CLASSDRIVER);

    #ifdef ENABLETRACE
            bmrk.Stop();
            TraceTag(ttidBenchmark, "%s : %s seconds",
                    bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
    #endif //ENABLETRACE
        }

        if (S_OK == hr)
        {
            // Go through every driver node and set DNF_BAD_DRIVER
            // if DNF_EXCLUDEFROMLIST is set. Note: SetupDi forces us
            // to do this for non netclass driver lists.
            SetBadDriverFlagIfNeededInList(hdi);

            // Exclude components that are in lockdown.
            //
            EnumLockedDownComponents (ExcludeLockedDownComponents, hdi);

            SP_DEVINSTALL_PARAMS deip;
            hr = HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);

            if (S_OK == hr)
            {
                pcfi = (CI_FILTER_INFO*)deip.ClassInstallReserved;

                // if filter info was present and we are selecting protocols...
                if (pcfi)
                {
                    if (GUID_DEVCLASS_NETTRANS == guidClass)
                    {
                        // If the filter is for lan or atm and pvReserved is
                        // not null...
                        if (((FC_LAN == pcfi->eFilter) ||
                             (FC_ATM == pcfi->eFilter))
                             && pcfi->pvReserved)
                        {
                            // Hide any drivers that can't bind to pvReserved
                            hr = HrCiHideIrrelevantDrivers(hdi,
                                    (PCWSTR)((CComponent *)pcfi->pvReserved)->Ext.PszUpperRange());

                        }
                        else if ((FC_RASSRV == pcfi->eFilter) ||
                                (FC_RASCLI == pcfi->eFilter))
                        {
                            // Hide from the select dialog any protocols RAS does
                            // not support
                            hr = HrCiHideIrrelevantRasProtocols (hdi,
                                    pcfi->eFilter);
                        }
                    }
                    else if ((GUID_DEVCLASS_NETCLIENT == guidClass) &&
                            (FC_ATM == pcfi->eFilter))
                    {
                        // ATM adapters don't bind to Netware Client so
                        // we need to try to hide it from the dialog
                        (VOID) HrCiExcludeNonNetClassDriverFromSelectUsingInfId(
                                hdi, c_szNetwareInfId);
                    }
                    else if ((GUID_DEVCLASS_NETSERVICE == guidClass) &&
                             (pcfi->pvReserved))
                    {
                        // Hide any filters that can't bind to this adapter
                        hr = HrCiHideIrrelevantFilterServices(hdi,
                                    (CComponent *)pcfi->pvReserved);
                    }
                }
            }
        }
    }

    if (S_OK == hr)
    {

        // Set the strings for the Select Device dialog.
        // This is done by changing the parameters in the DeviceInfoSet.
        // The next call will create this InfoSet
        // If the call fails, we can still go on, we'll just have
        // slightly odd descriptions in the dialog.  This is done after
        // the section above because strings change based on the existence
        // of the Have Disk button
        (VOID) HrCiSetSelectDeviceDialogStrings(hdi, pdeid, guidClass);

        // Now we need to indicate that we created a class install params
        // header in the structures and set the select device dialog strings
        // in it.  If the call fails, we can still proceed though the
        // dialog will appear a bit strange
        (VOID) HrSetupDiSetDeipFlags(hdi, pdeid,
                              DI_USECI_SELECTSTRINGS | DI_CLASSINSTALLPARAMS,
                              SDDFT_FLAGS, SDFBO_OR);
    }


    TraceHr (ttidError, FAL, hr, FALSE, "HrCiPrepareSelectDeviceDialog");
    return hr;
}

HRESULT
HrCiInstallFilterDevice (
    IN HDEVINFO hdi,
    IN PCWSTR pszInfId,
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN CFilterDevice** ppFilterDevice)
{
    HRESULT hr;
    SP_DEVINFO_DATA deid;

    Assert (hdi);
    Assert (pszInfId && *pszInfId);
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilter);
    Assert (pFilter->FIsFilter());
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (ppFilterDevice);

    *ppFilterDevice = NULL;

    // Initialize the devinfo data corresponding to the driver the
    // caller wants us to install.
    //
    hr = HrCiGetDriverInfo (hdi, &deid, *MAP_NETCLASS_TO_GUID[NC_NET],
            pszInfId, NULL);

    if (S_OK == hr)
    {
        ADAPTER_OUT_PARAMS AdapterOutParams;

        ZeroMemory (&AdapterOutParams, sizeof(AdapterOutParams));

        CiSetReservedField (hdi, &deid, &AdapterOutParams);

        // Perform the installation.
        //
        hr = HrCiCallClassInstallerToInstallComponent (hdi, &deid);

        CiClearReservedField (hdi, &deid);

        if (S_OK == hr)
        {
            WCHAR szInstanceGuid[c_cchGuidWithTerm];
            INT cch;
            HKEY hkeyInstance;

            // Convert the instance guid to a string.
            //
            cch = StringFromGUID2 (
                    AdapterOutParams.InstanceGuid,
                    szInstanceGuid,
                    c_cchGuidWithTerm);
            Assert (c_cchGuidWithTerm == cch);

            // Open the instance key of the newly installed device
            // so we can write the instance guid and the back pointer
            // to the filter.
            //
            hr = HrSetupDiOpenDevRegKey (hdi, &deid,
                    DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_WRITE,
                    &hkeyInstance);

            if (S_OK == hr)
            {
                // Write the instance guid.
                //
                hr = HrRegSetSz (hkeyInstance, L"NetCfgInstanceId",
                        szInstanceGuid);

                // Write the inf id of the parent filter.
                //
                hr = HrRegSetSz (hkeyInstance, L"FilterInfId",
                        pFilter->m_pszInfId);

                RegCloseKey (hkeyInstance);
            }

            // Set the friendly name to include the adapter being
            // filtered.
            //
            if (S_OK == hr)
            {
                PWSTR pszFilterDesc;

                hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (
                        hdi, &deid, SPDRP_DEVICEDESC,
                        NULL, (BYTE**)&pszFilterDesc);

                if (S_OK == hr)
                {
                    #define SZ_NAME_SEP L" - "

                    PWSTR pszName;
                    ULONG cb;

                    // sizeof(SZ_NAME_SEP) includes the NULL-terminator
                    // so that will automatically add room for the
                    // NULL-terminator we need to allocate for pszName.
                    //
                    cb = CbOfSzSafe (pAdapter->Ext.PszDescription()) +
                         sizeof(SZ_NAME_SEP) +
                         CbOfSzSafe (pszFilterDesc);

                    pszName = (PWSTR)MemAlloc (cb);
                    if (pszName)
                    {
                        wcscpy (pszName, pAdapter->Ext.PszDescription());
                        wcscat (pszName, SZ_NAME_SEP);
                        wcscat (pszName, pszFilterDesc);

                        Assert (cb == CbOfSzAndTerm(pszName));

                        hr = HrSetupDiSetDeviceRegistryProperty (
                                hdi, &deid,
                                SPDRP_FRIENDLYNAME,
                                (const BYTE*)pszName,
                                cb);

                        MemFree (pszName);
                    }

                    MemFree (pszFilterDesc);
                }

                // If the above fails, its not a big deal.
                //
                hr = S_OK;
            }

            if (S_OK == hr)
            {
                hr = CFilterDevice::HrCreateInstance (
                        pAdapter,
                        pFilter,
                        &deid,
                        szInstanceGuid,
                        ppFilterDevice);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiInstallFilterDevice");
    return hr;
}

HRESULT
HrCiRemoveFilterDevice (
    IN HDEVINFO hdi,
    IN SP_DEVINFO_DATA* pdeid)
{
    HRESULT hr;
    ADAPTER_REMOVE_PARAMS arp = {0};

    Assert (hdi);
    Assert (pdeid);

    CiSetReservedField (hdi, pdeid, &arp);

    hr = HrSetupDiCallClassInstaller (DIF_REMOVE, hdi, pdeid);

    CiClearReservedField (hdi, pdeid);

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiRemoveFilterDevice");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\compdefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P D E F S . H
//
//  Contents:   Basic component related defintions.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgx.h"


// Maximum length (arbitrary) for bind strings.
// Bind strings are of the form \Device\foo_bar_...
//
const UINT _MAX_BIND_LENGTH = 512;


// A property of a component is its "Class".  This corresponds directly
// to the concept of Class exposed by SetupAPI.  That is, devices of all
// kinds belong to a class.  There are five basic network classes:
//   Net        : network adapters or software drivers that usually reside
//                at layer 2 or below.
//   Irda       : represent Infra-red networking devices (layer 2)
//   Nettrans   : network transports (protocols like TCP/IP, IPX, etc.)
//   Netservice : network services (File & Print, QOS, NetBIOS, etc.)
//   Netclient  : network clients (Client for Microsoft Networks, etc.)
//
enum NETCLASS
{
    NC_NET,
    NC_INFRARED,
    NC_NETTRANS,
    NC_NETCLIENT,
    NC_NETSERVICE,

    NC_CELEMS,      // count of elements in this enum, not an item
    NC_INVALID      // sentinel value for an invalid class, not an item
};

// map of NETCLASS enum to GUIDs for class
//
extern const GUID*  MAP_NETCLASS_TO_GUID[];

// map of NETCLASS enum to registry subkey strings for class
//
extern const PCWSTR MAP_NETCLASS_TO_NETWORK_SUBTREE[];

extern const WCHAR c_szTempNetcfgStorageForUninstalledEnumeratedComponent[];

inline
BOOL
FIsValidNetClass (
    NETCLASS Class)
{
    return ((UINT)Class < NC_CELEMS);
}

inline
BOOL
FIsConsideredNetClass (
    NETCLASS Class)
{
    AssertH (FIsValidNetClass (Class));

    return (NC_NET == Class || NC_INFRARED == Class);
}

inline
BOOL
FIsEnumerated (
    NETCLASS Class)
{
    AssertH (FIsValidNetClass (Class));

    // Currently, NC_NET and NC_INFRARED must be enumerated and they
    // are the only ones that are.
    //
    return (NC_NET == Class || NC_INFRARED == Class);
}

inline
BOOL
FIsEnumerated (
    const GUID& guidClass)
{
    // Currently, NET and INFRARED must be enumerated and they
    // are the only ones that are.
    //
    return (GUID_DEVCLASS_NET == guidClass ||
            GUID_DEVCLASS_INFRARED == guidClass);
}


inline
BOOL
FIsPhysicalAdapter (
    NETCLASS Class,
    DWORD dwCharacteristics)
{
    return FIsConsideredNetClass(Class) && (NCF_PHYSICAL & dwCharacteristics);
}

inline
BOOL
FIsPhysicalNetAdapter (
    NETCLASS Class,
    DWORD dwCharacteristics)
{
    return (NC_NET == Class) && (NCF_PHYSICAL & dwCharacteristics);
}

NETCLASS
NetClassEnumFromGuid (
    const GUID& guidClass);



// BASIC_COMPONENT_DATA is a structure used by code which
// creates a CComponent.  It is present just to avoid passing
// bunches of parameters to a function.
//
struct BASIC_COMPONENT_DATA
{
    GUID        InstanceGuid;
    NETCLASS    Class;
    DWORD       dwCharacter;
    DWORD       dwDeipFlags;
    PCWSTR      pszInfId;
    PCWSTR      pszPnpId;
};

HRESULT
HrOpenDeviceInfo (
    IN NETCLASS Class,
    IN PCWSTR pszPnpId,
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut);

HRESULT
HrOpenComponentInstanceKey (
    IN NETCLASS Class,
    IN const GUID& InstanceGuid, OPTIONAL
    IN PCWSTR pszPnpId, OPTIONAL
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\bindings.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       B I N D I N G S . H
//
//  Contents:   The basic datatypes for binding objects.  Bindpaths are
//              ordered collections of component pointers.  Bindsets
//              are a collection of bindpaths.  This module declares the
//              objects which represent them.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"

class CComponentList;

// A bindpath is an ordered collection of pointers to components.
// The order in the collection is the order of the components on
// the bindpath from top to bottom.
// e.g.
//   a, b, c, and d represent components.
//   a bindpath of a -> b -> c -> d is represented in this data
//   structure by a vector:
//       vector offset: 0 1 2 3
//       vector data  : a b c d
//   hence, the zeroth element in this data structure is the top-most
//   (first) component in the bindpath.  The last element in this
//   data structure is the bottom-most (last) component.
//
// vector was chosen as the base class because it implements
// contiguous storage with fast inserts at the end.  Since, we only
// build bindpaths by inserting components at the end, it was a
// natural choice.  list uses non-contiguous storage which tends to
// fragment the heap -- especially with lots of small allocations.
// We create many CBindPath instances, and since each node is a pointer,
// using vector over list is much easier on the heap.
//
// For a bindpath to be valid, it must not be empty and it must not
// contain any dupliate component pointers.
//
class CBindPath : public CNetCfgDebug<CBindPath>,
                  public vector<CComponent*>
{
public:
    bool
    operator< (
        const CBindPath& OtherPath) const;

    bool
    operator> (
        const CBindPath& OtherPath) const;

    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountComponents () const
    {
        return size();
    }

    BOOL
    FAllComponentsLoadedOkayIfLoadedAtAll () const;

    BOOL
    FContainsComponent (
        IN const CComponent* pComponent) const
    {
        return (find (begin(), end(), pComponent) != end());
    }

    BOOL
    FGetPathToken (
        OUT PWSTR pszToken,
        IN OUT ULONG* pcchToken) const;

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FIsSameBindPathAs (
        IN const CBindPath* pOtherPath) const;

    BOOL
    FIsSubPathOf (
        IN const CBindPath* pOtherPath) const;

    HRESULT
    HrAppendBindPath (
        IN const CBindPath* pBindPath);

    HRESULT
    HrAppendComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrGetComponentsInBindPath (
        IN OUT CComponentList* pComponents) const;

    HRESULT
    HrInsertComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrReserveRoomForComponents (
        IN UINT cComponents);

    CComponent*
    PGetComponentAtIndex (
        IN UINT unIndex) const
    {
        return (unIndex < size()) ? (*this)[unIndex] : NULL;
    }

    CComponent*
    POwner () const
    {
        AssertH (CountComponents() > 1);
        AssertH (front());
        return front();
    }

    CComponent*
    PLastComponent () const
    {
        AssertH (CountComponents() > 1);
        AssertH (back());
        return back();
    }

    CComponent*
    RemoveFirstComponent ()
    {
        CComponent* pComponent = NULL;
        if (size() > 0)
        {
            pComponent = front();
            AssertH(pComponent);
            erase(begin());
        }
        return pComponent;
    }

    CComponent*
    RemoveLastComponent ()
    {
        CComponent* pComponent = NULL;
        if (size() > 0)
        {
            pComponent = back();
            AssertH(pComponent);
            pop_back();
        }
        return pComponent;
    }

#if DBG
    VOID DbgVerifyBindpath ();
#else
    VOID DbgVerifyBindpath () {}
#endif
};

// A binding set is a set of bindpaths.  Each bindpath in the set
// must be unique and cannot be empty.
//
class CBindingSet : public CNetCfgDebug<CBindingSet>,
                    public vector<CBindPath>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountBindPaths () const
    {
        return size();
    }

    VOID
    Printf (
        TRACETAGID ttid,
        PCSTR pszPrefixLine) const;

    BOOL
    FContainsBindPath (
        IN const CBindPath* pBindPath) const;

    BOOL
    FContainsComponent (
        IN const CComponent* pComponent) const;

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    HRESULT
    HrAppendBindingSet (
        IN const CBindingSet* pBindSet);

    HRESULT
    HrAddBindPath (
        IN const CBindPath* pBindPath,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrAddBindPathsInSet1ButNotInSet2 (
        IN const CBindingSet* pSet1,
        IN const CBindingSet* pSet2);

    HRESULT
    HrCopyBindingSet (
        IN const CBindingSet* pSourceSet);

    HRESULT
    HrGetAffectedComponentsInBindingSet (
        IN OUT CComponentList* pComponents) const;

    HRESULT
    HrReserveRoomForBindPaths (
        IN UINT cBindPaths);

    CBindPath*
    PGetBindPathAtIndex (
        IN UINT unIndex)
    {
        return (unIndex < size()) ? (begin() + unIndex) : end();
    }

    VOID
    RemoveBindPath (
        IN const CBindPath* pBindPath);

    VOID
    RemoveBindPathsWithComponent (
        IN const CComponent* pComponent);

    VOID
    RemoveSubpaths ();

    VOID
    SortForPnpBind ();

    VOID
    SortForPnpUnbind ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\comprefs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P R E F S . H
//
//  Contents:   Implements the interface to a component's references.  A
//              component can be referenced (installed by) other components,
//              the user, or other software.  This module manages the
//              interface to that data.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "complist.h"
#include "ncstring.h"
#include "netcfgx.h"


struct COMPONENT_REFERENCE_DATA
{
    CComponentList      RefByComponents;
    vector<CWideString> RefBySoftware;
    BOOLEAN             fRefByUser;
};

class CComponentReferences : public CNetCfgDebug<CComponentReferences>
{
private:
    COMPONENT_REFERENCE_DATA*   m_pData;

private:
    HRESULT
    HrEnsureAllocated ();

public:
    ~CComponentReferences ();

    ULONG
    CountComponentsReferencedBy () const;

    ULONG
    CountSoftwareReferencedBy () const;

    ULONG
    CountTotalReferencedBy () const;

    BOOL
    FIsReferencedByComponent (
        IN const CComponent* pComponent) const;

    BOOL
    FIsReferencedByOboToken (
        IN const OBO_TOKEN* pOboToken) const;

    BOOL
    FIsReferencedByOthers () const;

    BOOL
    FIsReferencedByUser () const
    {
        return (m_pData && m_pData->fRefByUser);
    }

    VOID
    GetReferenceDescriptionsAsMultiSz (
        IN BYTE* pbBuf OPTIONAL,
        OUT ULONG* pcbBuf) const;

    CComponent*
    PComponentReferencedByAtIndex (
        IN UINT unIndex) const;

    const CWideString*
    PSoftwareReferencedByAtIndex (
        IN UINT unIndex) const;

    HRESULT
    HrAddReferenceByUser ();

    HRESULT
    HrAddReferenceByComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrAddReferenceByOboToken (
        IN const OBO_TOKEN* pOboToken);

    HRESULT
    HrAddReferenceBySoftware (
        IN PCWSTR pszKey);

    HRESULT
    HrRemoveReferenceByOboToken (
        IN const OBO_TOKEN* pOboToken);

    VOID
    RemoveAllReferences();

    VOID
    RemoveReferenceByComponent (
        IN const CComponent* pComponent)
    {
        AssertH (pComponent);
        AssertH (m_pData);
        m_pData->RefByComponents.RemoveComponent(pComponent);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\dihook.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I H O O K. C P P
//
//  Contents:   Class installer functions called via the device installer.
//
//  Notes:
//
//  Author:     billbe   25 Nov 1996
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "adapter.h"
#include "benchmrk.h"
#include "classinst.h"
#include "compdefs.h"
#include "iatl.h"
#include "isdnhook.h"
#include "ncatl.h"
#include "ncreg.h"
#include "nceh.h"
#include "netsetup.h"
#include "resource.h"
#include "util.h"
#include "netconp.h"

EXTERN_C const CLSID CLSID_InstallQueue;

const DWORD c_cmsWaitForINetCfgWrite   = 2000;

inline
BOOL
FIsValidErrorFromINetCfgForDiHook (
    IN HRESULT hr)
{
    return (NETCFG_E_NO_WRITE_LOCK == hr) ||
            (NETCFG_E_NEED_REBOOT == hr);
}

inline
BOOL
FIsHandledByClassInstaller(
    IN const GUID& guidClass)
{
    return FIsEnumerated(guidClass) ||
            (GUID_DEVCLASS_NETTRANS == guidClass) ||
            (GUID_DEVCLASS_NETCLIENT == guidClass) ||
            (GUID_DEVCLASS_NETSERVICE == guidClass);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiAddComponentToINetCfg
//
//  Purpose:    This function adds or updates a device In InetCfg.
//
//  Arguments:
//      pinc              [in] INetCfg interface
//      pinci             [in] INetCfgInstaller interface
//      guidClass         [in] The class guid of the component
//      pszwPnpid         [in] The pnp instance id of the device
//      eType             [in] The install type (NCI_INSTALL or NCI_UPDATE)
//      pszInstanceGuid   [in] The netcfg instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
EXTERN_C
HRESULT
WINAPI
HrDiAddComponentToINetCfg(
    IN INetCfg* pINetCfg,
    IN INetCfgInternalSetup* pInternalSetup,
    IN const NIQ_INFO* pInfo)
{
    Assert (pINetCfg);
    Assert (pInternalSetup);
    Assert (pInfo);

    Assert (pInfo->pszPnpId && *(pInfo->pszPnpId));
    Assert (NCI_REMOVE != pInfo->eType);

    HRESULT hr = S_OK;
    NC_TRY
    {
        CComponent* pComponent;
        BASIC_COMPONENT_DATA Data;
        ZeroMemory (&Data, sizeof(Data));

        Data.InstanceGuid = pInfo->InstanceGuid;
        Data.Class = NetClassEnumFromGuid (pInfo->ClassGuid);
        Data.pszPnpId = pInfo->pszPnpId;
        Data.pszInfId = pInfo->pszInfId;
        Data.dwCharacter = pInfo->dwCharacter;
        Data.dwDeipFlags = pInfo->dwDeipFlags;

        hr = CComponent::HrCreateInstance (
                &Data,
                CCI_ENSURE_EXTERNAL_DATA_LOADED,
                NULL,
                &pComponent);

        if (S_OK == hr)
        {
            hr = pInternalSetup->EnumeratedComponentInstalled (pComponent);

        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
            "HrDiAddComponentToINetCfg");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrDiNotifyINetCfgOfInstallation
//
//  Purpose:    This function notifies INetCfg that a net class component
//                  has been installed or updated.
//
//  Arguments:
//      hdi             [in] See Device Installer Api for more info
//      pdeid           [in] See Device Installer Api for more info
//      pszwPnpid       [in] The pnp instance id of the device
//      pszInstanceGuid [in] The netcfg instance guid of the device
//      eType           [in] NCI_INSTALL if the component was installed
//                           NCI_UPDATE, if it was updated
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
HRESULT
HrDiNotifyINetCfgOfInstallation (
    IN const NIQ_INFO* pInfo)
{
    Assert(pInfo);
    Assert((NCI_INSTALL == pInfo->eType) || (NCI_UPDATE == pInfo->eType));

    static const WCHAR c_szInstaller[] = L"INetCfg Installer Interface";
    INetCfg*    pinc;
    BOOL        fInitCom = TRUE;
    BOOL        fReboot = FALSE;

#ifdef ENABLETRACE
    CBenchmark bmrk2;
    bmrk2.Start ("Notifying INetCfg of installation");
#endif //ENABLETRACE

    TraceTag(ttidClassInst, "Attempting to notify INetCfg.");

    HRESULT hr = HrCreateAndInitializeINetCfg(&fInitCom, &pinc, TRUE,
                                              c_cmsWaitForINetCfgWrite,
                                              c_szInstaller, NULL);
    if (S_OK == hr)
    {
        // Get the INetCfgInternalSetup interface.
        INetCfgInternalSetup* pInternalSetup;
        hr = pinc->QueryInterface (IID_INetCfgInternalSetup,
                (VOID**)&pInternalSetup);

        if (S_OK == hr)
        {
            if (NCI_INSTALL == pInfo->eType)
            {
                hr = HrDiAddComponentToINetCfg(pinc, pInternalSetup, pInfo);
            }
            else // NCI_UPDATE
            {
                hr = pInternalSetup->EnumeratedComponentUpdated (
                        pInfo->pszPnpId);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                fReboot = TRUE;
                hr = S_OK;
            }

            ReleaseObj(pInternalSetup);
        }

        // Whether we succeeded or not, we are done and it's
        // time to clean up.  If there was a previous error
        // we want to preserve that error code so we assign
        // Uninitialize's result to a temporary then assign
        // it to hr if there was no previous error.
        //
        HRESULT hrT = HrUninitializeAndReleaseINetCfg (fInitCom, pinc, TRUE);
        hr = (S_OK == hr) ? hrT : hr;
    }

    if ((S_OK == hr) && fReboot)
    {
        TraceTag(ttidClassInst, "INetCfg returned NETCFG_S_REBOOT");
        hr = NETCFG_S_REBOOT;
    }

#ifdef ENABLETRACE
    bmrk2.Stop();
    TraceTag(ttidBenchmark, "%s : %s seconds",
            bmrk2.SznDescription(), bmrk2.SznBenchmarkSeconds(2));
#endif //ENABLETRACE

    TraceHr (ttidError, FAL, hr,
            NETCFG_S_REBOOT == hr || FIsValidErrorFromINetCfgForDiHook (hr),
             "HrDiNotifyINetCfgOfInstallation");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   InsertItemIntoInstallQueue
//
//  Purpose:    This function uses the InstallQueue object to insert a
//              workitem to be processed at a later time.  The workitem:
//              a device that was installed, removed, or updated and
//              INetCfg needs to be notified.
//
//  Arguments:
//      pguid        [in] The class guid of the device
//      pszwDeviceId [in] The Id of the device (PnP instance Id if the device
//                        was added or updated, its netcfg instance guid if
//                        it was removed
//
//  Returns:    hresult. S_OK if successful, an error code otherwise.
//
//  Author:     billbe   8 Sep 1998
//
//  Notes:
//
HRESULT
HrInsertItemIntoInstallQueue (
    IN const NIQ_INFO* pInfo)
{
    // Initialize COM
    BOOL    fInitCom = TRUE;
    HRESULT hr = CoInitializeEx (NULL, COINIT_MULTITHREADED |
            COINIT_DISABLE_OLE1DDE);

    // We may have changed mode but that's okay
    if (RPC_E_CHANGED_MODE == hr)
    {
        hr = S_OK;
        fInitCom = FALSE;
    }

    if (SUCCEEDED(hr))
    {
        // Create the Install Queue object and get the
        // INetInstallQueue interface
        //
        INetInstallQueue* pniq;
        hr = HrCreateInstance(
            CLSID_InstallQueue,
            CLSCTX_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pniq);

        TraceHr (ttidError, FAL, hr, FALSE, "HrCreateInstance");

        if (S_OK == hr)
        {

            TraceTag (ttidClassInst, "Adding item %S to queue.",
                    pInfo->pszPnpId);

            // Add the device info and the install type to the queue
            hr = pniq->AddItem (pInfo);
            pniq->Release();
        }

        if (fInitCom)
        {
            CoUninitialize();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "InsertItemIntoInstallQueue");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiInstallNetAdapter
//
//  Purpose:    This function preinstalls the NetAdapter, notifies the
//                  COM interfaces through CINetCfgClass that the
//                  component was added. Then it finalizes the install
//                  by applying all changes to INetCfg.
//  Arguments:
//      hdi        [in] See Device Installer Api for more info
//      pdeid      [in] See Device Installer Api for more info
//      hwndParent [in] The handle to the parent window, used for UI
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   24 Apr 1997
//
//  Notes:
//
HRESULT
HrDiInstallNetAdapter(
    IN COMPONENT_INSTALL_INFO* pcii)
{
    HRESULT                 hr = S_OK;
    ADAPTER_OUT_PARAMS*     pAdapterOutParams = NULL;
    SP_DEVINSTALL_PARAMS    deip;
    BOOL                    fNotifyINetCfg = TRUE;

    // If we were called from INetCfg, we have to store the results of the
    // install in the out params structure placed in the reserved field.
    //
    (VOID) HrSetupDiGetDeviceInstallParams (pcii->hdi, pcii->pdeid, &deip);
    if (deip.ClassInstallReserved)
    {
        pAdapterOutParams = (ADAPTER_OUT_PARAMS*)deip.ClassInstallReserved;
        fNotifyINetCfg = FALSE;
    }

    PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
    SP_DRVINFO_DATA drid;

    hr = HrCiGetDriverDetail (pcii->hdi, pcii->pdeid, &drid, &pdridd);
    if (S_OK == hr)
    {
        pcii->pszInfFile = pdridd->InfFileName;
        pcii->pszSectionName = pdridd->SectionName;
        pcii->pszInfId = pdridd->HardwareID;
        pcii->pszDescription = drid.Description;
    }
    else if (SPAPI_E_NO_DRIVER_SELECTED == hr)
    {
        // If we are in GUI mode and the device was previously installed,
        // then this device should be removed since its inf file could not
        // be found.
        //
        if (FInSystemSetup() &&
                (S_OK == HrCiIsInstalledComponent (pcii, NULL)))
        {
            // This dev node was is being reinstalled but has no driver
            // info.  In this case, we are going to remove the devnode.

            TraceTag (ttidClassInst, "We are in GUI mode and were told to "
                     "install a device that has no driver.  We will remove "
                     "device instead.");
            // We need to set the reserved field in the pdeid so that the
            // remove code will know that this is a bad instance that
            // should be removed regardless of the NCF_NOT_USER_REMOVABLE
            // characteristic.
            //
            ADAPTER_REMOVE_PARAMS arp;
            arp.fBadDevInst = TRUE;
            arp.fNotifyINetCfg = fNotifyINetCfg;
            CiSetReservedField (pcii->hdi, pcii->pdeid, &arp);

            (VOID) HrSetupDiCallClassInstaller (DIF_REMOVE,
                    pcii->hdi, pcii->pdeid);

            CiClearReservedField (pcii->hdi, pcii->pdeid);
        }
    }

    if (S_OK == hr)
    {
        TraceTag (ttidClassInst, "Calling HrCiInstallComponentInternal");

#ifdef ENABLETRACE
        CBenchmark bmrk1;
        bmrk1.Start ("HrCiInstallComponentInternal");
#endif //ENABLETRACE

        // Install (or reinstall) the component
        hr = HrCiInstallComponentInternal (pcii);

#ifdef ENABLETRACE
        bmrk1.Stop();
        TraceTag (ttidBenchmark, "%s : %s seconds",
                bmrk1.SznDescription(), bmrk1.SznBenchmarkSeconds (2));
#endif //ENABLETRACE

        // if we have succeeded so far and we have to notify INetcfg.
        // We also have to update the NT4 legacy registry for adapters.
        // Note that this is not done for filter devices.
        if (S_OK == hr)
        {
            if (fNotifyINetCfg && !FIsFilterDevice (pcii->hdi, pcii->pdeid))
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof (Info));

                Info.eType = pcii->fPreviouslyInstalled ?
                                    NCI_UPDATE : NCI_INSTALL;
                Info.ClassGuid      = pcii->pdeid->ClassGuid;
                Info.InstanceGuid   = pcii->InstanceGuid;
                Info.dwCharacter    = pcii->dwCharacter;
                Info.dwDeipFlags    = deip.Flags;
                Info.pszInfId       = pcii->pszInfId;
                Info.pszPnpId       = pcii->pszPnpId;

                hr = HrDiNotifyINetCfgOfInstallation (&Info);

                if (FIsValidErrorFromINetCfgForDiHook (hr))
                {
                    WCHAR szGuid[c_cchGuidWithTerm];
                    INT  cch = StringFromGUID2 (pcii->InstanceGuid, szGuid,
                            c_cchGuidWithTerm);

                    Assert (c_cchGuidWithTerm == cch);

                    // use queue
                    hr = HrInsertItemIntoInstallQueue (&Info);
                }
                else if (NETCFG_S_REBOOT == hr)
                {
                    (VOID) HrSetupDiSetDeipFlags (pcii->hdi, pcii->pdeid,
                            DI_NEEDREBOOT, SDDFT_FLAGS, SDFBO_OR);
                    hr = S_OK;
                }
            }
            else // !fNotifyINetCfg or is a filter device.
            {
                // Since we installed this enumerated device from INetCfg
                // we need to set the out params so they can be retrieved
                // when DIF_INSTALLDEVICE has finished.
                //
                if (pAdapterOutParams)
                {
                    Assert (!pcii->fPreviouslyInstalled);
                    pAdapterOutParams->dwCharacter = pcii->dwCharacter;
                    pAdapterOutParams->InstanceGuid = pcii->InstanceGuid;
                }
            }

            // Write out the NT4 legacy registry info for app. compatibility.
            // Note, we only do this for physical net devices.
            if ((NCF_PHYSICAL & pcii->dwCharacter) &&
                    (GUID_DEVCLASS_NET == pcii->pdeid->ClassGuid))
            {
                AddOrRemoveLegacyNt4AdapterKey (pcii->hdi, pcii->pdeid,
                        &pcii->InstanceGuid, pcii->pszDescription,
                        LEGACY_NT4_KEY_ADD);
            }
        }

        MemFree (pdridd);
    }

    // All success codes should be mapped to S_OK since they have no meaning
    // along this code path.
    if (SUCCEEDED(hr))
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrDiInstallNetAdapter");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrDiNotifyINetCfgOfRemoval
//
//  Purpose:    This function notifies INetCfg that a net class component has
//                  been removed
//
//  Arguments:
//      hdi            [in]  See Device Installer api for more info
//      pdeid          [in]
//      szInstanceGuid [in] The instance guid of the component
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   29 Jul 1997
//
//  Notes:
//
HRESULT
HrDiNotifyINetCfgOfRemoval (
    IN PCWSTR pszPnpId)
{
    static const WCHAR c_szUninstaller[] = L"INetCfg UnInstaller Interface";
    INetCfg* pINetCfg;
    BOOL fInitCom = TRUE;
    HRESULT hr = HrCreateAndInitializeINetCfg(&fInitCom, &pINetCfg, TRUE,
            c_cmsWaitForINetCfgWrite, c_szUninstaller, NULL);

    if (SUCCEEDED(hr))
    {
        BOOL fNeedReboot = FALSE;

        // Get the INetCfgInternalSetup interface.
        INetCfgInternalSetup* pInternalSetup;
        hr = pINetCfg->QueryInterface (IID_INetCfgInternalSetup,
                (VOID**)&pInternalSetup);

        if (SUCCEEDED(hr))
        {
            hr = pInternalSetup->EnumeratedComponentRemoved (pszPnpId);

            if (NETCFG_S_REBOOT == hr)
            {
                fNeedReboot = TRUE;
            }
        }

        // Whether we succeeded or not, we are done and it's
        // time to clean up.  If there was a previous error
        // we want to preserve that error code so we assign
        // Uninitialize's result to a temporary then assign
        // it to hr if there was no previous error.
        //
        HRESULT hrT = HrUninitializeAndReleaseINetCfg (TRUE, pINetCfg, TRUE);

        // If everything was successful then set the return value to be
        // the return of HrUninitializeAndReleaseINetCfg
        hr = SUCCEEDED(hr) ? hrT : hr;

        if (SUCCEEDED(hr) && fNeedReboot)
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceHr (ttidError, FAL, hr,
            NETCFG_S_REBOOT == hr || FIsValidErrorFromINetCfgForDiHook (hr),
             "HrNcNotifyINetCfgOfRemoval");
    return hr;
}


VOID
StoreInfoForINetCfg (
    IN HKEY hkeyInstance)
{
    HKEY hkeyInterfaceStore = NULL;
    HKEY hkeyNdiStore = NULL;
    WCHAR szGuid[c_cchGuidWithTerm];
    DWORD cbGuid = sizeof (szGuid);
    WCHAR szNdiPath[_MAX_PATH];

    HRESULT hr = HrRegQuerySzBuffer (hkeyInstance, L"NetCfgInstanceId", szGuid,
            &cbGuid);

    if (S_OK == hr)
    {
        wcscpy (szNdiPath,
                c_szTempNetcfgStorageForUninstalledEnumeratedComponent);
        wcscat (szNdiPath, szGuid);
        wcscat (szNdiPath, L"\\Ndi");

        hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, szNdiPath,
                REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                &hkeyNdiStore, NULL);
        if (S_OK == hr)
        {
            hr = HrRegCreateKeyEx (hkeyNdiStore, L"Interfaces",
                    REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL,
                    &hkeyInterfaceStore, NULL);
        }
    }

    if (S_OK == hr)
    {
        HKEY hkeyNdi;
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            PWSTR pszRequiredList;
            hr = HrRegQuerySzWithAlloc (hkeyNdi, L"RequiredAll",
                    &pszRequiredList);

            if (S_OK == hr)
            {
                hr = HrRegSetSz (hkeyNdiStore, L"RequiredAll",
                        pszRequiredList);
                MemFree (pszRequiredList);
            }

            if (HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }

            TraceHr (ttidError, FAL, hr, FALSE, "Writing RequiredAll key "
                     "for INetCfg removal notify");
            RegCloseKey (hkeyNdi);
        }

        HKEY hkeyInterfaces;
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi\\Interfaces", KEY_READ,
                &hkeyInterfaces);

        if (S_OK == hr)
        {
            PWSTR pszUpper;
            PWSTR pszLower;
            hr = HrRegQuerySzWithAlloc (hkeyInterfaces, L"UpperRange",
                    &pszUpper);

            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyInterfaceStore, L"UpperRange",
                        pszUpper);
                MemFree ((VOID*) pszUpper);
            }

            hr = HrRegQuerySzWithAlloc (hkeyInterfaces, L"LowerRange",
                    &pszLower);

            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyInterfaceStore, L"LowerRange",
                        pszLower);
                MemFree ((VOID*) pszLower);
            }

            RegCloseKey (hkeyInterfaces);
        }
    }
    RegSafeCloseKey (hkeyInterfaceStore);
    RegSafeCloseKey (hkeyNdiStore);
}

//+--------------------------------------------------------------------------
//
//  Function:   HrDiRemoveNetAdapter
//
//  Purpose:    This function removes a net adapter, notifies the
//                  COM interfaces through CINetCfgClass that the
//                  component was removed. Then it finalizes the remove
//                  by applying all changes to INetCfg.
//  Arguments:
//      hdi             [in] See Device Installer Api for more info
//      pdeid           [in] See Device Installer Api for more info
//      pszPnPId        [in] The pnp instance id of the adapter
//      hwndParent      [in] The handle to the parent window, used for UI
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   24 Apr 1997
//
//  Notes:
//
HRESULT
HrDiRemoveNetAdapter (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                     PWSTR pszPnpId, HWND hwndParent)
{
    BOOL                    fAllowRemove = TRUE;

    SP_DEVINSTALL_PARAMS    deip;
    BOOL                    fNotifyINetCfg = TRUE;
    BOOL                    fBadDevInst = FALSE;
    HRESULT                 hr = S_OK;

    // Check for the existence of a CComponentInfo and retrieve the
    // value of the write lock flag
    //
    (VOID) HrSetupDiGetDeviceInstallParams (hdi, pdeid, &deip);
    if (deip.ClassInstallReserved)
    {
        ADAPTER_REMOVE_PARAMS* parp = reinterpret_cast<ADAPTER_REMOVE_PARAMS*>
                (deip.ClassInstallReserved);

        fNotifyINetCfg = parp->fNotifyINetCfg;

        fBadDevInst = parp->fBadDevInst;
    }

    if (fNotifyINetCfg)
    {
        // The component is not being removed programmatically (we can tell
        // this because we wouldn't have to notify INetCfg if it was
        // being removed through INetCfg).  Because of this. we have to
        // make sure the user is allowed to do this by checking the
        // component's characteristics
        //
        HKEY hkey;
        hr = HrSetupDiOpenDevRegKey (hdi, pdeid, DICS_FLAG_GLOBAL, 0,
                DIREG_DRV, KEY_READ, &hkey);

        if (S_OK == hr)
        {
            // If we are removing a bad device instance, don't bother
            // checking if we are allowed to.  We need to get rid of it.
            //
            if (!fBadDevInst)
            {
                DWORD dwCharacter;

                hr = HrRegQueryDword (hkey, L"Characteristics", &dwCharacter);

                if (S_OK == hr)
                {
                    // Is the not removable characteristic present?
                    fAllowRemove = !(dwCharacter & NCF_NOT_USER_REMOVABLE);
                }
            }

            if (fAllowRemove)
            {
                StoreInfoForINetCfg (hkey);

                // We need to remove this adapter from the old NT4 registry
                // location.
                //
                if (GUID_DEVCLASS_NET == pdeid->ClassGuid)

                {
                    AddOrRemoveLegacyNt4AdapterKey (hdi, pdeid, NULL, NULL,
                            LEGACY_NT4_KEY_REMOVE);
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32 (ERROR_ACCESS_DENIED);
                TraceTag (ttidClassInst, "User is trying to remove a "
                         "non user-removable device.");
            }
            RegCloseKey (hkey);
        }
        else if (SPAPI_E_KEY_DOES_NOT_EXIST == hr)
        {
            hr = S_OK;
        }
    }

    if ((S_OK == hr) && fAllowRemove)
    {
        // Remove the device
        //

        // Open the device's device parameters key
        //
        HKEY hkeyDevice;
        hr = HrSetupDiOpenDevRegKey (hdi, pdeid, DICS_FLAG_GLOBAL,
                0, DIREG_DEV, KEY_READ, &hkeyDevice);

        if (S_OK == hr)
        {
            // Delete this adapter's index number from the in-use list
            // so it can be reused.
            //

            // First retrieve the index
            //
            DWORD dwInstanceIndex;
            hr = HrRegQueryDword (hkeyDevice, L"InstanceIndex",
                    &dwInstanceIndex);

            if (S_OK == hr)
            {
                // Get the description for the adapter so we can
                // access the index list of that description
                //

                PWSTR pszDescription;
                hr = HrSetupDiGetDeviceRegistryPropertyWithAlloc (hdi, pdeid,
                        SPDRP_DEVICEDESC, NULL,
                        (BYTE**)&pszDescription);

                if (S_OK == hr)
                {
                    // Delete the index
                    (VOID) HrCiUpdateDescriptionIndexList (
                            NetClassEnumFromGuid(pdeid->ClassGuid),
                            pszDescription, DM_DELETE,
                            &dwInstanceIndex);

                    MemFree (pszDescription);
                }
            }
            RegCloseKey (hkeyDevice);
        }

        // Note: Yes we can walk over the last hr result.
        // We can still go on even if we failed to remove the index
        // from the in-use list.

        // remove the adapter
#ifdef ENABLETRACE
        CBenchmark bmrk;
        bmrk.Start ("SetupDiRemoveDevice");
#endif //ENABLETRACE

        hr = HrSetupDiRemoveDevice (hdi, pdeid);

#ifdef ENABLETRACE
        bmrk.Stop();
        TraceTag(ttidBenchmark, "%s : %s seconds",
                bmrk.SznDescription(), bmrk.SznBenchmarkSeconds(2));
#endif //ENABLETRACE

        TraceHr (ttidError, FAL, hr, FALSE,
                "HrRemoveNetAdapter::HrSetupDiRemoveDevice");

        // Notify INetCfg if needed.
        if ((S_OK == hr) && fNotifyINetCfg)
        {
            hr = HrDiNotifyINetCfgOfRemoval (pszPnpId);
            if (FIsValidErrorFromINetCfgForDiHook (hr))
            {
                NIQ_INFO Info;
                ZeroMemory(&Info, sizeof(Info));
                Info.ClassGuid = pdeid->ClassGuid;
                Info.eType = NCI_REMOVE;
                Info.pszInfId = L"";
                Info.pszPnpId = pszPnpId;

                // Use Queue
                hr = HrInsertItemIntoInstallQueue (&Info);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                (VOID) HrSetupDiSetDeipFlags (hdi, pdeid, DI_NEEDREBOOT,
                        SDDFT_FLAGS, SDFBO_OR);
                hr = S_OK;
            }
        }
    }

    if(SUCCEEDED(hr) && GUID_DEVCLASS_NET == pdeid->ClassGuid)
    {
        INetConnectionRefresh * pRefresh = NULL;
        HRESULT hrTemp = HrCreateInstance(
            CLSID_ConnectionManager,
            CLSCTX_LOCAL_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            &pRefresh);
        if(SUCCEEDED(hrTemp))
        {
            hrTemp = pRefresh->RefreshAll();
            ReleaseObj(pRefresh);
        }

    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrDiRemoveNetAdapter");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrNetClassInstaller
//
//  Purpose:    This function is called by the Device Installer for a
//                  variety of functions defined by dif.
//                  See SetupDiCallClassInstaller in the Device Installer
//                  documentation for more information.
//  Arguments:
//      dif   [in] See Device Installer Api
//      hdi   [in]
//      pdeid [in]
//
//  Returns:    DWORD. Win32/Device Installer error code
//
//  Author:     billbe   8 May 1997
//
//  Notes:
//
HRESULT _HrNetClassInstaller(DI_FUNCTION dif,
                            HDEVINFO hdi,
                            PSP_DEVINFO_DATA pdeid)
{
    HRESULT hr = SPAPI_E_DI_DO_DEFAULT;

    // The time it takes to remove a device.
    static const DWORD c_cmsNetComponentRemove = 30000;

    if ((DIF_INSTALLDEVICE == dif) || (DIF_REMOVE == dif))
    {
        WCHAR szPnpId[MAX_DEVICE_ID_LEN] = {0};
        hr = HrSetupDiGetDeviceInstanceId(hdi, pdeid, szPnpId,
                MAX_DEVICE_ID_LEN, NULL);

        if (S_OK == hr)
        {

#ifdef DBG
            if (FIsDebugFlagSet (dfidBreakOnNetInstall))
            {
                AssertSz(FALSE, "THIS IS NOT A BUG!  The debug flag "
                         "\"BreakOnNetInstall\" has been set. Set your breakpoints now.");
            }
#endif // DBG
            HWND hwndParent = NULL;

            // If this call fails we don't really care since it is a convenience.
            (VOID) HrSetupDiGetParentWindow (hdi, pdeid, &hwndParent);

#ifdef ENABLETRACE
            CBenchmark bmrk;
            const int c_cchBenchmarkDesc = 2*MAX_DEVICE_ID_LEN;
            CHAR szBenchmarkDesc[c_cchBenchmarkDesc];
#endif // ENABLETRACE

            if (DIF_INSTALLDEVICE == dif)
            {
                COMPONENT_INSTALL_INFO cii;
                ZeroMemory(&cii, sizeof(cii));

                cii.hwndParent   = hwndParent;
                cii.hdi          = hdi;
                cii.pdeid        = pdeid;
                cii.Class        = NetClassEnumFromGuid (pdeid->ClassGuid);
                cii.BusType      = InterfaceTypeUndefined;
                cii.InstanceGuid = GUID_NULL;
                cii.pszPnpId     = szPnpId;

#ifdef ENABLETRACE
                TraceTag (ttidClassInst, "Installing %S", szPnpId);
                _snprintf (szBenchmarkDesc, c_cchBenchmarkDesc,
                        "Installing %S", szPnpId);
                bmrk.Start (szBenchmarkDesc);
#endif // ENABLETRACE

                // Add the adapter to the network configuration.
                hr = HrDiInstallNetAdapter (&cii);

            }
            else // DIF_REMOVEDEVICE
            {
#ifdef ENABLETRACE
                TraceTag (ttidClassInst, "Removing %S", szPnpId);
                _snprintf (szBenchmarkDesc, c_cchBenchmarkDesc,
                        "Total Time Removing %S", szPnpId);
#endif //ENABLETRACE

                // We need to reset the hresult from SPAPI_E_DO_DEFAULT to S_OK
                // since we check for success a bit later.
                hr = S_OK;

                // Check to see it another net class installer thread is
                // currently deleting this component.
                //

                // The event name will be the adapter instance Id with slashes
                // converted to ampersands.  If we can't get the instance
                // id, we will attempt to remove the adapter without it
                //

                // convert the slashes in the instance id to ampersands
                //
                WCHAR szEventName[MAX_DEVICE_ID_LEN];
                wcscpy (szEventName, szPnpId);
                for (UINT i = 0; i < wcslen (szEventName); ++i)
                {
                    if ('\\' == szEventName[i])
                    {
                        szEventName[i] = L'&';
                    }
                }

                // create the event in the non-signaled state
                BOOL fAlreadyExists;
                HANDLE hRemoveEvent = NULL;
                hr = HrCreateEventWithWorldAccess (szEventName, FALSE, FALSE,
                        &fAlreadyExists, &hRemoveEvent);

                if ((S_OK == hr) && fAlreadyExists)
                {
                    // another instance of netclassinstaller is deleting this
                    // component, so wait till it is finished.  If the following
                    // times out, we still return success.  We are only waiting to
                    // give the other NetClassInstaller time to finish the state
                    // of this component
                    DWORD dwRet = WaitForSingleObject (hRemoveEvent,
                            c_cmsNetComponentRemove);

                    // if the other installer finished okay, we have the event
                    // so we signal (in case yet another process is waiting
                    // for the remove to finish) and close the handle.
                    // If we timeout, we just close the handle
                    if (WAIT_ABANDONED != dwRet)
                    {
                        if (WAIT_OBJECT_0 == dwRet)
                        {
                            SetEvent (hRemoveEvent);
                        }
                        CloseHandle (hRemoveEvent);
                        return S_OK;
                    }

                    // The event was abandoned so let's try to finish the job
                    //
                }
                else if (!hRemoveEvent)
                {
                    hr = HrFromLastWin32Error ();
                }

                if (S_OK == hr)
                {
                    // We created an event so we must make sure to remove it
                    // even if there is an exception.
                    //
                    NC_TRY
                    {

#ifdef ENABLETRACE
                        bmrk.Start (szBenchmarkDesc);
#endif // ENABLETRACE

                        hr = HrDiRemoveNetAdapter (hdi, pdeid, szPnpId,
                                hwndParent);
                    }
                    NC_CATCH_ALL
                    {
                        hr = E_UNEXPECTED;
                    }

                    // We are done.  If we created an event, we need to
                    // signal it and close our handle.
                    if (hRemoveEvent)
                    {
                        SetEvent (hRemoveEvent);
                        CloseHandle (hRemoveEvent);
                    }
                }
            }

#ifdef ENABLETRACE
            if (S_OK == hr)
            {
                bmrk.Stop ();
                TraceTag (ttidBenchmark, "%s : %s seconds",
                        bmrk.SznDescription (), bmrk.SznBenchmarkSeconds (2));
            }
#endif // ENABLETRACE
        }
    }
    else if (DIF_DESTROYPRIVATEDATA == dif)
    {
        SP_DEVINSTALL_PARAMS deip;
        hr = HrSetupDiGetDeviceInstallParams(hdi, pdeid, &deip);
        MemFree ((VOID*)deip.ClassInstallReserved);

    }
    else if (DIF_REGISTERDEVICE == dif)
    {
        // We handle 5 classes of components but we only
        // want to allow registration for two of them
        // (The ones considered NetClassComponents)
        Assert(pdeid);
        if (pdeid)
        {
            if (FIsHandledByClassInstaller(pdeid->ClassGuid))
            {
                if (!FIsEnumerated(pdeid->ClassGuid))
                {
                    // Don't let the device installer register
                    // devices that are not considered net class
                    hr = S_OK;
                }
            }
        }
    }
    else if (DIF_SELECTDEVICE == dif)
    {
        // This will set the proper description strings in the select device
        // dialog.  If it fails, we can still show the dialog
        (VOID) HrCiPrepareSelectDeviceDialog(hdi, pdeid);
    }
    else if (DIF_NEWDEVICEWIZARD_FINISHINSTALL == dif)
    {
        hr = HrAddIsdnWizardPagesIfAppropriate(hdi, pdeid);
    }
    else if (DIF_ALLOW_INSTALL == dif)
    {
        // Get the selected driver for this device
        //
        SP_DRVINFO_DATA             drid;
        hr = HrSetupDiGetSelectedDriver(hdi, pdeid, &drid);

        if (S_OK == hr)
        {
            // Now get the driver's detailed information
            //
            PSP_DRVINFO_DETAIL_DATA pdridd = NULL;
            hr  = HrSetupDiGetDriverInfoDetail(hdi, pdeid,
                &drid, &pdridd);

            if (S_OK == hr)
            {
                // Open the component's inf file
                //
                HINF hinf = NULL;
                hr = HrSetupOpenInfFile(pdridd->InfFileName, NULL,
                        INF_STYLE_WIN4, NULL, &hinf);

                if (S_OK == hr)
                {
                    // Make sure this is an NT5 inf network inf
                    //
                    hr = HrSetupIsValidNt5Inf(hinf);
                    SetupCloseInfFile(hinf);

                    if (S_OK == hr)
                    {
                        hr = SPAPI_E_DI_DO_DEFAULT;
                    }

                }
                MemFree (pdridd);
            }
        }
    }
    else if (DIF_POWERMESSAGEWAKE == dif)
    {
        SP_POWERMESSAGEWAKE_PARAMS_W wakeParams;

        // Get the power message wake params.
        //
        hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
               (PSP_CLASSINSTALL_HEADER)&wakeParams, sizeof(wakeParams));

        if (S_OK == hr)
        {
            Assert (DIF_POWERMESSAGEWAKE ==
                    wakeParams.ClassInstallHeader.InstallFunction);

            // Copy in our string for the power tab.
            wcscpy (wakeParams.PowerMessageWake, SzLoadIds(IDS_POWER_MESSAGE_WAKE));

            // Now we update the parameters.
            hr = HrSetupDiSetClassInstallParams (hdi, pdeid,
                    (PSP_CLASSINSTALL_HEADER)&wakeParams,
                    sizeof(SP_POWERMESSAGEWAKE_PARAMS_W));

            // If we failed to set the text just allow the device installer
            // to do the default.
            if (FAILED(hr))
            {
                hr = SPAPI_E_DI_DO_DEFAULT;
            }
        }
    }

    TraceHr (ttidClassInst, FAL, hr, (SPAPI_E_DI_DO_DEFAULT == hr) ||
            (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
             "HrNetClassInstaller");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\diag.cpp ===
#include "pch.h"
#pragma hdrstop

#include "adapter.h"
#include "diag.h"
#include "inetcfg.h"
#include "lanamap.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcfg.h"
#include "persist.h"
#include "util.h"
#include <conio.h>      // _kbhit

//move to classinst.cpp
HRESULT
HrCiDoCompleteSectionInstall(
    HINF hinfFile,
    HKEY hkeyRelative,
    PCWSTR szSection,
    HWND hwndParent,
    BOOL fEnumerated);


class CNetCfgInternalDiagnostic
{
public:
    static VOID
    DoCreateReleaseDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        BOOL fPrime);

    static VOID
    DoEnumAllDiagnostic (
        IN const DIAG_OPTIONS* pOptions);

    static VOID
    DoSaveLoadDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);

    static VOID
    DoWriteLockDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);

    static VOID
    CmdFullDiagnostic (
        IN const DIAG_OPTIONS* pOptions,
        IN CNetConfig* pNetConfig);
};

VOID
PromptForLeakCheck (
    IN const DIAG_OPTIONS* pOptions,
    IN PCSTR psz)
{
    if (pOptions->fLeakCheck)
    {
        g_pDiagCtx->Printf (ttidBeDiag, psz);
        while (!_kbhit())
        {
            Sleep (50);
        }
        _getch ();
        g_pDiagCtx->Printf (ttidBeDiag, "\n");
    }
}

HRESULT
HrCreateINetCfg (
    IN BOOL fAcquireWriteLock,
    OUT CImplINetCfg** ppINetCfg)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = CComCreator<CComObject <CImplINetCfg> >::CreateInstance(
            NULL, IID_INetCfg, (VOID**)&pINetCfg);
    if (S_OK == hr)
    {
        if (fAcquireWriteLock)
        {
            hr = pINetCfg->AcquireWriteLock (100, L"ncdiag", NULL);

            if (S_FALSE == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "The write lock could not be acquired.\n");
            }
            else if (NETCFG_E_NEED_REBOOT == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "A reboot is required before any futher "
                    "changes can be made.\n");
            }
        }

        if (S_OK == hr)
        {
            hr = pINetCfg->Initialize (NULL);
            if (S_OK == hr)
            {
                *ppINetCfg = pINetCfg;
            }
        }

        if (S_OK != hr)
        {
            ReleaseObj (pINetCfg->GetUnknown());
        }
    }
    return hr;
}

HRESULT
HrFindBindPath (
    IN CImplINetCfg* pINetCfg,
    IN PCWSTR pszPathToken,
    OUT INetCfgBindingPath** ppIPath,
    OUT INetCfgComponentBindings** ppIOwner)
{
    HRESULT hr;
    const WCHAR szDelim[] = L"->";
    WCHAR szBindPath [_MAX_PATH];
    PCWSTR pszInfId;
    PWSTR pszNext;
    INetCfgComponent* pIComp;

    *ppIPath = NULL;

    if (ppIOwner)
    {
        *ppIOwner = NULL;
    }

    wcscpy (szBindPath, pszPathToken);
    pszInfId = GetNextStringToken (szBindPath, szDelim, &pszNext);

    hr = pINetCfg->FindComponent (pszInfId, &pIComp);
    if (S_OK == hr)
    {
        INetCfgComponentBindings* pIBind;

        hr = pIComp->QueryInterface (IID_INetCfgComponentBindings,
                        (VOID**)&pIBind);
        if (S_OK == hr)
        {
            IEnumNetCfgBindingPath* pIEnumPath;

            hr = pIBind->EnumBindingPaths (EBP_BELOW, &pIEnumPath);
            if (S_OK == hr)
            {
                INetCfgBindingPath* rgIPath [256];
                ULONG cIPath;

                hr = pIEnumPath->Next (celems(rgIPath), rgIPath, &cIPath);
                if (SUCCEEDED(hr) && cIPath)
                {
                    for (ULONG iPath = 0;
                         (iPath < cIPath) && !(*ppIPath);
                         iPath++)
                    {
                        PWSTR pszToken;

                        hr = rgIPath[iPath]->GetPathToken (&pszToken);
                        if (S_OK == hr)
                        {
                            if (0 == wcscmp (pszPathToken, pszToken))
                            {
                                AddRefObj (rgIPath[iPath]);
                                *ppIPath = rgIPath[iPath];

                                if (ppIOwner)
                                {
                                    INetCfgComponent* pICompOwner;

                                    hr = rgIPath[0]->GetOwner(&pICompOwner);
                                    Assert (S_OK == hr);

                                    pICompOwner->QueryInterface (
                                        IID_INetCfgComponentBindings,
                                        (VOID**)ppIOwner);

                                    ReleaseObj (pICompOwner);
                                }
                            }
                            CoTaskMemFree (pszToken);
                        }
                    }

                    ReleaseIUnknownArray(cIPath, (IUnknown**)rgIPath);
                    hr = S_OK;
                }

                ReleaseObj (pIEnumPath);
            }

            ReleaseObj (pIBind);
        }

        ReleaseObj (pIComp);
    }
    else if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}

// This test ensures proper circular reference behavior between CNetConfig
// and CImplINetCfg.
// The following is performed:
//     create a CNetConfig and have it create its INetCfg for the notify objects.
//     AddRef its INetCfg
//     destroy the CNetConfig
//     Try to Uninitialize the INetCfg which should fail because it never
//     owned its internal CNetConfig pointer.
//     Release the INetCfg and ensure that nothing is leaked.
//
VOID
CNetCfgInternalDiagnostic::DoCreateReleaseDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN BOOL fPrime)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg = NULL;

    if (!fPrime)
    {
        PromptForLeakCheck (pOptions,
            "Create/Release diagnostic...(dump heap)");
    }

    // Scoping brackets so that NetConfig will be created and destroyed
    // in this scope.
    //
    {
        CNetConfig NetConfig;

        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            // Shouldn't have internal INetCfg created yet.
            //
            Assert (!NetConfig.Notify.m_pINetCfg);

            hr = NetConfig.Notify.HrEnsureNotifyObjectsInitialized ();
            if (S_OK == hr)
            {
                // Should now have internal INetCfg created.
                //
                Assert (NetConfig.Notify.m_pINetCfg);
                pINetCfg = NetConfig.Notify.m_pINetCfg;

                // INetCfg should be pointing back to our CNetConfig object.
                //
                Assert (&NetConfig == pINetCfg->m_pNetConfig);

                // Let's hang on to it and see what happens after we let
                // the parent CNetConfig be destroyed.
                //
                pINetCfg = NetConfig.Notify.m_pINetCfg;
                AddRefObj (pINetCfg->GetUnknown());
            }
        }
    }

    if ((S_OK == hr) && pINetCfg)
    {
        // Now that CNetConfig is destroyed, it should not be pointing to
        // any CNetConfig object.
        //
        Assert (!pINetCfg->m_pNetConfig);

        hr = pINetCfg->Uninitialize();
        Assert (NETCFG_E_NOT_INITIALIZED == hr);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (NETCFG_E_NOT_INITIALIZED == hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Passed Create/Release diagnostic.\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Create/Release diagnostic.\n");
    }

    if (!fPrime)
    {
        PromptForLeakCheck (pOptions,
            "Create/Release diagnostic...(dump heap and compare)");
    }
}

VOID
CNetCfgInternalDiagnostic::DoEnumAllDiagnostic (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Enumerate All diagnostic...(dump heap)");

    hr = HrCreateINetCfg (FALSE, &pINetCfg);
    if (S_OK == hr)
    {
        IEnumNetCfgComponent* pIEnum;

        hr = pINetCfg->EnumComponents (NULL, &pIEnum);
        if (S_OK == hr)
        {
            INetCfgComponent* rgIComp[128];
            ULONG cIComp;

            hr = pIEnum->Next (celems(rgIComp), rgIComp, &cIComp);
            if (SUCCEEDED(hr) && cIComp)
            {
                INetCfgComponentBindings* pIBind;
                IEnumNetCfgBindingPath* pIEnumPath;
                INetCfgBindingPath* rgIPath[256];
                PWSTR pszInfId;
                ULONG cIPath;
                ULONG cIPathTotal = 0;
                ULONG cIIntTotal = 0;

                for (ULONG iComp = 0; iComp < cIComp; iComp++)
                {
                    hr = rgIComp[iComp]->GetId (&pszInfId);
                    if (S_OK == hr)
                    {
                        hr = (*pszInfId) ? S_OK : E_FAIL;
                        if (S_OK != hr)
                        {
                            break;
                        }

                        hr = rgIComp[iComp]->QueryInterface (IID_INetCfgComponentBindings, (VOID**)&pIBind);
                        if (S_OK == hr)
                        {
                            hr = pIBind->EnumBindingPaths (EBP_BELOW, &pIEnumPath);
                            if (S_OK == hr)
                            {
                                hr = pIEnumPath->Next (celems(rgIPath), rgIPath, &cIPath);
                                if (SUCCEEDED(hr))
                                {
                                    for (ULONG iPath = 0; iPath < cIPath; iPath++)
                                    {
                                        ULONG ulDepth;
                                        hr = rgIPath[iPath]->GetDepth(&ulDepth);
                                        if (S_OK == hr)
                                        {
                                            IEnumNetCfgBindingInterface* pIEnumInt;
                                            INetCfgBindingInterface* rgIInt[128];
                                            ULONG cIInt;

                                            hr = rgIPath[iPath]->EnumBindingInterfaces (&pIEnumInt);
                                            if (S_OK == hr)
                                            {
                                                hr = pIEnumInt->Next (celems(rgIInt), rgIInt, &cIInt);
                                                if (SUCCEEDED(hr))
                                                {
                                                    cIIntTotal += cIInt;
                                                    ReleaseIUnknownArray(cIInt, (IUnknown**)rgIInt);
                                                }
                                                else if (S_FALSE == hr)
                                                {
                                                    hr = S_OK;
                                                }

                                                ReleaseObj (pIEnumInt);
                                            }
                                        }
                                    }

                                    cIPathTotal += cIPath;
                                    ReleaseIUnknownArray(cIPath, (IUnknown**)rgIPath);
                                    hr = S_OK;
                                }

                                ReleaseObj (pIEnumPath);
                            }

                            ReleaseObj (pIBind);
                        }

                        CoTaskMemFree (pszInfId);
                    }

                    if (S_OK != hr)
                    {
                        break;
                    }
                }

                ReleaseIUnknownArray(cIComp, (IUnknown**)rgIComp);

                // Note: Total bindpaths are not total unique bindpaths.
                // (A component's bindpaths which end in ms_ipx have
                // ms_ipx's lower bindings added.  These additional
                // bindings are counted for every component which has
                // bindpaths that end in ms_ipx.)
                //
                g_pDiagCtx->Printf (ttidBeDiag, "Passed Enumerate All diagnostic.  (%d components, %d (non-unique) bindpaths, %d interfaces)\n", cIComp, cIPathTotal, cIIntTotal);
            }
            else if (S_FALSE == hr)
            {
                hr = S_OK;
            }

            ReleaseObj (pIEnum);
        }
        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Enumerate All diagnostic.\n");
    }

    PromptForLeakCheck (pOptions, "Enumerate All diagnostic...(dump heap and compare)");
}

VOID
CNetCfgInternalDiagnostic::DoSaveLoadDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    BOOL fClearDisabledBindings = FALSE;
    CBindingSet BindingSet;
    CComponentList::iterator iter;
    CComponent* pComponent;

    // Generate a full set of bindings so we test persisting them as
    // disabled bindings, but only if we don't already have disabled
    // bindings.
    //
    if (0 == pNetConfig->Core.DisabledBindings.CountBindPaths())
    {
        fClearDisabledBindings = TRUE;

        for (iter =  pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent,
                    GBF_ADD_TO_BINDSET,
                    &pNetConfig->Core.DisabledBindings);
            if (S_OK != hr) return;
        }
    }

    PBYTE pbBuf;
    ULONG cbBuf;

    hr = HrSaveNetworkConfigurationToBufferWithAlloc (
            pNetConfig, &pbBuf, &cbBuf);
    if (S_OK == hr)
    {
        CNetConfig NetConfigCopy;

        hr = HrLoadNetworkConfigurationFromBuffer (
                pbBuf, cbBuf, &NetConfigCopy);
        if (S_OK == hr)
        {
            PBYTE pbBufCopy;
            ULONG cbBufCopy;

            hr = HrSaveNetworkConfigurationToBufferWithAlloc (
                    &NetConfigCopy, &pbBufCopy, &cbBufCopy);
            if (S_OK == hr)
            {
                if ((cbBufCopy == cbBuf) && (0 == memcmp(pbBufCopy, pbBuf, cbBuf)))
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "Passed Save/Load diagnostic.  (%d bytes)\n", cbBuf);
                }
                else
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "FAILED compare for Save/Load diagnostic.\n");
                }

                MemFree (pbBufCopy);
            }
        }

        MemFree (pbBuf);
    }

    // Leave the disabled bindings as we found them.
    //
    if (fClearDisabledBindings)
    {
        pNetConfig->Core.DisabledBindings.Clear();
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Save/Load diagnostic.\n");
    }
}

VOID
CNetCfgInternalDiagnostic::DoWriteLockDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    BOOL fFailed = FALSE;

    PromptForLeakCheck (pOptions, "WriteLock diagnostic...(dump heap)");

    hr = CComCreator<CComObject <CImplINetCfg> >::CreateInstance(
            NULL, IID_INetCfg, (VOID**)&pINetCfg);
    if (S_OK == hr)
    {
        PWSTR psz;

        hr = pINetCfg->IsWriteLocked (&psz);
        if (S_FALSE != hr) fFailed = TRUE;
        if (psz) fFailed = TRUE;

        hr = pINetCfg->AcquireWriteLock (100, L"ncdiag", &psz);
        if (S_OK != hr) fFailed = TRUE;
        if (psz) fFailed = TRUE;

        if (S_OK == hr)
        {
            hr = pINetCfg->IsWriteLocked (&psz);
            if (S_OK != hr) fFailed = TRUE;
            if (!psz) fFailed = TRUE;

            if (S_OK == hr)
            {
                if (0 != wcscmp(L"ncdiag", psz))
                {
                    fFailed = TRUE;
                }
            }

            CoTaskMemFree (psz);

            hr = pINetCfg->ReleaseWriteLock ();
            if (S_OK != hr) fFailed = TRUE;

            hr = pINetCfg->IsWriteLocked (&psz);
            if (S_FALSE != hr) fFailed = TRUE;
            if (psz) fFailed = TRUE;
        }

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (!fFailed)
    {
        PromptForLeakCheck (pOptions, "WriteLock diagnostic...(dump heap and compare)");
        g_pDiagCtx->Printf (ttidBeDiag, "Passed WriteLock diagnostic.\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED WriteLock diagnostic.\n");
    }
}

VOID
CNetCfgInternalDiagnostic::CmdFullDiagnostic (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    DoCreateReleaseDiagnostic (pOptions, TRUE);
    if (pOptions->fLeakCheck)
    {
        DoCreateReleaseDiagnostic (pOptions, FALSE);
    }

    DoEnumAllDiagnostic (pOptions);

    DoSaveLoadDiagnostic (pOptions, pNetConfig);

    DoWriteLockDiagnostic (pOptions, pNetConfig);
}

VOID
CmdAddComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Add component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgClassSetup* pSetup;

        hr = pINetCfg->QueryNetCfgClass (
                &pOptions->ClassGuid,
                IID_INetCfgClassSetup,
                (VOID**)&pSetup);

        if (S_OK == hr)
        {
            OBO_TOKEN OboToken;
            INetCfgComponent* pIComp;

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_USER;

            hr = pSetup->Install (
                    pOptions->pszInfId,
                    &OboToken,
                    0, 0, NULL, NULL,
                    &pIComp);

            if (SUCCEEDED(hr))
            {
                ReleaseObj (pIComp);
            }

            if (NETCFG_S_REBOOT == hr)
            {
                hr = S_OK;
                g_pDiagCtx->Printf (ttidBeDiag, "%S was installed, but a reboot is required.\n",
                    pOptions->pszInfId);
            }
            else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
                g_pDiagCtx->Printf (ttidBeDiag, "The INF file for %S could not be found.\n",
                    pOptions->pszInfId);
            }

            ReleaseObj (pSetup);
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Add component.\n");
    }

    PromptForLeakCheck (pOptions, "Add component...(dump heap and compare)");
}

VOID
CmdAddRemoveStress (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    NETCLASS Class;
    PCWSTR pszInfId;
    PRODUCT_FLAVOR Flavor;
    BOOL fPrompted;

    static const struct
    {
        NETCLASS    Class;
        PCWSTR      pszInfId;
        BOOL        fServerOnly;
    } aPassInfo [] =
    {
        { NC_NETCLIENT,  L"ms_msclient",    FALSE },
        { NC_NETCLIENT,  L"ms_nwclient",    FALSE },
//        { NC_NETSERVICE, L"ms_fpnw",        FALSE },    // requries copy files
        { NC_NETSERVICE, L"ms_netbios",     FALSE },
        { NC_NETSERVICE, L"ms_nwsapagent",  FALSE },
        { NC_NETSERVICE, L"ms_psched",      FALSE },
        { NC_NETSERVICE, L"ms_server",      FALSE },
//        { NC_NETSERVICE, L"ms_wlbs",        FALSE },
        { NC_NETTRANS,   L"ms_appletalk",   FALSE },
        { NC_NETTRANS,   L"ms_atmarps",     TRUE },
        { NC_NETTRANS,   L"ms_atmlane",     FALSE },
        { NC_NETTRANS,   L"ms_atmuni",      FALSE },
        { NC_NETTRANS,   L"ms_irda",        FALSE },
//        { NC_NETTRANS,   L"ms_isotpsys",    FALSE },
        { NC_NETTRANS,   L"ms_rawwan",      FALSE },
//        { NC_NETTRANS,   L"ms_streams",     FALSE },
//        { NC_NETTRANS,   L"ms_tcpip",       FALSE },
    };

    GetProductFlavor (NULL, &Flavor);

    fPrompted = FALSE;

    g_pDiagCtx->SetFlags (
        DF_SHOW_CONSOLE_OUTPUT | DF_DONT_START_SERVICES |
        DF_DONT_DO_PNP_BINDS | DF_SUPRESS_E_NEED_REBOOT);

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        UINT cSkip = 0;

        for (BOOL fInstall = TRUE;
             !_kbhit() && (S_OK == hr);
             fInstall = !fInstall)
        {
            for (UINT i = cSkip;
                 (i < celems(aPassInfo)) && (S_OK == hr);
                 i += (1 + cSkip))
            {
                INetCfgClassSetup* pSetup;
                INetCfgComponent* pIComp;

                if (aPassInfo[i].fServerOnly && (PF_WORKSTATION == Flavor))
                {
                    continue;
                }

                Class    = aPassInfo[i].Class;
                pszInfId = aPassInfo[i].pszInfId;

                if (fInstall)
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "--------------------\n"
                        "Installing %S\n", pszInfId);

                    hr = pINetCfg->QueryNetCfgClass (
                            MAP_NETCLASS_TO_GUID[Class],
                            IID_INetCfgClassSetup,
                            (VOID**)&pSetup);

                    if (S_OK == hr)
                    {
                        OBO_TOKEN OboToken;

                        ZeroMemory (&OboToken, sizeof(OboToken));
                        OboToken.Type = OBO_USER;

                        hr = pSetup->Install (
                                pszInfId,
                                &OboToken,
                                0, 0, NULL, NULL,
                                &pIComp);

                        if (SUCCEEDED(hr))
                        {
                            ReleaseObj (pIComp);
                        }

                        if (NETCFG_S_REBOOT == hr)
                        {
                            hr = S_OK;
                            g_pDiagCtx->Printf (ttidBeDiag, "%S was installed, but a reboot is required.\n",
                                pszInfId);
                        }

                        ReleaseObj (pSetup);
                    }
                }
                else
                {
                    hr = pINetCfg->FindComponent (pszInfId, &pIComp);
                    if (S_OK == hr)
                    {
                        GUID ClassGuid;

                        g_pDiagCtx->Printf (ttidBeDiag, "--------------------\n"
                            "Removing %S\n", pszInfId);

                        hr = pIComp->GetClassGuid (&ClassGuid);
                        if (S_OK == hr)
                        {
                            hr = pINetCfg->QueryNetCfgClass (
                                    &ClassGuid,
                                    IID_INetCfgClassSetup,
                                    (VOID**)&pSetup);

                            if (S_OK == hr)
                            {
                                OBO_TOKEN OboToken;

                                ZeroMemory (&OboToken, sizeof(OboToken));
                                OboToken.Type = OBO_USER;

                                hr = pSetup->DeInstall (
                                        pIComp,
                                        &OboToken,
                                        NULL);

                                if (NETCFG_S_REBOOT == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                                        pszInfId);
                                }

                                if (NETCFG_S_STILL_REFERENCED == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S is still referenced\n",
                                        pszInfId);
                                }

                                if (E_INVALIDARG == hr)
                                {
                                    hr = S_OK;
                                    g_pDiagCtx->Printf (ttidBeDiag, "%S is installed, but not on behalf of "
                                        "the user, so we can't remove it.  (Proceeding.)\n",
                                        pszInfId);
                                }

                                ReleaseObj (pSetup);
                            }
                        }

                        ReleaseObj (pIComp);
                    }
                    else if (S_FALSE == hr)
                    {
                        hr = S_OK;
                    }
                }
            }

            cSkip++;
            if (cSkip >= celems(aPassInfo))
            {
                cSkip = 0;
            }

            g_pDiagCtx->Printf (ttidBeDiag, "\n");

            if (!fPrompted)
            {
                PromptForLeakCheck (pOptions, "Add/Remove stress...(dump heap)");
                fPrompted = TRUE;
            }
        }

        if (S_OK == hr)
        {
            _getch ();
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Add/Remove stress component.\n");
    }

    if (fPrompted)
    {
        PromptForLeakCheck (pOptions, "Add/Remove stress...(dump heap and compare)");
    }
}

VOID
CmdCleanup (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    NETCLASS Class;
    PCWSTR pszSubtree;
    HKEY hkeySubtree;
    DWORD dwIndex;
    HKEY hkeyInstance;
    GUID InstanceGuid;
    BOOL fDeleteKey;
    WCHAR szInfPath [_MAX_PATH];
    WCHAR szInfSection [_MAX_PATH];
    DWORD cbData;

    static const struct
    {
        NETCLASS    Class;
        PCWSTR      pszSubtree;
    } aPassInfo [] =
    {
        { NC_NET,        NULL },
        { NC_INFRARED,   NULL },
        { NC_NETTRANS,   NULL },
        { NC_NETCLIENT,  NULL },
        { NC_NETSERVICE, NULL },
        { NC_NET,        L"System\\CurrentControlSet\\Control\\Network\\{4d36e972-e325-11ce-bfc1-08002be10318}" },
    };

    for (UINT i = 0; i < celems(aPassInfo); i++)
    {
        Class      = aPassInfo[i].Class;
        pszSubtree = aPassInfo[i].pszSubtree;

        Assert (FIsValidNetClass(Class));

        if (!pszSubtree)
        {
            pszSubtree = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
        }

        // Play it safe and assume we don't be deleting anything.
        //
        fDeleteKey = FALSE;

        if (!FIsEnumerated (Class))
        {
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                    pszSubtree,
                    KEY_READ,
                    &hkeySubtree);

            if (S_OK == hr)
            {
                DWORD cchGuid;
                WCHAR szInstanceGuid [c_cchGuidWithTerm];
                FILETIME ftLastWrite;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    fDeleteKey = FALSE;

                    cchGuid = celems(szInstanceGuid);

                    hr = HrRegEnumKeyEx (
                            hkeySubtree, dwIndex, szInstanceGuid, &cchGuid,
                            NULL, NULL, &ftLastWrite);

                    if ((S_OK == hr) && ((c_cchGuidWithTerm-1) == cchGuid))
                    {
                        hr = IIDFromString (szInstanceGuid, &InstanceGuid);
                        if (S_OK == hr)
                        {
                            if (!pNetConfig->Core.Components.PFindComponentByInstanceGuid(&InstanceGuid))
                            {
                                fDeleteKey = TRUE;

                                hr = HrRegOpenKeyEx (
                                        hkeySubtree,
                                        szInstanceGuid,
                                        KEY_READ,
                                        &hkeyInstance);

                                if (S_OK == hr)
                                {
                                    *szInfPath = 0;
                                    *szInfSection = 0;

                                    cbData = sizeof(szInfPath);
                                    HrRegQuerySzBuffer (hkeyInstance,
                                            REGSTR_VAL_INFPATH,
                                            szInfPath, &cbData);

                                    cbData = sizeof(szInfSection) - sizeof(L".Remove");
                                    HrRegQuerySzBuffer (hkeyInstance,
                                            REGSTR_VAL_INFSECTION,
                                            szInfSection, &cbData);

                                    if (*szInfPath && *szInfSection)
                                    {
                                        HINF hinf;

                                        hr = HrSetupOpenInfFile (
                                                szInfPath,
                                                NULL, INF_STYLE_WIN4, NULL,
                                                &hinf);

                                        if (S_OK == hr)
                                        {
                                            wcscat (szInfSection, L".Remove");

                                            g_pDiagCtx->Printf (ttidBeDiag, "Running %S...\n", szInfSection);

                                            hr = HrCiDoCompleteSectionInstall(
                                                    hinf, hkeyInstance,
                                                    szInfSection, NULL,
                                                    FIsEnumerated(Class));

                                            SetupCloseInfFile (hinf);
                                        }


                                    }

                                    RegCloseKey (hkeyInstance);
                                }
                            }
                        }

                        if (fDeleteKey)
                        {
                            g_pDiagCtx->Printf (ttidBeDiag, "Deleting tree %S...\n", szInstanceGuid);
                            (VOID) HrRegDeleteKeyTree (hkeySubtree, szInstanceGuid);
                            fDeleteKey = FALSE;

                            // Back the index up by one since we just
                            // delete the current element.
                            //
                            dwIndex--;
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeySubtree);
            }
        }
        else
        {

            HDEVINFO hdi;

            hr = HrSetupDiGetClassDevs (MAP_NETCLASS_TO_GUID[Class],
                    NULL, NULL, DIGCF_PROFILE, &hdi);

            if (S_OK == hr)
            {
                SP_DEVINFO_DATA deid;
                WCHAR szPnpId [2 * _MAX_PATH];
                BOOL fr;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex, &deid);

                    if (S_OK == hr)
                    {
                        fr = SetupDiGetDeviceInstanceId (
                                hdi, &deid,
                                szPnpId, celems(szPnpId), NULL);

                        if (fr)
                        {
                            if (!pNetConfig->Core.Components.PFindComponentByPnpId(szPnpId))
                            {
                                g_pDiagCtx->Printf (ttidBeDiag, "Removing %S...\n", szPnpId);

                                ADAPTER_REMOVE_PARAMS arp = {0};
                                CiSetReservedField (hdi, &deid, &arp);
                                hr = HrSetupDiCallClassInstaller (
                                        DIF_REMOVE, hdi, &deid);
                                CiClearReservedField (hdi, &deid);
                            }
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }
}

VOID
CmdRemoveComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Remove component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgComponent* pIComp;

        hr = pINetCfg->FindComponent (pOptions->pszInfId, &pIComp);
        if (S_OK == hr)
        {
            GUID ClassGuid;

            hr = pIComp->GetClassGuid (&ClassGuid);
            if (S_OK == hr)
            {
                INetCfgClassSetup* pSetup;

                hr = pINetCfg->QueryNetCfgClass (
                        &ClassGuid,
                        IID_INetCfgClassSetup,
                        (VOID**)&pSetup);

                if (S_OK == hr)
                {
                    OBO_TOKEN OboToken;

                    ZeroMemory (&OboToken, sizeof(OboToken));
                    OboToken.Type = OBO_USER;

                    hr = pSetup->DeInstall (
                            pIComp,
                            &OboToken,
                            NULL);

                    if (NETCFG_S_REBOOT == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                            pOptions->pszInfId);
                    }

                    if (NETCFG_S_STILL_REFERENCED == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S is still referenced\n",
                            pOptions->pszInfId);
                    }

                    if (E_INVALIDARG == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S is installed, but not on behalf of "
                            "the user, so it was not removed.\n",
                            pOptions->pszInfId);
                    }

                    ReleaseObj (pSetup);
                }
            }

            ReleaseObj (pIComp);
        }
        else if (S_FALSE == hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S was not found.\n", pOptions->pszInfId);
            hr = S_OK;
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
    else if (NETCFG_E_NEED_REBOOT == hr)
    {
        hr = S_OK;
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Remove component.\n");
    }

    PromptForLeakCheck (pOptions, "Remove component...(dump heap and compare)");
}

VOID
CmdUpdateComponent (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    PromptForLeakCheck (pOptions, "Update component...(dump heap)");

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgComponent* pIComp;

        hr = pINetCfg->FindComponent (pOptions->pszInfId, &pIComp);
        if (S_OK == hr)
        {
            INetCfgInternalSetup* pSetup;

            hr = pINetCfg->GetUnknown()->QueryInterface (
                    IID_INetCfgInternalSetup,
                    (VOID**)&pSetup);

            if (S_OK == hr)
            {
                hr = pSetup->UpdateNonEnumeratedComponent (
                        pIComp,
                        NSF_POSTSYSINSTALL,
                        0);

                if (S_OK == hr)
                {
                    hr = pINetCfg->Apply ();

                    if (NETCFG_S_REBOOT == hr)
                    {
                        hr = S_OK;
                        g_pDiagCtx->Printf (ttidBeDiag, "%S was removed, but a reboot is required.\n",
                            pOptions->pszInfId);
                    }
                }

                ReleaseObj (pSetup);
            }

            ReleaseObj (pIComp);
        }
        else if (S_FALSE == hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S was not found.\n", pOptions->pszInfId);
            hr = S_OK;
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
    else if (NETCFG_E_NEED_REBOOT == hr)
    {
        hr = S_OK;
    }

    if (S_OK != hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "FAILED Update component.\n");
    }

    PromptForLeakCheck (pOptions, "Update component...(dump heap and compare)");
}

VOID
CmdRemoveReferences (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    Assert (pOptions->pszInfId);

    CComponent* pComponent;

    pComponent = pNetConfig->Core.Components.PFindComponentByInfId (
                    pOptions->pszInfId, NULL);

    if (pComponent)
    {
        pComponent->Refs.RemoveAllReferences();

        HrSaveNetworkConfigurationToRegistry (pNetConfig);
    }
}

VOID
CmdShowBindings (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;

    CComponent* pComponent;
    CBindingSet BindingSet;
    tstring strBindingSet;

    if (SHOW_DISABLED == pOptions->ShowBindParam)
    {
        pNetConfig->Core.DisabledBindings.Printf (ttidBeDiag, NULL);
        return;
    }
    else if (CST_BY_NAME == pOptions->CompSpecifier.Type)
    {
        pComponent = pNetConfig->Core.Components.PFindComponentByPnpId (
                        pOptions->CompSpecifier.pszInfOrPnpId);

        if (!pComponent)
        {
            pComponent = pNetConfig->Core.Components.PFindComponentByInfId (
                            pOptions->CompSpecifier.pszInfOrPnpId, NULL);
        }

        if (!pComponent)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "Component not found.");
            return;
        }

        if (SHOW_BELOW == pOptions->ShowBindParam)
        {
            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
        else if (SHOW_INVOLVING == pOptions->ShowBindParam)
        {
            hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
        if ((SHOW_UPPER == pOptions->ShowBindParam) &&
            FIsEnumerated(pComponent->Class()))
        {
            hr = pNetConfig->Core.HrGetComponentUpperBindings (
                    pComponent, GBF_DEFAULT, &BindingSet);
        }
    }
    else if (CST_ALL == pOptions->CompSpecifier.Type)
    {
        CComponentList::const_iterator iter;

        for (iter =  pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pNetConfig->Core.HrGetComponentBindings (
                    pComponent,
                    GBF_ADD_TO_BINDSET,
                    &BindingSet);
            if (S_OK != hr) break;
        }
    }

    if ((S_OK == hr) && !BindingSet.FIsEmpty())
    {
        BindingSet.Printf (ttidBeDiag, NULL);
    }
}

VOID
CmdShowComponents (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    WCHAR szBuffer [256];
    CHAR* pszNetClass;
    UINT CountRefdBy;
    UINT i;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        StringFromGUID2 (pComponent->m_InstanceGuid,
            szBuffer, celems(szBuffer));

        switch (pComponent->Class())
        {
            case NC_NET:
                pszNetClass = "NET      ";
                break;

            case NC_INFRARED:
                pszNetClass = "INFRARED ";
                break;

            case NC_NETTRANS:
                pszNetClass = "TRANSPORT";
                break;

            case NC_NETCLIENT:
                pszNetClass = "CLIENT   ";
                break;

            case NC_NETSERVICE:
                pszNetClass = "SERVICE  ";
                break;

            default:
                pszNetClass = "(Invalid)";
                break;
        }

        tstring     strChars;

        SzFromCharacteristics(pComponent->m_dwCharacter, &strChars);

        g_pDiagCtx->Printf (ttidBeDiag,
            "\n"
            "%S   %S\n"                                 // InfId   PnpId
            "            Description:  %S\n"
            "                  Class:  %s\n"
            "              Character:  (0x%08x) %S\n"
            "                   Guid:  %S\n"
            "          NotifyObject?:  %s\n"
            "               BindForm:  %S\n"
            "               BindName:  %S\n"
            "   Service (CoServices):  %S  (%S)\n"
            "         Ref'd by User?:  %s\n",
            pComponent->m_pszInfId,
            (pComponent->m_pszPnpId) ? pComponent->m_pszPnpId : L"",
            (pComponent->Ext.PszDescription()) ? pComponent->Ext.PszDescription() : L"<no description>",
            pszNetClass, pComponent->m_dwCharacter, strChars.c_str(), szBuffer,
            pComponent->Ext.FHasNotifyObject() ? "Yes" : "No",
            (pComponent->Ext.PszBindForm()) ? pComponent->Ext.PszBindForm() : L"<default>",
            pComponent->Ext.PszBindName(),
            (pComponent->Ext.PszService()) ? pComponent->Ext.PszService() : L"(none)",
            (pComponent->Ext.PszCoServices()) ? pComponent->Ext.PszCoServices() : L"none",
            (pComponent->Refs.FIsReferencedByUser()) ? "Yes" : "No");

        CountRefdBy = pComponent->Refs.CountComponentsReferencedBy();
        if (CountRefdBy)
        {
            *szBuffer = 0;

            for (i = 0; i < CountRefdBy; i++)
            {
                CComponent* pRefdBy;
                pRefdBy = pComponent->Refs.PComponentReferencedByAtIndex(i);
                Assert (pRefdBy);

                wcscat (szBuffer, pRefdBy->PszGetPnpIdOrInfId());
                wcscat (szBuffer, L" ");
            }
        }
        else
        {
            wcscpy (szBuffer, L"(none)");
        }
        g_pDiagCtx->Printf (ttidBeDiag,
            "    Ref'd by Components:  %S\n", szBuffer);

        CountRefdBy = pComponent->Refs.CountSoftwareReferencedBy();
        if (CountRefdBy)
        {
            *szBuffer = 0;

            for (i = 0; i < CountRefdBy; i++)
            {
                const CWideString* pRefdBy;
                pRefdBy = pComponent->Refs.PSoftwareReferencedByAtIndex(i);
                Assert (pRefdBy);

                wcscat (szBuffer, pRefdBy->c_str());
                wcscat (szBuffer, L" ");
            }
        }
        else
        {
            wcscpy (szBuffer, L"(none)");
        }
        g_pDiagCtx->Printf (ttidBeDiag,
            "      Ref'd by Software:  %S\n", szBuffer);


    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");
}

VOID
CmdShowStackTable (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    const CStackEntry*  pStackEntry;

    g_pDiagCtx->Printf (ttidBeDiag, "\n%15s | %s\n"
        "---------------------------------\n",
        "Upper",
        "Lower");

    for (pStackEntry  = pNetConfig->Core.StackTable.begin();
         pStackEntry != pNetConfig->Core.StackTable.end();
         pStackEntry++)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "%15S | %S\n",
            pStackEntry->pUpper->PszGetPnpIdOrInfId(),
            pStackEntry->pLower->PszGetPnpIdOrInfId());
    }

    g_pDiagCtx->Printf (ttidBeDiag, "\n");
    g_pDiagCtx->Printf (ttidBeDiag, "WAN adapters are ordered %s\n\n",
        (pNetConfig->Core.StackTable.m_fWanAdaptersFirst)
            ? "first" : "last");
}

VOID
CmdShowLanAdapterPnpIds (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!FSubstringMatch (pComponent->Ext.PszUpperRange (), L"ndis5",
                NULL, NULL))
        {
            continue;
        }

        g_pDiagCtx->Printf (ttidBeDiag, "%S\n", pComponent->m_pszPnpId);
    }
}

VOID
CmdEnableOrDisableBinding (
    IN const DIAG_OPTIONS* pOptions,
    IN BOOL fEnable)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgBindingPath* pIPath;

        hr = HrFindBindPath (pINetCfg, pOptions->pszBindPath, &pIPath, NULL);
        if ((S_OK == hr) && pIPath)
        {
            pIPath->Enable (fEnable);

            ReleaseObj (pIPath);
        }

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to %s binding\n",
                (fEnable) ? "enable" : "disable");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdMoveBinding (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgBindingPath* pIPath;
        INetCfgBindingPath* pIOtherPath;
        INetCfgComponentBindings* pIOwner;

        hr = HrFindBindPath (pINetCfg, pOptions->pszBindPath, &pIPath, &pIOwner);
        if ((S_OK == hr) && pIPath)
        {
            if (0 == _wcsicmp(pOptions->pszOtherBindPath, L"null"))
            {
                pIOtherPath = NULL;
            }
            else
            {
                hr = HrFindBindPath (pINetCfg, pOptions->pszOtherBindPath,
                        &pIOtherPath, NULL);
            }

            if (S_OK == hr)
            {
                if (pOptions->fMoveBefore)
                {
                    hr = pIOwner->MoveBefore (pIPath, pIOtherPath);
                }
                else
                {
                    hr = pIOwner->MoveAfter (pIPath, pIOtherPath);
                }

                ReleaseObj (pIOtherPath);
            }

            ReleaseObj (pIPath);
            ReleaseObj (pIOwner);
        }

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to move binding\n");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdWriteBindings (
    IN const DIAG_OPTIONS* pOptions OPTIONAL,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    CRegistryBindingsContext RegBindCtx;

    hr = RegBindCtx.HrPrepare (pNetConfig);
    if (S_OK != hr)
    {
        return;
    }

    for (iter =  pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = RegBindCtx.HrWriteBindingsForComponent (pComponent);
    }
}

VOID
CmdSetWanOrder (
    IN const DIAG_OPTIONS* pOptions)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;

    hr = HrCreateINetCfg (TRUE, &pINetCfg);
    if (S_OK == hr)
    {
        INetCfgSpecialCase* pSpecialCase;

        hr = pINetCfg->GetUnknown()->QueryInterface (
                IID_INetCfgSpecialCase,
                (VOID**)&pSpecialCase);
        Assert (S_OK == hr);

        hr = pSpecialCase->SetWanAdaptersFirst (pOptions->fWanAdaptersFirst);

        ReleaseObj (pSpecialCase);

        hr = pINetCfg->Apply ();
        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "FAILED to move binding\n");
        }

        HRESULT hrT = pINetCfg->Uninitialize ();
        Assert (S_OK == hrT);

        ReleaseObj (pINetCfg->GetUnknown());
    }
}

VOID
CmdShowLanaDiag (
    IN const DIAG_OPTIONS* pOptions)
{
    CLanaMap LanaMap;
    HRESULT hr;

    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "NetBios Bindings and Lana Information\n"
                "-------------------------------------\n");
        CWideString str;
        LanaMap.Dump (&str);
        g_pDiagCtx->Printf (ttidBeDiag, "%S", str.c_str());

        HKEY hkeyNetBios;
        hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE,
                L"System\\currentcontrolset\\services\\netbios\\parameters",
                KEY_READ, &hkeyNetBios);

        if (S_OK == hr)
        {
            DWORD MaxLana;
            hr = HrRegQueryDword (hkeyNetBios, L"MaxLana", &MaxLana);
            if (S_OK == hr)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "\nMaximum Lana: %d\n", MaxLana);
            }
            RegCloseKey (hkeyNetBios);
        }
    }
}

HRESULT
HrPrintComponentDescriptionsFromBindPath (
    IN PCWSTR pszBindPath,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;
    PCWSTR pszBindName;
    PCWSTR pszEnd;
    DWORD cchComponent;
    CComponent* pComponent;
    WCHAR szComponentBindName[_MAX_PATH] = {0};

    Assert (pszBindPath && *pszBindPath);

    GetFirstComponentFromBindPath (pszBindPath, &pszBindName,
            &cchComponent);

    while (pszBindName && *pszBindName)
    {
        wcsncpy (szComponentBindName, pszBindName, cchComponent);

        pComponent = pNetConfig->Core.Components.
                PFindComponentByBindName (NC_INVALID, szComponentBindName);

        if (pComponent)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "-->%S", pComponent->Ext.PszDescription());
        }
#ifdef ENABLETRACE
        else
        {
            g_pDiagCtx->Printf (ttidBeDiag, "%S", szComponentBindName);
        }
#endif // ENABLETRACE

        pszBindName = wcschr (pszBindName, L'_');
        if (pszBindName)
        {
            pszBindName++;
            pszEnd = wcschr (pszBindName, L'_');
            if (pszEnd)
            {
                cchComponent = (DWORD)(pszEnd - pszBindName);
            }
            else
            {
                cchComponent = wcslen (pszBindName);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrPrintComponentDescriptionsFromBindPath");
    return hr;
}

VOID
CmdShowLanaPaths (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    CLanaMap LanaMap;
    PCWSTR pszBindPath;
    CLanaEntry* pEntry;

    PromptForLeakCheck (pOptions,
        "Show Lana UI info diagnostic...(dump heap)");
    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents();
    if (S_OK != hr)
    {
        return;
    }

    hr = LanaMap.HrLoadLanaMap();
    if (S_OK == hr)
    {
        PCWSTR pszBindName;
        PCWSTR pszEnd;
        DWORD cchComponent;
        CComponent* pComponent;
        WCHAR szComponentBindName[_MAX_PATH] = {0};
        for (pEntry = LanaMap.begin(); pEntry != LanaMap.end();
                pEntry++)
        {
            if (1 == pEntry->RegLanaEntry.Exported)
            {
                g_pDiagCtx->Printf (ttidNcDiag, "Lana: %3d\n",
                        pEntry->RegLanaEntry.LanaNumber);

                pszBindPath = pEntry->pszBindPath;
                GetFirstComponentFromBindPath (pszBindPath,
                        &pszBindName, &cchComponent);

                while (pszBindName && *pszBindName)
                {
                    wcsncpy (szComponentBindName, pszBindName, cchComponent);
                    szComponentBindName[cchComponent] = 0;

                    pComponent = pNetConfig->Core.Components.
                            PFindComponentByBindName (NC_INVALID,
                            szComponentBindName);

                    if (pComponent)
                    {
                        g_pDiagCtx->Printf (ttidNcDiag, "-->%S",
                                pComponent->Ext.PszDescription());
                    }
            #ifdef ENABLETRACE
                    else
                    {
                        g_pDiagCtx->Printf (ttidNcDiag, "-->%S", szComponentBindName);
                    }
            #endif // ENABLETRACE

                    pszBindName = wcschr (pszBindName, L'_');
                    if (pszBindName)
                    {
                        pszBindName++;
                        pszEnd = wcschr (pszBindName, L'_');
                        if (pszEnd)
                        {
                            cchComponent = (DWORD)(pszEnd - pszBindName);
                        }
                        else
                        {
                            cchComponent = wcslen (pszBindName);
                        }
                    }
                }

                if (FAILED(hr))
                {
                    break;
                }

                g_pDiagCtx->Printf (ttidNcDiag, "\n\n");
            }
        }
    }
    PromptForLeakCheck (pOptions,
        "Show Lana UI info diagnostic...(dump heap and compare)");
}

VOID
CmdSetLanaNumber (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    CLanaMap LanaMap;
    HRESULT hr;

    hr = pNetConfig->HrEnsureExternalDataLoadedForAllComponents();
    if (S_OK != hr)
    {
        return;
    }

    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        if (pOptions->OldLanaNumber != pOptions->NewLanaNumber)
        {
            hr = LanaMap.HrSetLanaNumber (pOptions->OldLanaNumber,
                    pOptions->NewLanaNumber);
            if (S_OK == hr)
            {
                hr = LanaMap.HrWriteLanaConfiguration (
                        pNetConfig->Core.Components);

                g_pDiagCtx->Printf (ttidNcDiag, "\nLana changed.\n");
            }
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nNo change.\n");
        }
    }

    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_OBJECT_NOT_FOUND) == hr)
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nThe old lana number is not currently "
                    "assigned to a bind path.\n");
        }
        else if (HRESULT_FROM_WIN32(ERROR_ALREADY_EXISTS) == hr)
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nThe new lana number is currently assigned "
                    "to a bind path.\n");
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nError %X occurred\n", hr);
        }
    }
}

VOID
CmdRewriteLanaInfo (
    IN const DIAG_OPTIONS* pOptions,
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;
    const CComponent* pComponent;
    CRegistryBindingsContext RegBindCtx;

    hr = RegBindCtx.HrPrepare (pNetConfig);
    if (S_OK == hr)
    {
        pComponent = pNetConfig->Core.Components.
                PFindComponentByInfId (L"MS_NetBios", NULL);

        if (pComponent)
        {
            hr = RegBindCtx.HrWriteBindingsForComponent (pComponent);
        }
        else
        {
            g_pDiagCtx->Printf (ttidNcDiag, "\nNetBios is not installed.\n");
        }
    }
}

EXTERN_C
VOID
WINAPI
NetCfgDiagFromCommandArgs (
    IN DIAG_OPTIONS* pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    CNetConfig NetConfig;
    HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

    switch (pOptions->Command)
    {
        case CMD_SHOW_BINDINGS:
            CmdShowBindings (pOptions, &NetConfig);
            break;

        case CMD_SHOW_COMPONENTS:
            CmdShowComponents (pOptions, &NetConfig);
            break;

        case CMD_SHOW_STACK_TABLE:
            CmdShowStackTable (pOptions, &NetConfig);
            break;

        case CMD_SHOW_LAN_ADAPTER_PNPIDS:
            CmdShowLanAdapterPnpIds (pOptions, &NetConfig);
            break;

        case CMD_ADD_COMPONENT:
            CmdAddComponent (pOptions, &NetConfig);
            break;

        case CMD_REMOVE_COMPONENT:
            CmdRemoveComponent (pOptions, &NetConfig);
            break;

        case CMD_UPDATE_COMPONENT:
            CmdUpdateComponent (pOptions, &NetConfig);
            break;

        case CMD_REMOVE_REFS:
            CmdRemoveReferences (pOptions, &NetConfig);
            break;

        case CMD_ENABLE_BINDING:
            CmdEnableOrDisableBinding (pOptions, TRUE);
            break;

        case CMD_DISABLE_BINDING:
            CmdEnableOrDisableBinding (pOptions, FALSE);
            break;

        case CMD_MOVE_BINDING:
            CmdMoveBinding (pOptions);
            break;

        case CMD_WRITE_BINDINGS:
            CmdWriteBindings (pOptions, &NetConfig);
            break;

        case CMD_SET_WANORDER:
            CmdSetWanOrder (pOptions);
            break;

        case CMD_FULL_DIAGNOSTIC:
            CNetCfgInternalDiagnostic::CmdFullDiagnostic (pOptions, &NetConfig);
            break;

        case CMD_CLEANUP:
            CmdCleanup (pOptions, &NetConfig);
            break;

        case CMD_ADD_REMOVE_STRESS:
            CmdAddRemoveStress (pOptions, &NetConfig);
            break;
        default:
            break;
    }

    g_pDiagCtx = NULL;
}

EXTERN_C
VOID
WINAPI
NetCfgDiagRepairRegistryBindings (
    IN FILE* pLogFile)
{
    HRESULT hr;
    BOOL fCoUninitialize = TRUE;

    hr = CoInitializeEx (NULL,
                    COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
    if (FAILED(hr))
    {
        fCoUninitialize = FALSE;
        if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
        }
        else
        {
            fprintf(pLogFile, "CoInitializeEx failed.  (hr=0x%08x)\n", hr);
        }
    }

    if (SUCCEEDED(hr))
    {
        CDiagContext DiagCtx;
        CNetConfig NetConfig;

        DiagCtx.SetFlags (DF_REPAIR_REGISTRY_BINDINGS);
        DiagCtx.SetLogFile (pLogFile);
        g_pDiagCtx = &DiagCtx;

        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);
        if (S_OK == hr)
        {
            CmdWriteBindings (NULL, &NetConfig);
        }
        else
        {
            fprintf(pLogFile,
                    "Failed to load network configuration "
                    "from the registry.  (hr=0x%08x)\n", hr);
        }

        g_pDiagCtx = NULL;

        if (fCoUninitialize)
        {
            CoUninitialize ();
        }
    }
}

EXTERN_C
VOID
WINAPI
LanaCfgFromCommandArgs (
    IN DIAG_OPTIONS* pOptions)
{
    Assert (pOptions);
    Assert (pOptions->pDiagCtx);
    g_pDiagCtx = pOptions->pDiagCtx;

    CNetConfig NetConfig;
    HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

    switch (pOptions->Command)
    {
        case CMD_SHOW_LANA_DIAG:
            CmdShowLanaDiag (pOptions);
            break;
        case CMD_SHOW_LANA_PATHS:
            CmdShowLanaPaths (pOptions, &NetConfig);
            break;
        case CMD_SET_LANA_NUMBER:
            CmdSetLanaNumber (pOptions, &NetConfig);
            break;
        case CMD_REWRITE_LANA_INFO:
            CmdRewriteLanaInfo (pOptions, &NetConfig);
            break;
        default:
            break;
    }

    g_pDiagCtx = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\comprefs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       C O M P R E F S . C P P
//
//  Contents:   Implements the interface to a component's references.  A
//              component can be referenced (installed by) other components,
//              the user, or other software.  This module manages the
//              interface to that data.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "comprefs.h"
#include "icomp.h"
#include "nceh.h"
#include "ncreg.h"

#define REGSTR_KEY_REFNAMES \
    L"SYSTEM\\CurrentControlSet\\Control\\Network\\RefNames"

// Cannot be inline because comprefs.h cannot include comp.h.
//
CComponentReferences::~CComponentReferences ()
{
    Assert (this);

    // Must use delete on m_pData to get destructors of its members
    // to be called.
    //
    delete m_pData;
}

ULONG
CComponentReferences::CountComponentsReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return m_pData->RefByComponents.Count ();
}

ULONG
CComponentReferences::CountSoftwareReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return m_pData->RefBySoftware.size ();
}

ULONG
CComponentReferences::CountTotalReferencedBy () const
{
    Assert (this);

    if (!m_pData)
    {
        return 0;
    }

    return ((m_pData->fRefByUser) ? 1 : 0) +
            m_pData->RefByComponents.Count () +
            m_pData->RefBySoftware.size ();
}

HRESULT
HrGetSoftwareOboTokenKey (
    IN const OBO_TOKEN* pOboToken,
    BOOL fRegister,
    OUT PWSTR* ppszKey)
{
    HRESULT hr;
    UINT cch;

    Assert (pOboToken);
    Assert (OBO_SOFTWARE == pOboToken->Type);
    Assert (pOboToken->pszwManufacturer && *pOboToken->pszwManufacturer);
    Assert (pOboToken->pszwProduct && *pOboToken->pszwProduct);
    Assert (ppszKey);

    cch = wcslen (pOboToken->pszwManufacturer) +
          wcslen (pOboToken->pszwProduct);

    hr = E_OUTOFMEMORY;
    *ppszKey = (PWSTR)MemAlloc ((cch + 1) * sizeof(WCHAR));
    if (*ppszKey)
    {
        hr = S_OK;
        wcscpy (*ppszKey, pOboToken->pszwManufacturer);
        wcscat (*ppszKey, pOboToken->pszwProduct);

        if (fRegister)
        {
            HKEY hkeyRefNames;
            hr = HrRegCreateKeyEx (
                    HKEY_LOCAL_MACHINE,
                    REGSTR_KEY_REFNAMES,
                    REG_OPTION_NON_VOLATILE,
                    KEY_WRITE, NULL, &hkeyRefNames, NULL);

            if (SUCCEEDED(hr))
            {
                hr = HrRegSetSz (
                        hkeyRefNames,
                        *ppszKey,
                        pOboToken->pszwDisplayName);

                RegCloseKey (hkeyRefNames);
            }
            else
            {
                MemFree (*ppszKey);
                *ppszKey = NULL;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrGetSoftwareOboTokenKey");
    return hr;
}

BOOL
CComponentReferences::FIsReferencedByComponent (
    IN const CComponent* pComponent) const
{
    Assert (pComponent);

    if (!m_pData)
    {
        return FALSE;
    }

    return m_pData->RefByComponents.FComponentInList (pComponent);
}


BOOL
CComponentReferences::FIsReferencedByOboToken (
    IN const OBO_TOKEN* pOboToken) const
{
    HRESULT hr;
    BOOL fIsReferenced;
    PWSTR pszKey;

    Assert (pOboToken);

    if (!m_pData)
    {
        return FALSE;
    }

    fIsReferenced = FALSE;

    CComponent* pComponent;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            fIsReferenced = m_pData->fRefByUser;
            break;

        case OBO_COMPONENT:
            // Can't be referenced if there are no references.
            //
            if (m_pData->RefByComponents.Count() > 0)
            {
                pComponent = PComponentFromComInterface (pOboToken->pncc);

                fIsReferenced = m_pData->RefByComponents.FComponentInList (
                                            pComponent);
            }
            break;

        case OBO_SOFTWARE:
            // Can't be referenced if there are no references.
            //
            if (m_pData->RefBySoftware.size() > 0)
            {
                // Get the key for the software token, but don't register
                // the display name.
                //
                hr = HrGetSoftwareOboTokenKey (pOboToken, FALSE, &pszKey);
                if (S_OK == hr)
                {
                    fIsReferenced =
                        find (m_pData->RefBySoftware.begin(),
                              m_pData->RefBySoftware.end(), pszKey) !=
                        m_pData->RefBySoftware.end();

                    MemFree (pszKey);
                }
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
    }

    return fIsReferenced;
}

VOID
CComponentReferences::GetReferenceDescriptionsAsMultiSz (
    IN BYTE* pbBuf OPTIONAL,
    OUT ULONG* pcbBuf) const
{
    ULONG cbBuf;
    ULONG cbBufIn;
    ULONG cb;
    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    vector<CWideString>::const_iterator pStr;

    Assert (this);
    Assert (m_pData);
    Assert (pcbBuf);

    cbBufIn = *pcbBuf;
    cbBuf = 0;

    // Get/Size the component descriptions.
    //
    for (iter  = m_pData->RefByComponents.begin();
         iter != m_pData->RefByComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        cb = CbOfSzAndTermSafe(pComponent->Ext.PszDescription());
        cbBuf += cb;
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            wcscpy ((PWSTR)pbBuf, pComponent->Ext.PszDescription());
            pbBuf += cb;
        }
    }

    // Get/Size the software descriptions.
    //
    if (!m_pData->RefBySoftware.empty())
    {
        HRESULT hr;
        HKEY hkeyRefNames;

        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                REGSTR_KEY_REFNAMES,
                KEY_READ,
                &hkeyRefNames);

        if (S_OK == hr)
        {
            for (pStr  = m_pData->RefBySoftware.begin();
                 pStr != m_pData->RefBySoftware.end();
                 pStr++)
            {
                cb = cbBufIn - cbBuf;

                hr = HrRegQuerySzBuffer (hkeyRefNames, pStr->c_str(),
                        (PWSTR)pbBuf, &cb);

                if (S_OK == hr)
                {
                    cbBuf += cb;

                    if (pbBuf)
                    {
                        pbBuf += cb;
                    }
                }
            }

            RegCloseKey (hkeyRefNames);
        }
    }

    // Terminate the multi-sz.
    //
    cbBuf += sizeof(WCHAR);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(PWSTR)pbBuf = 0;
    }

    // Return the size of the buffer required.
    //
    *pcbBuf = cbBuf;
}

BOOL
CComponentReferences::FIsReferencedByOthers () const
{
    Assert (this);

    if (!m_pData)
    {
        return FALSE;
    }

    return m_pData->fRefByUser ||
           !m_pData->RefByComponents.empty() ||
           !m_pData->RefBySoftware.empty();
}

CComponent*
CComponentReferences::PComponentReferencedByAtIndex (
    IN UINT unIndex) const
{
    Assert (this);

    if (!m_pData)
    {
        return NULL;
    }

    return m_pData->RefByComponents.PGetComponentAtIndex (unIndex);
}

const CWideString*
CComponentReferences::PSoftwareReferencedByAtIndex (
    IN UINT unIndex) const
{
    Assert (this);

    if (!m_pData)
    {
        return NULL;
    }

    return &m_pData->RefBySoftware[unIndex];
}


HRESULT
CComponentReferences::HrEnsureAllocated ()
{
    Assert (this);

    if (m_pData)
    {
        return S_OK;
    }

    HRESULT hr;

    hr = E_OUTOFMEMORY;
    m_pData = new COMPONENT_REFERENCE_DATA;
    if (m_pData)
    {
        ZeroMemory (m_pData, sizeof(COMPONENT_REFERENCE_DATA));
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrEnsureAllocated");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByUser ()
{
    HRESULT hr;

    Assert (this);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        m_pData->fRefByUser = TRUE;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::AddReferenceByUser");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByComponent (
    IN const CComponent* pComponent)
{
    HRESULT hr;

    Assert (this);
    Assert (pComponent);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        // If someone wants to add a reference by the same component
        // multiple times, we'll allow it.  The component only goes in the
        // list once.
        //
        hr = m_pData->RefByComponents.HrInsertComponent (
                pComponent, INS_IGNORE_IF_DUP | INS_NON_SORTED);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceByComponent");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceByOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    Assert (pOboToken);

    HRESULT hr;
    CComponent* pComponent;
    PWSTR pszKey;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            hr = HrAddReferenceByUser ();
            break;

        case OBO_COMPONENT:
            pComponent = PComponentFromComInterface (pOboToken->pncc);

            hr = HrAddReferenceByComponent (pComponent);
            break;

        case OBO_SOFTWARE:
            // Register the display name of the obo token.
            //
            hr = HrGetSoftwareOboTokenKey (pOboToken, TRUE, &pszKey);
            if (S_OK == hr)
            {
                hr = HrAddReferenceBySoftware (pszKey);

                MemFree (pszKey);
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
            hr = E_FAIL;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceByOboToken");
    return hr;
}

HRESULT
CComponentReferences::HrAddReferenceBySoftware (
    IN PCWSTR pszKey)
{
    HRESULT hr;

    Assert (this);
    Assert (pszKey && *pszKey);

    hr = HrEnsureAllocated ();
    if (S_OK == hr)
    {
        // If the key is not in the list, add it.
        //
        if (find (m_pData->RefBySoftware.begin(),
                  m_pData->RefBySoftware.end(), pszKey) ==
            m_pData->RefBySoftware.end())
        {
            NC_TRY
            {
                m_pData->RefBySoftware.push_back (pszKey);
                Assert (S_OK == hr);
            }
            NC_CATCH_BAD_ALLOC
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrAddReferenceBySoftware");
    return hr;
}

VOID
CComponentReferences::RemoveAllReferences()
{
    Assert (this);

    if (m_pData)
    {
        m_pData->fRefByUser = FALSE;
        m_pData->RefByComponents.Clear();
        m_pData->RefBySoftware.clear();
    }
}

HRESULT
CComponentReferences::HrRemoveReferenceByOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    Assert (pOboToken);

    HRESULT hr;
    CComponent* pComponent;
    PWSTR pszKey;

    if (!m_pData)
    {
        return S_OK;
    }

    hr = S_OK;

    switch (pOboToken->Type)
    {
        case OBO_USER:
            // Don't allow the user's reference to be removed until all
            // other references are.  This is to prevent the case where
            // the user wants to remove IPX, but it is still referenced by
            // SAP.  If we remove the user's reference to IPX, then we will
            // report that it was not removed.  If the user then removes
            // SAP, both SAP and IPX will be removed.  While this will
            // certainly work, to end users, they feel that if we tell them
            // we can't remove IPX because it is still referenced, then they
            // believe we have left IPX untouched and they should first remove
            // SAP and then come back and remove IPX.
            //
            if (m_pData->RefByComponents.empty() &&
                m_pData->RefBySoftware.empty())
            {
                m_pData->fRefByUser = FALSE;
            }
            break;

        case OBO_COMPONENT:
            pComponent = PComponentFromComInterface (pOboToken->pncc);

            m_pData->RefByComponents.RemoveComponent(pComponent);
            break;

        case OBO_SOFTWARE:
            // Register the display name of the obo token.
            //
            hr = HrGetSoftwareOboTokenKey (pOboToken, TRUE, &pszKey);
            if (S_OK == hr)
            {
                vector<CWideString>::iterator iter;

                iter = find (m_pData->RefBySoftware.begin(),
                             m_pData->RefBySoftware.end(), pszKey);
                Assert (m_pData->RefBySoftware.end() != iter);

                m_pData->RefBySoftware.erase (iter);

                Assert (m_pData->RefBySoftware.end() ==
                            find (m_pData->RefBySoftware.begin(),
                                  m_pData->RefBySoftware.end(), pszKey));

                MemFree (pszKey);
            }
            break;

        default:
            AssertSz (FALSE, "Invalid obo token");
            hr = E_FAIL;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CComponentReferences::HrRemoveReferenceByOboToken");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ecomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E C O M P . C P P
//
//  Contents:   Implements the interface to a component's external data.
//              External data is that data controlled (or placed) by
//              PnP or the network class installer.  Everything under a
//              component's instance key is considered external data.
//              (Internal data is that data we store in the persisted binary
//              for the network configuration.  See persist.cpp for
//              code that deals with internal data.)
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "comp.h"
#include "ncsetup.h"
#include "util.h"

// constants
const WCHAR c_szHelpText[]           = L"HelpText";

//+---------------------------------------------------------------------------
//
//  Function:   HrBuildBindNameFromBindForm
//
//  Purpose:    Build a bindname from a bindform and component parameters.
//
//  Arguments:
//      pszBindForm       [in]  The components bindform.  This is read from
//                              the Ndi key.  If the component did not specify
//                              it in its Ndi key, pass NULL.
//      Class             [in]  The class of the component.
//      dwCharacteristics [in]  The characteristics of the component.
//      pszServiceName    [in]  The components service name.
//      pszInfId          [in]  The component (device) id.
//      szInstanceGuid    [in]  The instance GUID of the component.
//      ppszBindName      [out] The returned bind string.  This must be freed
//                              with LocalFree.
//
//  Returns:    HRESULT
//
//  Author:     shaunco   6 Jun 1997
//  Modified:   ckotze   21 Dec 2000
//
//  Notes:      The bindform contains replaceable parameters designed to
//              be used with the FormatMessage API.
//                  %1 = pszServiceName
//                  %2 = pszInfId
//                  %3 = szInstanceGuid
//
HRESULT
HrBuildBindNameFromBindForm (
    IN PCWSTR pszBindForm,
    IN NETCLASS Class,
    IN DWORD dwCharacteristics,
    IN PCWSTR pszServiceName,
    IN PCWSTR pszInfId,
    IN const GUID& InstanceGuid,
    OUT PWSTR* ppszBindName)
{
    static const WCHAR c_szBindFormNet       [] = L"%3";
    static const WCHAR c_szBindFormNoService [] = L"%2";
    static const WCHAR c_szBindFormDefault   [] = L"%1";

    WCHAR szInstanceGuid [c_cchGuidWithTerm];
    INT cch;
    DWORD dwRet = 0;
    HRESULT hr = S_OK;

    Assert (ppszBindName);
    Assert (FIsValidNetClass(Class));

    cch = StringFromGUID2 (
                InstanceGuid,
                szInstanceGuid,
                c_cchGuidWithTerm);
    
    Assert (c_cchGuidWithTerm == cch);

    if (FIsPhysicalAdapter(Class, dwCharacteristics))
    {
        // netcards use the the instance guid only
        // We disregard any bind form sent in.
        Assert (szInstanceGuid && *szInstanceGuid);
        pszBindForm = c_szBindFormNet;
    }
    else if (!pszBindForm || !*pszBindForm)
    {
        // Figure out which bindform to use since it wasn't specified.
        //
        if (FIsEnumerated(Class))
        {
            // Virtual adapters use the the instance guid only
            Assert (szInstanceGuid && *szInstanceGuid);
            pszBindForm = c_szBindFormNet;
        }
        else if (pszServiceName && *pszServiceName)
        {
            // use the service name if we have one
            pszBindForm = c_szBindFormDefault;
        }
        else
        {
            // if no service, then use the component id
            Assert (pszInfId && *pszInfId);
            pszBindForm = c_szBindFormNoService;
        }
    }
    AssertSz (pszBindForm && *pszBindForm, "Should have pszBindForm by now.");

    // dwRet is either 0 or the number of chars in the resulting string.  Since 
    // *ppszBindName is either NULL or a valid string, we get the last error if it's
    // a NULL and ignore dwRet.
    dwRet = DwFormatStringWithLocalAlloc (
                pszBindForm, ppszBindName,
                pszServiceName, pszInfId, szInstanceGuid);

    if (*ppszBindName)
    {
        // Underscores are not allowed in the bind name so make a pass
        // to remove them.
        //
        PWSTR pszScan = *ppszBindName;
        while (NULL != (pszScan = wcschr (pszScan, L'_')))
        {
            wcscpy (pszScan, pszScan + 1);
        }
    }
    else
    {
        DWORD dwErr = GetLastError();

        hr = HRESULT_FROM_WIN32(dwErr);
    }

    AssertSz (*ppszBindName,
        "BuildBindNameFromBindForm: DwFormatStringWithLocalAlloc failed.");

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   NcLoadRegUIString
//
//  Purpose:    Wrapper around SHLoadRegUIString, which is used to support MUI.
//
//  Arguments:  same as RegQueryValueEx with lpReserved and lpType removed
//   
//  Returns:    If the function succeeds, the return value is ERROR_SUCCESS
//
//  Notes:      SHLoadRegUIString will read a string of the form
// 
//              @[path\]<dllname>,-<strId>
// 
//              The string with id <strId> is loaded from <dllname>.  If no explicit
//              path is provided then the DLL will be chosen according to pluggable UI
//              specifications, if possible.
// 
//              If the registry string is not of the special form described here,
//              SHLoadRegUIString will return the string intact. 
//
//
LONG NcLoadRegUIString (
    IN HKEY         hkey,
    IN PCWSTR       lpValueName,
    IN OUT LPBYTE   lpData OPTIONAL,
    IN OUT LPDWORD  lpcbData)
{
    const DWORD cchGrow    = 256;   // grows at 256 of WCHAR a time
    DWORD       cchBuffer  = 0;     // buffer size in number of WCHAR
    HRESULT     hr         = S_OK;
    LONG        lr         = ERROR_SUCCESS;
    LPWSTR      pwszBuffer = NULL;  // buffer for the WCHAR string
    DWORD       cbBuffer   = 0;     // the real buffer size in bytes
    
    if ( (NULL == hkey) || (NULL == lpValueName) )
    {
        return ERROR_BAD_ARGUMENTS;
    }

    // The lpcbData parameter can be NULL only if lpData is NULL. 
    if ( (NULL == lpcbData) && (NULL != lpData) )
    {
        return ERROR_BAD_ARGUMENTS;
    }
    if ( (NULL == lpcbData) && (lpData == NULL) )
    {
        // no operation
        return ERROR_SUCCESS;
    }
    
    Assert (lpcbData);
    if ( (*lpcbData > 0) && lpData && IsBadWritePtr(lpData, *lpcbData))
    {
        return ERROR_BAD_ARGUMENTS;
    }
    
    do
    {
        if (pwszBuffer)
        {
            // free the last allocated buffer
            MemFree((LPVOID) pwszBuffer);
        }

        // allocate a larger buffer for the string   
        cchBuffer += cchGrow;
        pwszBuffer = (LPWSTR) MemAlloc (cchBuffer * sizeof(WCHAR));

        if (pwszBuffer == NULL)
        {
            return (ERROR_OUTOFMEMORY);
        }

        // load the MUI enabled string from the registry
        // NOTE: for the buffer size, this API takes number of characters including NULL 
        //       character, not number of bytes for the buffer.
        // SHLoadRegUIStringW(HKEY hkey, LPCWSTR  pszValue, IN OUT LPWSTR pszOutBuf, IN UINT cchOutBuf)
        hr = SHLoadRegUIStringW (hkey, lpValueName, (LPWSTR)pwszBuffer, cchBuffer);
        if (FAILED(hr))
        {
            lr = ERROR_FUNCTION_FAILED;
            goto Exit;
        }

        // Unfortunately, SHLoadRegUIString doesn't have a way to query the
        // buffer size, so we assume more data available.  We'll loop around, 
        // grow the buffer, and try again.
        
    } while ( wcslen(pwszBuffer) == (cchBuffer - 1) ); // retry if the last buffer is fully used
    
    Assert (ERROR_SUCCESS == lr);

    // the actual buffer size requirement in bytes
    cbBuffer = (wcslen(pwszBuffer) + 1 ) * sizeof(WCHAR); 

    // If lpData is NULL, and lpcbData is non-NULL, the function returns ERROR_SUCCESS, 
    // and stores the size of the data, in bytes, in the variable pointed to by lpcbData. 
    // This lets an application determine the best way to allocate a buffer for 
    // the value's data. 
    if ( (NULL == lpData) && lpcbData )
    {
        *lpcbData = cbBuffer;
        goto Exit;
    }

    // If the buffer specified by lpData parameter is not large enough to hold the data, 
    // the function returns the value ERROR_MORE_DATA, and stores the required buffer size, 
    // in bytes, into the variable pointed to by lpcbData. In this case, the contents of 
    // the lpValue buffer are undefined. 
    if (cbBuffer > *lpcbData)
    {
        *lpcbData = cbBuffer;
        lr = ERROR_MORE_DATA;
        goto Exit;
    }

    // transfer values
    *lpcbData = cbBuffer;
    if (lpData)
    {
        CopyMemory(lpData, (LPBYTE) pwszBuffer, cbBuffer);
    }
    
Exit:   
    if (pwszBuffer)
    {
        MemFree((LPVOID) pwszBuffer);
    }
    return (lr);
}

//
// Query a value from the registry and ensure it is of the type we expect
// it to be.  When calling RegQueryValueEx, we don't care to know what
// the type is, only to know if it doesn't match what we expect it to be.
// If the value is not of dwType, return ERROR_INVALID_DATATYPE.
//
LONG
RegQueryValueType (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT BYTE* pbData OPTIONAL,
    IN OUT DWORD* pcbData)
{
    LONG lr;
    DWORD dwTypeQueried;

    lr = RegQueryValueExW (hkey, pszValueName, NULL, &dwTypeQueried, pbData, pcbData);
    if (!lr && (dwType != dwTypeQueried))
    {
        lr = ERROR_INVALID_DATATYPE;
    }
    return lr;
}

//
// Read a REG_SZ that is expected to represent a GUID and convert it
// to its GUID representation.  If the value does not seem to be a GUID,
// return ERROR_INVALID_DATATYPE.
//
// hkey is the parent key to read from and pszValueName is the name of the
// value whose data is expected to be a GUID in string form.
// pguidData points to a buffer to receive the GUID.  If pguidData is NULL,
// no data will be returned, but the size of the buffer required will be
// stored at the DWORD pointed to by pcbData.
//
// On input, *pcbData is the size (in bytes) of the buffer pointed to
// by pguidData.  On output, *pcbData is the size (in bytes) required to hold
// the data.
//
LONG
RegQueryGuid (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT GUID* pguidData OPTIONAL,
    IN OUT DWORD* pcbData
    )
{
    LONG lr;
    HRESULT hr;
    WCHAR szGuid [c_cchGuidWithTerm];
    DWORD cbDataIn;
    DWORD cbData;

    Assert (pcbData);

    cbDataIn = *pcbData;
    *pcbData = 0;

    // Get the string form of the guid and store it in szGuid.
    //
    cbData = sizeof (szGuid);
    lr = RegQueryValueType (hkey, pszValueName, REG_SZ, (PBYTE)szGuid, &cbData);
    if (!lr)
    {
        GUID guid;

        // Convert the string to a GUID.  If this fails, the data is invalid
        // and we will return such.
        //
        hr = IIDFromString (szGuid, &guid);
        if (S_OK != hr)
        {
            lr = ERROR_INVALID_DATATYPE;
        }

        if (!lr)
        {
            // The data looks to be a GUID, so we'll return the size
            // and the data if the caller wants it.
            //
            *pcbData = sizeof(GUID);

            if (pguidData)
            {
                if (cbDataIn >= sizeof(GUID))
                {
                    *pguidData = guid;
                }
                else
                {
                    lr = ERROR_MORE_DATA;
                }
            }
        }
    }

    // If querying for the string form of the guid returned ERROR_MORE_DATA,
    // it means that the data is not a GUID.
    //
    else if (ERROR_MORE_DATA == lr)
    {
        lr = ERROR_INVALID_DATATYPE;
    }

    return lr;
}

// Used as input to RegQueryValues.
//
struct REGVALINFO
{
    // The name of the subkey under which this registry value lives.
    // Set this to NULL if this registry value lives under the same key
    // as the previous registry value in the array of this structure.
    //
    PCWSTR  pszSubkey;

    // The name of the registry value.
    //
    PCWSTR  pszValueName;

    // The type of the registry value.  One of REG_SZ, REG_DWORD, etc.
    // REG_GUID is also supported.
    //
    DWORD   dwType;

    // The byte offset of the output pointer within the pbPointers
    // array to store the pointer to the queried data.
    //
    UINT    cbOffset;
};

#define REG_GUID ((DWORD)-5)

//
// Query a batch of values from the registry.  The number of values to query
// is given by cValues.  Information about the values is given through
// an array of REGVALINFO structures.  The data for the values is stored
// in the caller-supplied buffer pointed to by pbBuf.  The caller also
// supplies an array of pointers which will be set to point within pbBuf
// to the data for each value.  This array is must also have cValues elements.
//
// If a value does not exist, its corresponding pointer value in the
// pbPointers array is set to NULL.  This allows the caller to know whether
// the value existed or not.
//
LONG
RegQueryValues (
    IN HKEY hkeyRoot,
    IN ULONG cValues,
    IN const REGVALINFO* aValueInfo,
    OUT BYTE* pbPointers,
    OUT BYTE* pbBuf OPTIONAL,
    IN OUT ULONG* pcbBuf)
{
    LONG lr;
    ULONG cbBufIn;
    ULONG cbBufRequired;
    ULONG cbData;
    ULONG cbPad;
    BYTE *pData;
    const REGVALINFO* pInfo;
    HKEY hkey;
    HRESULT hr;

    Assert (hkeyRoot);
    Assert (pcbBuf);
    Assert (((ULONG_PTR)pbBuf & (sizeof(PVOID)-1)) == 0);

    // On input, *pcbBuf is the number of bytes available in pbBuf.
    //
    cbBufIn = *pcbBuf;
    cbBufRequired = 0;

    hkey = hkeyRoot;

    for (pInfo = aValueInfo; cValues; pInfo++, cValues--)
    {
        // Make sure we have the hkey we want.
        //
        if (pInfo->pszSubkey)
        {
            if (hkey != hkeyRoot)
            {
                RegCloseKey (hkey);
            }

            lr = RegOpenKeyEx (hkeyRoot, pInfo->pszSubkey, 0, KEY_READ, &hkey);
            if (lr)
            {
                continue;
            }
        }

        cbPad = cbBufRequired & (sizeof(PVOID)-1);
        if (cbPad !=0) {

            //
            // The current buffer offset is misaligned.  Increment it so that
            // it is properly aligned.
            // 

            cbPad = sizeof(PVOID) - cbPad;
            cbBufRequired += cbPad;
        }


        if (pbBuf != NULL) {

            //
            // The caller supplied a buffer, so calculate a pointer to the
            // current position within it.
            //

            pData = pbBuf + cbBufRequired;

        } else {

            pData = NULL;
        }

        //
        // Set cbData to the amount of data remaining in the buffer.
        //

        if (cbBufIn > cbBufRequired) {

            cbData = cbBufIn - cbBufRequired;

        } else {

            //
            // No room left, pass in a NULL buffer pointer too.
            //

            cbData = 0;
            pData = NULL;
        }

        //
        // Perform the query based on the desired type.
        //

        if (REG_GUID == pInfo->dwType)
        {
            lr = RegQueryGuid (hkey, pInfo->pszValueName, (GUID*)pData, &cbData);

        } 
        else if ( (REG_SZ == pInfo->dwType) && (!wcscmp(pInfo->pszValueName, c_szHelpText)) )
        {
            // Bug# 310358, load MUI string if necessary
            lr = NcLoadRegUIString(hkey, pInfo->pszValueName, pData, &cbData);
        }    
        else 
        {

            lr = RegQueryValueType (hkey, pInfo->pszValueName,
                    pInfo->dwType, pData, &cbData);
        }

        if (ERROR_SUCCESS == lr || ERROR_MORE_DATA == lr) {

            //
            // cbData contains the amount of data that is available.  Update
            // the buffer size required to contain all of the data.
            // 

            cbBufRequired += cbData;

        } else {

            //
            // The call failed for some reason other than ERROR_MORE_DATA,
            // back out the alignment padding from cbBufRequired.
            // 

            cbBufRequired -= cbPad;
        }

        if (ERROR_SUCCESS == lr && pData != NULL) {

            //
            // Data was retrieved into our buffer.  Store the pointer to the
            // data.
            // 

            *((BYTE**)(pbPointers + pInfo->cbOffset)) = pData;
        }
    }

    if (hkey != hkeyRoot)
    {
        RegCloseKey (hkey);
    }

    *pcbBuf = cbBufRequired;

    if (cbBufRequired <= cbBufIn)
    {
        lr = ERROR_SUCCESS;
    }
    else
    {
        lr = (pbBuf) ? ERROR_MORE_DATA : ERROR_SUCCESS;
    }
    return lr;
}

LONG
RegQueryValuesWithAlloc (
    IN HKEY hkeyRoot,
    IN ULONG cValues,
    IN const REGVALINFO* aValueInfo,
    OUT BYTE* pbPointers,
    OUT BYTE** ppbBuf,
    IN OUT ULONG* pcbBuf)
{
    LONG lr;
    ULONG cbBuf;
    ULONG cbBufConfirm;

    *ppbBuf = NULL;
    *pcbBuf = 0;

    cbBuf = 0;
    lr = RegQueryValues (hkeyRoot, cValues, aValueInfo,
            pbPointers, NULL, &cbBuf);

    if (!lr)
    {
        BYTE* pbBuf;

        lr = ERROR_OUTOFMEMORY;
        pbBuf = (BYTE*)MemAlloc (cbBuf);

        if (pbBuf)
        {
            cbBufConfirm = cbBuf;
            lr = RegQueryValues (hkeyRoot, cValues, aValueInfo,
                    pbPointers, pbBuf, &cbBufConfirm);

            if (!lr)
            {
                Assert (cbBufConfirm == cbBuf);
                *ppbBuf = pbBuf;
                *pcbBuf = cbBuf;
            }
            else
            {
                MemFree (pbBuf);
            }
        }
    }

    return lr;
}

HRESULT
CExternalComponentData::HrEnsureExternalDataLoaded ()
{
    if (m_fInitialized)
    {
        return m_hrLoadResult;
    }

    //$PERF: We can selectively prune certain rows out of this table under
    // certain conditions.  e.g. Enumerated components don't have Clsid or
    // CoServices.
    //
    static const REGVALINFO aValues[] =
    {
        { NULL, L"Description", REG_SZ,       ECD_OFFSET(m_pszDescription) },

        { L"Ndi",
                L"Clsid",       REG_GUID,     ECD_OFFSET(m_pNotifyObjectClsid) },
        { NULL, L"Service",     REG_SZ,       ECD_OFFSET(m_pszService) },
        { NULL, L"CoServices",  REG_MULTI_SZ, ECD_OFFSET(m_pmszCoServices) },
        { NULL, L"BindForm",    REG_SZ,       ECD_OFFSET(m_pszBindForm) },
        { NULL, c_szHelpText,   REG_SZ,       ECD_OFFSET(m_pszHelpText) },

        { L"Ndi\\Interfaces",
                L"LowerRange",      REG_SZ,   ECD_OFFSET(m_pszLowerRange) },
        { NULL, L"LowerExclude",    REG_SZ,   ECD_OFFSET(m_pszLowerExclude) },
        { NULL, L"UpperRange",      REG_SZ,   ECD_OFFSET(m_pszUpperRange) },
        { NULL, L"FilterMediaTypes",REG_SZ,   ECD_OFFSET(m_pszFilterMediaTypes) },
    };

    // Get our containing component pointer so we can open it's
    // instance key.
    //
    CComponent* pThis;
    pThis = CONTAINING_RECORD(this, CComponent, Ext);

    // Open the instance key of the component.
    //
    HRESULT hr;
    HKEY hkeyInstance;
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;

    hr = pThis->HrOpenInstanceKey (KEY_READ, &hkeyInstance, &hdi, &deid);

    if (S_OK == hr)
    {
        LONG lr;
        PVOID pvBuf;
        ULONG cbBuf;

        lr = RegQueryValuesWithAlloc (hkeyInstance, celems(aValues), aValues,
                (BYTE*)this, (BYTE**)&pvBuf, &cbBuf);
        if (!lr)
        {
            // Set our buffer markers.
            //
            m_pvBuffer = pvBuf;
            m_pvBufferLast = (BYTE*)pvBuf + cbBuf;

            // HrOpenInstanceKey may succeed but return a NULL hdi for
            // enumerated components when the real instance key does not
            // exist.  This happens when the class installer removes the
            // instance key and calls us to remove its bindings.
            //
            if (hdi && FIsEnumerated (pThis->Class()))
            {
                hr = HrSetupDiGetDeviceName (hdi, &deid,
                        (PWSTR*)&m_pszDescription);
            }

            if (S_OK == hr)
            {
                hr = HrBuildBindNameFromBindForm (
                        m_pszBindForm,
                        pThis->Class(),
                        pThis->m_dwCharacter,
                        m_pszService,
                        pThis->m_pszInfId,
                        pThis->m_InstanceGuid,
                       (PWSTR*)&m_pszBindName);
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(lr);
            ZeroMemory (this, sizeof(*this));
        }

        SetupDiDestroyDeviceInfoListSafe (hdi);

        RegCloseKey (hkeyInstance);
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;
    m_hrLoadResult = hr;

    TraceHr (ttidError, FAL, m_hrLoadResult, FALSE,
        "CExternalComponentData::HrEnsureExternalDataLoaded (%S)",
        pThis->PszGetPnpIdOrInfId());
    return m_hrLoadResult;
}

BOOL
CExternalComponentData::FLoadedOkayIfLoadedAtAll () const
{
    // Because m_hrLoadResult is S_OK even if we are not initialized,
    // (i.e. if the component's data is not loaded) we can just check
    // m_hrLoadResult without needing to check m_fInitialized.
    //
    return (S_OK == m_hrLoadResult);
}

VOID
CExternalComponentData::FreeDescription ()
{
    // If m_pszDescription is not pointing somewhere in our buffer
    // it means it is using a separate allocation.  (Because it was
    // changed.)
    //
    if ((m_pszDescription < (PCWSTR)m_pvBuffer) ||
        (m_pszDescription > (PCWSTR)m_pvBufferLast))
    {
        MemFree ((VOID*)m_pszDescription);
    }
    m_pszDescription = NULL;
}

VOID
CExternalComponentData::FreeExternalData ()
{
    LocalFree ((VOID*)m_pszBindName);
    FreeDescription();
    MemFree (m_pvBuffer);
}

HRESULT
CExternalComponentData::HrReloadExternalData ()
{
    HRESULT hr;

    FreeExternalData ();
    ZeroMemory (this, sizeof(*this));

    hr = HrEnsureExternalDataLoaded ();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CExternalComponentData::HrReloadExternalData");
    return hr;

}

HRESULT
CExternalComponentData::HrSetDescription (
    PCWSTR pszNewDescription)
{
    HRESULT hr;

    Assert (pszNewDescription);

    FreeDescription();

    hr = E_OUTOFMEMORY;
    m_pszDescription = (PWSTR)MemAlloc (CbOfSzAndTerm(pszNewDescription));
    if (m_pszDescription)
    {
        wcscpy ((PWSTR)m_pszDescription, pszNewDescription);
        hr = S_OK;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\dihook.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       D I H O O K. H
//
//  Contents:   Network Class Installer
//
//  Notes:
//
//  Author:     billbe   25 Nov 1996
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
_HrNetClassInstaller (DI_FUNCTION difFunction,
                      HDEVINFO hdi,
                      PSP_DEVINFO_DATA pdeid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\file.cpp ===
#include "pch.h"
#pragma hdrstop

#include "file.h"
#include "ncsetup.h"

//+---------------------------------------------------------------------------
//
//  Parse the specified INF section which corresponds to a component's
//  defintion. Return the upper-range and lower-range that the component
//  can bind over.
//  e.g. a section like:
//      [Tcpip]
//      UpperRange = "tdi"
//      LowerRange = "ndis5,ndis4,ndisatm,ndiswanip,ndis5_ip"
//
//  Arguments:
//      inf            [in]
//      pszSection     [in]
//      pstrUpperRange [out]
//      pstrLowerRange [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   25 Oct 1998
//
//  Notes:
//
HRESULT
HrParseComponentSection (
    IN  HINF        inf,
    IN  PCWSTR     pszSection,
    OUT tstring*    pstrUpperRange,
    OUT tstring*    pstrLowerRange)
{
    HRESULT hr;

    // Initialize the output parameters.
    //
    pstrUpperRange->erase();
    pstrLowerRange->erase();

    // Get the UpperRange string.  It is a set of comma-separated sub-strings.
    //
    hr = HrSetupGetFirstString (
            inf,
            pszSection,
            L"UpperRange",
            pstrUpperRange);

    if (S_OK == hr)
    {
        if (0 == _wcsicmp (L"noupper", pstrUpperRange->c_str()))
        {
            pstrUpperRange->erase();
        }
    }
    else if (SPAPI_E_LINE_NOT_FOUND != hr)
    {
        goto finished;
    }

    // Get the LowerRange string.  It is a set of comma-separated sub-strings.
    //
    hr = HrSetupGetFirstString (
            inf,
            pszSection,
            L"LowerRange",
            pstrLowerRange);

    if (S_OK == hr)
    {
        if (0 == _wcsicmp (L"nolower", pstrLowerRange->c_str()))
        {
            pstrLowerRange->erase();
        }
    }
    else if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        hr = S_OK;
    }

finished:

    TraceHr (ttidError, FAL, hr, FALSE, "HrParseComponentSection");
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Initialize a CNetConfig instance by reading information from an
//  INF-style file.
//
//  Arguments:
//      pszFilepath [in]
//      pNetConfig  [out]
//
//  Returns:    S_OK or an error code.
//
//  Author:     shaunco   25 Oct 1998
//
//  Notes:
//
HRESULT
HrLoadNetworkConfigurationFromFile (
    IN  PCTSTR      pszFilepath,
    OUT CNetConfig* pNetConfig)
{
    CSetupInfFile   inf;
    UINT            unErrorLine;
    HRESULT         hr;
    INFCONTEXT      ctx;

    // Open the answer file.  It will close itself in it's destructor.
    //
    hr = inf.HrOpen (
                pszFilepath, NULL,
                INF_STYLE_OLDNT | INF_STYLE_WIN4,
                &unErrorLine);

    if (S_OK == hr)
    {
        tstring strInfId;
        tstring strPnpId;
        tstring strUpperRange;
        tstring strLowerRange;
        BASIC_COMPONENT_DATA Data;
        CComponent* pComponent;

        // Find the [Components] section.  This is a list of all of
        // the components involved.
        //
        hr = HrSetupFindFirstLine (inf.Hinf(),
                L"Components",
                NULL,
                &ctx);

        // Process each line in this section by creating a CComponent instance
        // for it and inserting it into the list of components owned by
        // the CNetConfig instance we are initializing.
        //
        while (S_OK == hr)
        {
            ZeroMemory (&Data, sizeof(Data));

            // Get each string field into a local variable and create
            // a new CComponent instance if all succeed.
            //
            //hr = HrSetupGetStringField (ctx, 0, &strInstanceId);
            //if (S_OK != hr) goto finished;
            CoCreateGuid(&Data.InstanceGuid);

            hr = HrSetupGetStringField (ctx, 1, &strInfId);
            if (S_OK != hr) goto finished;
            Data.pszInfId = strInfId.c_str();

            hr = HrSetupGetIntField (ctx, 2, (INT*)&Data.Class);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetIntField (ctx, 3, (INT*)&Data.dwCharacter);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetStringField (ctx, 4, &strPnpId);
            if (S_OK != hr) goto finished;
            Data.pszPnpId = strPnpId.c_str();

            hr = HrParseComponentSection (inf.Hinf(), strInfId.c_str(),
                    &strUpperRange, &strLowerRange);
            if (S_OK != hr) goto finished;
            //Data.pszUpperRange = strUpperRange.c_str();
            //Data.pszLowerRange = strLowerRange.c_str();

            hr = CComponent::HrCreateInstance(
                    &Data,
                    CCI_DEFAULT,
                    NULL,
                    &pComponent);

            if (S_OK == hr)
            {
                hr = pNetConfig->Core.Components.HrInsertComponent (
                        pComponent, INS_NON_SORTED);
            }

            // S_FALSE returned if there is no next line.
            //
            hr = HrSetupFindNextMatchLine (ctx, NULL, &ctx);
        }
    }

    if (SUCCEEDED(hr))
    {
        CComponentList* pComponents = &pNetConfig->Core.Components;
        ULONG       ulUpperIndex;
        ULONG       ulLowerIndex;
        CStackEntry StackEntry;

        // Find the [StackTable] section.  This is a list of how the
        // components are "stacked" on each other.
        //
        hr = HrSetupFindFirstLine (inf.Hinf(),
                L"StackTable",
                NULL,
                &ctx);

        // Process each line in this section by initialzing a CStackEntry
        // structure and inserting a copy of it into the stack table
        // maintained by the CNetConfig instance we are initializing.
        //
        while (S_OK == hr)
        {
            hr = HrSetupGetIntField (ctx, 0, (INT*)&ulUpperIndex);
            if (S_OK != hr) goto finished;

            hr = HrSetupGetIntField (ctx, 1, (INT*)&ulLowerIndex);
            if (S_OK != hr) goto finished;

            StackEntry.pUpper = pComponents->PGetComponentAtIndex (
                                    ulUpperIndex);

            StackEntry.pLower = pComponents->PGetComponentAtIndex (
                                    ulLowerIndex);

            hr = pNetConfig->Core.StackTable.HrInsertStackEntry (
                    &StackEntry, INS_SORTED);
            if (S_OK != hr) goto finished;

            // S_FALSE returned if there is no next line.
            //
            hr = HrSetupFindNextMatchLine (ctx, NULL, &ctx);
        }
    }

    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    if (S_OK == hr)
    {
        pNetConfig->Core.DbgVerifyData();
    }

finished:
    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromFile");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ecomp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       E C O M P . H
//
//  Contents:   Implements the interface to a component's external data.
//              External data is that data controlled (or placed) by
//              PnP or the network class installer.  Everything under a
//              component's instance key is considered external data.
//              (Internal data is that data we store in the persisted binary
//              for the network configuration.  See persist.cpp for
//              code that deals with internal data.)
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "ncmisc.h"

#define ECD_OFFSET(_p) (UINT)FIELD_OFFSET(CExternalComponentData, _p)

class CExternalComponentData : CNetCfgDebug<CExternalComponentData>
{
friend class CImplINetCfgComponent;

private:
    // The data buffer into which subsequent member pointers will point.
    // Always freed.
    //
    PVOID       m_pvBuffer;

    // For enumerated components, this is the 'DriverDesc' value from PnP.
    // For non-enumerated components, this is read from the instance key.
    // In both cases, this is the localizable string value that comes from
    // the component's INF.  It is displayed as the component's
    // display name in any UI.  Note that this is the only member which
    // can be changed.  Therefore, it does not point into the same buffer
    // which all the others point.  Freed if it does not point into
    // m_pvBuffer.
    //
    PCWSTR      m_pszDescription;

    // The CLSID of the component's notify object.  Will be NULL in
    // the case the component does not have a notify object.  Never freed.
    //
    const GUID* m_pNotifyObjectClsid;

    // The component's primary service.  Will be NULL if the component does
    // not have a service.  Never freed.
    //
    PCWSTR      m_pszService;

    // The component's list of co-services as a multi-sz.  Will be NULL
    // if the component does not have any co-services.  Never freed.
    //
    PCWSTR      m_pmszCoServices;

    // The component's bind form.  Will be NULL if the component takes the
    // default bindform.  Never freed.
    //
    PCWSTR      m_pszBindForm;

    // The component's help text.  Will be NULL if the component does not
    // have any help text.  (Not recommened for visible component's)
    // Never freed.
    //
    PCWSTR      m_pszHelpText;

    // Comma-separated list of sub-strings that are the
    // lower-edge binding interfaces.  Never freed.
    //
    PCWSTR      m_pszLowerRange;

    // Comma-separated list of sub-strings that are the
    // upper-edge binding interfaces.
    //
    PCWSTR      m_pszUpperRange;

    // Comma-separated list of sub-strings that are the excluded
    // binding interfaces.
    //
    PCWSTR      m_pszLowerExclude;

    // Comma-separated list of sub-strings that are the media types supported
    // by this filter component.  (Only valid for filters.)
    //
    PCWSTR      m_pszFilterMediaTypes;

    // This pointer is just so that we have an upper bound on the pointers
    // that point into m_pvBuffer.  We use this knowledge to know
    // whether or not to free m_pszDescription as it may not be
    // pointing somewhere in this buffer for the case when it has been
    // changed and hence uses its own allocation.
    //
    PVOID       m_pvBufferLast;

    // The bindname for the component.  This is built from BindForm,
    // Class, Character, ServiceName, InfId, and InstanceGuid.
    // It is a seaparate allocation made with LocalAlloc (because
    // FormatMessage is used to build it.)  Freed with LocalFree.
    //
    PCWSTR      m_pszBindName;

    // The result of HrEnsureExternalDataLoaded.  It is saved, so that on
    // subsequent calls, we return the same result we did the first time.
    //
    HRESULT     m_hrLoadResult;

    // FALSE until HrEnsureExternalDataLoaded is called.  TRUE thereafter
    // which prevents HrEnsureExternalDataLoaded from hitting the registry
    // again.  Indicates all of the other members are cached and valid.
    //
    BOOLEAN     m_fInitialized;

private:
    HRESULT
    HrLoadData (
        IN HKEY hkeyInstance,
        OUT BYTE* pbBuf OPTIONAL,
        IN OUT ULONG* pcbBuf);

    VOID
    FreeDescription ();

    VOID
    FreeExternalData ();

public:
    ~CExternalComponentData ()
    {
        FreeExternalData ();
    }

    HRESULT
    HrEnsureExternalDataLoaded ();

    HRESULT
    HrReloadExternalData ();

    HRESULT
    HrSetDescription (
        PCWSTR pszNewDescription);

    BOOL
    FHasNotifyObject () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (NULL != m_pNotifyObjectClsid);
    }

    BOOL
    FLoadedOkayIfLoadedAtAll () const;

    const CLSID*
    PNotifyObjectClsid () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        AssertH (m_pNotifyObjectClsid);
        return m_pNotifyObjectClsid;
    }

    PCWSTR
    PszAtOffset (
        IN UINT unOffset) const
    {
        AssertH (
            (ECD_OFFSET(m_pszDescription) == unOffset) ||
            (ECD_OFFSET(m_pszService) == unOffset) ||
            (ECD_OFFSET(m_pszBindForm) == unOffset) ||
            (ECD_OFFSET(m_pszHelpText) == unOffset) ||
            (ECD_OFFSET(m_pszLowerRange) == unOffset) ||
            (ECD_OFFSET(m_pszUpperRange) == unOffset) ||
            (ECD_OFFSET(m_pszBindName) == unOffset));

        PCWSTR psz;
        psz = *(PCWSTR*)((BYTE*)this + unOffset);

        AssertH (
            (m_pszDescription == psz) ||
            (m_pszService == psz) ||
            (m_pszBindForm == psz) ||
            (m_pszHelpText == psz) ||
            (m_pszLowerRange == psz) ||
            (m_pszLowerRange == psz) ||
            (m_pszBindName == psz));

        return psz;
    }

    PCWSTR
    PszBindForm () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszBindForm;
    }

    PCWSTR
    PszBindName () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        AssertH (m_pszBindName && *m_pszBindName);
        return m_pszBindName;
    }

    PCWSTR
    PszDescription () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszDescription;
    }

    PCWSTR
    PszHelpText () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszHelpText;
    }

    PCWSTR
    PszService () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszService;
    }

    PCWSTR
    PszCoServices () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pmszCoServices;
    }

    PCWSTR
    PszFilterMediaTypes () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszFilterMediaTypes;
    }

    PCWSTR
    PszLowerRange () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (m_pszLowerRange) ? m_pszLowerRange : L"";
    }

    PCWSTR
    PszLowerExclude () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return m_pszLowerExclude;
    }

    PCWSTR
    PszUpperRange () const
    {
        AssertH (m_fInitialized && (S_OK == m_hrLoadResult));
        return (m_pszUpperRange) ? m_pszUpperRange : L"";
    }

#if DBG
    BOOL DbgIsExternalDataLoaded () const
    {
        return m_fInitialized && (S_OK == m_hrLoadResult);
    }
    VOID DbgVerifyExternalDataLoaded () const
    {
        AssertH (DbgIsExternalDataLoaded());
    }
#else
    BOOL DbgIsExternalDataLoaded () const { return TRUE; }
    VOID DbgVerifyExternalDataLoaded () const {}
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\file.h ===
#pragma once
#include "netcfg.h"

HRESULT
HrLoadNetworkConfigurationFromFile (
    IN  PCTSTR      pszFilepath,
    OUT CNetConfig* pNetConfig);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\filtdev.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V . C P P
//
//  Contents:   Implements the object that represents filter devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "filtdev.h"

//static
HRESULT
CFilterDevice::HrCreateInstance (
    IN CComponent* pAdapter,
    IN CComponent* pFilter,
    IN const SP_DEVINFO_DATA* pdeid,
    IN PCWSTR pszInstanceGuid,
    OUT CFilterDevice** ppFilterDevice)
{
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilter);
    Assert (pFilter->FIsFilter());
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (pdeid);
    Assert (pszInstanceGuid && *pszInstanceGuid);
    Assert ((c_cchGuidWithTerm - 1) == wcslen(pszInstanceGuid));
    Assert (ppFilterDevice);

    HRESULT hr = E_OUTOFMEMORY;
    CFilterDevice* pFilterDevice = new CFilterDevice;
    if (pFilterDevice)
    {
        pFilterDevice->m_pAdapter = pAdapter;
        pFilterDevice->m_pFilter = pFilter;
        pFilterDevice->m_deid = *pdeid;
        wcscpy(pFilterDevice->m_szInstanceGuid, pszInstanceGuid);
        hr = S_OK;
    }

    *ppFilterDevice = pFilterDevice;

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevice::HrCreateInstance");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\filtdevs.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V S . H
//
//  Contents:   Implements the basic datatype for a collection of filter
//              devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "filtdev.h"
#include "ncsetup.h"
#include "netcfg.h"

// Filter devices is a collection of pointers to CFilterDevice.
//
class CFilterDevices : public vector<CFilterDevice*>
{
friend class CRegistryBindingsContext;

private:
    CNetConfigCore* m_pCore;

    CComponentList  m_Filters;

    HDEVINFO        m_hdi;

    // This multi-sz is read from the registry (Control\Network\FilterClasses)
    // and defines the order in which filters stack up.  Each filter INF
    // specifies Ndi\FilterClass which matches a string in this list.  In
    // the event that the string does not match any in the list, it is added
    // to the top of the list.  (Top was chosen arbitrarily.)
    //
    PWSTR           m_pmszFilterClasses;

public:
    // When filters are installed or removed (or we see that a filter is
    // no longer active or newly active over an adapter as in the case of
    // disabling the binding between the filter and an adapter) we add the
    // upper bindings of the adapter to this binding set.
    // These bindings will be unbound before we start the filter devices.
    // This breaks the filter chain and allows NDIS to properly reconstruct
    // it when the new devices are started.
    // Then these bindings will be added to the set of added bindpaths in
    // CModifyContext::ApplyChanges and hence will be sent BIND
    // notifications.  This has to happen so that the protocol(s)
    // bound to the adapter get dynamically rebound after they have been
    // implicitly unbound due to the filter device removal.
    //
    CBindingSet     m_BindPathsToRebind;

private:
    HRESULT
    HrInsertFilterDevice (
        IN CFilterDevice* pDevice);

    HRESULT
    HrLoadFilterDevice (
        IN SP_DEVINFO_DATA* pdeid,
        IN HKEY hkeyInstance,
        IN PCWSTR pszFilterInfId,
        OUT BOOL* pfRemove);

    DWORD
    MapFilterClassToOrdinal (
        IN PCWSTR pszFilterClass);

    CFilterDevice*
    PFindFilterDeviceByAdapterAndFilter (
        IN const CComponent* pAdapter,
        IN const CComponent* pFilter) const;

    CFilterDevice*
    PFindFilterDeviceByInstanceGuid (
        IN PCWSTR pszInstanceGuid) const;

public:
    CFilterDevices (
        IN CNetConfigCore* pCore);

    ~CFilterDevices ();

    HRESULT
    HrPrepare ();

    VOID
    Free ();

    VOID
    LoadAndRemoveFilterDevicesIfNeeded ();

    VOID
    InstallFilterDevicesIfNeeded ();

    VOID
    SortForWritingBindings ();

    VOID
    StartFilterDevices ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\guisetup.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       G U I S E T U P . C P P
//
//  Contents:   Routines that are only executed during GUI setup.
//
//  Notes:
//
//  Author:     shaunco   19 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "guisetup.h"
#include "nceh.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcomm.h"
#include "netsetup.h"

VOID
ExcludeMarkedServicesForSetup (
    IN const CComponent* pComponent,
    IN OUT CPszArray* pServiceNames)
{
    HRESULT hr;
    HKEY hkeyInstance;
    HKEY hkeyNdi;
    PWSTR pmszExclude;
    CPszArray::iterator iter;
    PCWSTR pszServiceName;

    hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

    if (S_OK == hr)
    {
        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            hr = HrRegQueryMultiSzWithAlloc (
                    hkeyNdi,
                    L"ExcludeSetupStartServices",
                    &pmszExclude);

            if (S_OK == hr)
            {
                iter = pServiceNames->begin();
                while (iter != pServiceNames->end())
                {
                    pszServiceName = *iter;
                    Assert (pszServiceName);

                    if (FIsSzInMultiSzSafe (pszServiceName, pmszExclude))
                    {
                        pServiceNames->erase (iter);
                    }
                    else
                    {
                        iter++;
                    }
                }

                MemFree (pmszExclude);
            }

            RegCloseKey (hkeyNdi);
        }

        RegCloseKey (hkeyInstance);
    }
}

VOID
ProcessAdapterAnswerFileIfExists (
    IN const CComponent* pComponent)
{
    HDEVINFO hdi;
    SP_DEVINFO_DATA deid;
    HRESULT hr;

    Assert (pComponent);

    hr = pComponent->HrOpenDeviceInfo (&hdi, &deid);
    if (S_OK == hr)
    {
        PWSTR pszAnswerFile = NULL;
        PWSTR pszAnswerSections = NULL;

        TraceTag (ttidNetcfgBase, "Calling Netsetup for Install parameters");

        NC_TRY
        {
            // Get the Network install params for the adapter
            //
            hr = HrGetAnswerFileParametersForNetCard (hdi, &deid,
                    pComponent->Ext.PszBindName(),
                    &pComponent->m_InstanceGuid,
                    &pszAnswerFile, &pszAnswerSections);
        }
        NC_CATCH_BAD_ALLOC
        {
            hr = E_OUTOFMEMORY;
        }

        if (S_OK == hr)
        {
#ifdef ENABLETRACE
            if (pszAnswerFile)
            {
                TraceTag (ttidNetcfgBase, "Answerfile %S given for adapter",
                          pszAnswerFile);
            }

            if (pszAnswerSections)
            {
                TraceTag (ttidNetcfgBase, "Section %S given for adapter",
                          pszAnswerSections);
            }
#endif // ENABLETRACE
            if (ProcessAnswerFile (pszAnswerFile, pszAnswerSections, hdi,
                    &deid))
            {
                hr = HrSetupDiSendPropertyChangeNotification (hdi, &deid,
                        DICS_PROPCHANGE, DICS_FLAG_GLOBAL, 0);
            }
        }
        // Cleanup up if necessary
        CoTaskMemFree (pszAnswerFile);
        CoTaskMemFree (pszAnswerSections);

        SetupDiDestroyDeviceInfoList (hdi);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\filtdev.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V . H
//
//  Contents:   Implements the object that represents filter devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"

class CFilterDevice : CNetCfgDebug<CFilterDevice>
{
public:
    // The component which represents the adapter this filter device
    // filters.
    //
    CComponent*     m_pAdapter;

    // The component which represents the filter service itself.
    //
    CComponent*     m_pFilter;

    // The device info data for this filter device.
    // (Referencing HDEVINFO is kept external and is valid for the life of
    // these objects.)
    //
    SP_DEVINFO_DATA     m_deid;

    // The instance guid of the device in string form.
    // Assigned by the class installer when the device is installed.
    // This guid is stored in the instance key of the device under
    // 'NetCfgInstanceId'.  It is used to form the bind strings to
    // this device.
    //
    WCHAR   m_szInstanceGuid [c_cchGuidWithTerm];

private:
    // Declare all constructors private so that no one except
    // HrCreateInstance can create instances of this class.
    //
    CFilterDevice () {}

public:
    ~CFilterDevice () {}

    bool
    operator< (
        const CFilterDevice& OtherPath) const;

    static
    HRESULT
    HrCreateInstance (
        IN CComponent* pAdapter,
        IN CComponent* pFilter,
        IN const SP_DEVINFO_DATA* pdeid,
        IN PCWSTR pszInstanceGuid,
        OUT CFilterDevice** ppFilterDevice);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\friendly.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       F R I E N D L Y . C P P
//
//  Contents:   Creates indexes for device installs and sets friendly
//              name descriptions based on the indexes.
//
//  Notes:
//
//  Author:     billbe   6 Nov 1998
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "adapter.h"
#include "classinst.h"
#include "ncmsz.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"


const WCHAR c_szRegValueInstanceIndex[] = L"InstanceIndex";

const DWORD c_cchIndexValueNameLen = 6;
const ULONG c_cMaxDescriptions = 10001; // SetupDi only allows 0-9999
const WCHAR c_szRegKeyDescriptions[] = L"Descriptions";

//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddNextAvailableIndex
//
//  Purpose:    Adds the next available index to a multi-sz of indexes.
//
//  Arguments:
//      pmszIndexesIn  [in]    MultiSz of current indexes.
//      pulIndex       [inout] The index added.
//      ppmszIndexesOut[out]   New multiSz with the added index.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiAddNextAvailableIndex(PWSTR pmszIndexesIn, ULONG* pIndex,
        PWSTR* ppmszIndexesOut)
{
    Assert(pmszIndexesIn);
    Assert(ppmszIndexesOut);

    HRESULT          hr = S_OK;
    WCHAR            szIndex[c_cchIndexValueNameLen];

    // clear out param.
    *ppmszIndexesOut = NULL;

    // We are adding a new index.  Find the first available
    // index.
    //
    ULONG Index;
    ULONG NextIndex;
    PWSTR pszStopString;
    PWSTR pszCurrentIndex = pmszIndexesIn;
    DWORD PositionInMultiSz = 0;
    for (NextIndex = 1; NextIndex < c_cMaxDescriptions;
            ++NextIndex)
    {
        Index = wcstoul(pszCurrentIndex, &pszStopString, c_nBase10);
        if (Index != NextIndex)
        {
            // We found an available index.  Now we insert it.
            //
            swprintf(szIndex, L"%u", NextIndex);
            BOOL fChanged;
            hr = HrAddSzToMultiSz(szIndex, pmszIndexesIn,
                    STRING_FLAG_ENSURE_AT_INDEX, PositionInMultiSz,
                    ppmszIndexesOut, &fChanged);

            AssertSz(fChanged,
                    "We were adding a new index. Something had to change!");
            break;
        }

        ++PositionInMultiSz;

        // Try the next index.
        pszCurrentIndex += wcslen(pszCurrentIndex) + 1;
    }

    // If we succeeded, set the output param.
    if (S_OK == hr)
    {
        *pIndex = NextIndex;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddNextAvailableIndex");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateAndWaitForIndexListMutex
//
//  Purpose:    Creates Updates the description map by adding or removing
//              entries for pszDescription.
//
//  Arguments:
//      pszName     [in]  The name for this mutex.
//      phMutex     [out] The created mutex.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiCreateAndWaitForIndexListMutex(HANDLE* phMutex)
{
    Assert(phMutex);

    const WCHAR c_szMutexName[] = L"Global\\{84b06608-8026-11d2-b1f2-00c04fd912b2}";

    HRESULT hr = S_OK;

    // Create the mutex.
    hr = HrCreateMutexWithWorldAccess(c_szMutexName, FALSE,
            NULL, phMutex);

    if (S_OK == hr)
    {
        // Wait until the mutex is free or cMaxWaitMilliseconds seconds
        // have passed.
        //
        while (1)
        {
            const DWORD cMaxWaitMilliseconds = 30000;   // 30 seconds

            DWORD dwWait = MsgWaitForMultipleObjects (1, phMutex, FALSE,
                                cMaxWaitMilliseconds, QS_ALLINPUT);
            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage(&msg,NULL,NULL,NULL,PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                // Wait is satisfied, or we had a timeout, or an error.
                //
                if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else if (0xFFFFFFFF == dwWait)
                {
                    hr = HrFromLastWin32Error ();
                }

                break;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiCreateAndWaitForIndexListMutex");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiUpdateDescriptionIndexList
//
//  Purpose:    Updates the description map by adding or removing
//              entries for pszDescription.
//
//  Arguments:
//      pguidClass      [in]    The device's class guid
//      pszDescription  [in]    Description of the adapter
//      eOp             [in]    The operation to perform. DM_ADD to add
//                              an index, DM_DELETE to delete an index.
//      pulIndex        [inout] The index added if eOp was DM_ADD.
//                              The index to delete if eOp was DM_DELETE.
//
//  Returns:    HRESULT. S_OK is successful, a converted Win32 error otherwise
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:
//
HRESULT
HrCiUpdateDescriptionIndexList (
    IN NETCLASS Class,
    IN PCWSTR pszDescription,
    IN DM_OP eOp,
    IN OUT ULONG* pIndex)
{
    Assert(pszDescription);
    Assert(pIndex);
    Assert(FIsEnumerated(Class));

    // We don't want to update a decription's index list at the same time
    // as another process, so create a mutex and wait until it is available.
    //
    HANDLE hMutex = NULL;
    HRESULT hr = HrCiCreateAndWaitForIndexListMutex(&hMutex);

    if (S_OK == hr)
    {

        // Build the path to the description key
        // e.g. ...\Network\<net/infrared guid>\c_szRegKeyDescriptions
        //
        WCHAR szPath[_MAX_PATH];
        PCWSTR pszNetworkSubtreePath;

        pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
        AssertSz (pszNetworkSubtreePath,
            "This class does not use the network subtree.");

        wcscpy (szPath, pszNetworkSubtreePath);
        wcscat (szPath, L"\\");
        wcscat (szPath, c_szRegKeyDescriptions);

        // Open/Create the description key
        //
        HKEY hkeyDescription;
        hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                szPath, 0, KEY_READ_WRITE_DELETE, NULL, &hkeyDescription, NULL);

        if (S_OK == hr)
        {
            // Get the description index list if it exists.
            //
            PWSTR pmszIndexesOld;

            hr = HrRegQueryMultiSzWithAlloc(
                    hkeyDescription,
                    pszDescription,
                    &pmszIndexesOld);

            // If we have the list...
            if (S_OK == hr)
            {
                // Perform the requested operation on the list.
                //

                PWSTR pmszBufferToSet = NULL;
                PWSTR pmszIndexesNew = NULL;

                if (DM_ADD == eOp)
                {
                    // We need to add a new index.
                    hr = HrCiAddNextAvailableIndex(pmszIndexesOld,
                            pIndex, &pmszIndexesNew);

                    pmszBufferToSet = pmszIndexesNew;
                }
                else if (DM_DELETE == eOp)
                {
                    // Delete the index from the list.
                    //
                    WCHAR szDelete[c_cchIndexValueNameLen];
                    BOOL fRemoved;
                    swprintf(szDelete, L"%u", *pIndex);
                    RemoveSzFromMultiSz(szDelete, pmszIndexesOld,
                            STRING_FLAG_REMOVE_SINGLE, &fRemoved);

                    // If something was removed, check to see if the
                    // index list is empty.  If it is, delete the
                    // registry value.
                    //
                    if (fRemoved)
                    {
                        ULONG cchIndexes = CchOfMultiSzSafe(pmszIndexesOld);
                        if (!cchIndexes)
                        {
                            // Index list is empty, delete the value.
                            HrRegDeleteValue(hkeyDescription, pszDescription);
                        }
                        else
                        {
                            // Something was removed and there are still
                            // index entries so we have a buffer to set in the
                            // registry.
                            pmszBufferToSet = pmszIndexesOld;
                        }
                    }
                }

                // If we succeeded and have a new list to set...
                //
                if ((S_OK == hr) && pmszBufferToSet)
                {
                    // Set the map back in the registry.
                    hr = HrRegSetMultiSz(hkeyDescription,
                            pszDescription, pmszBufferToSet);
                }

                MemFree(pmszIndexesNew);
                MemFree(pmszIndexesOld);
            }
            else if ((HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr) &&
                    (DM_ADD == eOp))
            {
                // There was no entry for this description so we need to
                // create one.
                //
                hr = HrRegAddStringToMultiSz(L"1", hkeyDescription,
                        NULL, pszDescription, STRING_FLAG_ENSURE_AT_FRONT, 0);

                if (S_OK == hr)
                {
                    *pIndex = 1;
                }
            }

            RegCloseKey(hkeyDescription);
        }

        ReleaseMutex(hMutex);
        CloseHandle(hMutex);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiUpdateDescriptionIndexList");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   CiSetFriendlyNameIfNeeded
//
//  Purpose:    Sets an instance index for the adapter.  If this adapter's
//              description already exists (i.e. another similar adapter
//              is installed), then a friendly name for this adapter will be
//              set using the current description appened with the instance
//              index.
//
//  Arguments:
//      cii [in] See classinst.h
//
//  Returns:    nothing
//
//  Author:     billbe   30 Oct 1998
//
//  Notes:  If previous adapter descriptions were Foo, Foo, Foo
//          They will have friendly names Foo, Foo #2, Foo #3
//
VOID
CiSetFriendlyNameIfNeeded(IN const COMPONENT_INSTALL_INFO& cii)
{
    Assert(IsValidHandle(cii.hdi));
    Assert(cii.pdeid);
    Assert(FIsEnumerated(cii.Class));
    Assert(cii.pszDescription);

    // Open the device parameters key.
    //
    HKEY hkeyDevice;
    HRESULT hr;

    hr = HrSetupDiCreateDevRegKey(cii.hdi, cii.pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DEV, NULL, NULL, &hkeyDevice);

    if (S_OK == hr)
    {
        // Does this device already have an index?
        //
        DWORD Index;
        hr = HrRegQueryDword(hkeyDevice, c_szRegValueInstanceIndex, &Index);

        // This device doesn't have an index, so we need to give it one.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Update the description map and get the new index.
            hr = HrCiUpdateDescriptionIndexList(cii.Class,
                    cii.pszDescription, DM_ADD, &Index);

            if (S_OK == hr)
            {
                // Store the index there so we can retrieve it when
                // the device is uninstalled and delete the index from
                // out table of indexes in use.
                (void) HrRegSetDword(hkeyDevice, c_szRegValueInstanceIndex,
                        Index);
            }
        }

        // The first index doesn't get a new name.
        // i.e. the following same named devices:
        //
        // foo, foo, foo
        //
        // become
        //
        // foo, foo #2, foo #3
        //
        if ((S_OK == hr) && (1 != Index) && !FIsFilterDevice(cii.hdi, cii.pdeid))
        {
            // Now build the new name of this device using the index
            // number.
            //
            // Note: It doesn't matter if we failed to open the driver key
            // above; we can still continue.  It only means that this index
            // cannot be reused if the device is deleted.
            //
            WCHAR szIndex[c_cchIndexValueNameLen];
            swprintf(szIndex, L"%u", Index);

            WCHAR szNewName[LINE_LEN + 1] = {0};
            wcsncpy(szNewName, cii.pszDescription,
                    LINE_LEN - c_cchIndexValueNameLen);
            wcscat(szNewName, L" #");
            wcscat(szNewName, szIndex);

            // Set the new name as the friendly name of the device
            hr = HrSetupDiSetDeviceRegistryProperty(cii.hdi,
                    cii.pdeid,
                    SPDRP_FRIENDLYNAME,
                    reinterpret_cast<const BYTE*>(szNewName),
                    CbOfSzAndTerm(szNewName));

        }

        RegCloseKey(hkeyDevice);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "FCiSetFriendlyNameIfNeeded");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\guisetup.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       G U I S E T U P . H
//
//  Contents:   Routines that are only executed during GUI setup.
//
//  Notes:
//
//  Author:     shaunco   19 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "pszarray.h"

VOID
ExcludeMarkedServicesForSetup (
    IN const CComponent* pComponent,
    IN OUT CPszArray* pServiceNames);

VOID
ProcessAdapterAnswerFileIfExists (
    IN const CComponent* pComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\filtdevs.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       F I L T D E V S . C P P
//
//  Contents:   Implements the basic datatype for a collection of filter
//              devices.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "filtdevs.h"
#include "nceh.h"
#include "ncreg.h"
#include "ncstl.h"
#include "ncsetup.h"


CFilterDevices::CFilterDevices (
    IN CNetConfigCore* pCore)
{
    Assert (pCore);

    ZeroMemory (this, sizeof(*this));

    m_pCore = pCore;
}

CFilterDevices::~CFilterDevices ()
{
    // Free had better have been called before this.
    //
    Assert (this);
    Assert (!m_hdi);
    Assert (!m_pmszFilterClasses);
    Assert (empty());
}

HRESULT
CFilterDevices::HrInsertFilterDevice (
    IN CFilterDevice* pDevice)
{
    HRESULT hr;

    Assert (this);
    Assert (pDevice);

    // Assert there is not already a device in the list with the
    // same instance guid.
    //
    Assert (!PFindFilterDeviceByInstanceGuid (pDevice->m_szInstanceGuid));

    // Assert there is not already a device in the list with the
    // same parent filter AND the same filtered adapter.
    //
    Assert (!PFindFilterDeviceByAdapterAndFilter (
                pDevice->m_pAdapter,
                pDevice->m_pFilter));

    NC_TRY
    {
        push_back (pDevice);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevices::HrInsertFilterDevice");
    return hr;
}

HRESULT
CFilterDevices::HrPrepare ()
{
    HRESULT hr;
    HKEY hkeyNetwork;

    // Reserve room for 8 different filters in our internal member.
    // We use this component list at various times as "scratch space" when
    // figuring out which filters are enabled for an adapter.
    //
    hr = m_Filters.HrReserveRoomForComponents (8);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = m_BindPathsToRebind.HrReserveRoomForBindPaths (8);
    if (S_OK != hr)
    {
        goto finished;
    }

    // Load the FilterClasses multi-sz.
    //

    hr = HrOpenNetworkKey (KEY_READ, &hkeyNetwork);

    if (S_OK == hr)
    {
        hr = HrRegQueryMultiSzWithAlloc (
                hkeyNetwork,
                L"FilterClasses",
                &m_pmszFilterClasses);

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            Assert (!m_pmszFilterClasses);
            hr = S_OK;
        }

        RegCloseKey (hkeyNetwork);
    }

finished:

    TraceHr (ttidError, FAL, hr, FALSE, "CFilterDevices::HrPrepare");
    return hr;
}

CFilterDevice*
CFilterDevices::PFindFilterDeviceByAdapterAndFilter (
    IN const CComponent* pAdapter,
    IN const CComponent* pFilter) const
{
    const_iterator  iter;
    CFilterDevice*  pDevice;

    Assert (this);
    Assert (pAdapter);
    Assert (pFilter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (NC_NETSERVICE == pFilter->Class());
    Assert (pFilter->FIsFilter());

    for (iter = begin(); iter != end(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        if ((pAdapter == pDevice->m_pAdapter) &&
            (pFilter  == pDevice->m_pFilter))
        {
            return pDevice;
        }
    }

    return NULL;
}

DWORD
CFilterDevices::MapFilterClassToOrdinal (
    IN PCWSTR pszFilterClass)
{
    DWORD Ordinal;
    DWORD dwIndex;
    DWORD cStrings;

    Assert (pszFilterClass);
#if DBG
    Ordinal = 0;
#endif

    // If the class is found in the list, return its position.
    //
    if (FGetSzPositionInMultiSzSafe (
            pszFilterClass,
            m_pmszFilterClasses,
            &dwIndex,
            NULL,
            &cStrings))
    {
        Ordinal = dwIndex + 1;
    }
    else
    {
        HRESULT hr;
        PWSTR pmszNew;
        BOOL fChanged;

        // We're adding another string, so compute the new ordinal value
        // for return.
        //
        Ordinal = cStrings + 1;

        // String was not found, so we append it at the end.
        // It is important to insert at the end so we don't have to
        // change the ordinals of any existing filters that already
        // had their ordinal computed.
        //
        hr = HrAddSzToMultiSz (pszFilterClass, m_pmszFilterClasses,
                STRING_FLAG_ENSURE_AT_END, 0, &pmszNew, &fChanged);

        if (S_OK == hr)
        {
            HKEY hkeyNetwork;

            // It better have changed because we didn't find the string
            // above.
            //
            Assert (fChanged);

            // Out with the old. In with the new.
            //
            MemFree (m_pmszFilterClasses);
            m_pmszFilterClasses = pmszNew;

            // Save it back to the registry.
            //
            hr = HrOpenNetworkKey (KEY_WRITE, &hkeyNetwork);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSz (
                        hkeyNetwork,
                        L"FilterClasses",
                        m_pmszFilterClasses);

                Assert (S_OK == hr);

                RegCloseKey (hkeyNetwork);
            }
        }
    }

    // By definition, Ordinal is 1-based.  This is so that when stored
    // in CComponent, we know we have to load the filter class and get
    // its ordinal if CComponent::FilterClassOrdinal is zero.  i.e. zero
    // is a sentinel value that means we need to do work and when non-zero
    // means we don't have to do that work again.
    //
    Assert (Ordinal != 0);
    return Ordinal;
}

CFilterDevice*
CFilterDevices::PFindFilterDeviceByInstanceGuid (
    IN PCWSTR pszInstanceGuid) const
{
    const_iterator  iter;
    CFilterDevice*  pDevice;

    Assert (this);
    Assert (pszInstanceGuid && *pszInstanceGuid);

    for (iter = begin(); iter != end(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        if (0 == wcscmp(pszInstanceGuid, pDevice->m_szInstanceGuid))
        {
            return pDevice;
        }
    }

    return NULL;
}

HRESULT
CFilterDevices::HrLoadFilterDevice (
    IN SP_DEVINFO_DATA* pdeid,
    IN HKEY hkeyInstance,
    IN PCWSTR pszFilterInfId,
    OUT BOOL* pfRemove)
{
    HRESULT hr;
    CComponent* pAdapter;
    CComponent* pFilter;
    WCHAR szInstanceGuid [c_cchGuidWithTerm];
    DWORD cbBuffer;

    Assert (pszFilterInfId && *pszFilterInfId);
    Assert (pfRemove);

    *pfRemove = FALSE;

    // Initialize these to NULL.  If we don't find them below, they will
    // remain NULL and this will tell us something.
    //
    pAdapter = NULL;
    pFilter = NULL;

    cbBuffer = sizeof(szInstanceGuid);
    hr = HrRegQuerySzBuffer (
            hkeyInstance,
            L"NetCfgInstanceId",
            szInstanceGuid, &cbBuffer);

    if (S_OK == hr)
    {
        HKEY hkeyLinkage;

        // Read the RootDevice registry value for this filter device.  The
        // last entry in that multi-sz will be the bindname of the adapter
        // being filtered.
        //
        hr = HrRegOpenKeyEx (
                hkeyInstance,
                L"Linkage",
                KEY_READ,
                &hkeyLinkage);

        if (S_OK == hr)
        {
            PWSTR pmszRootDevice;

            hr = HrRegQueryMultiSzWithAlloc (
                    hkeyLinkage,
                    L"RootDevice",
                    &pmszRootDevice);

            if (S_OK == hr)
            {
                PCWSTR pszScan;
                PCWSTR pszLastDevice = NULL;

                // Scan to the last string in the multi-sz and note it.
                //
                for (pszScan = pmszRootDevice;
                     *pszScan;
                     pszScan += wcslen(pszScan) + 1)
                {
                    pszLastDevice = pszScan;
                }

                // The last string in the multi-sz is the bindname of the
                // adapter being filtered.
                //
                if (pszLastDevice)
                {
                    pAdapter = m_pCore->Components.PFindComponentByBindName (
                                                    NC_NET, pszLastDevice);
                    if (!pAdapter)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_NOT_FOUND);
                    }
                }

                MemFree (pmszRootDevice);
            }

            RegCloseKey (hkeyLinkage);
        }

        if (S_OK == hr)
        {
            // Should have the adapter if no error.
            //
            Assert (pAdapter);

            // Get the enabled filters for the adapter.
            //
            hr = m_pCore->HrGetFiltersEnabledForAdapter (pAdapter, &m_Filters);
            if (S_OK == hr)
            {
                // Use pszFilterInfId to find the parent filter component for
                // this filter device.  If it is not found, it probably means
                // the entire filter is in the process of being removed.
                // (Or the registry was messed with.)
                //
                pFilter = m_pCore->Components.PFindComponentByInfId (
                                                pszFilterInfId, NULL);

                // If the filter corresponding to this device is still
                // installed and is enabled over the adapter, then we'll
                // insert the device into our list.  Otherwise, we're going
                // to remove it.
                //
                if (pFilter && m_Filters.FComponentInList (pFilter))
                {
                    CFilterDevice* pFilterDevice;

                    // Create an instance of the filter device class to
                    // represent this filter device.
                    //
                    hr = CFilterDevice::HrCreateInstance (
                            pAdapter,
                            pFilter,
                            pdeid,
                            szInstanceGuid,
                            &pFilterDevice);

                    if (S_OK == hr)
                    {
                        // Add the filter device to our list of filter devices.
                        //
                        hr = HrInsertFilterDevice (pFilterDevice);

                        if (S_OK != hr)
                        {
                            delete pFilterDevice;
                        }
                    }
                }
                else
                {
                    *pfRemove = TRUE;

                    Assert (pszFilterInfId && *pszFilterInfId);
                    Assert (pAdapter);

                    g_pDiagCtx->Printf (ttidBeDiag,
                        "   Removing filter device for %S over %S adapter\n",
                        pszFilterInfId,
                        pAdapter->m_pszPnpId);

                    // Since we will be removing a filter device from the
                    // chain, we need to rebind the protocols above the
                    // adapter we are removing the filter device for.
                    //
                    // So, get the upper bindings of the adapter (bindpaths
                    // are only 2 levels deep) and add them to the bind set
                    // that we will rebind later on.
                    //
                    hr = m_pCore->HrGetComponentUpperBindings (
                            pAdapter,
                            GBF_ADD_TO_BINDSET | GBF_PRUNE_DISABLED_BINDINGS,
                            &m_BindPathsToRebind);
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr,
        HRESULT_FROM_WIN32(ERROR_NOT_FOUND) == hr,
        "CFilterDevices::HrLoadFilterDevice");
    return hr;
}

VOID
CFilterDevices::LoadAndRemoveFilterDevicesIfNeeded ()
{
    HRESULT hr;
    SP_DEVINFO_DATA deid;
    DWORD dwIndex;
    DWORD cbBuffer;
    WCHAR szFilterInfId [_MAX_PATH];

    Assert (this);
    Assert (m_pCore);
    Assert (!m_hdi);
    Assert (empty());

    // Filter devices can only be of net class.
    //
    hr = HrSetupDiGetClassDevs (&GUID_DEVCLASS_NET, NULL, NULL,
            DIGCF_PROFILE, &m_hdi);

    if (S_OK != hr)
    {
        return;
    }

    Assert (m_hdi);

    // Enumerate all net class devices from setupapi.
    //
    for (dwIndex = 0; S_OK == hr; dwIndex++)
    {
        hr = HrSetupDiEnumDeviceInfo (m_hdi, dwIndex, &deid);

        if (S_OK == hr)
        {
            HKEY hkeyInstance;

            hr = HrSetupDiOpenDevRegKey (
                    m_hdi, &deid,
                    DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                    KEY_READ, &hkeyInstance);

            if (S_OK == hr)
            {
                // If the device has a "FilterInfId" value under its
                // instance key, its one of ours.
                //
                cbBuffer = sizeof(szFilterInfId);
                hr = HrRegQuerySzBuffer (
                        hkeyInstance,
                        L"FilterInfId",
                        szFilterInfId,
                        &cbBuffer);

                if (S_OK == hr)
                {
                    BOOL fRemove;

                    // Load the rest of the filter device, and add it to
                    // our list.  If this fails for any reason, remove the
                    // filter device because its of no use to us anymore.
                    //
                    hr = HrLoadFilterDevice (
                            &deid,
                            hkeyInstance,
                            szFilterInfId,
                            &fRemove);

                    if ((S_OK != hr) || fRemove)
                    {
                        if (S_OK != hr)
                        {
                            g_pDiagCtx->Printf (ttidBeDiag,
                                "   Removing filter device for %S\n",
                                szFilterInfId);
                        }

                        (VOID) HrCiRemoveFilterDevice (m_hdi, &deid);
                        hr = S_OK;
                    }
                }

                //else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
                //{
                    // Not a filter device.  Skip it.
                //}

                RegCloseKey (hkeyInstance);
            }

            // Allow the loop to continue;
            //
            hr = S_OK;
        }
    }
    if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
    {
        hr = S_OK;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "   Loaded %d filter devices\n", size());
}

VOID
CFilterDevices::InstallFilterDevicesIfNeeded ()
{
    HRESULT hr;
    CComponentList::iterator iterAdapter;
    CComponentList::iterator iterFilter;
    CComponent* pAdapter;
    CComponent* pFilter;
    HKEY hkeyInstance;
    HKEY hkeyNdi;
    DWORD cbBuffer;
    BOOL fAddDevice;
    BOOL fAddedDeviceForAdapter;
    WCHAR szFilterDeviceInfId [_MAX_PATH];
    WCHAR szFilterClass [_MAX_PATH];

    Assert (this);
    Assert (m_pCore);

    // If, for some reason, we couldn't get m_hdi up in
    // RemoveFilterDevicesIfNeeded, we can't proceed.
    //
    if (!m_hdi)
    {
        return;
    }

    // For all adapters (because filters possibly bind to any adapter)
    // we get the filters enabled for each.  For each on of these filters
    // that don't already have an associated filter device for the adapter,
    // we create a new one and associated it.
    //
    for (iterAdapter  = m_pCore->Components.begin();
         iterAdapter != m_pCore->Components.end();
         iterAdapter++)
    {
        pAdapter = *iterAdapter;
        Assert (pAdapter);

        // Skip components that are not network adapters.
        //
        if (NC_NET != pAdapter->Class())
        {
            continue;
        }

        hr = m_pCore->HrGetFiltersEnabledForAdapter (pAdapter, &m_Filters);

        if (S_OK != hr)
        {
            // More than likely, we are out of memory.
            //
            TraceHr (ttidError, FAL, hr, FALSE,
                "HrGetFiltersEnabledForAdapter failed in "
                "InstallFilterDevicesIfNeeded. Adapter=%S",
                pAdapter->m_pszPnpId);
            break;
        }

        // We haven't yet added any devices for this adapter.
        //
        fAddedDeviceForAdapter = FALSE;

        // For each of the filters enabled for this adapter, install
        // a filter device if needed and make sure the filter has its
        // ordinal position with respect other filters read from the
        // registry.  We need m_dwFilterClassOrdinal to be valid (non-zero)
        // before we sort the filter devices when writing their bindings.
        //
        for (iterFilter  = m_Filters.begin();
             iterFilter != m_Filters.end();
             iterFilter++)
        {
            pFilter = *iterFilter;
            Assert (pFilter);

            // If there isn't a filter device for the current adapter
            // and filter, we need to install one.
            //
            fAddDevice = !PFindFilterDeviceByAdapterAndFilter (
                            pAdapter, pFilter);

            // If we don't need to add a filter device and we already
            // have the ordinal position of the filter, we can continue with
            // the next filter for this adapter.
            //
            if (!fAddDevice && (0 != pFilter->m_dwFilterClassOrdinal))
            {
                continue;
            }

            *szFilterDeviceInfId = 0;

            // Open the instance key of the filter so we can read
            // a few values.
            //
            hr = pFilter->HrOpenInstanceKey (KEY_READ, &hkeyInstance,
                    NULL, NULL);

            if (S_OK == hr)
            {
                // Open the Ndi key.
                //
                hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi",
                        KEY_READ, &hkeyNdi);

                if (S_OK == hr)
                {
                    if (0 == pFilter->m_dwFilterClassOrdinal)
                    {
                        // Read the filter class and convert it to an
                        // ordinal based on its position in the
                        // filter classes list.
                        //
                        cbBuffer = sizeof(szFilterClass);

                        hr = HrRegQuerySzBuffer (hkeyNdi,
                                L"FilterClass",
                                szFilterClass,
                                &cbBuffer);

                        if (S_OK == hr)
                        {
                            pFilter->m_dwFilterClassOrdinal =
                                MapFilterClassToOrdinal (szFilterClass);
                        }
                    }

                    if (fAddDevice)
                    {
                        // Read the ind id of the filter device.
                        //
                        cbBuffer = sizeof(szFilterDeviceInfId);

                        hr = HrRegQuerySzBuffer (
                                hkeyNdi, L"FilterDeviceInfId",
                                szFilterDeviceInfId, &cbBuffer);
                    }

                    RegCloseKey (hkeyNdi);
                }

                RegCloseKey (hkeyInstance);
            }

            if ((S_OK == hr) && fAddDevice)
            {
                CFilterDevice* pFilterDevice;

                Assert (*szFilterDeviceInfId);

                g_pDiagCtx->Printf (ttidBeDiag,
                    "   Installing filter device for %S over %S adapter\n",
                    pFilter->m_pszInfId,
                    pAdapter->m_pszPnpId);


                hr = HrCiInstallFilterDevice (m_hdi,
                        szFilterDeviceInfId,
                        pAdapter,
                        pFilter,
                        &pFilterDevice);

                if (S_OK == hr)
                {
                    hr = HrInsertFilterDevice (pFilterDevice);
                    if (S_OK == hr)
                    {
                        fAddedDeviceForAdapter = TRUE;
                    }
                    else
                    {
                        delete pFilterDevice;
                    }
                }
            }
        }

        // If we added at least one filter device in the chain for this
        // adapter, we'll need to unbind the adapter from whatever it is
        // currently bound to before we start the filter device.
        //
        if (fAddedDeviceForAdapter)
        {
            // So, get the upper bindings of the adapter (bindpaths
            // are only 2 levels deep) and add them to the bind set
            // that we will rebind later on.
            //
            hr = m_pCore->HrGetComponentUpperBindings (
                    pAdapter,
                    GBF_ADD_TO_BINDSET | GBF_PRUNE_DISABLED_BINDINGS,
                    &m_BindPathsToRebind);
        }
    }
}

INT
__cdecl
CompareFilterDevices (
    const VOID* pv1,
    const VOID* pv2)
{
    CFilterDevice* pDevice1 = *((CFilterDevice**)pv1);
    CFilterDevice* pDevice2 = *((CFilterDevice**)pv2);

    if (pDevice1->m_pAdapter == pDevice2->m_pAdapter)
    {
        Assert (pDevice1->m_pFilter != pDevice2->m_pFilter);

        if (pDevice1->m_pFilter->m_dwFilterClassOrdinal ==
            pDevice2->m_pFilter->m_dwFilterClassOrdinal)
        {
            AssertSz (0, "We have two filters of the same class installed.");
            return 0;
        }

        return (pDevice1->m_pFilter->m_dwFilterClassOrdinal <
                pDevice2->m_pFilter->m_dwFilterClassOrdinal)
                    ? -1 : 1;
    }

    return (pDevice1->m_pAdapter < pDevice2->m_pAdapter) ? -1 : 1;

/*
    if (pDevice1->m_pFilter == pDevice2->m_pFilter)
    {
        Assert (pDevice1->m_pAdapter != pDevice2->m_pAdapter);

        return (pDevice1->m_pAdapter < pDevice2->m_pAdapter) ? -1 : 1;
    }

    if (pDevice1->m_pFilter->m_dwFilterClassOrdinal ==
        pDevice2->m_pFilter->m_dwFilterClassOrdinal)
    {
        AssertSz (0, "We have two filters of the same class installed.");
        return 0;
    }

    return (pDevice1->m_pFilter->m_dwFilterClassOrdinal <
            pDevice2->m_pFilter->m_dwFilterClassOrdinal)
                ? -1 : 1;
*/
}

VOID
CFilterDevices::SortForWritingBindings ()
{
    Assert (this);

    // If we're empty, there is nothing to do.
    //
    if (empty())
    {
        return;
    }

    qsort (begin(), size(), sizeof(CFilterDevice*), CompareFilterDevices);
}

VOID
CFilterDevices::StartFilterDevices ()
{
    HRESULT hr;
    CFilterDevices::reverse_iterator iter;
    CFilterDevice* pDevice;

    Assert (this);
    Assert (m_pCore);

    // If we're empty, there is nothing to do.
    //
    if (empty())
    {
        return;
    }

    // If we're not empty, we must have had m_hdi to insert something.
    //
    Assert (m_hdi);

    for (iter = rbegin(); iter != rend(); iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        g_pDiagCtx->Printf (ttidBeDiag, "   %S filter over %S adapter\n",
            pDevice->m_pFilter->m_pszInfId,
            pDevice->m_pAdapter->m_pszPnpId);

        hr = HrSetupDiSendPropertyChangeNotification (
                m_hdi,
                &pDevice->m_deid,
                DICS_START,
                DICS_FLAG_CONFIGSPECIFIC,
                0);

        if (S_OK != hr)
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   Failed to start filter device for "
                "%S over %S adapter\n",
                pDevice->m_pFilter->m_pszInfId,
                pDevice->m_pAdapter->m_pszPnpId);
        }
    }
}

VOID
CFilterDevices::Free ()
{
    Assert (this);

    MemFree (m_pmszFilterClasses);
    m_pmszFilterClasses = NULL;

    SetupDiDestroyDeviceInfoListSafe (m_hdi);
    m_hdi = NULL;

    FreeCollectionAndItem (*this);

    // Do NOT free m_BindPathsToRebind.  This is used even after ApplyChanges
    // calls Free.
    //
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\iatl.h ===
#pragma once

#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\iclass.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C L A S S . H
//
//  Contents:   Implements the INetCfgClass and INetCfgClassSetup COM
//              interfaces on the NetCfgClass sub-level COM object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "iatl.h"
#include "inetcfg.h"
#include "compdefs.h"
#include "netcfgx.h"


//+---------------------------------------------------------------------------
// INetCfgClass -
//
class ATL_NO_VTABLE CImplINetCfgClass :
    public CImplINetCfgHolder,
    public INetCfgClass,
    public INetCfgClassSetup
{
private:
    NETCLASS    m_Class;

public:
    CImplINetCfgClass ()
    {
        m_Class = NC_INVALID;
    }

    BEGIN_COM_MAP(CImplINetCfgClass)
        COM_INTERFACE_ENTRY(INetCfgClass)
        COM_INTERFACE_ENTRY(INetCfgClassSetup)
    END_COM_MAP()

    // INetCfgClass
    //
    STDMETHOD (FindComponent) (
        IN PCWSTR pszInfId,
        OUT INetCfgComponent** ppComp);

    STDMETHOD (EnumComponents) (
        OUT IEnumNetCfgComponent** ppIEnum);

    // INetCfgClassSetup
    //
    STDMETHOD (SelectAndInstall) (
        IN HWND hwndParent,
        IN OBO_TOKEN* pOboToken,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (Install) (
        IN PCWSTR pszwInfId,
        IN OBO_TOKEN* pOboToken,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo,
        IN PCWSTR pszAnswerFile,
        IN PCWSTR pszAnswerSection,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (DeInstall) (
        IN INetCfgComponent* pIComp,
        IN OBO_TOKEN* pOboToken,
        OUT PWSTR* ppmszwRefs);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  NETCLASS Class,
        OUT INetCfgClass** ppIClass);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ibind.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I B I N D . H
//
//  Contents:   Implements the INetCfgBindingInterface and INetCfgBindingPath
//              COM interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "iatl.h"
#include "ienum.h"
#include "icomp.h"
#include "inetcfg.h"

//+---------------------------------------------------------------------------
// INetCfgBindingInterface -
//
class ATL_NO_VTABLE CImplINetCfgBindingInterface :
    public CImplINetCfgHolder,
    public INetCfgBindingInterface
{
private:
    CImplINetCfgComponent*  m_pUpper;
    CImplINetCfgComponent*  m_pLower;

private:
    HRESULT HrLockAndTestForValidInterface (
        DWORD dwFlags);

public:
    CImplINetCfgBindingInterface ()
    {
        m_pUpper = NULL;
        m_pLower = NULL;
    }

    VOID FinalRelease ()
    {
        AssertH (m_pUpper);
        AssertH (m_pLower);
        ReleaseObj (m_pUpper->GetUnknown());
        ReleaseObj (m_pLower->GetUnknown());

        CImplINetCfgHolder::FinalRelease();
    }

    BEGIN_COM_MAP(CImplINetCfgBindingInterface)
        COM_INTERFACE_ENTRY(INetCfgBindingInterface)
    END_COM_MAP()

    // INetCfgBindingInterface
    //
    STDMETHOD (GetName) (
        OUT PWSTR* ppszInterfaceName);

    STDMETHOD (GetUpperComponent) (
        OUT INetCfgComponent** ppComp);

    STDMETHOD (GetLowerComponent) (
        OUT INetCfgComponent** ppComp);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  CImplINetCfgComponent* pUpper,
        IN  CImplINetCfgComponent* pLower,
        OUT INetCfgBindingInterface** ppv);
};


//+---------------------------------------------------------------------------
// INetCfgBindingPath -
//
class ATL_NO_VTABLE CImplINetCfgBindingPath :
    public CImplINetCfgHolder,
    public INetCfgBindingPath
{
friend class CImplIEnumNetCfgBindingInterface;

private:
    // Note: For code coverage, we keep the static array small to
    // test the case where we don't fit and have to allocate.
    // Make this number 8 after we test both cases.
    //
    INetCfgComponent*   m_apIComp [8];
    INetCfgComponent**  m_papIComp;
    ULONG               m_cpIComp;

private:
    HRESULT HrLockAndTestForValidInterface (
        IN DWORD dwFlags,
        OUT CBindPath* pBindPath);

public:
    CImplINetCfgBindingPath ()
    {
        m_papIComp = NULL;
        m_cpIComp = 0;
    }

    VOID FinalRelease ()
    {
        AssertH (m_cpIComp);
        AssertH (m_papIComp);

        ReleaseIUnknownArray (m_cpIComp, (IUnknown**)m_papIComp);

        // If we are not using our static array, free what we allocated.
        //
        if (m_papIComp != m_apIComp)
        {
            MemFree (m_papIComp);
        }

        CImplINetCfgHolder::FinalRelease();
    }

    HRESULT
    HrIsValidInterface (
        IN DWORD dwFlags,
        OUT CBindPath* pBindPath);

    BEGIN_COM_MAP(CImplINetCfgBindingPath)
        COM_INTERFACE_ENTRY(INetCfgBindingPath)
    END_COM_MAP()

    // INetCfgBindingPath
    //
    STDMETHOD (IsSamePathAs) (
        IN INetCfgBindingPath* pIPath);

    STDMETHOD (IsSubPathOf) (
        IN INetCfgBindingPath* pIPath);

    STDMETHOD (IsEnabled) ();

    STDMETHOD (Enable) (
        IN BOOL fEnable);

    STDMETHOD (GetPathToken) (
        OUT PWSTR* ppszPathToken);

    STDMETHOD (GetOwner) (
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (GetDepth) (
        OUT ULONG* pulDepth);

    STDMETHOD (EnumBindingInterfaces) (
        OUT IEnumNetCfgBindingInterface** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  const CBindPath* pBindPath,
        OUT INetCfgBindingPath** ppIPath);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\icomp.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C O M P . H
//
//  Contents:   Implements the INetCfgComponent COM interface.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "comp.h"
#include "iatl.h"
#include "inetcfg.h"
#include "netcfgx.h"
#include "stable.h"

HRESULT
HrIsValidINetCfgComponent (
    IN INetCfgComponent* pICompInterface);

CComponent*
PComponentFromComInterface (
    IN INetCfgComponent* pICompInterface);

//+---------------------------------------------------------------------------
// INetCfgComponent -
//
class ATL_NO_VTABLE CImplINetCfgComponent :
    public CImplINetCfgHolder,
    public INetCfgComponent,
    public INetCfgComponentBindings,
    public INetCfgComponentPrivate
{
friend class CImplINetCfg;
friend class CImplINetCfgClass;
friend class CImplINetCfgBindingInterface;
friend class CImplINetCfgBindingPath;
friend class CComponent;
friend CComponent* PComponentFromComInterface (
        IN INetCfgComponent* pICompInterface);
friend HRESULT HrIsValidINetCfgComponent (
        IN INetCfgComponent* pICompInterface);

private:
    // Pointer to the component this object represents.  This points directly
    // into CNetConfig.Components.  When NULL, it means that someone
    // is still holding a reference to this object, but the underlying
    // CComponent has been removed from CNetConfig.
    //
    CComponent*     m_pComponent;

protected:
    HRESULT
    HrIsValidInterface (
        IN DWORD dwFlags);

    HRESULT
    HrLockAndTestForValidInterface (
        IN DWORD dwFlags,
        IN INetCfgComponent* pIOtherComp, OPTIONAL
        OUT CComponent** ppOtherComp OPTIONAL);

    HRESULT
    HrAccessExternalStringAtOffsetAndCopy (
        IN UINT unOffset,
        OUT PWSTR* ppszDst);

    HRESULT
    HrBindToOrUnbindFrom (
        IN INetCfgComponent* pIOtherComp,
        IN DWORD dwChangeFlag);

    HRESULT
    HrMoveBindPath (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst,
        IN MOVE_FLAG Flag);

public:
    CImplINetCfgComponent ()
    {
        m_pComponent = NULL;
    }

    BEGIN_COM_MAP(CImplINetCfgComponent)
        COM_INTERFACE_ENTRY(INetCfgComponent)
        COM_INTERFACE_ENTRY(INetCfgComponentBindings)
        COM_INTERFACE_ENTRY(INetCfgComponentPrivate)
    END_COM_MAP()

    // INetCfgComponent
    //
    STDMETHOD (GetDisplayName) (
        OUT PWSTR* ppszDisplayName);

    STDMETHOD (SetDisplayName) (
        IN PCWSTR pszDisplayName);

    STDMETHOD (GetHelpText) (
        OUT PWSTR* pszHelpText);

    STDMETHOD (GetId) (
        OUT PWSTR* ppszId);

    STDMETHOD (GetCharacteristics) (
        OUT LPDWORD pdwCharacteristics);

    STDMETHOD (GetInstanceGuid) (
        OUT GUID* pInstanceGuid);

    STDMETHOD (GetPnpDevNodeId) (
        OUT PWSTR* ppszDevNodeId);

    STDMETHOD (GetClassGuid) (
        OUT GUID* pguidClass);

    STDMETHOD (GetBindName) (
        OUT PWSTR* ppszBindName);

    STDMETHOD (GetDeviceStatus) (
        OUT ULONG* pulStatus);

    STDMETHOD (OpenParamKey) (
        OUT HKEY* phkey);

    STDMETHOD (RaisePropertyUi) (
        IN HWND hwndParent,
        IN DWORD dwFlags, /* NCRP_FLAGS */
        IN IUnknown* punkContext OPTIONAL);

    // INetCfgComponentBindings
    //
    STDMETHOD (BindTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (UnbindFrom) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (SupportsBindingInterface) (
        IN DWORD dwFlags,
        IN PCWSTR pszInterfaceName);

    STDMETHOD (IsBoundTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (IsBindableTo) (
        IN INetCfgComponent* pIOtherComp);

    STDMETHOD (EnumBindingPaths) (
        IN DWORD dwFlags,
        OUT IEnumNetCfgBindingPath** ppIEnum);

    STDMETHOD (MoveBefore) (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst);

    STDMETHOD (MoveAfter) (
        IN INetCfgBindingPath* pIPathSrc,
        IN INetCfgBindingPath* pIPathDst);

    // INetCfgComponentPrivate
    //
    STDMETHOD (QueryNotifyObject) (
        IN REFIID riid,
        OUT VOID** ppvObject);

    STDMETHOD (SetDirty) ();

    STDMETHOD (NotifyUpperEdgeConfigChange) ();


public:
    static HRESULT HrCreateInstance (
        IN  CImplINetCfg* pINetCfg,
        IN  CComponent* pComponent,
        OUT CImplINetCfgComponent** ppIComp);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ibind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I B I N D . C P P
//
//  Contents:   Implements the INetCfgBindingInterface and INetCfgBindingPath
//              COM interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "ncvalid.h"
#include "netcfg.h"
#include "util.h"


//static
HRESULT
CImplINetCfgBindingInterface::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  CImplINetCfgComponent* pUpper,
    IN  CImplINetCfgComponent* pLower,
    OUT INetCfgBindingInterface** ppv)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgBindingInterface* pObj;
    pObj = new CComObject <CImplINetCfgBindingInterface>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pUpper = pUpper;
        pObj->m_pLower = pLower;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_INetCfgBindingInterface,
                        (VOID**)ppv);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                AddRefObj (pUpper->GetUnknown());
                AddRefObj (pLower->GetUnknown());
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgBindingInterface::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    Lock();

    hr = m_pUpper->HrIsValidInterface (dwFlags);
    if (S_OK == hr)
    {
        hr = m_pLower->HrIsValidInterface (dwFlags);
    }

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::HrLockAndTestForValidInterface");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgBindingInterface
//

STDMETHODIMP
CImplINetCfgBindingInterface::GetName (
    OUT PWSTR* ppszInterfaceName)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppszInterfaceName))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszInterfaceName = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA);
        if (S_OK == hr)
        {
            CComponent*  pUpper = m_pUpper->m_pComponent;
            CComponent*  pLower = m_pLower->m_pComponent;
            const WCHAR* pch;
            ULONG        cch;

            if (pUpper->FCanDirectlyBindTo (pLower, &pch, &cch))
            {
                hr = HrCoTaskMemAllocAndDupSzLen (
                        pch, cch, ppszInterfaceName, MAX_INF_STRING_LENGTH);
            }
            else
            {
                AssertSz(0, "Why no match if we have a binding interface "
                    "created for these components?");
                hr = E_UNEXPECTED;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterface::GetName");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingInterface::GetUpperComponent (
    OUT INetCfgComponent** ppComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            AddRefObj (m_pUpper->GetUnknown());
            *ppComp = m_pUpper;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterfaceGetName::GetUpperComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingInterface::GetLowerComponent (
    OUT INetCfgComponent** ppComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            AddRefObj (m_pLower->GetUnknown());
            *ppComp = m_pLower;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingInterfaceGetName::GetLowerComponent");
    return hr;
}


//static
HRESULT
CImplINetCfgBindingPath::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN const CBindPath* pBindPath,
    OUT INetCfgBindingPath** ppIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    ULONG ulDepth;
    ULONG cbArray;
    CComponent* pComponent;
    CImplINetCfgBindingPath* pObj;

    Assert (pINetCfg);
    Assert (pBindPath);
    Assert (ppIPath);

    // Caller's are responsible for ensuring that if an interface is about
    // to be handed out, and the external data has been loaded, that the
    // data has been loaded successfully.  If we handed out an interface
    // and the data was NOT loaded successfully, it just means we are doomed
    // to fail later when the client of the interface calls a method that
    // requires that data.
    //
    Assert (pBindPath->FAllComponentsLoadedOkayIfLoadedAtAll());

    hr = E_OUTOFMEMORY;
    pObj = new CComObject <CImplINetCfgBindingPath>;

    if (pObj)
    {
        // Initialize our members.
        //

        ulDepth = pBindPath->CountComponents();
        cbArray = ulDepth * sizeof(INetCfgComponent*);

        AssertSz (0 != ulDepth, "Why are we being asked to expose an empty bindpath?");
        AssertSz (1 != ulDepth, "Why are we being asked to expose a bindpath with only one component?");

        // If the bindpath has more components than our static
        // array has room for, we'll have to use an allocated array.
        //
        if (cbArray > sizeof(pObj->m_apIComp))
        {
            // Ensure failure of MemAlloc causes us to return the correct
            // error code.  (Should be set above and not changed between.)
            //
            Assert (E_OUTOFMEMORY == hr);

            pObj->m_papIComp = (INetCfgComponent**) MemAlloc (cbArray);

            if (pObj->m_papIComp)
            {
                hr = S_OK;
            }
        }
        else
        {
            pObj->m_papIComp = pObj->m_apIComp;
            hr = S_OK;
        }

        // Now get each INetCfgComponent interface for the components in
        // the bindpath.
        //
        if (S_OK == hr)
        {
            UINT iComp;

            ZeroMemory (pObj->m_papIComp, cbArray);

            for (iComp = 0; iComp < ulDepth; iComp++)
            {
                pComponent = pBindPath->PGetComponentAtIndex (iComp);
                Assert (pComponent);

                hr = pComponent->HrGetINetCfgComponentInterface (
                        pINetCfg, pObj->m_papIComp + iComp);

                if (S_OK != hr)
                {
                    ReleaseIUnknownArray (iComp+1, (IUnknown**)pObj->m_papIComp);
                    break;
                }
            }
        }

        if (S_OK == hr)
        {
            pObj->m_cpIComp = ulDepth;

            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            if (S_OK == hr)
            {
                hr = pObj->QueryInterface (IID_INetCfgBindingPath,
                            (VOID**)ppIPath);

                // The last thing we do is addref any interfaces we hold.
                // We only do this if we are returning success.
                //
                if (S_OK == hr)
                {
                    pObj->HoldINetCfg (pINetCfg);
                }
            }
        }

        if (S_OK != hr)
        {
            if (pObj->m_papIComp != pObj->m_apIComp)
            {
				MemFree (pObj->m_papIComp);
            }

            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgBindingPath::HrIsValidInterface (
    IN DWORD dwFlags,
    OUT CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);

    if ((S_OK == hr) && pBindPath)
    {
        Assert (0 == pBindPath->CountComponents());

        // When pBindPath is specified, it means the caller wants a
        // CBindPath representation of the bindpath we represent.
        // We have to build this using the array of INetCfgComponent
        // pointer we maintain.  Do this by verifying each one is valid
        // and then adding its internal CComponent* to pBindPath.
        //
        hr = pBindPath->HrReserveRoomForComponents (m_cpIComp);

        if (S_OK == hr)
        {
            CImplINetCfgComponent* pIComp;
            CComponent* pComponent;

            // For each INetCfgComponent* in our array...
            //
            for (UINT i = 0; i < m_cpIComp; i++)
            {
                pIComp = (CImplINetCfgComponent*)m_papIComp[i];

                if (pIComp == NULL)
				{
					return(E_OUTOFMEMORY);
				}

                hr = pIComp->HrIsValidInterface (IF_DEFAULT);

                if (S_OK != hr)
                {
                    break;
                }

                pComponent = pIComp->m_pComponent;
                Assert (pComponent);

                hr = pBindPath->HrAppendComponent (pComponent);
                if (S_OK != hr)
                {
                    break;
                }
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::HrIsValidInterface");
    return hr;
}

HRESULT
CImplINetCfgBindingPath::HrLockAndTestForValidInterface (
    IN DWORD dwFlags,
    OUT CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags, pBindPath);

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgHolder::HrLockAndTestForValidInterface");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgBindingPath
//

STDMETHODIMP
CImplINetCfgBindingPath::IsSamePathAs (
    IN INetCfgBindingPath* pIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPath))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pOther = (CImplINetCfgBindingPath*)pIPath;

            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (pOther->m_cpIComp);
            Assert (pOther->m_papIComp);

            // Can't be the same if our length is not the same.
            //
            if (m_cpIComp != pOther->m_cpIComp)
            {
                hr = S_FALSE;
            }
            else
            {
                UINT cb;

                cb = m_cpIComp * sizeof(INetCfgComponent*);

                hr = (0 == memcmp (
                            (BYTE*)(m_papIComp),
                            (BYTE*)(pOther->m_papIComp),
                            cb)) ? S_OK : S_FALSE;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgBindingPath::IsSamePathAs");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::IsSubPathOf (
    IN INetCfgBindingPath* pIPath)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPath))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pOther = (CImplINetCfgBindingPath*)pIPath;

            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (pOther->m_cpIComp);
            Assert (pOther->m_papIComp);

            // Can't be a subpath if our length is greater or equal.
            //
            if (m_cpIComp >= pOther->m_cpIComp)
            {
                hr = S_FALSE;
            }
            else
            {
                UINT cb;
                UINT unSkipComponents;

                cb = m_cpIComp * sizeof(INetCfgComponent*);

                Assert (pOther->m_cpIComp > m_cpIComp);
                unSkipComponents = pOther->m_cpIComp - m_cpIComp;

                hr = (0 == memcmp (
                            (BYTE*)(m_papIComp),
                            (BYTE*)(pOther->m_papIComp + unSkipComponents),
                            cb)) ? S_OK : S_FALSE;
            }

            // Special Case: NCF_DONTEXPOSELOWER
            // If we're about to return false, let's check for a case like:
            // is ms_ipx->adapter a subpath of ms_server->ms_ipx and return
            // TRUE.  For this case, it really is a subpath, but the binding
            // has been broken because of NCF_DONTEXPOSELOWER.
            //
            // If the last component of pIPath, and the first component of
            // this path both are NCF_DONTEXPOSELOWER, then consider this
            // path a subpath of pIPath.  This assumes that ms_nwipx and
            // ms_nwnb are the only components with this characteristic.
            //
            if (S_FALSE == hr)
            {
                CImplINetCfgComponent* pIFirst;
                CImplINetCfgComponent* pILast;

                pIFirst = (CImplINetCfgComponent*)m_papIComp[0];
                pILast = (CImplINetCfgComponent*)pOther->m_papIComp[pOther->m_cpIComp - 1];

				if ((pIFirst == NULL) ||
					(pILast == NULL))
				{
					return(E_OUTOFMEMORY);
				}

                if ((S_OK == pIFirst->HrIsValidInterface(IF_DEFAULT)) &&
                    (S_OK == pILast->HrIsValidInterface(IF_DEFAULT)))
                {
                    Assert (pIFirst->m_pComponent);
                    Assert (pILast->m_pComponent);

                    if ((pIFirst->m_pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER) &&
                        (pILast->m_pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        if (0 == wcscmp(L"ms_nwipx", pIFirst->m_pComponent->m_pszInfId))
                        {
                            hr = S_OK;
                        }
                        else if (pIFirst->m_pComponent == pILast->m_pComponent)
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
            // End Special case

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgBindingPath::IsSubPathOf");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::IsEnabled ()
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    CBindPath BindPath;

    hr = HrLockAndTestForValidInterface (IF_DEFAULT, &BindPath);
    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        if (m_pINetCfg->m_pNetConfig->Core.FIsBindPathDisabled (
                            &BindPath, IBD_MATCH_SUBPATHS_TOO))
        {
            hr = S_FALSE;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgBindingPath::IsEnabled");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::Enable (
    IN BOOL fEnable)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;
    CBindPath BindPath;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, &BindPath);
    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.HrEnableOrDisableBindPath (
                    (fEnable) ? NCN_ENABLE : NCN_DISABLE,
                    &BindPath,
                    this);

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::Enable");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetPathToken (
    OUT PWSTR* ppszPathToken)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppszPathToken))
    {
        hr = E_POINTER;
    }
    else
    {
        CBindPath BindPath;

        *ppszPathToken = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, &BindPath);
        if (S_OK == hr)
        {
            ULONG cch;

            cch = 0;
            BindPath.FGetPathToken (NULL, &cch);
            if (cch)
            {
                hr = HrCoTaskMemAlloc (
                        ((cch + 1) * sizeof(WCHAR)),
                        (VOID**)ppszPathToken);

                if (S_OK == hr)
                {
                    BindPath.FGetPathToken (*ppszPathToken, &cch);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetPathToken");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetOwner (
    OUT INetCfgComponent** ppIComp)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIComp))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIComp = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            Assert (m_cpIComp);
            Assert (m_papIComp);
            Assert (m_papIComp[0]);

            AddRefObj (m_papIComp[0]);
            *ppIComp = m_papIComp[0];

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetOwner");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::GetDepth (
    OUT ULONG* pulDepth)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(pulDepth))
    {
        hr = E_POINTER;
    }
    else
    {
        *pulDepth = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            Assert (m_cpIComp);

            *pulDepth = m_cpIComp;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::GetDepth");
    return hr;
}

STDMETHODIMP
CImplINetCfgBindingPath::EnumBindingInterfaces (
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    TraceFileFunc(ttidNetCfgBind);
    
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgBindingInterface::HrCreateInstance (
                    m_pINetCfg,
                    this,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgBindingPath::EnumBindingInterfaces");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\icomp.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C O M P . C P P
//
//  Contents:   Implements the INetCfgComponent COM interface.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "icomp.h"
#include "ienum.h"
#include "nccfgmgr.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncvalid.h"
#include "netcfg.h"
#include "netconp.h"
#include "util.h"


HRESULT
HrIsValidINetCfgComponent (
    IN INetCfgComponent* pICompInterface)
{
    Assert (pICompInterface);

    CImplINetCfgComponent* pIComp;
    pIComp = (CImplINetCfgComponent*)pICompInterface;

	if (pIComp == NULL)
	{
		return(E_OUTOFMEMORY);
	}

    return pIComp->HrIsValidInterface (IF_DEFAULT);
}

CComponent*
PComponentFromComInterface (
    IN INetCfgComponent* pICompInterface)
{
    Assert (pICompInterface);

    CImplINetCfgComponent* pIComp;
    pIComp = (CImplINetCfgComponent*)pICompInterface;

    // Can't do the following assert because we may be referencing the
    // component before it has been added to the core.  This case is possible
    // when installing a new component that installed a required component
    // on behalf of itself.  We will wind up in the function when adding
    // the refernce for the obo token.
    //
    //Assert (S_OK == pIComp->HrIsValidInterface (dwFlags));

    Assert (pIComp->m_pComponent);
    return pIComp->m_pComponent;
}

// static
HRESULT
CImplINetCfgComponent::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  CComponent* pComponent,
    OUT CImplINetCfgComponent** ppIComp)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgComponent* pObj;
    pObj = new CComObject <CImplINetCfgComponent>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pComponent = pComponent;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            pObj->HoldINetCfg (pINetCfg);

            AddRefObj (pObj->GetUnknown());
            *ppIComp = pObj;
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrIsValidInterface (
    IN DWORD dwFlags)
{
    HRESULT hr;

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);
    if (S_OK != hr)
    {
        return hr;
    }

    // Check for deleted component.
    //
    if (!m_pComponent)
    {
        return HRESULT_FROM_WIN32(ERROR_INVALID_HANDLE);
    }

    // If we made it this far, the component this interface represents
    // should definately be in the core component list or in the core
    // that we started with in the case that this component is in the middle
    // of being removed.
    //
    Assert(m_pINetCfg->m_pNetConfig->Core.Components.
                FComponentInList (m_pComponent) ||
           m_pINetCfg->m_pNetConfig->ModifyCtx.m_CoreStartedWith.Components.
                FComponentInList (m_pComponent));

    if (dwFlags & IF_NEED_COMPONENT_DATA)
    {
        hr = m_pComponent->Ext.HrEnsureExternalDataLoaded ();
    }

    return hr;
}

// We need to override CImplINetCfgHolder::HrLockAndTestForValidInterface
// because we have our own HrIsValidInterface to be called.
//
HRESULT
CImplINetCfgComponent::HrLockAndTestForValidInterface (
    IN DWORD dwFlags,
    IN INetCfgComponent* pIOtherComp, OPTIONAL
    OUT CComponent** ppOtherComp OPTIONAL)
{
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags);

    // If pIOtherComp was passed in, the caller wants that interface
    // validated and the internal CComponent pointer for it returned.
    //
    if ((S_OK == hr) && pIOtherComp)
    {
        CImplINetCfgComponent* pOther;

        Assert (ppOtherComp);

        pOther = (CImplINetCfgComponent*)pIOtherComp;

        hr = pOther->HrIsValidInterface (IF_NEED_COMPONENT_DATA);
        if (S_OK == hr)
        {
            *ppOtherComp = pOther->m_pComponent;
        }
    }

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrLockAndTestForValidInterface");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy (
    IN UINT unOffset,
    OUT PWSTR* ppszDst)
{
    HRESULT hr;

    // Validate parameter.
    //
    if (FBadOutPtr (ppszDst))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppszDst = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    m_pComponent->Ext.PszAtOffset (unOffset),
                    ppszDst, 
                    MAX_INF_STRING_LENGTH);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrAccessExternalStringAtOffsetAndCopy");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponent -
//
STDMETHODIMP
CImplINetCfgComponent::GetDisplayName (
    OUT PWSTR* ppszDisplayName)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszDescription),
            ppszDisplayName);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetDisplayName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SetDisplayName (
    IN PCWSTR pszDisplayName)
{
    HRESULT hr;

    // Validate parameter.
    //
    if (FBadInPtr (pszDisplayName))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            // We only allow changing the display name (SPDRP_FRIENDLYNAME,
            // actually) of enumerated components.
            //
            if (FIsEnumerated(m_pComponent->Class()))
            {
                HDEVINFO hdi;
                SP_DEVINFO_DATA deid;

                hr = m_pComponent->HrOpenDeviceInfo (&hdi, &deid);
                if (S_OK == hr)
                {
                    hr = HrSetupDiSetDeviceName (hdi, &deid, pszDisplayName);

                    if (S_OK == hr)
                    {
                        m_pComponent->Ext.HrSetDescription (pszDisplayName);
                    }

                    SetupDiDestroyDeviceInfoList (hdi);
                }
            }
            else
            {
                hr = E_NOTIMPL;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::SetDisplayName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetHelpText (
    OUT PWSTR* pszHelpText)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszHelpText),
            pszHelpText);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetHelpText");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetId (
    OUT PWSTR* ppszId)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppszId))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            hr = HrCoTaskMemAllocAndDupSz (
                    m_pComponent->m_pszInfId,
                    ppszId,
                    MAX_DEVICE_ID_LEN);

            Unlock();
        }
        else
        {
            *ppszId = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetId");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetCharacteristics (
    OUT LPDWORD pdwCharacteristics)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pdwCharacteristics))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pdwCharacteristics = m_pComponent->m_dwCharacter;

            Unlock();
        }
        else
        {
            *pdwCharacteristics = 0;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetCharacteristics");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetInstanceGuid (
    OUT GUID* pInstanceGuid)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pInstanceGuid))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pInstanceGuid = m_pComponent->m_InstanceGuid;

            Unlock();
        }
        else
        {
            *pInstanceGuid = GUID_NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetInstanceGuid");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetPnpDevNodeId (
    OUT PWSTR* ppszDevNodeId)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppszDevNodeId))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            if (FIsEnumerated(m_pComponent->Class()))
            {
                hr = HrCoTaskMemAllocAndDupSz (
                        m_pComponent->m_pszPnpId,
                        ppszDevNodeId, 
                        MAX_DEVICE_ID_LEN);
            }
            else
            {
                hr = E_NOTIMPL;
            }

            Unlock();
        }
        else
        {
            *ppszDevNodeId = NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetPnpDevNodeId");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetClassGuid (
    OUT GUID* pguidClass)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pguidClass))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            *pguidClass = *MAP_NETCLASS_TO_GUID[m_pComponent->Class()];

            Unlock();
        }
        else
        {
            *pguidClass = GUID_NULL;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetClassGuid");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetBindName (
    OUT PWSTR* ppszBindName)
{
    HRESULT hr;

    hr = HrAccessExternalStringAtOffsetAndCopy (
            ECD_OFFSET(m_pszBindName),
            ppszBindName);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetBindName");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::GetDeviceStatus (
    OUT ULONG* pulStatus)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pulStatus))
    {
        hr = E_POINTER;
    }
    else
    {
        *pulStatus = 0;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            if (!FIsEnumerated(m_pComponent->Class()))
            {
                hr = E_UNEXPECTED;
            }
            else
            {
                HDEVINFO hdi;
                SP_DEVINFO_DATA deid;

                hr = m_pComponent->HrOpenDeviceInfo (&hdi, &deid);

                if (S_OK == hr)
                {
                    ULONG ulStatus;
                    ULONG ulProblem;
                    CONFIGRET cfgRet;

                    cfgRet = CM_Get_DevNode_Status_Ex (
                                &ulStatus, &ulProblem, deid.DevInst, 0, NULL);

                    if (CR_SUCCESS == cfgRet)
                    {
                        hr = S_OK;
                        *pulStatus = ulProblem;
                    }
                    else if(CR_NO_SUCH_DEVINST == cfgRet)
                    {
                        hr = NETCFG_E_ADAPTER_NOT_FOUND;
                    }
                    else
                    {
                        TraceTag (ttidError, "CM_Get_DevNode_Status_Ex for "
                            "%S returned cfgRet=0x%08x, ulStatus=0x%08x, ulProblem=0x%08x",
                            m_pComponent->m_pszPnpId,
                            cfgRet,
                            ulStatus,
                            ulProblem);

                        hr = HrFromConfigManagerError (cfgRet, E_FAIL);
                    }

                    SetupDiDestroyDeviceInfoList (hdi);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::GetDeviceStatus");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::OpenParamKey (
    OUT HKEY* phkey)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (phkey))
    {
        hr = E_POINTER;
    }
    else
    {
        *phkey = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            // Get the correct REGSAM value base on?
            //
            REGSAM samDesired = KEY_READ_WRITE;

            // For enumerated components, the parameter key is the
            // instance key.
            //
            if (FIsEnumerated (m_pComponent->Class()))
            {
                hr = m_pComponent->HrOpenInstanceKey (
                            samDesired, phkey, NULL, NULL);
            }

            // For non-enumerated components, the parameter is either under
            // the service key (if the component has a service) or it is
            // under the instance key.
            //
            else
            {
                // Get the parent of the parameters key.
                //
                HKEY hkeyParent;

                #if DBG
                hkeyParent = NULL;
                #endif

                if (m_pComponent->FHasService())
                {
                    hr = m_pComponent->HrOpenServiceKey (
                            samDesired, &hkeyParent);
                }
                else
                {
                    hr = m_pComponent->HrOpenInstanceKey (
                            samDesired, &hkeyParent, NULL, NULL);
                }

                if (S_OK == hr)
                {
                    Assert (hkeyParent);

                    DWORD dwDisposition;
                    hr = HrRegCreateKeyEx (
                            hkeyParent,
                            L"Parameters",
                            REG_OPTION_NON_VOLATILE,
                            samDesired,
                            NULL,
                            phkey,
                            &dwDisposition);

                    RegCloseKey (hkeyParent);
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::OpenParamKey");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::RaisePropertyUi (
    IN HWND hwndParent,
    IN DWORD dwFlags, /* NCRP_FLAGS */
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if ((!IsWindow (hwndParent) && (dwFlags & NCRP_SHOW_PROPERTY_UI)) ||
        !(dwFlags & (NCRP_QUERY_PROPERTY_UI | NCRP_SHOW_PROPERTY_UI)) ||
        ((dwFlags & NCRP_QUERY_PROPERTY_UI) && (dwFlags & NCRP_SHOW_PROPERTY_UI)))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtrOptional (punkContext))
    {
        hr = E_POINTER;
    }
    else
    {
        DWORD dwIfFlags = IF_NEED_WRITE_LOCK;
        BOOL fReadOnlyRasUiContext = FALSE;
        
        // Special case: for RAS UI.  We need to allow raising property
        // sheets within the context of a RAS connection even when we
        // don't have the write lock.  This is because non-admins need to be
        // able to change TCP/IP properties for their connections.  The 
        // property values will be stored in the phonebook and we won't need 
        // to make any netcfg changes anyway.  Therefore, if we have a
        // punkContext, we'll check to see if it supports the private 
        // interface that we know RAS uses when it raises properties.
        // If this interface is present, we won't require the write lock
        // to proceed
        //
        if (punkContext && !m_pINetCfg->m_WriteLock.FIsOwnedByMe ())
        {
            INetRasConnectionIpUiInfo* pRasUiInfo;
            hr = punkContext->QueryInterface (IID_INetRasConnectionIpUiInfo,
                                (PVOID*)&pRasUiInfo);
            if (S_OK == hr)
            {
                dwIfFlags &= ~IF_NEED_WRITE_LOCK;
                dwIfFlags |= IF_NEED_COMPONENT_DATA;
                fReadOnlyRasUiContext = TRUE;
                
                ReleaseObj (pRasUiInfo);
            }
            hr = S_OK;
        }
        // End special case
        
        hr = HrLockAndTestForValidInterface (dwIfFlags, NULL, NULL);
        if (S_OK == hr)
        {
            // Special case: (see above)
            //
            if (fReadOnlyRasUiContext)
            {
                if (0 == wcscmp (m_pComponent->m_pszInfId, L"ms_tcpip"))
                {
                    hr = m_pComponent->Notify.HrEnsureNotifyObjectInitialized (
                            m_pINetCfg, FALSE);
                }
                else
                {
                    hr = NETCFG_E_NO_WRITE_LOCK;
                }
            }
            // End special case
            
            if (S_OK == hr)
            {
                if (dwFlags & NCRP_QUERY_PROPERTY_UI)
                {
                    hr = m_pComponent->Notify.HrQueryPropertyUi (
                            m_pINetCfg,
                            punkContext);
                }
                else
                {
                    Assert (dwFlags & NCRP_SHOW_PROPERTY_UI);

                    hr = m_pComponent->Notify.HrShowPropertyUi (
                            m_pINetCfg,
                            hwndParent,
                            punkContext);
                }
            }

            Unlock ();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (S_FALSE == hr),
        "CImplINetCfgComponent::RaisePropertyUi");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentBindings -
//
HRESULT
CImplINetCfgComponent::HrBindToOrUnbindFrom (
    IN INetCfgComponent* pIOtherComp,
    IN DWORD dwChangeFlag)
{
    HRESULT hr;

    Assert ((dwChangeFlag == NCN_ENABLE) || (dwChangeFlag == NCN_DISABLE));

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            // Assume the components do not bind.
            //
            hr = S_FALSE;

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                if (S_OK == hr)
                {
                    CBindPath* pBindPath;

                    // Assume we don't find the component in any bindings.
                    //
                    hr = S_FALSE;

                    for (pBindPath  = BindingSet.begin();
                         pBindPath != BindingSet.end();
                         pBindPath++)
                    {
                        // Skip bindpaths that don't contain the lower
                        // component.
                        //
                        if (!pBindPath->FContainsComponent (pLower))
                        {
                            continue;
                        }

                        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrEnableOrDisableBindPath (
                                    dwChangeFlag,
                                    pBindPath,
                                    NULL);

                        if (S_OK != hr)
                        {
                            break;
                        }
                    }
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::HrBindToOrUnbindFrom");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::BindTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    hr = HrBindToOrUnbindFrom (pIOtherComp, NCN_ENABLE);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::BindTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::UnbindFrom (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    hr = HrBindToOrUnbindFrom (pIOtherComp, NCN_DISABLE);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::UnbindFrom");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SupportsBindingInterface (
    IN DWORD dwFlags,
    IN PCWSTR pszInterfaceName)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!((dwFlags & NCF_UPPER) || (dwFlags & NCF_LOWER)))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtr (pszInterfaceName))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            PCWSTR pszRange;

            pszRange = (dwFlags & NCF_LOWER)
                            ? m_pComponent->Ext.PszLowerRange()
                            : m_pComponent->Ext.PszUpperRange();

            hr =  (FSubstringMatch (pszRange, pszInterfaceName, NULL, NULL))
                    ? S_OK
                    : S_FALSE;

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::SupportsBindingInterface");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::IsBoundTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            hr = S_FALSE;  // assume it is not bound or is disabled

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                // If we think its bound, make sure it exists in at least
                // one bindpath that is not disabled.
                //
                if (S_OK == hr)
                {
                    CBindPath* pBindPath;

                    // Assume we don't fint it in at least one enabled
                    // bindpath.
                    //
                    hr = S_FALSE;

                    for (pBindPath  = BindingSet.begin();
                         pBindPath != BindingSet.end();
                         pBindPath++)
                    {
                        // If the bindpath contains the component, and it is
                        // not a disabled bindpath, it means pUpper has a
                        // path to pLower.
                        //

                        if (pBindPath->FContainsComponent (pLower) &&
                            !m_pINetCfg->m_pNetConfig->Core.
                                FIsBindPathDisabled (pBindPath,
                                    IBD_MATCH_SUBPATHS_TOO))
                        {
                            hr = S_OK;
                            break;
                        }
                    }
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::IsBoundTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::IsBindableTo (
    IN INetCfgComponent* pIOtherComp)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIOtherComp))
    {
        hr = E_POINTER;
    }
    else
    {
        CComponent* pLower;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA,
                pIOtherComp, &pLower);

        if (S_OK == hr)
        {
            const CComponent* pUpper = m_pComponent;

            hr = S_FALSE;  // assume it does not bind

            if (pUpper != pLower)
            {
                CBindingSet BindingSet;

                hr = m_pINetCfg->m_pNetConfig->Core.HrGetComponentBindings (
                        pUpper, GBF_DEFAULT, &BindingSet);

                if (S_OK == hr)
                {
                    hr = (BindingSet.FContainsComponent (pLower))
                            ? S_OK : S_FALSE;
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfgComponent::IsBindableTo");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::EnumBindingPaths (
    IN DWORD dwFlags,
    OUT IEnumNetCfgBindingPath** ppIEnum)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (ppIEnum))
    {
        hr = E_POINTER;
    }
    else if ((EBP_ABOVE != dwFlags) &&
             (EBP_BELOW != dwFlags))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT, NULL, NULL);
        if (S_OK == hr)
        {
            CImplIEnumNetCfgBindingPath* pIEnum;

            // Create an empty bindpath enumerator.  We create it empty
            // before we get the set of bindings so we don't have to copy
            // the bindings.
            //
            hr = CImplIEnumNetCfgBindingPath::HrCreateInstance (
                    m_pINetCfg,
                    NULL,
                    EBPC_CREATE_EMPTY,
                    &pIEnum);

            if (S_OK == hr)
            {
                // Get the bindset and store it directly in the enumerator
                // for its exclusive use.
                //
                if (EBP_ABOVE == dwFlags)
                {
                    hr = m_pINetCfg->m_pNetConfig->Core.
                            HrGetBindingsInvolvingComponent (
                                m_pComponent,
                                GBF_DEFAULT,
                                &pIEnum->m_InternalBindSet);
                }
                else
                {
                    hr = m_pINetCfg->m_pNetConfig->Core.
                            HrGetComponentBindings (
                                m_pComponent,
                                GBF_DEFAULT,
                                &pIEnum->m_InternalBindSet);
                }

                if (S_OK == hr)
                {
                    // Must Reset so that the internal iterator is setup properly
                    // after we initialized the InternalBindSet above.
                    //
                    hr = pIEnum->Reset ();
                    Assert (S_OK == hr);

                    AddRefObj (pIEnum->GetUnknown());
                    *ppIEnum = pIEnum;
                }

                ReleaseObj (pIEnum->GetUnknown());
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::EnumBindingPaths");
    return hr;
}

HRESULT
CImplINetCfgComponent::HrMoveBindPath (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst,
    IN MOVE_FLAG Flag)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pIPathSrc) || FBadInPtrOptional (pIPathDst))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
        if (S_OK == hr)
        {
            CImplINetCfgBindingPath* pISrc;
            CImplINetCfgBindingPath* pIDst;
            CBindPath SrcBindPath;
            CBindPath DstBindPath;
            CBindPath::const_iterator iterSrc;
            CBindPath::const_iterator iterDst;
            CStackEntry SrcEntry;
            CStackEntry DstEntry;

            Assert (m_pINetCfg);
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            pISrc = (CImplINetCfgBindingPath*)pIPathSrc;
            pIDst = (CImplINetCfgBindingPath*)pIPathDst;

            hr = pISrc->HrIsValidInterface (IF_NEED_WRITE_LOCK, &SrcBindPath);
            if (S_OK != hr)
            {
                goto unlock;
            }

            // pIPathDst (hence pIDst) may be NULL.
            //
            if (pIDst)
            {
                hr = pIDst->HrIsValidInterface (IF_NEED_WRITE_LOCK, &DstBindPath);
                if (S_OK != hr)
                {
                    goto unlock;
                }
            }

            // The first component of both bindpaths must be this component.
            //
            if ((m_pComponent != SrcBindPath.POwner()) ||
                (pIDst && (m_pComponent != DstBindPath.POwner())))
            {
                hr = E_INVALIDARG;
                goto unlock;
            }

            if (pIDst)
            {
                // Scan down both bindpaths until we find the first components
                // that don't match.  Assume we don't find this occurance and
                // return E_INVALIDARG if we don't.
                //
                hr = E_INVALIDARG;

                for (iterSrc  = SrcBindPath.begin(), iterDst  = DstBindPath.begin();
                     iterSrc != SrcBindPath.end() && iterDst != DstBindPath.end();
                     iterSrc++, iterDst++)
                {
                    // First time through *iterSrc is guaranteed to be the
                    // sameas *iterDst because the first component in both
                    // bindpaths is m_pComponent as tested above.
                    //
                    if (*iterSrc != *iterDst)
                    {
                        SrcEntry.pLower = *iterSrc;
                        Assert (SrcEntry.pLower);

                        DstEntry.pLower = *iterDst;
                        Assert (DstEntry.pUpper);

                        Assert (SrcEntry.pUpper == DstEntry.pUpper);
                        Assert (SrcEntry.pLower != DstEntry.pLower);

                        hr = m_pINetCfg->m_pNetConfig->Core.StackTable.
                                HrMoveStackEntries (
                                    &SrcEntry,
                                    &DstEntry,
                                    Flag,
                                    &m_pINetCfg->m_pNetConfig->ModifyCtx);

                        if(SUCCEEDED(hr))
                        {
                            // Mark this component as dirty so it's bindings will be written out and 
                            // NDIS will be notified.
                            m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrDirtyComponentAndComponentsAbove(SrcEntry.pUpper);
                            m_pINetCfg->m_pNetConfig->ModifyCtx.
                                HrDirtyComponentAndComponentsAbove(DstEntry.pUpper);
                        }

                        break;
                    }

                    // Remember the upper components as we are about to
                    // advance past them.
                    //
                    SrcEntry.pUpper = *iterSrc;
                    Assert (SrcEntry.pUpper);

                    DstEntry.pUpper = *iterDst;
                    Assert (SrcEntry.pUpper);

                    Assert (SrcEntry.pUpper == DstEntry.pUpper);
                }
            }
            else
            {
                SrcEntry.pUpper = SrcBindPath.POwner();
                Assert ((SrcBindPath.begin() + 1) != SrcBindPath.end());
                SrcEntry.pLower = *(SrcBindPath.begin() + 1);

                hr = m_pINetCfg->m_pNetConfig->Core.StackTable.
                        HrMoveStackEntries (
                            &SrcEntry,
                            NULL,
                            Flag,
                            &m_pINetCfg->m_pNetConfig->ModifyCtx);

                if(SUCCEEDED(hr))
                {
                    // Mark this component as dirty so it's bindings will be written out and 
                    // NDIS will be notified.
                    m_pINetCfg->m_pNetConfig->ModifyCtx.
                        HrDirtyComponentAndComponentsAbove(SrcEntry.pUpper);
                }
            }

unlock:
            Unlock();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::HrMoveBindPath");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::MoveBefore (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst)
{
    HRESULT hr;

    hr = HrMoveBindPath (pIPathSrc, pIPathDst, MOVE_BEFORE);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::MoveBefore");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::MoveAfter (
    IN INetCfgBindingPath* pIPathSrc,
    IN INetCfgBindingPath* pIPathDst)
{
    HRESULT hr;

    hr = HrMoveBindPath (pIPathSrc, pIPathDst, MOVE_AFTER);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::MoveAfter");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgComponentPrivate -
//
STDMETHODIMP
CImplINetCfgComponent::QueryNotifyObject (
    IN REFIID riid,
    OUT VOID** ppvObject)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(&riid) || FBadOutPtr (ppvObject))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppvObject = NULL;

        hr = HrLockAndTestForValidInterface (IF_NEED_COMPONENT_DATA, NULL, NULL);
        if (S_OK == hr)
        {
            hr = m_pComponent->Notify.QueryNotifyObject (
                    m_pINetCfg, riid, ppvObject);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::QueryNotifyObject");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::SetDirty ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
    if (S_OK == hr)
    {
        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.HrDirtyComponent(
                m_pComponent);

        Unlock ();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgComponent::SetDirty");
    return hr;
}

STDMETHODIMP
CImplINetCfgComponent::NotifyUpperEdgeConfigChange ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK, NULL, NULL);
    if (S_OK == hr)
    {
        hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                HrDirtyComponentAndComponentsAbove (m_pComponent);

        Unlock ();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgComponent::NotifyUpperEdgeConfigChange");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\iclass.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I C L A S S . C P P
//
//  Contents:   Implements the INetCfgClass and INetCfgClassSetup COM
//              interfaces on the NetCfgClass sub-level COM object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "iclass.h"
#include "icomp.h"
#include "ienum.h"
#include "install.h"
#include "netcfg.h"
#include "obotoken.h"


// static
HRESULT
CImplINetCfgClass::HrCreateInstance (
    IN  CImplINetCfg* pINetCfg,
    IN  NETCLASS Class,
    OUT INetCfgClass** ppIClass)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfgClass* pObj;
    pObj = new CComObject <CImplINetCfgClass>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_Class = Class;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->GetUnknown()->QueryInterface (IID_INetCfgClass,
                    (VOID**)ppIClass);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgClass::HrCreateInstance");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgClass -
//

STDMETHODIMP
CImplINetCfgClass::FindComponent (
    IN PCWSTR pszInfId,
    OUT INetCfgComponent** ppComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pszInfId) || FBadOutPtrOptional(ppComp))
    {
        hr = E_POINTER;
    }
    else if (wcslen (pszInfId) >= MAX_DEVICE_ID_LEN)
    {
        //impose the same limit on infid as imposed by pnp on pnpid.
        hr = E_INVALIDARG;
    }
    else
    {
        if (ppComp)
        {
            *ppComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            CComponent* pComponent;

            pComponent = m_pINetCfg->m_pNetConfig->Core.Components.
                            PFindComponentByInfId (pszInfId, NULL);

            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (pComponent &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll() &&
                (m_Class == pComponent->Class()))
            {
                hr = S_OK;

                if (ppComp)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface (
                            m_pINetCfg, ppComp);
                }
            }
            else
            {
                hr = S_FALSE;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfgClass::FindComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::EnumComponents (
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgComponent::HrCreateInstance (
                    m_pINetCfg,
                    m_Class,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfgClass::EnumComponents");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgClassSetup -
//
STDMETHODIMP
CImplINetCfgClass::SelectAndInstall (
    IN HWND hwndParent,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr = m_pINetCfg->SelectWithFilterAndInstall(
            hwndParent,
            MAP_NETCLASS_TO_GUID[m_Class],
            pOboToken,
            NULL,
            ppIComp);

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (NETCFG_S_REBOOT == hr),
        "CImplINetCfgClass::SelectAndInstall");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::Install (
    IN PCWSTR pszwInfId,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    IN DWORD dwSetupFlags OPTIONAL,
    IN DWORD dwUpgradeFromBuildNo OPTIONAL,
    IN PCWSTR pszAnswerFile OPTIONAL,
    IN PCWSTR pszAnswerSection OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pszwInfId) ||
        !FOboTokenValidForClass(pOboToken, m_Class) ||
        FBadInPtrOptional (pszAnswerFile) ||
        FBadInPtrOptional (pszAnswerSection) ||
        FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    // Must specifiy a non-empty INF id, and must either not specifiy,
    // or completely specifiy the answerfile and the section.
    //
    else if (!(*pszwInfId) ||
             ((!!pszAnswerFile) ^ (!!pszAnswerSection)))
    {
        hr = E_INVALIDARG;
    }
    else if (wcslen (pszwInfId) >= MAX_DEVICE_ID_LEN)
    {
        //impose the same limit on infid as imposed by pnp on pnpid.
        hr = E_INVALIDARG;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
                IF_ALLOW_INSTALL_OR_REMOVE);
        if (S_OK == hr)
        {
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            NETWORK_INSTALL_PARAMS nip;
            COMPONENT_INSTALL_PARAMS Params;
            CComponent* pComponent;

            // Pack the network install parameters and call the common
            // function.
            //
            //$REVIEW: Just make this method take NETWORK_INSTALL_PARAMS?.
            //
            nip.dwSetupFlags         = dwSetupFlags;
            nip.dwUpgradeFromBuildNo = dwUpgradeFromBuildNo;
            nip.pszAnswerFile        = pszAnswerFile;
            nip.pszAnswerSection     = pszAnswerSection;

            // Setup the component install parameters.
            //
            ZeroMemory (&Params, sizeof(Params));
            Params.Class     = m_Class;
            Params.pszInfId  = pszwInfId;
            Params.pOboToken = pOboToken;
            Params.pnip      = &nip;

            hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                    HrInstallNewOrReferenceExistingComponent (
                        Params,
                        &pComponent);

            // The above may return NETCFG_S_REBOOT so use SUCCEEDED instead
            // of checking for S_OK only.
            //
            if (SUCCEEDED(hr) && ppIComp)
            {
                pComponent->HrGetINetCfgComponentInterface (
                    m_pINetCfg,
                    ppIComp);
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (NETCFG_S_REBOOT == hr),
        "CImplINetCfgClass::Install");
    return hr;
}

STDMETHODIMP
CImplINetCfgClass::DeInstall (
    IN INetCfgComponent* pIComp,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT PWSTR* ppmszwRefs OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pIComp) ||
        !FOboTokenValidForClass(pOboToken, m_Class) ||
        FBadOutPtrOptional(ppmszwRefs))
    {
        hr = E_POINTER;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppmszwRefs)
        {
            *ppmszwRefs = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
                IF_ALLOW_INSTALL_OR_REMOVE);
        if (S_OK == hr)
        {
            Assert (m_pINetCfg->m_pNetConfig->ModifyCtx.m_fPrepared);

            CImplINetCfgComponent* pICompToRemove;
            pICompToRemove = (CImplINetCfgComponent*)pIComp;

            hr = pICompToRemove->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

            if (S_OK == hr)
            {
                // We don't allow removals of physical adapters via INetCfg.
                //
                if (!FIsPhysicalAdapter (m_Class,
                        pICompToRemove->m_pComponent->m_dwCharacter))
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrRemoveComponentIfNotReferenced (
                                pICompToRemove->m_pComponent,
                                pOboToken,
                                ppmszwRefs);
                }
                else
                {
                    hr = SPAPI_E_INVALID_CLASS;
                }
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (NETCFG_S_REBOOT == hr) || (NETCFG_S_STILL_REFERENCED == hr),
        "CImplINetCfgClass::DeInstall");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ienum.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I E N U M . C P P
//
//  Contents:   Implements the IEnumNetCfgBindingInterface,
//              IEnumNetCfgBindingPath, and IEnumNetCfgComponent COM
//              interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ibind.h"
#include "ienum.h"
#include "ncatl.h"
#include "netcfg.h"

/*
 A helper function for finishing up the semantics of a IEnumXXX::Next or
 IEnumXXX::Skip. Return S_OK if no error passed in and celt == celtFetched.
 Return S_FALSE if no error passed in and celt != celtFetched. If returning
 an error, release celt IUnknowns from rgelt.

 Returns:   S_OK, S_FALSE,  or an error code

 Author:    shaunco   13 Jan 1999
*/
HRESULT
HrFinishNextOrSkipContract (
    IN HRESULT hr,
    IN ULONG celtFetched,
    IN ULONG celt,
    IN OUT IUnknown** rgelt,
    OUT ULONG* pceltFetched)
{
    if (S_OK == hr)
    {
        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
        hr = (celtFetched == celt) ? S_OK : S_FALSE;
    }
    else
    {
        // For any failures, we need to release what we were about to return.
        // Set any output parameters to NULL.
        //
        if (rgelt)
        {
            for (ULONG ulIndex = 0; ulIndex < celt; ulIndex++)
            {
                ReleaseObj (rgelt[ulIndex]);
                rgelt[ulIndex] = NULL;
            }
        }
        if (pceltFetched)
        {
            *pceltFetched = 0;
        }
    }
    return hr;
}

//+---------------------------------------------------------------------------
// CImplIEnumNetCfgBindingInterface -
//

/*
 Create an instance of a binding interface enumerator.

 Returns:   S_OK or an error code

 Author:    shaunco   13 Jan 1999
*/
// static
HRESULT
CImplIEnumNetCfgBindingInterface::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN CImplINetCfgBindingPath* pIPath,
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplIEnumNetCfgBindingInterface* pObj;
    pObj = new CComObject <CImplIEnumNetCfgBindingInterface>;
    if (pObj)
    {
        hr = S_OK;

        // Initialize our members.
        //
        pObj->m_pIPath = pIPath;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        // The last thing we do is addref any interfaces we hold.
        // We only do this if we are returning success.
        //
        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_IEnumNetCfgBindingInterface,
                        (VOID**)ppIEnum);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                AddRefObj (pIPath->GetUnknown());
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgBindingInterface::HrCreateInstance");
    return hr;
}

VOID
CImplIEnumNetCfgBindingInterface::FinalRelease ()
{
    AssertH (m_pIPath);
    ReleaseObj (m_pIPath->GetUnknown());

    CImplINetCfgHolder::FinalRelease();
}

HRESULT
CImplIEnumNetCfgBindingInterface::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgBindingInterface** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    Assert (m_unIndex >= 1);

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (m_unIndex < m_pIPath->m_cpIComp))
        {
            if (rgelt)
            {
                hr = CImplINetCfgBindingInterface::HrCreateInstance (
                        m_pINetCfg,
                        (CImplINetCfgComponent*)m_pIPath->
                            m_papIComp[m_unIndex-1],

                        (CImplINetCfgComponent*)m_pIPath->
                            m_papIComp[m_unIndex],
                        rgelt + celtFetched);
            }

            celtFetched++;
            m_unIndex++;
        }
        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Next (
    IN ULONG celt,
    OUT INetCfgBindingInterface** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingInterface::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Reset ()
{
    Lock();
    Assert (m_pIPath);
    m_unIndex = 1;
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgBindingInterface::Clone (
    OUT IEnumNetCfgBindingInterface** ppIEnum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// CImplIEnumNetCfgBindingPath -
//

// static
HRESULT
CImplIEnumNetCfgBindingPath::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN const CBindingSet* pBindSet OPTIONAL,
    IN DWORD dwFlags,
    OUT CImplIEnumNetCfgBindingPath** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    Assert (dwFlags);
    if (pBindSet)
    {
        pINetCfg->m_pNetConfig->Core.DbgVerifyBindingSet (pBindSet);
    }

    CImplIEnumNetCfgBindingPath* pObj;
    pObj = new CComObject <CImplIEnumNetCfgBindingPath>;
    if (pObj)
    {
        hr = S_OK;

        // Initialize our members.
        //
        if (dwFlags & EBPC_TAKE_OWNERSHIP)
        {
            Assert (pBindSet);
            pObj->m_pBindSet = pBindSet;
            pObj->m_iter = pBindSet->begin();
        }
        else if (dwFlags & EBPC_COPY_BINDSET)
        {
            Assert (pBindSet);
            hr = pObj->m_InternalBindSet.HrCopyBindingSet(pBindSet);
            pObj->m_pBindSet = &pObj->m_InternalBindSet;
            pObj->m_iter = pObj->m_InternalBindSet.begin();
        }
        else
        {
            Assert (dwFlags & EBPC_CREATE_EMPTY);
            pObj->m_pBindSet = &pObj->m_InternalBindSet;
            pObj->m_iter = pObj->m_InternalBindSet.begin();
        }

        if (S_OK == hr)
        {
            // Do the standard CComCreator::CreateInstance stuff.
            //
            pObj->SetVoid (NULL);
            pObj->InternalFinalConstructAddRef ();
            hr = pObj->FinalConstruct ();
            pObj->InternalFinalConstructRelease ();

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);

                AddRefObj (pObj->GetUnknown());
                *ppIEnum = pObj;
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }

    if ((S_OK != hr) && (dwFlags & EBPC_TAKE_OWNERSHIP))
    {
        delete pBindSet;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgBindingPath::HrCreateInstance");
    return hr;
}

HRESULT
CImplIEnumNetCfgBindingPath::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgBindingPath** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    Assert(m_iter >= m_pBindSet->begin());

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (m_iter != m_pBindSet->end()))
        {
            // Don't return interfaces to bindpaths that contain
            // components that have had problem loading.
            //
            if (m_iter->FAllComponentsLoadedOkayIfLoadedAtAll())
            {
                if (rgelt)
                {
                    hr = CImplINetCfgBindingPath::HrCreateInstance (
                            m_pINetCfg,
                            m_iter,
                            rgelt + celtFetched);
                }

                celtFetched++;
            }

            m_iter++;
        }

        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Next (
    IN ULONG celt,
    OUT INetCfgBindingPath** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgBindingPath::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Reset ()
{
    Lock();
    Assert (m_pBindSet);
    m_iter = m_pBindSet->begin();
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgBindingPath::Clone (
    OUT IEnumNetCfgBindingPath** ppIEnum)
{
    return E_NOTIMPL;
}


//+---------------------------------------------------------------------------
// CImplIEnumNetCfgComponent -
//

// static
HRESULT
CImplIEnumNetCfgComponent::HrCreateInstance (
    IN CImplINetCfg* pINetCfg,
    IN NETCLASS Class,
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr = E_OUTOFMEMORY;

    CImplIEnumNetCfgComponent* pObj;
    pObj = new CComObject <CImplIEnumNetCfgComponent>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_unIndex = 0;
        pObj->m_Class = Class;

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            hr = pObj->QueryInterface (IID_IEnumNetCfgComponent,
                        (VOID**)ppIEnum);

            // The last thing we do is addref any interfaces we hold.
            // We only do this if we are returning success.
            //
            if (S_OK == hr)
            {
                pObj->HoldINetCfg (pINetCfg);
            }
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplIEnumNetCfgComponent::HrCreateInstance");
    return hr;
}

HRESULT
CImplIEnumNetCfgComponent::HrNextOrSkip (
    IN ULONG celt,
    OUT INetCfgComponent** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Important to initialize rgelt so that in case we fail, we can
    // release only what we put in rgelt.
    //
    if (rgelt)
    {
        ZeroMemory (rgelt, sizeof (*rgelt) * celt);
    }

    hr = HrLockAndTestForValidInterface (IF_DEFAULT);
    if (S_OK == hr)
    {
        CComponentList* pComponents;
        CComponent* pComponent;

        pComponents = &m_pINetCfg->m_pNetConfig->Core.Components;

        // Enumerate the requested number of elements or stop short
        // if we don't have that many left to enumerate.
        //
        ULONG celtFetched = 0;
        while ((S_OK == hr)
                && (celtFetched < celt)
                && (NULL != (pComponent = pComponents->PGetComponentAtIndex(
                                                            m_unIndex))))
        {
            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (((NC_INVALID == m_Class) ||
                 (m_Class == pComponent->Class())) &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll())
            {
                if (rgelt)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface(
                            m_pINetCfg, rgelt + celtFetched);
                }

                celtFetched++;
            }

            m_unIndex++;
        }

        Unlock();

        hr = HrFinishNextOrSkipContract (hr, celtFetched, celt,
                reinterpret_cast<IUnknown**>(rgelt), pceltFetched);
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::HrNextOrSkip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Next (
    IN ULONG celt,
    OUT INetCfgComponent** rgelt,
    OUT ULONG* pceltFetched)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (!rgelt || (!pceltFetched && (1 != celt)))
    {
        hr = E_POINTER;
    }
    else if (rgelt && IsBadWritePtr(rgelt, celt * sizeof(*rgelt)))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = HrNextOrSkip (celt, rgelt, pceltFetched);
    }
    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::Next");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Skip (
    IN ULONG celt)
{
    HRESULT hr = HrNextOrSkip (celt, NULL, NULL);

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplIEnumNetCfgComponent::Skip");
    return hr;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Reset ()
{
    Lock();
    m_unIndex = 0;
    Unlock();

    return S_OK;
}

STDMETHODIMP
CImplIEnumNetCfgComponent::Clone (
    OUT IEnumNetCfgComponent** ppIEnum)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\isdnhook.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N H O O K . H
//
//  Contents:   ISDN Hook functionality for the class installer.
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNHOOK_H_
#define _ISDNHOOK_H_

HRESULT HrAddIsdnWizardPagesIfAppropriate(HDEVINFO hdi,
                                          PSP_DEVINFO_DATA pdeid);

#endif // _ISDNHOOK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ienum.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I E N U M . H
//
//  Contents:   Implements the IEnumNetCfgBindingInterface,
//              IEnumNetCfgBindingPath, and IEnumNetCfgComponent COM
//              interfaces.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "compdefs.h"
#include "complist.h"
#include "iatl.h"
#include "inetcfg.h"

//+---------------------------------------------------------------------------
// IEnumNetCfgBindingInterface -
//
class ATL_NO_VTABLE CImplIEnumNetCfgBindingInterface :
    public CImplINetCfgHolder,
    public IEnumNetCfgBindingInterface
{
private:
    class CImplINetCfgBindingPath*  m_pIPath;
    UINT                            m_unIndex;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgBindingInterface** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgBindingInterface ()
    {
        m_pIPath = NULL;
        m_unIndex = 1;
    }

    VOID FinalRelease ();

    BEGIN_COM_MAP(CImplIEnumNetCfgBindingInterface)
        COM_INTERFACE_ENTRY(IEnumNetCfgBindingInterface)
    END_COM_MAP()

    // IEnumNetCfgBindingInterface
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgBindingInterface** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgBindingInterface** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN class CImplINetCfgBindingPath* pIPath,
        OUT IEnumNetCfgBindingInterface** ppIEnum);
};


//+---------------------------------------------------------------------------
// IEnumNetCfgBindingPath -
//
enum EBPC_FLAGS
{
    EBPC_CREATE_EMPTY    = 0x00000001,
    EBPC_COPY_BINDSET    = 0x00000002,
    EBPC_TAKE_OWNERSHIP  = 0x00000004,
};

class ATL_NO_VTABLE CImplIEnumNetCfgBindingPath :
    public CImplINetCfgHolder,
    public IEnumNetCfgBindingPath
{
friend CImplINetCfgComponent;

private:
    CBindingSet m_InternalBindSet;

    // m_pBindSet is the pointer through which we access the data being
    // enumerated.  It will either point to m_InternalBindSet above or some
    // other bindset that we were given ownership of via HrCreateInstance.
    //
    const CBindingSet*  m_pBindSet;

    // The current enumeration position.
    //
    CBindingSet::const_iterator m_iter;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgBindingPath** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgBindingPath ()
    {
        m_pBindSet = NULL;
        m_iter = NULL;
    }

    ~CImplIEnumNetCfgBindingPath ()
    {
        // Delete m_pBindSet if we own it.  (If it's not aliasing a copied
        // bindset.)
        //
        if (&m_InternalBindSet != m_pBindSet)
        {
            delete m_pBindSet;
        }
    }

    BEGIN_COM_MAP(CImplIEnumNetCfgBindingPath)
        COM_INTERFACE_ENTRY(IEnumNetCfgBindingPath)
    END_COM_MAP()

    // IEnumNetCfgBindingPath
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgBindingPath** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgBindingPath** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN const CBindingSet* pBindSet OPTIONAL,
        IN DWORD dwFlags,
        OUT CImplIEnumNetCfgBindingPath** ppIEnum);
};

//+---------------------------------------------------------------------------
// IEnumNetCfgComponent -
//
class ATL_NO_VTABLE CImplIEnumNetCfgComponent :
    public CImplINetCfgHolder,
    public IEnumNetCfgComponent
{
private:
    UINT            m_unIndex;
    NETCLASS        m_Class;

private:
    HRESULT
    HrNextOrSkip (
        IN ULONG celt,
        OUT INetCfgComponent** rgelt,
        OUT ULONG* pceltFetched);

public:
    CImplIEnumNetCfgComponent ()
    {
        m_unIndex = 0;
    }

    BEGIN_COM_MAP(CImplIEnumNetCfgComponent)
        COM_INTERFACE_ENTRY(IEnumNetCfgComponent)
    END_COM_MAP()

    // IEnumNetCfgComponent
    STDMETHOD (Next) (
        IN ULONG celt,
        OUT INetCfgComponent** rgelt,
        OUT ULONG* pceltFetched);

    STDMETHOD (Skip) (
        IN ULONG celt);

    STDMETHOD (Reset) ();

    STDMETHOD (Clone) (
        OUT IEnumNetCfgComponent** ppIEnum);

public:
    static HRESULT HrCreateInstance (
        IN CImplINetCfg* pINetCfg,
        IN NETCLASS Class,
        OUT IEnumNetCfgComponent** ppIEnum);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\inetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N E T C F G . C P P
//
//  Contents:   Implements the COM interfaces on the top-level NetCfg object.
//              These interfaces are: INetCfg and INetCfgLock.  Also
//              implements a base C++ class inherited by sub-level NetCfg
//              objects which hold a reference to the top-level object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "iclass.h"
#include "icomp.h"
#include "ienum.h"
#include "inetcfg.h"
#include "ncperms.h"
#include "ncras.h"
#include "ncreg.h"
#include "ncui.h"
#include "ncvalid.h"
#include "ndispnp.h"
#include "netcfg.h"
#include "obotoken.h"
#include "resource.h"

// static
HRESULT
CImplINetCfg::HrCreateInstance (
    CNetConfig* pNetConfig,
    CImplINetCfg** ppINetCfg)
{
    Assert (pNetConfig);
    Assert (ppINetCfg);

    HRESULT hr = E_OUTOFMEMORY;

    CImplINetCfg* pObj;
    pObj = new CComObject <CImplINetCfg>;
    if (pObj)
    {
        // Initialize our members.
        //
        pObj->m_pNetConfig = pNetConfig;
        Assert (!pObj->m_fOwnNetConfig);

        // Do the standard CComCreator::CreateInstance stuff.
        //
        pObj->SetVoid (NULL);
        pObj->InternalFinalConstructAddRef ();
        hr = pObj->FinalConstruct ();
        pObj->InternalFinalConstructRelease ();

        if (S_OK == hr)
        {
            AddRefObj (pObj->GetUnknown());
            *ppINetCfg = pObj;
        }

        if (S_OK != hr)
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::HrCreateInstance");
    return hr;
}

HRESULT
CImplINetCfg::HrCoCreateWrapper (
    IN REFCLSID rclsid,
    IN LPUNKNOWN punkOuter,
    IN DWORD dwClsContext,
    IN REFIID riid,
    OUT LPVOID FAR* ppv)
{
/*
    HRESULT hr = S_OK;

    if (!m_fComInitialized)
    {
        m_fComInitialized = TRUE;

        hr = CoInitializeEx (
                NULL,
                COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED);
        if (SUCCEEDED(hr))
        {
            m_fUninitCom = TRUE;
            hr = S_OK;  // mask S_FALSE
        }
        else if (RPC_E_CHANGED_MODE == hr)
        {
            hr = S_OK;
            Assert (!m_fUninitCom);
        }
    }

    if (S_OK == hr)
    {
        hr = CoCreateInstance (rclsid, punkOuter, dwClsContext, riid, ppv);
    }
*/

    HRESULT hr;
    hr = CoCreateInstance (rclsid, punkOuter, dwClsContext, riid, ppv);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::HrCoCreateWrapper");
    return hr;
}

HRESULT
CImplINetCfg::HrCheckForReentrancy (
    IN DWORD dwFlags)
{
    Assert (FImplies(dwFlags & IF_ALLOW_INSTALL_OR_REMOVE,
                     dwFlags & IF_REFUSE_REENTRANCY));

    if (dwFlags & IF_ALLOW_INSTALL_OR_REMOVE)
    {
        if (m_LastAllowedSetupRpl != m_CurrentRpl)
        {
            return E_FAIL;
        }
    }
    else if (0 != m_CurrentRpl)
    {
        return E_FAIL;
    }

    return S_OK;
}

HRESULT
CImplINetCfg::HrIsValidInterface (
    IN DWORD dwFlags)
{
    HRESULT hr;

    // Check if we need to refuse re-entrancy.
    //
    if (dwFlags & IF_REFUSE_REENTRANCY)
    {
        hr = HrCheckForReentrancy (dwFlags);
        if (S_OK != hr)
        {
            return hr;
        }
    }

    // Check if initialized/uninitalized as required.
    //
    if ((dwFlags & IF_NEED_UNINITIALIZED) && m_pNetConfig)
    {
        return NETCFG_E_ALREADY_INITIALIZED;
    }
    else if (!(dwFlags & IF_NEED_UNINITIALIZED) && !m_pNetConfig)
    {
        return NETCFG_E_NOT_INITIALIZED;
    }

    // Check for the write lock.
    //
    if (dwFlags & IF_NEED_WRITE_LOCK)
    {
        if (!m_WriteLock.FIsOwnedByMe ())
        {
            return NETCFG_E_NO_WRITE_LOCK;
        }

        // Needing the write lock means we need the modify context to
        // be prepared (unless the caller specified
        // IF_DONT_PREPARE_MODIFY_CONTEXT).
        //
        if (!m_pNetConfig->ModifyCtx.m_fPrepared &&
            !(dwFlags & IF_DONT_PREPARE_MODIFY_CONTEXT))
        {
            hr = m_pNetConfig->ModifyCtx.HrPrepare ();
            if (S_OK != hr)
            {
                return hr;
            }
        }
    }

    if (!(dwFlags & IF_UNINITIALIZING))
    {
        // Check for an error that occured during the current modification
        // that has not been rolled back yet.  i.e. keep people out until
        // we unwind enough to cleanup our modify context.
        //
        if (m_pNetConfig && (S_OK != m_pNetConfig->ModifyCtx.m_hr))
        {
            return m_pNetConfig->ModifyCtx.m_hr;
        }
    }

    Assert (FImplies(!m_pNetConfig, (dwFlags & IF_NEED_UNINITIALIZED)));

    return S_OK;
}

VOID
CImplINetCfg::LowerRpl (
    IN RPL_FLAGS Flags)
{
    if (RPL_ALLOW_INSTALL_REMOVE == Flags)
    {
        Assert (m_LastAllowedSetupRpl > 0);
        m_LastAllowedSetupRpl--;
    }

    Assert (m_CurrentRpl > 0);
    m_CurrentRpl--;
}

VOID
CImplINetCfg::RaiseRpl (
    IN RPL_FLAGS Flags)
{
    m_CurrentRpl++;

    if (RPL_ALLOW_INSTALL_REMOVE == Flags)
    {
        m_LastAllowedSetupRpl++;
    }
}

HRESULT
CImplINetCfg::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    HRESULT hr;

    Lock();

    hr = HrIsValidInterface (dwFlags);

    if (S_OK != hr)
    {
        Unlock();
    }

    return hr;
}

//+---------------------------------------------------------------------------
// INetCfg -
//
STDMETHODIMP
CImplINetCfg::Initialize (
    IN PVOID pvReserved)
{
    HRESULT hr;

    ULONG* pReserved = (ULONG*)pvReserved;

    // Validate parameters.
    //
    if (FBadInPtrOptional(pReserved))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (
                IF_NEED_UNINITIALIZED | IF_REFUSE_REENTRANCY);
        if (S_OK == hr)
        {
            Assert (!m_pNetConfig);

            hr = CNetConfig::HrCreateInstance (
                    this,
                    &m_pNetConfig);

            if (S_OK == hr)
            {
                Assert (m_pNetConfig);

                m_fOwnNetConfig = TRUE;
            }
            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Initialize");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Uninitialize ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (
            IF_REFUSE_REENTRANCY | IF_UNINITIALIZING);
    if (S_OK == hr)
    {
        Assert (m_pNetConfig);
        Assert (m_fOwnNetConfig);

        delete m_pNetConfig;

        // CGlobalNotifyInterface::ReleaseINetCfg (called via the above
        // delete call) will set m_pNetConfig to NULL for us.
        // Verify it is so.
        //
        Assert (!m_pNetConfig);

        // Release our cache of INetCfgClass pointers.
        //
        ReleaseIUnknownArray (celems(m_apINetCfgClass), (IUnknown**)m_apINetCfgClass);
        ZeroMemory (m_apINetCfgClass, sizeof(m_apINetCfgClass));

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, NETCFG_E_NOT_INITIALIZED == hr,
        "CImplINetCfg::Uninitialize");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Validate ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_REFUSE_REENTRANCY);
    if (S_OK == hr)
    {

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Validate");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Cancel ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_REFUSE_REENTRANCY);
    if (S_OK == hr)
    {
        // Only cancel the changes if we have a prepared modify context.
        //
        if (m_pNetConfig->ModifyCtx.m_fPrepared)
        {
            hr = m_pNetConfig->ModifyCtx.HrApplyIfOkOrCancel (FALSE);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::Cancel");
    return hr;
}

STDMETHODIMP
CImplINetCfg::Apply ()
{
    HRESULT hr;

    // We need the write lock to Apply, but we don't want to prepare the
    // modify context if it has not been prepared.  (This case amounts to
    // applying no changes.)  Hence we use the IF_DONT_PREPARE_MODIFY_CONTEXT
    // flag.
    //
    hr = HrLockAndTestForValidInterface (
            IF_NEED_WRITE_LOCK | IF_REFUSE_REENTRANCY |
            IF_DONT_PREPARE_MODIFY_CONTEXT);
    if (S_OK == hr)
    {
        // Only apply the changes if we have a prepared modify context.
        //
        if (m_pNetConfig->ModifyCtx.m_fPrepared)
        {
            hr = m_pNetConfig->ModifyCtx.HrApplyIfOkOrCancel (TRUE);
        }

        // If there is nothing to apply, but we've previously applied
        // something that indicated a reboot was recommened or required,
        // return an indication.
        //
        else if (m_pNetConfig->ModifyCtx.m_fRebootRecommended ||
                 m_pNetConfig->ModifyCtx.m_fRebootRequired)
        {
            hr = NETCFG_S_REBOOT;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
        "CImplINetCfg::Apply");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumComponents (
    IN const GUID* pguidClass OPTIONAL,
    OUT IEnumNetCfgComponent** ppIEnum)
{
    HRESULT hr;
    NETCLASS Class;

    // Validate parameters.
    //
    if (FBadInPtrOptional(pguidClass) || FBadOutPtr(ppIEnum))
    {
        hr = E_POINTER;
    }
    else if (pguidClass &&
             (NC_INVALID == (Class = NetClassEnumFromGuid(*pguidClass))))
    {
        hr = E_INVALIDARG;
        *ppIEnum = NULL;
    }
    else
    {
        *ppIEnum = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = CImplIEnumNetCfgComponent::HrCreateInstance (
                    this,
                    (pguidClass) ? Class : NC_INVALID,
                    ppIEnum);

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::EnumComponents");
    return hr;
}

STDMETHODIMP
CImplINetCfg::FindComponent (
    IN PCWSTR pszInfId,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr(pszInfId) || FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    else if (wcslen (pszInfId) >= MAX_DEVICE_ID_LEN)
    {
        //impose the same limit on infid as imposed by pnp on pnpid.
        hr = E_INVALIDARG;
    }
    else
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            CComponent* pComponent;

            pComponent = m_pNetConfig->Core.Components.
                            PFindComponentByInfId (pszInfId, NULL);

            // Don't return interfaces to components that have had
            // problem loading.
            //
            if (pComponent &&
                pComponent->Ext.FLoadedOkayIfLoadedAtAll())
            {
                hr = S_OK;

                if (ppIComp)
                {
                    hr = pComponent->HrGetINetCfgComponentInterface (
                            this, ppIComp);
                }
            }
            else
            {
                hr = S_FALSE;
            }


            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CImplINetCfg::FindComponent");
    return hr;
}

STDMETHODIMP
CImplINetCfg::QueryNetCfgClass (
    IN const GUID* pguidClass,
    IN REFIID riid,
    OUT VOID** ppv)
{
    HRESULT hr;
    NETCLASS Class;

    // Validate parameters.
    //
    if (FBadInPtr(pguidClass) || FBadInPtr(&riid) || FBadOutPtr(ppv))
    {
        hr = E_POINTER;
    }
    else if (NC_INVALID == (Class = NetClassEnumFromGuid(*pguidClass)))
    {
        hr = E_INVALIDARG;
        *ppv = NULL;
    }
    else
    {
        *ppv = NULL;

        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            // Get the INetCfgClass interface from our cache.
            //
            Assert(Class < celems(m_apINetCfgClass));
            INetCfgClass* pIClass = m_apINetCfgClass[Class];

            // If we don't have it yet, create it.
            //
            if (!pIClass)
            {
                hr = CImplINetCfgClass::HrCreateInstance (
                        this,
                        Class,
                        &pIClass);
                if (S_OK == hr)
                {
                    pIClass = m_apINetCfgClass[Class] = pIClass;
                    Assert(pIClass);
                }
            }

            // Give the caller the requested interface.
            //
            if (S_OK == hr)
            {
                hr = pIClass->QueryInterface (riid, ppv);
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::QueryNetCfgClass");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgLock -
//
STDMETHODIMP
CImplINetCfg::AcquireWriteLock (
    IN DWORD cmsTimeout,
    IN PCWSTR pszClientDescription,
    OUT PWSTR* ppszClientDescription OPTIONAL)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadInPtr (pszClientDescription) ||
        FBadOutPtrOptional (ppszClientDescription))
    {
        hr = E_POINTER;
    }
    else
    {
        TraceTag (ttidNetcfgBase, "%S is asking for the write lock",
                pszClientDescription);

        // Initialize the optional output parameter.
        //
        if (ppszClientDescription)
        {
            *ppszClientDescription = NULL;
        }

        // Only administrators and netconfig operators can make changes requiring the write lock.
        //
        if (!FIsUserAdmin() && !FIsUserNetworkConfigOps())
        {
            hr = E_ACCESSDENIED;
        }
        else
        {
            hr = HrLockAndTestForValidInterface (
                    IF_NEED_UNINITIALIZED | IF_REFUSE_REENTRANCY);
            if (S_OK == hr)
            {
                // Wait for the mutex to become available.
                //
                if (m_WriteLock.WaitToAcquire (cmsTimeout,
                        pszClientDescription, ppszClientDescription))
                {
                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }

                Unlock();
            }
        }
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfg::AcquireWriteLock");
    return hr;
}

STDMETHODIMP
CImplINetCfg::ReleaseWriteLock ()
{
    HRESULT hr;

    // This method that can be called whether we are initialized or
    // not.  That is why we don't call HrLockAndTestForValidInterface.
    //
    Lock ();

    // Check if we need to refuse re-entrancy.
    //
    hr = HrCheckForReentrancy (IF_DEFAULT);
    if (S_OK == hr)
    {
        m_WriteLock.ReleaseIfOwned ();
    }

    Unlock();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::ReleaseWriteLock");
    return hr;
}

STDMETHODIMP
CImplINetCfg::IsWriteLocked (
    OUT PWSTR* ppszClientDescription)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtrOptional (ppszClientDescription))
    {
        hr = E_POINTER;
    }
    else
    {
        if (ppszClientDescription)
        {
            *ppszClientDescription = NULL;
        }

        // This method that can be called whether we are initialized or
        // not.  That is why we don't call HrLockAndTestForValidInterface.
        //
        Lock ();

        // Check if we need to refuse re-entrancy.
        //
        hr = HrCheckForReentrancy (IF_DEFAULT);
        if (S_OK == hr)
        {
            hr = (m_WriteLock.FIsLockedByAnyone (ppszClientDescription))
                    ? S_OK : S_FALSE;
        }

        Unlock ();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
        "CImplINetCfg::IsWriteLocked");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgInternalSetup -
//
STDMETHODIMP
CImplINetCfg::BeginBatchOperation ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        hr = m_pNetConfig->ModifyCtx.HrBeginBatchOperation ();

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "BeginBatchOperation");
    return hr;
}

STDMETHODIMP
CImplINetCfg::CommitBatchOperation ()
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        hr = m_pNetConfig->ModifyCtx.HrEndBatchOperation (EBO_COMMIT_NOW);

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CommitBatchOperation");
    return hr;
}

STDMETHODIMP
CImplINetCfg::SelectWithFilterAndInstall (
    IN HWND hwndParent,
    IN const GUID* pClassGuid,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    IN const CI_FILTER_INFO* pcfi OPTIONAL,
    OUT INetCfgComponent** ppIComp OPTIONAL)
{
    Assert (pClassGuid);
    HRESULT hr;
    NETCLASS Class;

    if (FBadInPtr(pClassGuid))
    {
        hr = E_POINTER;
    }
    else if (FIsEnumerated ((Class = NetClassEnumFromGuid(*pClassGuid))))
    {
        // This fcn is only for selecting non-enumerated components.
        //
        return E_INVALIDARG;
    }
    else if (!FOboTokenValidForClass(pOboToken, Class) ||
             FBadOutPtrOptional(ppIComp))
    {
        hr = E_POINTER;
    }
    else if (hwndParent && !IsWindow(hwndParent))
    {
        hr = E_INVALIDARG;
    }
    else if (S_OK == (hr = HrProbeOboToken(pOboToken)))
    {
        if (ppIComp)
        {
            *ppIComp = NULL;
        }

        hr = HrLockAndTestForValidInterface (
                IF_NEED_WRITE_LOCK | IF_ALLOW_INSTALL_OR_REMOVE);

        if (S_OK == hr)
        {
            Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

            // if a filter info was specified, and it is for FC_LAN or FC_ATM,
            // we need to set up the reserved member of the filter info for
            // the class installer.
            //
            if (pcfi &&
                    ((FC_LAN == pcfi->eFilter) || (FC_ATM == pcfi->eFilter)))
            {
                // If the pIComp member was NULL, then return invalid
                // argument.
                //
                Assert (pcfi->pIComp);
                CImplINetCfgComponent* pICompImpl;
                pICompImpl = (CImplINetCfgComponent*)pcfi->pIComp;

                hr = pICompImpl->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

                if (S_OK == hr)
                {
                    // The class installer needs to access adapter's attributes
                    // like lower and upper range. So we store a pointer to
                    // the associated CComponent in the reserved field of the filter 
                    // info
                    Assert (pICompImpl->m_pComponent);
                    ((CI_FILTER_INFO*)pcfi)->pvReserved = (void*)
                        pICompImpl->m_pComponent;
                }
            }

            COMPONENT_INSTALL_PARAMS* pParams;
            hr = HrCiSelectComponent (Class, hwndParent, pcfi, &pParams);

            if (pcfi)
            {
                // Don't want to return the private data to the client.
                //
                ((CI_FILTER_INFO*)pcfi)->pvReserved = NULL;
            }

            // Check for installing a NET_SERVICE and active RAS connections
            // exist.  If so, warn the user that this may disconnect those
            // connections.  (This assumes that all filter components are
            // of class NET_SERVICE.)
            //
            if (S_OK == hr)
            {
                Assert (pParams);
                if ((NC_NETSERVICE == pParams->Class) &&
                    FExistActiveRasConnections ())
                {
                    INT nRet;

                    nRet = NcMsgBox (
                            _Module.GetResourceInstance(),
                            hwndParent,
                            IDS_WARNING_CAPTION,
                            IDS_ACTIVE_RAS_CONNECTION_WARNING,
                            MB_ICONQUESTION | MB_YESNO);

                    if (IDYES != nRet)
                    {
                        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                    }
                }
            }

            if (S_OK == hr)
            {
                Assert(pParams);
                CComponent* pComponent;

                // Check to see if the user selected a component that
                // is already installed.  If so, we need to reinstall.
                //
                pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByInfId(pParams->pszInfId, NULL);

                if (!pComponent)
                {
                    pParams->pOboToken = pOboToken;
                    hr = m_pNetConfig->ModifyCtx.
                            HrInstallNewOrReferenceExistingComponent (
                                *pParams, &pComponent);
                }
                else
                {
                    // reinstall. call Update.
                    hr = UpdateNonEnumeratedComponent (
                            pComponent->GetINetCfgComponentInterface(),
                            NSF_COMPONENT_UPDATE, 0);
                }

                // The above may return NETCFG_S_REBOOT so use SUCCEEDED instead
                // of checking for S_OK only.
                //
                if (SUCCEEDED(hr) && ppIComp)
                {
                    pComponent->HrGetINetCfgComponentInterface (
                        this,
                        ppIComp);
                }

                delete pParams;
            }

            Unlock();
        }
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) ||
        (NETCFG_S_REBOOT == hr),
        "SelectWithFilterAndInstall");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumeratedComponentInstalled (
    IN PVOID pv /* type of CComponent */)
{
    HRESULT hr;
    CComponent* pComponent;

    pComponent = (CComponent*)pv;

    Assert (pComponent);
    Assert (FIsEnumerated(pComponent->Class()));
    Assert (pComponent->m_pszInfId && *pComponent->m_pszInfId);
    Assert (pComponent->m_pszPnpId && *pComponent->m_pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        COMPONENT_INSTALL_PARAMS Params;
        CComponent* pReturned;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        ZeroMemory(&Params, sizeof(Params));
        Params.pComponent = (CComponent*)pComponent;

        hr = m_pNetConfig->ModifyCtx.HrInstallNewOrReferenceExistingComponent (
                            Params,
                            &pReturned);

        if (S_OK == hr)
        {
            Assert (pComponent == pReturned);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentInstalled");
    return hr;
}

STDMETHODIMP
CImplINetCfg::EnumeratedComponentUpdated (
    IN PCWSTR pszPnpId)
{
    HRESULT hr;

    Assert (pszPnpId && *pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);

    if (S_OK == hr)
    {
        CComponent* pComponent;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByPnpId (pszPnpId);

        if (pComponent)
        {
            // Note: Core info may have changed so load core info from driver key.

            // If not a remote boot adapter, do a binding analysis to see if
            // anything has changed.

            hr = S_OK;
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentUpdated");
    return hr;
}

STDMETHODIMP
CImplINetCfg::UpdateNonEnumeratedComponent (
    IN INetCfgComponent* pIComp,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    Assert (pIComp);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        CImplINetCfgComponent* pICompToUpdate;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pICompToUpdate = (CImplINetCfgComponent*)pIComp;
        if (pICompToUpdate == NULL)
        {
            return E_OUTOFMEMORY;
        }

        hr = pICompToUpdate->HrIsValidInterface (IF_NEED_COMPONENT_DATA);

        if (S_OK == hr)
        {
            HKEY hkeyInstance;
            CComponent* pComponent = pICompToUpdate->m_pComponent;


            hr = pComponent->HrOpenInstanceKey (KEY_READ_WRITE_DELETE, &hkeyInstance,
                    NULL, NULL);

            if (S_OK == hr)
            {
                DWORD dwNewCharacter;
                COMPONENT_INSTALL_PARAMS Params;
                ZeroMemory (&Params, sizeof (Params));

                Params.Class = pComponent->Class();
                Params.pszInfId = pComponent->m_pszInfId;

                hr = HrCiInstallComponent (Params, NULL, &dwNewCharacter);

                // The driver could not be selected because
                // this component's section or inf is missing.
                // We will remove the component in this case.
                //
                if (SPAPI_E_NO_DRIVER_SELECTED == hr)
                {
                    pComponent->Refs.RemoveAllReferences();

                    hr = m_pNetConfig->ModifyCtx.
                            HrRemoveComponentIfNotReferenced (pComponent,
                                NULL, NULL);
                }
                else if (S_OK == hr)
                {
                    pComponent->m_dwCharacter = dwNewCharacter;

                    AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
                            pComponent);

                    hr = m_pNetConfig->ModifyCtx.HrUpdateComponent (
                            pComponent,
                            dwSetupFlags,
                            dwUpgradeFromBuildNo);
                }
                RegCloseKey (hkeyInstance);
            }
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "UpdateNonEnumeratedComponent");
    return S_OK;
}


STDMETHODIMP
CImplINetCfg::EnumeratedComponentRemoved (
    IN PCWSTR pszPnpId)
{
    HRESULT hr;

    Assert (pszPnpId);

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK |
            IF_ALLOW_INSTALL_OR_REMOVE);

    if (S_OK == hr)
    {
        CComponent* pComponent;

        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        pComponent = m_pNetConfig->Core.Components.
                        PFindComponentByPnpId (pszPnpId);

        // If we found it, remove it.  Otherwise our work here is done.
        //
        if (pComponent)
        {
            hr = m_pNetConfig->ModifyCtx.
                    HrRemoveComponentIfNotReferenced (pComponent, NULL, NULL);
        }

        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "EnumeratedComponentRemoved");
    return hr;
}


//+---------------------------------------------------------------------------
// INetCfgSpecialCase -
//
STDMETHODIMP
CImplINetCfg::GetAdapterOrder (
    OUT DWORD* pcAdapters,
    OUT INetCfgComponent*** papAdapters,
    OUT BOOL* pfWanAdaptersFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImplINetCfg::SetAdapterOrder (
    IN DWORD cAdapters,
    IN INetCfgComponent** apAdapters,
    IN BOOL fWanAdaptersFirst)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CImplINetCfg::GetWanAdaptersFirst (
    OUT BOOL* pfWanAdaptersFirst)
{
    HRESULT hr;

    // Validate parameters.
    //
    if (FBadOutPtr (pfWanAdaptersFirst))
    {
        hr = E_POINTER;
    }
    else
    {
        hr = HrLockAndTestForValidInterface (IF_DEFAULT);
        if (S_OK == hr)
        {
            *pfWanAdaptersFirst = m_pNetConfig->Core.
                                    StackTable.m_fWanAdaptersFirst;

            Unlock();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::GetWanAdaptersFirst");
    return hr;
}

STDMETHODIMP
CImplINetCfg::SetWanAdaptersFirst (
    IN BOOL fWanAdaptersFirst)
{
    HRESULT hr;

    hr = HrLockAndTestForValidInterface (IF_NEED_WRITE_LOCK);
    if (S_OK == hr)
    {
        Assert (m_pNetConfig->ModifyCtx.m_fPrepared);

        m_pNetConfig->Core.StackTable.SetWanAdapterOrder (!!fWanAdaptersFirst);

        Unlock();
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfg::SetWanAdaptersFirst");
    return hr;
}

//+---------------------------------------------------------------------------
// INetCfgPnpReconfigCallback -
//
STDMETHODIMP
CImplINetCfg::SendPnpReconfig (
    IN NCPNP_RECONFIG_LAYER Layer,
    IN PCWSTR pszUpper,
    IN PCWSTR pszLower,
    IN PVOID pvData,
    IN DWORD dwSizeOfData)
{
    HRESULT hr;

    if ((NCRL_NDIS != Layer) && (NCRL_TDI != Layer))
    {
        hr = E_INVALIDARG;
    }
    else if (FBadInPtr(pszUpper) || FBadInPtr(pszLower) ||
             IsBadReadPtr(pvData, dwSizeOfData))
    {
        hr = E_POINTER;
    }
    else
    {
        BOOL fOk;
        UNICODE_STRING LowerString;
        UNICODE_STRING UpperString;
        UNICODE_STRING BindList;
        WCHAR szLower [_MAX_PATH];

        hr = S_OK;

        *szLower = 0;
        if (*pszLower)
        {
            wcscpy (szLower, L"\\Device\\");
            wcsncat (szLower, pszLower, celems(szLower) - wcslen(szLower));
        }

        RtlInitUnicodeString (&LowerString, szLower);
        RtlInitUnicodeString (&UpperString, pszUpper);
        RtlInitUnicodeString (&BindList, NULL);

        fOk = NdisHandlePnPEvent (
                (NCRL_NDIS == Layer) ? NDIS : TDI,
                RECONFIGURE,
                &LowerString,
                &UpperString,
                &BindList,
                pvData,
                dwSizeOfData);

        if (!fOk)
        {
            hr = HrFromLastWin32Error ();
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CImplINetCfg::SendPnpReconfig");
    return hr;
}

//+---------------------------------------------------------------------------
// CImplINetCfgHolder -
//

VOID
CImplINetCfgHolder::HoldINetCfg (
    CImplINetCfg* pINetCfg)
{
    Assert(pINetCfg);
    AddRefObj (pINetCfg->GetUnknown());
    m_pINetCfg = pINetCfg;
}

HRESULT
CImplINetCfgHolder::HrLockAndTestForValidInterface (
    DWORD dwFlags)
{
    HRESULT hr;

    Lock();

    hr = m_pINetCfg->HrIsValidInterface (dwFlags);

    if (S_OK != hr)
    {
        Unlock();
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CImplINetCfgHolder::HrLockAndTestForValidInterface");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\inetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N E T C F G . H
//
//  Contents:   Implements the COM interfaces on the top-level NetCfg object.
//              These interfaces are: INetCfg and INetCfgLock.  Also
//              implements a base C++ class inherited by sub-level NetCfg
//              objects which hold a reference to the top-level object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "iatl.h"
#include "compdefs.h"
#include "nccom.h"
#include "ncres.h"
#include "netcfgp.h"
#include "netcfgn.h"
#include "wrlock.h"

// Flags for HrIsValidInterface.
//
enum IF_FLAGS
{
    IF_DEFAULT                      = 0x00000000,
    IF_NEED_UNINITIALIZED           = 0x00000001,
    IF_NEED_WRITE_LOCK              = 0x00000002,
    IF_NEED_COMPONENT_DATA          = 0x00000004,
    IF_REFUSE_REENTRANCY            = 0x00000010,
    IF_ALLOW_INSTALL_OR_REMOVE      = 0x00000020,
    IF_UNINITIALIZING               = 0x00000040,
    IF_DONT_PREPARE_MODIFY_CONTEXT  = 0x00000080,
};

enum RPL_FLAGS
{
    RPL_ALLOW_INSTALL_REMOVE,
    RPL_DISALLOW,
};

class CNetConfig;

class ATL_NO_VTABLE CImplINetCfg :
    public CComObjectRootEx <CComMultiThreadModel>,
    public CComCoClass<CImplINetCfg, &CLSID_CNetCfg>,
    public INetCfg,
    public INetCfgLock,
    public INetCfgInternalSetup,
    public INetCfgSpecialCase,
    public INetCfgPnpReconfigCallback
{
friend class CGlobalNotifyInterface;
friend class CImplIEnumNetCfgBindingPath;
friend class CImplIEnumNetCfgComponent;
friend class CImplINetCfgBindingPath;
friend class CImplINetCfgClass;
friend class CImplINetCfgComponent;
friend class CModifyContext;
friend class CNetCfgInternalDiagnostic;
friend class CNetConfig;
friend class CNotifyObjectInterface;

private:
    // This is our data.  We own it (i.e. we created it) if Initialize is
    // called.  We will delete it when Unintialize is called.  We won't own
    // it if we were created by CNetConfig.
    //
    CNetConfig*     m_pNetConfig;

    // m_apINetCfgClass is an array of cached INetCfgClass pointers.
    // These are created in QueryNetCfgClass (if needed) and released
    // during Uninitialize.
    //
    INetCfgClass*   m_apINetCfgClass [NC_CELEMS];

    // This controls the write lock.
    //
    CWriteLock      m_WriteLock;

    // Reentrancy Protection Levels.  General reentrancy is prevented when
    // m_CurrentRpl is non-zero.  Reentrancy for setup calls (Install or
    // Remove) is allowed when m_LastAllowedSetupRpl equals m_CurrentRpl.
    // Both are incremented when we call a notify object and we want to
    // prevent general reentrancy but allow Install or Remove.  Only
    // m_CurrentRpl is incremented when we want to prevent all reentrancy.
    // See LowerRpl() and RaiseRpl().
    //
    ULONG           m_CurrentRpl;
    ULONG           m_LastAllowedSetupRpl;

    BOOLEAN         m_fOwnNetConfig;

private:
    HRESULT
    HrCheckForReentrancy (
        IN DWORD dwFlags);

    HRESULT
    HrLockAndTestForValidInterface (
        IN DWORD dwFlags);

    VOID
    LowerRpl (
        IN RPL_FLAGS Flags);

    VOID
    RaiseRpl (
        IN RPL_FLAGS Flags);

public:
    CImplINetCfg ()
    {
        m_pNetConfig = NULL;
        m_CurrentRpl = 0;
        m_LastAllowedSetupRpl = 0;
        m_fOwnNetConfig = FALSE;
        ZeroMemory (m_apINetCfgClass, sizeof(m_apINetCfgClass));
    }

    VOID FinalRelease ()
    {
        // Should be NULL because we either delete it during Uninitialize,
        // or it is NULL'd for us via CGlobalNotifyInterface::ReleaseINetCfg
        // before they release us.
        //
        AssertH (!m_pNetConfig);

        // Release our cache of INetCfgClass pointers.
        //
        ReleaseIUnknownArray (celems(m_apINetCfgClass), (IUnknown**)m_apINetCfgClass);

    }

    HRESULT HrCoCreateWrapper (
        IN REFCLSID rclsid,
        IN LPUNKNOWN pUnkOuter,
        IN DWORD dwClsContext,
        IN REFIID riid,
        OUT LPVOID FAR* ppv);

    HRESULT HrIsValidInterface (
        DWORD dwFlags);

    BEGIN_COM_MAP(CImplINetCfg)
        COM_INTERFACE_ENTRY(INetCfg)
        COM_INTERFACE_ENTRY(INetCfgLock)
        COM_INTERFACE_ENTRY(INetCfgInternalSetup)
        COM_INTERFACE_ENTRY(INetCfgSpecialCase)
        COM_INTERFACE_ENTRY(INetCfgPnpReconfigCallback)
    END_COM_MAP()

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NETCFG)

    // INetCfg
    //
    STDMETHOD (Initialize) (
        IN PVOID pvReserved);

    STDMETHOD (Uninitialize) ();

    STDMETHOD (Validate) ();

    STDMETHOD (Cancel) ();

    STDMETHOD (Apply) ();

    STDMETHOD (EnumComponents) (
        IN const GUID* pguidClass OPTIONAL,
        OUT IEnumNetCfgComponent** ppIEnum);

    STDMETHOD (FindComponent) (
        IN PCWSTR pszInfId,
        OUT INetCfgComponent** ppIComp);

    STDMETHOD (QueryNetCfgClass) (
        IN const GUID* pguidClass,
        IN REFIID riid,
        OUT VOID** ppv);

    // INetCfgLock
    //
    STDMETHOD (AcquireWriteLock) (
        IN DWORD cmsTimeout,
        IN PCWSTR pszClientDescription,
        OUT PWSTR* ppszClientDescription);

    STDMETHOD (ReleaseWriteLock) ();

    STDMETHOD (IsWriteLocked) (
        OUT PWSTR* ppszClientDescription);

    // INetCfgInternalSetup
    //
    STDMETHOD (BeginBatchOperation) ();
    STDMETHOD (CommitBatchOperation) ();

    STDMETHOD (SelectWithFilterAndInstall) (
        IN HWND hwndParent,
        IN const GUID* pClassGuid,
        IN OBO_TOKEN* pOboToken,
        IN const CI_FILTER_INFO* pcfi,
        OUT INetCfgComponent** ppnccItem);

    STDMETHOD (EnumeratedComponentInstalled) (
        IN PVOID pComponent /* type of CComponent */);

    STDMETHOD (EnumeratedComponentUpdated) (
        IN PCWSTR pszPnpId);

    STDMETHOD (UpdateNonEnumeratedComponent) (
        IN INetCfgComponent* pIComp,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);

    STDMETHOD (EnumeratedComponentRemoved) (
        IN PCWSTR pszPnpId);

    // INetCfgSpecialCase
    //
    STDMETHOD (GetAdapterOrder) (
        OUT DWORD* pcAdapters,
        OUT INetCfgComponent*** papAdapters,
        OUT BOOL* pfWanAdaptersFirst);

    STDMETHOD (SetAdapterOrder) (
        IN DWORD cAdapters,
        IN INetCfgComponent** apAdapters,
        IN BOOL fWanAdaptersFirst);

    STDMETHOD (GetWanAdaptersFirst) (
        OUT BOOL* pfWanAdaptersFirst);

    STDMETHOD (SetWanAdaptersFirst) (
        IN BOOL fWanAdaptersFirst);

    // INetCfgPnpReconfigCallback
    //
    STDMETHOD (SendPnpReconfig) (
        IN NCPNP_RECONFIG_LAYER Layer,
        IN PCWSTR pszUpper,
        IN PCWSTR pszLower,
        IN PVOID pvData,
        IN DWORD dwSizeOfData);

    static HRESULT
    HrCreateInstance (
        CNetConfig* pNetConfig,
        CImplINetCfg** ppINetCfg);
};


//+---------------------------------------------------------------------------
// CImplINetCfgHolder -
//
// No need for a critical section for these objects because they
// use the lock provided by CImplINetCfg.  i.e. use CComMultiThreadModelNoCS
// instead of CComMultiThreadModel.
//
class ATL_NO_VTABLE CImplINetCfgHolder :
    public CComObjectRootEx <CComMultiThreadModelNoCS>
{
protected:
    CImplINetCfg*   m_pINetCfg;

protected:
    VOID HoldINetCfg (
        CImplINetCfg* pINetCfg);

    HRESULT HrLockAndTestForValidInterface (
        DWORD dwFlags);

public:
    CImplINetCfgHolder ()
    {
        m_pINetCfg = NULL;
    }

#if DBG
    ~CImplINetCfgHolder ()
    {
        AssertH (!m_pINetCfg);
    }
#endif // DBG

    VOID FinalRelease ()
    {
        AssertH (m_pINetCfg);
        ReleaseObj (m_pINetCfg->GetUnknown());

#if DBG
        m_pINetCfg = NULL;
#endif // DBG

        CComObjectRootEx <CComMultiThreadModelNoCS>::FinalRelease();
    }

    VOID Lock ()
    {
        CComObjectRootEx <CComMultiThreadModelNoCS>::Lock();

        AssertH(m_pINetCfg);
        m_pINetCfg->Lock ();
    }
    VOID Unlock ()
    {
        AssertH(m_pINetCfg);
        m_pINetCfg->Unlock ();

        CComObjectRootEx <CComMultiThreadModelNoCS>::Unlock();
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\install.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N S T A L L . C P P
//
//  Contents:   Implements actions related to installing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "lockdown.h"
#include "netcfg.h"
#include "obotoken.h"
#include "util.h"


#if DBG

VOID
DbgVerifyComponentInstallParams (
    IN const COMPONENT_INSTALL_PARAMS& Params)
{
    if (!Params.pComponent)
    {
        Assert (FIsValidNetClass (Params.Class));
        Assert (Params.pszInfId && *Params.pszInfId);
        Assert (FOboTokenValidForClass (Params.pOboToken, Params.Class));
    }
}

#else

#define DbgVerifyComponentInstallParams NOP_FUNCTION

#endif


VOID
CModifyContext::InstallAndAddAndNotifyComponent(
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent)
{
    CNetConfig* pNetConfig;
    CComponent* pComponent;
    UINT cPreviousAddedBindPaths;

    Assert (this);
    Assert (S_OK == m_hr);
    DbgVerifyComponentInstallParams (Params);
    Assert (ppComponent);

    pNetConfig = PNetConfig();

    // Call the class installer to do the grunt work of finding the
    // INF, processing it, creating the instance key, etc.  If this
    // all succeeds, we are returned an allocated CComponent.
    //
    //$REVIEW: Think about having HrCiInstallComponent return the
    // list of required components.  This will keep us from having to
    // reopen the instance key and ndi key.
    //
    if (!Params.pComponent)
    {

// error test only
//if (0 == _wcsicmp(L"ms_nwipx", Params.pszInfId))
//{
//    TraceTag (ttidBeDiag, "Simulating failure for: %S", Params.pszInfId);
//    m_hr = E_FAIL;
//    return;
//}

        m_hr = HrCiInstallComponent (Params, &pComponent, NULL);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }
    else
    {
        pComponent = Params.pComponent;
    }
    Assert (pComponent);

    // Install all of the components required by this component.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallOrRemoveRequiredComponents (pComponent, IOR_INSTALL);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // If this is an enumerated component, and it has the same PnpId as
    // a component already in our core, we will remove the existing component.
    // This can happen if an adapter is removed and reinstalled and the
    // binding engine could not be notified of both because the write
    // lock was held at the time of remove.
    //
    if (FIsEnumerated(pComponent->Class()))
    {
        CComponent* pDup;

        while (NULL != (pDup = pNetConfig->Core.Components.PFindComponentByPnpId (
                                    pComponent->m_pszPnpId)))
        {
            TraceTag (ttidBeDiag, "Removing duplicate PnpId: %S",
                pComponent->m_pszPnpId);

            pDup->Refs.RemoveAllReferences();
            (VOID) HrRemoveComponentIfNotReferenced (pDup, NULL, NULL);
        }
    }

    // We only insert the component and its stack table entries into our
    // list after all of its required components have been installed.
    // This is just the concept of "don't consider a component installed
    // until all of its requirements are also installed".
    // i.e. Atomicity of component installation.
    //
    m_hr = pNetConfig->Core.HrAddComponentToCore (pComponent, INS_SORTED);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Notify the component's notify object it is being installed.
    // This also sends global notifications to other notify objects
    // who may be interested.
    //
    // THIS MAY CAUSE RECURSION
    //
    m_hr = pNetConfig->Notify.ComponentAdded (pComponent, Params.pnip);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Note the number of bindpaths currently in m_AddedBindPaths.
    // We need this so that when we add to the set, we only notify
    // for the ones we add.
    //
    cPreviousAddedBindPaths = m_AddedBindPaths.CountBindPaths ();

    // Get the bindpaths that involve the component we are adding.
    // Add these to the added bindpaths we are keeping track of.
    //
    m_hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ADD_TO_BINDSET | GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &m_AddedBindPaths);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Query and notify for these added bindpaths.
    //
    // THIS MAY CAUSE RECURSION
    //
    if (m_AddedBindPaths.CountBindPaths() > cPreviousAddedBindPaths)
    {
        m_hr = pNetConfig->Notify.QueryAndNotifyForAddedBindPaths (
                    &m_AddedBindPaths,
                    cPreviousAddedBindPaths);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }

    // Install any components as a convenience to the user
    // depending on the component we just installed component.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallConvenienceComponentsForUser (pComponent);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Assign the output pointer.
    //
    Assert (S_OK == m_hr);
    Assert (pComponent);
    *ppComponent = pComponent;
}


//+---------------------------------------------------------------------------
// Install components on behalf of the user
//
// Assumptions:
//
VOID
CModifyContext::InstallConvenienceComponentsForUser (
    IN const CComponent* pComponent)
{
    COMPONENT_INSTALL_PARAMS Params;
    OBO_TOKEN UserOboToken;
    CComponent* pNewComponent;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    ZeroMemory (&UserOboToken, sizeof(UserOboToken));
    UserOboToken.Type = OBO_USER;

    // If the component is an ATM adapter, make sure ATMUNI and ATMLANE are
    // installed.
    //
    if (FSubstringMatch (L"ndisatm", pComponent->Ext.PszUpperRange(),
            NULL, NULL))
    {
        ZeroMemory (&Params, sizeof(Params));
        Params.pOboToken = &UserOboToken;
        Params.Class = NC_NETTRANS;

        Params.pszInfId  = L"ms_atmuni";
        HrInstallNewOrReferenceExistingComponent (Params, &pNewComponent);

        Params.pszInfId  = L"ms_atmlane";
        HrInstallNewOrReferenceExistingComponent (Params, &pNewComponent);
    }
}

HRESULT
CModifyContext::HrInstallNewOrReferenceExistingComponent (
    IN const COMPONENT_INSTALL_PARAMS& Params,
    OUT CComponent** ppComponent)
{
    HRESULT hr;
    BOOL fInstallNew;
    CNetConfig* pNetConfig;
    CComponent* pComponent;

    Assert (this);
    Assert (S_OK == m_hr);
    DbgVerifyComponentInstallParams (Params);
    Assert (ppComponent);

    // Initialize the output parameter.
    //
    *ppComponent = NULL;

    // Assume, for now, that we will be installing a new component.
    //
    hr = S_OK;
    fInstallNew = TRUE;
    pNetConfig = PNetConfig();
    pComponent = NULL;

    // If the user wishes to add a reference if the component is already
    // installed...
    //
    if (Params.pOboToken)
    {
        // ...then look to see if the component is installed...
        //
        pComponent = pNetConfig->Core.Components.
                        PFindComponentByInfId (Params.pszInfId, NULL);

        // ...if it is, we won't be installing a new one.
        //
        if (pComponent)
        {
            fInstallNew = FALSE;

            if (pComponent->m_dwCharacter & NCF_SINGLE_INSTANCE)
            {
                *ppComponent = NULL;
                return HRESULT_FROM_SETUPAPI(ERROR_DEVINST_ALREADY_EXISTS);
            }

            // If the existing component is already referenced by
            // the specified obo token, we can return.
            //
            if (pComponent->Refs.FIsReferencedByOboToken (Params.pOboToken))
            {
                *ppComponent = pComponent;
                return S_OK;
            }
        }

        // ...otherwise, (it is not in the current core) but if it IS
        // in the core we started with, it means someone had previously
        // removed it during this modify context and now wants to add it
        // back.  This is tricky and should probably be implemented later.
        // For now, return an error and throw up an assert so we can see
        // who needs to do this.
        //
        else if (m_CoreStartedWith.Components.
                        PFindComponentByInfId (Params.pszInfId, NULL))
        {
            AssertSz (FALSE, "Whoa.  Someone is trying to install a "
                "component that was previously removed during this same "
                "modify context.  We need to decide if we can support this.");
            return E_UNEXPECTED;
        }
    }

    // If we've decided to install a new component, (which can happen
    // if an obo token was not specified OR if an obo token was specified
    // but the component was not already present) then do the work.
    //
    if (fInstallNew)
    {
        // If the component to be installed is locked down, bail out.
        // Note we don't put the modify context into error if this situation
        // occurs.
        // Note too that we only do this if Params.pComponent is not present
        // which would indicate the class installer calling us to install an
        // enumerated component.
        //
        if (!Params.pComponent)
        {
            if (FIsComponentLockedDown (Params.pszInfId))
            {
                TraceTag (ttidBeDiag, "%S is locked down and cannot be installed "
                    "until the next reboot.",
                    Params.pszInfId);

                return NETCFG_E_NEED_REBOOT;
            }
        }

        // Make sure the modify context is setup and keep track of our
        // recursion depth.
        //
        PushRecursionDepth ();
        Assert (S_OK == m_hr);

        InstallAndAddAndNotifyComponent (Params, ppComponent);

        hr = HrPopRecursionDepth ();

        // If the component to be installed was not found, the return code
        // will be SPAPI_E_NO_DRIVER_SELECTED.  We want to return this to the
        // caller, but we don't need the context to remain with this error.
        // This will allow subsequent calls to install other componetns to
        // proceed.
        //
        if (SPAPI_E_NO_DRIVER_SELECTED == m_hr)
        {
            m_hr = S_OK;
            Assert (SPAPI_E_NO_DRIVER_SELECTED == hr);
        }
    }
    else
    {
        // Referencing pComponent on behalf of the obo token.
        //
        Assert (pComponent);
        Assert (Params.pOboToken);

        // Make sure the modify context is setup and keep track of our
        // recursion depth.
        //
        PushRecursionDepth ();
        Assert (S_OK == m_hr);

        m_hr = pComponent->Refs.HrAddReferenceByOboToken (Params.pOboToken);

        if (S_OK == m_hr)
        {
            *ppComponent = pComponent;
        }

        hr = HrPopRecursionDepth ();
    }

    // If we are returning success, we'd better have our ouput parameter set.
    //
    Assert (FImplies(SUCCEEDED(hr), *ppComponent));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\install.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       I N S T A L L . H
//
//  Contents:   Implements actions related to installing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once

#include "comp.h"
#include "ncnetcfg.h"

struct COMPONENT_INSTALL_PARAMS
{
    IN NETCLASS                         Class;
    IN PCWSTR                           pszInfId;
    IN PCWSTR                           pszInfFile; OPTIONAL
    IN const OBO_TOKEN*                 pOboToken;  OPTIONAL
    IN const NETWORK_INSTALL_PARAMS*    pnip;       OPTIONAL
    IN HWND                             hwndParent; OPTIONAL
    IN CComponent*                      pComponent; OPTIONAL
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\lanamap.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L A N A M A P . C P P
//
//  Contents:   NetBios Lana map routines.
//
//  Notes:
//
//  Author:     billbe   17 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop

#include "lanamap.h"
#include "nceh.h"
#include "ncerror.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netsetup.h"
#include "persist.h"

const WCHAR c_szRegKeyNetBiosLinkage[] =
        L"System\\CurrentControlSet\\Services\\NetBios\\Linkage";

const WCHAR c_szRegKeyNetBiosParameters[] =
        L"System\\CurrentControlSet\\Services\\NetBIOS\\Parameters";

const WCHAR c_szRegValueLanaMap[] = L"LanaMap";
const WCHAR c_szRegValueMaxLana[] = L"MaxLana";

#if DBG
    VOID DbgVerifyBindPathString (PCWSTR pszBindPath);
#else
    VOID DbgVerifyBindPathString (PCWSTR /*pszBindPath*/) {}
#endif


typedef vector<const GUID*> VECTOR_OF_GUIDS;

struct LANA_BIND_PATH
{
    VECTOR_OF_GUIDS GuidsOfComponentsOnPath;
    BYTE LanaNumber;
};

VOID
GetFirstComponentFromBindPath (
    IN PCWSTR pszBindPath,
    OUT PCWSTR* ppszComponentStart,
    OUT DWORD* pcchComponent)
{
    PCWSTR pszComponentEnd;
    PCWSTR pszComponentStart;

    Assert (pszBindPath);
    Assert (ppszComponentStart);
    Assert (pcchComponent);

    *pcchComponent = 0;

    // The Bind path is of the form \Device\<component>_<component>_<etc.>
    //
    pszComponentEnd = wcschr (pszBindPath, L'_');
    if (!pszComponentEnd)
    {
        // There is no underscore so set the end pointer
        // to the end of the string.
        pszComponentEnd = pszBindPath + wcslen (pszBindPath);
    }

    for (pszComponentStart = pszComponentEnd;
            pszComponentStart != pszBindPath; pszComponentStart--)
    {
        // Backup from the end until we get to the slash.
        // If we don't find a slash, the loop will stop when
        // we hit the beginning.
        //
        if (L'\\' == *pszComponentStart)
        {
            // We hit the slash. The Component start is one character
            // past that.
            pszComponentStart++;
            break;
        }
    }

    *ppszComponentStart = pszComponentStart;
    *pcchComponent = (DWORD)(pszComponentEnd - pszComponentStart);
}

VOID
CLanaMap::Dump (
    OUT CWideString* pstr) const
{
    Assert (this);
    Assert (pstr);

    WCHAR pszBuf[1024];
    pstr->erase();

    const CLanaEntry* pEntry;

    for (pEntry = begin(); pEntry != end(); pEntry++)
    {
        swprintf (pszBuf, L"Lana: %3d  Export: %d Path: %s\n",
                pEntry->RegLanaEntry.LanaNumber,
                pEntry->RegLanaEntry.Exported, pEntry->pszBindPath);

        pstr->append (pszBuf);
    }
}

HRESULT
CLanaMap::HrLoadLanaMap()
{
    HRESULT hr;
    HKEY hkey;

    // The lana map is stored in Netbios's linkage key.
    //
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNetBiosLinkage,
            KEY_READ, &hkey);

    if (S_OK == hr)
    {
        REG_LANA_ENTRY* pRegEntries;
        DWORD cbLanaEntries;

        // Read in the lana map binary blob.
        hr = HrRegQueryBinaryWithAlloc (hkey, c_szRegValueLanaMap,
                (BYTE**)&pRegEntries, &cbLanaEntries);

        if (S_OK == hr)
        {
            DWORD cEntries = cbLanaEntries / sizeof (REG_LANA_ENTRY);

            PWSTR pmszBindPaths;

            // Grab the bind paths for NetBios so we can match them
            // up with the lana map.
            hr = HrRegQueryMultiSzWithAlloc (hkey, L"Bind", &pmszBindPaths);

            if (S_OK == hr)
            {
                PCWSTR pszScan;
                DWORD cPaths;
                for (pszScan = pmszBindPaths, cPaths = 0;
                        *pszScan;
                            pszScan += wcslen(pszScan) + 1)
                {
                    ++cPaths;
                }

                m_pszBindPathsBuffer = pmszBindPaths;

                hr = HrReserveRoomForEntries (cPaths);

                if (S_OK == hr)
                {
                    DWORD dw = 0;
                    CLanaEntry Entry;

                    for (pszScan = pmszBindPaths;
                            *pszScan;
                                pszScan += wcslen(pszScan) + 1)
                    {
                        Entry.pszBindPath = pszScan;

                        if (dw < cEntries)
                        {
                            Entry.RegLanaEntry.LanaNumber =
                                    pRegEntries[dw].LanaNumber;
                            Entry.RegLanaEntry.Exported =
                                    pRegEntries[dw].Exported;
                        }
                        else
                        {
                            // We have more bind paths but no more
                            // lana map entries to correlate.
                            // Now we assign available lanas.
                            //
                            BYTE* location = find (m_LanasInUse,
                                    m_LanasInUse + MAX_LANA, 0);
                            if (location != m_LanasInUse + MAX_LANA)
                            {
                                Entry.RegLanaEntry.LanaNumber =
                                        (BYTE)(location - m_LanasInUse);
                                Entry.RegLanaEntry.Exported = 1;
                            }
                        }

                        // Mark this Lana as taken.
                        m_LanasInUse[Entry.RegLanaEntry.LanaNumber] = 1;

                        hr = HrAppendEntry (&Entry);

                        if (S_OK != hr)
                        {
                            break;
                        }

                        dw++;
                    }
                }

            }
            MemFree (pRegEntries);
        }

        // If lana map or bind is not there, it is okay since we will be
        // recreating the info.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }

        RegCloseKey (hkey);
    }
    else
    {
        // If the linkage has not been created yet, it is okay since it will
        // be creating after the lanamap is written out.  This occurs when
        // NetBios is first installed.
        //
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrLoadLanaMap");
    return hr;
}

#if DBG
VOID
DbgVerifyBindPathString (
    PCWSTR pszBindPath)
{
    const WCHAR c_szDevice[] = L"\\Device\\";
    Assert (pszBindPath);
    Assert (0 == _wcsnicmp (pszBindPath, c_szDevice, celems(c_szDevice)-1));
}
#endif // DBG


BOOL
FBindPathContainsMultipleInterface (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPath)
{
    BOOL fContainsMultipleInterface = FALSE;
    PCWSTR pszLastDevice = wcsrchr (pszBindPath, L'{');

    if (pszLastDevice)
    {
        GUID Guid;
        if (S_OK == IIDFromString ((PWSTR)pszLastDevice, &Guid))
        {
            // If this is a multiple interface, it will not exist
            // as a component.
            //
            CComponent* pComponent;

            pComponent = Components.
                    PFindComponentByInstanceGuid (&Guid);

            if (!pComponent)
            {
                // This means the path contains a multiple interface.
                fContainsMultipleInterface = TRUE;
            }
        }
    }
    return fContainsMultipleInterface;
}

HRESULT
CLanaMap::HrAppendEntry (
    IN CLanaEntry* pEntry)
{
    HRESULT hr;

    Assert (pEntry);
    Assert (pEntry->pszBindPath && *(pEntry->pszBindPath));

    DbgVerifyBindPathString (pEntry->pszBindPath);

    NC_TRY
    {
        push_back (*pEntry);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    if (S_OK == hr)
    {
        // Update out lanas in use map.
        m_LanasInUse[pEntry->RegLanaEntry.LanaNumber] = 1;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrAppendLanaEntry");
    return hr;
}

HRESULT
CLanaMap::HrCreateRegistryMap()
{
    HRESULT hr;

    CLanaEntry* pEntry;

    if (m_RegistryLanaMap.CountOfBytesUsed())
    {
        m_RegistryLanaMap.Clear();
    }

    hr = m_RegistryLanaMap.HrReserveBytes (
            CountEntries() * sizeof (REG_LANA_ENTRY));

    if (S_OK == hr)
    {
        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            hr = m_RegistryLanaMap.HrCopyBytes ((BYTE*)&pEntry->RegLanaEntry,
                    sizeof (REG_LANA_ENTRY));
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaEntry::HrCreateRegistryMap");
    return hr;
}

HRESULT
CLanaMap::HrReserveRoomForEntries (
    IN UINT cEntries)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cEntries);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrReserveRoomForEntries");
    return hr;
}

BYTE
CLanaMap::GetExportValue (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPath)
{
    const WCHAR c_szNdisWanNbfIn[] = L"NdisWanNbfIn{";

    BYTE Exported = 1;
    PCWSTR pszLastDevice;

    Assert (pszBindPath && *pszBindPath);

    // Get the last "device" on the bind path.
    // If it matches NbfIn, we don't export.
    //

    pszLastDevice = wcsrchr (pszBindPath, L'_');
    if (!pszLastDevice)
    {
        pszLastDevice = wcsrchr (pszBindPath, L'\\');
        if (!pszLastDevice)
        {
            pszLastDevice = pszBindPath;
        }
    }

    if (pszLastDevice != pszBindPath)
    {
        pszLastDevice++;
    }

    if (0 == _wcsnicmp (pszLastDevice, c_szNdisWanNbfIn,
            wcslen (c_szNdisWanNbfIn)))
    {
        Exported = 0;
    }

    // If we haven't turned off export, check to see if this bind path
    // contains a multiple interface.
    //
    if (0 != Exported && FBindPathContainsMultipleInterface (Components,
            pszBindPath))
    {
        Exported = 0;
    }

    return Exported;
}

VOID
CLanaMap::GetLanaEntry (
    IN const CComponentList& Components,
    IN CLanaEntry* pEntry)
{
    CLanaEntry* pCurrentEntry;
    BOOL fFound = FALSE;

    Assert (pEntry->pszBindPath);

    // Check the map for the entry
    //
    for (pCurrentEntry = begin(); pCurrentEntry != end(); pCurrentEntry++)
    {
        if (0 == _wcsicmp (pEntry->pszBindPath, pCurrentEntry->pszBindPath))
        {
            // Found the entry, set the lana number and figure out
            // if this entry should be exported.
            //
            pEntry->RegLanaEntry.Exported =
                    GetExportValue (Components, pEntry->pszBindPath);
            pEntry->RegLanaEntry.LanaNumber =
                    pCurrentEntry->RegLanaEntry.LanaNumber;
            fFound = TRUE;
            break;
        }
    }

    if (!fFound)
    {
        // no match, get next available lana number
        BYTE* location = find (m_LanasInUse, m_LanasInUse + MAX_LANA, 0);
        if (location != m_LanasInUse + MAX_LANA)
        {
            pEntry->RegLanaEntry.Exported =
                    GetExportValue (Components, pEntry->pszBindPath);
            pEntry->RegLanaEntry.LanaNumber = (BYTE)(location - m_LanasInUse);
            m_LanasInUse[location - m_LanasInUse] = 1;
        }
        else
        {
            // They tell me this is impossible.
            AssertSz (FALSE, "No more available Lanas.");
            pEntry->RegLanaEntry.Exported = 0;
            pEntry->RegLanaEntry.LanaNumber = MAX_LANA + 1;
        }
    }
}

HRESULT
CLanaMap::HrWriteLanaMapConfig()
{
    HKEY hkeyLinkage;
    HRESULT hr;

    hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE, c_szRegKeyNetBiosLinkage,
            REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hkeyLinkage, NULL);

    if (S_OK == hr)
    {
        const BYTE* pbBuffer;
        DWORD cbBuffer = m_RegistryLanaMap.CountOfBytesUsed();

        if (cbBuffer > 0)
        {
            pbBuffer = m_RegistryLanaMap.PbBuffer();
        }
        else
        {
            pbBuffer = NULL;
        }

        hr = HrRegSetBinary (hkeyLinkage, c_szRegValueLanaMap,
                pbBuffer, cbBuffer);
        RegCloseKey (hkeyLinkage);
    }

    if (S_OK == hr)
    {
        HKEY hkeyParams;
        hr = HrRegCreateKeyEx (HKEY_LOCAL_MACHINE,
                c_szRegKeyNetBiosParameters, REG_OPTION_NON_VOLATILE,
                KEY_WRITE, NULL, &hkeyParams, NULL);

        if (S_OK == hr)
        {
            hr = HrRegSetDword (hkeyParams, c_szRegValueMaxLana,
                    GetMaxLana());

            RegCloseKey (hkeyParams);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrWriteLanaMapConfig");
    return hr;
}

HRESULT
HrGetNetBiosProviderName (
    IN CComponent* pComponent,
    OUT PWSTR pszName)
{
    HRESULT hr;

    Assert (pComponent);
    Assert (pszName);

    // The netbios provider name for a component is stored in its
    // <service>\Parameters key.
    //
    HKEY hkeyService;
    hr = pComponent->HrOpenServiceKey (KEY_READ, &hkeyService);

    if (S_OK == hr)
    {
        HKEY hkeyParams;
        hr = HrRegOpenKeyEx (hkeyService, L"Parameters", KEY_READ,
                &hkeyParams);

        if (S_OK == hr)
        {
            DWORD cbBuffer = _MAX_PATH;
            hr = HrRegQuerySzBuffer (hkeyParams, L"NbProvider", pszName,
                    &cbBuffer);

            RegCloseKey (hkeyParams);
        }
        RegCloseKey (hkeyService);
    }

    TraceHr (ttidError, FAL, hr,
             HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr,
             "HrGetNetBiosProviderName");
    return hr;
}

HRESULT
CLanaMap::HrSetLanaNumber (
    IN BYTE OldLanaNumber,
    IN BYTE NewLanaNumber)
{
    HRESULT hr = S_OK;
    if (0 == m_LanasInUse[NewLanaNumber])
    {
        CLanaEntry* pEntry;

        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            if (OldLanaNumber == pEntry->RegLanaEntry.LanaNumber)
            {
                // free up the lana number this entry had.
                m_LanasInUse[pEntry->RegLanaEntry.LanaNumber] = 0;

                // Give the entry the new lana number.
                pEntry->RegLanaEntry.LanaNumber = NewLanaNumber;

                m_LanasInUse[NewLanaNumber] = 1;
                break;
            }
        }

        if (pEntry == end())
        {
            hr = HRESULT_FROM_WIN32 (ERROR_OBJECT_NOT_FOUND);
        }
    }
    else
    {
        // The lana is not free.  We will swap the lanas used by the
        // two paths.
        //

        CLanaEntry* pEntry;
        CLanaEntry* pEntryToSet = NULL;
        CLanaEntry* pEntryUsingLana = NULL;

        for (pEntry = begin(); pEntry != end(); pEntry++)
        {
            if (!pEntryToSet &&
                    (OldLanaNumber == pEntry->RegLanaEntry.LanaNumber))
            {
                pEntryToSet = pEntry;
            }
            else if (!pEntryUsingLana &&
                     (NewLanaNumber == pEntry->RegLanaEntry.LanaNumber))
            {
                pEntryUsingLana = pEntry;
            }

            if (pEntryToSet && pEntryUsingLana)
            {
                // Give the entry the new lana number.
                pEntryToSet->RegLanaEntry.LanaNumber = NewLanaNumber;

                // Give the old lana number to the entry that was using the
                // new lana number.
                pEntryUsingLana->RegLanaEntry.LanaNumber = OldLanaNumber;
                break;
            }
        }

        if (!pEntryToSet || !pEntryUsingLana)
        {
            hr = HRESULT_FROM_WIN32 (ERROR_OBJECT_NOT_FOUND);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CLanaMap::HrSetLanaNumber");

    return hr;
}

BYTE
CLanaMap::GetMaxLana()
{
   for (BYTE b = MAX_LANA; b; b--)
   {
       if (m_LanasInUse[b]) return b;
   }

   return 0;
}


HRESULT
CLanaMap::HrWriteLanaConfiguration (
    IN const CComponentList& Components)
{
    HRESULT hr;

    // Create the registry map that will be stored.
    hr = HrCreateRegistryMap();
    if (S_OK == hr)
    {
        // Write out the map and other lana info.
        hr = HrWriteLanaMapConfig();
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteLanaConfiguration");
    return hr;
}

VOID
DumpLanaBindPaths (
    IN LANA_BIND_PATH* pBindSet,
    IN DWORD cPaths)
{
    LANA_BIND_PATH* pPath = pBindSet;
    DWORD dw = 0;
    VECTOR_OF_GUIDS::iterator iter;

    for (dw = 0; dw < cPaths; dw++)
    {
        TraceTag (ttidNetcfgBase, "Path %d", dw);
        for (iter = pPath->GuidsOfComponentsOnPath.begin();
                iter != pPath->GuidsOfComponentsOnPath.end();
                iter++)
        {
            const GUID* guid = *iter;
            TraceTag (ttidNetcfgBase, "    %lX", guid->Data1);
        }
        pPath++;
    }
}


VOID
UpdateLanaConfigWithAnswerFileInfo (
    IN CLanaMap* pLanaMap,
    IN DWORD cAfPaths,
    IN LANA_BIND_PATH* pOriginalBindSet,
    IN LANA_BIND_PATH* pAnswerFileBindSet)
{
    DWORD dwAnswerFile;
    DWORD dwPaths;
    DWORD dwComponents;
    DWORD dwNumberOfComponents;
    BOOL fEqual;
    LANA_BIND_PATH* pAfEntry;
    LANA_BIND_PATH* pOEntry;

    Assert (pLanaMap);
    Assert (pOriginalBindSet);
    Assert (pAnswerFileBindSet);

    TraceTag (ttidNetcfgBase, "Dumping original bind set");
    DumpLanaBindPaths (pOriginalBindSet, pLanaMap->CountEntries());
    TraceTag (ttidNetcfgBase, "Dumping af bind set");
    DumpLanaBindPaths (pAnswerFileBindSet, cAfPaths);

    pAfEntry = pAnswerFileBindSet;
    for (dwAnswerFile = 0; dwAnswerFile < cAfPaths; dwAnswerFile++)
    {
        // Do we have a valid path?
        if (!pAfEntry->GuidsOfComponentsOnPath.empty())
        {
            pOEntry = pOriginalBindSet;
            for (dwPaths = 0; dwPaths < pLanaMap->CountEntries(); dwPaths++)
            {
                if (pAfEntry->GuidsOfComponentsOnPath.size() ==
                        pOEntry->GuidsOfComponentsOnPath.size())
                {
                    dwNumberOfComponents =
                            pAfEntry->GuidsOfComponentsOnPath.size();

                    fEqual = TRUE;
                    for (dwComponents = 0;
                            dwComponents < dwNumberOfComponents;
                            dwComponents++)
                    {
                        if (pAfEntry->GuidsOfComponentsOnPath[dwComponents] !=
                                pOEntry->GuidsOfComponentsOnPath[dwComponents])
                        {
                            fEqual = FALSE;
                        }
                    }

                    if (fEqual)
                    {
                        HRESULT hr;
                        hr = pLanaMap->HrSetLanaNumber (
                                pOEntry->LanaNumber,
                                pAfEntry->LanaNumber);


                        TraceTag (ttidNetcfgBase, "af path %d matches %d",
                                dwAnswerFile, dwPaths);
                        TraceTag (ttidNetcfgBase, "Changing lana number "
                                  "from %X to %X", pOEntry->LanaNumber,
                                  pAfEntry->LanaNumber);

                        TraceHr (ttidError, FAL, hr, FALSE, "Setting lana");
                    }
                }
                pOEntry++;
            }
        }
        pAfEntry++;
    }
}

VOID
ConvertAnswerFileComponentsToGuids (
    IN const CComponentList& Components,
    IN PCWSTR mszComponents,
    OUT VECTOR_OF_GUIDS* pvector)
{
    CComponent* pComponent;
    PCWSTR pszScan;
    const GUID* pguid;
    GUID guidTemp;

    Assert (mszComponents);
    Assert (pvector);

    for (pszScan = mszComponents; *pszScan; pszScan += wcslen (pszScan) + 1)
    {

        TraceTag (ttidNetcfgBase, "  Looking for af component %S", pszScan);

        // Look for the component in our installed components list.
        //
        pComponent = Components.PFindComponentByInfId (pszScan, NULL);

        if (pComponent)
        {
            pguid = &pComponent->m_InstanceGuid;
        }
        else
        {
            TraceTag (ttidNetcfgBase, "    Id did not match installed ids. "
                    "Checking af map");

            // The component wasn't listed in our installed list.  The inf
            // id might be something that the answerfile processor has mapped
            // to the component's instance guid.  This happens for adapters.
            // e.g. Id is listed as Adapter01 so netsetup uses an alogrithm
            // to determine which adapter it is and then save off its
            // instance guid in a map.
            //
            if (FGetInstanceGuidOfComponentFromAnswerFileMap (
                    pszScan, &guidTemp))
            {
                pComponent = Components.PFindComponentByInstanceGuid (
                    &guidTemp);
            }
            else
            {
                TraceTag (ttidError, "    Component %S not found in answerfile "
                          "map", pszScan);
            }

            // If we found the component, store a reference to its
            // instance guid
            //
            if (pComponent)
            {
                TraceTag (ttidNetcfgBase, "    Found component");
                pguid = &pComponent->m_InstanceGuid;
            }
            else
            {
                // We didn't find the component. Store GUID_NULL.
                pguid = &GUID_NULL;
            }
        }
        TraceTag (ttidNetcfgBase, "    Using GUID %lX", pguid->Data1);

        pvector->push_back (pguid);
    }
}

HRESULT
HrConvertAnswerFileParamsToLanaBindSet (
    IN INFCONTEXT& ctxLana,
    IN const CComponentList& Components,
    IN DWORD cPaths,
    OUT LANA_BIND_PATH* pBindSet)
{
    DWORD cchField = _MAX_PATH;
    DWORD cchRequired;
    INT LanaCode;
    PWSTR mszComponents;
    HRESULT hr;
    DWORD dw;
    INFCONTEXT ctx = ctxLana;
    LANA_BIND_PATH* pPath;

    hr = S_OK;
    mszComponents = (PWSTR)MemAlloc (cchField * sizeof (WCHAR));

    pPath = pBindSet;
    for (dw = 0; dw < cPaths; dw++)
    {
        if (mszComponents && (S_OK == hr))
        {
            hr = HrSetupGetMultiSzField (ctx, 1, mszComponents, cchField,
                    &cchRequired);

            if (S_OK == hr)
            {
                TraceTag (ttidNetcfgBase, "Path %ld", dw);
                ConvertAnswerFileComponentsToGuids (Components,
                        mszComponents,
                        &(pPath->GuidsOfComponentsOnPath));

                hr = HrSetupFindNextLine (ctx, &ctx);

                if (S_OK == hr)
                {
                    hr = HrSetupGetIntField (ctx, 1, &LanaCode);

                    if (S_OK == hr)
                    {
                        pPath->LanaNumber = LanaCode & 0xff;

                        TraceTag (ttidNetcfgBase, "  Using LanaNumber %X for "
                            "path", pPath->LanaNumber);
                    }
                    else
                    {
                        TraceTag (ttidNetcfgBase, "  Bad lana code");
                        // Bad lana number, clear the guids so we won't match
                        // this path and use this info.
                        //
                        pPath->GuidsOfComponentsOnPath.erase(
                            pPath->GuidsOfComponentsOnPath.begin(),
                            pPath->GuidsOfComponentsOnPath.end());
                    }
                }

                hr = HrSetupFindNextMatchLine (ctx, L"LanaPath", &ctx);

                if (S_FALSE == hr)
                {
                    break;
                }

                pPath++;
            }
            else if (HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) == hr)
            {
                // Reallocate the buffer.
                //
                hr = S_OK;
                MemFree (mszComponents);
                mszComponents = (PWSTR)MemAlloc (cchRequired * sizeof(WCHAR));
                cchField = cchRequired;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }

    if (S_FALSE == hr)
    {
        // Check to see if we were really finished.
        if ((dw + 1) < cPaths)
        {
            TraceTag (ttidError, "Answerfile specified %d lana paths "
                    "but only %d were found", cPaths, (dw + 1));
        }

        // This fcn only returns S_OK on success.
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
            "HrConvertAnswerFileParamsToLanaBindSet");
    return hr;
}

HRESULT
HrProcessAnswerFile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection,
    IN const CComponentList& Components,
    OUT LANA_BIND_PATH** ppBindSet,
    OUT DWORD* pcPaths)
{
    HINF hinf;
    PCWSTR pszBindPath;
    WCHAR szBindName[_MAX_PATH];
    HRESULT hr;

    Assert (pszAnswerFile);
    Assert (pszSection);
    Assert (ppBindSet);
    Assert (pcPaths);

    *pcPaths = 0;
    *ppBindSet = NULL;

    hr = HrSetupOpenInfFile (pszAnswerFile, NULL,
            INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL, &hinf);

    if (S_OK == hr)
    {
        hr = HrSetupGetFirstDword (hinf, pszSection,
                L"NumberOfPaths", pcPaths);

        if (S_OK == hr)
        {
            TraceTag (ttidNetcfgBase, "\n\n");
            TraceTag (ttidNetcfgBase, "%d paths found in answerfile",
                    *pcPaths);

            hr = E_OUTOFMEMORY;
            *ppBindSet = new LANA_BIND_PATH[*pcPaths];
            if (*ppBindSet)
            {
                hr = S_OK;
            }
        }

        if (S_OK == hr)
        {
            INFCONTEXT ctx;
            hr = HrSetupFindFirstLine (hinf, pszSection, L"LanaPath", &ctx);

            if (S_OK == hr)
            {
                hr = HrConvertAnswerFileParamsToLanaBindSet (ctx, Components,
                        *pcPaths, *ppBindSet);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrProcessAnswerFile");
    return hr;
}


HRESULT
HrConvertBindingsToLanaBindSet (
    IN const CComponentList& Components,
    IN const CLanaMap& LanaMap,
    OUT LANA_BIND_PATH** ppBindSet)
{

    PCWSTR pszBindPath;
    WCHAR szBindName[_MAX_PATH];
    HRESULT hr;
    DWORD cPaths;

    Assert (ppBindSet);

    cPaths = LanaMap.CountEntries();

    TraceTag (ttidNetcfgBase, "%d paths in system", cPaths);

    hr = E_OUTOFMEMORY;
    *ppBindSet = new LANA_BIND_PATH[cPaths];

    if (*ppBindSet)
    {
        LANA_BIND_PATH* pBindPath = *ppBindSet;
        CComponent* pComponent;
        PCWSTR pszCompStart;
        PCWSTR pszCompEnd;
        DWORD cchComp;

        hr = S_OK;

        const CLanaEntry* pEntry;
        for (pEntry = LanaMap.begin(); pEntry != LanaMap.end(); pEntry++)
        {
            pszBindPath = pEntry->pszBindPath;

            TraceTag (ttidNetcfgBase, "BindPath %S", pszBindPath);

            pBindPath->LanaNumber = pEntry->RegLanaEntry.LanaNumber;
            TraceTag (ttidNetcfgBase, "Lana %X", pBindPath->LanaNumber);

            GetFirstComponentFromBindPath (pszBindPath, &pszCompStart,
                    &cchComp);

            while (*pszCompStart)
            {
                wcsncpy (szBindName, pszCompStart, cchComp);
                szBindName[cchComp] = L'\0';

                TraceTag (ttidNetcfgBase, "  Searching for component with bind name %S",
                        szBindName);

                pComponent = Components.PFindComponentByBindName (NC_INVALID,
                        szBindName);

                if (pComponent)
                {
                    TraceTag (ttidNetcfgBase, "  Found component. Guid = %lX",
                            pComponent->m_InstanceGuid.Data1);
                    pBindPath->GuidsOfComponentsOnPath.push_back (&pComponent->m_InstanceGuid);
                }
                else
                {
                    if (*pszCompEnd)
                    {
                        AssertSz (FALSE, "  Bind Name not found in component list");
                        pBindPath->GuidsOfComponentsOnPath.push_back (&GUID_NULL);
                    }
                }

                pszCompStart = pszCompStart + cchComp;

                if (*pszCompStart)
                {
                    pszCompStart++;

                    pszCompEnd = wcschr (pszCompStart, L'_');
                    if (!pszCompEnd)
                    {
                        // There is no underscore so set the end pointer
                        // to the end of the string.
                        pszCompEnd = pszBindPath + wcslen (pszBindPath);
                    }
                }

                cchComp = (DWORD)(pszCompEnd - pszCompStart);
            }
            pBindPath++;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrConvertBindingsToLanaBindSet");
    return hr;
}

HRESULT
HrUpdateLanaConfig (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPaths,
    IN UINT cPaths)
{
    CLanaMap CurrentLanaMap;
    CLanaMap NewLanaMap;
    HRESULT hr;

    hr = CurrentLanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        hr = NewLanaMap.HrReserveRoomForEntries (cPaths);

        if (S_OK == hr)
        {
            PCWSTR pszScan;
            CLanaEntry LanaEntry;

            for (pszScan = pszBindPaths;
                 *pszScan;
                 pszScan += wcslen (pszScan) + 1)
            {
                LanaEntry.pszBindPath = pszScan;
                CurrentLanaMap.GetLanaEntry (Components, &LanaEntry);

                hr = NewLanaMap.HrAppendEntry (&LanaEntry);

                if (S_OK != hr)
                {
                    break;
                }
            }

            if (S_OK == hr)
            {
                hr = NewLanaMap.HrWriteLanaConfiguration (Components);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrUpdateLanaConfig");
    return hr;

}

EXTERN_C
VOID
WINAPI
UpdateLanaConfigUsingAnswerfile (
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszSection)
{
    HRESULT hr;
    CLanaMap LanaMap;

    // Load the current lanamap information.
    hr = LanaMap.HrLoadLanaMap();

    if (S_OK == hr)
    {
        TraceTag (ttidNetcfgBase, "Answerfile params %S:%S",
                pszAnswerFile, pszSection);

        // Load up the current network configuration.
        //

        CNetConfig NetConfig;
        hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, &NetConfig);

        if (S_OK == hr)
        {
            hr = NetConfig.HrEnsureExternalDataLoadedForAllComponents();

            if (S_OK == hr)
            {
                // Convert our current lana bind paths to a lana bind set.
                //
                LANA_BIND_PATH* pBindSet;
                hr = HrConvertBindingsToLanaBindSet (
                        NetConfig.Core.Components, LanaMap, &pBindSet);

                if (S_OK == hr)
                {
                    // Convert the answerfile lana bind paths
                    // to a lana bind set.
                    //
                    LANA_BIND_PATH* pAnswerFileBindSet;
                    DWORD cAnswerFilePaths;

                    hr = HrProcessAnswerFile (
                            pszAnswerFile, pszSection,
                            NetConfig.Core.Components, &pAnswerFileBindSet,
                            &cAnswerFilePaths);

                    if (S_OK == hr)
                    {
                        // Now update the config using the answerfile info.
                        //
                        UpdateLanaConfigWithAnswerFileInfo (
                                &LanaMap, cAnswerFilePaths,
                                pBindSet, pAnswerFileBindSet);

                        // Write out the information.
                        hr = LanaMap.HrWriteLanaConfiguration (
                                NetConfig.Core.Components);

                        delete [] pAnswerFileBindSet;
                    }
                    delete [] pBindSet;
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "UpdateLanaConfigUsingAnswerfile");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ncprsht.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P R S H T . H
//
//  Contents:   NetCfg custom PropertySheet header
//
//  Notes:
//
//  Author:     billbe   8 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgn.h"

struct CAPAGES
{
    int nCount;
    HPROPSHEETPAGE* ahpsp;
};

struct CAINCP
{
    int nCount;
    INetCfgComponentPropertyUi** apncp;
};

HRESULT
HrNetCfgPropertySheet(IN OUT LPPROPSHEETHEADER lppsh,
        IN const CAPAGES& capOem,
        IN PCWSTR pStartPage,
        IN const CAINCP& caiProperties);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\lanamap.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L A N A M A P . H
//
//  Contents:   NetBios Lana map routines.
//
//  Notes:
//
//  Author:     billbe   17 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

#include "nb30.h"
#include "ncstring.h"
#include "netcfg.h"
#include "util.h"

//
// Structure of LANA MAP
//
// The Lana map is a simple structure that looks like this in memory:
//
//    Entry #0    Entry #1   .....   Entry #n
// |-----------|-----------| ..... |-----------|
// | 0x01 0x00 | 0x00 0x01 | ..... | 0x01 0x03 |
// |-----------|-----------| ..... |-----------|
//   EP0   LN0   EP1   LN1           EPn  LNn
//
// EP is "ExportPref" - means that when someone asks for the list of
// all Lana numbers, entries with a 0 here will not be returned.
//
// LN is the "Lana number" - see the IBM NetBIOS spec for details.
// Basically, this describes a single, unique network route which
// uses NetBIOS.
//
// Using the above example, Entry #0 has a lana number of 0 and WILL
// be returned during enumeration. Entry #1 has a lana number of 1
// and WILL NOT be returned.
//

struct REG_LANA_ENTRY
{
    BYTE Exported;
    BYTE LanaNumber;
};

class CLanaEntry
{
public:
    PCWSTR pszBindPath;
    REG_LANA_ENTRY RegLanaEntry;
};


class CLanaMap : public vector<CLanaEntry>
{
public:

    CLanaMap()
    {
        ZeroMemory (this, sizeof (*this));
        m_RegistryLanaMap.SetGranularity (256);
    }

    ~CLanaMap()
    {
        MemFree ((VOID*)m_pszBindPathsBuffer);
    };

    VOID
    Clear()
    {
        clear();
    }

    UINT
    CountEntries() const
    {
        return size();
    }

    VOID
    Dump (
        CWideString* pstr) const;

    HRESULT
    HrReserveRoomForEntries (
        IN UINT cEntries);

    HRESULT
    HrAppendEntry (
        IN CLanaEntry* pEntry);

    BYTE
    GetExportValue (
        IN const CComponentList& Components,
        IN PCWSTR pszBindPath);

    HRESULT
    HrSetLanaNumber (
        IN BYTE OldLanaNumber,
        IN BYTE NewLanaNumber);

    HRESULT
    HrCreateRegistryMap();

    VOID
    GetLanaEntry (
        IN const CComponentList& Components,
        IN CLanaEntry* pEntry);

    HRESULT
    HrLoadLanaMap();

    BYTE
    GetMaxLana();

    HRESULT
    HrWriteLanaConfiguration (
        IN const CComponentList& Components);

private:
    PCWSTR m_pszBindPathsBuffer;
    BYTE m_LanasInUse[MAX_LANA + 1];
    CDynamicBuffer m_RegistryLanaMap;

    HRESULT
    HrWriteLanaMapConfig();
};

HRESULT
HrUpdateLanaConfig (
    IN const CComponentList& Components,
    IN PCWSTR pszBindPaths,
    IN UINT cPaths);

VOID
GetFirstComponentFromBindPath (
    IN PCWSTR pszBindPath,
    OUT PCWSTR* ppszComponentStart,
    OUT DWORD* pcchComponent);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ncwins.h ===
//
// File:    ncwins.h
//
// Purpose: Declare and define public constants and entry-points
//          for use in configuring Winsock dependancies.
//
// Author:  27-Mar-97 created scottbri
//
#pragma once

//
// Function:    HrAddOrRemoveWinsockDependancy
//
// Purpose:     To add or remove Winsock dependancies for components
//
// Parameters:  nccObject      [IN] - Current configuration object
//              pszSectionName [IN] - The Base install section name.
//                                    (The prefix for the .Services section)
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddOrRemoveWinsockDependancy(
    HINF hinfInstallFile,
    PCWSTR pszSectionName);


HRESULT
HrRunWinsock2Migration(
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ncprsht.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C P R S H T . C P P
//
//  Contents:   NetCfg custom PropertySheet
//
//  Notes:
//
//  Author:     billbe   8 Apr 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncprsht.h"
#include <prsht.h>
#include "nceh.h"

// Necessary evil globals
CAPAGES g_capPagesToAdd;  // Counted array of pages to add after Property
                          // Sheet is initialized
CAINCP  g_cai;  // Counted array of INetCfgProperty pointers
HRESULT g_hr; // Global error code
BOOL    g_fChanged; // Global flag representing whether a PSM_CHANGED
                    // message was sent by a page

DLGPROC lpfnOldWndProc; // Previous dialog procedure

// NetCfg Property Sheet dialog procedure
INT_PTR CALLBACK NetCfgPsDlgProc(HWND hDlg, UINT msg, WPARAM wParam,
        LPARAM lParam);


//+---------------------------------------------------------------------------
//
//  Function:   SetLastHresult
//
//  Purpose:    This sets a global hresult variable.  The function
//              is analogous to SetLastError
//
//  Arguments:
//      HRESULT [in] Result to set
//
//  Returns:    nothing
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
//
inline void
SetLastHresult(HRESULT hr)
{
    g_hr = hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrGetLastHresult
//
//  Purpose:    This returns the value of the global hresult variable.
//              The function is analogous to GetLastError
//
//  Arguments:
//      none
//
//  Returns:    HRESULT. Value of the global g_hr.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
//
inline HRESULT
HrGetLastHresult()
{
    return (g_hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   ResetChanged
//
//  Purpose:    This resets the global changed flag. The reset state
//                  indicates that a PSM_VHANGED message was not sent
//
//  Arguments:
//      none
//
//  Returns:
//      (nothing)
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline void
ResetChanged()
{
    g_fChanged = FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetChanged
//
//  Purpose:    This sets the global changed flag.  The set state indicates
//                  that a PSM_CHANGED message was sent
//
//  Arguments:
//      none
//
//  Returns:
//      (nothing)
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline void
SetChanged()
{
    g_fChanged = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetChanged
//
//  Purpose:    This returns the state of the global changed flag.  The set
//                  state indicates whether a PSM_CHANGED message was sent
//                  or not.
//
//  Arguments:
//      none
//
//  Returns:
//      BOOL. Value of the global g_fChanged flag.
//
//  Author:     billbe   3 May 1997
//
//  Notes:
//
//
inline BOOL
FGetChanged()
{
    return (g_fChanged);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetCfgPropSheetCallback
//
//  Purpose:    This callback is called after the aheet dialog is
//              initialized. We subclass the dialog and add any OEM
//              pages here (if common pages exist).  See Win32 for
//              discussion of PropSheetProc
//
//  Arguments:
//      HWND [in] hwndDlg handle to the property sheet dialog box
//      UINT uMsg [in] message identifier
//      LPARAM lParam  [in] message parameter
//
//  Returns:    int, The function returns zero.
//
//  Author:     billbe   11 Nov 1996
//
//  Notes:
//
//
int
CALLBACK NetCfgPropSheetCallback(HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    // If the sheet has just been initialized
    if (uMsg == PSCB_INITIALIZED)
    {
        // Replace the original procedure with ours
        lpfnOldWndProc = (DLGPROC)SetWindowLongPtr(hwndDlg, DWLP_DLGPROC, (LONG_PTR) NetCfgPsDlgProc);
        Assert(lpfnOldWndProc);

        // Add the OEM pages that were scheduled for late add
        // This will cause them to be clipped if they are larger than
        // the common (default) pages.  Note that this is the desired
        // result.
        //
        for (int i = 0; i < g_capPagesToAdd.nCount; i++)
        {
            PropSheet_AddPage(hwndDlg, g_capPagesToAdd.ahpsp[i]);
        }

    }

    return (0);
}




//+---------------------------------------------------------------------------
//
//  Function:   HrCallValidateProperties
//
//  Purpose:    This function calls the notify objects'
//              INetCfgProperties::ValidateProperties method.
//
//  Arguments:
//      none
//
//  Returns:    HRESULT, S_OK if all of the INetCfgProperties return S_OK
//                       of the result of the first interface that does not
//                       return S_OK.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:  If one of the interfaces returns something other than S_OK, the
//          others will not be called and the function will return the hresult
//          of that interface.
//
HRESULT
HrCallValidateProperties(HWND hwndSheet)
{
    HRESULT hr = S_OK;

    // enumerate through the counted array of interfaces
    // and call ValidateProperties
    //
    for (int i = 0; i < g_cai.nCount; i++)
    {
        // At the first sign of non-S_OK get out
        if (S_OK != (hr = g_cai.apncp[i]->ValidateProperties(hwndSheet)))
            break;
    }

    TraceError("HrCallValidateProperties", hr);
    return (hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   NetCfgPsDlgProc
//
//  Purpose:    This function is the dialog procedure for the property sheet
//              See Win32 documentation on DialogProc for more information
//
//  Arguments:
//      hwndDlg [in] handle to dialog box
//      uMsg    [in] message
//      wParam  [in] first message parameter
//      lParam  [in] second message parameter
//
//  Returns:    LONG, Except in response to the WM_INITDIALOG message, the
//              dialog box procedure should return nonzero if it processes
//              the message, and zero if it does not.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//
INT_PTR CALLBACK NetCfgPsDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch (msg)
    {
    case WM_DESTROY:
        // restore the dialog procedure before we exit
        SetWindowLongPtr(hDlg, DWLP_DLGPROC, (LONG_PTR) lpfnOldWndProc);
        break;
    case WM_SYSCOMMAND:
        // The user is closing through the system menu. This is like
        // canceling
        if (SC_CLOSE == wParam)
        {
            SetLastHresult(HRESULT_FROM_WIN32(ERROR_CANCELLED));
        }
        break;
    case PSM_CHANGED:
        SetChanged();
        break;
    case WM_COMMAND:
        // If the user pressed OK
        if ((IDOK == LOWORD(wParam)) && (BN_CLICKED == HIWORD(wParam)))
        {

            // Send a KillActive message to the currect page. This echoes
            // what the Win32 propertysheet would do.  This results in a
            // second KillActive message being sent to the active page
            // when the OK message is processed. It is necessary
            // to send it here because we need its result before we
            // call HrCallValidateProperties which is done before the OK
            // is processed.
            //

            NMHDR nmhdr;
            ZeroMemory(&nmhdr, sizeof(NMHDR));
            nmhdr.hwndFrom = hDlg;
            nmhdr.code = PSN_KILLACTIVE;

            if (SendMessage(PropSheet_GetCurrentPageHwnd(hDlg), WM_NOTIFY,
                    0, (LPARAM) &nmhdr))
            {
                // The page does not want the PropertySheet to go away so exit
                // without allowing the original procedure to get the message
                return (TRUE);
            }

            // The current page validated okay so now we must call all the
            // ValidateProperties necessary.
            if (S_OK != HrCallValidateProperties(hDlg))
            {
                // One of the interfaces returned something other than S_OK
                // from Validateproperties so we exit without letting
                // the original dialog procedure process the message.
                // This will keep the PropertySheet active.
                return (TRUE);
            }
        }
        else if (IDCANCEL == LOWORD(wParam) && BN_CLICKED == HIWORD(wParam))
        {
            // If Cancel was pressed set the last hresult
            SetLastHresult(HRESULT_FROM_WIN32(ERROR_CANCELLED));
        }
        break;

    }

    // call the original dialog procedure
    return (CallWindowProc((WNDPROC)lpfnOldWndProc, hDlg, msg, wParam, lParam));

}


//+---------------------------------------------------------------------------
//
//  Function:   VerifyCAPAGES
//
//  Synopsis:   function to check the validity of a given CAPAGES structure
//
//  Arguments:  [cap] --
//
//  Returns:    BOOL
//
//  Notes:      14-Jan-1998     SumitC      Created
//
//----------------------------------------------------------------------------

BOOL
FVerifyCAPAGES(const struct CAPAGES& cap)
{
    BOOL fGood = FALSE;

    if (cap.nCount == 0)
    {
        fGood = (cap.ahpsp == NULL);
    }
    else
    {
        fGood = !IsBadReadPtr(cap.ahpsp, sizeof(HPROPSHEETPAGE) * cap.nCount);
    }

    return fGood;
}


//+---------------------------------------------------------------------------
//
//  Function:   HrNetCfgPropertySheet
//
//  Purpose:    This function is sets up our custom property sheet which is
//              a subclassed Win32 property sheet.
//              See Win32 documentation on PropertySheet for more information
//
//  Arguments:
//      lppsh           [in] a PROPSHEETHEADER
//      capOem          [in] A counted array of Oem pages
//      pStartPage      [in] Name of the initial page that appears when the property
//                              sheet dialog box is created. This member can specify
//                              either the identifier of a string resource or the
//                              pointer to a string that specifies the name.
//      caiProperties   [in] A counted array of INetCfgProperties interfaces
//
//  Returns:    HRESULT, S_OK if OK was pressed and changes were made,
//                          S_FALSE if OK was pressed and no changes were
//                          made. An error code otherwise.
//
//  Author:     billbe   8 Apr 1997
//
//  Notes:
//          HRESULT_FROM_WIN32(ERROR_CANCELLED) is returned if the
//              cancel button was pressed
//
HRESULT
HrNetCfgPropertySheet(
        IN OUT LPPROPSHEETHEADER lppsh,
        IN const CAPAGES& capOem,
        IN PCWSTR pStartPage,
        const CAINCP& caiProperties)
{
    HRESULT hr = S_OK;

    Assert(lppsh);

    // The following should not be set since we are setting them
    Assert(0 == lppsh->nPages);
    Assert(NULL == lppsh->phpage);
    Assert(!(PSH_USECALLBACK & lppsh->dwFlags));
    Assert(!(PSH_PROPSHEETPAGE & lppsh->dwFlags));

    // If a start page was specified than there had better be Oem Pages
    Assert(FImplies(pStartPage, capOem.nCount));

    // We have to have at least one INetCfgProperties since we are here
    Assert(caiProperties.nCount);
    Assert(caiProperties.apncp);

    // Set our global CAINCP structure
    g_cai.nCount = caiProperties.nCount;
    g_cai.apncp = caiProperties.apncp;

    // Reset our global CAPAGES
    g_capPagesToAdd.nCount = 0;
    g_capPagesToAdd.ahpsp = NULL;

    // We need to set up a callback to subclass the dialog
    lppsh->dwFlags |= PSH_USECALLBACK;
    lppsh->pfnCallback = NetCfgPropSheetCallback;

    // There are no common pages to show so we will use the OEM pages
    // instead
    Assert(capOem.nCount);
    if (FVerifyCAPAGES(capOem))
    {
        lppsh->nPages = capOem.nCount;
        lppsh->phpage = capOem.ahpsp;
    }
    else
    {
        //$ REVIEW sumitc: or just return E_INVALIDARG?
        lppsh->nPages = 0;
        lppsh->phpage = NULL;
    }
    Assert(FImplies(lppsh->nPages, lppsh->phpage));

    // If a start page was specified, set the propsheet flag and
    // start page member.
    // Note: (billbe) This will not work if common pages exist since
    // that means Oem pages are added after the sheet is initialized
    if (pStartPage)
    {
        lppsh->dwFlags |= PSH_USEPSTARTPAGE;
        lppsh->pStartPage = pStartPage;
    }


    // Clear last hresult and changed flag
    SetLastHresult(S_OK);
    ResetChanged();

    // Call the Win32 property sheet
    NC_TRY
    {
        INT_PTR iRetVal = PropertySheet(lppsh);
        if (-1 == iRetVal)
        {
            // The Win32 Sheet failed so we return E_FAIL
            SetLastHresult(E_FAIL);
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    if (S_OK == hr)
    {
        // if the catch hasn't set hr to some error
        hr = HrGetLastHresult();
    }

    // if everthing went well, return the correct value based on whether
    // any of the pages changed
    //
    if (SUCCEEDED(hr))
    {
        // S_OK - changes were made, S_FALSE - no changes were made
        hr = FGetChanged() ? S_OK : S_FALSE;
    }

    TraceError("HrNetCfgPropertySheet",
        ((HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr) || (S_FALSE == hr)) ? S_OK : hr);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\lockdown.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L O C K D O W N . C P P
//
//  Contents:   Routines to get and set components that are in a lockdown
//              state.  A component goes into lockdown when it requires a
//              reboot on removal.  When a component is locked down, it
//              cannot be installed until after the next reboot.
//
//  Notes:      Because a component comes out of lockdown after a reboot,
//              a natural choice for implementation is to use a volatile
//              registry key to keep track of the state.  Each component
//              that is locked down is represented by a volatile registry
//              key the name of which is the same as the INF ID of the
//              component.  These keys exist under
//              SYSTEM\CurrentControlSet\Control\Network\Lockdown.
//
//  Author:     shaunco   24 May 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "diagctx.h"
#include "lockdown.h"
#include "ncreg.h"

#define REGSTR_KEY_LOCKDOWN \
    L"SYSTEM\\CurrentControlSet\\Control\\Network\\Lockdown"


//+---------------------------------------------------------------------------
//
//  Function:   EnumLockedDownComponents
//
//  Purpose:    Enumerate the currently locked down components via a
//              caller-supplied callback.
//
//  Arguments:
//      pfnCallback [in] pointer to callback function
//      OPTIONAL    [in] optional caller-supplied data to pass back
//
//  Returns:    nothing
//
//  Author:     shaunco   24 May 1999
//
VOID
EnumLockedDownComponents (
    IN PFN_ELDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL)
{
    HRESULT hr;
    HKEY hkey;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            REGSTR_KEY_LOCKDOWN,
            KEY_READ,
            &hkey);

    if (S_OK == hr)
    {
        WCHAR szInfId [_MAX_PATH];
        FILETIME ft;
        DWORD dwSize;
        DWORD dwRegIndex;

        for (dwRegIndex = 0, dwSize = celems(szInfId);
             S_OK == HrRegEnumKeyEx(hkey, dwRegIndex, szInfId,
                        &dwSize, NULL, NULL, &ft);
             dwRegIndex++, dwSize = celems(szInfId))
        {
            pfnCallback (szInfId, pvCallerData);
        }

        RegCloseKey (hkey);;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FGetOrSetComponentLockDown
//
//  Purpose:    Gets or sets the state of whether a component is locked down.
//
//  Arguments:
//      fSet     [in] TRUE to set into the lockdown state, FALSE to get.
//      pszInfId [in] the INF ID of the component in question.
//
//  Returns:    TRUE if non-zero fSet and component is locked down.
//              FALSE otherwise.
//
//  Author:     shaunco   24 May 1999
//
BOOL
FGetOrSetComponentLockDown (
    IN BOOL fSet,
    IN PCWSTR pszInfId)
{
    Assert (pszInfId);

    //ensure that the infid passed in is within required limits. 
    Assert (wcslen (pszInfId) < MAX_DEVICE_ID_LEN);

    HRESULT hr;
    HKEY hkey;
    BOOL fRet;
    WCHAR szKey [_MAX_PATH];

    fRet = FALSE;
    hkey = NULL;

    wcscpy (szKey, REGSTR_KEY_LOCKDOWN);
    wcscat (szKey, L"\\");
    wcscat (szKey, pszInfId);

    if (fSet)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      %S is being locked "
            "down to prevent re-install until the next reboot\n",
            pszInfId);

        hr = HrRegCreateKeyEx (
                HKEY_LOCAL_MACHINE,
                szKey,
                REG_OPTION_VOLATILE,
                KEY_WRITE,
                NULL,
                &hkey,
                NULL);
    }
    else
    {
        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                szKey,
                KEY_READ,
                &hkey);

        if (S_OK == hr)
        {
            fRet = TRUE;
        }
    }

    RegSafeCloseKey (hkey);

    return fRet;
}

BOOL
FIsComponentLockedDown (
    IN PCWSTR pszInfId)
{
    return FGetOrSetComponentLockDown (FALSE, pszInfId);
}


struct LOCKDOWN_DEPENDENCY_ENTRY
{
    PCWSTR          pszInfId;
    const PCWSTR*   ppszDependentInfIds;
};

extern const WCHAR c_szInfId_MS_NWIPX[];
extern const WCHAR c_szInfId_MS_FPNW[];
extern const WCHAR c_szInfId_MS_NWClient[];
extern const WCHAR c_szInfId_MS_NwSapAgent[];

static const PCWSTR c_apszNwlnkIpxDependentInfIds [] =
{
    c_szInfId_MS_FPNW,
    c_szInfId_MS_NWClient,
    c_szInfId_MS_NwSapAgent,
    NULL,
};

static const LOCKDOWN_DEPENDENCY_ENTRY c_LockdownDependencyMap [] =
{
    { c_szInfId_MS_NWIPX, c_apszNwlnkIpxDependentInfIds },
    { NULL, NULL }
};

VOID
LockdownComponentUntilNextReboot (
    IN PCWSTR pszInfId)
{
    (VOID) FGetOrSetComponentLockDown (TRUE, pszInfId);

    // Lock down dependents of the component as well.
    //
    const LOCKDOWN_DEPENDENCY_ENTRY* pEntry;
    UINT ipsz;

    // Search for the matching entry in c_LockdownDependencyMap.
    //
    for (pEntry = c_LockdownDependencyMap;
         pEntry->pszInfId;
         pEntry++)
    {
        if (0 != _wcsicmp (pEntry->pszInfId, pszInfId))
        {
            continue;
        }

        // Found a matching entry.  Now lock down all of its
        // dependent INF ids.  The array of const PCWSTR pointers is
        // terminated with a NULL pointer.
        //
        Assert (pEntry->ppszDependentInfIds);

        for (ipsz = 0;
             pEntry->ppszDependentInfIds [ipsz];
             ipsz++)
        {
            (VOID) FGetOrSetComponentLockDown (
                    TRUE, pEntry->ppszDependentInfIds [ipsz]);
        }
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\lockdown.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       L O C K D O W N . H
//
//  Contents:   Routines to get and set components that are in a lockdown
//              state.  A component goes into lockdown when it requires a
//              reboot on removal.  When a component is locked down, it
//              cannot be installed until after the next reboot.
//
//  Notes:
//
//  Author:     shaunco   24 May 1999
//
//----------------------------------------------------------------------------

#pragma once

typedef VOID
(CALLBACK* PFN_ELDC_CALLBACK) (
    IN PCWSTR pszInfId,
    IN PVOID pvCallerData OPTIONAL);

VOID
EnumLockedDownComponents (
    IN PFN_ELDC_CALLBACK pfnCallback,
    IN PVOID pvCallerData OPTIONAL);

BOOL
FIsComponentLockedDown (
    IN PCWSTR pszInfId);

VOID
LockdownComponentUntilNextReboot (
    IN PCWSTR pszInfId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\modify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       M O D I F Y . C P P
//
//  Contents:   Routines used to setup modifications to the network
//              configuration.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "classinst.h"
#include "filtdevs.h"
#include "guisetup.h"
#include "inetcfg.h"
#include "lockdown.h"
#include "ncmsz.h"
#include "ncreg.h"
#include "ncsvc.h"
#include "ndispnp.h"
#include "netcfg.h"
#include "persist.h"
#include "pnpbind.h"
#include "pszarray.h"
#include "util.h"
#include "wscfg.h"
#include "ncwins.h"
#include "ncperms.h"

CNetConfig*
CModifyContext::PNetConfig ()
{
    TraceFileFunc(ttidNetcfgBase);

    CNetConfig* pNetConfig;

    Assert ((LONG_PTR)this > FIELD_OFFSET(CNetConfig, ModifyCtx));

    // Get our containing CNetConfig pointer.
    //
    pNetConfig = CONTAINING_RECORD(this, CNetConfig, ModifyCtx);
    pNetConfig->Core.DbgVerifyData ();

    return pNetConfig;
}

HRESULT
CModifyContext::HrDirtyComponent (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    m_hr = m_DirtyComponents.HrInsertComponent (pComponent,
            INS_IGNORE_IF_DUP | INS_SORTED);

#if DBG
    m_fComponentExplicitlyDirtied = TRUE;
#endif

    TraceHr (ttidError, FAL, m_hr, FALSE,
        "CModifyContext::HrDirtyComponentAndComponentsAbove");
    return m_hr;
}

HRESULT
CModifyContext::HrDirtyComponentAndComponentsAbove (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    GCCONTEXT Ctx;

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    // And insert the component itself.
    //
    m_hr = HrDirtyComponent (pComponent);

    // Only dirty the ones above if this component doesn't have the
    // NCF_DONTEXPOSELOWER characteristic.
    //
    if ((S_OK == m_hr) && !(pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
    {
        // Initialize the members of our context structure for recursion.
        //
        ZeroMemory (&Ctx, sizeof(Ctx));
        Ctx.pStackTable = &(PNetConfig()->Core.StackTable);
        Ctx.pComponents = &m_DirtyComponents;

        // Insert all of the component above.
        //
        GetComponentsAboveComponent (pComponent, &Ctx);
        m_hr = Ctx.hr;
    }

    TraceHr (ttidError, FAL, m_hr, FALSE,
        "CModifyContext::HrDirtyComponentAndComponentsAbove");
    return m_hr;
}

HRESULT
CModifyContext::HrApplyIfOkOrCancel (
    IN BOOL fApply)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;

    Assert (m_fPrepared);
    pNetConfig = PNetConfig();

    // Only apply if the context result is S_OK.
    //
    if (fApply && (S_OK == m_hr))
    {
        // Setupapi calls that we make during ApplyChanges have the
        // potential to return control to our clients windows message loop.
        // When this happens, and our clients are poorly written, they
        // may try to re-enter us on the same thread.  This is disaster
        // waiting to happen, so we need to prevent it by raising our
        // reentrancy protection level before we start apply changes.
        //
        pNetConfig->Notify.PINetCfg()->RaiseRpl (RPL_DISALLOW);

        ApplyChanges ();

        pNetConfig->Notify.PINetCfg()->LowerRpl (RPL_DISALLOW);

        // Delete those components from m_CoreStartedWith that are not
        // in the current core and reset the modify context.
        //
        m_CoreStartedWith.Components.FreeComponentsNotInOtherComponentList (
                &pNetConfig->Core.Components);
        m_CoreStartedWith.Clear();

        hr = S_OK;

        // Return the correct HRESULT to the caller.  If we've successfully
        // applied, but need a reboot, return so.
        //
        if (m_fRebootRecommended || m_fRebootRequired)
        {
            hr = NETCFG_S_REBOOT;
        }
    }
    else
    {
        // Cancel and release all notify objects.  Do this for what is
        // in the core as well as what we started with.  (There will
        // be some overlap, but they will only be released once.)
        // We need to do both sets so we don't miss releasing components
        // that have been removed.  (Removed components won't be in
        // current core, but they will be in the core that we started
        // with.)  Likewise, if we just released the core we started with,
        // we'd miss releasing those components that were added.)
        //
        pNetConfig->Notify.ReleaseAllNotifyObjects (pNetConfig->Core.Components, TRUE);
        pNetConfig->Notify.ReleaseAllNotifyObjects (m_CoreStartedWith.Components, TRUE);

        // Delete those components from m_CoreStartedWith that are not
        // in the current core.  Then delete all the components in the
        // current core and reload from our persistent storage.
        // (This has the nice effect of invalidating all outstanding
        // INetCfgComponent interfaces.)
        //
        m_CoreStartedWith.Components.FreeComponentsNotInOtherComponentList (
                &pNetConfig->Core.Components);
        pNetConfig->Core.Free ();

        // Eject both cores (didn't you just know this metaphor was coming ;-)
        // and reload the core from our persisted binary.  This magically,
        // and completely rolls everything back.
        //
        m_CoreStartedWith.Clear();
        pNetConfig->Core.Clear();

        // Return reason for failure through hr.
        //
        hr = m_hr;

        // Reload the configuration and, if successful, it means m_hr
        // will be S_OK.  If unsuccessful, m_hr will be the error and will
        // prevent subsequent operations.
        //
        m_hr = HrLoadNetworkConfigurationFromRegistry (KEY_READ, pNetConfig);
    }

    // Very important to set m_fPrepared back to FALSE so that HrPrepare gets
    // called for the next modifcation and correctly copy the core etc.
    //
    m_fPrepared = FALSE;
    m_AddedBindPaths.Clear();
    m_DeletedBindPaths.Clear();
    m_DirtyComponents.Clear();
#if DBG
    m_fComponentExplicitlyDirtied = FALSE;
#endif

    Assert (!m_fPrepared);
    Assert (m_CoreStartedWith.FIsEmpty());
    Assert (m_AddedBindPaths.FIsEmpty());
    Assert (m_DeletedBindPaths.FIsEmpty());
    Assert (m_DirtyComponents.FIsEmpty());
    Assert (0 == m_ulRecursionDepth);
    Assert (!m_fComponentExplicitlyDirtied);

    Assert ((S_OK == hr) || (NETCFG_S_REBOOT == hr) || FAILED(hr));
    TraceHr (ttidError, FAL, hr, NETCFG_S_REBOOT == hr,
        "CModifyContext::HrApplyIfOkOrCancel");
    return hr;
}

HRESULT
CModifyContext::HrPrepare ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (!m_fPrepared);
    Assert (m_CoreStartedWith.FIsEmpty());
    Assert (m_AddedBindPaths.FIsEmpty());
    Assert (m_DeletedBindPaths.FIsEmpty());
    Assert (m_DirtyComponents.FIsEmpty());
    Assert (0 == m_ulRecursionDepth);
    Assert (!m_fComponentExplicitlyDirtied);

    CNetConfig* pThis;

    pThis = PNetConfig();

    // Prepare the bind context.  This will ensure all of the external
    // data for all components is loaded as well as all ensuring that
    // all notify objects have been initialized.
    //
    m_hr = m_RegBindCtx.HrPrepare (pThis);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Snapshot the current core so that we know what we started with.
    // We will use the differences when we apply (if we get that far).
    //
    m_hr = m_CoreStartedWith.HrCopyCore (&pThis->Core);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 components in the core.
    // (64 * 4 = 256 bytes on 32-bit platforms)
    //
    m_hr = pThis->Core.Components.HrReserveRoomForComponents (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 stack entries in the core.
    // (64 * (4 + 4) = 512 bytes on 32-bit platforms)
    //
    m_hr = pThis->Core.StackTable.HrReserveRoomForEntries (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room in our added list for 64 bindpaths of 8 components.
    // (64 * 16 = 1K bytes on 32-bit platforms)
    //
    m_hr = m_AddedBindPaths.HrReserveRoomForBindPaths (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room in our deleted list for 64 bindpaths of 8 components.
    // (64 * 16 = 1K bytes on 32-bit platforms)
    //
    m_hr = m_DeletedBindPaths.HrReserveRoomForBindPaths (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    // Reserve room for 64 components in the dirty component list.
    // (64 * 4) = 256 bytes on 32-bit platforms)
    //
    m_hr = m_DirtyComponents.HrReserveRoomForComponents (64);
    if (S_OK != m_hr)
    {
        goto finished;
    }

    m_fPrepared = TRUE;

finished:
    TraceHr (ttidError, FAL, m_hr, FALSE, "CModifyContext::HrPrepare");
    return m_hr;
}

HRESULT
CModifyContext::HrBeginBatchOperation ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (0 == m_ulRecursionDepth);

    TraceTag (ttidBeDiag, "Begin batch operation...");

    PushRecursionDepth();
    return m_hr;
}

HRESULT
CModifyContext::HrEndBatchOperation (
    IN EBO_FLAG Flag)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    Assert (m_fPrepared);
    Assert (1 == m_ulRecursionDepth);

    if (EBO_COMMIT_NOW == Flag)
    {
        TraceTag (ttidBeDiag, "End batch (commiting changes)...");

        hr = HrPopRecursionDepth ();
    }
    else
    {
        Assert (EBO_DEFER_COMMIT_UNTIL_APPLY == Flag);

        TraceTag (ttidBeDiag, "End batch (deferring commit until Apply)...");

        m_ulRecursionDepth = 0;
        hr = S_OK;
    }

    Assert (0 == m_ulRecursionDepth);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrEndBatchOperation");
    return hr;
}

VOID
CModifyContext::PushRecursionDepth ()
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);

    m_ulRecursionDepth++;
}

HRESULT
CModifyContext::HrPopRecursionDepth ()
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (m_fPrepared);
    Assert (m_ulRecursionDepth > 0);

    m_ulRecursionDepth--;

    if (0 != m_ulRecursionDepth)
    {
        return m_hr;
    }

    // We're at the top-level of the install or remove modifcation so
    // apply or cancel the changes depending on the state of the context
    // result.
    //
    HRESULT hr;

    hr = HrApplyIfOkOrCancel (S_OK == m_hr);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrPopRecursionDepth");
    return hr;
}

//----------------------------------------------------------------------------
// This is a convenience method to find and process Winsock Remove
// section for a component which is about to be removed.

HRESULT
CModifyContext::HrProcessWinsockRemove(IN const CComponent *pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    HINF hinf = NULL;
    HKEY hkeyInstance = NULL;
    HRESULT hr;

    Assert(pComponent);

    hr = pComponent->HrOpenInfFile(&hinf);
    if (S_OK == hr)
    {
        static const WCHAR c_szRemoveSectionSuffix[] = L".Remove";

        // We get the remove section name and process all relevant sections
        WCHAR szRemoveSection[_MAX_PATH];
        DWORD cbBuffer = sizeof (szRemoveSection);

        hr = pComponent->HrOpenInstanceKey (KEY_READ,
            &hkeyInstance, NULL, NULL);

        if(S_OK == hr)
        {
            hr = HrRegQuerySzBuffer (hkeyInstance, REGSTR_VAL_INFSECTION,
                        szRemoveSection, &cbBuffer);

            if (S_OK == hr)
            {
                //HrAddOrRemoveWinsockDependancy processes the winsock
                //remove section in the given inf file and then calls
                //MigrateWinsockConfiguration which will cause the
                //necessary PnP notifications to be issued to the
                //interested application.
                wcscat (szRemoveSection, c_szRemoveSectionSuffix);

                hr = HrAddOrRemoveWinsockDependancy (hinf, szRemoveSection);
            }
            RegSafeCloseKey (hkeyInstance);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrProcessWinsockRemove (%S)",
        pComponent->PszGetPnpIdOrInfId());

    return hr;
}

VOID
CModifyContext::ApplyChanges ()
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    CComponentList::const_iterator iter;
    CComponent* pComponent;
    CFilterDevices FilterDevices (&PNetConfig()->Core);
    CPszArray ServiceNames;
    CServiceManager ServiceManager;
    PCWSTR pszService;
    BOOL fRebootNeeded;
    BOOL fMigrateWinsock;
    BOOL fModifyFilterDevices;
    BOOL fSignalNetworkProviderLoaded;
    BOOL fUserIsNetConfigOps;
    BOOL fCallCoFreeUnusedLibraries;

    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (0 == m_ulRecursionDepth);

    pNetConfig = PNetConfig();

    fMigrateWinsock = FALSE;
    fModifyFilterDevices = FALSE;
    fSignalNetworkProviderLoaded = FALSE;
    fUserIsNetConfigOps = FIsUserNetworkConfigOps();
    fCallCoFreeUnusedLibraries = FALSE;

    //+-----------------------------------------------------------------------
    // Step 0: Prepare m_AddedBindPaths, m_DeletedBindPaths, and
    // m_DirtyComponents.
    //

    // Add the bindpaths that were once disabled, but are now enabled, to
    // m_AddedBindPaths.  We do this so that PnP notifications are sent for
    // them.
    //
    m_hr = m_AddedBindPaths.HrAddBindPathsInSet1ButNotInSet2 (
                &m_CoreStartedWith.DisabledBindings,
                &pNetConfig->Core.DisabledBindings);
    if (S_OK != m_hr)
    {
        return;
    }

    // Add the bindpaths that were once enabled, but are now disabled, to
    // m_DeletedBindPaths.  We do this so that PnP notifications are sent for
    // them.
    //
    m_hr = m_DeletedBindPaths.HrAddBindPathsInSet1ButNotInSet2 (
                &pNetConfig->Core.DisabledBindings,
                &m_CoreStartedWith.DisabledBindings);
    if (S_OK != m_hr)
    {
        return;
    }

    // m_fDirtyComponents should be empty unless we've explicitly dirtied
    // one or more.  If m_fDirtyComponents were not empty, it would probably
    // mean we forgot to clear it after the last Apply or Cancel.
    // Conversely, m_DirtyComponents better not be empty if we've explicitly
    // dirtied one or more.
    //
    Assert (FIff(!m_fComponentExplicitlyDirtied, m_DirtyComponents.FIsEmpty()));

    // Dirty the affected components (owners and adapters in bindpaths of
    // length 2) from the added and deleted bindpaths.  We need to write
    // bindings for these components.
    //
    m_hr = m_AddedBindPaths.HrGetAffectedComponentsInBindingSet (
                &m_DirtyComponents);
    if (S_OK != m_hr)
    {
        return;
    }

    m_hr = m_DeletedBindPaths.HrGetAffectedComponentsInBindingSet (
                &m_DirtyComponents);
    if (S_OK != m_hr)
    {
        return;
    }

    // Dirty components that exist in the current core, but not in the core
    // we started with.  (These are added components).
    //
    m_hr = m_DirtyComponents.HrAddComponentsInList1ButNotInList2 (
                &pNetConfig->Core.Components,
                &m_CoreStartedWith.Components);
    if (S_OK != m_hr)
    {
        return;
    }

    // Dirty components that exist in the core we started with, but not in
    // the current core.  (These are removed components).
    //
    m_hr = m_DirtyComponents.HrAddComponentsInList1ButNotInList2 (
                &m_CoreStartedWith.Components,
                &pNetConfig->Core.Components);
    if (S_OK != m_hr)
    {
        return;
    }

    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 0: The following components are dirty:\n");
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %-12S  (removed)\n",
                pComponent->PszGetPnpIdOrInfId());
        }
        else if (!m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %-12S  (installed)\n",
                pComponent->PszGetPnpIdOrInfId());
        }
        else
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S\n",
                pComponent->PszGetPnpIdOrInfId());
        }
    }

    // Reserve room for 32 pointers to service names.  We use this buffer
    // to start and stop services.
    //
    m_hr = ServiceNames.HrReserveRoomForPointers (32);
    if (S_OK != m_hr)
    {
        return;
    }

    // See if we are going to modify any filter devices.  If we are,
    // we'll go through all of the steps of loading filter devices, removing
    // any we don't need, installing any new ones, and binding them all up.
    // We only modify filter devices if the user is a normal admin and not
    // a netcfgop.
    //
    // This test could be further refined to see if we had any filters which
    // were dirty or if we had any dirty adapters which are filtered.
    //
    if (!fUserIsNetConfigOps)
    {
        fModifyFilterDevices = pNetConfig->Core.FContainsFilterComponent() ||
                              m_CoreStartedWith.FContainsFilterComponent();
    }
    else
    {
        Assert(!fModifyFilterDevices);
    }

    if (fModifyFilterDevices)
    {
        // Allow the filter devices structure to reserve whatever memory it
        // may need.
        //
        m_hr = FilterDevices.HrPrepare ();
        if (S_OK != m_hr)
        {
            return;
        }
    }

    pNetConfig->Core.DisabledBindings.Printf (ttidBeDiag,
        "   The following bindings are currently disabled:\n");


    //+-----------------------------------------------------------------------
    // Step 1: Save the network configuration binary.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 1: Save the network configuration binary.\n");

    HrSaveNetworkConfigurationToRegistry (pNetConfig);


    //+-----------------------------------------------------------------------
    // Step 2: Write the static bindings for all changed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 2: Write the following static bindings.\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If any protocols are dirty, we'll want to migrate winsock
        // configuration later.
        //
        if (NC_NETTRANS == pComponent->Class())
        {
            fMigrateWinsock = TRUE;
        }

        // If the component is in the core, write its bindings.
        // If it is not in the core, it means it has been removed and
        // we should therefore remove its bindings.
        //
        if (pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            hr = m_RegBindCtx.HrWriteBindingsForComponent (pComponent);

            // Remember any errors, but continue.
            //
            if (S_OK != hr)
            {
                Assert (FAILED(hr));
                m_hr = hr;
            }
        }
        else
        {
            // Only delete if we're not installing another version of this
            // component that has a duplicate PnpId.  If we had already
            // written the bindings for the newly installed one, and then
            // deleted the ones for the removed (yet duplicate PnpId), we'd
            // effectivly delete the bindings for the new one too.  See the
            // comments at step 6 for how we can get into this case.
            //
            if (!FIsEnumerated (pComponent->Class()) ||
                !pNetConfig->Core.Components.PFindComponentByPnpId (
                    pComponent->m_pszPnpId))
            {
                // There's no reason to fail if we can't delete the bindings.
                // The entire component is about to be tossed anyway.
                //
                (VOID) m_RegBindCtx.HrDeleteBindingsForComponent (pComponent);
            }
        }
    }


    //+-----------------------------------------------------------------------
    // Step 3: Notify ApplyRegistryChanges
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 3: Notify: apply registry changes\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ApplyRegistryChanges (
            pNetConfig->Notify.PINetCfg(),
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      %S notify object wants a reboot\n",
                pComponent->m_pszInfId);
        }
    }

    // Migrate Winsock configuration if needed.
    // Important to do this after the LANA map is written, afer Notify Applys
    // are called, but before any services are started.
    //
    if (fMigrateWinsock)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Migrating winsock configuration.\n");
        (VOID) HrMigrateWinsockConfiguration ();
    }

    //+-----------------------------------------------------------------------
    // Step 4: Unbind deleted bindpaths.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 4: Unbind the following deleted bindings:\n");

    if (!m_DeletedBindPaths.FIsEmpty())
    {
        // We don't need to send UNBIND notifications for bindpaths that
        // involve adapters that have been removed.  They will be unbound
        // automatically when the adapter is uninstalled.  (For the case
        // when the class installer is notifying us of a removed adapter,
        // its important NOT to try to send an UNBIND notification because
        // the adapter has already been uninstalled (hence unbound) and
        // our notification might come back in error causing us to need
        // a reboot uneccessary.
        //
        // So, remove the bindpaths in m_DeletedBindPaths that involve
        // adapters that have been removed.
        //
        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // If its enumerated, and not in the current core, its a
            // removed adapter.
            //
            if (FIsEnumerated (pComponent->Class()) &&
                !pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_DeletedBindPaths.RemoveBindPathsWithComponent (pComponent);
            }
        }

        m_DeletedBindPaths.SortForPnpUnbind ();

        m_RegBindCtx.PnpBindOrUnbindBindPaths (UNBIND,
            &m_DeletedBindPaths,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }
    }


    //+-----------------------------------------------------------------------
    // Step 5: Stop services for removed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 5: Stop the following services:\n");

    Assert (0 == ServiceNames.Count());
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Ignore enumerated components because they will have their drivers
        // stopped automatically (if appropriate) when they are removed.
        // Ignore components that are in the current core (not being removed).
        //
        if (FIsEnumerated (pComponent->Class()) ||
            pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // Winsock remove section needs to be processed for every
        // component that is being removed in order to update
        // Transport key for the winsock registry settings

        HrProcessWinsockRemove (pComponent);

        // If its a protcol, send an UNLOAD before trying to stop the service.
        //

        if ((NC_NETTRANS == pComponent->Class()) || (NCF_NDIS_PROTOCOL & pComponent->m_dwCharacter))
        {
            // Unload can fail as a lot of drivers do not support it.
            // Treat it as an 'FYI' indication and don't set the reboot
            // flag if it fails.
            //
            (VOID) HrPnpUnloadDriver (NDIS, pComponent->Ext.PszBindName());
        }

        // Ignore components that don't have any services.
        if (!pComponent->Ext.PszCoServices())
        {
            continue;
        }


        for (pszService = pComponent->Ext.PszCoServices();
             *pszService;
             pszService += wcslen(pszService) + 1)
        {
            (VOID)ServiceNames.HrAddPointer (pszService);

            g_pDiagCtx->Printf (ttidBeDiag, "   %S", pszService);
        }
        g_pDiagCtx->Printf (ttidBeDiag, "\n");
    }

    if (ServiceNames.Count() > 0)
    {
        static const CSFLAGS CsStopFlags =
        {
            FALSE,                  // FALSE means don't start
            SERVICE_CONTROL_STOP,   // use this control instead
            15000,                  // wait up to 15 seconds...
            SERVICE_STOPPED,        // ... for service to reach this state
            FALSE,                  //
        };

        hr = ServiceManager.HrControlServicesAndWait (
                ServiceNames.Count(),
                ServiceNames.begin(),
                &CsStopFlags);

        if (S_OK != hr)
        {
            m_fRebootRequired = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      some service failed to stop (hr = 0x%08X)\n",
                hr);

            // Unfortunately, there is no easy way to get back which service
            // did not stop and then to figure out which component contains
            // that service.  Sooo, we'll just put every component that is
            // being removed in lockdown.  This isn't a big deal when the UI
            // is doing the removal because it only removes things one at a
            // time.
            //
            for (iter  = m_DirtyComponents.begin();
                 iter != m_DirtyComponents.end();
                 iter++)
            {
                pComponent = *iter;
                Assert (pComponent);

                if (FIsEnumerated (pComponent->Class()) ||
                    !pComponent->Ext.PszCoServices() ||
                    pNetConfig->Core.Components.FComponentInList (pComponent))
                {
                    continue;
                }

                LockdownComponentUntilNextReboot (pComponent->m_pszInfId);
            }
        }

        ServiceNames.Clear();
    }

    //+-----------------------------------------------------------------------
    // Step 5a: Uninstall filters first.
    //

    if (fModifyFilterDevices)
    {
        g_pDiagCtx->Printf(ttidBeDiag, "Step 5a: Remove filter devices:\n");

        // Order is of utmost importance here.  Remove must be called first
        // because it initializes some state internal to FilterDevices.  Start
        // must come after Write and Write obviously has to come after all
        // new filter devices are installed.
        //
        FilterDevices.LoadAndRemoveFilterDevicesIfNeeded ();
    }


    //+-----------------------------------------------------------------------
    // Step 6: Uninstall removed components.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 6: Uninstall the following components:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If the component is in the core, ignore it.
        // If it is not in the core, it means it has been removed and
        // we should therefore remove its bindings.
        //
        if (pNetConfig->Core.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // If this is an enumerated component whose PnpId matches that of
        // a component in the current core, we've run into a special case.
        // This can happen when the external data (like the NetCfgInstanceId)
        // is corrupted and the class installer was told to update the
        // component.  The class installer is really told to "install" the
        // component, but if it already exists as determined by the presence
        // of NetCfgInstanceId, the class installer translates it to "update".
        // Without the key, the class installer thinks its installing
        // a new one.  We detect the duplicate PnpId and remove the "prior"
        // so we can install the "new".  This "prior" instance is what we
        // are finalizing the remove of, but if we call HrCiRemoveComponent,
        // it just removes the same PnpId that the class installer told us
        // to install.  By not calling HrCiRemoveComponent for this case,
        // the "prior" instance key gets reused implicitly by the "new"
        // instance.
        //
        if (FIsEnumerated (pComponent->Class()) &&
            pNetConfig->Core.Components.PFindComponentByPnpId (
                pComponent->m_pszPnpId))
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "   Skip removal of %S because a duplicate was installed\n",
                pComponent->m_pszPnpId);

            continue;
        }

        g_pDiagCtx->Printf (ttidBeDiag,
            "   %S\n", pComponent->PszGetPnpIdOrInfId());

        hr = HrCiRemoveComponent (pComponent, &pComponent->m_strRemoveSection);

        // We can ignore SPAPI_E_NO_SUCH_DEVINST because the class installer
        // may have already removed it and is just notifying us.
        //
        if ((S_OK != hr) && (SPAPI_E_NO_SUCH_DEVINST != hr))
        {
            m_fRebootRequired = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ needs a reboot (hr = 0x%08X)\n",
                hr);
        }
    }

    //+-----------------------------------------------------------------------
    // Step 6a: Modify filter devices.
    //
    if (fModifyFilterDevices)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "Step 6a: Modify filter devices:\n");

        FilterDevices.InstallFilterDevicesIfNeeded ();

        (VOID)m_RegBindCtx.HrWriteBindingsForFilterDevices (&FilterDevices);

        PruneNdisWanBindPathsIfActiveRasConnections (
            &FilterDevices.m_BindPathsToRebind,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }

        m_RegBindCtx.PnpBindOrUnbindBindPaths (UNBIND,
            &FilterDevices.m_BindPathsToRebind,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            m_fRebootRecommended = TRUE;
        }

        g_pDiagCtx->Printf (ttidBeDiag, "Step 6b: Starting filter devices:\n");

        FilterDevices.StartFilterDevices ();
        FilterDevices.Free ();
    }

    //+-----------------------------------------------------------------------
    // Step 7: Start services for added components.
    //
    Assert (0 == ServiceNames.Count());

    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 7: Start the following drivers/services:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // If the component is in the core we started with, ignore it.
        // If it is not in the core we started with, it means it is newly
        // installed we should therefore start its services.
        //
        if (m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // If we've added a network client, we'll need to signal the
        // network provider loaded event after we've started its service.
        //
        if (NC_NETCLIENT == pComponent->Class())
        {
            fSignalNetworkProviderLoaded = TRUE;
        }

        if (FIsEnumerated (pComponent->Class()))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S\n", pComponent->m_pszPnpId);

            hr = pComponent->HrStartOrStopEnumeratedComponent (DICS_START);

            if (S_OK != hr)
            {
                m_fRebootRecommended = TRUE;

                g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ needs a reboot (hr = 0x%08X)\n",
                    hr);
            }

            if (FIsPhysicalNetAdapter (pComponent->Class(),
                    pComponent->m_dwCharacter) && FInSystemSetup())
            {
                ProcessAdapterAnswerFileIfExists (pComponent);
            }
        }
        else if (pComponent->Ext.PszCoServices())
        {
            for (pszService = pComponent->Ext.PszCoServices();
                 *pszService;
                 pszService += wcslen(pszService) + 1)
            {
                (VOID)ServiceNames.HrAddPointer (pszService);

                g_pDiagCtx->Printf (ttidBeDiag, "   %S", pszService);
            }
            g_pDiagCtx->Printf (ttidBeDiag, "\n");

            // If we're in system setup, then exclude whatever services
            // the component has marked as such.
            //
            if (FInSystemSetup())
            {
                ExcludeMarkedServicesForSetup (pComponent, &ServiceNames);
            }
        }
    }

    if ((ServiceNames.Count() > 0) &&
        !(g_pDiagCtx->Flags() & DF_DONT_START_SERVICES))
    {
        static const CSFLAGS CsStartFlags =
        {
            TRUE,               // TRUE means start
            0,
            20000,              // wait up to 20 seconds...
            SERVICE_RUNNING,    // ... for service to reach this state
            TRUE,               // ignore demand-start and disabled
        };

        hr = ServiceManager.HrControlServicesAndWait (
                ServiceNames.Count(),
                ServiceNames.begin(),
                &CsStartFlags);

        if (S_OK != hr)
        {
            m_fRebootRecommended = TRUE;

            g_pDiagCtx->Printf (ttidBeDiag, "      some service failed to start (hr = 0x%08X)\n",
                hr);
        }
    }


    //+-----------------------------------------------------------------------
    // Step 8: Bind added bindpaths.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 8: Bind the following added bindings:\n");

    if (fModifyFilterDevices)
    {
        hr = m_AddedBindPaths.HrAppendBindingSet (
                &FilterDevices.m_BindPathsToRebind);
        if (S_OK != hr)
        {
            // Well, that's not good, but there is nothing we can do about
            // it now.  (Most likely we ran out of memory.)
        }
    }

    if (!m_AddedBindPaths.FIsEmpty())
    {
        CBindPath* pBindPath;

        // We don't need to send BIND notifications for bindpaths that
        // involve adapters that have been newly installed.  They will be
        // bound automatically when the adapter is started.
        //
        // Update to the above comment: We THOUGHT that was correct, but it
        // turns out it isn't.  TDI isn't PNP (guess they must have missed
        // THAT memo) and they are not re-reading the new bind strings
        // from the registry when lower notifications bubble up.  So, we
        // have to send these BINDS for added adapters too.
        //
        // We should remove bindpaths that involve components that have
        // been removed.  These can end up in added bindpaths because way
        // up in step 0, we added bindpaths that were disabled in the
        // core we started with and that are no longer disabled in the
        // current core.  Well, when the component is removed, its disabled
        // bindings are removed, so this case would have caused us to add
        // the bindpath to this binding set.
        //
        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // If its been removed, remove any bindpaths that reference it.
            //
            if (!pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_AddedBindPaths.RemoveBindPathsWithComponent (pComponent);
            }
        }

        // To prevent TDI from sending duplicate BINDs to its clients, we
        // have to do a little more work.  We need to not send the TDI
        // BINDs to components that are newly installed.  This is because
        // TDI sent them the BINDs when we started the driver above.
        // So, for each added bindpath, if it's going to the TDI layer, and
        // the owner (topmost) component of the bindpath is newly installed,
        // remove it from the added binding so we won't send a notification
        // for it below.
        //
        pBindPath = m_AddedBindPaths.begin();
        while (pBindPath != m_AddedBindPaths.end())
        {
            UINT unLayer = GetPnpLayerForBindPath (pBindPath);

            if ((TDI == unLayer) &&
                !m_CoreStartedWith.Components.FComponentInList (
                        pBindPath->POwner()))
            {
                m_AddedBindPaths.erase (pBindPath);
            }
            else
            {
                pBindPath++;
            }
        }

        m_AddedBindPaths.SortForPnpBind ();

        m_RegBindCtx.PnpBindOrUnbindBindPaths (BIND,
            &m_AddedBindPaths,
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            // If BINDs fail, we should recommend a reboot, but one is
            // not required for subsequent installs or removes.
            //
            m_fRebootRecommended = TRUE;
        }
    }

    // Signal the network provider loaded event if needed.
    // Probably best to do this after we've indiciated the PnP bindings
    // (above) to the new clients.
    //
    if (fSignalNetworkProviderLoaded)
    {
        SignalNetworkProviderLoaded ();
    }

    //+-----------------------------------------------------------------------
    // Step 9: Allow notify objects to apply PnP changes
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 9: Notify: apply PnP changes\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ApplyPnpChanges (
            pNetConfig->Notify.PINetCfg(),
            &fRebootNeeded);

        if (fRebootNeeded)
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "      %S notify object wants a reboot\n",
                pComponent->m_pszInfId);

            // If the component has been removed, treat the reboot
            // as mandatory.  (The reason being that we cannot risk a
            // failed re-install.)  We put the component into lockdown
            // in this situation.
            //
            if (!pNetConfig->Core.Components.FComponentInList (pComponent))
            {
                m_fRebootRequired = TRUE;

                LockdownComponentUntilNextReboot (pComponent->m_pszInfId);
            }
            else
            {
                m_fRebootRecommended = TRUE;
            }
        }
    }

    //+-----------------------------------------------------------------------
    // Step 10: Release notify objects for removed components and
    // process any DelFiles in the remove section of their INF.
    //
    g_pDiagCtx->Printf (ttidBeDiag,
        "Step 10: Release notify objects for removed components:\n");

    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip enumerated components (they don't have notify objects), and
        // Skip components that were not removed.
        // Skip components that don't have their INF open (like unsupported
        // components that get removed during GUI setup.)
        //
        if (FIsEnumerated (pComponent->Class()) ||
            pNetConfig->Core.Components.FComponentInList (pComponent) ||
            !pComponent->GetCachedInfFile())
        {
            continue;
        }

        pComponent->Notify.ReleaseNotifyObject(NULL, FALSE);

        fCallCoFreeUnusedLibraries = TRUE;
    }

    if (fCallCoFreeUnusedLibraries)
    {
        g_pDiagCtx->Printf (ttidBeDiag,
            "   calling CoFreeUnusedLibraries before running remove sections\n");

        // Now ask COM to unload any DLLs hosting COM objects that are no longer
        // in use.  (This is a bit heavy-handed as it affects the entire process,
        // but there is currently no other way to safely unload the DLLs hosting
        // the notify objects of the removed components.)
        //
        CoFreeUnusedLibrariesEx(0, 0);

        for (iter  = m_DirtyComponents.begin();
             iter != m_DirtyComponents.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Skip enumerated components (they don't have notify objects), and
            // Skip components that were not removed.
            // Skip components that don't have their INF open (like unsupported
            // components that get removed during GUI setup.)
            //
            if (FIsEnumerated (pComponent->Class()) ||
                pNetConfig->Core.Components.FComponentInList (pComponent) ||
                !pComponent->GetCachedInfFile())
            {
                continue;
            }

            g_pDiagCtx->Printf (ttidBeDiag,
                "   %S  [%S]\n", pComponent->PszGetPnpIdOrInfId(),
                                 pComponent->m_strRemoveSection.c_str());

            (VOID) HrCiInstallFromInfSection(
                        pComponent->GetCachedInfFile(),
                        pComponent->m_strRemoveSection.c_str(),
                        NULL, NULL, SPINST_FILES);
        }
    }


/*
    //+-----------------------------------------------------------------------
    // Step 11: Reconfigure moved bindings
    //
    // If we changed binding order, Send PnP RECONFIGURE for all dirty
    // components that are neither installed nor removed so we
    // pickup these order changes.
    //
    for (iter  = m_DirtyComponents.begin();
         iter != m_DirtyComponents.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        // Skip components that have been newly installed or removed.
        //
        if (!pNetConfig->Core.Components.FComponentInList (pComponent) ||
            !m_CoreStartedWith.Components.FComponentInList (pComponent))
        {
            continue;
        }

        // Note: send RECONFIGURE
    }
*/
}

HRESULT
CModifyContext::HrEnableOrDisableBindPath (
    IN DWORD dwChangeFlag,
    IN CBindPath* pBindPath,
    IN INetCfgBindingPath* pIPath OPTIONAL)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    UINT CountBefore;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert ((dwChangeFlag == NCN_ENABLE) || (dwChangeFlag == NCN_DISABLE));
    Assert (pBindPath);

    hr = S_OK;
    pNetConfig = PNetConfig();

    // Get the count of bindpaths currently disabled.  If it changes
    // after we enable/disable this one, we'll inform notify objects
    // about it.  If the count does not change, it means the state
    // of the bindpath has not changed.
    //
    CountBefore = pNetConfig->Core.DisabledBindings.CountBindPaths();

    if (NCN_ENABLE == dwChangeFlag)
    {
        pNetConfig->Core.EnableBindPath (pBindPath);
        Assert (S_OK == hr);
    }
    else
    {
        hr = pNetConfig->Core.HrDisableBindPath (pBindPath);
    }

    if ((S_OK == hr) &&
        (pNetConfig->Core.DisabledBindings.CountBindPaths() != CountBefore))
    {
        // Note: Need to protect against bad notify objects that
        // switch the state of a bindpath we are notifying for.
        // This could cause an infinite loop.  Solve by adding a
        // recursion count and bindset to the modify context dedicated
        // to bindpath enabling/disabling.  When the count is zero,
        // we clear the bindingset, add the bindpath we are about to
        // notify for, increment the recursion count and call
        // NotifyBindPath.  When the call returns, we decrement the
        // recursion count, remove the bindpath from the binding set,
        // and return.  Before we call NotifyBindPath when the recursion
        // count is non-zero, if the bindpath is already in the
        // bindingset, we don't call.
        //

        pNetConfig->Notify.NotifyBindPath (dwChangeFlag, pBindPath, pIPath);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrEnableOrDisableBindPath");
   return hr;
}

VOID
CModifyContext::InstallOrRemoveRequiredComponents (
    IN CComponent* pComponent,
    IN IOR_ACTION Action)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    HKEY hkeyInstance;
    PWSTR pszRequiredList;
    const WCHAR szDelims[] = L", ";

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);
    Assert ((IOR_INSTALL == Action) || (IOR_REMOVE == Action));

    pszRequiredList = NULL;

    // Open the instance key of the component and read the RequireAll value.
    // This value may not exist, which is okay, it means we have nothing
    // to do.
    //
    hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyInstance, NULL, NULL);

    if (S_OK == hr)
    {
        HKEY hkeyNdi;

        hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

        if (S_OK == hr)
        {
            hr = HrRegQuerySzWithAlloc (hkeyNdi, L"RequiredAll",
                    &pszRequiredList);

            RegCloseKey (hkeyNdi);
        }

        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
            Assert (!pszRequiredList);
        }

        RegCloseKey (hkeyInstance);
    }

    // If we have a list of required components, install or remove them.
    //
    if ((S_OK == hr) && pszRequiredList)
    {
        CNetConfig* pNetConfig;
        INetCfgComponent* pIComp;

        pNetConfig = PNetConfig();

        hr = pComponent->HrGetINetCfgComponentInterface (
                pNetConfig->Notify.PINetCfg(),
                &pIComp);

        if (S_OK == hr)
        {
            PCWSTR pszInfId;
            PWSTR pszNextInfId;
            OBO_TOKEN OboToken;
            CComponent* pComponentToRemove;
            WCHAR szInfFile [_MAX_PATH];

            ZeroMemory (&OboToken, sizeof(OboToken));
            OboToken.Type = OBO_COMPONENT;
            OboToken.pncc = pIComp;

            // For each INF ID in the comma separate list of required
            // components...
            //
            for (pszInfId = GetNextStringToken (pszRequiredList, szDelims, &pszNextInfId);
                 pszInfId && *pszInfId;
                 pszInfId = GetNextStringToken (NULL, szDelims, &pszNextInfId))
            {
                if (IOR_INSTALL == Action)
                {
                    NETWORK_INSTALL_PARAMS nip;
                    COMPONENT_INSTALL_PARAMS Params;

                    ZeroMemory (&Params, sizeof(Params));

                    // Get the Class corresponding to the INF ID.
                    //
                    m_hr = HrCiGetClassAndInfFileOfInfId (
                            pszInfId, &Params.Class, szInfFile);
                    if (S_OK != m_hr)
                    {
                        break;
                    }

                    //$REVIEW:Should we stick the filename in the
                    // COMPONENT_INSTALL_PARAMS so that we don't grovel
                    // the INF directory to find it again?
                    // If so, store the filename buffer in the modify
                    // context so we don't take up stack space or heap space.
                    // Just need to be sure that we use it to install the
                    // component before we recurse and overwrite it.

                    // Pack the network install parameters and call the common
                    // function.
                    //
                    //$REVIEW: we probably need dwSetupFlags and dwUpgradeFromBuildNo
                    // in the modify context saved when it was called at
                    // recursion depth 0.  Otherwise, things installed here
                    // during GUI setup will have wrong parameters.
                    //
                    nip.dwSetupFlags         = 0;
                    nip.dwUpgradeFromBuildNo = 0;
                    nip.pszAnswerFile        = NULL;
                    nip.pszAnswerSection     = NULL;

                    // Setup the component install parameters.
                    //
                    Params.pszInfId   = pszInfId;
                    Params.pszInfFile = szInfFile;
                    Params.pOboToken  = FIsEnumerated (Params.Class)
                                            ? NULL : &OboToken;
                    Params.pnip       = &nip;

                    //
                    // THIS MAY CAUSE RECURSION
                    //
                    // (just using pComponentToRemove as a placeholder
                    // for a required parameter.)
                    //
                    HrInstallNewOrReferenceExistingComponent (
                        Params, &pComponentToRemove);
                    if (S_OK != m_hr)
                    {
                        break;
                    }
                }
                else
                {
                    Assert (IOR_REMOVE == Action);

                    // Search for the component to remove using its INF ID.
                    //
                    pComponentToRemove = pNetConfig->Core.Components.
                                    PFindComponentByInfId (pszInfId, NULL);

                    if (pComponentToRemove)
                    {
                        //
                        // THIS MAY CAUSE RECURSION
                        //
                        HrRemoveComponentIfNotReferenced (
                            pComponentToRemove,
                            FIsEnumerated (pComponentToRemove->Class())
                                    ? NULL
                                    : &OboToken,
                            NULL);
                        if (S_OK != m_hr)
                        {
                            break;
                        }
                    }
                }
            }

            ReleaseObj (pIComp);
        }

        MemFree (pszRequiredList);
    }
}

//----------------------------------------------------------------------------
// Update a component.  Do this by generating the bindings which involve
// the component and noting them as 'OldBindPaths'.  The stack entries which
// involve the component are removed and re-generated and the bindings which
// involve the component are again noted as 'NewBindPaths'.  The old bindings
// are compared to the new bindings and the differences are notified to
// notify objects as either being removed or added.  For any removed bindings,
// we also remove them from the core's disabled set if they happen to exist
// there too.
//
// Assumptions:
//  The INF for pComponent has already been re-run so that the potentially
//  new values for UpperRange, LowerRange, etc. are present in the registry.
//
//  pComponent has had its external data loaded already.
//
HRESULT
CModifyContext::HrUpdateComponent (
    IN CComponent* pComponent,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;
    CNetConfig* pNetConfig;
    CBindingSet OldBindPaths;
    CBindingSet NewBindPaths;
    CBindPath* pScan;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (m_fPrepared);
    Assert (pComponent);

    pNetConfig = PNetConfig();

    // Now that we actually are going to modify something, push a new
    // recursion depth.
    //
    PushRecursionDepth();
    Assert (S_OK == m_hr);

    // Generate the "old" bindings by noting those which involve the
    // component.
    //
    hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &OldBindPaths);
    if (S_OK != hr)
    {
        goto finished;
    }

    // Reload the external data so we pickup what the possibly updated
    // INF has changed.
    //
    hr = pComponent->Ext.HrReloadExternalData ();

    if (S_OK != hr)
    {
        goto finished;
    }

    // Update the stack table entries for the component.
    //

    hr = pNetConfig->Core.StackTable.HrUpdateEntriesForComponent (
                pComponent,
                &pNetConfig->Core.Components,
                INS_SORTED);
    if (S_OK != hr)
    {
        // This is not good.  We ripped out the stack entries and failed
        // putting them back in.  The stack table now has no entries for
        // this component.  Prevent this from being applied by setting the
        // modify context's HRESULT to the error.
        //
        m_hr = hr;
        goto finished;
    }

    // Generate the "new" bindings by noting those which involve the
    // component.
    //
    hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &NewBindPaths);
    if (S_OK != hr)
    {
        // Probably out of memory.  Prevent apply by setting the modify
        // context's HRESULT to the error.
        //
        m_hr = hr;
        goto finished;
    }

    // Notify any bindpaths which have been removed.
    //
    for (pScan  = OldBindPaths.begin();
         pScan != OldBindPaths.end();
         pScan++)
    {
        if (NewBindPaths.FContainsBindPath (pScan))
        {
            continue;
        }

        m_DeletedBindPaths.HrAddBindPath (pScan, INS_IGNORE_IF_DUP | INS_APPEND);
        pNetConfig->Core.DisabledBindings.RemoveBindPath (pScan);
        pNetConfig->Notify.NotifyBindPath (NCN_REMOVE, pScan, NULL);
    }

    // Notify any bindpaths which have been added.
    //
    for (pScan  = NewBindPaths.begin();
         pScan != NewBindPaths.end();
         pScan++)
    {
        if (OldBindPaths.FContainsBindPath (pScan))
        {
            continue;
        }

        m_AddedBindPaths.HrAddBindPath (pScan, INS_IGNORE_IF_DUP | INS_APPEND);
        pNetConfig->Notify.NotifyBindPath (NCN_ADD | NCN_ENABLE, pScan, NULL);
    }

    // Notify that the component has been updated.
    //
    pNetConfig->Notify.ComponentUpdated (pComponent,
                    dwSetupFlags,
                    dwUpgradeFromBuildNo);

finished:

    hr = HrPopRecursionDepth();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CModifyContext::HrUpdateComponent (%S)",
        pComponent->PszGetPnpIdOrInfId());
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\ncwins.cpp ===
//
// File:    ncwins.cpp
//
// Purpose: Manage the creation and maintanence of the Winsock service.
//
// Entry Point:
//          HrAddOrRemoveWinsockDependancy
//
// Changes: 18-Mar-97 Created scottbri
//
#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "ncxbase.h"
#include "ncinf.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "resource.h"
#include "wscfg.h"
#include <winsock2.h>
#include <ws2spi.h>

extern "C"
{
#include <wsasetup.h>
}

extern const WCHAR c_szBackslash[];
extern const WCHAR c_szParameters[];

static const WCHAR c_szWinsockName[]        = L"Winsock";
static const WCHAR c_szLibraryName[]        = L"LibraryPath";
static const WCHAR c_szDisplayString[]      = L"DisplayString";
static const WCHAR c_szSupportedNameSpace[] = L"SupportedNameSpace";
static const WCHAR c_szProviderId[]         = L"ProviderId";
static const WCHAR c_szVersion[]            = L"Version";
static const WCHAR c_szTransportService[]   = L"TransportService";
static const WCHAR c_szHelperDllName[]      = L"HelperDllName";
static const WCHAR c_szMaxSockAddrLength[]  = L"MaxSockAddrLength";
static const WCHAR c_szMinSockAddrLength[]  = L"MinSockAddrLength";
static const WCHAR c_szWinsockMapping[]     = L"Mapping";
static const WCHAR c_szErrorControl[]       = L"ErrorControl";
static const WCHAR c_szStartType[]          = L"Start";
static const WCHAR c_szServiceType[]        = L"Type";
static const WCHAR c_szTransports[]         = L"Transports";
static const WCHAR c_szAFDServiceName[]     = L"AFD";
static const WCHAR c_szTDI[]                = L"TDI";
static const WCHAR c_szAddSecLabel[]        = L"AddSock";
static const WCHAR c_szRemoveSecLabel[]     = L"DelSock";
static const WCHAR c_szServices[]           = L"System\\CurrentControlSet\\Services";
static const WCHAR c_szAfdSrvImagePath[]    = L"\\SystemRoot\\System32\\drivers\\afd.sys";

typedef struct {
    PCWSTR      pszVal;
    DWORD       dwData;
} WRITEREGDW;

// Begin - Stolen from nt\private\inc\wsahelp.h
// Not exposed in public sdk header files, only documented in MSDN
// so the structure is unlikely to change
typedef struct _WINSOCK_MAPPING {
    DWORD Rows;
    DWORD Columns;
    struct {
        DWORD AddressFamily;
        DWORD SocketType;
        DWORD Protocol;
    } Mapping[1];
} WINSOCK_MAPPING, *PWINSOCK_MAPPING;

typedef
DWORD
(WINAPI * PWSH_GET_WINSOCK_MAPPING) (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );

DWORD
WINAPI
WSHGetWinsockMapping (
    OUT PWINSOCK_MAPPING Mapping,
    IN DWORD MappingLength
    );
// End - Stolen from nt\private\inc\wsahelp.h


HRESULT HrRunWinsock2Migration()
{

    HRESULT hr = HrMigrateWinsockConfiguration();

    TraceHr (ttidError, FAL, hr, FALSE, "HrRunWinsock2Migration");
    return hr;
}

//
// Function:    HrRemoveNameSpaceProvider
//
// Purpose:     Remove a Winsock namespace
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrRemoveNameSpaceProvider (
    const GUID *pguidProvider)
{
    DWORD dwErr;

    // Ignore any WSAEINVAL error.  It occurs when the name space provider was
    // already removed.
    //
    dwErr = WSCUnInstallNameSpace((GUID *)pguidProvider);
    if ((0 != dwErr) && (WSAEINVAL != GetLastError()))
    {
        TraceError("HrRemoveNameSpaceProvider", HrFromLastWin32Error());
        return HrFromLastWin32Error();
    }

#ifdef _WIN64
    // Uninstall 32 bit name space as well.
    //
    dwErr = WSCUnInstallNameSpace32((GUID *)pguidProvider);
    if ((0 != dwErr) && (WSAEINVAL != GetLastError()))
    {
        TraceError("HrRemoveNameSpaceProvider", HrFromLastWin32Error());
        return HrFromLastWin32Error();
    }
#endif
    return S_OK;
}

//
// Function:    HrAddNameSpaceProvider
//
// Purpose:     Create a Winsock namespace
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddNameSpaceProvider (
    PCWSTR pszDisplayName,
    PCWSTR pszPathDLLName,
    DWORD  dwNameSpace,
    DWORD  dwVersion,
    const GUID * pguidProvider)
{
    // Call the Winsock API to create a namespace
    if (WSCInstallNameSpace((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, dwVersion,
                                (GUID *)pguidProvider))
    {
        // They namespace provider may already be registered
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Name space provider may already be registered.");
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Trying to unregister and then re-register.");

        // Try unregistering it, and then give one more try at registering it.
        HrRemoveNameSpaceProvider(pguidProvider);

        if (WSCInstallNameSpace((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, dwVersion,
                                (GUID *)pguidProvider))
        {
            TraceError("HrAddNameSpaceProvider - Second attempt failed, returning error", HrFromLastWin32Error());
            return HrFromLastWin32Error();
        }
    }

#ifdef _WIN64
    // Call the Winsock API to create a 32 namespace
    if (WSCInstallNameSpace32((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, dwVersion,
                                (GUID *)pguidProvider))
    {
        // They namespace provider may already be registered
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "32 bit Name space provider may already be registered.");
        TraceTag(ttidNetcfgBase, "HrAddNameSpaceProvider - "
            "Trying to unregister and then re-register 32 bit name space.");

        // Try unregistering it, and then give one more try at registering it.
        // Use direct call to ws2_32 to avoid unregistering 64 bit provider.
        WSCUnInstallNameSpace32((GUID *)pguidProvider);

        if (WSCInstallNameSpace32((PWSTR)pszDisplayName, (PWSTR)pszPathDLLName,
                                dwNameSpace, dwVersion,
                                (GUID *)pguidProvider))
        {
            TraceError("HrAddNameSpaceProvider - Second attempt failed (32 bit), returning error", HrFromLastWin32Error());
            return HrFromLastWin32Error();
        }
    }
#endif

    return S_OK;
}

//
// Function:    HrInstallWinsock
//
// Purpose:     Copy winsock and afd related files, and setup the appropriate
//              registry values
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK if afd and winsock are installed successfully
//
HRESULT HrInstallWinsock()
{
    DWORD           dwDisposition;
    HKEY            hkeyParameters = NULL;
    HKEY            hkeyWinsock = NULL;
    HRESULT         hr;
    INT             i;
    WRITEREGDW      regdata[3];
    tstring         strBuf;
    CService        srvc;
    CServiceManager sm;

    hr = sm.HrCreateService( &srvc, c_szAFDServiceName,
                             SzLoadIds(IDS_NETCFG_AFD_SERVICE_DESC),
                             0x1, 0x2, 0x1, c_szAfdSrvImagePath,
                             NULL, c_szTDI, NULL, SERVICE_ALL_ACCESS,
                             NULL, NULL, NULL);
    if (SUCCEEDED(hr))
    {
        // For VadimE, start AFD as soon as it is installed
        //
        (VOID)sm.HrStartServiceNoWait(c_szAFDServiceName);

        srvc.Close();
    }

    // Close the service control manager.
    sm.Close();

    if (FAILED(hr) && (HRESULT_FROM_WIN32 (ERROR_SERVICE_EXISTS) != hr))
    {
        goto Done;
    }

    // Create/Open the Services\Winsock key
    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                            &hkeyWinsock, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Create/Open the Services\Winsock\Parameters key
    strBuf += c_szBackslash;
    strBuf += c_szParameters;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE, KEY_READ_WRITE, NULL,
                            &hkeyParameters, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Populate the Winsock key
    regdata[0].pszVal  = c_szErrorControl;
    regdata[0].dwData = 0x1;                // ErrorControl
    regdata[1].pszVal  = c_szStartType;
    regdata[1].dwData = 0x3;                // Start Type
    regdata[2].pszVal  = c_szServiceType;
    regdata[2].dwData = 0x4;                // Service Type

    // Write the data to the components Winsock subkey
    for (i=0; i<3; i++)
    {
        hr = HrRegSetDword(hkeyWinsock, regdata[i].pszVal, regdata[i].dwData);
        if (S_OK != hr)
        {
            goto Done;
        }
    }

Done:
    TraceError("HrInstallWinsock",hr);
    RegSafeCloseKey(hkeyParameters);
    RegSafeCloseKey(hkeyWinsock);
    return hr;
}

//
// Function:    FIsWinsockInstalled
//
// Purpose:     Verify whether winsock is installed
//
// Parameters:  pfInstalled [OUT] - Contains TRUE if Winsock is currently installed
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrIsWinsockInstalled (
    BOOL * pfInstalled)
{
    HRESULT hr;
    HKEY    hkey;
    tstring strBuf;

    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;

    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(), KEY_READ,
                           &hkey );
    if (S_OK == hr)
    {
        RegCloseKey(hkey);

        // Now check to make sure AFD is installed
        strBuf = c_szServices;
        strBuf += c_szBackslash;
        strBuf += c_szAFDServiceName;
        hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(), KEY_READ,
                               &hkey );
        if (S_OK == hr)
        {
            RegCloseKey(hkey);
            *pfInstalled = TRUE;
        }
    }

    if (S_OK != hr)
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        *pfInstalled = FALSE;
    }

    TraceError("HrIsWinsockInstalled", hr);
    return hr;
}

//
// Function:    HrUpdateWinsockTransportList
//
// Purpose:     Update the contents of Winsock's Transport property by
//              adding/removing the specified transport
//
// Parameters:  pszTransport [IN] - Name of the transport to add/remove
//              fInstall    [IN] - If TRUE, install, otherwise remove
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrUpdateWinsockTransportList (
    PCWSTR pszTransport,
    BOOL fInstall)
{
    HKEY    hkey = NULL;
    HRESULT hr;
    tstring strBuf;

    strBuf = c_szServices;
    strBuf += c_szBackslash;;
    strBuf += c_szWinsockName;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;

    hr = HrRegOpenKeyEx( HKEY_LOCAL_MACHINE, strBuf.c_str(),
                           KEY_READ_WRITE, &hkey );
    if (S_OK != hr)
    {
        // Handle registry key not found.  When installing a component with
        // a winsock dependancy an in memory state can exist such that winsock
        // is not literally installed yet (Apply has not been pressed).  If
        // the user removes this added component, the current removal code
        // processes the services removal section, which includes winsock
        // removal.  Since we haven't actually gotten as a far as installing
        // winsock yet accessing the winsock parameters key is not possible.
        // Safely consume the error.
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            hr = S_OK;
        }
        goto Done;
    }

    if (fInstall)
    {
        hr = HrRegAddStringToMultiSz(pszTransport, hkey, NULL, c_szTransports,
                                       STRING_FLAG_ENSURE_AT_END, 0);
    }
    else
    {
        hr = HrRegRemoveStringFromMultiSz(pszTransport, hkey, NULL,
                                            c_szTransports,
                                            STRING_FLAG_REMOVE_ALL);
    }

Done:
    RegSafeCloseKey(hkey);
    TraceError("HrUpdateWinsockTransport", hr);
    return hr;
}

#define WSHWINSOCKMAPPING "WSHGetWinsockMapping"
#define WSH_MAX_MAPPING_DATA 8192

//
// Function:    HrWriteWinsockMapping
//
// Purpose:     To extract the magic binary data from the winsock helper dll.
//              This code was extracted from nt\private\net\ui\ncpa1.1\netcfg\setup.cpp
//
// Parameters:  pszDllName - Name of the Winsock helper DLL
//              hkey - Key where the "Mapping" value is to be written
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrWriteWinsockMapping (
    PCWSTR pszDllName,
    HKEY hkey)
{
    INT                      cb;
    DWORD                    cbMapping;
    HRESULT                  hr;
    HMODULE                  hDll = NULL;
    PWSH_GET_WINSOCK_MAPPING pMapFunc = NULL;
    PWINSOCK_MAPPING         pMapTriples = NULL;
    WCHAR                    tchExpandedName [MAX_PATH+1];

    do  // Pseudo-loop
    {
        pMapTriples = (PWINSOCK_MAPPING) MemAlloc(WSH_MAX_MAPPING_DATA);

        if ( pMapTriples == NULL)
        {
            hr = E_OUTOFMEMORY;
            break ;
        }

        //  Expand any environment strings in the DLL path string.
        cb = ExpandEnvironmentStrings( pszDllName,
                                       tchExpandedName,
                                       MAX_PATH+1 ) ;

        if ( cb == 0 || cb > (MAX_PATH+1) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );
            break ;
        }

        // Located the mapping function
        hr = HrLoadLibAndGetProc(tchExpandedName, WSHWINSOCKMAPPING, &hDll,
                                 reinterpret_cast<FARPROC*>(&pMapFunc));
        //  Bind to the DLL
        if (FAILED(hr))
        {
            break ;
        }

        //  Call the export to return the mapping table
        cbMapping = (*pMapFunc)( pMapTriples, WSH_MAX_MAPPING_DATA ) ;
        if ( cbMapping > WSH_MAX_MAPPING_DATA )
        {
            hr = E_OUTOFMEMORY;
            break ;
        }

        // Store the mapping info into the Registry
        hr = HrRegSetBinary(hkey, c_szWinsockMapping,
                              (LPBYTE) pMapTriples, cbMapping);
    }
    while (FALSE);

    MemFree(pMapTriples);

    if (hDll)
    {
        FreeLibrary(hDll);
    }

    TraceError("HrWriteWinsockMapping",hr);
    return hr;
}

//
// Function:    HrWriteWinsockInfo
//
// Purpose:     Commit the Winsock information to the component's Winsock
//              section, and also to the Winsock section.
//
// Parameters:  strTransport - Name of the transport to be installed
//              strDllHelper - Name of the Winsock helper dll
//              dwMaxSockAddrLength - ?
//              dwMinSockAddrLength - ?
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrWriteWinsockInfo (
    tstring& strTransport,
    tstring& strDllHelper,
    DWORD dwMaxSockAddrLength,
    DWORD dwMinSockAddrLength)
{
    DWORD      dwDisposition;
    HKEY       hkey;
    HRESULT    hr;
    int        i;
    WRITEREGDW regdata[2];
    tstring    strBuf;

    // Create/Open the component's Winsock Key
    // Verify we don't need an intermediate step to create the key
    strBuf = c_szServices;
    strBuf += c_szBackslash;
    strBuf += strTransport;
    strBuf += c_szBackslash;
    strBuf += c_szParameters;
    strBuf += c_szBackslash;
    strBuf += c_szWinsockName;
    hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE, strBuf.c_str(),
                            REG_OPTION_NON_VOLATILE,
                            KEY_READ_WRITE, NULL, &hkey, &dwDisposition);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Initialize the information to write
    hr = HrRegSetValueEx(hkey, c_szHelperDllName, REG_EXPAND_SZ,
                           (LPBYTE)(LPBYTE)strDllHelper.c_str(),
                           strDllHelper.length() * sizeof(WCHAR));
    if (S_OK != hr)
    {
        goto Done;
    }

    // Initialize the information to write
    regdata[0].pszVal  = c_szMaxSockAddrLength;
    regdata[0].dwData = dwMaxSockAddrLength;
    regdata[1].pszVal  = c_szMinSockAddrLength;
    regdata[1].dwData = dwMinSockAddrLength;

    // Write the data to the components Winsock subkey
    for (i=0; i<celems(regdata); i++)
    {
        hr = HrRegSetDword(hkey, regdata[i].pszVal, regdata[i].dwData);
        if (S_OK != hr)
        {
            goto Done;
        }
    }


    // Write the Winsock DLL Mapping information
    hr = HrWriteWinsockMapping(strDllHelper.c_str(), hkey);
    if (S_OK != hr)
    {
        goto Done;
    }

    // Update the Winsock transport list
    hr = HrUpdateWinsockTransportList(strTransport.c_str(), TRUE);

Done:
    RegSafeCloseKey(hkey);
    TraceError("HrWriteWinsockInfo",hr);
    return hr;
}

//
// Function:    HrInstallWinsockDependancy
//
// Purpose:     Examine the current components .inf file and determine whether
//              or not a winsock dependancy exists.  If the current component
//              requires interaction with Winsock, this code will first verify
//              if Winsock is already installed.  If it is not, then both the
//              Winsock and afd services will be installed via a call to the
//              function FInstallWinsock.  Once that is accomplished, the code
//              will update Winsock to be aware of this component and will
//              write Winsock specific info to this components Services
//              registry section via the function FWriteWinsockInfo.  If the
//              current component does not have a Winsock dependancy no action
//              is taken.
//
// Parameters:  hinfInstallFile [IN] - Handle to the current component's
//                                     .inf file.
//              szSectionName   [IN] - The name of the install/remove section
//
// Returns:     HRESULT, S_OK if the component had a Winsock dependancy and
//              the registry was updated successfully with the information.
//
HRESULT
HrInstallWinsockDependancy (
    HINF hinfInstallFile,
    PCWSTR pszSectionName)
{
    DWORD       dwMaxSockAddrLength;
    DWORD       dwMinSockAddrLength;
    DWORD       dwSupportedNameSpace;
    DWORD       dwVersion = 1;
    tstring     strDllHelper;
    tstring     strTransport;
    tstring     strLibraryPath;
    tstring     strDisplayString;
    tstring     strProviderId;
    BOOL        fSuccess = FALSE;
    BOOL        fWinsockInstalled;
    BOOL        fWinsockInfoComplete = FALSE;
    BOOL        fNamespaceInfoComplete = FALSE;
    HRESULT     hr = HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND );

    // Search for the "TransportService" property.
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szTransportService, &strTransport);
    if (S_OK == hr)
    {
        // Retrieve the path to the helper DLL
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                     c_szHelperDllName, &strDllHelper);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the MaxSockAddrLength
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                                c_szMaxSockAddrLength, &dwMaxSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the MinSockAddrLength
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                              c_szMinSockAddrLength, &dwMinSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }

        fWinsockInfoComplete = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Retrieve the Provider ID, if not present then don't registry a
    // namespace provider
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szProviderId, &strProviderId);
    if (S_OK == hr)
    {
        // Retrieve the path to Library
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                 c_szLibraryName, &strLibraryPath);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the transport providers display string
        hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                                 c_szDisplayString, &strDisplayString);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve the ID of the supported namespace
        hr = HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                              c_szSupportedNameSpace, &dwSupportedNameSpace);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Retrieve Version (optional, defaults to 1)
        (VOID)HrSetupGetFirstDword(hinfInstallFile, pszSectionName,
                                c_szVersion, &dwVersion);

        fNamespaceInfoComplete = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Check for Winsock installation (if required)
    if (fWinsockInfoComplete || fNamespaceInfoComplete)
    {
        // Check if winsock is installed
        hr = HrIsWinsockInstalled(&fWinsockInstalled);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Is Winsock already installed?  If not, install
        // the bloke...
        if (!fWinsockInstalled)
        {
            hr = HrInstallWinsock();
            if (FAILED(hr))
            {
                goto Error;
            }
        }
    }

    // Write the data we've collect to the correct
    // spots in the registry
    if (fWinsockInfoComplete)
    {
        hr = HrWriteWinsockInfo(strTransport, strDllHelper,
                                dwMaxSockAddrLength, dwMinSockAddrLength);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    // Write the namespace provider information if we read the namespace
    // provider information
    if (fNamespaceInfoComplete)
    {
        IID guid;

        hr = IIDFromString((PWSTR)strProviderId.c_str(), &guid);
        if (FAILED(hr))
        {
            goto Error;
        }

        hr = HrAddNameSpaceProvider(strDisplayString.c_str(),
                                      strLibraryPath.c_str(),
                                      dwSupportedNameSpace,
                                      dwVersion,
                                      &guid);
        if (FAILED(hr))
        {
            goto Error;
        }
    }

    if (fWinsockInfoComplete || fNamespaceInfoComplete)
    {
        (void)HrRunWinsock2Migration();
    }

Error:
    TraceError("HrInstallWinsockDependancy",hr);
    return hr;
}

//
// Function:    HrRemoveWinsockDependancy
//
// Purpose:     Remove the current component from the Winsock
//              transport list, if present.
//
// Parameters:  hinfInstallFile [IN] - Handle to the current component's
//                                     .inf file.
//              pszSectionName   [IN] - The name of the install/remove section
//
// Returns:     HRESULT, S_OK on success
//
HRESULT HrRemoveWinsockDependancy(HINF hinfInstallFile,
                                  PCWSTR pszSectionName)
{
    HRESULT     hr;
    tstring     str;
    tstring     strTransport;
    BOOL        fRunWinsockMigration = FALSE;

    // Search for the "TransportService" property
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szTransportService, &strTransport);
    if (S_OK == hr)
    {
        HKEY        hkey;

        // Remove the Transport from the Winsock transport list
        hr = HrUpdateWinsockTransportList(strTransport.c_str(), FALSE);
        if (FAILED(hr))
        {
            goto Error;
        }

        fRunWinsockMigration = TRUE;

        // Remove the Winsock subkey under the specified transport
        // But ignore failures, as we're just trying to be tidy
        str = c_szServices;
        str += c_szBackslash;
        str += strTransport.c_str();
        str += c_szBackslash;
        str += c_szParameters;
        if (S_OK == HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, str.c_str(),
                                   KEY_READ_WRITE_DELETE, &hkey))
        {
            HrRegDeleteKeyTree(hkey, c_szWinsockName);
            RegCloseKey(hkey);
        }
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    // Remove the Winsock Namespace provider
    hr = HrSetupGetFirstString(hinfInstallFile, pszSectionName,
                             c_szProviderId, &str);
    if (S_OK == hr)
    {
        IID guid;

        hr = IIDFromString((PWSTR)str.c_str(), &guid);
        if (FAILED(hr))
        {
            goto Error;
        }

        // Don't fail, the name space may not have been successfully registered.
        // Especially if the component installation failed.
        HrRemoveNameSpaceProvider(&guid);

        fRunWinsockMigration = TRUE;
    }
    else if ((SPAPI_E_SECTION_NOT_FOUND != hr) && (SPAPI_E_LINE_NOT_FOUND != hr))
    {
        goto Error;
    }

    if (fRunWinsockMigration)
    {
        (void)HrRunWinsock2Migration();
    }

    hr = S_OK;      // Normalize return

Error:
    TraceError("HrRemoveWinsockDependancy",hr);
    return hr;
}


//
// Function:    HrAddOrRemoveWinsockDependancy
//
// Purpose:     To add or remove Winsock dependancies for components
//
// Parameters:  hinfInstallFile [IN] - The handle to the inf file to install
//                                      from
//              pszSectionName  [IN] - The Base install section name.
//                                    (The prefix for the .Services section)
//
// Returns:     HRESULT, S_OK on success
//
HRESULT
HrAddOrRemoveWinsockDependancy (
    HINF hinfInstallFile,
    PCWSTR pszSectionName)
{
    Assert(IsValidHandle(hinfInstallFile));

    HRESULT     hr;

    hr = HrProcessInfExtension(hinfInstallFile, pszSectionName,
                               c_szWinsockName, c_szAddSecLabel,
                               c_szRemoveSecLabel, HrInstallWinsockDependancy,
                               HrRemoveWinsockDependancy);

    if (SPAPI_E_LINE_NOT_FOUND == hr)
    {
        // .Winsock section is not required
        hr = S_OK;
    }

    TraceError("HrAddOrRemoveWinsockDependancy",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\obotoken.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       O B O T O K E N . H
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "compdefs.h"
#include "netcfgx.h"

BOOL
FOboTokenValidForClass (
    IN const OBO_TOKEN* pOboToken,
    IN NETCLASS Class);

HRESULT
HrProbeOboToken (
    IN const OBO_TOKEN* pOboToken);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\obotoken.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       O B O T O K E N . C P P
//
//  Contents:
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "obotoken.h"
#include "icomp.h"
#include "ncvalid.h"

BOOL
FOboTokenValidForClass (
    IN const OBO_TOKEN* pOboToken,
    IN NETCLASS Class )
{
    // OboTokens must be specified for anything other than adapters.
    //
    if (!pOboToken && !FIsEnumerated (Class))
    {
        return FALSE;
    }
    return TRUE;
}

HRESULT
HrProbeOboToken (
    IN const OBO_TOKEN* pOboToken)
{
    // Only probe if pOboToken was specified.
    //
    if (!pOboToken)
    {
        return S_OK;
    }

    HRESULT hr = S_OK;

    if (FBadInPtr (pOboToken))
    {
        hr = E_POINTER;
    }
    else
    {
        switch (pOboToken->Type)
        {
        case OBO_USER:
            hr = S_OK;
            break;

        case OBO_COMPONENT:
            hr = E_POINTER;
            if (!FBadInPtr (pOboToken->pncc))
            {
                hr = HrIsValidINetCfgComponent (pOboToken->pncc);
            }
            break;

        case OBO_SOFTWARE:
            if (FBadInPtr (pOboToken->pszwManufacturer) ||
                FBadInPtr (pOboToken->pszwProduct)      ||
                FBadInPtr (pOboToken->pszwDisplayName))
            {
                hr = E_POINTER;
            }
            else if (!*pOboToken->pszwManufacturer ||
                     !*pOboToken->pszwProduct ||
                     !*pOboToken->pszwDisplayName)
            {
                hr = E_INVALIDARG;
            }
            break;

        default:
            hr = E_INVALIDARG;
        }
    }
    TraceError ("HrProbeOboToken", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\notify.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N O T I F Y . H
//
//  Contents:   Implements the interface to a component's optional notify
//              object.  The object defined here is meant to be a member
//              of CComponent.  This object encapsulates all of its internal
//              data in a separate allocation made only if the component
//              actually has a notify object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfgn.h"
#include "netcfgx.h"
#include "ncnetcfg.h"

class CBindPath;
class CBindingSet;
class CComponent;
class CImplINetCfg;

struct NOTIFY_OBJECT_DATA
{
    INetCfgComponentControl*        pCc;
    INetCfgComponentNotifyBinding*  pNb;
    INetCfgComponentPropertyUi*     pCp;
    INetCfgComponentSetup*          pCs;
    INetCfgComponentUpperEdge*      pUe;
    INetCfgComponentNotifyGlobal*   pNg;
    DWORD                           dwNotifyGlobalFlags;
};

enum QN_FLAG
{
    QN_QUERY,
    QN_NOTIFY
};

// CComponent has a member called Notify that is of this type.
//
// pComponent = CONTAINING_RECORD(this, CComponent, Notify)
//
class CNotifyObjectInterface
{
friend class CGlobalNotifyInterface;
friend class CImplINetCfgComponent;

private:
    NOTIFY_OBJECT_DATA* m_pNod;
    BOOLEAN             m_fInitialized;

public:
    ~CNotifyObjectInterface ()
    {
        ReleaseNotifyObject (NULL, FALSE);
        AssertH (!m_pNod);
        AssertH (!m_fInitialized);
    }

    VOID
    ApplyPnpChanges (
        IN CImplINetCfg* pINetCfg,
        OUT BOOL* pfNeedReboot) const;

    VOID
    ApplyRegistryChanges (
        IN CImplINetCfg* pINetCfg,
        OUT BOOL* pfNeedReboot) const;

    HRESULT
    HrGetInterfaceIdsForAdapter (
        IN CImplINetCfg* pINetCfg,
        IN const CComponent* pAdapter,
        OUT DWORD* pcInterfaces,
        OUT GUID** ppguidInterfaceIds) const;

    HRESULT
    HrQueryPropertyUi (
        IN CImplINetCfg* pINetCfg,
        IN IUnknown* punkContext OPTIONAL);

    HRESULT
    HrShowPropertyUi (
        IN CImplINetCfg* pINetCfg,
        IN HWND hwndParent,
        IN IUnknown* punkContext OPTIONAL);

    HRESULT
    QueryNotifyObject (
        IN CImplINetCfg* pINetCfg,
        IN REFIID riid,
        OUT VOID** ppvObject);

    VOID
    ReleaseNotifyObject (
        IN CImplINetCfg* pINetCfg,
        IN BOOL fCancel);

private:
    // If not m_fInitialized, looks under component's instance key
    // for CLSID and, if found, CoCreates it and initializes m_pNod.
    //
    HRESULT
    HrEnsureNotifyObjectInitialized (
        IN CImplINetCfg* pINetCfg,
        IN BOOL fInstalling);

    VOID
    SetUiContext (
        IN CImplINetCfg* pINetCfg,
        IN IUnknown* punkContext);

    VOID
    NbQueryOrNotifyBindingPath (
        IN CImplINetCfg* pINetCfg,
        IN QN_FLAG Flag,
        IN DWORD dwChangeFlag,
        IN INetCfgBindingPath* pIPath,
        OUT BOOL* pfDisabled);

    HRESULT
    NewlyAdded (
        IN CImplINetCfg* pINetCfg,
        IN const NETWORK_INSTALL_PARAMS* pnip);

    VOID
    Removed (
        IN CImplINetCfg* pINetCfg);

    VOID
    Updated (
        IN CImplINetCfg* pINetCfg,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);
};


// CNetCfg has a member called GlobalNotify that is of this type.
//
// pConfig = CONTAINING_RECORD(this, CNetConfig, GlobalNotify)
//
class CGlobalNotifyInterface
{
friend class CNotifyObjectInterface;
friend class CNetCfgInternalDiagnostic;

private:
    // TRUE if all notify objects have been loaded and QI'd for
    // INetCfgComponentNotifyGlobal.
    //
    BOOL            m_fInitialized;

    // A pointer to INetCfg is needed because we hand this to notify objects.
    //
    CImplINetCfg*   m_pINetCfg;

private:
    // INetCfgComponentNotifyGlobal
    //
    // (each method calls HrEnsureNotifyObjectsInitialized and then
    // for each component in CNetCfg that has non-NULL Notify.m_pNod,
    // calls through Notify.m_pNod->pNg)
    //
    VOID
    NgSysQueryOrNotifyBindingPath (
        IN QN_FLAG Flag,
        IN DWORD dwChangeFlag,
        IN INetCfgBindingPath* pIPath,
        IN BOOL* pfDisabled);

    // Called when a component is added, removed, updated, or has its
    // properties changed.
    //
    HRESULT
    NgSysNotifyComponent (
        IN DWORD dwChangeFlag,
        IN CComponent* pComponent);

    HRESULT
    QueryAndNotifyBindPaths (
        IN DWORD dwBaseChangeFlag,
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths);

public:
    ~CGlobalNotifyInterface ()
    {
        ReleaseINetCfg ();
        AssertH (!m_pINetCfg);
    }

    VOID
    HoldINetCfg (
        CImplINetCfg* pINetCfg);

    VOID
    ReleaseINetCfg ();

    CImplINetCfg*
    PINetCfg ()
    {
        AssertH (m_pINetCfg);
        return m_pINetCfg;
    }

    // If not m_fInitialized, calls into CNetConfig to load every component's
    // notify object.
    //
    HRESULT
    HrEnsureNotifyObjectsInitialized ();

    HRESULT
    ComponentAdded (
        IN CComponent* pComponent,
        IN const NETWORK_INSTALL_PARAMS* pnip);

    HRESULT
    ComponentRemoved (
        IN CComponent* pComponent);

    HRESULT
    ComponentUpdated (
        IN CComponent* pComponent,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);

    HRESULT
    NotifyRemovedBindPaths (
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths)
    {
        return QueryAndNotifyBindPaths (NCN_REMOVE, pBindSet, cSkipFirstBindPaths);
    }

    HRESULT
    QueryAndNotifyForAddedBindPaths (
        IN CBindingSet* pBindSet,
        IN UINT cSkipFirstBindPaths)
    {
        return QueryAndNotifyBindPaths (NCN_ADD, pBindSet, cSkipFirstBindPaths);
    }

    VOID
    NotifyBindPath (
        IN DWORD dwChangeFlag,
        IN CBindPath* pBindPath,
        IN INetCfgBindingPath* pIPath);

    VOID
    ReleaseAllNotifyObjects (
        IN CComponentList& Components,
        IN BOOL fCancel);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\netcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N E T C F G . C P P
//
//  Contents:   The main set of routines for dealing with the network
//              binding engine.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"
#include "inetcfg.h"
#include "persist.h"
#include "netcfg.h"
#include "util.h"

// Called after a component has been removed.  In case this component
// is still listed in any other component's references, we remove those
// references.  This can happen if a notify object installs something
// on behalf of its component, but forgets to remove it.
//
VOID
CNetConfigCore::EnsureComponentNotReferencedByOthers (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);

    CComponentList::iterator iter;
    CComponent* pScan;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan->Refs.FIsReferencedByComponent (pComponent))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   %S is still referenced by %S.  "
                "Removing the refernce.\n",
                pScan->PszGetPnpIdOrInfId(),
                pComponent->PszGetPnpIdOrInfId());

            pScan->Refs.RemoveReferenceByComponent (pComponent);
        }
    }
}

HRESULT
CNetConfigCore::HrCopyCore (
    IN const CNetConfigCore* pSourceCore)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    hr = Components.HrCopyComponentList (&pSourceCore->Components);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = StackTable.HrCopyStackTable (&pSourceCore->StackTable);
    if (S_OK != hr)
    {
        goto finished;
    }

    hr = DisabledBindings.HrCopyBindingSet (&pSourceCore->DisabledBindings);
    if (S_OK != hr)
    {
        goto finished;
    }

finished:
    if (S_OK != hr)
    {
        Clear ();
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CNetConfigCore::HrCopyCore");
    return hr;
}

VOID
CNetConfigCore::Clear ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (this);

    DisabledBindings.Clear();
    StackTable.Clear();
    Components.Clear();
}

VOID
CNetConfigCore::Free ()
{
    TraceFileFunc(ttidNetcfgBase);

    Assert (this);

    FreeCollectionAndItem (Components);
}

BOOL
CNetConfigCore::FIsEmpty () const
{
    TraceFileFunc(ttidNetcfgBase);

    return Components.FIsEmpty () &&
           StackTable.FIsEmpty () &&
           DisabledBindings.FIsEmpty ();
}

BOOL
CNetConfigCore::FContainsFilterComponent () const
{
    TraceFileFunc(ttidNetcfgBase);

    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pComponent->FIsFilter())
        {
            return TRUE;
        }
    }
    return FALSE;
}

BOOL
CNetConfigCore::FIsBindPathDisabled (
    IN const CBindPath* pBindPath,
    IN DWORD dwFlags /* IBD_FLAGS */) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pScan;

    Assert (this);
    Assert (pBindPath);
    Assert ((dwFlags & IBD_EXACT_MATCH_ONLY) ||
            (dwFlags & IBD_MATCH_SUBPATHS_TOO));

    DbgVerifyBindingSet (&DisabledBindings);

    // The bindpath is disabled if it matches one of the bindpaths in
    // the disabled set or if one of the bindpaths in the disabled set
    // is a subpath of it.
    //
    // IBD_EXACT_MATCH_ONLY is used when writing bindings to the registry.
    //   We only neglect writing a disabled binding for the components
    //   which directly have the disabled binding.  i.e. if
    //   netbt>-tcpip->adapter is disabled, we only negect to write the
    //   binding for netbt.  We still write binding for components above
    //   netbt (server, client) as if they were bound.  We do this because
    //   1) it doesn't matter that the upper components have these written
    //   2) it means we don't have to involve these upper components in
    //      PnP notifications when then binding is enabled/disabled.
    //
    // IBD_MATCH_SUBPATHS_TOO is used when reporting bindpaths as enabled
    //   or disabled through the INetCfg interface.  To clients, a binding
    //   is disabled if any of its subpaths are disabled.  It has to be
    //   because there is no way that connectivity along the entire path
    //   will happen if any of the subpaths are cut-off (disabled).
    //
    for (pScan  = DisabledBindings.begin();
         pScan != DisabledBindings.end();
         pScan++)
    {
        if (pScan->FIsSameBindPathAs (pBindPath))
        {
            return TRUE;
        }

        if (dwFlags & IBD_MATCH_SUBPATHS_TOO)
        {
            if (pScan->FIsSubPathOf (pBindPath))
            {
                return TRUE;
            }
        }
    }
    return FALSE;
}

// An alternate way to check if a bindpath is disabled when you have
// just the two components in question and you know that they are expected
// to be bound to one another.  Using this method as opposed to
// FIsBindPathDisabled is better when you don't have the binpath allocated
// and don't want to allocate one just to check it.  Thus, this method
// allocates no memory and doesn't need to check subpaths because a bindpath
// of length 2 can have no subpaths.  This method is used primarily when
// seeing if a filter is bound to an adapter.
//
BOOL
CNetConfigCore::FIsLength2BindPathDisabled (
    IN const CComponent* pUpper,
    IN const CComponent* pLower) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pScan;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    DbgVerifyBindingSet (&DisabledBindings);

    for (pScan  = DisabledBindings.begin();
         pScan != DisabledBindings.end();
         pScan++)
    {
        if (pScan->CountComponents() != 2)
        {
            continue;
        }

        if ((pScan->POwner() == pUpper) &&
            (pScan->PLastComponent() == pLower))
        {
            return TRUE;
        }
    }
    return FALSE;
}

HRESULT
CNetConfigCore::HrDisableBindPath (
    IN const CBindPath* pBindPath)
{
    TraceFileFunc(ttidNetcfgBase);

    HRESULT hr;

    Assert (this);
    Assert (pBindPath);

    hr = DisabledBindings.HrAddBindPath (
            pBindPath, INS_IGNORE_IF_DUP | INS_APPEND);

    DbgVerifyBindingSet (&DisabledBindings);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrDisableBindPath");
    return hr;
}

HRESULT
CNetConfigCore::HrGetComponentBindings (
    IN const CComponent* pComponent,
    IN DWORD dwFlags /* GB_FLAGS */,
    OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    GBCONTEXT Ctx;

    Assert (pComponent);
    Assert (pBindSet);

    DbgVerifyData();

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
    }

    // Initialize the members of our context structure for recursion.
    // We set the append bindpath flags to assert if a duplicate is inserted
    // because we know that GetBindingsBelowComponent will not insert
    // duplicates under normal conditions.
    //
    ZeroMemory (&Ctx, sizeof(Ctx));
    Ctx.pCore                   = this;
    Ctx.pBindSet                = pBindSet;
    Ctx.pSourceComponent        = pComponent;
    Ctx.fPruneDisabledBindings  = (dwFlags & GBF_PRUNE_DISABLED_BINDINGS);
    Ctx.dwAddBindPathFlags      = (dwFlags & GBF_ADD_TO_BINDSET)
                                        ? INS_IGNORE_IF_DUP
                                        : INS_ASSERT_IF_DUP;

    GetBindingsBelowComponent (pComponent, &Ctx);

    // Verify the bindset we are about to return is valid.
    // (Checked builds only.)
    //
    if (S_OK == Ctx.hr)
    {
        DbgVerifyBindingSet (pBindSet);
    }

    TraceHr (ttidError, FAL, Ctx.hr, FALSE,
        "CNetConfigCore::HrGetComponentBindings");
    return Ctx.hr;
}

HRESULT
CNetConfigCore::HrGetComponentUpperBindings (
    IN const CComponent* pComponent,
    IN DWORD dwFlags,
    OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr = S_OK;
    CBindPath BindPath;
    const CStackEntry* pScan;
    DWORD dwAddBindPathFlags;

    Assert (pComponent);
    Assert (FIsEnumerated(pComponent->Class()));
    Assert ((GBF_DEFAULT == dwFlags) ||
            (dwFlags & GBF_ADD_TO_BINDSET) ||
            (dwFlags & GBF_PRUNE_DISABLED_BINDINGS));
    Assert (pBindSet);

    DbgVerifyData();

    dwAddBindPathFlags = INS_APPEND | INS_IGNORE_IF_DUP;

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
        dwAddBindPathFlags = INS_APPEND | INS_ASSERT_IF_DUP;
    }

    hr = BindPath.HrReserveRoomForComponents (2);

    if (S_OK == hr)
    {
        // This won't fail because we've reserved enough room above.
        //
        hr = BindPath.HrInsertComponent (pComponent);
        Assert (S_OK == hr);
        Assert (1 == BindPath.CountComponents());

        // For all rows in the stack table where the lower component
        // is the one passed in...
        //
        for (pScan  = StackTable.begin();
             pScan != StackTable.end();
             pScan++)
        {
            if (pComponent != pScan->pLower)
            {
                continue;
            }

            // Continue if this length-2 bindpath is disabled.
            //
            if (dwFlags & GBF_PRUNE_DISABLED_BINDINGS)
            {
                if (FIsLength2BindPathDisabled (pScan->pUpper, pScan->pLower))
                {
                    continue;
                }
            }

            // This won't fail because we've reserved enough room above.
            //
            hr = BindPath.HrInsertComponent (pScan->pUpper);
            Assert (S_OK == hr);

            Assert (2 == BindPath.CountComponents());
            hr = pBindSet->HrAddBindPath (&BindPath, dwAddBindPathFlags);
            if (S_OK != hr)
            {
                break;
            }

            BindPath.RemoveFirstComponent();
        }

        // Verify the bindset we are about to return is valid.
        // (Checked builds only.)
        //
        DbgVerifyBindingSet (pBindSet);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrGetComponentUpperBindings");
    return hr;
}

HRESULT
CNetConfigCore::HrGetBindingsInvolvingComponent (
    IN const CComponent* pComponent,
    IN DWORD dwFlags,
    IN OUT CBindingSet* pBindSet)
{
    TraceFileFunc(ttidNetcfgBase);
    GCCONTEXT Ctx;
    CComponentList ComponentsAbove;
    UINT cExistingBindPaths;

    Assert (pComponent);
    Assert ((GBF_DEFAULT == dwFlags) ||
            (dwFlags & GBF_ADD_TO_BINDSET) ||
            (dwFlags & GBF_PRUNE_DISABLED_BINDINGS) ||
            (dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT));
    Assert (pBindSet);
    DbgVerifyData();

    // Initialize the output parameter.
    //
    if (!(dwFlags & GBF_ADD_TO_BINDSET))
    {
        pBindSet->Clear();
    }

    // Since we may be adding to the bindset, be sure to exclude the existing
    // bindpaths from our scans below.
    //
    cExistingBindPaths = pBindSet->CountBindPaths();

    // Initialize the members of our context structure for recursion.
    //
    ZeroMemory (&Ctx, sizeof(Ctx));
    Ctx.pStackTable = &StackTable;
    Ctx.pComponents = &ComponentsAbove;
    Ctx.fIgnoreDontExposeLower = TRUE;

    GetComponentsAboveComponent (pComponent, &Ctx);

    if (S_OK == Ctx.hr)
    {
        // First get the bindings below the component.
        //
        Ctx.hr = HrGetComponentBindings (
                    pComponent,
                    dwFlags | GBF_ADD_TO_BINDSET,
                    pBindSet);

        if (S_OK == Ctx.hr)
        {
            CComponentList::const_iterator iter;
            const CComponent* pComponentAbove;

            // Now get the bindings below each of the components
            // above the component and add them to the bindset.
            //
            for (iter  = ComponentsAbove.begin();
                 iter != ComponentsAbove.end();
                 iter++)
            {
                pComponentAbove = *iter;
                Assert (pComponentAbove);

                Ctx.hr = HrGetComponentBindings (
                            pComponentAbove,
                            dwFlags | GBF_ADD_TO_BINDSET,
                            pBindSet);

                if (S_OK != Ctx.hr)
                {
                    break;
                }

                // Verify the bindset we are about to return is valid.
                // (Checked builds only.)
                //
                DbgVerifyBindingSet (pBindSet);
            }
        }

        // Now remove any bindings that don't involve the component.
        // If the component is enumerated, leave bindings that end in
        // NCF_DONTEXPOSELOWER components, because they are indirectly
        // involved in the bindings associated with the adapter.
        //
        if (S_OK == Ctx.hr)
        {
            CBindPath* pScan;
            BOOL fIsEnumerated;

            fIsEnumerated = FIsEnumerated(pComponent->Class());

            if (fIsEnumerated || !(dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT))
            {
                // fDelBoundToComponent means "is there a NCF_DONTEXPOSELOWER
                // component bound to pComponent".  If there is not, we will
                // be setting GBF_ONLY_WHICH_CONTAIN_COMPONENT to force the
                // removal of any NCF_DONTEXPOSELOWER components from
                // the bind set below.
                //
                BOOL fDelBoundToComponent = FALSE;

                for (pScan  = pBindSet->PGetBindPathAtIndex (cExistingBindPaths);
                     pScan != pBindSet->end();
                     pScan++)
                {
                    if ((pScan->PLastComponent() == pComponent) &&
                        (pScan->POwner()->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        fDelBoundToComponent = TRUE;
                        break;
                    }
                }

                if (!fDelBoundToComponent)
                {
                    dwFlags |= GBF_ONLY_WHICH_CONTAIN_COMPONENT;
                }
            }

            pScan = pBindSet->PGetBindPathAtIndex (cExistingBindPaths);
            while (pScan != pBindSet->end())
            {
                if (pScan->FContainsComponent (pComponent))
                {
                    pScan++;
                    continue;
                }

                // At this point, we know that the bindpath does not
                // contain pComponent.  See if we should erase it or keep it.
                //

                // If the component is not an adpater or if the caller wants
                // only bindpaths which contain the adapter, erase it.
                //
                if (!fIsEnumerated ||
                    (dwFlags & GBF_ONLY_WHICH_CONTAIN_COMPONENT))
                {
                    pBindSet->erase (pScan);
                    continue;
                }

                // Otherwise, (pComponent is an adpater and the caller wants
                // indirect bindings involved with that adpater) we'll
                // erase the bindpath only if the last component is not an
                // NCF_DONTEXPOSELOWER component.  We need to keep these
                // bindpaths so that the LAN UI (which shows components
                // involved in bindpaths that involve an adapter) can
                // display these NCF_DONTEXPOSELOWER components too.
                //
                else
                {
                    CComponent* pLast = pScan->PLastComponent();

                    if (!(pLast->m_dwCharacter & NCF_DONTEXPOSELOWER))
                    {
                        pBindSet->erase (pScan);
                        continue;
                    }
                }

                pScan++;
            }
        }
    }

    TraceHr (ttidError, FAL, Ctx.hr, FALSE,
        "CNetConfigCore::HrGetBindingsInvolvingComponent");
    return Ctx.hr;
}

HRESULT
CNetConfigCore::HrGetFiltersEnabledForAdapter (
    IN const CComponent* pAdapter,
    OUT CComponentList* pFilters)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;
    const CStackEntry* pScan;

    Assert (this);
    Assert (pAdapter);
    Assert (FIsEnumerated(pAdapter->Class()));
    Assert (pFilters);

    // Initialize the output parameter.
    //
    pFilters->Clear();

    // Scan the stack table looking for lower component matches to pAdapter.
    // When found, and if the upper component is a filter, and if the
    // direct bindpath is not disabled, add the filter to the output list.
    //
    for (pScan = StackTable.begin(); pScan != StackTable.end(); pScan++)
    {
        // Looking for lower component matches to the adapter where
        // the upper component is a filter.  Ignore all others.
        //
        if ((pScan->pLower != pAdapter) || !pScan->pUpper->FIsFilter())
        {
            continue;
        }

        Assert (pScan->pUpper->FIsFilter());
        Assert (pScan->pLower == pAdapter);

        // If the bindpath is not disabled, add the filter to the list.
        //
        if (!FIsLength2BindPathDisabled (pScan->pUpper, pScan->pLower))
        {
            // Assert if a duplicate because the same filter can't be bound
            // to the same adapter more than once.
            // No need to sort when we insert because the class of all of
            // the components in this list will be the same.
            //
            hr = pFilters->HrInsertComponent (pScan->pUpper,
                    INS_ASSERT_IF_DUP | INS_NON_SORTED);

            if (S_OK != hr)
            {
                return hr;
            }
        }
    }

    return S_OK;
}

// (Takes ownership of pComponent)
//
HRESULT
CNetConfigCore::HrAddComponentToCore (
    IN CComponent* pComponent,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;

    Assert (pComponent);
    Assert ((INS_SORTED == dwFlags) || (INS_NON_SORTED == dwFlags));

    DbgVerifyExternalDataLoadedForAllComponents ();
    pComponent->Ext.DbgVerifyExternalDataLoaded ();

    // Make sure we are not trying to insert a component with a PnpId that
    // is the same as one already in the core.  Note that we do not perform
    // this check inside of CComponentList::HrInsertComponent because it is
    // not appropriate for all component lists.  Specifically, the dirty
    // component list may end up having two different components with the
    // same PnpId for the case when we are asked to install an adapter that
    // is pending removal.  In this case the new adapter will get the same
    // PnpId as the one that was removed.  We'll remove the old one from
    // core to insert the new one so the dirty component list will have
    // both components with the same PnpId.
    //
    if (FIsEnumerated(pComponent->Class()) &&
        Components.PFindComponentByPnpId (pComponent->m_pszPnpId))
    {
        AssertSz (FALSE, "Asked to add a component with a duplicate PnpId!");
        return E_INVALIDARG;
    }

    // Insert the component into the list.  This should only fail if we
    // are out of memory.
    //
    hr = Components.HrInsertComponent (
            pComponent, dwFlags | INS_ASSERT_IF_DUP);

    if (S_OK == hr)
    {
        // Insert the appropriate stack entries for pComponent based on
        // how it binds with the other components.
        //
        hr = StackTable.HrInsertStackEntriesForComponent (
                pComponent, &Components, dwFlags);

        // If we failed to insert the stack entries, undo the insertion
        // into the component list.
        //
        if (S_OK != hr)
        {
            Components.RemoveComponent (pComponent);
        }
    }

    // Error or not, we should still have a valid core.
    //
    DbgVerifyData();

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNetConfigCore::HrAddComponentToCore");
    return hr;
}

VOID
CNetConfigCore::RemoveComponentFromCore (
    IN const CComponent* pComponent)
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (this);
    Assert (pComponent);

    Components.RemoveComponent (pComponent);
    StackTable.RemoveEntriesWithComponent (pComponent);
    DisabledBindings.RemoveBindPathsWithComponent (pComponent);

#if DBG
    // We set m_fRemovedAComponent so that when subsequent
    // DbgVerifyBindingSet calls are made, we don't assert on components
    // that are in the binding set but not in the core.  This is a natural
    // occurance for the m_DeletedBindings we build up during removal of
    // components.
    //
    m_fRemovedAComponent = TRUE;

    // Note: need to find a convenient time during Apply where
    // we set this flag back to FALSE.
#endif
}


// static
HRESULT
CNetConfig::HrCreateInstance (
    IN class CImplINetCfg* pINetCfg,
    OUT CNetConfig** ppNetConfig)
{
    TraceFileFunc(ttidNetcfgBase);
    Assert (pINetCfg);

    HRESULT hr = E_OUTOFMEMORY;

    CNetConfig* pObj;
    pObj = new CNetConfig;
    if (pObj)
    {
        // Load the configuration binary.  If we have have the write lock,
        // request write access, otherwise, request read access.
        // Requesting write access means this will only succeed if the
        // volatile key indicating we need a reboot does not exist.
        //
        hr = HrLoadNetworkConfigurationFromRegistry (
                (pINetCfg->m_WriteLock.FIsOwnedByMe ())
                    ? KEY_WRITE : KEY_READ,
                pObj);

        if (S_OK == hr)
        {
            pObj->Core.DbgVerifyData();
            pObj->Notify.HoldINetCfg (pINetCfg);
            *ppNetConfig = pObj;
        }
        else
        {
            delete pObj;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CNetConfig::HrCreateInstance");
    return hr;
}

CNetConfig::~CNetConfig ()
{
    TraceFileFunc(ttidNetcfgBase);
    Core.Free ();
}

HRESULT
CNetConfig::HrEnsureExternalDataLoadedForAllComponents ()
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;
    HRESULT hrRet;
    CComponentList::iterator iter;
    CComponent* pComponent;

    hrRet = S_OK;

    // This is a while loop instead of a for loop because of the
    // potential for conditional advancement of the iterator.  If we
    // remove a component from the core while looping, we don't increment
    // the iterator for the next iteration.
    //
    iter = Core.Components.begin();
    while (iter != Core.Components.end())
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponent->Ext.HrEnsureExternalDataLoaded ();

        if ((SPAPI_E_NO_SUCH_DEVINST == hr) ||
            (SPAPI_E_KEY_DOES_NOT_EXIST == hr))
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "Removing %s from the core because its external data is missing\n",
                pComponent->PszGetPnpIdOrInfId());

            Core.RemoveComponentFromCore (pComponent);
            delete pComponent;
            hr = S_OK;

            // Because we removed this component from the core, the
            // list has been adjusted and the next component is now this
            // iter.  Therefore, just continue without incrementing iter.
            //
            continue;
        }

        // Remember the first error as our return code, but keep going.
        // Like the name says, we are to load data for all components so
        // don't stop just because one fails.
        //
        if ((S_OK != hr) && (S_OK == hrRet))
        {
            hrRet = hr;
        }

        iter++;
    }

    TraceHr (ttidError, FAL, hrRet, FALSE,
        "CNetConfig::HrEnsureExternalDataLoadedForAllComponents");
    return hrRet;
}


#if DBG

VOID
CNetConfigCore::DbgVerifyData () const
{
    TraceFileFunc(ttidNetcfgBase);
    HRESULT hr;

    CComponentList::const_iterator iter;
    const CComponent* pComponent;
    const CStackEntry*  pStackEntry;
    const CComponent* pUpper;
    const CComponent* pLower;
    CHAR szBuffer [512];

    for (pStackEntry  = StackTable.begin();
         pStackEntry != StackTable.end();
         pStackEntry++)
    {
        pUpper = pStackEntry->pUpper;
        pLower = pStackEntry->pLower;

        Assert (pUpper);
        Assert (pLower);
        Assert (pUpper != pLower);

        // Can't access upper and lower range if the external data isn't
        // loaded.
        //
        if (pUpper->Ext.DbgIsExternalDataLoaded() &&
            pLower->Ext.DbgIsExternalDataLoaded())
        {
            if (!pUpper->FCanDirectlyBindTo (pLower, NULL, NULL))
            {
                wsprintfA (szBuffer, "%S should not bind to %S.  They are in the "
                    "stack table as if they do.  (Likely upgrade problem.)",
                    pUpper->PszGetPnpIdOrInfId(),
                    pLower->PszGetPnpIdOrInfId());
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (!FIsEnumerated (pUpper->Class()))
        {
            if (pUpper != Components.PFindComponentByInfId (
                                        pUpper->m_pszInfId, NULL))
            {
                wsprintfA (szBuffer, "%S is an upper component in the stack "
                    "table, but was not found in the component list.",
                    pUpper->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }
        else
        {
            if (pUpper != Components.PFindComponentByPnpId (
                                        pUpper->m_pszPnpId))
            {
                wsprintfA (szBuffer, "%S is an upper component in the stack "
                    "table, but was not found in the component list.",
                    pUpper->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (!FIsEnumerated (pLower->Class()))
        {
            if (pLower != Components.PFindComponentByInfId (
                                        pLower->m_pszInfId, NULL))
            {
                wsprintfA (szBuffer, "%S is a lower component in the stack "
                    "table, but was not found in the component list.",
                    pLower->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }
        else
        {
            if (pLower != Components.PFindComponentByPnpId (
                                        pLower->m_pszPnpId))
            {
                wsprintfA (szBuffer, "%S is a lower component in the stack "
                    "table, but was not found in the component list.",
                    pLower->m_pszInfId);
                AssertSzFn (szBuffer, FAL);
            }
        }

        if (pUpper != Components.PFindComponentByInstanceGuid (&pUpper->m_InstanceGuid))
        {
            wsprintfA (szBuffer, "%S is an upper component in the stack "
                "table, but was not found in the component list by GUID.",
                pUpper->PszGetPnpIdOrInfId());
            AssertSzFn (szBuffer, FAL);
        }

        if (pLower != Components.PFindComponentByInstanceGuid (&pLower->m_InstanceGuid))
        {
            wsprintfA (szBuffer, "%S is a lower component in the stack "
                "table, but was not found in the component list by GUID.",
                pLower->PszGetPnpIdOrInfId());
            AssertSzFn (szBuffer, FAL);
        }
    }
}

VOID
CNetConfigCore::DbgVerifyExternalDataLoadedForAllComponents () const
{
    TraceFileFunc(ttidNetcfgBase);
    CComponentList::const_iterator iter;
    const CComponent* pComponent;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Ext.DbgVerifyExternalDataLoaded();
    }
}

VOID
CNetConfigCore::DbgVerifyBindingSet (
    const CBindingSet* pBindSet) const
{
    TraceFileFunc(ttidNetcfgBase);
    const CBindPath* pPath;
    const CBindPath* pOtherPath;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;

    Assert (pBindSet);

    // First make sure every component in the set is in our component
    // list.  We only do this if we're not in the state where a component
    // has been removed from the core.  For this case, its okay if those
    // components still exist in binding sets.
    //
    if (!m_fRemovedAComponent)
    {
        for (pPath  = pBindSet->begin();
             pPath != pBindSet->end();
             pPath++)
        {
            for (iter  = pPath->begin();
                 iter != pPath->end();
                 iter++)
            {
                pComponent = *iter;

                Assert (Components.FComponentInList (pComponent));
            }
        }
    }

    // Make sure there are no duplicate bindpaths in the set.
    //
    for (pPath  = pBindSet->begin();
         pPath != pBindSet->end();
         pPath++)
    {
        Assert (!pPath->FIsEmpty());

        for (pOtherPath  = pBindSet->begin();
             pOtherPath != pBindSet->end();
             pOtherPath++)
        {
            if (pPath == pOtherPath)
            {
                continue;
            }

            Assert (!pPath->FIsSameBindPathAs (pOtherPath));
        }
    }
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOHELP
#define NOICONS
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOSYSPARAMSINFO
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <infstr.h>
#include <regstr.h>
#include <setupapi.h>
#include <stdio.h>
#include <wchar.h>
#include <shlwapi.h>
#include <shlwapip.h>	// for SHLoadRegUIString

#include "ncmem.h"

#include "algorithm"
#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"

#ifdef ENABLELEAKDETECTION
#include "iatl.h"
template <class T>
class CComObjectRootExDbg : public CComObjectRootEx<T>, 
                            public CNetCfgDebug<T>
{
public:
    void FinalRelease()
    {
        CComObjectRootEx<T>::FinalRelease();
//      ISSUE_knownleak(this);
    }
};
#define CComObjectRootEx CComObjectRootExDbg

class CComObjectRootDbg : public CNetCfgDebug<CComObjectRootDbg>, 
                          public CComObjectRoot
{
};
#define CComObjectRoot CComObjectRootDbg

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\netcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N E T C F G . H
//
//  Contents:   Defines the overall datatype for representing the network
//              bindings engine.  This datatype, CNetConfig, is a
//              collection of components and their binding relationships
//              to each other.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "complist.h"
#include "diagctx.h"
#include "install.h"
#include "notify.h"
#include "stable.h"
#include "util.h"

// Flags for HrGetBindingsXXX.
//
enum GB_FLAGS
{
    GBF_DEFAULT                         = 0x00000000,
    GBF_ADD_TO_BINDSET                  = 0x00000001,
    GBF_PRUNE_DISABLED_BINDINGS         = 0x00000002,
    GBF_ONLY_WHICH_CONTAIN_COMPONENT    = 0x00000004,
};

// Flags for FIsBindPathDisabled.
//
enum IBD_FLAGS
{
    IBD_EXACT_MATCH_ONLY        = 0x00000001,
    IBD_MATCH_SUBPATHS_TOO      = 0x00000002,
};

class CNetConfigCore : CNetCfgDebug<CNetConfigCore>
{
public:
    CComponentList  Components;
    CStackTable     StackTable;
    CBindingSet     DisabledBindings;

#if DBG
private:
    BOOL    m_fRemovedAComponent;
#endif

public:
    VOID Clear ();
    VOID Free ();
    BOOL FIsEmpty () const;

    BOOL
    FContainsFilterComponent () const;

    BOOL
    FIsBindPathDisabled (
        IN const CBindPath* pBindPath,
        IN DWORD dwFlags /* IBD_FLAGS */) const;

    BOOL
    FIsLength2BindPathDisabled (
        IN const CComponent* pUpper,
        IN const CComponent* pLower) const;

    VOID
    EnableBindPath (
        IN const CBindPath* pBindPath)
    {
        TraceFileFunc(ttidNetCfgBind);

        DisabledBindings.RemoveBindPath (pBindPath);
        DbgVerifyBindingSet (&DisabledBindings);
    }

    VOID
    EnsureComponentNotReferencedByOthers (
        IN const CComponent* pComponent);

    HRESULT
    HrDisableBindPath (
        IN const CBindPath* pBindPath);

    HRESULT
    HrCopyCore (
        IN const CNetConfigCore* pSourceCore);

    HRESULT
    HrGetBindingsInvolvingComponent (
        IN const CComponent* pComponent,
        IN DWORD dwFlags,
        IN OUT CBindingSet* pBindSet);

    HRESULT
    HrGetComponentBindings (
        IN const CComponent* pComponent,
        IN DWORD dwFlags /* GB_FLAGS */,
        OUT CBindingSet* pBindSet);

    HRESULT
    HrGetComponentUpperBindings (
        IN const CComponent* pComponent,
        IN DWORD dwFlags,
        OUT CBindingSet* pBindSet);

    HRESULT
    HrGetFiltersEnabledForAdapter (
        IN const CComponent* pAdapter,
        OUT CComponentList* pFilters);

    HRESULT
    HrAddComponentToCore (
        IN CComponent* pComponent,
        IN DWORD dwFlags /* INS_FLAGS */);

    VOID
    RemoveComponentFromCore (
        IN const CComponent* pComponent);

#if DBG
    VOID DbgVerifyData () const;
    VOID DbgVerifyExternalDataLoadedForAllComponents () const;
    VOID DbgVerifyBindingSet (
        const CBindingSet* pBindSet) const;
#else
    VOID DbgVerifyData () const {}
    VOID DbgVerifyExternalDataLoadedForAllComponents () const {}
    VOID DbgVerifyBindingSet (
        const CBindingSet* /*pBindSet*/) const {}
#endif
};


class CNetConfig;
class CFilterDevices;


class CRegistryBindingsContext : CNetCfgDebug<CRegistryBindingsContext>
{
private:
    CNetConfig*     m_pNetConfig;
    CBindingSet     m_BindSet;
    CDynamicBuffer  m_BindValue;
    CDynamicBuffer  m_ExportValue;
    CDynamicBuffer  m_RouteValue;

public:
    HRESULT
    HrPrepare (
        IN CNetConfig* pNetConfig);

    HRESULT
    HrGetAdapterUpperBindValue (
        IN const CComponent* pAdapter);

    HRESULT
    HrWriteBindingsForComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrWriteBindingsForFilterDevices (
        IN CFilterDevices* pFilterDevices);

    HRESULT
    HrDeleteBindingsForComponent (
        IN const CComponent* pComponent);

    VOID
    PnpBindOrUnbindBindPaths (
        IN UINT unOperation,
        IN const CBindingSet* pBindSet,
        OUT BOOL* pfRebootNeeded);
};


enum IOR_ACTION
{
    IOR_INSTALL,
    IOR_REMOVE,
};

enum EBO_FLAG
{
    EBO_COMMIT_NOW = 1,
    EBO_DEFER_COMMIT_UNTIL_APPLY,
};

class CModifyContext : CNetCfgDebug<CModifyContext>
{
public:
    // This is the core data we started with before the modification began.
    // In the event the modification fails, we will revert to this data.
    // We also use this data when we apply the changes.  We compare what
    // we started with to what we have as a result of the modification and
    // the differences represent the things we need to change.
    //
    CNetConfigCore  m_CoreStartedWith;

    // These bindings are the added bindpaths (due to adding components)
    // These represent bindings that have been queried and notified to
    // notify objects.
    //
    CBindingSet     m_AddedBindPaths;

    // These bindings are the deleted bindpaths (due to removing components)
    // These represent bindings that have been notified to notify objects.
    //
    CBindingSet     m_DeletedBindPaths;

    // These components are all the components involved in m_AddedBindPaths
    // and m_DeletedBindPaths.  As such, they are the components we need
    // to visit during Apply to write bindings for, delete bindings for,
    // or finish removal of depending on whether the components exist in
    // the core we started with.  Components can get in this list if they
    // have had their bind order changed, or if they were involved in a
    // binding that has been enabled or disabled.
    //
    CComponentList  m_DirtyComponents;

    // The purpose of the binding context is just to allow us to make one
    // allocation (and use it over and over) for the buffer which holds the
    // bind strings that get written to the registry.  We make this allocation
    // up front when the modify context is prepared.  Doing so minimizes the
    // risk of getting half-way through apply and then finding out we are so
    // low on memory that we cannot allocate a buffer to write the registry
    // bindings with.
    //
    CRegistryBindingsContext    m_RegBindCtx;

    ULONG           m_ulRecursionDepth;
    HRESULT         m_hr;
    BOOLEAN         m_fPrepared;

    // Set when a notify object says they need to reboot in order for changes
    // to take affect.  Setting this will not REQUIRE us to reboot, it will
    // only cause NETCFG_S_REBOOT to be returned from the install or remove
    // operation.
    //
    BOOLEAN         m_fRebootRecommended;

    // Set when a component that is being removed fails to stop.  When it
    // does, its service will be marked as 'pending delete'.  We cannot allow
    // any other config changes to happen when we are in this state because
    // if that service ever needs to be re-installed, we will fail.
    //
    BOOLEAN         m_fRebootRequired;

#if DBG
    // This flag indicates that we've dirtied a component outside of
    // ApplyChanges.  We will do this when bind order changes, and when
    // INetCfgComponentPrivate::SetDirty or
    // INetCfgComponentPrivate::NotifyUpperEdgeConfigChange are called.
    // If this flag is TRUE, m_fDirtyComponents will not be empty upon
    // entering ApplyChanges.  Normally, when this flag is FALSE,
    // m_fDirtyComponents should be empty when entering ApplyChanges.
    // If it were not, it would probably mean we forgot to empty it after
    // the last Apply or Cancel and are now risking applying changes to
    // components which really are not dirty.
    //
    BOOLEAN         m_fComponentExplicitlyDirtied;
#endif

private:
    VOID
    PushRecursionDepth ();

    HRESULT
    HrPopRecursionDepth ();

    VOID
    ApplyChanges ();

    VOID
    InstallAndAddAndNotifyComponent (
        IN const COMPONENT_INSTALL_PARAMS& Params,
        OUT CComponent** ppComponent);

    VOID
    InstallConvenienceComponentsForUser (
        IN const CComponent* pComponent);

    VOID
    InstallOrRemoveRequiredComponents (
        IN CComponent* pComponent,
        IN IOR_ACTION Action);

    VOID
    NotifyAndRemoveComponent (
        IN CComponent* pComponent);

    HRESULT
    HrProcessWinsockRemove (
        IN const CComponent* pComponent);

public:
    CNetConfig*
    PNetConfig ();

    HRESULT
    HrBeginBatchOperation ();

    HRESULT
    HrEndBatchOperation (
        IN EBO_FLAG Flag);

    HRESULT
    HrDirtyComponent (
        IN const CComponent* pComponent);

    HRESULT
    HrDirtyComponentAndComponentsAbove (
        IN const CComponent* pComponent);

    HRESULT
    HrApplyIfOkOrCancel (
        IN BOOL fApply);

    HRESULT
    HrPrepare ();

    HRESULT
    HrEnableOrDisableBindPath (
        IN DWORD dwChangeFlag,
        IN CBindPath* pBindPath,
        IN INetCfgBindingPath* pIPath OPTIONAL);

    HRESULT
    HrInstallNewOrReferenceExistingComponent (
        IN const COMPONENT_INSTALL_PARAMS& Params,
        OUT CComponent** ppComponent);

    HRESULT
    HrRemoveComponentIfNotReferenced (
        IN CComponent* pComponent,
        IN OBO_TOKEN* pOboToken OPTIONAL,
        OUT PWSTR* ppmszwRefs OPTIONAL);

    HRESULT
    HrUpdateComponent (
        IN CComponent* pComponent,
        IN DWORD dwSetupFlags,
        IN DWORD dwUpgradeFromBuildNo);
};


class CNetConfig : CNetCfgDebug<CNetConfig>
{
public:
    // This is the core data managed by this object.  The reason it
    // is encapsulated by NETCFG_CORE is so that we can save it away before
    // we being any modify operation.  (We save it into
    // CModifyContext.m_StartedWith.)  In the event of a failure to modify
    // we restore the core data from what we started with.
    //
    CNetConfigCore          Core;

    // The interface to all notify objects representing the components.
    //
    CGlobalNotifyInterface  Notify;

    CModifyContext          ModifyCtx;

public:
    CNetConfig ()
    {
        TraceFileFunc(ttidNetcfgBase);
        ZeroMemory (this, sizeof(*this));
    }

    ~CNetConfig ();

    HRESULT
    HrEnsureExternalDataLoadedForAllComponents ();

    static HRESULT
    HrCreateInstance (
        IN class CImplINetCfg* pINetCfg,
        OUT CNetConfig** ppNetConfig);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\notify.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       N O T I F Y . C P P
//
//  Contents:   Implements the interface to a component's optional notify
//              object.  The object defined here is meant to be a member
//              of CComponent.  This object encapsulates all of its internal
//              data in a separate allocation made only if the component
//              actually has a notify object.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "diagctx.h"
#include "ibind.h"
#include "inetcfg.h"
#include "nceh.h"
#include "ncmisc.h"
#include "ncprsht.h"
#include "netcfg.h"
#include "notify.h"


//+---------------------------------------------------------------------------
// CNotifyObjectInterface -
//

HRESULT
CNotifyObjectInterface::HrEnsureNotifyObjectInitialized (
    IN CImplINetCfg* pINetCfg,
    IN BOOL fInstalling)
{
    Assert (pINetCfg);

    // If we've already been through initialization, return immediately.
    //
    if (m_fInitialized)
    {
        return S_OK;
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;

    // Get our containing component pointer so we can ask it what the
    // CLSID for the notify object is.  (If it has one.)
    //
    CComponent* pThis;
    pThis = CONTAINING_RECORD (this, CComponent, Notify);

    // Don't bother if we can't have a notify object.  Bailing here saves
    // uneccesarily loading the external data for netclass components only
    // to find that they won't have a notify object below.
    //
    if (FIsEnumerated (pThis->Class()))
    {
        return S_OK;
    }

    HRESULT hrRet;

    // Since the notify object clsid is part of the components external data,
    // we have to make sure we've loaded this data.
    //
    hrRet = pThis->Ext.HrEnsureExternalDataLoaded ();
    if (S_OK != hrRet)
    {
        goto finished;
    }

    // Don't bother if we don't have a notify object.
    //
    if (!pThis->Ext.FHasNotifyObject())
    {
        return S_OK;
    }

    // The component claims to have a notify object.  Let's CoCreate it
    // and see what we get.
    //
    HRESULT hr;
    INetCfgComponentControl* pCc;

    hr = pINetCfg->HrCoCreateWrapper (
            *(pThis->Ext.PNotifyObjectClsid()),
            NULL, CLSCTX_INPROC_SERVER | CLSCTX_NO_CODE_DOWNLOAD,
            IID_INetCfgComponentControl,
            (PVOID*)&pCc);

    if (S_OK == hr)
    {
        // So far so good.  The notify object implements the required
        // INetCfgComponentControl interface.
        //
        // We now must get the INetCfgComponent interface that we'll
        // pass to the notify object during Initialize below.
        //
        INetCfgComponent* pIComp;
        hrRet = pThis->HrGetINetCfgComponentInterface (pINetCfg, &pIComp);
        if (S_OK == hrRet)
        {
            // Allocate space for the various notify interfaces and QI for
            // them.
            //
            hrRet = E_OUTOFMEMORY;
            m_pNod = (NOTIFY_OBJECT_DATA*) MemAlloc (sizeof(NOTIFY_OBJECT_DATA));
            if (m_pNod)
            {
                hrRet = S_OK;
                ZeroMemory (m_pNod, sizeof(NOTIFY_OBJECT_DATA));

                AddRefObj (pCc);
                m_pNod->pCc = pCc;

                pCc->QueryInterface (IID_INetCfgComponentNotifyBinding,
                        (PVOID*)&m_pNod->pNb);

                pCc->QueryInterface (IID_INetCfgComponentPropertyUi,
                        (PVOID*)&m_pNod->pCp);

                pCc->QueryInterface (IID_INetCfgComponentSetup,
                        (PVOID*)&m_pNod->pCs);

                pCc->QueryInterface (IID_INetCfgComponentUpperEdge,
                        (PVOID*)&m_pNod->pUe);

                pCc->QueryInterface (IID_INetCfgComponentNotifyGlobal,
                        (PVOID*)&m_pNod->pNg);
                if (m_pNod->pNg)
                {
                    // Since it supports INetCfgComponentNotifyGlobal,
                    // get the mask that indicates which global notifications
                    // it is interested in.
                    //
                    hr = m_pNod->pNg->GetSupportedNotifications(
                            &m_pNod->dwNotifyGlobalFlags);
                    if (FAILED(hr))
                    {
                        m_pNod->dwNotifyGlobalFlags = 0;
                    }
                }

                // We now need to initialize the notify object and indicate
                // if we are installing its component or not.
                //
                pINetCfg->RaiseRpl (RPL_DISALLOW);
                    NC_TRY
                    {
                        Assert (pIComp);
                        Assert (pINetCfg);
                        (VOID) pCc->Initialize (pIComp, pINetCfg, fInstalling);
                    }
                    NC_CATCH_ALL
                    {
                        ;   // ignored
                    }
                pINetCfg->LowerRpl (RPL_DISALLOW);
            }

            ReleaseObj (pIComp);
        }

        ReleaseObj (pCc);
    }

finished:
    TraceHr (ttidError, FAL, hrRet, FALSE,
        "CNotifyObjectInterface::HrEnsureNotifyObjectInitialized");
    return hrRet;
}

VOID
CNotifyObjectInterface::ApplyPnpChanges (
    IN CImplINetCfg* pINetCfg,
    OUT BOOL* pfNeedReboot) const
{
    HRESULT hr;

    Assert (pINetCfg);
    Assert (pfNeedReboot);
    Assert (m_fInitialized);

    *pfNeedReboot = FALSE;

    if (!m_pNod)
    {
        return;
    }

    Assert (m_pNod->pCc);

    CComponent* pThis;
    pThis = CONTAINING_RECORD (this, CComponent, Notify);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            g_pDiagCtx->Printf (ttidBeDiag,
                "      calling %S->ApplyPnpChanges\n",
                pThis->m_pszInfId);

            hr = m_pNod->pCc->ApplyPnpChanges (pINetCfg);

            if (FAILED(hr) || (NETCFG_S_REBOOT == hr))
            {
                *pfNeedReboot = TRUE;
            }
        }
        NC_CATCH_ALL
        {
            *pfNeedReboot = TRUE;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

VOID
CNotifyObjectInterface::ApplyRegistryChanges (
    IN CImplINetCfg* pINetCfg,
    OUT BOOL* pfNeedReboot) const
{
    HRESULT hr;

    Assert (pINetCfg);
    Assert (pfNeedReboot);
    Assert (m_fInitialized);

    *pfNeedReboot = FALSE;

    if (!m_pNod)
    {
        return;
    }

    Assert (m_pNod->pCc);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pCc->ApplyRegistryChanges ();

            if (FAILED(hr) || (NETCFG_S_REBOOT == hr))
            {
                *pfNeedReboot = TRUE;
            }
        }
        NC_CATCH_ALL
        {
            *pfNeedReboot = TRUE;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

HRESULT
CNotifyObjectInterface::HrGetInterfaceIdsForAdapter (
    IN CImplINetCfg* pINetCfg,
    IN const CComponent* pAdapter,
    OUT DWORD* pcInterfaces,
    OUT GUID** ppguidInterfaceIds) const
{
    HRESULT hr;

    Assert (pAdapter);
    Assert (pcInterfaces);

    Assert (m_fInitialized);

    *pcInterfaces = 0;
    if (ppguidInterfaceIds)
    {
        *ppguidInterfaceIds = NULL;
    }

    if (!m_pNod || !m_pNod->pUe)
    {
        return S_FALSE;
    }

    Assert (pAdapter->GetINetCfgComponentInterface());

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pUe->GetInterfaceIdsForAdapter (
                    pAdapter->GetINetCfgComponentInterface(),
                    pcInterfaces, ppguidInterfaceIds);

            if (S_FALSE == hr)
            {
                *pcInterfaces = 0;
                if (ppguidInterfaceIds)
                {
                    *ppguidInterfaceIds = NULL;
                }
            }
        }
        NC_CATCH_ALL
        {
            ;   // ignored
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    TraceHr (ttidError, FAL, hr, (S_FALSE == hr),
        "CNotifyObjectInterface::HrGetInterfaceIdsForAdapter");
    return hr;
}

HRESULT
CNotifyObjectInterface::HrQueryPropertyUi (
    IN CImplINetCfg* pINetCfg,
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;
    CComponent* pThis;

    Assert (this);
    Assert (pINetCfg);
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCp)
    {
        return S_FALSE;
    }

    pThis = CONTAINING_RECORD (this, CComponent, Notify);
    Assert (pThis);

    if (!(pThis->m_dwCharacter & NCF_HAS_UI))
    {
        return S_FALSE;
    }

    hr = S_OK;

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            Assert (m_pNod && m_pNod->pCp);

            hr = m_pNod->pCp->QueryPropertyUi (punkContext);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::HrQueryPropertyUi");
    return hr;
}

HRESULT
CNotifyObjectInterface::HrShowPropertyUi (
    IN CImplINetCfg* pINetCfg,
    IN HWND hwndParent,
    IN IUnknown* punkContext OPTIONAL)
{
    HRESULT hr;
    DWORD cDefPages;
    UINT cPages;
    HPROPSHEETPAGE* ahpsp;
    PCWSTR pszStartPage;

    Assert (this);
    Assert (pINetCfg);
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCp)
    {
        return E_NOINTERFACE;
    }

    Assert (m_pNod && m_pNod->pCp);

    // If given a context, let the notify object know what it is.
    //
    if (punkContext)
    {
        SetUiContext (pINetCfg, punkContext);
    }

    hr = S_OK;
    cDefPages = 0;
    ahpsp = NULL;
    cPages = 0;
    pszStartPage = NULL;

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            hr = m_pNod->pCp->MergePropPages (
                    &cDefPages,
                    (BYTE**)&ahpsp,
                    &cPages,
                    hwndParent,
                    &pszStartPage);
        }
        NC_CATCH_ALL
        {
            hr = E_UNEXPECTED;
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);

    if ((S_OK == hr) && cPages)
    {
        PROPSHEETHEADER psh;
        CAPAGES caPages;
        CAINCP cai;
        CComponent* pThis;

        pThis = CONTAINING_RECORD (this, CComponent, Notify);
        Assert (pThis);

        ZeroMemory(&psh, sizeof(psh));
        ZeroMemory(&caPages, sizeof(caPages));
        ZeroMemory(&cai, sizeof(cai));

        psh.dwSize = sizeof(psh);
        psh.dwFlags = PSH_PROPTITLE | PSH_NOAPPLYNOW;
        psh.hwndParent = hwndParent;
        psh.hInstance = _Module.GetModuleInstance();
        psh.pszCaption = pThis->Ext.PszDescription();

        caPages.nCount = cPages;
        caPages.ahpsp = ahpsp;

        cai.nCount = 1;
        cai.apncp = &m_pNod->pCp;

        hr = HrNetCfgPropertySheet (&psh, caPages, pszStartPage, cai);

        // S_FALSE is returned if no changes were made.
        //
        if (S_OK == hr)
        {
            if (pINetCfg->m_WriteLock.FIsOwnedByMe ())
            {
                pINetCfg->m_pNetConfig->ModifyCtx.HrBeginBatchOperation ();
            }

            BOOL bCommitNow = FALSE;

            // Call ApplyProperties
            //
            pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
                NC_TRY
                {
                    hr = m_pNod->pCp->ApplyProperties ();
                    if(NETCFG_S_COMMIT_NOW == hr)
                    {
                        bCommitNow = TRUE;
                    }
                }
                NC_CATCH_ALL
                {
                    hr = E_UNEXPECTED;
                }
            pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

            if (pINetCfg->m_WriteLock.FIsOwnedByMe ())
            {
                // Set this component as dirty so we call its Apply method
                // if INetCfg is applied.
                //
                hr = pINetCfg->m_pNetConfig->ModifyCtx.HrDirtyComponent(
                        pThis);

                // Notify other components that this component changed.
                //
                pINetCfg->m_pNetConfig->Notify.NgSysNotifyComponent (
                    NCN_PROPERTYCHANGE,
                    pThis);

                hr = pINetCfg->m_pNetConfig->ModifyCtx.
                    HrEndBatchOperation (bCommitNow ? EBO_COMMIT_NOW : EBO_DEFER_COMMIT_UNTIL_APPLY);
            }
        }
        else
        {
            // Don't overwrite hr.  It is what we need to return.
            //
            // Call CancelProperties
            //
            pINetCfg->RaiseRpl (RPL_DISALLOW);
                NC_TRY
                {
                    (VOID) m_pNod->pCp->CancelProperties ();
                }
                NC_CATCH_ALL
                {
                    hr = E_UNEXPECTED;
                }
            pINetCfg->LowerRpl (RPL_DISALLOW);
        }
    }

    // This is outside the above if in case a notify object actually
    // allocates it but returns zero pages.
    //
    CoTaskMemFree (ahpsp);

    // If given a context, let the notify object know it is no longer valid.
    //
    if (punkContext)
    {
        SetUiContext (pINetCfg, NULL);
    }

    TraceHr (ttidError, FAL, hr,
        (HRESULT_FROM_WIN32(ERROR_CANCELLED) == hr),
        "CNotifyObjectInterface::HrShowPropertyUi");
    return hr;
}

VOID
CNotifyObjectInterface::SetUiContext (
    IN CImplINetCfg* pINetCfg,
    IN IUnknown* punkContext)
{
    Assert (m_fInitialized);
    Assert (m_pNod && m_pNod->pCp);

    pINetCfg->RaiseRpl (RPL_DISALLOW);
        NC_TRY
        {
            (VOID) m_pNod->pCp->SetContext (punkContext);
        }
        NC_CATCH_ALL
        {
            ;   // ignored
        }
    pINetCfg->LowerRpl (RPL_DISALLOW);
}

VOID
CNotifyObjectInterface::NbQueryOrNotifyBindingPath (
    IN CImplINetCfg* pINetCfg,
    IN QN_FLAG Flag,
    IN DWORD dwChangeFlag,
    IN INetCfgBindingPath* pIPath,
    OUT BOOL* pfDisabled)
{
    RPL_FLAGS RplFlag;

    Assert (pINetCfg);
    Assert ((QN_QUERY == Flag) || (QN_NOTIFY == Flag));
    Assert (pIPath);
    Assert (FImplies(QN_QUERY == Flag, pfDisabled));

    Assert (m_fInitialized);

    if (pfDisabled)
    {
        *pfDisabled = FALSE;
    }

    if (m_pNod && m_pNod->pNb)
    {
        RplFlag = (QN_NOTIFY == Flag) ? RPL_ALLOW_INSTALL_REMOVE
                                      : RPL_DISALLOW;

        pINetCfg->RaiseRpl (RplFlag);
            NC_TRY
            {
                if (QN_QUERY == Flag)
                {
                    HRESULT hr;

                    hr = m_pNod->pNb->QueryBindingPath (dwChangeFlag, pIPath);

                    if (NETCFG_S_DISABLE_QUERY == hr)
                    {
                        *pfDisabled = TRUE;
                    }
                }
                else
                {
                    (VOID) m_pNod->pNb->NotifyBindingPath (dwChangeFlag, pIPath);
                }
            }
            NC_CATCH_ALL
            {
                ;   // ignored
            }
        pINetCfg->LowerRpl (RplFlag);
    }
}

HRESULT
CNotifyObjectInterface::QueryNotifyObject (
    IN CImplINetCfg* pINetCfg,
    IN REFIID riid,
    OUT VOID** ppvObject)
{
    HRESULT hr;

    *ppvObject = NULL;

    hr = HrEnsureNotifyObjectInitialized (pINetCfg, FALSE);
    if (S_OK == hr)
    {
        if (m_pNod && m_pNod->pCc)
        {
            hr = m_pNod->pCc->QueryInterface (riid, ppvObject);
        }
        else
        {
            hr = E_NOINTERFACE;
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::QueryNotifyObject");
    return hr;
}

VOID
CNotifyObjectInterface::ReleaseNotifyObject (
    IN CImplINetCfg* pINetCfg,
    IN BOOL fCancel)
{
    Assert (FIff(pINetCfg, fCancel));

    if (m_pNod)
    {
        // Tell the notify object to cancel if requested.
        //
        if (fCancel)
        {
            pINetCfg->RaiseRpl (RPL_DISALLOW);
                NC_TRY
                {
                    (VOID) m_pNod->pCc->CancelChanges ();
                }
                NC_CATCH_ALL
                {
                    ;   // ignored
                }
            pINetCfg->LowerRpl (RPL_DISALLOW);
        }

        // Release all of the interfaces we are holding.
        //
        ReleaseObj (m_pNod->pCc);
        ReleaseObj (m_pNod->pNb);
        ReleaseObj (m_pNod->pCp);
        ReleaseObj (m_pNod->pCs);
        ReleaseObj (m_pNod->pUe);
        ReleaseObj (m_pNod->pNg);

        MemFree (m_pNod);
        m_pNod = NULL;
    }
    m_fInitialized = FALSE;
}

HRESULT
CNotifyObjectInterface::NewlyAdded (
    IN CImplINetCfg* pINetCfg,
    IN const NETWORK_INSTALL_PARAMS* pnip)
{
    HRESULT hr;

    //$REVIEW: Calling HrEnsureNotifyObjectInitialized is probably not needed
    // because when we have the write lock and call notify objects, we always
    // ensure they are loaded before we get here.
    //
    hr = HrEnsureNotifyObjectInitialized (pINetCfg, TRUE);
    if ((S_OK == hr) && m_pNod && m_pNod->pCs)
    {
        // Inform the notify object that its component is being installed
        // and tell it to read the answerfile if we are using one.
        //
        DWORD dwSetupFlags;

        if (pnip)
        {
            dwSetupFlags = pnip->dwSetupFlags;
        }
        else
        {
            dwSetupFlags = FInSystemSetup() ? NSF_PRIMARYINSTALL
                                            : NSF_POSTSYSINSTALL;
        }

        // Raise the reentrancy protection level to only allow
        // install or remove before calling the notify object's Install
        // method.
        //
        pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
            NC_TRY
            {
                hr = m_pNod->pCs->Install (dwSetupFlags);

                if (SUCCEEDED(hr) && pnip &&
                    pnip->pszAnswerFile &&
                    pnip->pszAnswerSection)
                {
                    // Raise the reentrancy protection level to disallow
                    // all reentrancy before calling the notify object's
                    // ReadAnswerFile method.
                    //
                    pINetCfg->RaiseRpl (RPL_DISALLOW);
                    NC_TRY
                    {
                        hr = m_pNod->pCs->ReadAnswerFile (
                                pnip->pszAnswerFile,
                                pnip->pszAnswerSection);
                    }
                    NC_CATCH_ALL
                    {
                        ;
                    }
                    pINetCfg->LowerRpl (RPL_DISALLOW);
                }
            }
            NC_CATCH_ALL
            {
                ;
            }
        pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CNotifyObjectInterface::NewlyAdded");
    return hr;
}

VOID
CNotifyObjectInterface::Removed (
    IN CImplINetCfg* pINetCfg)
{
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCs)
    {
        return;
    }

    // Raise the reentrancy protection level to only allow
    // install or remove before calling the notify object's Install
    // method.
    //
    pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
        NC_TRY
        {
            // Inform the notify object that its component is being removed.
            //
            (VOID) m_pNod->pCs->Removing ();
        }
        NC_CATCH_ALL
        {
            ;
        }
    pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);
}

VOID
CNotifyObjectInterface::Updated (
    IN CImplINetCfg* pINetCfg,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    Assert (m_fInitialized);

    if (!m_pNod || !m_pNod->pCs)
    {
        return;
    }

    // Raise the reentrancy protection level to only allow
    // install or remove before calling the notify object's Install
    // method.
    //
    pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);
        NC_TRY
        {
            HRESULT hrNotify;

            // Inform the notify object that its component is being updated.
            //
            hrNotify = m_pNod->pCs->Upgrade (dwSetupFlags,
                    dwUpgradeFromBuildNo);

            // If Upgrade returns S_OK, it means they recognized and
            // handled the event and are now dirty because of it.
            //
            if (S_OK == hrNotify)
            {
                CComponent* pThis;

                pThis = CONTAINING_RECORD (this, CComponent, Notify);
                Assert (pThis);

                (VOID) pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent (pThis);
            }
        }
        NC_CATCH_ALL
        {
            ;
        }
    pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);
}

//+---------------------------------------------------------------------------
// CGlobalNotifyInterface -
//

VOID
CGlobalNotifyInterface::HoldINetCfg (
    CImplINetCfg* pINetCfg)
{
    AssertH (pINetCfg);
    AssertH (!m_pINetCfg);

    AddRefObj (pINetCfg->GetUnknown());
    m_pINetCfg = pINetCfg;
}

VOID
CGlobalNotifyInterface::ReleaseAllNotifyObjects (
    IN CComponentList& Components,
    IN BOOL fCancel)
{
    CComponentList::iterator iter;
    CComponent* pComponent;
    CImplINetCfg* pINetCfg;

    // We need to pass a non-NULL pINetCfg if we are not cancelling.
    //
    pINetCfg = (fCancel) ? m_pINetCfg : NULL;

    for (iter  = Components.begin();
         iter != Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        pComponent->Notify.ReleaseNotifyObject (pINetCfg, fCancel);
    }

    m_fInitialized = FALSE;
}

VOID
CGlobalNotifyInterface::ReleaseINetCfg ()
{
    // If we have a cached INetCfg interface, we need to tell it
    // that we no longer exist.  Then we need to release the interface,
    // of course.
    //
    if (m_pINetCfg)
    {
        // Get our containing CNetConfig pointer.
        //
        CNetConfig* pThis;
        pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

        Assert (pThis == m_pINetCfg->m_pNetConfig);
        m_pINetCfg->m_pNetConfig = NULL;
        ReleaseObj (m_pINetCfg->GetUnknown());
        m_pINetCfg = NULL;
    }
}

HRESULT
CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized ()
{
    // If we've already been through initialization, return immediately.
    //
    if (m_fInitialized)
    {
        return S_OK;
    }

    // Only perform initialization once, regardless of whether it succeeds
    // or not.
    //
    m_fInitialized = TRUE;

    // Get our containing CNetConfig pointer so we can enumerate all components.
    //
    CNetConfig* pThis;
    pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

    HRESULT hr = S_OK;

    // If we don't have an INetCfg interface pointer yet, it means we are
    // creating one instead of it creating CNetConfig.  If we had one, it
    // would have been handed to us via HoldINetCfg which is called when
    // CNetConfig is created by CImplINetCfg.
    //
    if (!m_pINetCfg)
    {
        hr = CImplINetCfg::HrCreateInstance (pThis, &m_pINetCfg);
        Assert (!m_pINetCfg->m_fOwnNetConfig);
    }

    if (S_OK == hr)
    {
        Assert (m_pINetCfg);

        CComponentList::iterator iter;
        CComponent* pComponent;
        for (iter  = pThis->Core.Components.begin();
             iter != pThis->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            hr = pComponent->Notify.HrEnsureNotifyObjectInitialized (m_pINetCfg, FALSE);
            if (S_OK != hr)
            {
                break;
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::HrEnsureNotifyObjectsInitialized");
    return hr;
}

VOID
CGlobalNotifyInterface::NgSysQueryOrNotifyBindingPath (
    IN QN_FLAG Flag,
    IN DWORD dwChangeFlag,
    IN INetCfgBindingPath* pIPath,
    IN BOOL* pfDisabled)
{
    RPL_FLAGS RplFlag;
    CNetConfig* pThis;
    CComponentList::iterator iter;
    CComponent* pComponent;

    Assert (m_pINetCfg);
    Assert ((QN_QUERY == Flag) || (QN_NOTIFY == Flag));
    Assert (pIPath);
    Assert (FImplies(QN_QUERY == Flag, pfDisabled));

    Assert (m_fInitialized);

    if (pfDisabled)
    {
        *pfDisabled = FALSE;
    }

    // Get our containing CNetConfig pointer so we can enumerate
    // all components.
    //
    pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

    RplFlag = (QN_NOTIFY == Flag) ? RPL_ALLOW_INSTALL_REMOVE
                                  : RPL_DISALLOW;

    m_pINetCfg->RaiseRpl (RplFlag);

    for (iter  = pThis->Core.Components.begin();
         iter != pThis->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (!pComponent->Notify.m_pNod ||
            !pComponent->Notify.m_pNod->pNg ||
            !(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & NCN_BINDING_PATH))
        {
            continue;
        }

        // If the component has not registered for what we are changing,
        // (NCN_ADD, NCN_REMOVE, NCN_ENABLE, NCN_DISABLE) then
        // skip it.
        //
        if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwChangeFlag))
        {
            continue;
        }

        NC_TRY
        {
            HRESULT hr;

            if (QN_QUERY == Flag)
            {
                hr = pComponent->Notify.m_pNod->pNg->
                        SysQueryBindingPath (dwChangeFlag, pIPath);

                if (NETCFG_S_DISABLE_QUERY == hr)
                {
                    *pfDisabled = TRUE;
                    break;
                }
            }
            else
            {
                hr = pComponent->Notify.m_pNod->pNg->
                        SysNotifyBindingPath (dwChangeFlag, pIPath);

                // If SysNotifyBindingPath returns S_OK, it means they
                // recognized and handled the event and are now dirty
                // because of it.  Because some notify objects let
                // success codes such as NETCFG_S_REBOOT slip through,
                // consider them dirty if they don't return S_FALSE.
                //
                if (S_FALSE != hr)
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent(pComponent);
                }
            }
        }
        NC_CATCH_ALL
        {
            ;
        }
    }

    m_pINetCfg->LowerRpl (RplFlag);
}

HRESULT
CGlobalNotifyInterface::NgSysNotifyComponent (
    IN DWORD dwChangeFlag,
    IN CComponent* pComponentOfInterest)
{
    HRESULT hr;
    INetCfgComponent* pICompOfInterest;

    // We should have called HrEnsureNotifyObjectsInitialized by now.
    //
    Assert (m_fInitialized);

    // If the component of interest has not had its data loaded successfully,
    // we shouldn't bother sending the notification.  The notify objects are
    // just going to call back on the interface to the component and fail
    // if they call a method that requires this data.
    //
    if (!pComponentOfInterest->Ext.FLoadedOkayIfLoadedAtAll())
    {
        return S_OK;
    }

    hr = pComponentOfInterest->HrGetINetCfgComponentInterface (
            m_pINetCfg, &pICompOfInterest);

    if (S_OK == hr)
    {
        DWORD dwMask = 0;
        NETCLASS Class = pComponentOfInterest->Class();
        CNetConfig* pThis;
        CComponentList::iterator iter;
        CComponent* pComponent;

        if (FIsConsideredNetClass(Class))
        {
            dwMask = NCN_NET;
        }
        else if (NC_NETTRANS == Class)
        {
            dwMask = NCN_NETTRANS;
        }
        else if (NC_NETCLIENT == Class)
        {
            dwMask = NCN_NETCLIENT;
        }
        else if (NC_NETSERVICE == Class)
        {
            dwMask = NCN_NETSERVICE;
        }

        // Get our containing CNetConfig pointer so we can enumerate
        // all components.
        //
        pThis = CONTAINING_RECORD(this, CNetConfig, Notify);

        // Raise the reentrancy protection level to only allow
        // install or remove before calling the notify object's
        // SysNotifyComponent method.
        //
        m_pINetCfg->RaiseRpl (RPL_ALLOW_INSTALL_REMOVE);

        for (iter  = pThis->Core.Components.begin();
             iter != pThis->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            if (!pComponent->Notify.m_pNod ||
                !pComponent->Notify.m_pNod->pNg)
            {
                continue;
            }

            // If the component has not registered for one of NCN_NET,
            // NCN_NETTRANS, etc. then skip it.
            //
            if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwMask))
            {
                continue;
            }

            // If the component has not registered for what we are changing,
            // (NCN_ADD, NCN_REMOVE, NCN_UPDATE, NCN_PROPERTYCHANGE) then
            // skip it.
            //
            if (!(pComponent->Notify.m_pNod->dwNotifyGlobalFlags & dwChangeFlag))
            {
                continue;
            }

            NC_TRY
            {
                HRESULT hrNotify;

                hrNotify = pComponent->Notify.m_pNod->pNg->SysNotifyComponent (
                            dwMask | dwChangeFlag,
                            pICompOfInterest);

                // If SysNotifyComponent returns S_OK, it means they
                // recognized and handled the event and are now dirty
                // because of it.  Because some notify objects let
                // success codes such as NETCFG_S_REBOOT slip through,
                // consider them dirty if they don't return S_FALSE.
                //
                if (S_FALSE != hrNotify)
                {
                    hr = m_pINetCfg->m_pNetConfig->ModifyCtx.
                            HrDirtyComponent(pComponent);
                }
            }
            NC_CATCH_ALL
            {
                ;
            }
        }

        m_pINetCfg->LowerRpl (RPL_ALLOW_INSTALL_REMOVE);

        ReleaseObj (pICompOfInterest);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::NgSysNotifyComponent");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentAdded (
    IN CComponent* pComponent,
    IN const NETWORK_INSTALL_PARAMS* pnip)
{
    HRESULT hr;

    Assert (pComponent);

    // Initialize the notify object for the component and call
    // its Install method followed by ReadAnswerFile if we are installing
    // with one.
    //
    hr = pComponent->Notify.NewlyAdded (m_pINetCfg, pnip);
    if (S_OK == hr)
    {
        // Notify all notify objects that are interested in component
        // additions.
        //
        hr = NgSysNotifyComponent(NCN_ADD, pComponent);
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentAdded");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentRemoved (
    IN CComponent* pComponent)
{
    HRESULT hr;

    Assert (pComponent);

    pComponent->Notify.Removed (m_pINetCfg);

    hr = NgSysNotifyComponent(NCN_REMOVE, pComponent);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentRemoved");
    return hr;
}

HRESULT
CGlobalNotifyInterface::ComponentUpdated (
    IN CComponent* pComponent,
    IN DWORD dwSetupFlags,
    IN DWORD dwUpgradeFromBuildNo)
{
    HRESULT hr;

    Assert (pComponent);

    pComponent->Notify.Updated (m_pINetCfg,
            dwSetupFlags, dwUpgradeFromBuildNo);

    hr = NgSysNotifyComponent(NCN_UPDATE, pComponent);

    TraceHr (ttidError, FAL, hr, FALSE,
        "CGlobalNotifyInterface::ComponentUpdated");
    return hr;
}

VOID
CGlobalNotifyInterface::NotifyBindPath (
    IN DWORD dwChangeFlag,
    IN CBindPath* pBindPath,
    IN INetCfgBindingPath* pIPath OPTIONAL)
{
    HRESULT hr;
    CImplINetCfg* pINetCfg;
    CComponent* pOwner;
    BOOL fReleasePath;

    Assert (m_fInitialized);
    Assert ((dwChangeFlag & NCN_ADD) ||
            (dwChangeFlag & NCN_REMOVE) ||
            (dwChangeFlag & NCN_ENABLE) ||
            (dwChangeFlag & NCN_DISABLE));
    Assert (FImplies(dwChangeFlag & NCN_REMOVE, !(dwChangeFlag & NCN_DISABLE)));
    Assert (FImplies(dwChangeFlag & NCN_ADD,    !(dwChangeFlag & NCN_REMOVE)));
    Assert (FImplies(dwChangeFlag & NCN_REMOVE, !(dwChangeFlag & NCN_ADD)));
    Assert (pBindPath);

    hr = S_OK;
    pINetCfg = PINetCfg();
    pOwner = pBindPath->POwner();
    fReleasePath = FALSE;

    // Create an INetCfgBindingPath representation of the path for
    // the notify objects if we were not given one.
    //
    if (!pIPath)
    {
        // If the bindpath contains components that have had a problem
        // loading, we shouldn't bother sending the notification.
        // The notify objects are just going to call back on the interface
        // to the component and fail if they call a method that requires
        // this data.
        //
        if (!pBindPath->FAllComponentsLoadedOkayIfLoadedAtAll())
        {
            return;
        }

        hr = CImplINetCfgBindingPath::HrCreateInstance (
                pINetCfg, pBindPath, &pIPath);

        fReleasePath = TRUE;
    }

    if (S_OK == hr)
    {
        Assert (pIPath);

        // If adding...
        //
        if (dwChangeFlag & NCN_ADD)
        {
            BOOL fDisabled;

            fDisabled = FALSE;

            // First, query the owner of the bindpath to see if he wants
            // it disabled.
            //
            pOwner->Notify.NbQueryOrNotifyBindingPath (
                pINetCfg,
                QN_QUERY,
                dwChangeFlag,
                pIPath,
                &fDisabled);

            // If the owner doesn't want it disabled, see if any global
            // notify objects do.
            //
            if (!fDisabled)
            {
                NgSysQueryOrNotifyBindingPath (
                    QN_QUERY,
                    dwChangeFlag,
                    pIPath,
                    &fDisabled);
            }

            // If someone wants it disabled, adjust the change flag
            // for notify and add the bindpath to our disabled list.
            //
            if (fDisabled)
            {
                dwChangeFlag = NCN_ADD | NCN_DISABLE;

                (VOID)pINetCfg->m_pNetConfig->Core.HrDisableBindPath (pBindPath);
            }
        }

        //if (g_pDiagCtx->Flags() & DF_SHOW_CONSOLE_OUTPUT)
        {
            WCHAR pszBindPath [1024];
            ULONG cch;

            cch = celems(pszBindPath) - 1;
            if (pBindPath->FGetPathToken (pszBindPath, &cch))
            {
                g_pDiagCtx->Printf (ttidBeDiag, "   %S (%s)\n",
                    pszBindPath,
                    (dwChangeFlag & NCN_ENABLE)
                        ? "enabled"
                        : (dwChangeFlag & NCN_DISABLE)
                            ? "disabled"
                            : "removed");
            }
        }

        pOwner->Notify.NbQueryOrNotifyBindingPath (
            pINetCfg,
            QN_NOTIFY,
            dwChangeFlag,
            pIPath,
            NULL);

        NgSysQueryOrNotifyBindingPath (
            QN_NOTIFY,
            dwChangeFlag,
            pIPath,
            NULL);

        if (fReleasePath)
        {
            ReleaseObj (pIPath);
        }
    }
}

HRESULT
CGlobalNotifyInterface::QueryAndNotifyBindPaths (
    IN DWORD dwBaseChangeFlag,
    IN CBindingSet* pBindSet,
    IN UINT cSkipFirstBindPaths)
{
    CBindPath* pBindPath;
    DWORD dwChangeFlag;
    PCSTR pszDiagMsg;

    // We should have called HrEnsureNotifyObjectsInitialized by now.
    //
    Assert (m_fInitialized);
    Assert ((dwBaseChangeFlag & NCN_ADD) || (dwBaseChangeFlag & NCN_REMOVE));

    if (dwBaseChangeFlag & NCN_ADD)
    {
        dwChangeFlag = NCN_ADD | NCN_ENABLE;
        pszDiagMsg = "Query and notify the following bindings:\n";
    }
    else
    {
        dwChangeFlag = NCN_REMOVE;
        pszDiagMsg = "Notify the following bindings are removed:\n";
    }

    g_pDiagCtx->Printf (ttidBeDiag, pszDiagMsg);

    // Iterate the newly added bindpaths by picking up where the
    // previous set ended and going to the end of the binding set.
    // Note, because this may recurse, pBindSet may change during
    // iteration, so a simple pointer increment through begin() to end()
    // may fail if the bindset is reallocated or grown.
    // Note too that we save off the current count of bindpaths in
    // iStopAtBindPath.  If we did not, when we come out of a recursion where
    // the binding set grew, we'd re-notify the newly added bindpaths
    // if we used a direct comparison of 'i < pBindSet->CountBindPaths()'.
    //
    UINT iStopAtBindPath = pBindSet->CountBindPaths();

    for (UINT i = cSkipFirstBindPaths; i < iStopAtBindPath; i++)
    {
        pBindPath = pBindSet->PGetBindPathAtIndex(i);

        NotifyBindPath (dwChangeFlag, pBindPath, NULL);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\pnpbind.h ===
#pragma once
#include "bindings.h"

UINT
GetPnpLayerForBindPath (
    IN const CBindPath* pBindPath);

HRESULT
HrPnpUnloadDriver (
    IN UINT Layer,
    IN PCWSTR pszComponentBindName);

VOID
PruneNdisWanBindPathsIfActiveRasConnections (
    IN CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\provider.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       P R O V I D E R . H
//
//  Contents:   NetClient class installer functions
//
//  Notes:
//
//  Author:     billbe  22 Mar 1997
//
//---------------------------------------------------------------------------

#pragma once

HRESULT
HrCiAddNetProviderInfo(HINF hinf, PCWSTR pszSection,
        HKEY hkeyInstance, BOOL fPreviouslyInstalled);


HRESULT
HrCiDeleteNetProviderInfo(HKEY hkeyInstance, DWORD* pdwNetworkPosition,
        DWORD* pdwPrintPosition);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\persist.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P E R S I S T . C P P
//
//  Contents:   Module repsonsible for persistence of the network
//              configuration information.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "persist.h"
#include "ncreg.h"

#if defined (_X86_)
inline BOOL IsRunningOnWow64()
{
    static DWORD dwCachedWow64 = DWORD_MAX;
    if (DWORD_MAX == dwCachedWow64)
    {
        BOOL fTempWow64;
        if (IsWow64Process(GetCurrentProcess(), &fTempWow64))
        {
            dwCachedWow64 = fTempWow64;
        }
        else
        {
            AssertSz(FALSE, "Could not determine whether this is a WOW64 process.");
            return FALSE;
        }
    }

    return dwCachedWow64;
}

inline size_t ALIGNUP(size_t nSize)
{
    // If we are a 32-bit app running on a 64-bit O/S we need to use 64-bit alignment when reading or writing from the registry.
    if (IsRunningOnWow64())
    {
        return ((nSize + (sizeof(DWORD64) - 1)) & ~(sizeof(DWORD64) - 1));
    }
    else
    {
        return nSize;
    }
}

#elif defined (_WIN64) 
    #define ALIGNUP(x) ((x + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID) - 1))

#else
    #error Please define an ALIGNUP implementation for this architecture.

#endif

#define alignedsizeof(x) ALIGNUP(sizeof(x))

const DWORD CURRENT_VERSION = 0;

HRESULT
HrLoadNetworkConfigurationFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    DWORD dwVersion;
    ULONG cComponents;
    ULONG cStackEntries;
    ULONG cBindPaths;
    ULONG unUpperIndex;
    ULONG unLowerIndex;
    ULONG unComponentIndex;
    BOOL fRefByUser;
    BASIC_COMPONENT_DATA Data;
    CComponentList* pComponents;
    CComponent* pComponent;
    CStackEntry StackEntry;
    CBindPath BindPath;
    PCWSTR pszString;

    // We should be starting clean.
    //
    Assert (pNetConfig->Core.FIsEmpty());

    hr = S_OK;

    // Load the version marker.
    //
    dwVersion = *(DWORD32*)pbBuf;
    pbBuf += alignedsizeof(DWORD32);

    if (dwVersion > CURRENT_VERSION)
    {
        hr = E_UNEXPECTED;
        goto finished;
    }

    // Load the component list.
    //
    cComponents = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cComponents--)
    {
        ZeroMemory (&Data, sizeof(Data));

        Data.InstanceGuid = *(GUID*)pbBuf;
        pbBuf += alignedsizeof(GUID);

        Data.Class = *(NETCLASS*)pbBuf;
        pbBuf += alignedsizeof(NETCLASS);

        Data.dwCharacter = *(DWORD32*)pbBuf;
        pbBuf += alignedsizeof(DWORD32);

        Data.pszInfId = (PCWSTR)pbBuf;
        Assert (*Data.pszInfId);
        pbBuf += ALIGNUP(CbOfSzAndTerm (Data.pszInfId));

        pszString = (PCWSTR)pbBuf;
        pbBuf += ALIGNUP(CbOfSzAndTerm (pszString));
        if (*pszString)
        {
            Data.pszPnpId = pszString;
        }

        hr = CComponent::HrCreateInstance (
                &Data,
                CCI_DEFAULT,
                NULL,
                &pComponent);
        if (S_OK == hr)
        {
            hr = pNetConfig->Core.Components.HrInsertComponent (
                    pComponent, INS_ASSERT_IF_DUP | INS_NON_SORTED);
        }

        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the stack table.
    //
    pComponents = &pNetConfig->Core.Components;

    pNetConfig->Core.StackTable.m_fWanAdaptersFirst = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    cStackEntries = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cStackEntries--)
    {
        ZeroMemory (&StackEntry, sizeof(StackEntry));

        unUpperIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        unLowerIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        StackEntry.pUpper = pComponents->PGetComponentAtIndex (
                                unUpperIndex);

        StackEntry.pLower = pComponents->PGetComponentAtIndex (
                                unLowerIndex);

        // Insert in the order we persisted.  If we used ISE_SORT here, we'd
        // blow away whatever bind order we saved.
        //
        hr = pNetConfig->Core.StackTable.HrInsertStackEntry (
                &StackEntry, INS_NON_SORTED);
        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the disabled bindpaths.
    //
    cBindPaths = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cBindPaths--)
    {
        cComponents = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        BindPath.Clear();

        while (cComponents--)
        {
            unComponentIndex = *(ULONG32*)pbBuf;
            pbBuf += alignedsizeof(ULONG32);

            pComponent = pComponents->PGetComponentAtIndex (unComponentIndex);
            Assert (pComponent);

            hr = BindPath.HrAppendComponent (pComponent);
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        hr = pNetConfig->Core.DisabledBindings.HrAddBindPath (
                &BindPath, INS_ASSERT_IF_DUP | INS_APPEND);

        if (S_OK != hr)
        {
            goto finished;
        }
    }

    // Load the component references.
    //
    cComponents = *(ULONG32*)pbBuf;
    pbBuf += alignedsizeof(ULONG32);

    while (cComponents--)
    {
        unComponentIndex = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        pComponent = pComponents->PGetComponentAtIndex (unComponentIndex);
        Assert (pComponent);

        fRefByUser = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        if (fRefByUser)
        {
            hr = pComponent->Refs.HrAddReferenceByUser ();
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        // Load the count of components that reference this component.
        //
        ULONG CountRefdBy = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        // Load the indicies of the components that reference this component.
        //
        for (UINT i = 0; i < CountRefdBy; i++)
        {
            unComponentIndex = *(ULONG32*)pbBuf;
            pbBuf += alignedsizeof(ULONG32);

            CComponent* pRefdBy;
            pRefdBy = pComponents->PGetComponentAtIndex (unComponentIndex);
            Assert (pRefdBy);

            hr = pComponent->Refs.HrAddReferenceByComponent (pRefdBy);
            if (S_OK != hr)
            {
                goto finished;
            }
        }

        // Load the count of strings that represent external software
        // that reference this component.
        //
        CountRefdBy = *(ULONG32*)pbBuf;
        pbBuf += alignedsizeof(ULONG32);

        // Load the strings that represent external software that
        // references this component.
        //
        for (i = 0; i < CountRefdBy; i++)
        {
            pszString = (PCWSTR)pbBuf;
            pbBuf += ALIGNUP(CbOfSzAndTerm (pszString));

            hr = pComponent->Refs.HrAddReferenceBySoftware (pszString);
            if (S_OK != hr)
            {
                goto finished;
            }
        }
    }

finished:
    if (S_OK != hr)
    {
        pNetConfig->Core.DisabledBindings.Clear ();
        pNetConfig->Core.StackTable.Clear ();
        FreeCollectionAndItem (pNetConfig->Core.Components);
    }
    return hr;
}

HRESULT
HrLoadNetworkConfigurationFromRegistry (
    IN REGSAM samDesired,
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    HKEY hkeyNetwork;

    Assert ((KEY_READ == samDesired) || (KEY_WRITE == samDesired));

    hr = HrOpenNetworkKey (KEY_READ, &hkeyNetwork);

    if (S_OK == hr)
    {
        BYTE* pbBuf;
        ULONG cbBuf;

        hr = HrRegQueryBinaryWithAlloc (
                hkeyNetwork,
                L"Config",
                &pbBuf, &cbBuf);

        // If we read the config binary, use it to initialize pNetConfig.
        //
        if (S_OK == hr)
        {
            hr = HrLoadNetworkConfigurationFromBuffer (pbBuf, cbBuf,
                    pNetConfig);

            if (S_OK == hr)
            {
                pNetConfig->Core.DbgVerifyData ();
            }

            MemFree (pbBuf);
        }
        // Otherwise, if we couldn't read the config binary, we'll have
        // to construct what we can by grovelling the registry.
        //
        else
        {
            hr = HrLoadNetworkConfigurationFromLegacy (pNetConfig);

            if (S_OK == hr)
            {
                hr = HrSaveNetworkConfigurationToRegistry (pNetConfig);
            }
        }

        RegCloseKey (hkeyNetwork);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromRegistry");
    return hr;
}

ULONG
CountComponentsReferencedByOthers (
    IN CNetConfig* pNetConfig)
{
    ULONG cComponents;
    CComponentList::iterator iter;
    CComponent* pComponent;

    cComponents = 0;

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        if (pComponent->Refs.FIsReferencedByOthers ())
        {
            cComponents++;
        }
    }

    return cComponents;
}

HRESULT
HrSaveNetworkConfigurationToBuffer (
    IN CNetConfig* pNetConfig,
    IN BYTE* pbBuf,
    IN OUT ULONG* pcbBuf)
{
    HRESULT hr;
    ULONG cbBuf;
    ULONG cbBufIn;
    ULONG unIndex;
    ULONG Count;
    CComponentList* pComponents;
    CComponent* pComponent;
    CStackEntry* pStackEntry;
    CBindPath* pBindPath;
    PCWSTR pszString;

    Assert (pNetConfig);
    pNetConfig->Core.DbgVerifyData ();
    Assert (pcbBuf);

    cbBufIn = *pcbBuf;
    cbBuf = 0;
    pComponents = &pNetConfig->Core.Components;

    // Save the version number.
    //
    cbBuf += alignedsizeof(DWORD32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(DWORD32*)pbBuf = CURRENT_VERSION;
        pbBuf += alignedsizeof(DWORD32);
    }

    // Save the component list.
    //
    Count = pComponents->Count();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (unIndex = 0; unIndex < Count; unIndex++)
    {
        pComponent = pComponents->PGetComponentAtIndex (unIndex);
        Assert (pComponent);

        pszString = (pComponent->m_pszPnpId) ? pComponent->m_pszPnpId : L"";

        ULONG cbInfIdUnpad = CbOfSzAndTerm (pComponent->m_pszInfId);
        ULONG cbPnpIdUnpad = CbOfSzAndTerm (pszString);

        ULONG cbInfId = ALIGNUP(cbInfIdUnpad);
        ULONG cbPnpId = ALIGNUP(cbPnpIdUnpad);

        cbBuf += alignedsizeof(GUID) + alignedsizeof(NETCLASS) + alignedsizeof(DWORD32) +
                 cbInfId +
                 cbPnpId;

        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(GUID*)pbBuf = pComponent->m_InstanceGuid;
            pbBuf += alignedsizeof(GUID);

            *(NETCLASS*)pbBuf = pComponent->Class();
            pbBuf += alignedsizeof(NETCLASS);

            *(DWORD32*)pbBuf = pComponent->m_dwCharacter;
            pbBuf += alignedsizeof(DWORD32);

            CopyMemory(pbBuf, pComponent->m_pszInfId, cbInfIdUnpad);
            pbBuf += cbInfId;

            CopyMemory(pbBuf, pszString, cbPnpIdUnpad);
            pbBuf += cbPnpId;
        }
    }

    // Save the stack table.
    //
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = pNetConfig->Core.StackTable.m_fWanAdaptersFirst;
        pbBuf += alignedsizeof(ULONG32);
    }

    Count = pNetConfig->Core.StackTable.CountEntries();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (pStackEntry  = pNetConfig->Core.StackTable.begin();
         pStackEntry != pNetConfig->Core.StackTable.end();
         pStackEntry++)
    {
        cbBuf += alignedsizeof(ULONG32) + alignedsizeof(ULONG32);

        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pStackEntry->pUpper);
            pbBuf += alignedsizeof(ULONG32);

            *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pStackEntry->pLower);
            pbBuf += alignedsizeof(ULONG32);
        }
    }

    // Save the disabled bindpaths.
    //
    Count = pNetConfig->Core.DisabledBindings.CountBindPaths();
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }
    for (pBindPath  = pNetConfig->Core.DisabledBindings.begin();
         pBindPath != pNetConfig->Core.DisabledBindings.end();
         pBindPath++)
    {
        Count = pBindPath->CountComponents();
        cbBuf += alignedsizeof(ULONG32) + (Count * alignedsizeof(ULONG32));
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = Count;
            pbBuf += alignedsizeof(ULONG32);

            CBindPath::iterator iter;
            for (iter  = pBindPath->begin();
                 iter != pBindPath->end();
                 iter++)
            {
                pComponent = *iter;
                *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pComponent);
                pbBuf += alignedsizeof(ULONG32);
            }
        }

    }

    // Save the component references.
    //
    Count = CountComponentsReferencedByOthers (pNetConfig);
    cbBuf += alignedsizeof(ULONG32);
    if (pbBuf && (cbBuf <= cbBufIn))
    {
        *(ULONG32*)pbBuf = Count;
        pbBuf += alignedsizeof(ULONG32);
    }

    for (unIndex = 0; unIndex < pComponents->Count(); unIndex++)
    {
        pComponent = pComponents->PGetComponentAtIndex (unIndex);
        Assert (pComponent);

        if (!pComponent->Refs.FIsReferencedByOthers ())
        {
            continue;
        }

        // Index of component with the references.
        //
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = unIndex;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save whether the component is refernced by the user or not.
        //
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = pComponent->Refs.FIsReferencedByUser() ? 1 : 0;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the count of components that reference this component.
        //
        ULONG CountRefdBy = pComponent->Refs.CountComponentsReferencedBy ();
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = CountRefdBy;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the indicies of the components that reference this component.
        //
        for (UINT i = 0; i < CountRefdBy; i++)
        {
            CComponent* pRefdBy;
            pRefdBy = pComponent->Refs.PComponentReferencedByAtIndex(i);
            Assert (pRefdBy);

            cbBuf += alignedsizeof(ULONG32);
            if (pbBuf && (cbBuf <= cbBufIn))
            {
                *(ULONG32*)pbBuf = pComponents->UnGetIndexOfComponent (pRefdBy);
                pbBuf += alignedsizeof(ULONG32);
            }
        }

        // Save the count of strings that represent external software
        // that reference this component.
        //
        CountRefdBy = pComponent->Refs.CountSoftwareReferencedBy ();
        cbBuf += alignedsizeof(ULONG32);
        if (pbBuf && (cbBuf <= cbBufIn))
        {
            *(ULONG32*)pbBuf = CountRefdBy;
            pbBuf += alignedsizeof(ULONG32);
        }

        // Save the strings that represent external software that
        // reference this component.
        //
        for (i = 0; i < CountRefdBy; i++)
        {
            const CWideString* pStr;
            pStr = pComponent->Refs.PSoftwareReferencedByAtIndex(i);
            Assert (pStr);

            ULONG cb = (pStr->length() + 1) * sizeof(WCHAR);

            cbBuf += ALIGNUP(cb);
            if (pbBuf && (cbBuf <= cbBufIn))
            {
                CopyMemory (pbBuf, pStr->c_str(), cb);
                pbBuf += ALIGNUP(cb);
            }
        }
    }


    *pcbBuf = cbBuf;
    if (cbBuf <= cbBufIn)
    {
        hr = S_OK;
    }
    else
    {
        hr = (pbBuf) ? HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER) : S_OK;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToBuffer");
    return hr;
}

HRESULT
HrSaveNetworkConfigurationToBufferWithAlloc (
    IN CNetConfig* pNetConfig,
    OUT BYTE** ppbBuf,
    OUT ULONG* pcbBuf)
{
    HRESULT hr;

    Assert (pNetConfig);
    Assert (ppbBuf);
    Assert (pcbBuf);

    *ppbBuf = NULL;
    *pcbBuf = 0;

    ULONG cbBuf;
    hr = HrSaveNetworkConfigurationToBuffer (pNetConfig, NULL, &cbBuf);
    if (S_OK == hr)
    {
        hr = E_OUTOFMEMORY;
        *ppbBuf = (BYTE*)MemAlloc (cbBuf);
        if (*ppbBuf)
        {
            hr = HrSaveNetworkConfigurationToBuffer (
                    pNetConfig, *ppbBuf, &cbBuf);
            if (S_OK == hr)
            {
                *pcbBuf = cbBuf;
            }
        }
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToBufferWithAlloc");
    return hr;
}

HRESULT
HrSaveNetworkConfigurationToRegistry (
    IN  CNetConfig* pNetConfig)
{
    HRESULT hr;
    HKEY hkeyNetwork;

    Assert (pNetConfig);
    pNetConfig->Core.DbgVerifyData ();

    hr = HrOpenNetworkKey (KEY_WRITE, &hkeyNetwork);

    if (S_OK == hr)
    {
        BYTE* pbBuf;
        ULONG cbBuf;

        hr = HrSaveNetworkConfigurationToBufferWithAlloc (
                pNetConfig, &pbBuf, &cbBuf);

        if (S_OK == hr)
        {
            hr = HrRegSetBinary (hkeyNetwork, L"Config", pbBuf, cbBuf);

            MemFree (pbBuf);

            // Permission from the Perf team to call this.  We need to ensure
            // that the configuration we just wrote will be available on
            // next boot in the case that we crash.
            //
            RegFlushKey (hkeyNetwork);
        }

        RegCloseKey (hkeyNetwork);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrSaveNetworkConfigurationToRegistry");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\pszarray.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P S Z A R R A Y . C P P
//
//  Contents:   Implements the basic datatype for a collection of pointers
//              to strings.
//
//  Notes:
//
//  Author:     shaunco   9 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nceh.h"
#include "pszarray.h"

HRESULT
CPszArray::HrAddPointer (
    IN PCWSTR psz)
{
    HRESULT hr;

    Assert (this);
    Assert (psz);

    NC_TRY
    {
        push_back (psz);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CPszArray::HrAddPointer");
    return hr;
}

HRESULT
CPszArray::HrReserveRoomForPointers (
    IN UINT cPointers)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cPointers);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE,
        "CPszArray::HrReserveRoomForPointers");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\pszarray.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P S Z A R R A Y . H
//
//  Contents:   Implements the basic datatype for a collection of pointers
//              to strings.
//
//  Notes:
//
//  Author:     shaunco   9 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

class CPszArray : public vector<PCWSTR>
{
public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    Count () const
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    HRESULT
    HrAddPointer (
        IN PCWSTR psz);

    HRESULT
    HrReserveRoomForPointers (
        IN UINT cPointers);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\persist.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P E R S I S T . H
//
//  Contents:   Module repsonsible for persistence of the network
//              configuration information.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "netcfg.h"

HRESULT
HrLoadNetworkConfigurationFromBuffer (
    IN const BYTE* pbBuf,
    IN ULONG cbBuf,
    OUT CNetConfig* pNetConfig);

HRESULT
HrLoadNetworkConfigurationFromLegacy (
    OUT CNetConfig* pNetConfig);

HRESULT
HrLoadNetworkConfigurationFromRegistry (
    IN REGSAM samDesired,
    OUT CNetConfig* pNetConfig);


HRESULT
HrSaveNetworkConfigurationToBuffer (
    IN CNetConfig* pNetConfig,
    IN BYTE* pbBuf,
    OUT ULONG* pcbBuf);

HRESULT
HrSaveNetworkConfigurationToBufferWithAlloc (
    IN CNetConfig* pNetConfig,
    OUT BYTE** ppbBuf,
    OUT ULONG* pcbBuf);

HRESULT
HrSaveNetworkConfigurationToRegistry (
    IN CNetConfig* pNetConfig);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\pnpbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       P N P B I N D . C P P
//
//  Contents:   This module is responsible for sending BIND, UNBIND, UNLOAD
//              and RECONFIGURE PnP notifications to NDIS and TDI drivers.
//
//  Notes:
//
//  Author:     shaunco   17 Feb 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "ncras.h"
#include "ndispnp.h"
#include "netcfg.h"

UINT
GetPnpLayerForBindPath (
    IN const CBindPath* pBindPath)
{
    const CComponent* pComponent;
    UINT Layer;

    // Get the component below the component we would be sending the
    // BIND or UNBIND to.
    //
    Assert (pBindPath->CountComponents() > 1);

    pComponent = *(pBindPath->begin() + 1);

    if (FIsEnumerated(pComponent->Class()))
    {
        Layer = NDIS;
    }
    else
    {
        Layer = TDI;
    }

    Assert ((NDIS == Layer) || (TDI == Layer));
    return Layer;
}

HRESULT
HrPnpBindOrUnbind (
    IN UINT Layer,
    IN UINT Operation,
    IN PCWSTR pszComponentBindName,
    IN PCWSTR pszBindString)
{
    HRESULT hr;
    UNICODE_STRING LowerString;
    UNICODE_STRING UpperString;
    UNICODE_STRING BindList;

    Assert ((NDIS == Layer) || (TDI == Layer));
    Assert ((BIND == Operation) || (UNBIND == Operation));
    Assert (pszComponentBindName && *pszComponentBindName);
    Assert (pszBindString && *pszBindString);

    hr = S_OK;

    TraceTag (ttidNetCfgPnp, "PnP Event: %s %s %S - %S",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);

    g_pDiagCtx->Printf (ttidBeDiag, "   PnP Event: %s %s %S - %S\n",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);

    RtlInitUnicodeString (&LowerString, pszBindString);
    RtlInitUnicodeString (&UpperString, pszComponentBindName);

    // Special case for NetBIOS until it can change its bind handler.
    // It blindly dereferences the bind list so we need to make sure it
    // gets down there with a valid (but empty) buffer.  For some reason,
    // the buffer doesn't make it down to kernel mode unless .Length is
    // non-zero.  .MaximumLength is the same as .Length in this case which
    // seems odd.  (The old binding engine sent it this way.)
    //
    // RtlInitUnicodeString (&BindList, L"");  (doesn't work because it
    //  sets .Length to zero.)
    //
    BindList.Buffer = L"";
    BindList.Length = sizeof(WCHAR);
    BindList.MaximumLength = sizeof(WCHAR);

    NC_TRY
    {
        if (!(g_pDiagCtx->Flags() & DF_DONT_DO_PNP_BINDS) ||
            (BIND != Operation))
        {
            BOOL fOk;
            fOk = NdisHandlePnPEvent (
                    Layer,
                    Operation,
                    &LowerString,
                    &UpperString,
                    &BindList,
                    NULL, 0);

            if (!fOk)
            {
                DWORD dwError = GetLastError();

                // Map TDI's version of file not found to the right error.
                //
                if ((TDI == Layer) && (ERROR_GEN_FAILURE == dwError))
                {
                    dwError = ERROR_FILE_NOT_FOUND;
                }

                // ERROR_FILE_NOT_FOUND for UNBIND means it it wasn't
                // bound to begin with.  This is okay.
                //
                // ERROR_FILE_NOT_FOUND for BIND means one of the drivers
                // (above or below) wasn't started.  This is okay too.
                //
                if (ERROR_FILE_NOT_FOUND == dwError)
                {
                    Assert (S_OK == hr);
                }
                else
                {
                    g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ Error = %d\n", dwError);
                    hr = HRESULT_FROM_WIN32(dwError);
                }
            }
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "HrPnpBindOrUnbind: %s %s %S - %S\n",
        (NDIS == Layer) ? "NDIS" : "TDI",
        (BIND == Operation) ? "BIND" : "UNBIND",
        pszComponentBindName,
        pszBindString);
    return hr;
}

HRESULT
HrPnpUnloadDriver (
    IN UINT Layer,
    IN PCWSTR pszComponentBindName)
{
    HRESULT hr;
    UNICODE_STRING LowerString;
    UNICODE_STRING UpperString;
    UNICODE_STRING BindList;

    Assert ((NDIS == Layer) || (TDI == Layer));
    Assert (pszComponentBindName && *pszComponentBindName);

    hr = S_OK;

    TraceTag (ttidNetCfgPnp, "PnP Event: UNLOAD %S",
        pszComponentBindName);

    g_pDiagCtx->Printf (ttidBeDiag, "   PnP Event: UNLOAD %S\n",
        pszComponentBindName);

    RtlInitUnicodeString (&LowerString, NULL);
    RtlInitUnicodeString (&UpperString, pszComponentBindName);
    RtlInitUnicodeString (&BindList, NULL);

    NC_TRY
    {
        BOOL fOk;
        fOk = NdisHandlePnPEvent (
                Layer,
                UNLOAD,
                &LowerString,
                &UpperString,
                &BindList,
                NULL, 0);

        if (!fOk)
        {
            DWORD dwError = GetLastError();

            // ERROR_GEN_FAILURE for UNLOAD means the driver does not
            // support UNLOAD.  This is okay.
            //
            if (ERROR_GEN_FAILURE == dwError)
            {
                g_pDiagCtx->Printf (ttidBeDiag, "      %S does not support UNLOAD. "
                    "(Okay)\n",
                    pszComponentBindName);

                Assert (S_OK == hr);
            }
            else
            {
                g_pDiagCtx->Printf (ttidBeDiag, "      ^^^ Error = %d\n", dwError);
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }

    // UNLOADs are informational, so we do not trace any errors.
    //
    //TraceHr (ttidError, FAL, hr, FALSE,
    //    "HrPnpUnloadDriver: UNLOAD %S\n",
    //    pszComponentBindName);
    return hr;
}

VOID
CRegistryBindingsContext::PnpBindOrUnbindBindPaths (
    IN UINT Operation,
    IN const CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded)
{
    HRESULT hr;
    const CBindPath* pBindPath;
    CBindPath::const_iterator iter;
    const CComponent* pComponent;
    WCHAR szBind [_MAX_BIND_LENGTH];
    UINT Layer;

    Assert ((BIND == Operation) || (UNBIND == Operation));
    Assert (pBindSet);
    Assert (pfRebootNeeded);

    *pfRebootNeeded = FALSE;

    for (pBindPath  = pBindSet->begin();
         pBindPath != pBindSet->end();
         pBindPath++)
    {
        Assert (pBindPath->CountComponents() > 1);

        // Special case for multiple interfaces.  Unless this is the
        // length 2 bindpath of protocol to adapter (e.g. tcpip->ndiswanip),
        // check to see if the adapter on this bindpath expose multiple
        // interfaces from its protocol.  If it does, we're going to skip
        // sending bind notifications.
        //
        // The reason we only do this for bindpaths of length greater than
        // two is because the protocol exposes multiple-interfaces but does
        // not deal with them in its direct binding (i.e. length 2) to the
        // adapter.
        //
        // Note: in future versions, we may not want to skip it.  We do so
        // for now because the legacy binding engine skips them and these
        // bindings aren't active until RAS calls are made anyhow.
        //
        if (pBindPath->CountComponents() > 2)
        {
            const CComponent* pAdapter;
            DWORD cInterfaces;

            // Get the last component in the bindpath and the component
            // just above that.  The last component is the adapter,
            // and the one above the adapter is the protocol.
            //
            iter = pBindPath->end();
            Assert (iter - 2 > pBindPath->begin());

            pComponent = *(iter - 2);
            pAdapter   = *(iter - 1);
            Assert (pComponent);
            Assert (pAdapter);
            Assert (pAdapter == pBindPath->PLastComponent());

            // Calling HrGetInterfaceIdsForAdapter requires the INetCfgComponent
            // interface for the adapter.  If we don't have it, it is likely
            // because the adapter has been removed in which case we don't
            // need to bother asking about how many interfaces it supports.
            //
            if (pComponent->m_pIComp && pAdapter->m_pIComp)
            {
                hr = pComponent->Notify.HrGetInterfaceIdsForAdapter (
                        m_pNetConfig->Notify.PINetCfg(),
                        pAdapter,
                        &cInterfaces,
                        NULL);

                // If multiple interfaces supported for the adapter,
                // continue to the next bindpath.
                //
                if (S_OK == hr)
                {
                    continue;
                }

                // On S_FALSE or an error, continue below.
                hr = S_OK;
            }
        }

        wcscpy (szBind, L"\\Device\\");

        // Skip the first component in each path because it is the
        // component we are issuing the BIND/UNBIND for.
        //
        for (iter  = pBindPath->begin() + 1;
             iter != pBindPath->end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Assert there is enough room in the bind buffer.
            //
            Assert (wcslen(szBind) + 1 + wcslen(pComponent->Ext.PszBindName())
                        < celems(szBind));

            // If this isn't the first component to come after \Device\,
            // add underscores to seperate the components.
            //
            if (iter != (pBindPath->begin() + 1))
            {
                wcscat (szBind, L"_");
            }

            wcscat (szBind, pComponent->Ext.PszBindName());
        }

        Layer = GetPnpLayerForBindPath (pBindPath);

        hr = HrPnpBindOrUnbind (
                Layer,
                Operation,
                pBindPath->POwner()->Ext.PszBindName(),
                szBind);

        if (S_OK != hr)
        {
            *pfRebootNeeded = TRUE;
        }
    }
}

VOID
PruneNdisWanBindPathsIfActiveRasConnections (
    IN CBindingSet* pBindSet,
    OUT BOOL* pfRebootNeeded)
{
    CBindPath* pBindPath;
    UINT Layer;
    BOOL fExistActiveRasConnections;

    Assert (pBindSet);
    Assert (pfRebootNeeded);

    *pfRebootNeeded = FALSE;

    // Special case for binding/unbinding from ndiswan miniports while
    // active RAS connections exist.  (Don't do it.)  (BUG 344504)
    // (Binding will be to the NDIS layer, the bindpath will have two
    // components, and the service of the last component will be NdisWan.
    // (These are ndiswan miniport devices that behave badly if we
    // unbind them while active connections exist.  Binding them also
    // can disconnect any connections they might be running.)
    // Order of the if is to do the inexpensive checks first.
    //

    if (!FExistActiveRasConnections ())
    {
        return;
    }

    pBindPath  = pBindSet->begin();
    while (pBindPath != pBindSet->end())
    {
        Assert (pBindPath->CountComponents() > 1);

        Layer = GetPnpLayerForBindPath (pBindPath);

        if ((2 == pBindPath->CountComponents()) &&
            (NDIS == Layer) &&
            (0 == _wcsicmp (L"NdisWan", pBindPath->back()->Ext.PszService())))
        {
            g_pDiagCtx->Printf (ttidBeDiag, "   Skipping PnP BIND/UNBIND for  %S -> %S  (active RAS connections)\n",
                pBindPath->POwner()->Ext.PszBindName(),
                pBindPath->back()->Ext.PszBindName());

            *pfRebootNeeded = TRUE;

            pBindSet->erase (pBindPath);
        }
        else
        {
            pBindPath++;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\provider.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       P R O V I D E R . C P P
//
//  Contents:   Net component installer functions for Net providers.
//
//  Notes:
//
//  Author:     billbe   22 Mar 1997
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include "provider.h"
#include "winspool.h"
#include "ncmisc.h"

// constants
//

extern const WCHAR c_szDevice[];
extern const WCHAR c_szProviderOrder[];
extern const WCHAR c_szRegKeyCtlNPOrder[];
extern const WCHAR c_szRegKeyServices[];

const WCHAR c_chComma                       = L',';
const WCHAR c_szDeviceName[]                = L"DeviceName";
const WCHAR c_szDisplayName[]               = L"DisplayName";
const WCHAR c_szInfKeyPrintProviderDll[]    = L"PrintProviderDll";
const WCHAR c_szInfSubKeyPrintProvider[]    = L"PrintProvider";
const WCHAR c_szNetworkProvider[]           = L"NetworkProvider";
const WCHAR c_szPrintProviderName[]         = L"PrintProviderName";
const WCHAR c_szRegKeyPrintProviders[]      = L"System\\CurrentControlSet\\Control\\Print\\Providers";
const WCHAR c_szRegKeyShortName[]           = L"System\\CurrentControlSet\\Control\\NetworkProvider\\ShortName";
const WCHAR c_szRegValueName[]              = L"Name";
const WCHAR c_szRegValueOrder[]             = L"Order";
const WCHAR c_szShortName[]                 = L"ShortName";


// Functions
//
HRESULT
HrCiCreateShortNameValueIfNeeded(HINF hinf, HKEY hkeyNetworkProvider,
                                 const tstring& strSection,
                                 tstring* pstrShortName);

HRESULT
HrCiSetDeviceName(HINF hinf, HKEY hkeyNetworkProvider,
                  const tstring& strSection, const tstring& strServiceName);

HRESULT
HrCiWritePrintProviderInfoIfNeeded(HINF hinfFile, const tstring& strSection,
                                   HKEY hkeyInstance, DWORD dwPrintPosition);

HRESULT
HrCiAddPrintProvider(const tstring& strName, const tstring& strDllName,
                     const tstring& strDisplayName, DWORD dwPrintPosition);

HRESULT
HrCiDeletePrintProviderIfNeeded(HKEY hkeyInstance, DWORD* pdwProviderPosition);


//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddNetProviderInfo
//
//  Purpose:    Adds the current component to the list of network
//                  providers and also adds it as a print provider if
//                  necessary.
//
//  Arguments:
//      hinf                    [in] Handle to component's inf file
//      strSection              [in] Main inf section
//      hkeyInstance            [in] Component's instance key
//      fPreviouslyInstalled    [in] TRUE if this component is being
//                                      reinstalled, FALSE otherwise
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiAddNetProviderInfo(HINF hinf, PCWSTR pszSection,
                       HKEY hkeyInstance, BOOL fPreviouslyInstalled)
{
    Assert(IsValidHandle(hinf));
    Assert(pszSection);
    Assert(hkeyInstance);

    //tstring strServiceName;
    DWORD   dwNetworkPosition = 0; // default position is the front.
    DWORD   dwPrintPosition = 0; // default position is the front.

    if (fPreviouslyInstalled)
    {
        // Because the inf may contain modifications to the print provider.
        // e.g. Display name change, dll name change, etc.  We delete it
        // then readd.  We would like to just update the information
        // but the print provider api doesn't support it yet.  Until
        // then, we need to delete and readd to pick up changes.
        //
        (void) HrCiDeleteNetProviderInfo(hkeyInstance, &dwNetworkPosition,
                &dwPrintPosition);
        TraceTag(ttidClassInst, "Upgrading provider info. Net Prov Pos %d "
                 "Print Prov Pos %d", dwNetworkPosition, dwPrintPosition);
    }

    // Get the service name for this component
    WCHAR szServiceName[MAX_SERVICE_NAME_LEN];
    DWORD cbServiceName = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);

    HKEY hkeyNdi;
    HRESULT hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

    if (S_OK == hr)
    {
        hr = HrRegQuerySzBuffer (
            hkeyNdi,
            L"Service",
            szServiceName,
            &cbServiceName);
        RegCloseKey (hkeyNdi);
    }

    if (S_OK == hr)
    {
        // If this is Webclient we need to make sure it is after
        // lanmanworkstation in the ordering.  This should be temporary
        // until mpr.dll is updated to return the union of provider
        // information.  Right now a server can source smb shares and
        // webclient shares but only one set can be retrieved via the mpr.
        // Since smb shares are more common, lanmanworkstation needs to be
        // before webclient.  When mpr.dll changes, both sets will be returned
        // and ordering shouldn't matter (expect for performance).
        //
        if (0 == lstrcmpiW(szServiceName, L"WebClient"))
        {
            HKEY hkeyNP;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
                KEY_READ, &hkeyNP);
            if (S_OK == hr)
            {
                PWSTR Order;
                hr = HrRegQuerySzWithAlloc(hkeyNP, c_szProviderOrder, &Order);

                if (S_OK == hr)
                {
                    DWORD dwPosition;
                    if (FFindStringInCommaSeparatedList(L"LanmanWorkstation",
                            Order, NC_IGNORE, &dwPosition))
                    {
                        dwNetworkPosition = dwPosition + 1;
                    }
                    MemFree(Order);
                }
                RegCloseKey(hkeyNP);
            }
        }

        TraceTag(ttidClassInst, "Adding %S to the network provider "
                 "order at position %d\n", szServiceName, dwNetworkPosition);

        // Add it to the list of network providers
        hr = HrRegAddStringToSz(szServiceName, HKEY_LOCAL_MACHINE,
                c_szRegKeyCtlNPOrder, c_szProviderOrder,
                c_chComma, STRING_FLAG_ENSURE_AT_INDEX, dwNetworkPosition);

        if (S_OK == hr)
        {
            tstring strNetworkProvider = c_szRegKeyServices;
            strNetworkProvider.append(L"\\");
            strNetworkProvider.append(szServiceName);
            strNetworkProvider.append(L"\\");
            strNetworkProvider.append(c_szNetworkProvider);

            // Open the NetworkProvider key under the component's
            // service key
            //
            HKEY hkey;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                    strNetworkProvider.c_str(), KEY_SET_VALUE | KEY_READ,
                    &hkey);

            if (S_OK == hr)
            {
                // Check if shortname is needed.
                // by looking for it in the option
                // <main install section>.NetworkProvider section
                //
                tstring strNetworkSection(pszSection);
                strNetworkSection += L'.';
                strNetworkSection += c_szNetworkProvider;

                tstring strShortName;
                hr = HrCiCreateShortNameValueIfNeeded(hinf,
                        hkey, strNetworkSection, &strShortName);

                if (S_OK == hr)
                {
                    // If shortname was created then we need to
                    // also store it under the instance
                    // key so we can remove it when the component
                    // is removed
                    (void) HrRegSetString(hkeyInstance,
                            c_szShortName, strShortName);
                }

                // Set the device name in the NetworkProvider key
                // under the componet's service key
                //
                if (SUCCEEDED(hr))
                {
                    hr = HrCiSetDeviceName(hinf, hkey, strNetworkSection,
                            szServiceName);
                }

                RegCloseKey(hkey);
            }
        }
    }

    // Write out any print provider information if the inf file specifies it
    //
    if (S_OK == hr)
    {
        hr = HrCiWritePrintProviderInfoIfNeeded(hinf, pszSection,
                hkeyInstance, dwPrintPosition);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddNetProviderInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiDeleteNetProviderInfo
//
//  Purpose:    Deletes the current component from the list of network
//                  providers and also deletes it as a print provider if
//                  necessary.
//
//  Arguments:
//      hkeyInstance       [in] The handle to the component's isntance key.
//      pdwNetworkPosition [out] Optional. The positon pf this component in
//                               the network provider order before removal.
//      pdwPrintPosition   [out] Optional. The positon of this component in
//                               the print provider order before removal.
//
//  Returns:    HRESULT. S_OK if successful, an error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiDeleteNetProviderInfo(HKEY hkeyInstance, DWORD* pdwNetworkPosition,
        DWORD* pdwPrintPosition)
{
    Assert(hkeyInstance);

    // Initialize out param.
    if (pdwNetworkPosition)
    {
        *pdwNetworkPosition = 0;
    }

    // Initialize out param.
    if (pdwPrintPosition)
    {
        *pdwPrintPosition = 0;
    }

    WCHAR szServiceName[MAX_SERVICE_NAME_LEN];
    DWORD cbServiceName = MAX_SERVICE_NAME_LEN * sizeof(WCHAR);
    // Get the service name for this component.

    HKEY hkeyNdi;
    HRESULT hr = HrRegOpenKeyEx (hkeyInstance, L"Ndi", KEY_READ, &hkeyNdi);

    if (S_OK == hr)
    {
        hr = HrRegQuerySzBuffer (
            hkeyNdi,
            L"Service",
            szServiceName,
            &cbServiceName);
        RegCloseKey(hkeyNdi);
    }

    if (S_OK == hr)
    {
        // Open the network provider key.
        //
        HKEY hkeyNetProvider;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyCtlNPOrder,
                KEY_READ_WRITE, &hkeyNetProvider);

        if (S_OK == hr)
        {
            PWSTR pszOrder = NULL;
            PWSTR pszNewOrder;
            DWORD dwNetPos;

            // Get the current list of providers.
            //
            hr = HrRegQuerySzWithAlloc(hkeyNetProvider,
                    c_szProviderOrder, &pszOrder);

            // If we managed to get the list and the provider we are
            // removing is in the list...
            //
            if ((S_OK == hr) && FFindStringInCommaSeparatedList(
                    szServiceName, pszOrder,
                    NC_IGNORE, &dwNetPos))
            {
                // Remove the provider from the list.
                hr = HrRemoveStringFromDelimitedSz(szServiceName,
                        pszOrder, c_chComma, STRING_FLAG_REMOVE_ALL,
                        &pszNewOrder);

                if (S_OK == hr)
                {
                    // Set the new provider list back in the registry.
                    (void) HrRegSetSz(hkeyNetProvider, c_szProviderOrder,
                            pszNewOrder);
                    MemFree (pszNewOrder);
                }

                // If the out param was specified, set the position.
                //
                if (pdwNetworkPosition)
                {
                    *pdwNetworkPosition = dwNetPos;
                }
            }
            MemFree(pszOrder);
            RegCloseKey(hkeyNetProvider);
        }


        if (S_OK == hr)
        {
            // If short name was used, we need to remove it
            //
            tstring strShortName;
            hr = HrRegQueryString(hkeyInstance, c_szShortName, &strShortName);

            if (S_OK == hr)
            {
                // ShortName was used so remove it
                //
                HKEY hkey;
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyShortName,
                        KEY_SET_VALUE, &hkey);

                if (S_OK == hr)
                {
                    hr = HrRegDeleteValue(hkey, strShortName.c_str());

                    // delete from our instance key as well
                    // Note: we do this because if this component is being
                    // reinstalled, the new inf might not have shortname so
                    // we don't want the old value lying around
                    (void) HrRegDeleteValue(hkeyInstance, c_szShortName);

                    RegCloseKey(hkey);
                }

            }

            // If the value wasn't there (in the driver key or the ShortName key,
            // then there is nothing to delete and everything is okay
            if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
            {
                hr = S_OK;
            }
        }
    }


    // Delete this component as a print provider if necessary
    //
    if (S_OK == hr)
    {
        hr = HrCiDeletePrintProviderIfNeeded(hkeyInstance, pdwPrintPosition);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDeleteNetProviderInfo");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiCreateShortNameValueIfNeeded
//
//  Purpose:    Creates the short name value for the component under
//                  the c_szRegKeyShortName registry key if short name is
//                  present in the inf.  The short name value is set to the
//                  display name as found in the NetworkProvider key under
//                  the component's service key
//
//  Arguments:
//      hinf                    [in]  Handle to the component's inf
//      hkeyNetworkProvider     [in]  The hkey to the NetworkProvider
//                                      key under the component's service
//                                      key
//      strSection              [in]  The section name where ShortName
//                                       would be located
//      pstrShortName           [out] The short name found in the inf
//
//  Returns:    HRESULT. S_OK if shortname found, S_FALSE if no shortname was
//                  found, or error code otherwise.
//
//  Author:     billbe  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiCreateShortNameValueIfNeeded(HINF hinf, HKEY hkeyNetworkProvider,
                                 const tstring& strSection,
                                 tstring* pstrShortName)
{
    Assert(IsValidHandle(hinf));
    Assert(hkeyNetworkProvider);
    Assert(!strSection.empty());
    Assert(pstrShortName);

    INFCONTEXT ctx;

    // Look for optional shortname
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szShortName, &ctx);

    if (SUCCEEDED(hr))
    {
        // Get the shortname value
        hr = HrSetupGetStringField(ctx, 1, pstrShortName);

        if (SUCCEEDED(hr))
        {
            HKEY hkey;
            // Create the ShortName key
            hr = HrRegCreateKeyEx(HKEY_LOCAL_MACHINE,
                    c_szRegKeyShortName, REG_OPTION_NON_VOLATILE,
                    KEY_SET_VALUE, NULL, &hkey, NULL);

            if (SUCCEEDED(hr))
            {
                // Get the provider name to set the short name value
                //
                tstring strProviderName;
                hr = HrRegQueryString(hkeyNetworkProvider, c_szRegValueName,
                        &strProviderName);

                if (SUCCEEDED(hr))
                {
                    // create the component's short name value under
                    // the ShortName key and set it to the component's
                    // display name
                    hr = HrRegSetString(hkey, pstrShortName->c_str(),
                            strProviderName);
                }
                RegCloseKey(hkey);
            }
        }
    }

    // The line and section were optional so if it didn't exists return S_FALSE
    if ((SPAPI_E_LINE_NOT_FOUND == hr) ||
            (SPAPI_E_BAD_SECTION_NAME_LINE == hr))
    {
        hr = S_FALSE;
    }

    // On failure, initialize the out param
    if (FAILED(hr))
    {
        pstrShortName->erase();
    }

    TraceHr (ttidError, FAL, hr, S_FALSE == hr,
            "HrCiCreateShortNameValueIfNeeded");
    return hr;

}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiSetDeviceName
//
//  Purpose:    Creates the device name value for the component under
//                  the NetworkProvider key located in the component's
//                  service key. The device name by default is
//                  \Device\<component's service name> unless the inf
//                  specifies a new device name.
//
//  Arguments:
//      hinf                    [in]  Handle to the component's inf
//      hkeyNetworkProvider     [in]  The hkey to the NetworkProvider
//                                      key under the component's service
//                                      key
//      strSection              [in]  The section name where ShortName
//                                       would be located
//      strServiceName          [in]  The component's service name
//
//  Returns:    HRESULT. S_OK if successful, or error code otherwise.
//
//  Author:     billbe  7 Oct 1997
//
//  Notes:
//
HRESULT
HrCiSetDeviceName(HINF hinf, HKEY hkeyNetworkProvider,
                  const tstring& strSection, const tstring& strServiceName)
{
    Assert(IsValidHandle(hinf));
    Assert(hkeyNetworkProvider);

    INFCONTEXT ctx;
    tstring strDeviceName = c_szDevice;

    // Look for optional DeviceName
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szDeviceName, &ctx);

    if (SUCCEEDED(hr))
    {
        tstring strName;
        // Get the DeviceName value
        hr = HrSetupGetStringField(ctx, 1, &strName);

        if (SUCCEEDED(hr))
        {
            // append it to the current value
            strDeviceName.append(strName);
        }
    }

    // If the device name line was not found in the inf (or the
    // section name wasn't found), use the service name
    //
    if ((SPAPI_E_LINE_NOT_FOUND == hr) ||
            (SPAPI_E_BAD_SECTION_NAME_LINE == hr))
    {
        strDeviceName.append(strServiceName);
        hr = S_OK;
    }

    if (SUCCEEDED(hr))
    {
        // Now set the device name value in the service's networkprovider key
        hr = HrRegSetString(hkeyNetworkProvider, c_szDeviceName,
                strDeviceName);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiSetDeviceName");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiGetPrintProviderInfoFromInf
//
//  Purpose:    This function gets the display name and dll name from
//                  the print provider section strSection.
//
//  Arguments:
//      hinf            [in] handle to inf file. See SetupApi for more info
//      strSection      [in]  The print provider section name
//      pstrName        [out] The print provider name found in the inf
//      pstrDll         [out] The dll name found in the inf
//      pstrDisplayName [out] The localized display name found in the inf
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe  24 Oct 1997
//
//  Notes:
HRESULT
HrCiGetPrintProviderInfoFromInf(HINF hinf, tstring strSection, tstring* pstrName,
                                tstring* pstrDll, tstring* pstrDisplayName)
{
    Assert(!strSection.empty());
    Assert(pstrName);
    Assert(pstrDll);
    Assert(pstrDisplayName);

    INFCONTEXT ctx;

    // find the line containing non-localized ProviderName
    HRESULT hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
            c_szPrintProviderName, &ctx);

    if (S_OK == hr)
    {
        // Get the ProviderName
        hr = HrSetupGetStringField(ctx, 1, pstrName);

        if (S_OK == hr)
        {
            // Now find and get the PrintProviderDll value
            //
            hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
                    c_szInfKeyPrintProviderDll, &ctx);

            if (S_OK == hr)
            {
                hr = HrSetupGetStringField(ctx, 1, pstrDll);

                if (S_OK == hr)
                {
                    // find the line containing DisplayName
                    hr = HrSetupFindFirstLine(hinf, strSection.c_str(),
                            c_szDisplayName, &ctx);

                    if (S_OK == hr)
                    {
                        // Get the DisplayName
                        hr = HrSetupGetStringField(ctx, 1, pstrDisplayName);
                    }
                }
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiGetPrintProviderInfoFromInf");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   HrCiWritePrintProviderInfoIfNeeded
//
//  Purpose:    This function updates necessary registry entries for
//                  NETCLIENT class components that are print providers.
//
//  Arguments:
//      hinf            [in] handle to inf file. See SetupApi for more info.
//      strSection      [in] The main section name.
//      hkeyInstance    [in] The hkey to the component's instance key.
//      dwPrintPosition [in] The position to place the print provider when
//                           it is added to the list.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes:
HRESULT
HrCiWritePrintProviderInfoIfNeeded(HINF hinf, const tstring& strSection,
                                   HKEY hkeyInstance, DWORD dwPrintPosition)
{
    Assert(IsValidHandle(hinf));
    Assert(!strSection.empty());
    Assert(hkeyInstance);

    HRESULT     hr = S_OK;
    INFCONTEXT  ctx;
    tstring     strDisplayName;
    tstring     strName;
    tstring     strPrintProviderDll;
    tstring     strPrintSection(strSection);

    strPrintSection.append(L".");
    strPrintSection.append(c_szInfSubKeyPrintProvider);

    // First we check for the PrintProvider inf section
    hr = HrSetupFindFirstLine(hinf, strPrintSection.c_str(),  NULL,
            &ctx);

    if (S_OK == hr)
    {
        // Get the print provider information from the inf
        hr = HrCiGetPrintProviderInfoFromInf(hinf, strPrintSection,
                &strName, &strPrintProviderDll, &strDisplayName);

        if (S_OK == hr)
        {
            // Add the component as a print provider
            hr = HrCiAddPrintProvider(strName, strPrintProviderDll,
                    strDisplayName, dwPrintPosition);

            // Now write the Provider name under our instance key
            // so we can remove this provider when asked
            if (S_OK == hr)
            {
                (void) HrRegSetString(hkeyInstance,
                        c_szPrintProviderName, strName);
            }
        }
    }
    else
    {
        // The section is optional so this is not an error
        if (SPAPI_E_LINE_NOT_FOUND == hr)
        {
            hr = S_OK;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiWritePrintProviderInfoIfNeeded");
    return hr;
}

//+--------------------------------------------------------------------------
//
//  Function:   MoveProviderToIndex
//
//  Purpose:    This function moves the pszProviderName to the position
//              specified.
//
//  Arguments:
//      pszProviderName [in] Name of the print provider (used in call to
//                           AddPrintProvidor.
//      dwPrintPosition [in] The index to place this provider in the
//                           provider order.
//
//  Returns:    nothing
//
//  Author:     billbe   6 Oct 1998
//
//  Notes:
//
VOID
MoveProviderToIndex (
    IN PCWSTR pszProviderName,
    IN DWORD dwPrintPosition)
{
    PROVIDOR_INFO_2  p2info;

    // Open the print provider key
    //
    HKEY hkey;
    HRESULT hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyPrintProviders,
            KEY_READ, &hkey);

    if (S_OK == hr)
    {
        // Retrieve the current order
        //
        PWSTR pmszOrder;
        hr = HrRegQueryMultiSzWithAlloc(hkey, c_szRegValueOrder, &pmszOrder);

        if (S_OK == hr)
        {
            PWSTR pmszNewOrder;
            BOOL fChanged;

            // Move the provider to the front
            //
            hr = HrAddSzToMultiSz(pszProviderName, pmszOrder,
                    STRING_FLAG_ENSURE_AT_INDEX, dwPrintPosition,
                    &pmszNewOrder, &fChanged);

            if ((S_OK == hr) && fChanged)
            {
                // Notify Spooler that we want to change the order
                //
                p2info.pOrder = pmszNewOrder;
                if (!AddPrintProvidor(NULL, 2, (LPBYTE)&p2info))
                {
                    hr = HrFromLastWin32Error();
                    // If we removed duplicates, the last call to
                    // AddPrintProvidor may have failed with
                    // ERROR_INVALID_PARAMETER.  Trying again will correct
                    // the problem.
                    //
                    if (HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER) == hr)
                    {
                        AddPrintProvidor(NULL, 2,
                                reinterpret_cast<LPBYTE>(&p2info));
                    }

                    TraceHr (ttidError, FAL, hr, FALSE,
                            "AddPrintProvider(class 2) returned an error");
                }

                MemFree(pmszNewOrder);
            }

            MemFree(pmszOrder);
        }
        TraceHr (ttidError, FAL, hr, FALSE, "MoveProviderToIndex");

        RegCloseKey(hkey);
    }
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiAddPrintProvider
//
//  Purpose:    This function calls the AddPrintProvidor [sic] function
//                  to add the current component as a provider.
//
//  Arguments:
//      strName         [in] Name of the print provider (used in call to
//                           AddPrintProvidor.
//      strDllName      [in] Dll name of the print provider.
//      strDisplayName  [in] Localized Display Name.
//      dwPrintPosition [in] The position to place this provider when it
//                           is added to the list.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise.
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes: See AddPrintProvidor Win32 fcn for more info
HRESULT
HrCiAddPrintProvider(
    const tstring& strName,
    const tstring& strDllName,
    const tstring& strDisplayName,
    DWORD dwPrintPosition)
{
    Assert(!strName.empty());
    Assert(!strDllName.empty());

    PROVIDOR_INFO_1 pi1;
    HRESULT hr=S_OK;

    // Fill the structure with the relevant info
    //
    pi1.pEnvironment = NULL;
    pi1.pDLLName = (PWSTR)strDllName.c_str();
    pi1.pName = (PWSTR)strName.c_str();

    hr = HrEnableAndStartSpooler();
    if (S_OK == hr)
    {
        if (!AddPrintProvidor(NULL, 1, reinterpret_cast<LPBYTE>(&pi1)))
        {
            // convert the error
            hr = HrFromLastWin32Error();
        }
    }

    if (S_OK == hr)
    {
        // AddPrintProvidor adds the print provider to the end of list.
        // 99% of the time, the goal is to have the provider be somewhere
        // else.  We will attempt to move it to the position given to us. This
        // is either the beginning of the list or the previous position of
        // this provider (i.e. if we are reinstalling)  If it fails we can
        // still go on.
        (void) MoveProviderToIndex(pi1.pName, dwPrintPosition);

        tstring strPrintProvider = c_szRegKeyPrintProviders;
        strPrintProvider.append(L"\\");
        strPrintProvider.append(strName);

        HKEY hkey;
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE,
                strPrintProvider.c_str(),
                KEY_SET_VALUE, &hkey);

        if (S_OK == hr)
        {
            // Write DisplayName in the new key created by the
            // AddPrintProvidor [sic] call.
            // Not sure who the consumer of this value is but
            // the NT4 code did this
            hr = HrRegSetString(hkey, c_szDisplayName, strDisplayName);
            RegCloseKey(hkey);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiAddPrintProvider");
    return hr;
}


//+--------------------------------------------------------------------------
//
//  Function:   HrCiDeletePrintProviderIfNeeded
//
//  Purpose:    This function calls the DeletePrintProvidor [sic] function
//                  if this component was a print provider
//
//  Arguments:
//      hkeyInstance        [in] The hkey for the component's instance key.
//      pdwProviderPosition [out] Optional. The position of the print
//                                provider in the order list before it was
//                                deleted.
//
//  Returns:    HRESULT. S_OK if successful, error code otherwise
//
//  Author:     billbe   22 Mar 1997
//              updated   7 Oct 1997
//
//  Notes: See DeletePrintProvidor Win32 fcn for more info
//
HRESULT
HrCiDeletePrintProviderIfNeeded(HKEY hkeyInstance, DWORD* pdwProviderPosition)
{
    // Check if this component is a print provider
    //
    tstring strName;
    HRESULT hr = HrRegQueryString(hkeyInstance, c_szPrintProviderName,
            &strName);

    if (SUCCEEDED(hr))
    {
        // If the out param was specified, we may need to get the current position of this print provider
        // in the list of providers
        if (pdwProviderPosition)
        {
            *pdwProviderPosition = 0;

            // Open the print key
            //
            HKEY hkeyPrint;
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyPrintProviders,
                    KEY_READ, &hkeyPrint);

            if (SUCCEEDED(hr))
            {
                // Get the current order of providers
                //
                PWSTR pmszOrder;
                hr = HrRegQueryMultiSzWithAlloc(hkeyPrint,
                        c_szRegValueOrder, &pmszOrder);

                if (S_OK == hr)
                {
                    // Get this provider's current position
                    (void) FGetSzPositionInMultiSzSafe(
                            strName.c_str(), pmszOrder, pdwProviderPosition,
                            NULL, NULL);

                    MemFree(pmszOrder);
                }
                RegCloseKey(hkeyPrint);
            }
        }

        // The component was a print provider so we need to delete it as such
        //
        DeletePrintProvidor(NULL, NULL, (PWSTR)strName.c_str());

        // delete from our instance key as well
        // Note: we do this because if this component is being
        // reinstalled, the new inf might not have a providername so
        // we don't want the old value lying around
        (void) HrRegDeleteValue(hkeyInstance, c_szPrintProviderName);

    }
    else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        // This component was not a print provider so there
        // is nothing to remove
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrCiDeletePrintProviderIfNeeded");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\resource.h ===
#include <ncres.h>

#define IDS_NETCFG_AFD_SERVICE_DESC             (IDS_NC_NETCFG +  2)
#define IDS_SELECTDEVICEADAPTERINSTRUCTIONS     (IDS_NC_NETCFG +  3)
#define IDS_SELECTDEVICEADAPTERLISTLABEL        (IDS_NC_NETCFG +  4)
#define IDS_SELECTDEVICEADAPTERSUBTITLE         (IDS_NC_NETCFG +  5)
#define IDS_SELECTDEVICEADAPTERTITLE            (IDS_NC_NETCFG +  6)
#define IDS_SELECTDEVICECLIENTINSTRUCTIONS      (IDS_NC_NETCFG +  7)
#define IDS_SELECTDEVICECLIENTLISTLABEL         (IDS_NC_NETCFG +  8)
#define IDS_SELECTDEVICECLIENTTITLE             (IDS_NC_NETCFG +  9)
#define IDS_SELECTDEVICEINFRAREDINSTRUCTIONS    (IDS_NC_NETCFG + 10)
#define IDS_SELECTDEVICEINFRAREDLISTLABEL       (IDS_NC_NETCFG + 11)
#define IDS_SELECTDEVICEINFRAREDSUBTITLE        (IDS_NC_NETCFG + 12)
#define IDS_SELECTDEVICEINFRAREDTITLE           (IDS_NC_NETCFG + 13)
#define IDS_SELECTDEVICEPROTOCOLINSTRUCTIONS    (IDS_NC_NETCFG + 14)
#define IDS_SELECTDEVICEPROTOCOLLISTLABEL       (IDS_NC_NETCFG + 15)
#define IDS_SELECTDEVICEPROTOCOLTITLE           (IDS_NC_NETCFG + 16)
#define IDS_SELECTDEVICESERVICEINSTRUCTIONS     (IDS_NC_NETCFG + 17)
#define IDS_SELECTDEVICESERVICELISTLABEL        (IDS_NC_NETCFG + 18)
#define IDS_SELECTDEVICESERVICETITLE            (IDS_NC_NETCFG + 19)
#define IDS_HAVEDISK_INSTRUCTIONS               (IDS_NC_NETCFG + 20)

#define IDS_WARNING_CAPTION                     (IDS_NC_NETCFG + 22)
#define IDS_ACTIVE_RAS_CONNECTION_WARNING       (IDS_NC_NETCFG + 23)
#define IDS_POWER_MESSAGE_WAKE                  (IDS_NC_NETCFG + 24)

// Bug# 310358 
// MUI enabled HelpText for network components
// format: IDS_ComponentId_HELP_TEXT
// IDS_NC_COMP_HELP_TEXT is #define'ed as 50000. DON'T change this numbers 
// because inx files located in %sdxroot%\net\config\netcfg\inf depend on 
// these resource ids.
// Note: For component with Characteristics of NCF_HIDDEN, they don't need
//       to be MUI enabled. 
#define IDS_MS_TCPIP_HELP_TEXT                  (IDS_NC_COMP_HELP_TEXT + 1) 
#define IDS_MS_MSCLIENT_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 2) 
#define IDS_MS_SERVER_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 3)
#define IDS_MS_ATMARPS_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 4)
#define IDS_MS_APPLETALK_HELP_TEXT              (IDS_NC_COMP_HELP_TEXT + 5)
#define IDS_MS_ATMUNI_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 6)
#define IDS_MS_RELAYAGENT_HELP_TEXT             (IDS_NC_COMP_HELP_TEXT + 7)
#define IDS_MS_ATMELAN_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 9)
#define IDS_MS_ATMLANE_HELP_TEXT                (IDS_NC_COMP_HELP_TEXT + 10)
#define IDS_MS_NWCLIENT_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 12)
#define IDS_MS_NWIPX_HELP_TEXT                  (IDS_NC_COMP_HELP_TEXT + 13)
#define IDS_MS_NWNB_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 14)
#define IDS_MS_PSCHED_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 15)
#define IDS_MS_NWSAPAGENT_HELP_TEXT             (IDS_NC_COMP_HELP_TEXT + 16)
#define IDS_MS_FPNW_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 17)
#define IDS_MS_ISOTPSYS_HELP_TEXT               (IDS_NC_COMP_HELP_TEXT + 18)
#define IDS_MS_WLBS_HELP_TEXT                   (IDS_NC_COMP_HELP_TEXT + 19)
#define IDS_MS_NETMON_HELP_TEXT                 (IDS_NC_COMP_HELP_TEXT + 20)


// Do not change this number since external clients access this resource
#define IDI_INFRARED_ICON                       1401
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\regbind.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       R E G B I N D . C P P
//
//  Contents:   This module is responsible for writing bindings to the
//              registry so that they may be consumed by NDIS and TDI.
//
//  Notes:
//
//  Author:     shaunco   1 Feb 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "filtdevs.h"
#include "lanamap.h"
#include "netcfg.h"
#include "ncreg.h"
#include "ndispnp.h"


HRESULT
HrRegSetMultiSzAndLogDifference (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN PCWSTR pmszValue,
    IN const CComponent* pComponent
)
{
    // Only log the difference if we're operating under the appropriate
    // diagnostic context.
    //
    if (g_pDiagCtx->Flags() & DF_REPAIR_REGISTRY_BINDINGS)
    {
        HRESULT hr;
        DWORD cbCurrent;
        PWSTR pmszCurrent = (PWSTR)g_pDiagCtx->GetScratchBuffer(&cbCurrent);

        // Read the current value into the diagnostic context's scratch
        // buffer.
        //
        hr = HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_MULTI_SZ,
                                     pmszCurrent, &cbCurrent);

        // Grow the scratch buffer and retry if the value is bigger than
        // than will fit.
        //
        if ((HRESULT_FROM_WIN32(ERROR_MORE_DATA) == hr) ||
            ((NULL == pmszCurrent) && (S_OK == hr)))
        {
            pmszCurrent = (PWSTR)g_pDiagCtx->GrowScratchBuffer(&cbCurrent);
            if (pmszCurrent)
            {
                hr = HrRegQueryTypeSzBuffer (hkey, pszValueName, REG_MULTI_SZ,
                                             pmszCurrent, &cbCurrent);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }

        if (S_OK == hr)
        {
            DWORD cbValue = CbOfMultiSzAndTermSafe(pmszValue);

            // Compare the values and log if they are different.
            //
            if ((cbValue != cbCurrent) ||
                (memcmp(pmszValue, pmszCurrent, cbCurrent)))
            {
                FILE *LogFile = g_pDiagCtx->LogFile();

                fprintf(LogFile,
                        "reset   Linkage\\%S for %S.  bad value was:\n",
                        pszValueName, pComponent->PszGetPnpIdOrInfId());

                fprintf(LogFile, "            REG_MULTI_SZ =\n");
                if (*pmszCurrent)
                {
                    while (*pmszCurrent)
                    {
                        fprintf(LogFile, "                %S\n", pmszCurrent);
                        pmszCurrent += wcslen(pmszCurrent) + 1;
                    }
                }
                else
                {
                    fprintf(LogFile, "                <empty>\n");
                }
                fprintf(LogFile, "\n");
            }
            else
            {
                // The value is correct.  No need to write it.
                //
                return S_OK;
            }
        }
        else if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            fprintf(g_pDiagCtx->LogFile(),
                    "added   Linkage\\%S for %S\n",
                    pszValueName, pComponent->PszGetPnpIdOrInfId());
        }
    }

    // N.B. success or failure of the diagnostic portion of this routine
    // (above) should NOT affect the return value of this routine.
    //
    return HrRegSetMultiSz (hkey, pszValueName, pmszValue);
}

HRESULT
HrCreateLinkageKey (
    IN const CComponent* pComponent,
    IN CFilterDevice* pDevice,
    IN HDEVINFO hdi,
    OUT HKEY* phKey)
{
    HRESULT hr = E_UNEXPECTED;
    HKEY hkeyParent = NULL;
    CONST REGSAM samDesired = KEY_READ | KEY_WRITE;

    Assert (pComponent || pDevice);
    Assert (!(pComponent && pDevice));
    Assert (FIff(pDevice, hdi));
    Assert (phKey);

    if (pComponent)
    {
        // Open the parent of the linkage key.  This is the instance key if
        // the component is enumerated or does not have a service.
        //
        if (FIsEnumerated (pComponent->Class()) || !pComponent->FHasService())
        {
            hr = pComponent->HrOpenInstanceKey (samDesired,
                    &hkeyParent,
                    NULL, NULL);

            if ((S_OK == hr) && FIsEnumerated (pComponent->Class()))
            {
                // Write out the netcfg instance id. Connections will use
                // this to determine if the device is known by net config
                // and will create the <instance guid> key under network
                // to store its connection info. We only need to do this
                // for enumerated components.
                //
                hr = HrRegSetGuidAsSz (hkeyParent, L"NetCfgInstanceId",
                        pComponent->m_InstanceGuid);
            }
        }
        else
        {
            hr = pComponent->HrOpenServiceKey (samDesired, &hkeyParent);
        }
    }
    else
    {
        Assert (pDevice);
        Assert (hdi);

        hr = HrSetupDiOpenDevRegKey (
                hdi,
                &pDevice->m_deid,
                DICS_FLAG_GLOBAL,
                0,
                DIREG_DRV,
                samDesired,
                &hkeyParent);
    }

    if (S_OK == hr)
    {
        Assert (hkeyParent);

        hr = HrRegCreateKeyEx (
                hkeyParent,
                L"Linkage",
                REG_OPTION_NON_VOLATILE,
                samDesired,
                NULL,
                phKey,
                NULL);

        RegCloseKey (hkeyParent);
    }

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "HrCreateLinkageKey");
    return hr;
}

HRESULT
HrWriteLinkageValues (
    IN const CComponent* pComponent,
    IN PCWSTR pmszBind,
    IN PCWSTR pmszExport,
    IN PCWSTR pmszRoute)
{
    HRESULT hr;
    HKEY hkeyLinkage;
    PCWSTR pmsz;

    Assert (pmszBind);
    Assert (pmszExport);
    Assert (pmszRoute);

    g_pDiagCtx->Printf (ttidBeDiag, "   %S  (%S)\n",
        pComponent->Ext.PszBindName(),
        pComponent->PszGetPnpIdOrInfId());

    if (FIsEnumerated (pComponent->Class()))
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      UpperBind:\n");
    }
    else
    {
        g_pDiagCtx->Printf (ttidBeDiag, "      Bind:\n");
    }

    pmsz = pmszBind;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      Export:\n");
    pmsz = pmszExport;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");

    hr = HrCreateLinkageKey (pComponent, NULL, NULL, &hkeyLinkage);

    if (S_OK == hr)
    {
        // For enumerated components, write RootDevice, UpperBind, and Export.
        // For non-enumerated components, write Bind and Export.
        //
        if (FIsEnumerated (pComponent->Class()))
        {
            // Create the root device multi-sz from the bindname.
            //
            WCHAR mszRootDevice [_MAX_PATH];
            wcscpy (mszRootDevice, pComponent->Ext.PszBindName());
            mszRootDevice [wcslen(mszRootDevice) + 1] = 0;

            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"RootDevice", mszRootDevice, pComponent);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSzAndLogDifference (
                        hkeyLinkage, L"UpperBind", pmszBind, pComponent);
            }
        }
        else
        {
            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"Bind", pmszBind, pComponent);

            if (S_OK == hr)
            {
                hr = HrRegSetMultiSzAndLogDifference (
                        hkeyLinkage, L"Route", pmszRoute, pComponent);
            }
        }

        if ((S_OK == hr) && *pmszExport)
        {
            hr = HrRegSetMultiSzAndLogDifference (
                    hkeyLinkage, L"Export", pmszExport, pComponent);
        }

        RegCloseKey (hkeyLinkage);
    }

    TraceHr (ttidError, FAL, hr,
        (SPAPI_E_NO_SUCH_DEVINST == hr),
        "HrWriteLinkageValues");
    return hr;
}

HRESULT
HrWriteFilterDeviceLinkage (
    IN CFilterDevice* pDevice,
    IN HDEVINFO hdi,
    IN PCWSTR pmszExport,
    IN PCWSTR pmszRootDevice,
    IN PCWSTR pmszUpperBind)
{
    HRESULT hr;
    HKEY hkeyLinkage;
    PCWSTR pmsz;

    g_pDiagCtx->Printf (ttidBeDiag, "   %S filter over %S adapter\n",
        pDevice->m_pFilter->m_pszInfId,
        pDevice->m_pAdapter->m_pszPnpId);

    g_pDiagCtx->Printf (ttidBeDiag, "      Export:\n");
    pmsz = pmszExport;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      RootDevice:\n");
    pmsz = pmszRootDevice;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }

    g_pDiagCtx->Printf (ttidBeDiag, "      UpperBind:\n");
    pmsz = pmszUpperBind;
    while (*pmsz)
    {
        g_pDiagCtx->Printf (ttidBeDiag, "         %S\n", pmsz);
        pmsz += wcslen (pmsz) + 1;
    }
    g_pDiagCtx->Printf (ttidBeDiag, "\n");

    hr = HrCreateLinkageKey (NULL, pDevice, hdi, &hkeyLinkage);

    if (S_OK == hr)
    {
        hr = HrRegSetMultiSz (hkeyLinkage, L"Export", pmszExport);

        if (S_OK == hr)
        {
            hr = HrRegSetMultiSz (hkeyLinkage, L"RootDevice", pmszRootDevice);
        }

        if (S_OK == hr)
        {
            hr = HrRegSetMultiSz (hkeyLinkage, L"UpperBind", pmszUpperBind);
        }

        // Delete values used by the previous binding engine that are
        // not needed any longer.
        //
        RegDeleteValue (hkeyLinkage, L"BindPath");
        RegDeleteValue (hkeyLinkage, L"Bind");
        RegDeleteValue (hkeyLinkage, L"Route");
        RegDeleteKey   (hkeyLinkage, L"Disabled");

        RegCloseKey (hkeyLinkage);
    }

    // Now write to the standard filter parameter registry layout under
    // the filter's service key.
    //

    if (pDevice->m_pFilter->Ext.PszService())
    {
        HKEY hkeyAdapterParams;
        WCHAR szRegPath [_MAX_PATH];

        Assert (pDevice->m_pFilter->Ext.PszService());
        Assert (pDevice->m_pAdapter->Ext.PszBindName());

        wsprintfW (
            szRegPath,
            L"System\\CurrentControlSet\\Services\\%s\\Parameters\\Adapters\\%s",
            pDevice->m_pFilter->Ext.PszService(),
            pDevice->m_pAdapter->Ext.PszBindName());

        hr = HrRegCreateKeyEx (
                HKEY_LOCAL_MACHINE,
                szRegPath,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hkeyAdapterParams,
                NULL);

        if (S_OK == hr)
        {
            // UpperBindings is a REG_SZ, not a REG_MULTI_SZ.
            //
            hr = HrRegSetSz (hkeyAdapterParams, L"UpperBindings", pmszExport);

            RegCloseKey (hkeyAdapterParams);
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteFilterDeviceLinkage");
    return hr;
}

HRESULT
HrWriteFilteredAdapterUpperBind (
    IN const CComponent* pAdapter,
    IN PCWSTR pmszUpperBind)
{
    HRESULT hr;
    HKEY hkeyLinkage;

    hr = HrCreateLinkageKey (pAdapter, NULL, NULL, &hkeyLinkage);

    if (S_OK == hr)
    {
        hr = HrRegSetMultiSz (hkeyLinkage, L"UpperBind", pmszUpperBind);

        RegCloseKey (hkeyLinkage);
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrWriteFilteredAdapterUpperBind");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrPrepare (
    IN CNetConfig* pNetConfig)
{
    HRESULT hr;

    Assert (pNetConfig);
    m_pNetConfig = pNetConfig;

    hr = m_BindValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    hr = m_ExportValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    hr = m_RouteValue.HrReserveBytes (4096);
    if (S_OK != hr)
    {
        return hr;
    }

    // Ensure all of the external data for all components is loaded.
    //
    hr = m_pNetConfig->HrEnsureExternalDataLoadedForAllComponents ();
    if (S_OK != hr)
    {
        return hr;
    }

    // Ensure all of the notify objects have been initialized.
    //
    hr = m_pNetConfig->Notify.HrEnsureNotifyObjectsInitialized ();
    if (S_OK != hr)
    {
        return hr;
    }

    return S_OK;
}

HRESULT
CRegistryBindingsContext::HrDeleteBindingsForComponent (
    IN const CComponent* pComponent)
{
    return HrWriteLinkageValues (pComponent, L"", L"", L"");
}

HRESULT
CRegistryBindingsContext::HrGetAdapterUpperBindValue (
    IN const CComponent* pAdapter)
{
    HRESULT hr;
    const CBindPath* pBindPath;

    m_BindValue.Clear();

    // Get the upper bindings of the component.  This returns a bindset
    // with binpaths only 2 levels deep.  That is, the bindpaths begin
    // with the components one level above pComponent.
    //
    hr = m_pNetConfig->Core.HrGetComponentUpperBindings (
            pAdapter,
            GBF_PRUNE_DISABLED_BINDINGS,
            &m_BindSet);

    if (S_OK == hr)
    {
        for (pBindPath  = m_BindSet.begin();
             pBindPath != m_BindSet.end();
             pBindPath++)
        {
            // Don't put filters in the UpperBind of an adapter.
            //
            if (pBindPath->POwner()->FIsFilter())
            {
                continue;
            }

            hr = m_BindValue.HrCopyString (
                    pBindPath->POwner()->Ext.PszBindName());
            if (S_OK != hr)
            {
                break;
            }
        }

        hr = m_BindValue.HrCopyString (L"");
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrGetAdapterUpperBindValue");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrWriteBindingsForComponent (
    IN const CComponent* pComponent)
{
    HRESULT hr;
    const CBindPath* pBindPath;
    CBindPath::const_iterator iter;
    const CComponent* pUpper;
    const CComponent* pLower;
    WCHAR szBind [_MAX_BIND_LENGTH];
    WCHAR szExport [_MAX_BIND_LENGTH];
    WCHAR szRoute [_MAX_BIND_LENGTH];
    PWCHAR pchBind;
    PWCHAR pchExport;

    Assert (pComponent);
    pComponent->Ext.DbgVerifyExternalDataLoaded ();

    // If the component is not bindable, we have nothing to do.
    //
    if (!pComponent->FIsBindable())
    {
        return S_OK;
    }

    m_BindValue.Clear ();
    m_ExportValue.Clear ();
    m_RouteValue.Clear ();

    wcscpy (szExport, L"\\Device\\");
    wcscat (szExport, pComponent->Ext.PszBindName());
    hr = m_ExportValue.HrCopyString (szExport);
    Assert (S_OK == hr);
    hr = m_ExportValue.HrCopyString (L"");
    Assert (S_OK == hr);

    if (FIsEnumerated (pComponent->Class()))
    {
        // UpperBind
        //
        hr = HrGetAdapterUpperBindValue (pComponent);
    }
    else
    {
        // Bind, Export
        //
        hr = m_pNetConfig->Core.HrGetComponentBindings (
                pComponent,
                GBF_PRUNE_DISABLED_BINDINGS,
                &m_BindSet);

        if ((S_OK == hr) && (m_BindSet.CountBindPaths() > 0))
        {
            // Since the component has bindings, it's export value will be
            // different from the default one we initialized with above.
            //
            m_ExportValue.Clear ();

            for (pBindPath  = m_BindSet.begin();
                 pBindPath != m_BindSet.end();
                 pBindPath++)
            {
                Assert (pBindPath->CountComponents() > 1);

                wcscpy (szBind,   L"\\Device\\");
                wcscpy (szExport, L"\\Device\\");
                *szRoute = 0;

                for (iter  = pBindPath->begin();
                     iter != pBindPath->end();
                     iter++)
                {
                    pUpper = *iter;
                    Assert (pUpper);

                    // For the bind value, skip the first component in each
                    // path because it is the component we are writing the
                    // bindings for.
                    //
                    if (iter != pBindPath->begin())
                    {
                        Assert (wcslen(szBind) + 1 +
                                wcslen(pUpper->Ext.PszBindName())
                                    < celems(szBind));

                        // If this isn't the first component to come after
                        // \Device\, add underscores to seperate the
                        // components.
                        //
                        if (iter != (pBindPath->begin() + 1))
                        {
                            wcscat (szBind, L"_");
                            wcscat (szRoute, L" ");
                        }
                        wcscat (szBind, pUpper->Ext.PszBindName());

                        wcscat (szRoute, L"\"");
                        wcscat (szRoute, pUpper->Ext.PszBindName());
                        wcscat (szRoute, L"\"");
                    }

                    Assert (wcslen(szExport) + 1 +
                            wcslen(pUpper->Ext.PszBindName())
                                < celems(szExport));

                    // If this isn't the first component to come after
                    // \Device\, add underscores to seperate the
                    // components.
                    //
                    if (iter != pBindPath->begin())
                    {
                        wcscat (szExport, L"_");
                    }
                    wcscat (szExport, pUpper->Ext.PszBindName());

                    // If the next component in the bindpath is the last
                    // component, it is an adapter (by convention).  Check
                    // to see if there are multiple interfaces to be expanded
                    // for the current component over this adapter.
                    //
                    if ((iter + 1) == (pBindPath->end() - 1))
                    {
                        DWORD cInterfaces;
                        GUID* pguidInterfaceIds;

                        pLower = *(iter + 1);

                        hr = pUpper->Notify.HrGetInterfaceIdsForAdapter (
                                m_pNetConfig->Notify.PINetCfg(),
                                pLower,
                                &cInterfaces,
                                &pguidInterfaceIds);

                        if (FAILED(hr))
                        {
                            break;
                        }

                        if (cInterfaces)
                        {
                            Assert (pguidInterfaceIds);

                            if (iter != pBindPath->begin())
                            {
                                wcscat (szBind, L"_");
                                pchBind = szBind + wcslen(szBind);
                                Assert (wcslen(szBind) +
                                    c_cchGuidWithTerm < celems(szBind));
                            }
                            else
                            {
                                // The first component in the bindpath is
                                // one that has multiple interfaces over the
                                // adapter.  The bind value should be as
                                // normal, the export value will have the
                                // expand interfaces.
                                //
                                Assert (wcslen(szBind) +
                                        wcslen(pLower->Ext.PszBindName())
                                            < celems(szBind));

                                wcscat (szBind, pLower->Ext.PszBindName());

                                hr = m_BindValue.HrCopyString (szBind);
                                if (S_OK != hr)
                                {
                                    break;
                                }
                            }

                            wcscat (szExport, L"_");
                            pchExport = szExport + wcslen(szExport);
                            Assert (wcslen(szExport) +
                                c_cchGuidWithTerm < celems(szExport));

                            for (UINT i = 0; i < cInterfaces; i++)
                            {
                                if (iter != pBindPath->begin())
                                {
                                    StringFromGUID2 (
                                        pguidInterfaceIds[i],
                                        pchBind, c_cchGuidWithTerm);

                                    hr = m_BindValue.HrCopyString (szBind);
                                    if (S_OK != hr)
                                    {
                                        break;
                                    }
                                }

                                StringFromGUID2 (
                                    pguidInterfaceIds[i],
                                    pchExport, c_cchGuidWithTerm);

                                hr = m_ExportValue.HrCopyString (szExport);
                                if (S_OK != hr)
                                {
                                    break;
                                }
                            }

                            CoTaskMemFree (pguidInterfaceIds);

                            if (iter != pBindPath->begin())
                            {
                                wcscat (szRoute, L" ");
                            }
                            wcscat (szRoute, L"\"");
                            wcscat (szRoute, pLower->Ext.PszBindName());
                            wcscat (szRoute, L"\"");

                            hr = m_RouteValue.HrCopyString (szRoute);
                            if (S_OK != hr)
                            {
                                break;
                            }

                            // We only allow one component in a bindpath
                            // to support mutliple interfaces and it always
                            // comes at the end of the bindpath.  Therefore,
                            // after expanding them, we are done with the
                            // bindpath and proceed to the next.  (Hence, the
                            // 'break').
                            //
                            break;
                        }
                    }
                }

                // If we exited the loop because we traversed the entire
                // bindpath (as opposed to expanding multiple interfaces,
                // where we would have stopped short), then add the bind
                // and export strings for this bindpath to the buffer and
                // proceed to the next bindpath.
                //
                if (iter == pBindPath->end())
                {
                    hr = m_BindValue.HrCopyString (szBind);
                    if (S_OK != hr)
                    {
                        break;
                    }

                    hr = m_ExportValue.HrCopyString (szExport);
                    if (S_OK != hr)
                    {
                        break;
                    }

                    hr = m_RouteValue.HrCopyString (szRoute);
                    if (S_OK != hr)
                    {
                        break;
                    }
                }
            }

            // The bind and export values are multi-sz, so make sure they
            // are double null-terminiated.
            //
            hr = m_BindValue.HrCopyString (L"");
            if (S_OK == hr)
            {
                hr = m_ExportValue.HrCopyString (L"");
            }
            if (S_OK == hr)
            {
                hr = m_RouteValue.HrCopyString (L"");
            }
        }

        // Special case: NCF_DONTEXPOSELOWER
        //
        if ((S_OK == hr) &&
            ((pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER) ||
             (0 == wcscmp(L"ms_nwspx", pComponent->m_pszInfId))))
        {
            wcscpy (szExport, L"\\Device\\");
            wcscat (szExport, pComponent->Ext.PszBindName());

            m_ExportValue.Clear ();
            hr = m_ExportValue.HrCopyString (szExport);
            Assert (S_OK == hr);
            hr = m_ExportValue.HrCopyString (L"");
            Assert (S_OK == hr);
        }
        // End Special case
    }

    if (S_OK == hr)
    {
        // Need to write out lanamap before writing new bindings since
        // we need the old binding information to persist lana numbers.
        //
        if (0 == wcscmp (pComponent->m_pszInfId, L"ms_netbios"))
        {
            (VOID) HrUpdateLanaConfig (
                    m_pNetConfig->Core.Components,
                    (PCWSTR)m_BindValue.PbBuffer(),
                    m_BindSet.CountBindPaths());
        }

        hr = HrWriteLinkageValues (
                pComponent,
                (PCWSTR)m_BindValue.PbBuffer(),
                (PCWSTR)m_ExportValue.PbBuffer(),
                (PCWSTR)m_RouteValue.PbBuffer());

        if(S_OK == hr)
        {
            // mbend June 20, 2000
            // RAID 23275: Default gateway isn't respecting the adapter order specified under connections->advanced->properties
            // Notify NDIS when the binding list for a component changes.
            //
            UNICODE_STRING LowerComponent;
            UNICODE_STRING UpperComponent;
            UNICODE_STRING BindList;

            BOOL bOk = TRUE;
            if (FIsEnumerated(pComponent->Class()))
            {
                RtlInitUnicodeString(&BindList, NULL);
                RtlInitUnicodeString(&LowerComponent, NULL);
                RtlInitUnicodeString(&UpperComponent, pComponent->Ext.PszBindName());
                bOk = NdisHandlePnPEvent(
                        NDIS,
                        BIND_LIST,
                        &LowerComponent,
                        &UpperComponent,
                        &BindList,
                        const_cast<PBYTE>(m_BindValue.PbBuffer()),
                        m_BindValue.CountOfBytesUsed());

            }
            else
            {
                RtlInitUnicodeString(&BindList, NULL);
                RtlInitUnicodeString(&LowerComponent, NULL);
                RtlInitUnicodeString(&UpperComponent, pComponent->Ext.PszBindName());

                TraceTag(ttidBeDiag, "BindName (TDI Client): %S", pComponent->Ext.PszBindName());

                bOk = NdisHandlePnPEvent(
                      TDI,
                      RECONFIGURE,
                      &LowerComponent,
                      &UpperComponent,
                      &BindList,
                      const_cast<PBYTE>(m_BindValue.PbBuffer()),
                      m_BindValue.CountOfBytesUsed());
            }

            if(!bOk)
            {
//                hr = HrFromLastWin32Error();
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrWriteBindingsForComponent");
    return hr;
}

HRESULT
CRegistryBindingsContext::HrWriteBindingsForFilterDevices (
    IN CFilterDevices* pFilterDevices)
{
    HRESULT hr;
    CFilterDevices::iterator iter;
    CFilterDevices::iterator next;
    CFilterDevice* pDevice;
    CFilterDevice* pNextDevice;
    CFilterDevice* pPrevDevice;
    PCWSTR pmszRootDevice;
    PCWSTR pmszUpperBind;

    #define SZ_DEVICE_LEN 8     // characters in L"\\Device\\"
    WCHAR mszExport [SZ_DEVICE_LEN + c_cchGuidWithTerm + 1];
    WCHAR* const pchExportGuid = mszExport + SZ_DEVICE_LEN;

    // Pre-fill the beginning of the Export string.
    // Set the terminating NULL for the mutli-sz too.
    //
    wcscpy (mszExport, L"\\Device\\");
    Assert (SZ_DEVICE_LEN == wcslen(mszExport));
    mszExport[celems(mszExport) - 1] = 0;

    hr = S_OK;

    // Sort the filter devices by pAdapter and then by
    // pFilter->m_dwFilterClassOrdinal.  We will then iterate all filter
    // devices to write the bindings.  Because of the sort, we'll iterate
    // all filter devices for a given adapter in class order from smallest
    // to largest.  (Smaller class ordinals have affinity for the protocol.)
    //
    pFilterDevices->SortForWritingBindings ();

    pPrevDevice = NULL;

    for (iter  = pFilterDevices->begin();
         iter != pFilterDevices->end();
         iter++)
    {
        pDevice = *iter;
        Assert (pDevice);

        // Generate the rest of the Export string.
        // \Device\{GUID}
        //
        Assert ((c_cchGuidWithTerm - 1) == wcslen(pDevice->m_szInstanceGuid));

        wcscpy (pchExportGuid, pDevice->m_szInstanceGuid);

        // If this device's adapter is different than the previous device's
        // adapter, we are dealing with the top of a new chain.  We need
        // to initialize RootDevice which will be the multi-sz of all
        // bindnames in the chain including the adapter.
        //
        if (!pPrevDevice ||
            (pDevice->m_pAdapter != pPrevDevice->m_pAdapter))
        {
            // Compute RootDevice.
            // We'll use m_ExportValue as the buffer.
            //
            m_ExportValue.Clear();
            m_ExportValue.HrCopyString (pDevice->m_szInstanceGuid);

            for (next = iter + 1;
                 next != pFilterDevices->end();
                 next++)
            {
                pNextDevice = *next;
                Assert (pNextDevice);

                // We're done when we reach the next filter chain.
                //
                if (pNextDevice->m_pAdapter != pDevice->m_pAdapter)
                {
                    break;
                }

                m_ExportValue.HrCopyString (pNextDevice->m_szInstanceGuid);
            }

            m_ExportValue.HrCopyString (pDevice->m_pAdapter->Ext.PszBindName());
            m_ExportValue.HrCopyString (L"");
            pmszRootDevice = (PCWSTR)m_ExportValue.PbBuffer();
            Assert (*pmszRootDevice);

            // Compute UpperBind.
            // We'll use m_BindValue as the buffer.
            //
            hr = HrGetAdapterUpperBindValue (pDevice->m_pAdapter);
        }
        // We're continuing in the filter chain and this device is not
        // the topmost. (not closest to the protocol).
        //
        else
        {
            // Since RootDevice was built up for the top device in the chain,
            // each successive device just needs to skip past the next
            // string in the mutli-sz.
            //
            Assert (*pmszRootDevice);
            pmszRootDevice += wcslen(pmszRootDevice) + 1;

            // UpperBind is the previous device's filter's bind name.
            //
            m_BindValue.Clear();
            m_BindValue.HrCopyString (pPrevDevice->m_pFilter->Ext.PszBindName());
            m_BindValue.HrCopyString (L"");
        }

        pmszUpperBind = (PCWSTR)m_BindValue.PbBuffer();

        // We now have:
        //   Export in mszExport
        //   RootDevice at pmszRootDevice (in m_ExportValue)
        //   UpperBind at pmszUpperBind (in m_BindValue)
        //
        hr = HrWriteFilterDeviceLinkage (
                pDevice, pFilterDevices->m_hdi,
                mszExport, pmszRootDevice, pmszUpperBind);

        // If this is the last device in the chain, we need to write
        // the UpperBind of the adapter to be this filter device.
        //
        next = iter + 1;
        if ((next == pFilterDevices->end()) ||
            (*next)->m_pAdapter != pDevice->m_pAdapter)
        {
            // UpperBind is this last device's filter's bind name.
            //
            m_BindValue.Clear();
            m_BindValue.HrCopyString (pDevice->m_pFilter->Ext.PszBindName());
            m_BindValue.HrCopyString (L"");
            pmszUpperBind = (PCWSTR)m_BindValue.PbBuffer();

            hr = HrWriteFilteredAdapterUpperBind (
                    pDevice->m_pAdapter,
                    pmszUpperBind);
        }

        // Remember the previous device so that when we go to the next
        // device, we'll know we're dealing with a different chain if
        // the next device's adapter is different than this one.
        //
        pPrevDevice = pDevice;
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CRegistryBindingsContext::HrWriteBindingsForFilterDevices");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\remove.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       R E M O V E . C P P
//
//  Contents:   Implements actions related to removing components.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "ncreg.h"
#include "netcfg.h"


VOID
CModifyContext::NotifyAndRemoveComponent (
    IN CComponent* pComponent)
{
    CNetConfig* pNetConfig;
    UINT cPreviousDeletedBindPaths;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    pNetConfig = PNetConfig();

    // Note the number of bindpaths currently in m_DeletedBindPaths.
    // We need this so that when we add to the set, we only notify
    // for the ones we add.
    //
    cPreviousDeletedBindPaths = m_DeletedBindPaths.CountBindPaths ();

    // Get the bindpaths that involve the component we are removing.
    // Add these to the deleted bindpaths we are keeping track of.
    //
    m_hr = pNetConfig->Core.HrGetBindingsInvolvingComponent (
                pComponent,
                GBF_ADD_TO_BINDSET | GBF_ONLY_WHICH_CONTAIN_COMPONENT,
                &m_DeletedBindPaths);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Remove the component from the core.
    //
    pNetConfig->Core.RemoveComponentFromCore (pComponent);

    // Notify that these bindpaths are being removed.  We only need to do
    // so if we added any new ones to the set.  Existing ones in the set
    // have already been notified.
    //
    // THIS MAY CAUSE RECURSION
    //
    if (m_DeletedBindPaths.CountBindPaths() > cPreviousDeletedBindPaths)
    {
        m_hr = pNetConfig->Notify.NotifyRemovedBindPaths (
                    &m_DeletedBindPaths,
                    cPreviousDeletedBindPaths);
        if (S_OK != m_hr)
        {
            Assert(FAILED(m_hr));
            return;
        }
    }

    // Notify the component's notify object it is being removed.
    // This also sends global notifications to other notify objects
    // who may be interested.
    //
    // THIS MAY CAUSE RECURSION
    //
    m_hr = pNetConfig->Notify.ComponentRemoved (pComponent);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // If we have a cached INetCfgComponent interface, we need to tell it
    // that the component it represents is no longer valid.
    //
    pComponent->ReleaseINetCfgComponentInterface ();

    // Remove (if not referenced) any components that this component
    // required.
    //
    // THIS MAY CAUSE RECURSION
    //
    InstallOrRemoveRequiredComponents (pComponent, IOR_REMOVE);
    if (S_OK != m_hr)
    {
        Assert(FAILED(m_hr));
        return;
    }

    // Now that we've given a chance to notify objects to remove references
    // to the component being removed, we need to ensure it is not
    // referenced by anyone else.
    // Check to see if the component we just removed is still
    // referencing other components.  If it is, it means it forgot
    // to remove those components.  We'll print what they are and
    // remove the bogus reference (but not the components themselves)
    // so that when we save the configuration binary we don't
    // barf trying to lookup the index of this component we just
    // removed.)
    //
    pNetConfig->Core.EnsureComponentNotReferencedByOthers (pComponent);
}

HRESULT
CModifyContext::HrRemoveComponentIfNotReferenced (
    IN CComponent* pComponent,
    IN OBO_TOKEN* pOboToken OPTIONAL,
    OUT PWSTR* ppmszwRefs OPTIONAL)
{
    CNetConfig* pNetConfig;
    BOOL fStillReferenced;

    Assert (this);
    Assert (S_OK == m_hr);
    Assert (pComponent);

    // If the caller is requesting removal on behalf of an obo token,
    // (and its not obo the user) make sure the component is actually
    // referenced by that obo token.  If it is not, consider it an
    // invalid argument.
    //
    // The reason we don't consider the obo user case is because the UI
    // will show anything that is installed and allow the user to try to
    // remove them.  If the user hasn't actually installed it, we don't
    // want to treat this as an invalid argument, rather, we want to let
    // the code fall through to the case where we will return the multi-sz
    // of descriptions of components still referencing the component.
    //
    // However, if there are no references (which can happen if we delete
    // the configuration binary and then re-create it) we'll go ahead and
    // allow removals by anyone).  This is a safety-net.
    //
    // The overall purpose of the following 'if' is to catch programatic
    // removals that are on behalf of other components or software that
    // have previously installed the component being removed.
    //
    if (pOboToken &&
        (OBO_USER != pOboToken->Type) &&
        !pComponent->Refs.FIsReferencedByOboToken (pOboToken) &&
        (pComponent->Refs.CountTotalReferencedBy() > 0))
    {
        return E_INVALIDARG;
    }

    pNetConfig = PNetConfig();
    fStillReferenced = TRUE;

    // Now that we actually are going to modify something, push a new
    // recursion depth.
    //
    PushRecursionDepth ();
    Assert (S_OK == m_hr);

    // If the component is NOT in the list of components we started with,
    // it means someone had previously installed it during this modify
    // context and now wants to remove it.  This is tricky and should
    // probably be implemented later.  For now, return an error and throw
    // up an assert so we can see who needs to do this.
    //
    if (!m_CoreStartedWith.Components.FComponentInList (pComponent))
    {
        AssertSz (FALSE, "Whoa.  Someone is trying to remove a "
            "component that was previously installed during this same "
            "modify context.  We need to decide if we can support this.");
        m_hr = E_UNEXPECTED;
    }

    if (pOboToken && (S_OK == m_hr))
    {
        m_hr = pComponent->Refs.HrRemoveReferenceByOboToken (pOboToken);
    }

    // If no obo token, or we removed the reference from it, actually
    // remove it if it is not still referenced by anything else.
    //
    if (S_OK == m_hr)
    {
        if (0 == pComponent->Refs.CountTotalReferencedBy())
        {
            fStillReferenced = FALSE;

            NotifyAndRemoveComponent (pComponent);
        }
        else if (ppmszwRefs)
        {
            ULONG cb;

            // Need to return the multi-sz of descriptions still referencing
            // the component the caller tried to remove.
            //

            // Size the data first.
            //
            cb = 0;
            pComponent->Refs.GetReferenceDescriptionsAsMultiSz (
                NULL, &cb);

            Assert (cb);

            // Allocate room to return the multi-sz.
            //
            Assert (S_OK == m_hr);

            m_hr = HrCoTaskMemAlloc (cb, (VOID**)ppmszwRefs);
            if (S_OK == m_hr)
            {
                // Now get the multi-sz.
                //
                pComponent->Refs.GetReferenceDescriptionsAsMultiSz (
                    (BYTE*)(*ppmszwRefs), &cb);

                Assert (fStillReferenced);
            }
        }
    }

    HRESULT hr;

    hr = HrPopRecursionDepth ();

    if (fStillReferenced && SUCCEEDED(hr))
    {
        // Still reference return code overrides other success codes like
        // need reboot.
        //
        hr = NETCFG_S_STILL_REFERENCED;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\stable.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       S T A B L E . C P P
//
//  Contents:   Implements operations that are valid on stack entries and
//              stack tables.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "nceh.h"
#include "netcfg.h"
#include "stable.h"

BOOL
CStackTable::FStackEntryInTable (
    IN const CComponent*  pUpper,
    IN const CComponent*  pLower) const
{
    const CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    for (pStackEntry = begin(); pStackEntry != end(); pStackEntry++)
    {
        if ((pUpper == pStackEntry->pUpper) &&
            (pLower == pStackEntry->pLower))
        {
            return TRUE;
        }
    }

    return FALSE;
}

VOID
CStackTable::RemoveStackEntry(
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower)
{
    CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pUpper);
    Assert (pLower);

    for (pStackEntry = begin(); pStackEntry != end(); pStackEntry++)
    {
        if ((pUpper == pStackEntry->pUpper) &&
            (pLower == pStackEntry->pLower))
        {
            erase(pStackEntry);
            break;
        }
    }
}

HRESULT
CStackTable::HrCopyStackTable (
    IN const CStackTable* pSourceTable)
{
    HRESULT hr;

    Assert (this);
    Assert (pSourceTable);

    NC_TRY
    {
        *this = *pSourceTable;
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrCopyStackTable");
    return hr;
}

HRESULT
CStackTable::HrInsertStackEntriesForComponent (
    IN const CComponent* pComponent,
    IN const CComponentList* pComponents,
    IN DWORD dwFlags /* INS_FLAGS */)
{
    HRESULT hr;
    CStackEntry StackEntry;
    CComponentList::const_iterator iter;
    const CComponent* pScan;

    Assert (this);
    Assert (pComponent);
    Assert (pComponents);

    hr = S_OK;

    // Insert the stack entries for other components which bind with this one.
    //
    for (iter  = pComponents->begin();
         iter != pComponents->end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan == pComponent)
        {
            continue;
        }

        if (pScan->FCanDirectlyBindTo (pComponent, NULL, NULL))
        {
            StackEntry.pUpper = pScan;
            StackEntry.pLower = pComponent;
        }
        else if (pComponent->FCanDirectlyBindTo (pScan, NULL, NULL))
        {
            StackEntry.pUpper = pComponent;
            StackEntry.pLower = pScan;
        }
        else
        {
            continue;
        }

        // Insert the stack entry.  This should only fail if we are
        // out of memory.
        //
        hr = HrInsertStackEntry (&StackEntry, dwFlags);

        // If we fail to insert the entry, undo all of the previous
        // insertions of this component and return.
        //
        if (S_OK != hr)
        {
            RemoveEntriesWithComponent (pComponent);
            break;
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE,
        "CStackTable::HrInsertStackEntriesForComponent");
    return hr;
}

HRESULT
CStackTable::HrInsertStackEntry (
    IN const CStackEntry* pStackEntry,
    IN DWORD dwFlags)
{
    HRESULT hr;

    Assert (this);
    Assert (pStackEntry);
    Assert (dwFlags);
    Assert ((INS_SORTED == dwFlags) || (INS_NON_SORTED == dwFlags));

    const CComponent* pUpper = pStackEntry->pUpper;
    const CComponent* pLower = pStackEntry->pLower;

    Assert (pUpper && pLower && (pUpper != pLower));
    Assert (!FStackEntryInTable (pUpper, pLower));

    CStackEntry* pScan = end();

    if (dwFlags & INS_SORTED)
    {
        CStackEntry* pFirstInClass = NULL;
        CStackEntry* pFirstSameUpper = NULL;

        // Find the beginning of the group of entries belonging to the
        // same class or lower as the one we are inserting.
        //
        for (pScan = begin(); pScan != end(); pScan++)
        {
            if ((UINT)pUpper->Class() >= (UINT)pScan->pUpper->Class())
            {
                pFirstInClass = pScan;
                break;
            }
        }

        // Find the first entry with the same pUpper (if there is one).
        //
        for (; pScan != end(); pScan++)
        {
            if (pUpper == pScan->pUpper)
            {
                pFirstSameUpper = pScan;
                break;
            }
        }

        // If we found the first entry with a matching pUpper, find the
        // specific entry to insert before.
        //
        if (pFirstSameUpper)
        {
            BOOL fLowerIsNetBt;

            // This may seem ugly, but will save a lot of code in a
            // notify object.  If inserting pLower of netbt, make sure
            // it comes after netbt_smb.
            //
            fLowerIsNetBt = (0 == wcscmp (pLower->m_pszInfId, L"ms_netbt"));
            if (fLowerIsNetBt)
            {
                while ((pScan != end()) && (pUpper == pScan->pUpper))
                {
                    pScan++;
                }
            }
            else if (pLower->FIsWanAdapter() && !m_fWanAdaptersFirst)
            {
                // For WAN adapters, either insert them before or after
                // all other adapters as determined by m_fWanAdaptersFirst.
                // If they don't come first, they come last, so scan
                // to the end of the group with the same upper.
                //
                while ((pScan != end()) && (pUpper == pScan->pUpper))
                {
                    pScan++;
                }
            }
        }

        // Otherwise, (if we didn't find any entry with the same upper),
        // but we did find the beginning of the class group, set pScan
        // to the class marker because that is where we will insert.
        //
        else if (pFirstInClass)
        {
            pScan = pFirstInClass;
        }
        else
        {
            Assert (pScan == end());
        }
    }

    // Now insert the entry before the element we found as appropriate.
    //
    NC_TRY
    {
        insert (pScan, *pStackEntry);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrInsertStackEntry");
    return hr;
}

HRESULT
CStackTable::HrMoveStackEntries (
    IN const CStackEntry* pSrc,
    IN const CStackEntry* pDst,
    IN MOVE_FLAG Flag,
    IN CModifyContext* pModifyCtx)
{
    CStackEntry* pScanSrc;
    CStackEntry* pScanDst;

    // Search for the matching source entry in the table.  We need
    // the pointer to the entry in the table so we can remove it before
    // we re-insert it before or after pDst.
    //
    pScanSrc = find (begin(), end(), *pSrc);

    // If we didn't find the entry, the caller has passed us an invalid
    // argument.
    //
    if (pScanSrc == end())
    {
        return E_INVALIDARG;
    }

    if (pDst)
    {
        // pDst is optional, but if it is specified, it have the same upper
        // but different lower than pSrc.
        //
        if ((pSrc->pUpper != pDst->pUpper) ||
            (pSrc->pLower == pDst->pLower))
        {
            return E_INVALIDARG;
        }

        pScanDst = find (begin(), end(), *pDst);

        // If we didn't find the entry, the caller has passed us an invalid
        // argument.
        //
        if (pScanDst == end())
        {
            return E_INVALIDARG;
        }

        // Since we only have an insert operation, moving after is the
        // same as inserting before the element following pScanDst.
        //
        if ((MOVE_AFTER == Flag) && (pScanDst != end()))
        {
            pScanDst++;
        }
    }
    else
    {
        // Find the first or last in the group with the same upper
        // as pScanSrc.
        //
        pScanDst = pScanSrc;

        if (MOVE_AFTER == Flag)
        {
            // Find the last in the group and insert after that.
            //
            while (pScanDst->pUpper == pScanSrc->pUpper)
            {
                pScanDst++;
                if (pScanDst == end())
                {
                    break;
                }
            }
        }
        else
        {
            // Find the first in the group and insert before that.
            //
            while (1)
            {
                pScanDst--;

                if (pScanDst == begin())
                {
                    break;
                }

                // If we've stepped out of the group, we need to point
                // back at the first element since we are inserting.
                //
                if (pScanDst->pUpper != pScanSrc->pUpper)
                {
                    pScanDst++;
                    break;
                }
            }
        }
    }

    // Remove pScanSrc and insert it pSrc before pScanDst.
    //
    Assert ((pScanSrc >= begin()) && pScanSrc < end());
    erase (pScanSrc);

    // Erasing pScanSrc will move everything that follows it up.
    // If pScanDst comes after pScanSrc, we need to back it up by one.
    //
    Assert ((pScanDst >= begin()) && pScanSrc <= end());
    if (pScanSrc < pScanDst)
    {
        pScanDst--;
    }

    Assert ((pScanDst >= begin()) && pScanSrc <= end());
    insert (pScanDst, *pSrc);

    // We now need to add pSrc->pUpper and all components above
    // it to the modify context's dirty component list.  This will
    // allow us to rewrite the newly ordered bindings during ApplyChanges.
    //
    HRESULT hr = pModifyCtx->HrDirtyComponentAndComponentsAbove (pSrc->pUpper);

    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrMoveStackEntries");
    return hr;
}

HRESULT
CStackTable::HrReserveRoomForEntries (
    IN UINT cEntries)
{
    HRESULT hr;

    NC_TRY
    {
        reserve (cEntries);
        hr = S_OK;
    }
    NC_CATCH_BAD_ALLOC
    {
        hr = E_OUTOFMEMORY;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "CStackTable::HrReserveRoomForEntries");
    return hr;
}

VOID
CStackTable::RemoveEntriesWithComponent (
    IN const CComponent* pComponent)
{
    CStackEntry*  pStackEntry;

    Assert (this);
    Assert (pComponent);

    pStackEntry = begin();
    while (pStackEntry != end())
    {
        if ((pComponent == pStackEntry->pUpper) ||
            (pComponent == pStackEntry->pLower))
        {
            erase (pStackEntry);
        }
        else
        {
            pStackEntry++;
        }
    }
}

HRESULT
CStackTable::HrUpdateEntriesForComponent (
    IN const CComponent* pComponent,
    IN const CComponentList* pComponents,
    IN DWORD dwFlags)
{
    HRESULT hr;
    CStackEntry StackEntry;
    CComponentList::const_iterator iter;
    const CComponent* pScan;
    CStackTable NewStackEntries;
    CStackEntry*  pStackEntry = NULL;

    Assert (this);
    Assert (pComponent);
    Assert (pComponents);

    hr = S_OK;

    TraceTag(ttidBeDiag, 
            "UpdateBindingInterfaces for %S",
            pComponent->PszGetPnpIdOrInfId());
    
    // Save the stack entries for other components which bind with this one.
    //
    for (iter  = pComponents->begin();
         iter != pComponents->end();
         iter++)
    {
        pScan = *iter;
        Assert (pScan);

        if (pScan == pComponent)
        {
            continue;
        }

        if (pScan->FCanDirectlyBindTo (pComponent, NULL, NULL))
        {
            StackEntry.pUpper = pScan;
            StackEntry.pLower = pComponent;
        }
        else if (pComponent->FCanDirectlyBindTo (pScan, NULL, NULL))
        {
            StackEntry.pUpper = pComponent;
            StackEntry.pLower = pScan;
        }
        else
        {
            continue;
        }

        // Save the stack entry for comparation later
        NewStackEntries.push_back(StackEntry);

    }

    //Check whether the current stack entry table is consist with NewStackEntries
    //if not, then update the current stack entry table
    pStackEntry = begin();
    while (pStackEntry != end())
    {
        if ((pComponent == pStackEntry->pUpper) ||
            (pComponent == pStackEntry->pLower))
        {
            if (!NewStackEntries.FStackEntryInTable(pStackEntry->pUpper, pStackEntry->pLower))
            {
                //if the stack entry is not in the new component binding entry list, remove it 
                //from the current stack entry list
                erase (pStackEntry);

                TraceTag(ttidBeDiag, 
                    "erasing binding interface Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());

                //dont need to increase the iterator since we just removed the current one 
                continue;
            }
            else
            {
                //if the stack entry is also in NewStackEntries, just keep it untouched 
                //in current entry list. Remove that entry from NewStackEntries so that we don't add
                // it again to the current entry list later
                NewStackEntries.RemoveStackEntry(pStackEntry->pUpper, pStackEntry->pLower);
                TraceTag(ttidBeDiag, 
                    "Keep the binding interface untouched: Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());
            }
        }
        
        pStackEntry++;
    }

    //At this step, the NewStackEntries only contains the stack entries that are in the new binding list
    //but are NOT in the current entry list. So add them in.
    pStackEntry = NewStackEntries.begin();
    while (pStackEntry != NewStackEntries.end())
    {
        Assert(!FStackEntryInTable(pStackEntry->pUpper, pStackEntry->pLower));
        TraceTag(ttidBeDiag, 
                    "Adding the bind interface: Uppper %S - Lower %S",
                    pStackEntry->pUpper->PszGetPnpIdOrInfId(),
                    pStackEntry->pLower->PszGetPnpIdOrInfId());
        hr = HrInsertStackEntry(pStackEntry, dwFlags);
        if (S_OK != hr)
        {
            break;
        }
        
        pStackEntry++;
    }

    // If we fail to insert the entry, undo all of the previous
    // insertions of this component and return.
    //
    if (S_OK != hr)
    {
        RemoveEntriesWithComponent (pComponent);
    }

    TraceError("UpdateEntriesWithComponent", hr);
    return hr;
}

VOID
CStackTable::SetWanAdapterOrder (
    IN BOOL fWanAdaptersFirst)
{
    m_fWanAdaptersFirst = fWanAdaptersFirst;

    // Note: TODO - reorder table
}

VOID
GetComponentsAboveComponent (
    IN const CComponent* pComponent,
    IN OUT GCCONTEXT* pCtx)
{
    const CStackEntry* pStackEntry;

    // For all rows in the stack table where the lower component
    // is the one passed in...
    //
    for (pStackEntry  = pCtx->pStackTable->begin();
         pStackEntry != pCtx->pStackTable->end();
         pStackEntry++)
    {
        if (pComponent != pStackEntry->pLower)
        {
            continue;
        }

        pCtx->hr = pCtx->pComponents->HrInsertComponent (
                    pStackEntry->pUpper, INS_IGNORE_IF_DUP | INS_SORTED);

        // Special case: NCF_DONTEXPOSELOWER
        // If the upper component has the NCF_DONTEXPOSELOWER characteristic,
        // don't recurse.
        //
        if (!pCtx->fIgnoreDontExposeLower &&
            (pStackEntry->pUpper->m_dwCharacter & NCF_DONTEXPOSELOWER))
        {
            continue;
        }
        // End Special case

        // Recurse on the upper component...
        //
        GetComponentsAboveComponent (pStackEntry->pUpper, pCtx);
        if (S_OK != pCtx->hr)
        {
            return;
        }
    }
}

VOID
GetBindingsBelowComponent (
    IN const CComponent* pComponent,
    IN OUT GBCONTEXT* pCtx)
{
    BOOL fFoundOne = FALSE;
    const CStackEntry* pStackEntry;

    // Append this component to the end of the context's working bindpath.
    //
    pCtx->hr = pCtx->BindPath.HrAppendComponent (pComponent);
    if (S_OK != pCtx->hr)
    {
        return;
    }

    // Special case: NCF_DONTEXPOSELOWER
    // If this is not the original component we are asked to find the
    // component for (i.e. not the top-level call) and if the component
    // has the NCF_DONTEXPOSELOWER characteristic, stop recursion since
    // this means we don't get to see components below it.
    //
    if ((pComponent != pCtx->pSourceComponent) &&
        (pComponent->m_dwCharacter & NCF_DONTEXPOSELOWER))
    {
        ;
    }
    // End Special case

    else
    {
        // For all rows in the stack table where the upper component
        // is the one passed in...
        //
        for (pStackEntry  = pCtx->pCore->StackTable.begin();
             pStackEntry != pCtx->pCore->StackTable.end();
             pStackEntry++)
        {
            if (pComponent != pStackEntry->pUpper)
            {
                continue;
            }

            // Detect circular bindings.  If the lower component of this
            // stack entry is already on the bindpath we are building, we
            // have a circular binding.  Break it now, by not recursing any
            // further.
            //
            if (pCtx->BindPath.FContainsComponent (pStackEntry->pLower))
            {
                g_pDiagCtx->Printf (ttidBeDiag, "Circular binding detected...\n");
                continue;
            }

            fFoundOne = TRUE;

            // Recurse on the lower component...
            //
            GetBindingsBelowComponent (pStackEntry->pLower, pCtx);
            if (S_OK != pCtx->hr)
            {
                return;
            }
        }
    }

    // If we didn't find any rows with pComponent as an upper, it
    // means we hit the depth of the bindpath.  Time to add it to
    // the binding set as a complete path unless this is the orignal
    // component we were asked to find the bindpath for.
    //
    if (!fFoundOne && (pComponent != pCtx->pSourceComponent))
    {
        // Add the bindpath to the bindset if we're not pruning disabled
        // bindings or the bindpath isn't disabled.
        //
        if (!pCtx->fPruneDisabledBindings ||
            !pCtx->pCore->FIsBindPathDisabled (&pCtx->BindPath,
                            IBD_EXACT_MATCH_ONLY))
        {
            pCtx->hr = pCtx->pBindSet->HrAddBindPath (&pCtx->BindPath,
                                        INS_APPEND | pCtx->dwAddBindPathFlags);
        }
    }

    const CComponent* pRemoved;

    pRemoved = pCtx->BindPath.RemoveLastComponent();

    // This should be the component we appened above.
    //
    Assert (pRemoved == pComponent);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\upgrade.cpp ===
#include <pch.h>
#pragma hdrstop
#include "persist.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"

HRESULT HrAddOrRemoveWinsockDependancy(
    IN HINF hinfInstallFile,
    IN PCWSTR pszSectionName);


HRESULT
HrLoadAndAddComponentFromInstanceKey (
    IN HKEY hkey,
    IN const GUID* pInstanceGuid,
    IN NETCLASS Class,
    IN PCWSTR pszPnpId OPTIONAL,
    IN OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    BASIC_COMPONENT_DATA Data;
    CComponent* pComponent;
    WCHAR szInfId [_MAX_PATH];
    WCHAR szMiniportId [_MAX_PATH];
    ULONG cbInfId;

    Assert (hkey);
    Assert (pInstanceGuid);
    Assert (FIsValidNetClass (Class));
    Assert (FImplies(pszPnpId, *pszPnpId));
    Assert (pNetConfig);

    ZeroMemory (&Data, sizeof(Data));

    hr = HrRegQueryDword (hkey, L"Characteristics", &Data.dwCharacter);
    if (S_OK == hr)
    {
        // If the component is a filter, copy Ndi\MiniportId to
        // Ndi\FilterDeviceInfId.
        //
        if (Data.dwCharacter & NCF_FILTER)
        {
            HKEY hkeyNdi;

            hr = HrRegOpenKeyEx (
                    hkey,
                    L"Ndi",
                    KEY_READ | KEY_WRITE,
                    &hkeyNdi);

            if (S_OK == hr)
            {
                HKEY hkeyInterfaces;
                DWORD cbMiniportId = sizeof(szMiniportId);

                hr = HrRegQuerySzBuffer (
                        hkeyNdi,
                        L"MiniportId",
                        szMiniportId,
                        &cbMiniportId);

                if (S_OK == hr)
                {
                    (VOID) HrRegSetSz (
                                hkeyNdi,
                                L"FilterDeviceInfId",
                                szMiniportId);
                }

                if (FInSystemSetup())
                {
                    // Need to update LowerExclude for filters (the only one
                    // being PSched) so we prevent PSched from binding to
                    // every adapter on the machine.  This only needs to
                    // happen during GUI setup and when we detect no Config
                    // binary because this happens way before INFs get re-run.)
                    //
                    hr = HrRegOpenKeyEx (
                            hkeyNdi,
                            L"Interfaces",
                            KEY_WRITE,
                            &hkeyInterfaces);

                    if (S_OK == hr)
                    {
                        (VOID) HrRegSetSz (
                                    hkeyInterfaces,
                                    L"LowerExclude",
                                    L"ndiscowan, ndiswan, ndiswanasync, "
                                    L"ndiswanipx, ndiswannbf");

                        RegCloseKey (hkeyInterfaces);
                    }
                }

                RegCloseKey (hkeyNdi);
                hr = S_OK;
            }
        }

        cbInfId = sizeof(szInfId);
        hr = HrRegQuerySzBuffer (hkey, L"ComponentId", szInfId, &cbInfId);
        if (S_OK == hr)
        {
            // Wanarp needs its refcounts key deleted in case we are
            // loaded before netupgrd.inf is run.
            //
            if (0 == _wcsicmp(L"ms_wanarp", szInfId))
            {
                (VOID)HrRegDeleteKey (hkey, L"RefCounts");
            }

            Data.InstanceGuid = *pInstanceGuid;
            Data.Class = Class;
            Data.pszInfId = szInfId;
            Data.pszPnpId = pszPnpId;

            // It is important to make sure we can load the external data
            // for two reasons:
            //  1) If we have a failure reading critical data that we
            //     need in order to function, we want to know about it
            //     now, before we add it to the component list.
            //  2) For filter devices which will be subsequently upgraded,
            //     we need to search for specific components by BindForm
            //     and BindName which are external data loaded by the
            //     following call.
            //
            hr = CComponent::HrCreateInstance (
                    &Data,
                    CCI_ENSURE_EXTERNAL_DATA_LOADED,
                    NULL,
                    &pComponent);
            if (S_OK == hr)
            {
                // Add the component and the stack entries, but don't
                // send any notifications to notify objects.
                //
                hr = pNetConfig->Core.HrAddComponentToCore (
                        pComponent, INS_SORTED);
            }
        }
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadAndAddComponentFromInstanceKey");
    return hr;
}

BOOL
FUpgradeFilterDeviceInstanceKey (
    IN CNetConfig* pNetConfig,
    IN HKEY hkeyInstance,
    IN PCWSTR pszFilterName)
{
    CComponent* pFilter;

    // The new binding engine uses FilterInfId located in under the instance
    // key instead of FilterName under Ndi.
    //
    pFilter = pNetConfig->Core.Components.PFindComponentByBindForm (
                NC_NETSERVICE, pszFilterName);

    if (pFilter)
    {
        (VOID) HrRegSetSz (hkeyInstance, L"FilterInfId", pFilter->m_pszInfId);

        return TRUE;
    }
    return FALSE;
}

HRESULT
HrLoadComponentReferencesFromLegacy (
    IN OUT CNetConfig* pNetConfig)
{
    HRESULT hr = S_OK;
    CComponentList::iterator iter;
    CComponent* pComponent;
    HKEY hkeyInstance;

    Assert (pNetConfig);

    for (iter  = pNetConfig->Core.Components.begin();
         iter != pNetConfig->Core.Components.end();
         iter++)
    {
        pComponent = *iter;
        Assert (pComponent);

        hr = pComponent->HrOpenInstanceKey (KEY_READ,
                &hkeyInstance, NULL, NULL);

        if (S_OK == hr)
        {
            HKEY hkeyRefCounts;

            hr = HrRegOpenKeyEx (hkeyInstance, L"RefCounts",
                    KEY_READ, &hkeyRefCounts);

            if (S_OK == hr)
            {
                DWORD dwIndex;
                WCHAR szValueName [_MAX_PATH];
                DWORD cchValueName;
                DWORD dwType;
                DWORD dwRefCount;
                DWORD cbData;
                CComponent* pRefdByComponent;
                GUID InstanceGuid;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    cchValueName = celems(szValueName);
                    cbData = sizeof(dwRefCount);

                    hr = HrRegEnumValue (hkeyRefCounts, dwIndex,
                            szValueName, &cchValueName, &dwType,
                            (LPBYTE)&dwRefCount, &cbData);

                    if (S_OK == hr)
                    {
                        if (0 == _wcsicmp (L"User", szValueName))
                        {
                            hr = pComponent->Refs.HrAddReferenceByUser ();
                        }
                        else if ((L'{' == *szValueName) &&
                                 (S_OK == IIDFromString (szValueName, &InstanceGuid)) &&
                                 (NULL != (pRefdByComponent = pNetConfig->Core.Components.PFindComponentByInstanceGuid(&InstanceGuid))))
                        {
                            hr = pComponent->Refs.HrAddReferenceByComponent (
                                    pRefdByComponent);
                        }
                        else if (NULL != (pRefdByComponent = pNetConfig->
                                    Core.Components.PFindComponentByInfId (
                                            szValueName, NULL)))
                        {
                            hr = pComponent->Refs.HrAddReferenceByComponent (
                                    pRefdByComponent);
                        }
                        else
                        {
                            hr = pComponent->Refs.HrAddReferenceBySoftware (
                                    szValueName);
                        }
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeyRefCounts);
            }

            RegCloseKey (hkeyInstance);
        }
    }

    // If the instance key or the refcounts key don't exist, there is not
    // much we can do about it.  Don't fail for these reasons.
    //
    if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
    {
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadComponentReferencesFromLegacy");
    return hr;
}

VOID
UpgradeConnection (
    IN const GUID& InstanceGuid,
    IN PCWSTR pszPnpId)
{
    HRESULT hr;
    WCHAR szPath[_MAX_PATH];
    HKEY hkeyConn;

    Assert (pszPnpId && *pszPnpId);

    // Connections uses a pnp id value as their back pointer to the pnp
    // tree.
    //
    CreateInstanceKeyPath (NC_NET, InstanceGuid, szPath);
    wcscat (szPath, L"\\Connection");
    hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, szPath, KEY_READ_WRITE,
            &hkeyConn);

    if (S_OK == hr)
    {
        HrRegSetSz (hkeyConn, L"PnpInstanceId", pszPnpId);
    }

    RegCloseKey(hkeyConn);
}

HRESULT
HrLoadNetworkConfigurationFromLegacy (
    OUT CNetConfig* pNetConfig)
{
    HRESULT hr;
    NETCLASS Class;
    PCWSTR pszSubtree;
    HKEY hkeySubtree;
    DWORD dwIndex;
    HKEY hkeyInstance;
    GUID InstanceGuid;
    UINT PassNumber;

    // Get the value for whether WAN adapters comes first or last in
    // adapter order.  We need to give this to the stack table so it will
    // know which way to order things.
    //
    Assert (FALSE == pNetConfig->Core.StackTable.m_fWanAdaptersFirst);

    hr = HrOpenNetworkKey (
            KEY_READ,
            &hkeySubtree);

    if (S_OK == hr)
    {
        DWORD dwValue;

        hr = HrRegQueryDword (hkeySubtree, L"WanAdaptersFirst", &dwValue);

        if (S_OK == hr)
        {
            pNetConfig->Core.StackTable.m_fWanAdaptersFirst = !!dwValue;
        }

        RegCloseKey (hkeySubtree);
    }

    // We need two passes to correctly upgrade everything.  Since filter
    // devices reference an adapter, we need to have already read the
    // information for all adapters before we can read information about
    // a filter device and create a memory representation for it which
    // references the memory representation of the adapter which it filters.
    //
    // The following structure should make this more clear.  For each
    // element in this array, we enumerate components in the specified
    // class.  Note that NC_NET is reference twice -- once for pass one
    // and once for pass two.  The code below uses the pass number to
    // know whether it should be ignoring filter devices (in pass one)
    // or ignoring adapters (in pass two, because they were already handled
    // in pass one.)  If it isn't clear by now, don't touch this code. ;-)
    //
    static const struct
    {
        NETCLASS    Class;
        UINT        PassNumber;
    } aPassInfo [] =
    {
        { NC_NET,        1 },
        { NC_INFRARED,   1 },
        { NC_NETTRANS,   1 },
        { NC_NETCLIENT,  1 },
        { NC_NETSERVICE, 1 },
        { NC_NET,        2 },
    };

    for (UINT i = 0; i < celems(aPassInfo); i++)
    {
        Class      = aPassInfo[i].Class;
        PassNumber = aPassInfo[i].PassNumber;

        Assert (FIsValidNetClass(Class));

        pszSubtree = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];

        if (!FIsEnumerated (Class))
        {
            hr = HrRegOpenKeyEx (HKEY_LOCAL_MACHINE, pszSubtree,
                    KEY_READ, &hkeySubtree);

            if (S_OK == hr)
            {
                DWORD cchGuid;
                WCHAR szInstanceGuid [c_cchGuidWithTerm];
                FILETIME ftLastWrite;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    cchGuid = celems(szInstanceGuid);

                    hr = HrRegEnumKeyEx (
                            hkeySubtree, dwIndex, szInstanceGuid, &cchGuid,
                            NULL, NULL, &ftLastWrite);

                    if ((S_OK == hr) && ((c_cchGuidWithTerm-1) == cchGuid))
                    {
                        hr = IIDFromString (szInstanceGuid, &InstanceGuid);
                        if (S_OK == hr)
                        {
                            hr = HrRegOpenKeyEx (
                                    hkeySubtree,
                                    szInstanceGuid,
                                    KEY_READ,
                                    &hkeyInstance);

                            if (S_OK == hr)
                            {
                                hr = HrLoadAndAddComponentFromInstanceKey (
                                        hkeyInstance,
                                        &InstanceGuid,
                                        Class,
                                        NULL,
                                        pNetConfig);

                                RegCloseKey (hkeyInstance);
                            }
                        }
                        else
                        {
                            // Delete the key?
                        }

                        // Ignore any errors during the loop
                        hr = S_OK;
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                RegCloseKey (hkeySubtree);
            }
        }
        else
        {
            HDEVINFO hdi;

            hr = HrSetupDiGetClassDevs (MAP_NETCLASS_TO_GUID[Class],
                    NULL, NULL, DIGCF_PROFILE, &hdi);

            if (S_OK == hr)
            {
                SP_DEVINFO_DATA deid;
                WCHAR szPnpId [2 * _MAX_PATH];
                WCHAR szFilterName [_MAX_PATH];
                BOOL fr;

                for (dwIndex = 0; S_OK == hr; dwIndex++)
                {
                    hr = HrSetupDiEnumDeviceInfo (hdi, dwIndex, &deid);

                    if (S_OK == hr)
                    {
                        fr = SetupDiGetDeviceInstanceId (
                                hdi, &deid,
                                szPnpId, celems(szPnpId), NULL);

                        if (fr)
                        {
                            // We open with KEY_WRITE because we will be
                            // adding a new value to filter devices we
                            // upgrade.
                            //
                            hr = HrSetupDiOpenDevRegKey (
                                    hdi, &deid,
                                    DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                                    KEY_WRITE | KEY_READ, &hkeyInstance);

                            if (S_OK == hr)
                            {
                                LONG lr;
                                ULONG cbGuid = sizeof(GUID);

                                lr = RegQueryGuid (
                                        hkeyInstance,
                                        L"NetCfgInstanceId",
                                        &InstanceGuid,
                                        &cbGuid);

                                if (!lr)
                                {
                                    BOOL fIsFilterDevice;
                                    HKEY hkeyNdi;

                                    fIsFilterDevice = FALSE;

                                    hr = HrRegOpenKeyEx (
                                            hkeyInstance,
                                            L"Ndi",
                                            KEY_READ,
                                            &hkeyNdi);

                                    if (S_OK == hr)
                                    {
                                        DWORD cbFilterName = sizeof(szFilterName);

                                        hr = HrRegQuerySzBuffer (
                                                hkeyNdi,
                                                L"FilterName",
                                                szFilterName,
                                                &cbFilterName);

                                        if (S_OK == hr)
                                        {
                                            fIsFilterDevice = TRUE;
                                        }

                                        RegCloseKey (hkeyNdi);
                                    }

                                    // If it's a filter device, ignore it in
                                    // pass one and handle it in pass two.
                                    //
                                    if (fIsFilterDevice && (2 == PassNumber))
                                    {
                                        FUpgradeFilterDeviceInstanceKey (
                                                pNetConfig,
                                                hkeyInstance,
                                                szFilterName);
                                    }

                                    // If it's not a filter device, handle it
                                    // in pass one and ignore it in pass two.
                                    //
                                    else if (!fIsFilterDevice && (1 == PassNumber))
                                    {
                                        UpgradeConnection (InstanceGuid,
                                                szPnpId);

                                        hr = HrLoadAndAddComponentFromInstanceKey (
                                                hkeyInstance,
                                                &InstanceGuid,
                                                Class,
                                                szPnpId,
                                                pNetConfig);
                                    }
                                }

                                RegCloseKey (hkeyInstance);
                            }
                        }

                        // Ignore any errors during the loop
                        hr = S_OK;
                    }
                }
                if (HRESULT_FROM_WIN32(ERROR_NO_MORE_ITEMS) == hr)
                {
                    hr = S_OK;
                }

                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
    }

    if (S_OK == hr)
    {
        hr = HrLoadComponentReferencesFromLegacy (pNetConfig);
    }

    if (S_OK == hr)
    {
        CComponentList::iterator iter;
        CComponent* pComponent;
        CBindPath BindPath;
        CBindingSet BindSet;
        HKEY hkeyParent;
        HKEY hkeyDisabled;

        // Upgrade disabled bindings.
        //
        for (iter  = pNetConfig->Core.Components.begin();
             iter != pNetConfig->Core.Components.end();
             iter++)
        {
            pComponent = *iter;
            Assert (pComponent);

            // Open the parent of the linkage key depending on what type
            // of component this is.
            //
            if (FIsEnumerated (pComponent->Class()) || !pComponent->FHasService())
            {
                hr = pComponent->HrOpenInstanceKey (KEY_READ, &hkeyParent,
                        NULL, NULL);
            }
            else
            {
                hr = pComponent->HrOpenServiceKey (KEY_READ, &hkeyParent);
            }

            // Open the Linkage\Disabled key.
            //
            if (S_OK == hr)
            {
                hr = HrRegOpenKeyEx (hkeyParent, L"Linkage\\Disabled",
                        KEY_READ,
                        &hkeyDisabled);

                if (S_OK == hr)
                {
                    PWSTR pmszBindPath;

                    hr = HrRegQueryMultiSzWithAlloc (
                            hkeyDisabled,
                            L"BindPath",
                            &pmszBindPath);

                    if (S_OK == hr)
                    {
                        PWSTR pszBindPath;
                        PCWSTR pszBindName;
                        PWSTR pszNext;
                        CComponent* pOther;

                        // Get the components current bindings as they
                        // exist in the new engine.  We won't disable
                        // any bindings that don't exist in this set.
                        //
                        (VOID) pNetConfig->Core.HrGetComponentBindings (
                                pComponent,
                                GBF_DEFAULT,
                                &BindSet);

                        // Iterate the multi-sz of disabled bindpaths.
                        //
                        for (pszBindPath = pmszBindPath;
                             *pszBindPath;
                             pszBindPath += wcslen(pszBindPath) + 1)
                        {
                            // The bindpath will start with this component
                            // that has the disabled bindings.
                            //
                            BindPath.Clear();
                            BindPath.HrAppendComponent (pComponent);

                            for (pszBindName = GetNextStringToken (pszBindPath, L"_", &pszNext);
                                 pszBindName && *pszBindName;
                                 pszBindName = GetNextStringToken (NULL, L"_", &pszNext))
                            {
                                pOther = pNetConfig->Core.Components.
                                            PFindComponentByBindName (
                                                NC_INVALID, pszBindName);

                                if (!pOther)
                                {
                                    break;
                                }

                                BindPath.HrAppendComponent (pOther);
                            }

                            // If the bindpath is valid, disable it.
                            //
                            if (BindSet.FContainsBindPath (&BindPath))
                            {
                                pNetConfig->Core.HrDisableBindPath (&BindPath);
                            }
                        }

                        MemFree (pmszBindPath);
                    }

                    RegCloseKey (hkeyDisabled);
                }

                RegCloseKey (hkeyParent);
            }
        }

        // If we can't upgrade disabled bindings, no biggee.
        //
        hr = S_OK;
    }

    TraceHr (ttidError, FAL, hr, FALSE, "HrLoadNetworkConfigurationFromLegacy");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\util.cpp ===
#include <pch.h>
#pragma hdrstop
#include "comp.h"
#include "nccom.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "util.h"

VOID
CreateInstanceKeyPath (
    NETCLASS Class,
    const GUID& InstanceGuid,
    PWSTR pszPath)
{
    PCWSTR pszNetworkSubtreePath;

    Assert (pszPath);

    pszNetworkSubtreePath = MAP_NETCLASS_TO_NETWORK_SUBTREE[Class];
    AssertSz (pszNetworkSubtreePath,
        "This class does not use the network subtree.");

    wcscpy (pszPath, pszNetworkSubtreePath);
    wcscat (pszPath, L"\\");

    INT cch = StringFromGUID2 (
                InstanceGuid,
                pszPath + wcslen(pszPath),
                c_cchGuidWithTerm);
    Assert (c_cchGuidWithTerm == cch);
}

HRESULT
HrOpenDeviceInfo (
    IN NETCLASS Class,
    IN PCWSTR pszPnpId,
    OUT HDEVINFO* phdiOut,
    OUT SP_DEVINFO_DATA* pdeidOut)
{
    HRESULT hr;

    Assert (FIsEnumerated(Class));
    Assert (pszPnpId && *pszPnpId);
    Assert (phdiOut);
    Assert (pdeidOut);

    hr = HrSetupDiCreateDeviceInfoList (
            NULL,
            NULL,
            phdiOut);

    if (S_OK == hr)
    {
        hr = HrSetupDiOpenDeviceInfo (
                *phdiOut,
                pszPnpId,
                NULL,
                0,
                pdeidOut);

        // On failure, cleanup the hdevinfo.
        //
        if (S_OK != hr)
        {
            SetupDiDestroyDeviceInfoList (*phdiOut);
            *phdiOut = NULL;
        }
    }


    TraceHr (ttidError, FAL, hr, SPAPI_E_NO_SUCH_DEVINST == hr,
            "HrOpenDeviceInfo (%S)", pszPnpId);
    return hr;
}


HRESULT
HrOpenComponentInstanceKey (
    IN NETCLASS Class,
    IN const GUID& InstanceGuid, OPTIONAL
    IN PCWSTR pszPnpId, OPTIONAL
    IN REGSAM samDesired,
    OUT HKEY* phkey,
    OUT HDEVINFO* phdiOut OPTIONAL,
    OUT SP_DEVINFO_DATA* pdeidOut OPTIONAL)
{
    HRESULT hr;
    WCHAR szInstanceKeyPath [_MAX_PATH];

    Assert (FIsValidNetClass(Class));
    Assert (FImplies(FIsConsideredNetClass(Class), pszPnpId && *pszPnpId));
    Assert (phkey);
    Assert ((phdiOut && pdeidOut) || (!phdiOut && !pdeidOut));

    *phkey = NULL;

    if (phdiOut)
    {
        *phdiOut = NULL;
    }

    // Non-enumerated components have there instance key under the Network
    // tree.
    //
    if (!FIsEnumerated (Class))
    {
        CreateInstanceKeyPath(Class, InstanceGuid, szInstanceKeyPath);

        hr = HrRegOpenKeyEx (
                HKEY_LOCAL_MACHINE,
                szInstanceKeyPath,
                samDesired,
                phkey);

        TraceHr (ttidError, FAL, hr, FALSE, "HrOpenInstanceKey (%S)",
            szInstanceKeyPath);
    }

    // For enumerated components, we get the instance key from PnP.
    //
    else
    {
        Assert (pszPnpId);

        HDEVINFO hdi;
        SP_DEVINFO_DATA deid;
        SP_DEVINFO_DATA* pdeid;

        pdeid = (pdeidOut) ? pdeidOut : &deid;

        hr = HrOpenDeviceInfo (Class, pszPnpId, &hdi, pdeid);

        if (S_OK == hr)
        {
            hr = HrSetupDiOpenDevRegKey (
                    hdi,
                    pdeid,
                    DICS_FLAG_GLOBAL,
                    0,
                    DIREG_DRV,
                    samDesired,
                    phkey);

            if (S_OK == hr)
            {
                if (phdiOut)
                {
                    *phdiOut = hdi;
                }
            }

            // On error, or if the caller doesn't want the HDEVINFO, free it.
            //
            if (!phdiOut || (S_OK != hr))
            {
                SetupDiDestroyDeviceInfoList (hdi);
            }
        }
        else if ((SPAPI_E_NO_SUCH_DEVINST == hr) && (KEY_READ == samDesired))
        {
            // The instance key may not exist for the case when the
            // class installer is called to remove an enumerated
            // component and then notifies us to remove its bindings.
            // For this case, the class installer has created a
            // temporary key under the Network subtree that we can use
            // to read a limited set of the data (namely LowerRange and
            // UpperRange) we'll need to finish off the removal.
            //
            // We only do this for KEY_READ since there is no point in
            // allowing anyone else to write to this key.  This prevents
            // HrCreateLinkageKey in particular from trying to write
            // to this key.
            //
            wcscpy (szInstanceKeyPath,
                    c_szTempNetcfgStorageForUninstalledEnumeratedComponent);

            INT cch = StringFromGUID2 (
                        InstanceGuid,
                        szInstanceKeyPath + wcslen(szInstanceKeyPath),
                        c_cchGuidWithTerm);
            Assert (c_cchGuidWithTerm == cch);

            hr = HrRegOpenKeyEx (
                    HKEY_LOCAL_MACHINE,
                    szInstanceKeyPath,
                    KEY_READ,
                    phkey);

            if (S_OK != hr)
            {
                hr = SPAPI_E_NO_SUCH_DEVINST;
            }
        }

        TraceHr (ttidError, FAL, hr,
            (SPAPI_E_NO_SUCH_DEVINST == hr),
            "HrOpenInstanceKey (%S)", pszPnpId);
    }

    return hr;
}

HRESULT
HrOpenNetworkKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey)
{
    HRESULT hr;

    hr = HrRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            L"System\\CurrentControlSet\\Control\\Network",
            samDesired,
            phkey);

    TraceHr (ttidError, FAL, hr, FALSE, "HrOpenNetworkKey");
    return hr;
}

HRESULT
HrRegCreateKeyWithWorldAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkey,
    LPDWORD pdwDisposition)
{
    HRESULT hr;
    SECURITY_ATTRIBUTES sa = {0};
    PSECURITY_DESCRIPTOR pSd;

    // Create the correct descriptor. If this fails, we'll still
    // create the key, it's just that if a service running as
    // localsystem is creating this key, and a user process tries
    // to open it, it will fail.
    //
    hr = HrAllocateSecurityDescriptorAllowAccessToWorld (&pSd);

    if (S_OK == hr)
    {
        sa.nLength = sizeof(sa);
        sa.lpSecurityDescriptor = pSd;
        sa.bInheritHandle = FALSE;
    }
    else
    {
        Assert (!pSd);
        TraceHr (ttidError, FAL, hr, FALSE,
            "HrAllocateSecurityDescriptorAllowAccessToWorld "
            "failed in HrRegCreateKeyWithWorldAccess");
    }

    hr = HrRegCreateKeyEx (
            hkey,
            pszSubkey,
            dwOptions,
            samDesired,
            (pSd) ? &sa : NULL,
            phkey,
            pdwDisposition);

    MemFree (pSd);

    TraceHr (ttidError, FAL, hr, FALSE, "HrRegCreateKeyWithWorldAccess");
    return hr;
}

PWSTR
GetNextStringToken (
    IN OUT PWSTR pszString,
    IN PCWSTR pszDelims,
    OUT PWSTR* ppszNextToken)
{
    const WCHAR* pchDelim;
    PWSTR pszToken;

    Assert (pszDelims);
    Assert (ppszNextToken);

    // If pszString is NULL, continue with the previous string.
    //
    if (!pszString)
    {
        pszString = *ppszNextToken;
        Assert (pszString);
    }

    // Find the beginning of the token by skipping over the leading
    // delimiters.  Note that there is no token if and only if this loop
    // sets pszString to point to the terminating NULL.
    //
    while (*pszString)
    {
        pchDelim = pszDelims;
        while (*pchDelim && (*pchDelim != *pszString))
        {
             pchDelim++;
        }

        if (!*pchDelim)
        {
            // Current string character is not a delimiter, so it must
            // be part of the token.  Break the loop and go find the
            // whole token.
            //
            break;
        }

        pszString++;
    }

    pszToken = pszString;

    // Find the end of the token.  If it is not the end of the string,
    // put a NULL there.
    //
    while (*pszString)
    {
        pchDelim = pszDelims;
        while (*pchDelim && (*pchDelim != *pszString))
        {
             pchDelim++;
        }

        if (*pchDelim)
        {
            // Found a delimiter so this ends the token.  Advance
            // pszString so that we'll set *ppszNextToken for next time.
            //
            *pszString = 0;
            pszString++;
            break;
        }

        pszString++;
    }

    // Remember where we left off for the next token.
    //
    *ppszNextToken = pszString;

    // Return the token if we found it.
    //
    if (pszToken == pszString)
    {
        return NULL;
    }
    else
    {
        return pszToken;
    }
}

VOID
SignalNetworkProviderLoaded (
    VOID)
{
    HANDLE Event;
    UNICODE_STRING EventName;
    OBJECT_ATTRIBUTES EventAttr;
    NTSTATUS Status;

    RtlInitUnicodeString (
        &EventName,
        L"\\Security\\NetworkProviderLoad");

    InitializeObjectAttributes (
        &EventAttr,
        &EventName,
        OBJ_CASE_INSENSITIVE,
        NULL, NULL);

    Status = NtOpenEvent (
                &Event,
                EVENT_QUERY_STATE | EVENT_MODIFY_STATE | SYNCHRONIZE,
                &EventAttr);

    if (NT_SUCCESS(Status))
    {
        SetEvent (Event);
        CloseHandle (Event);
    }
    else
    {
        ULONG Win32Error;

        Win32Error = RtlNtStatusToDosError(Status);
        SetLastError(Win32Error);

        TraceHr (ttidError, FAL, HrFromLastWin32Error(), FALSE,
            "SignalNetworkProviderLoaded");
    }
}

BOOL
CDynamicBuffer::FGrowBuffer (
    ULONG cbGrow)
{
    PBYTE pbNew;

    // If it hasn't been set, use a default of 4096.
    if (!m_cbGranularity)
    {
        m_cbGranularity = 4096;
    }

    if (cbGrow % m_cbGranularity)
    {
        cbGrow = (cbGrow + m_cbGranularity) - (cbGrow % m_cbGranularity);
    }

    pbNew = (PBYTE)MemAlloc (m_cbAllocated + cbGrow);

    if (pbNew)
    {
#ifdef ENABLETRACE
        if (m_pbBuffer)
        {
            TraceTag (ttidDefault, "Dynamic buffer grown.  New size = %d.",
                m_cbAllocated + cbGrow);
        }
#endif

        CopyMemory (pbNew, m_pbBuffer, m_cbConsumed);
        MemFree (m_pbBuffer);
        m_pbBuffer = pbNew;
        m_cbAllocated += cbGrow;
    }

    return !!pbNew;
}

HRESULT
CDynamicBuffer::HrReserveBytes (
    ULONG cbReserve)
{
    if (cbReserve > m_cbAllocated)
    {
        return (FGrowBuffer(cbReserve)) ? S_OK : E_OUTOFMEMORY;
    }
    return S_OK;
}

HRESULT
CDynamicBuffer::HrCopyBytes (
    const BYTE* pbSrc,
    ULONG cbSrc)
{
    Assert (pbSrc);
    Assert (m_cbAllocated >= m_cbConsumed);

    if (cbSrc > m_cbAllocated - m_cbConsumed)
    {
        if (!FGrowBuffer (cbSrc))
        {
            return E_OUTOFMEMORY;
        }
    }

    CopyMemory (m_pbBuffer + m_cbConsumed, pbSrc, cbSrc);
    m_cbConsumed += cbSrc;

    return S_OK;
}

HRESULT
CDynamicBuffer::HrCopyString (
    PCWSTR pszSrc)
{
    ULONG cbSrc;

    cbSrc = CbOfSzAndTermSafe(pszSrc);

    return HrCopyBytes ((const BYTE*)pszSrc, cbSrc);
}

BOOL
FIsFilterDevice (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    WCHAR szFilterInfId[_MAX_PATH];
    BOOL fIsFilterDevice = FALSE;
    HKEY hkeyInstance;
    HRESULT hr;

    // Open the device's driver key.
    //
    hr = HrSetupDiOpenDevRegKey (
            hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV,
            KEY_READ, &hkeyInstance);

    if (S_OK == hr)
    {
        // Get the filterinfid value.  If present, then
        // this device is a filter device.
        //
        DWORD cbFilterInfId = sizeof(szFilterInfId);

        hr = HrRegQuerySzBuffer (
                hkeyInstance,
                L"FilterInfId",
                szFilterInfId,
                &cbFilterInfId);

        if (S_OK == hr)
        {
            fIsFilterDevice = TRUE;
        }

        RegCloseKey (hkeyInstance);
    }

    return fIsFilterDevice;
}

VOID
AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
    IN OUT CComponent* pComponent)
{

    ASSERT (pComponent);

    // Special case: NCF_DONTEXPOSELOWER
    // SPX has erroneously set this characteristic. It's not really
    // needed as nothing binds with SPX.  Having it set means that
    // two components above IPX have this characteristic set.  (NWNB
    // is the other.  The code to generate bindpaths by recursing
    // the stack table is only setup to handle at most one component
    // with this characteristic per pass.  Turning it off for SPX
    // solves this in the simplest way.
    //
    // Furthermore, enforce that only IPX and NWNB have this
    // characteristic set..
    //
    //
    if ((0 == wcscmp(L"ms_nwnb",  pComponent->m_pszInfId)) ||
        (0 == wcscmp(L"ms_nwipx", pComponent->m_pszInfId)))
    {
        pComponent->m_dwCharacter |= NCF_DONTEXPOSELOWER;
    }
    else
    {
        pComponent->m_dwCharacter &= ~NCF_DONTEXPOSELOWER;
    }
    // End Special case
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\wscfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W S C F G . C P P
//
//  Contents:   Winsock configuration routines.
//
//  Notes:
//
//  Author:     shaunco   15 Feb 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "nceh.h"
#include "wscfg.h"
extern "C"
{
#include <wsasetup.h>
}

HRESULT
HrMigrateWinsockConfiguration (
    VOID)
{
    HRESULT hr;

    NC_TRY
    {
        WSA_SETUP_DISPOSITION Disposition;
        DWORD dwErr = MigrateWinsockConfiguration (&Disposition, NULL, 0);
        hr = HRESULT_FROM_WIN32(dwErr);
    }
    NC_CATCH_ALL
    {
        hr = E_UNEXPECTED;
    }
    TraceHr (ttidError, FAL, hr, FALSE, "HrMigrateWinsockConfiguration");
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\util.h ===
#pragma once

#include "compdefs.h"
#include "comp.h"

BOOL
FIsFilterDevice (HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

PWSTR
GetNextStringToken (
    IN OUT PWSTR pszString,
    IN PCWSTR pszDelims,
    OUT PWSTR* ppszNextToken);

HRESULT
HrOpenNetworkKey (
    IN REGSAM samDesired,
    OUT HKEY* phkey);

HRESULT
HrRegCreateKeyWithWorldAccess (
    HKEY hkey,
    PCWSTR pszSubkey,
    DWORD dwOptions,
    REGSAM samDesired,
    PHKEY phkey,
    LPDWORD pdwDisposition);

LONG
RegQueryValueType (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    IN DWORD dwType,
    OUT BYTE* pbData OPTIONAL,
    IN OUT DWORD* pcbData);

LONG
RegQueryGuid (
    IN HKEY hkey,
    IN PCWSTR pszValueName,
    OUT GUID* pguidData OPTIONAL,
    IN OUT DWORD* pcbData
    );

VOID
SignalNetworkProviderLoaded (
    VOID);

VOID
CreateInstanceKeyPath (
    NETCLASS Class,
    const GUID& InstanceGuid,
    PWSTR pszPath);

VOID
AddOrRemoveDontExposeLowerCharacteristicIfNeeded (
    IN OUT CComponent* pComponent);

class CDynamicBuffer
{
private:
    PBYTE   m_pbBuffer;
    ULONG   m_cbConsumed;
    ULONG   m_cbAllocated;
    ULONG   m_cbGranularity;

    BOOL
    FGrowBuffer (
        ULONG cbGrow);

public:
    CDynamicBuffer ()
    {
        ZeroMemory (this, sizeof(*this));
    }
    ~CDynamicBuffer ()
    {
        MemFree (m_pbBuffer);
    }

    VOID
    Clear ()
    {
        // Most of the time, the buffer is treated as a string.  Setting
        // the buffer to an empty string is a convienence for callers who
        // clear the buffer then try to use it as a string.  This way, they
        // don't have to check the CountOfBytesUsed before accessing the
        // buffer contents.
        //
        AssertH (m_pbBuffer);
        AssertH (m_cbAllocated > sizeof(WCHAR));
        *((PWCHAR)m_pbBuffer) = 0;

        m_cbConsumed = 0;
    }

    ULONG
    CountOfBytesUsed ()
    {
        return m_cbConsumed;
    }

    const BYTE*
    PbBuffer ()
    {
        AssertH (m_pbBuffer);
        return m_pbBuffer;
    }

    VOID
    SetGranularity (
        ULONG cbGranularity)
    {
        m_cbGranularity = cbGranularity;
    }

    HRESULT
    HrReserveBytes (
        ULONG cbReserve);

    HRESULT
    HrCopyBytes (
        const BYTE* pbSrc,
        ULONG cbSrc);

    HRESULT
    HrCopyString (
        PCWSTR pszSrc);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\wrlock.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W R L O C K . H
//
//  Contents:   Defines the interface to the netcfg write lock used to
//              protect the network configuration information from being
//              modified by more than one writer at a time.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once

// This is the interface to the write lock that INetCfg uses.
//
class CWriteLock : CNetCfgDebug<CWriteLock>
{
private:
    HANDLE  m_hMutex;
    BOOL    m_fOwned;

private:
    HRESULT
    HrEnsureMutexCreated ();

    VOID
    SetOrQueryLockHolder (
        IN BOOL fSet,
        IN PCWSTR pszNewOwnerDesc,
        OUT PWSTR* ppszCurrentOwnerDesc);

public:
    CWriteLock ()
    {
        m_hMutex = NULL;
        m_fOwned = FALSE;
    }

    ~CWriteLock ();

    BOOL
    WaitToAcquire (
        IN DWORD dwMilliseconds,
        IN PCWSTR pszNewOwnerDesc,
        OUT PWSTR* ppszCurrentOwnerDesc);

    BOOL
    FIsLockedByAnyone (
        OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL);

    BOOL
    FIsOwnedByMe ()
    {
        AssertH (FImplies(m_fOwned, m_hMutex));
        return m_fOwned;
    }

    VOID
    ReleaseIfOwned ();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\wrlock.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W R L O C K . C P P
//
//  Contents:   Defines the interface to the netcfg write lock used to
//              protect the network configuration information from being
//              modified by more than one writer at a time.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#include <pch.h>
#pragma hdrstop
#include "lm.h"
#include "nccom.h"
#include "ncreg.h"
#include "util.h"
#include "wrlock.h"

#define MUTEX_NAME          L"Global\\NetCfgWriteLock"
#define LOCK_HOLDER_SUBKEY  L"NetCfgLockHolder"


CWriteLock::~CWriteLock ()
{
    // If we have the mutex created, release it if we own it
    // and close its handle.
    //
    if (m_hMutex)
    {
        ReleaseIfOwned ();
        CloseHandle (m_hMutex);
    }
}

HRESULT
CWriteLock::HrEnsureMutexCreated ()
{
    if (m_hMutex)
    {
        return S_OK;
    }

    // Ensure the mutex has been created.  It is important to create it
    // with a security descriptor that allows access to the world because
    // we may be running under the localsystem account and someone else
    // may be running under a user account.  If we didn't give the world
    // explicit access, the user account clients would get access denied
    // because the mutex would have inherited the security level of our
    // process.
    //
    HRESULT hr;
    Assert (!m_hMutex);
    Assert (!m_fOwned);

    hr = HrCreateMutexWithWorldAccess (
            MUTEX_NAME,
            FALSE, // not initially owned,
            NULL,
            &m_hMutex);

    TraceHr (ttidError, FAL, hr, FALSE, "CWriteLock::HrEnsureMutexCreated");
    return hr;
}

BOOL
CWriteLock::WaitToAcquire (
    IN DWORD dwMilliseconds,
    IN PCWSTR pszNewOwnerDesc,
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    HRESULT hr;
    BOOL fAcquired = FALSE;

    hr = HrEnsureMutexCreated ();
    if (S_OK == hr)
    {
        // Now wait for the mutext to become available.  (Pump messages while
        // waiting so we don't hang the clients UI.)
        //
        while (1)
        {
            DWORD dwWait;

            dwWait = MsgWaitForMultipleObjects (
                        1, &m_hMutex, FALSE,
                        dwMilliseconds, QS_ALLINPUT);

            if ((WAIT_OBJECT_0 + 1) == dwWait)
            {
                // We have messages to pump.
                //
                MSG msg;
                while (PeekMessage (&msg, NULL, NULL, NULL, PM_REMOVE))
                {
                    DispatchMessage (&msg);
                }
            }
            else
            {
                if (WAIT_OBJECT_0 == dwWait)
                {
                    fAcquired = TRUE;
                }
                else if (WAIT_ABANDONED_0 == dwWait)
                {
                    fAcquired = TRUE;
                    TraceTag (ttidError, "NetCfg write lock was abandoned!");
                }
                else if (WAIT_TIMEOUT == dwWait)
                {
                    hr = HRESULT_FROM_WIN32 (ERROR_TIMEOUT);
                }
                else
                {
                    hr = HrFromLastWin32Error ();
                    TraceHr (ttidError, FAL, hr, FALSE,
                        "MsgWaitForMultipleObjects");
                }

                // If we acquired the mutex, set the new owner.
                //
                if (fAcquired)
                {
                    m_fOwned = TRUE;
                    SetOrQueryLockHolder (TRUE,
                        pszNewOwnerDesc, ppszCurrentOwnerDesc);
                }
                else if (ppszCurrentOwnerDesc)
                {
                    // Query the lock holder description.
                    //
                    SetOrQueryLockHolder (FALSE,
                        NULL, ppszCurrentOwnerDesc);
                }

                break;
            }
        }
    }

    return fAcquired;
}

BOOL
CWriteLock::FIsLockedByAnyone (
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    // It's locked if we own it.
    //
    BOOL fLocked = m_fOwned;

    // If we don't own it, check to see if some other process does.
    //
    if (!fLocked)
    {
        HRESULT hr;

        hr = HrEnsureMutexCreated ();
        if (S_OK == hr)
        {
            DWORD dw;

            // Wait for the mutex, but with a zero timeout.  This is
            // equivalent to a quick check.  (But we still need to release
            // it if we acquire ownership.  If we timeout, it means that
            // someone else owns it.
            //
            dw = WaitForSingleObject (m_hMutex, 0);

            if (WAIT_OBJECT_0 == dw)
            {
                ReleaseMutex (m_hMutex);
            }
            else if (WAIT_TIMEOUT == dw)
            {
                // Someone else owns it.
                //
                fLocked = TRUE;
            }
        }
    }

    if (fLocked)
    {
        // Query the lock holder description.
        //
        SetOrQueryLockHolder (FALSE, NULL, ppszCurrentOwnerDesc);
    }

    return fLocked;
}

VOID
CWriteLock::ReleaseIfOwned ()
{
    if (m_fOwned)
    {
        Assert (m_hMutex);

        // Clear the lock holder now that no one is about to own it.
        //
        SetOrQueryLockHolder (TRUE, NULL, NULL);

        ReleaseMutex (m_hMutex);
        m_fOwned = FALSE;
    }
}

VOID
CWriteLock::SetOrQueryLockHolder (
    IN BOOL fSet,
    IN PCWSTR pszNewOwnerDesc OPTIONAL,
    OUT PWSTR* ppszCurrentOwnerDesc OPTIONAL)
{
    HRESULT hr;
    HKEY hkeyNetwork;
    HKEY hkeyLockHolder;
    REGSAM samDesired;
    BOOL fClear;

    // We're clearing the value if we're asked to set it to NULL.
    //
    fClear = fSet && !pszNewOwnerDesc;

    // Initialize the output parameter if specified.
    //
    if (ppszCurrentOwnerDesc)
    {
        *ppszCurrentOwnerDesc = NULL;
    }

    // If we're setting the lock holder, we need write access.  Otherwise,
    // we only need read access.
    //
    samDesired = (fSet) ? KEY_READ_WRITE_DELETE : KEY_READ;

    hr = HrOpenNetworkKey (samDesired, &hkeyNetwork);

    if (S_OK == hr)
    {
        // The lock holder is represented by the default value of a
        // volatile subkey under the Network subtree.
        //

        if (fClear)
        {
            RegDeleteKey (hkeyNetwork, LOCK_HOLDER_SUBKEY);
        }
        else if (fSet)
        {
            DWORD dwDisposition;

            Assert (pszNewOwnerDesc);

            hr = HrRegCreateKeyWithWorldAccess (
                    hkeyNetwork,
                    LOCK_HOLDER_SUBKEY,
                    REG_OPTION_VOLATILE,
                    KEY_WRITE,
                    &hkeyLockHolder,
                    &dwDisposition);

            // Set the lock holder and close the key.
            //
            if (S_OK == hr)
            {
                (VOID) HrRegSetSz (hkeyLockHolder, NULL, pszNewOwnerDesc);

                RegCloseKey (hkeyLockHolder);
            }
        }
        else
        {
            // Query for the lock holder by opening the key (if it exists)
            // and reading the default value.  We return the string
            // allocated with CoTaskMemAlloc because we use this
            // directly from the COM implementation.
            //
            Assert (ppszCurrentOwnerDesc);

            hr = HrRegOpenKeyEx (
                    hkeyNetwork,
                    LOCK_HOLDER_SUBKEY,
                    KEY_READ,
                    &hkeyLockHolder);

            if (S_OK == hr)
            {
                PWSTR pszLockHolder;

                hr = HrRegQuerySzWithAlloc (
                        hkeyLockHolder,
                        NULL,
                        &pszLockHolder);

                if (S_OK == hr)
                {
                    hr = HrCoTaskMemAllocAndDupSz (
                            pszLockHolder, ppszCurrentOwnerDesc, UNLEN);

                    MemFree (pszLockHolder);
                }
                RegCloseKey (hkeyLockHolder);
            }
        }

        RegCloseKey (hkeyNetwork);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\stable.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       S T A B L E . H
//
//  Contents:   Defines the datatypes to represent stack entries and stack
//              tables.
//
//  Notes:
//
//  Author:     shaunco   15 Jan 1999
//
//----------------------------------------------------------------------------

#pragma once
#include "bindings.h"
#include "comp.h"

class CStackEntry : public CNetCfgDebug<CStackEntry>
{
public:
    const CComponent*  pUpper;
    const CComponent*  pLower;

public:
    BOOL
    operator== (
        const CStackEntry& Other) const
    {
        return (pUpper == Other.pUpper) && (pLower == Other.pLower);
    }
};


class CModifyContext;

enum MOVE_FLAG
{
    MOVE_BEFORE = 1,
    MOVE_AFTER = 2,
};

class CStackTable : public CNetCfgDebug<CStackTable>,
                    public vector<CStackEntry>
{
public:
    // This flag indicates how WAN adapters are inserted into the stack
    // table.  If TRUE, they are inserted before any LAN adapters.  If
    // FALSE, they are inserted after any LAN adapters.
    //
    BOOL    m_fWanAdaptersFirst;

public:
    VOID
    Clear ()
    {
        clear ();
    }

    UINT
    CountEntries ()
    {
        return size();
    }

    BOOL
    FIsEmpty () const
    {
        return empty();
    }

    BOOL
    FStackEntryInTable (
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower) const;

    HRESULT
    HrCopyStackTable (
        IN const CStackTable* pSourceTable);

    HRESULT
    HrInsertStackEntriesForComponent (
        IN const CComponent* pComponent,
        IN const CComponentList* pComponents,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrUpdateEntriesForComponent (
        IN const CComponent* pComponent,
        IN const CComponentList* pComponents,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrInsertStackEntry (
        IN const CStackEntry* pStackEntry,
        IN DWORD dwFlags /* INS_FLAGS */);

    HRESULT
    HrMoveStackEntries (
        IN const CStackEntry* pSrc,
        IN const CStackEntry* pDst,
        IN MOVE_FLAG Flag,
        IN CModifyContext* pModifyCtx);

    HRESULT
    HrReserveRoomForEntries (
        IN UINT cEntries);

    VOID
    RemoveEntriesWithComponent (
        IN const CComponent* pComponent);

    VOID
    SetWanAdapterOrder (
        IN BOOL fWanAdaptersFirst);

    VOID
    RemoveStackEntry(
        IN const CComponent*  pUpper,
        IN const CComponent*  pLower);
};


class CNetConfigCore;

// Context structure for recursive function GetBindingsBelowComponent.
//
struct GBCONTEXT
{
    // The core to reference for generating the binding set.
    //
    IN const CNetConfigCore*    pCore;

    // The binding set to generate based on pSourceComponent.
    //
    IN OUT  CBindingSet*        pBindSet;

    // The component to start with when generating the binding set.
    //
    IN      const CComponent*   pSourceComponent;

    // If TRUE, do not add those bindpaths to pBindSet that exist in
    // pCore->DisabledBindings.  This feature is used when we generate the
    // bindings that get written to the registry.
    //
    IN      BOOL                fPruneDisabledBindings;

    // Special case: NCF_DONTEXPOSELOWER
    //
    IN      DWORD               dwAddBindPathFlags;

    // The result of the operation.
    //
    OUT     HRESULT             hr;

    // This is the bindpath that is built up via recursion.  It is
    // added to the binding set when recursion finishes.
    //
    OUT     CBindPath           BindPath;
};


// Context structure for recursive functions:
//   GetComponentsAboveComponent
//
struct GCCONTEXT
{
    // The stack table to reference for generating the component list.
    //
    IN      const CStackTable*  pStackTable;

    // The component list to generate.
    //
    IN OUT  CComponentList*     pComponents;

    // If TRUE, don't stop recursing at NCF_DONTEXPOSELOWER components.
    //
    IN      BOOL                fIgnoreDontExposeLower;

    // The result of the operation.
    //
    OUT     HRESULT             hr;
};

VOID
GetComponentsAboveComponent (
    IN const CComponent* pComponent,
    IN OUT GCCONTEXT* pCtx);

VOID
GetBindingsBelowComponent (
    IN      const CComponent*   pComponent,
    IN OUT  GBCONTEXT*            pCtx);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\engine\wscfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       W S C F G . H
//
//  Contents:   Winsock configuration routines.
//
//  Notes:
//
//  Author:     shaunco   15 Feb 1999
//
//----------------------------------------------------------------------------

#pragma once

HRESULT
HrMigrateWinsockConfiguration (
    VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\ipctrl.h ===
//-------------------------------------------------------------------
// I P C T R L . H
//
// IP Address control helper class declaration
//-------------------------------------------------------------------

#pragma once
#include "ncstring.h"

class IpControl
{
public:
    IpControl();
    ~IpControl();

// Implementation
public:
    BOOL Create(HWND hParent, UINT nId);
    operator HWND() {AssertH(m_hIpAddress); return m_hIpAddress;}

    BOOL IsBlank();
    void SetFocusField(DWORD dwField);
    void SetFieldRange(DWORD dwField, DWORD dwMin, DWORD dwMax);
    void ClearAddress();

    void SetAddress(DWORD adwAddress[4]);
    void SetAddress(DWORD dw1, DWORD dw2, DWORD dw3, DWORD dw4);
    void SetAddress(PCWSTR szString);

    void GetAddress(DWORD adwAddress[4]);
    void GetAddress(DWORD * dw1, DWORD * dw2, DWORD * dw3, DWORD * dw4);
    void GetAddress(tstring * pstrAddress);

    LRESULT SendMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    HWND m_hIpAddress;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\ncres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C R E S . H
//
//  Contents:   Resource ID ranges
//
//  Notes:
//
//  Author:     shaunco   23 Apr 1997
//
//----------------------------------------------------------------------------

#pragma once

#define IDC_STATIC          -1

#define IDS_NC_ATMCFG       10000
#define IDS_NC_DHCPCFG      11000
#define IDS_NC_MSCLICFG     12000
#define IDS_NC_NBFCFG       13000
#define IDS_NC_NETCFG       14000
#define IDS_NC_NETCOMM      15000
#define IDS_NC_NWCLICFG     16000
#define IDS_NC_NWLNKCFG     17000
#define IDS_NC_RASCFG       19000
#define IDS_NC_SAPCFG       20000
#define IDS_NC_SRVRCFG      22000
#define IDS_NC_TCPIPCFG     23000
#define IDS_NC_COMMON       24000
#define IDS_NC_ATLKCFG      25000
#define IDS_NC_STRMCFG      26000
#define IDS_NC_ISDNCFG      27000
#define IDS_NC_ALANECFG     28000
#define IDS_NC_COMP_HELP_TEXT       50000  // component help text

// ATL Registration IDs
//
#define IDR_REG_ALANECFG            31000
#define IDR_REG_ARPSCFG             31001
#define IDR_REG_ATLKCFG             31002
#define IDR_REG_AUNICFG             31003
#define IDR_REG_DHCPSCFG            31004
#define IDR_REG_L2TP                31005
#define IDR_REG_MSCLICFG            31006
#define IDR_REG_NBFCFG              31007
#define IDR_REG_NDISWAN             31008
#define IDR_REG_NETCFG              31009
#define IDR_REG_NWCLICFG            31011
#define IDR_REG_NWLNKIPX            31012
#define IDR_REG_NWLNKNB             31013
#define IDR_REG_PPTP                31014
#define IDR_REG_RASCLI              31017
#define IDR_REG_RASSRV              31019
#define IDR_REG_SAPCFG              31020
#define IDR_REG_SRVRCFG             31021
#define IDR_REG_STEELHEAD           31022
#define IDR_REG_TCPIPCFG            31024
#define IDR_REG_PPPOE               31025


#define IDS_CAPTION_NETCFG              (IDS_NC_COMMON + 1)
#define IDS_COMMONDLG_TEXT              (IDS_NC_COMMON + 2)
#define IDS_TEXT_WITH_WIN32_ERROR       (IDS_NC_COMMON + 4)
#define IDS_UNKNOWN_NETWORK_CARD        (IDS_NC_COMMON + 5)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\ncxclsid.h ===
#include <guiddef.h>

DEFINE_GUID(CLSID_CALaneCfg,    0x295789F0,0x0949,0x11D1,0xB9,0x0C,0x00,0xAA,0x00,0x4A,0xB1,0x2A);
DEFINE_GUID(CLSID_CATlkObj,     0x525609F4,0xD232,0x11D0,0xB7,0x6F,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CArpsCfg,     0x962FFCF3,0x965F,0x11D0,0xA8,0x81,0x00,0xC0,0x4F,0xC9,0x9C,0x9C);
DEFINE_GUID(CLSID_CAtmUniCfg,   0x674D3E3D,0xA1A8,0x11D0,0xA8,0x86,0x00,0xC0,0x4F,0xC9,0x9C,0x9C);
DEFINE_GUID(CLSID_CBridgeObj,   0xa5fda055,0x899d,0x4895,0x97,0xae,0x0c,0xc4,0xfe,0x4e,0x97,0x7f);
DEFINE_GUID(CLSID_CDHCPServer,  0xAA9BB1E0,0x9FE2,0x11D0,0xB2,0x57,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CMSClient,    0x57C06EAA,0x8784,0x11D0,0x83,0xD4,0x00,0xA0,0xC9,0x11,0xE5,0xDF);
DEFINE_GUID(CLSID_CNbfObj,      0xA28D553A,0xA703,0x11D0,0x9C,0xEC,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CNWClient,    0x5BEDF7DE,0x98CF,0x11D0,0xB2,0x55,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CNwlnkIPX,    0xC59938DA,0x9B20,0x11D0,0x9C,0xE3,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CNwlnkNB,     0x050DA15F,0x9F13,0x11D0,0x9C,0xE5,0x00,0xC0,0x4F,0xC9,0xBC,0xC4);
DEFINE_GUID(CLSID_CRasCli,      0x6E65CBC0,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CRasSrv,      0x6E65CBC1,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CNdisWan,     0x6E65CBC3,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CL2tp,        0x6E65CBC6,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CPptp,        0x6E65CBC4,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CSteelhead,   0x6E65CBC5,0x926D,0x11D0,0x8E,0x27,0x00,0xC0,0x4F,0xC9,0x9D,0xCF);
DEFINE_GUID(CLSID_CSAPCfg,      0xB45AFEC0,0x2AE6,0x11D1,0x85,0x9E,0x00,0xC0,0x4F,0xC9,0xE2,0x92);
DEFINE_GUID(CLSID_CSrvrcfg,     0x7F368827,0x9516,0x11D0,0x83,0xD9,0x00,0xA0,0xC9,0x11,0xE5,0xDF);
DEFINE_GUID(CLSID_CTcpipcfg,    0xA907657F,0x6FDF,0x11D0,0x8E,0xFB,0x00,0xC0,0x4F,0xD9,0x12,0xB2);
DEFINE_GUID(CLSID_CWLBS,        0xbf0eaea8,0xc122,0x11d2,0x94,0xf4,0x00,0xc0,0x4f,0x72,0xd8,0xc4);
DEFINE_GUID(CLSID_CPppoe,       0xe949da38,0xc39d,0x4460,0x8e,0xa7,0xa3,0x91,0x52,0xc5,0x68,0x36);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\ncxbase.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       N C X B A S E . H
//
//  Contents:   Base include file for netcfgx.dll.  Defines globals.
//
//  Notes:
//
//  Author:     shaunco   15 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <atlbase.h>
extern CComModule _Module;  // required by atlcom.h
#include <atlcom.h>

#ifdef SubclassWindow
#undef SubclassWindow
#endif
#include <atlwin.h>

#include "ncatl.h"
#include "ncstring.h"
#include "ncnetcfg.h"
#include "ncxclsid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\netpages.h ===
#pragma once

HRESULT
HrGetAdvancedPage(HDEVINFO hdi,
                  PSP_DEVINFO_DATA pdeid,
                  HPROPSHEETPAGE* phpsp);

HRESULT
HrGetIsdnPage(HDEVINFO hdi,
              PSP_DEVINFO_DATA pdeid,
              HPROPSHEETPAGE* phpsp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\pch.h ===
#pragma once

#define COM_NO_WINDOWS_H
#define RPC_NO_WINDOWS_H
#define NOCOMM
#define NOCRYPT
#define NOGDI
#define NOIME
#define NOMCX
#define NOMDI
#define NOMETAFILE
#define NOSOUND
#define NOWH
#define NOWINABLE
#define NOWINRES

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <objbase.h>

#include <cfgmgr32.h>
#include <devguid.h>
#include <setupapi.h>
#include <wchar.h>
#include <shlwapi.h>

#include "ncmem.h"

#include "list"
#include "vector"
using namespace std;

#include "ncbase.h"
#include "ncdebug.h"
#include "ncdefine.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\netcomm.h ===
#pragma once

BOOL
ProcessAnswerFile(
    IN PCWSTR pszAnswerFile,
    IN PCWSTR pszAnswerSections,
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);



VOID
UpdateAdvancedParametersIfNeeded(
    IN HDEVINFO hdi,
    IN PSP_DEVINFO_DATA pdeid);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\inc\atmcommon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1998.
//
//  File:       A T M C O M M O N . H
//
//  Contents:   Common ATM functions
//
//  Notes:
//
//  Author:     tongl   10 Mar 1998
//
//----------------------------------------------------------------------------

#pragma once

// maximum valid address lenght in characters
//
const INT MAX_ATM_ADDRESS_LENGTH = 40;

BOOL FIsValidAtmAddress(PCWSTR szAtmAddress, INT * piErrCharPos, INT * pnId);

BOOL fIsSameVstr(const vector<tstring *> vstr1, const vector<tstring *> vstr2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnshts.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N S H T S . H
//
//  Contents:   Prototypes for the ISDN property sheets and wizard pages
//              dialog procs
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNSHTS_H_
#define _ISDNSHTS_H_

//---[ Prototypes ]-----------------------------------------------------------

VOID SetSwitchType(HWND hwndDlg, INT iItemSwitchType, DWORD dwSwitchType);
DWORD DwGetSwitchType(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci,
                      INT iDialogItem);
VOID PopulateIsdnSwitchTypes(HWND hwndDlg, INT iDialogItem,
                             PISDN_CONFIG_INFO pisdnci);
DWORD DwGetCurrentCountryCode(VOID);
BOOL FIsDefaultForLocale(DWORD nCountry, DWORD dwSwitchType);
VOID PopulateIsdnChannels(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                          INT iLineLB, INT iChannelLB,
                          PISDN_CONFIG_INFO pisdnci);
LONG OnIsdnInfoPageSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnSwitchTypeInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetModifiedIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                                INT iPhoneControl, INT iChannelLB,
                                INT iCurrentChannel,
                                PISDN_CONFIG_INFO pisdnci);
VOID RetrieveIsdnChannelInfo(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                             INT iChannelLB, PISDN_CONFIG_INFO pisdnci,
                             DWORD dwDChannel, INT iCurrentChannel);
VOID OnIsdnInfoPageApply(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizFinish(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageWizBack(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnInfoPageTransition(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetCurrentIsdnChannelSelection(HWND hwndDlg, INT iSpidControl,
                                    INT iPhoneControl, INT iChannelLB,
                                    PISDN_CONFIG_INFO pisdnci,
                                    DWORD dwDChannel, INT * nBChannel);
VOID SetDataToEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                           PISDN_CONFIG_INFO pisdnci, PISDN_B_CHANNEL pisdnbc);
VOID GetDataFromEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                             PISDN_CONFIG_INFO pisdnci,
                             PISDN_B_CHANNEL pisdnbc);
LONG OnIsdnSwitchTypeSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnIsdnSwitchTypeWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);

VOID OnIsdnInfoPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO   pisdnci);

INT_PTR CALLBACK
IsdnInfoPageProc(HWND hDlg, UINT uMessage, WPARAM wparam, LPARAM lparam);

INT_PTR CALLBACK
IsdnSwitchTypeProc(HWND hwndDlg, UINT uMessage, WPARAM wparam, LPARAM lparam);

VOID OnMsnPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID SetDataToListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID GetDataFromListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageAdd(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageRemove(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageEditSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);
VOID OnMsnPageInitDialog(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci);

VOID CheckShowPagesFlag(PISDN_CONFIG_INFO pisdnci);
UINT CALLBACK DestroyWizardData(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp);

struct PAGE_DATA
{
    PISDN_CONFIG_INFO       pisdnci;
    UINT                    idd;
};

const INT c_cchMaxSpid = 20;     // Maximum length of SPID
const INT c_cchMaxOther = 30;    // Maximum length of other fields

#endif // _ISDNSHTS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N P A G E . H
//
//  Contents:   Isdn property page for Net Adapters
//
//  Notes:
//
//  Author:     BillBe   9 Sep 1997
//
//----------------------------------------------------------------------------

#pragma once
#include "isdncfg.h"
#include <ncxbase.h>
#include "ncatlps.h"
#include "resource.h"

class CIsdnPage: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CIsdnPage)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        COMMAND_ID_HANDLER(IDC_CMB_SwitchType, OnSwitchType)
        COMMAND_ID_HANDLER(IDC_PSB_Configure, OnConfigure)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
		MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu)
    END_MSG_MAP()

    CIsdnPage ();
    ~CIsdnPage();

    VOID DestroyPageCallbackHandler()
    {
        delete this;
    }

    HPROPSHEETPAGE
    CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

    // ATL message handlers
    LRESULT
    OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT
    OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT
    OnSwitchType(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);

    LRESULT
    OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    VOID    EnableDisableConfigure ();

private:
    BOOL                m_fDirty;
    HKEY                m_hkeyDriver;
    HDEVINFO            m_hdi;
    PSP_DEVINFO_DATA    m_pdeid;
    PISDN_CONFIG_INFO   m_pisdnci;

    VOID DoSpidsDlg(VOID);
    VOID DoJapanDlg(VOID);
    VOID DoEazDlg(VOID);
    VOID DoMsnDlg(VOID);
};

//
// SPIDS dialog
//

class CSpidsDlg : public CDialogImpl<CSpidsDlg>
{
public:
    BEGIN_MSG_MAP(CSpidsDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_SPIDS};

    CSpidsDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CSpidsDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

//
// EAZ Dialog
//

class CEazDlg : public CDialogImpl<CEazDlg>
{
public:
    BEGIN_MSG_MAP(CEazDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_EAZ};

    CEazDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CEazDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

//
// Multi-subscriber number dialog
//

class CMsnDlg : public CDialogImpl<CMsnDlg>
{
public:
    BEGIN_MSG_MAP(CMsnDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDC_PSB_ADD, OnAdd)
        COMMAND_ID_HANDLER(IDC_PSB_REMOVE, OnRemove)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_MSN};

    CMsnDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
        m_iItemOld = 0;
    }

    ~CMsnDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
    INT                 m_iItemOld;
};

//
// Logical terminal dialog
//

class CJapanDlg : public CDialogImpl<CJapanDlg>
{
public:
    BEGIN_MSG_MAP(CJapanDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        COMMAND_ID_HANDLER(IDOK, OnOk)
        COMMAND_ID_HANDLER(IDCANCEL, OnCancel)
        COMMAND_ID_HANDLER(IDC_LBX_Variant, OnSelChange)
        COMMAND_ID_HANDLER(IDC_LBX_Line, OnSelChange)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
    END_MSG_MAP()

    enum {IDD = IDD_ISDN_JAPAN};

    CJapanDlg(PISDN_CONFIG_INFO pisdnci)
    {
        m_pisdnci = pisdnci;
    }

    ~CJapanDlg() {};

    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                         BOOL& bHandled);
    LRESULT OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
    LRESULT OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

private:
    PISDN_CONFIG_INFO   m_pisdnci;
};

const WCHAR c_szIsdnHelpFile[] = L"devmgr.hlp";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnhook.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N H O O K . C P P
//
//  Contents:   Hook for the ISDN wizard, from the netdi.cpp class installer
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "isdncfg.h"
#include "isdnwiz.h"
#include "ncmisc.h"
#include "ncreg.h"
#include "ncstring.h"

//---[ Constants ]------------------------------------------------------------

extern const WCHAR c_szRegKeyInterfacesFromInstance[];
extern const WCHAR c_szRegValueLowerRange[];


//+--------------------------------------------------------------------------
//
//  Function:   FAdapterIsIsdn
//
//  Purpose:    Checks information under the adapters driver's key to
//                  determine if the adapter is ISDN
//
//  Arguments:
//      hkeyDriver [in] The driver key for the adapter
//
//  Returns:    BOOL. TRUE if the adapter is ISDN, FALSE otherwise
//
//  Author:     billbe   09 Sep 1997
//
//  Notes:
//
BOOL
FAdapterIsIsdn(HKEY hkeyDriver)
{
    Assert(hkeyDriver);

    const WCHAR c_szIsdn[]  = L"isdn";
    HKEY hkey;
    BOOL fIsIsdn = FALSE;

    // Open the Interfaces key under the driver key
    HRESULT hr = HrRegOpenKeyEx(hkeyDriver,
            c_szRegKeyInterfacesFromInstance, KEY_READ, &hkey);

    if (SUCCEEDED(hr))
    {
        PWSTR szRange;
        // Get the lower range of interfaces
        hr = HrRegQuerySzWithAlloc(hkey, c_szRegValueLowerRange, &szRange);

        if (SUCCEEDED(hr))
        {
            // Look for ISDN in the lower range
            fIsIsdn = FFindStringInCommaSeparatedList(c_szIsdn, szRange,
                    NC_IGNORE, NULL);
            MemFree(szRange);
        }
        RegCloseKey(hkey);
    }

    return fIsIsdn;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrAddIsdnWizardPagesIfAppropriate
//
//  Purpose:    Adds the ISDN wizard pages to the hardware wizard if the
//              bindings dictate such. We look to see if they have a lower
//              binding of "isdn", and if so, then add the pages.
//
//  Arguments:
//      hdi   [in] See Device Installer Api for more info
//      pdeid [in]
//
//  Returns:    S_OK if successful or valid Win32 error
//
//  Author:     jeffspr   17 Jun 1997
//
//  Notes:
//
HRESULT HrAddIsdnWizardPagesIfAppropriate(HDEVINFO hdi,
                                          PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Open the adapter's driver key
    //
    HKEY    hkeyInstance = NULL;
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid, DICS_FLAG_GLOBAL, 0,
            DIREG_DRV, KEY_READ, &hkeyInstance);


    // Don't do anything if its not an ISDN adapter.
    if (SUCCEEDED(hr) && FShowIsdnPages(hkeyInstance))
    {
        // Read the ISDN registry structure into the config info
        //
        PISDN_CONFIG_INFO pisdnci;
        hr = HrReadIsdnPropertiesInfo(hkeyInstance, hdi, pdeid, &pisdnci);
        if (SUCCEEDED(hr))
        {
            Assert(pisdnci);

            if (pisdnci->dwCurSwitchType == ISDN_SWITCH_NONE)
            {
                // Add the wizard pages to the device's class install params.
                //
                hr = HrAddIsdnWizardPagesToDevice(hdi, pdeid, pisdnci);
            }
            else
            {
                TraceTag(ttidISDNCfg, "Not adding wizard pages because we "
                         "found a previous switch type for this device.");
            }
        }
    }

    RegSafeCloseKey(hkeyInstance);

    TraceError("HrAddIsdnWizardPagesIfAppropriate", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnshts.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N S H T S . C P P
//
//  Contents:   Dialog procs for the ISDN Property sheets and wizard pages
//
//  Notes:
//
//  Author:     danielwe    9 Mar 1998
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncui.h>
#include "ncreg.h"
#include "isdncfg.h"
#include "isdnshts.h"
#include "resource.h"
#include "ncmisc.h"

#ifndef IDD_NetDevSelect
#define IDD_NetDevSelect               21013
#endif


//---[ Constants ]------------------------------------------------------------

const DWORD c_iMaxChannelName  =   3;      // For the channel listbox

struct SWITCH_TYPE_MASK_INFO
{
    DWORD   dwMask;
    UINT    idsSwitchType;
};

//
// Switch type masks.
//
// Maps the switch type to a description string.
//
static const SWITCH_TYPE_MASK_INFO c_astmi[] =
{
    {ISDN_SWITCH_AUTO,  IDS_ISDN_SWITCH_AUTO},
    {ISDN_SWITCH_ATT,   IDS_ISDN_SWITCH_ATT},
    {ISDN_SWITCH_NI1,   IDS_ISDN_SWITCH_NI1},
    {ISDN_SWITCH_NI2,   IDS_ISDN_SWITCH_NI2},
    {ISDN_SWITCH_NTI,   IDS_ISDN_SWITCH_NTI},
    {ISDN_SWITCH_INS64, IDS_ISDN_SWITCH_INS64},
    {ISDN_SWITCH_1TR6,  IDS_ISDN_SWITCH_1TR6},
    {ISDN_SWITCH_VN3,   IDS_ISDN_SWITCH_VN3},
//    {ISDN_SWITCH_NET3,  IDS_ISDN_SWITCH_DSS1},
    {ISDN_SWITCH_DSS1,  IDS_ISDN_SWITCH_DSS1},
    {ISDN_SWITCH_AUS,   IDS_ISDN_SWITCH_AUS},
    {ISDN_SWITCH_BEL,   IDS_ISDN_SWITCH_BEL},
    {ISDN_SWITCH_VN4,   IDS_ISDN_SWITCH_VN4},
    {ISDN_SWITCH_SWE,   IDS_ISDN_SWITCH_SWE},
    {ISDN_SWITCH_TWN,   IDS_ISDN_SWITCH_TWN},
    {ISDN_SWITCH_ITA,   IDS_ISDN_SWITCH_ITA},
};

static const INT c_cstmi = celems(c_astmi);

static const WCHAR c_szIsdnShowPages[] = L"ShowIsdnPages";

//+---------------------------------------------------------------------------
//
//  Function:   FShowIsdnPages
//
//  Purpose:    Determines whether the ISDN wizard property page or wizard
//              pages should be shown.
//
//  Arguments:
//      hkey [in]   Driver instance key for ISDN device
//
//  Returns:    If the ShowIsdnPages value is:
//
//              not present:            TRUE, if adapter has ISDN in lower
//                                            range
//              present and zero:       FALSE
//              present and non-zero:   TRUE, unconditionally
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
BOOL FShowIsdnPages(HKEY hkey)
{
    DWORD   dwValue;

    if (SUCCEEDED(HrRegQueryDword(hkey, c_szIsdnShowPages, &dwValue)))
    {
        if (!dwValue)
        {
            return FALSE;
        }
        else
        {
            return TRUE;
        }
    }
    else
    {
        return FAdapterIsIsdn(hkey);
    }
}

//
// Switch Type page functions
//

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeInit
//
//  Purpose:    Called when the switch type page is initialized
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnSwitchTypeInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Populate the switch types from the multi-sz that we read
    //
    PopulateIsdnSwitchTypes(hwndDlg, IDC_CMB_SwitchType, pisdnci);

    pisdnci->nOldDChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                                   LB_GETCURSEL, 0, 0);
    pisdnci->nOldBChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                                   LB_GETCURSEL, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckShowPagesFlag
//
//  Purpose:    Checks a special registry flag to see if a vendor wishes to
//              suppress the ISDN wizard from appearing upon installation of
//              their device.
//
//  Arguments:
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   15 Dec 1998
//
//  Notes:
//
VOID CheckShowPagesFlag(PISDN_CONFIG_INFO pisdnci)
{
    // Open the adapter's driver key
    //
    HKEY    hkeyInstance = NULL;
    HRESULT hr = S_OK;

    hr = HrSetupDiOpenDevRegKey(pisdnci->hdi, pisdnci->pdeid,
                                DICS_FLAG_GLOBAL, 0, DIREG_DRV,
                                KEY_READ, &hkeyInstance);
    if (SUCCEEDED(hr))
    {
        if (!FShowIsdnPages(hkeyInstance))
        {
            TraceTag(ttidISDNCfg, "Skipping all ISDN wizard pages because"
                     "the %S value was present and zero", c_szIsdnShowPages);

            pisdnci->fSkipToEnd = TRUE;
        }
        else
        {
            TraceTag(ttidISDNCfg, "Showing all ISDN wizard pages...");
        }

        RegCloseKey(hkeyInstance);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeSetActive
//
//  Purpose:    Called when the switch type page is made active.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    DWL_MSGRESULT
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
LONG OnIsdnSwitchTypeSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // For bug #265745: Some vendors will want to suppress the ISDN wizard
    // in the case where their card is multifunction. The coinstaller for that
    // device will ask the user if they want the card configured for ISDN and
    // if they say 'no' then we shouldn't show the ISDN wizard. The following
    // function checks the registry to see if the user essentially chose 'no'.
    CheckShowPagesFlag(pisdnci);

    if (pisdnci->fSkipToEnd)
    {
        return -1;
    }
    else
    {
        // Set the button states.
        //
        SetWizardButtons(GetParent(hwndDlg),TRUE, pisdnci);
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetWizardButtons
//
//  Purpose:    Sets the next, back and cancel buttons depending what property 
//              page we are in and if we are in GUI mode setup or stand-alone mode.
//
//  Arguments:
//      hwndDlg    [in]    Handle to property page
//      bFirstPage [in]    Indicates if the property page is the first page.
//                         If it is the first page and we are in stand-alone 
//                         the back button is disabled
//
//  Returns:    void
//
//  Author:     omiller   15 May 2000
//
//  Notes:      Next and Back are enabled in GUI setup mode. The cancel button
//              is not displayed in GUI setup mode.
//              In stand-alone mode the next button and cancel button are enabled.
//
VOID SetWizardButtons(HWND hwndDlg, BOOLEAN bFirstPage, PISDN_CONFIG_INFO pisdnci)
{
    // Determine if we are in GUI mode setup or running stand-alone
    //
    if( FInSystemSetup() )
    {
        // We are GUI Setup mode. There is a property page before us and after us. 
        // Therefore we have to enable the next and/or back buttons. There is no 
        // cancel button for this property page in GUI setup mode.
        //

        DWORD  dwFlags = PSWIZB_BACK | PSWIZB_NEXT;
        int    iIndex;
        HWND   hwndFirstPage;

        if ( pisdnci )
        {
            iIndex = PropSheet_IdToIndex( hwndDlg, IDD_NetDevSelect );

            if ( iIndex != -1 )
            {
                hwndFirstPage = PropSheet_IndexToHwnd( hwndDlg, iIndex );

                if ( hwndFirstPage )
                {
                    if (SendMessage(hwndFirstPage, WM_SELECTED_ALL, (WPARAM)0,
                                     (LPARAM)pisdnci->pdeid->DevInst) )
                    {
                        dwFlags = PSWIZB_NEXT;
                    }
                }
            }
        }

        PropSheet_SetWizButtons(hwndDlg, dwFlags);
    }
    else
    {
        // We are running in stand-alone mode. This means that we are the first property 
        // sheet. Therefore the back button should be disabled, the next button enabled.
        // and the cancel button should be enabled. The cancel button does not appear in 
        // GUI setup mode.
        //
        HWND hCancel;
        

        // Get the handle to the cancel button and enable the button.
        //
        hCancel=GetDlgItem(hwndDlg,IDCANCEL);
        EnableWindow(hCancel,TRUE);

        if( bFirstPage )
        {
            // Enable the next button.
            PropSheet_SetWizButtons(hwndDlg,PSWIZB_NEXT);
        }
        else
        {
            // Enable the next button.
           PropSheet_SetWizButtons(hwndDlg,PSWIZB_BACK | PSWIZB_NEXT);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   DwGetSwitchType
//
//  Purpose:    Takes the selected switch type in the dropdown list and
//              returns the actual value that will be stored in the registry.
//
//  Arguments:
//      hwndDlg     [in]    HWND of dialog
//      pisdnci     [in]    Configuration information as read from the
//                          registry
//      iDialogItem [in]    Item ID of switch type dropdown list
//
//  Returns:
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
DWORD DwGetSwitchType(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci,
                      INT iDialogItem)
{
    INT     iCurSel;
    INT     iSwitchType;

    iCurSel = (INT)SendDlgItemMessage(hwndDlg, iDialogItem, CB_GETCURSEL, 0, 0);

    // Switch type index should be the item data for the selected switch
    // type
    iSwitchType = (INT)SendDlgItemMessage(hwndDlg, iDialogItem, CB_GETITEMDATA,
                                          iCurSel, 0);

    AssertSz(iSwitchType >= 0 && iSwitchType < c_cstmi, "Switch type item data"
             " is bad!");

    return c_astmi[iSwitchType].dwMask;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnSwitchTypeWizNext
//
//  Purpose:    Called when the switch type page is advanced in the forward
//              direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnSwitchTypeWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     idd = 0;

    pisdnci->dwCurSwitchType = DwGetSwitchType(hwndDlg, pisdnci,
                                               IDC_CMB_SwitchType);

    switch (pisdnci->dwCurSwitchType)
    {
    case ISDN_SWITCH_ATT:
    case ISDN_SWITCH_NI1:
    case ISDN_SWITCH_NI2:
    case ISDN_SWITCH_NTI:
        if (pisdnci->fIsPri)
        {
            // PRI adapters use the EAZ page instead
            idd = IDW_ISDN_EAZ;
            pisdnci->fSkipToEnd = TRUE;
        }
        else
        {
            idd = IDW_ISDN_SPIDS;
        }
        break;

    case ISDN_SWITCH_INS64:
        idd = IDW_ISDN_JAPAN;
        break;

    case ISDN_SWITCH_AUTO:
        if (pisdnci->fIsPri)
        {
            pisdnci->fSkipToEnd = TRUE;
        }

    case ISDN_SWITCH_1TR6:
        idd = IDW_ISDN_EAZ;
        break;

    case ISDN_SWITCH_VN3:
    case ISDN_SWITCH_VN4:
    case ISDN_SWITCH_DSS1:
    case ISDN_SWITCH_AUS:
    case ISDN_SWITCH_BEL:
    case ISDN_SWITCH_SWE:
    case ISDN_SWITCH_TWN:
    case ISDN_SWITCH_ITA:
        idd = IDW_ISDN_MSN;
        break;

    default:
        AssertSz(FALSE, "Where do we go from here.. now that all of our "
                 "children are growin' up?");
        break;
    }

    // Save away the dialog we used so we can make decisions later on about
    // what to call things, etc...
    //
    pisdnci->idd = idd;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsdnSwitchTypeProc
//
//  Purpose:    Dialog proc handler for switch type page.
//
//  Arguments:
//      hwndDlg  []
//      uMessage []
//      wparam   []
//      lparam   []
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
INT_PTR
CALLBACK
IsdnSwitchTypeProc(HWND hwndDlg, UINT uMessage,
                                 WPARAM wparam, LPARAM lparam)
{
    LPNMHDR             lpnmhdr    = NULL;
    PISDN_CONFIG_INFO   pisdnci;
    PROPSHEETPAGE *     ppsp;

    pisdnci = (PISDN_CONFIG_INFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMessage)
    {
        case WM_INITDIALOG:
            PAGE_DATA * pPageData;

            ppsp = (PROPSHEETPAGE *) lparam;

            // Set the per-page data for this particular page. See the
            // comments above about why we use the per-page data.
            //
            AssertSz(!pisdnci, "This should not have been set yet");

            pPageData = (PAGE_DATA *)ppsp->lParam;
            pisdnci = pPageData->pisdnci;

            // Set this data in the window long for user-data
            //
            SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pisdnci);

            // Call the init handler function
            //
            OnIsdnSwitchTypeInit(hwndDlg, pisdnci);
            break;

        case WM_NOTIFY:
            lpnmhdr = (NMHDR FAR *)lparam;
            // Handle all of the notification messages
            //
            switch (lpnmhdr->code)
            {
                case PSN_SETACTIVE:
                {
                    LONG l = OnIsdnSwitchTypeSetActive(hwndDlg, pisdnci);
                    SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, l);
                    return TRUE;
                }
                case PSN_APPLY:
                    break;
                case PSN_WIZBACK:
                    break;
                case PSN_WIZNEXT:
                    OnIsdnSwitchTypeWizNext(hwndDlg, pisdnci);
                    break;
                case PSN_WIZFINISH:
                    AssertSz(FALSE, "You can't finish from this page!");
                    break;
                default:
                    break;
            }

            break;

        default:
            break;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   PopulateIsdnSwitchTypes
//
//  Purpose:    Fills in the drop-down list for the switch type page
//
//  Arguments:
//      hwndDlg     [in]    Handle to page
//      iDialogItem [in]    Item ID of drop-down list
//      pisdnci     [in]    Configuration information as read from the
//                          registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID PopulateIsdnSwitchTypes(HWND hwndDlg, INT iDialogItem,
                             PISDN_CONFIG_INFO pisdnci)
{
    INT     iCurrentIndex   = 0;
    INT     iSetItemData    = 0;
    DWORD   dwSwitchType    = 0;
    DWORD   nCountry;
    INT     istmi;

    Assert(hwndDlg);
    Assert(pisdnci);
    Assert(pisdnci->dwSwitchTypes);

    nCountry = DwGetCurrentCountryCode();

    // Loop through the list of switch types and add them to the combo box
    //
    for (istmi = 0; istmi < c_cstmi; istmi++)
    {
        if (pisdnci->dwSwitchTypes & c_astmi[istmi].dwMask)
        {
            // Add the string
            //
            iCurrentIndex = (INT)SendDlgItemMessage(hwndDlg, iDialogItem,
                       CB_ADDSTRING,
                       0, (LPARAM) SzLoadIds(c_astmi[istmi].idsSwitchType));

            Assert(iCurrentIndex != CB_ERR);

            // Set the item data, so we know the index into the switch type
            // array that we're dealing with.
            //
            iSetItemData = (INT)SendDlgItemMessage(hwndDlg, iDialogItem,
                                              CB_SETITEMDATA, iCurrentIndex,
                                              istmi);

            if (FIsDefaultForLocale(nCountry, c_astmi[istmi].dwMask))
            {
                // Save index to find default item to select later
                dwSwitchType = c_astmi[istmi].dwMask;
            }
            else if (!dwSwitchType)
            {
                // If no default has been set, set one now.
                dwSwitchType = c_astmi[istmi].dwMask;
            }

            Assert(iSetItemData != CB_ERR);
        }
    }

        SetSwitchType(hwndDlg, IDC_CMB_SwitchType, dwSwitchType);
}

//+---------------------------------------------------------------------------
//
//  Function:   SetSwitchType
//
//  Purpose:    Given a switch type mask, selects the item in the combo box
//              that corresponds to that switch type.
//
//  Arguments:
//      hwndDlg         [in]    Dialog handle.
//      iItemSwitchType [in]    Item ID of switch type combo box.
//      dwSwitchType    [in]    Switch type mask to select.
//
//  Returns:    Nothin'
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetSwitchType(HWND hwndDlg, INT iItemSwitchType, DWORD dwSwitchType)
{
    INT     iItem;
    INT     cItems;

    cItems = (INT)SendDlgItemMessage(hwndDlg, iItemSwitchType, CB_GETCOUNT, 0, 0);
    for (iItem = 0; iItem < cItems; iItem++)
    {
        INT     istmiCur;

        istmiCur = (INT)SendDlgItemMessage(hwndDlg, iItemSwitchType,
                                      CB_GETITEMDATA, iItem, 0);
        if (c_astmi[istmiCur].dwMask == dwSwitchType)
        {
            // Select switch type
            //
            SendDlgItemMessage(hwndDlg, iItemSwitchType, CB_SETCURSEL,
                               iItem, 0);
            break;
        }
    }
}

//
// Info page functions
//

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageInit
//
//  Purpose:    Called when the info (second) page of the wizard is
//              initialized.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageInit(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, pisdnci);

    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageSetActive
//
//  Purpose:    Called when the second page of the wizard is activated
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
LONG OnIsdnInfoPageSetActive(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    if (pisdnci->idd == (UINT)GetWindowLongPtr(hwndDlg, DWLP_USER) &&
        !pisdnci->fSkipToEnd)
    {
        // Set the button states.
        //
        SetWizardButtons(GetParent(hwndDlg),FALSE, NULL);

        SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));

        // Note the current selections
        //
        pisdnci->nOldBChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                                   LB_GETCURSEL, 0, 0);
        pisdnci->nOldDChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                                   LB_GETCURSEL, 0, 0);
    }
    else
    {
        return -1;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageApply
//
//  Purpose:    Called when the info (second) page is applied
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageApply(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    // Open the adapter's driver key and store the info
    //
    HRESULT hr;
    HKEY    hkey;

    hr = HrSetupDiOpenDevRegKey(pisdnci->hdi, pisdnci->pdeid, DICS_FLAG_GLOBAL,
                                0, DIREG_DRV, KEY_ALL_ACCESS, &hkey);
    if (SUCCEEDED(hr))
    {
        // Write the parameters back out into the registry.
        //
        hr = HrWriteIsdnPropertiesInfo(hkey, pisdnci);
        if (SUCCEEDED(hr))
        {
            hr = HrSetupDiSendPropertyChangeNotification(pisdnci->hdi,
                                                         pisdnci->pdeid,
                                                         DICS_PROPCHANGE,
                                                         DICS_FLAG_GLOBAL,
                                                         0);
        }

        RegCloseKey(hkey);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageWizNext
//
//  Purpose:    Called when the info (second) page is advanced in the
//              forward direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageWizNext(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    if (pisdnci->idd == (UINT)GetWindowLongPtr(hwndDlg, DWLP_USER))
    {
        OnIsdnInfoPageTransition(hwndDlg, pisdnci);
        OnIsdnInfoPageApply(hwndDlg, pisdnci);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageTransition
//
//  Purpose:    Called when the info (second) page is advanced in either the
//              forward or backward directions.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   5 May 1998
//
//  Notes:
//
VOID OnIsdnInfoPageTransition(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    Assert(hwndDlg);

    if (pisdnci->idd == IDW_ISDN_MSN)
    {
        INT     iCurSel;

        iCurSel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Line, LB_GETCURSEL, 0, 0);
        if (iCurSel != LB_ERR)
        {
            GetDataFromListBox(iCurSel, hwndDlg, pisdnci);
        }
    }
    else
    {
        DWORD   dwDChannel;
        DWORD   dwBChannel;

        Assert(pisdnci);
        Assert(pisdnci->pDChannel);

        dwDChannel = (DWORD)SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                               LB_GETCURSEL, 0, 0);

        Assert(pisdnci->dwNumDChannels >= dwDChannel);

        dwBChannel = (DWORD)SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                               LB_GETCURSEL, 0, 0);

        // Update the channel info for the currently selected channel from
        // the SPID/Phone Number edit controls
        //
        SetModifiedIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                   IDC_LBX_Variant, dwBChannel, pisdnci);

        // Retrieve all of the ISDN B-Channel info from the listbox item-data,
        // and update the config info.
        //
        RetrieveIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                IDC_LBX_Variant, pisdnci, dwDChannel,
                                dwBChannel);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageWizBack
//
//  Purpose:    Called when the info (second) page is advanced in the reverse
//              direction.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageWizBack(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    OnIsdnInfoPageTransition(hwndDlg, pisdnci);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnIsdnInfoPageSelChange
//
//  Purpose:    Called when the selection changes in either the D-channel or
//              B-channel listboxes.
//
//  Arguments:
//      hwndDlg [in]    Handle to dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID OnIsdnInfoPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     nDChannel;
    INT     nBChannel;

    Assert(hwndDlg);
    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    nDChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Line,
                                        LB_GETCURSEL, 0, 0);
    Assert(LB_ERR != nDChannel);

    Assert(pisdnci->dwNumDChannels >= (DWORD)nDChannel);

    nBChannel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Variant,
                                        LB_GETCURSEL, 0, 0);
    Assert(LB_ERR != nBChannel);

    if ((LB_ERR != nDChannel) &&
        (LB_ERR != nBChannel) &&
        ((nBChannel != pisdnci->nOldBChannel) ||
         (nDChannel != pisdnci->nOldDChannel)))
    {
        PISDN_D_CHANNEL pisdndc;

        // Get the channel info for the selection that's going away, and update
        // it's listbox item data.
        //
        SetModifiedIsdnChannelInfo(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                                   IDC_LBX_Variant, pisdnci->nOldBChannel,
                                   pisdnci);

        pisdndc = &(pisdnci->pDChannel[nDChannel]);

        Assert(pisdndc);

        // Update item data to reflect new line (d channel)
        //
        for (DWORD dwChannel = 0;
             dwChannel < pisdndc->dwNumBChannels;
             dwChannel++)
        {
            SendDlgItemMessage(hwndDlg, IDC_LBX_Variant, LB_SETITEMDATA,
                               dwChannel,
                               (LPARAM) (&pisdndc->pBChannel[dwChannel]));
        }

        // Update the edit controls for the newly selected listbox item (channel)
        //
        SetCurrentIsdnChannelSelection(hwndDlg, IDC_EDT_SPID,
                                       IDC_EDT_PhoneNumber, IDC_LBX_Variant,
                                       pisdnci, nDChannel, &nBChannel);

        pisdnci->nOldBChannel = nBChannel;
        pisdnci->nOldDChannel = nDChannel;

        SetFocus(GetDlgItem(hwndDlg, IDC_EDT_PhoneNumber));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataFromListBox
//
//  Purpose:    On the MSN page, this takes the contents of the listbox and
//              saves it in memory.
//
//  Arguments:
//      iItem   [in]    Selected item in channel listbox
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID GetDataFromListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT             cItems;
    INT             iItemCur;
    PISDN_D_CHANNEL pisdndc;
    INT             cchText = 0;

    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    pisdndc = &(pisdnci->pDChannel[iItem]);

    Assert(pisdndc);

    cItems = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCOUNT, 0, 0);

    // First calculate length of multi-sz
    //
    for (iItemCur = 0; iItemCur < cItems; iItemCur++)
    {
        cchText += (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETTEXTLEN,
                                           iItemCur, 0) + 1;
    }

    // Include final Null
    cchText++;

    // Free the old one
    delete [] pisdndc->mszMsnNumbers;
    pisdndc->mszMsnNumbers = new WCHAR[cchText];

	if (pisdndc->mszMsnNumbers == NULL)
	{
		return;
	}

    WCHAR *     pchMsn = pisdndc->mszMsnNumbers;

    for (iItemCur = 0; iItemCur < cItems; iItemCur++)
    {
        AssertSz(pchMsn - pisdndc->mszMsnNumbers < cchText, "Bad buffer for "
                 "MSN string!");
        SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETTEXT, iItemCur,
                           (LPARAM)pchMsn);
        pchMsn += lstrlenW(pchMsn) + 1;
    }

    *pchMsn = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDataToListBox
//
//  Purpose:    Sets the contents of the MSN listbox based on the passed in
//              selected item from the channel listbox.
//
//  Arguments:
//      iItem   [in]    Selected item in channel listbox
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID SetDataToListBox(INT iItem, HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    PISDN_D_CHANNEL pisdndc;

    Assert(pisdnci);
    Assert(pisdnci->pDChannel);

    pisdndc = &(pisdnci->pDChannel[iItem]);

    Assert(pisdndc);

    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_RESETCONTENT, 0, 0);

    WCHAR *     szMsn = pisdndc->mszMsnNumbers;

    while (*szMsn)
    {
        SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_ADDSTRING, 0,
                           (LPARAM)szMsn);
        szMsn += lstrlenW(szMsn) + 1;
    }

    // Select first item
    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageInitDialog
//
//  Purpose:    Called on initialization of the MSN dialog
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageInitDialog(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     cItems;

    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(hwndDlg, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, pisdnci);

    SetDataToListBox(0, hwndDlg, pisdnci);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), FALSE);
    SendDlgItemMessage(hwndDlg, IDC_EDT_MSN, EM_LIMITTEXT,
                       RAS_MaxPhoneNumber, 0);
    cItems = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCOUNT , 0, 0);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), !!cItems);

    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
    SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN), GWLP_USERDATA, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageSelChange
//
//  Purpose:    Called when the listbox selection changes
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT iItemNew;
    INT iItemOld = (INT)GetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN),
                                         GWLP_USERDATA);

    iItemNew = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_Line, LB_GETCURSEL, 0, 0);

    if ((iItemNew != LB_ERR) && (iItemNew != iItemOld))
    {
        GetDataFromListBox(iItemOld, hwndDlg, pisdnci);
        SetDataToListBox(iItemNew, hwndDlg, pisdnci);
        SetWindowLongPtr(GetDlgItem(hwndDlg, IDC_EDT_MSN), GWLP_USERDATA,
                         iItemNew);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageAdd
//
//  Purpose:    Called when the Add button is pressed
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageAdd(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    WCHAR   szItem[RAS_MaxPhoneNumber + 1];
    INT     iItem;

    GetDlgItemText(hwndDlg, IDC_EDT_MSN, szItem, celems(szItem));
    iItem = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_ADDSTRING, 0,
                                    (LPARAM)szItem);
    // Select the item after adding it
    SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, iItem, 0);
    EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), TRUE);
    SetDlgItemText(hwndDlg, IDC_EDT_MSN, c_szEmpty);
    SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageRemove
//
//  Purpose:    Called when the remove button is pressed
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageRemove(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    INT     iSel;

    iSel = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_GETCURSEL, 0, 0);
    if (iSel != LB_ERR)
    {
        INT     cItems;

        cItems = (INT)SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_DELETESTRING,
                                         iSel, 0);
        if (cItems)
        {
            if (iSel == cItems)
            {
                iSel--;
            }

            SendDlgItemMessage(hwndDlg, IDC_LBX_MSN, LB_SETCURSEL, iSel, 0);
        }
        else
        {
            ::EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_REMOVE), FALSE);
            ::SetFocus(GetDlgItem(hwndDlg, IDC_EDT_MSN));
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   OnMsnPageEditSelChange
//
//  Purpose:    Called when the edit control contents change
//
//  Arguments:
//      hwndDlg [in]    HWND of dialog
//      pisdnci [in]    Configuration information as read from the
//                      registry
//
//  Returns:    Nothing
//
//  Author:     danielwe   23 Apr 1998
//
//  Notes:
//
VOID OnMsnPageEditSelChange(HWND hwndDlg, PISDN_CONFIG_INFO pisdnci)
{
    LRESULT     lres;

    // Make the old default button normal again
    lres = SendMessage(hwndDlg, DM_GETDEFID, 0, 0);
    if (HIWORD(lres) == DC_HASDEFID)
    {
        SendDlgItemMessage(hwndDlg, LOWORD(lres), BM_SETSTYLE,
                           BS_PUSHBUTTON, TRUE);
    }

    // Disable Add button based on whether text is present in the edit control
    //
    if (GetWindowTextLength(GetDlgItem(hwndDlg, IDC_EDT_MSN)))
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), TRUE);

        // Make this the default button as well
        SendMessage(hwndDlg, DM_SETDEFID, IDC_PSB_ADD, 0);
        SendDlgItemMessage(hwndDlg, IDC_PSB_ADD, BM_SETSTYLE,
                           BS_DEFPUSHBUTTON, TRUE);
    }
    else
    {
        EnableWindow(GetDlgItem(hwndDlg, IDC_PSB_ADD), FALSE);

        // Make the OK button the default
        SendMessage(hwndDlg, DM_SETDEFID, IDOK, 0);
        SendDlgItemMessage(hwndDlg, IDOK, BM_SETSTYLE,
                           BS_DEFPUSHBUTTON, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsdnInfoPageProc
//
//  Purpose:    Dialog proc handler for info (second) page.
//
//  Arguments:
//      hwndDlg  [in]
//      uMessage [in]
//      wparam   [in]
//      lparam   [in]
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
INT_PTR CALLBACK
IsdnInfoPageProc(HWND hwndDlg, UINT uMessage, WPARAM wparam, LPARAM lparam)
{
    LPNMHDR             lpnmhdr    = NULL;
    PISDN_CONFIG_INFO   pisdnci;
    PROPSHEETPAGE *     ppsp;

    // We have to do this in this fashion because it's very likely that we'll
    // have multiple instances of this dlg proc active at one time. This means
    // that we can't use the single pipipd as a static, as it would get
    // overwritten everytime we hit the WM_INITDIALOG on a new instance.
    //
    pisdnci = (PISDN_CONFIG_INFO)GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        PAGE_DATA * pPageData;

        ppsp = (PROPSHEETPAGE *) lparam;

        // Set the per-page data for this particular page. See the
        // comments above about why we use the per-page data.
        //
        AssertSz(!pisdnci, "This should not have been set yet");

        pPageData = (PAGE_DATA *)ppsp->lParam;
        pisdnci = pPageData->pisdnci;

        // Set this data in the window long for user-data
        //
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, (LONG_PTR) pisdnci);
        SetWindowLongPtr(hwndDlg, DWLP_USER, (LONG_PTR) pPageData->idd);

        Assert(pisdnci);

        // Call the init handler function
        //
        if (pisdnci->idd == IDW_ISDN_MSN)
        {
            OnMsnPageInitDialog(hwndDlg, pisdnci);
        }
        else
        {
            OnIsdnInfoPageInit(hwndDlg, pisdnci);
        }

        // Limit text in the edit controls
        switch (pisdnci->idd)
        {
        case IDW_ISDN_SPIDS:
            SendDlgItemMessage(hwndDlg, IDC_EDT_SPID, EM_LIMITTEXT,
                               c_cchMaxSpid, 0);
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_MSN:
            SendDlgItemMessage(hwndDlg, IDC_EDT_MSN, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_JAPAN:
            SendDlgItemMessage(hwndDlg, IDC_EDT_SPID, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;

        case IDW_ISDN_EAZ:
            SendDlgItemMessage(hwndDlg, IDC_EDT_PhoneNumber, EM_LIMITTEXT,
                               c_cchMaxOther, 0);
            break;
        }

        break;

    case WM_NOTIFY:
        lpnmhdr = (NMHDR FAR *)lparam;
        // Handle all of the notification messages
        //
        switch (lpnmhdr->code)
        {
        case PSN_SETACTIVE:
            {
                LONG l = OnIsdnInfoPageSetActive(hwndDlg, pisdnci);
                SetWindowLongPtr(hwndDlg, DWLP_MSGRESULT, l);
                return TRUE;
            }
        case PSN_APPLY:
            OnIsdnInfoPageApply(hwndDlg, pisdnci);
            break;
        case PSN_WIZBACK:
            OnIsdnInfoPageWizBack(hwndDlg, pisdnci);
            break;
        case PSN_WIZNEXT:
            OnIsdnInfoPageWizNext(hwndDlg, pisdnci);
            break;
        default:
            break;
        }

        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDC_PSB_ADD:
            OnMsnPageAdd(hwndDlg, pisdnci);
            break;

        case IDC_PSB_REMOVE:
            OnMsnPageRemove(hwndDlg, pisdnci);
            break;

        case IDC_EDT_MSN:
            if (HIWORD(wparam) == EN_CHANGE)
            {
                OnMsnPageEditSelChange(hwndDlg, pisdnci);
            }
            break;

        case IDC_LBX_Variant:
        case IDC_LBX_Line:
            if (HIWORD(wparam) == LBN_SELCHANGE)
            {
                if (pisdnci->idd == IDW_ISDN_MSN)
                {
                    OnMsnPageSelChange(hwndDlg, pisdnci);
                }
                else
                {
                    OnIsdnInfoPageSelChange(hwndDlg, pisdnci);
                }
            }

            break;
        }
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Function:   RetrieveIsdnChannelInfo
//
//  Purpose:    Stores the state of the edit controls into the in-memory
//              state for the currently selected D-channel and B-channel.
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      pisdnci         [in]    Configuration information as read from the
//                              registry
//      dwDChannel      [in]    Currently selected D-channel in listbox
//      iCurrentChannel [in]    Currently selected B-channel in listbox
//
//  Returns:
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID RetrieveIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                             INT iPhoneControl, INT iChannelLB,
                             PISDN_CONFIG_INFO pisdnci, DWORD dwDChannel,
                             INT iCurrentChannel)
{
    DWORD   dwItemCount     = 0;
    DWORD   dwItemLoop      = 0;
    INT     iCharsReturned  = 0;

    WCHAR   szBChannelName[c_iMaxChannelName+1];

    Assert(hwndDlg);
    Assert(iSpidControl);
    Assert(iPhoneControl);
    Assert(iChannelLB);
    Assert(pisdnci);
    Assert(pisdnci->pDChannel);
    Assert(pisdnci->dwNumDChannels >= dwDChannel);

    // Make sure that the current selection has been propogated back to the
    // channel data
    //
    SetModifiedIsdnChannelInfo(hwndDlg, iSpidControl, iPhoneControl,
            iChannelLB, iCurrentChannel, pisdnci);

    // Get the item from from the listbox
    //
    dwItemCount = (DWORD)SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETCOUNT, 0, 0L);
    if (dwItemCount != pisdnci->pDChannel[dwDChannel].dwNumBChannels)
    {
        AssertSz(FALSE, "Count of items in LB != number of B Channels");
        goto Exit;
    }

    // Loop through the items and get the channel names. Convert those to channel
    // numbers, and propogate the data back to the appropriate B Channel in the
    // config info.
    //
    for (dwItemLoop = 0; dwItemLoop < dwItemCount; dwItemLoop++)
    {
        DWORD           dwChannelNumber = 0;
        PISDN_B_CHANNEL pisdnbc         = NULL;
        INT_PTR         iItemData       = 0;

        // Get the length of the channel name.
        //
        iCharsReturned = (INT)SendDlgItemMessage(hwndDlg, iChannelLB,
                                                 LB_GETTEXTLEN, dwItemLoop, 0L);

        AssertSz(iCharsReturned != LB_ERR,
                 "No reason that we should have gotten a failure for LB_GETTEXTLEN "
                 "on the Channel LB");

        if (iCharsReturned > c_iMaxChannelName)
        {
            AssertSz(iCharsReturned <= c_iMaxChannelName, "Channel name too long for buffer");
            goto Exit;
        }

        // Get the channel name.
        //
        iCharsReturned = (INT)SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETTEXT,
                                                 dwItemLoop, (LPARAM) szBChannelName);
        AssertSz(iCharsReturned != LB_ERR,
                 "Failed on LB_GETTEXT on the Channel LB. Strange");

        // Convert to a channel num from display # (using radix 10), then subtract 1 (base 0)
        //
        dwChannelNumber = wcstoul(szBChannelName, NULL, 10) - 1;
        if (dwChannelNumber >= pisdnci->pDChannel[dwDChannel].dwNumBChannels)
        {
            AssertSz(FALSE, "dwChannelNumber out of the range of valid B Channels");
            goto Exit;
        }

        // Get the item data for that particular channel. This will be the stored SPID and
        // phone numbers (a PISDN_B_CHANNEL).
        //
        iItemData = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETITEMDATA,
                                       dwItemLoop, (LPARAM)0);
        AssertSz(iItemData != (INT_PTR)LB_ERR, "LB_ERR returned from LB_GETITEMDATA on Channel LB. Bogus.");

        // It's valid data, so cast it to the struct form.
        //
        pisdnbc = reinterpret_cast<PISDN_B_CHANNEL>(iItemData);

        // Copy the phone number and spid data between the saved list box data and the
        // full config info
        //
        lstrcpyW(pisdnci->pDChannel[dwDChannel].pBChannel[dwChannelNumber].szSpid,
                pisdnbc->szSpid);
        lstrcpyW(pisdnci->pDChannel[dwDChannel].pBChannel[dwChannelNumber].szPhoneNumber,
                pisdnbc->szPhoneNumber);
    }

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetCurrentIsdnChannelSelection
//
//  Purpose:    Retrives the information from the in-memory representation of
//              the current D-channel and B-channel information and sets
//              the edit controls with this information.
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      pisdnci         [in]    Configuration information as read from the
//                              registry
//      dwDChannel      [in]    Currently selected D-channel in listbox
//      pnBChannel      [out]   Returns currently selected B-channel in list
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetCurrentIsdnChannelSelection(HWND hwndDlg, INT iSpidControl,
                                    INT iPhoneControl, INT iChannelLB,
                                    PISDN_CONFIG_INFO pisdnci,
                                    DWORD dwDChannel, INT *pnBChannel)
{
    INT             iIndex      = 0;
    INT_PTR         iItemData   = 0;
    PISDN_B_CHANNEL pisdnbc     = NULL;

    // Get the current selection
    //
    iIndex = (INT)SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETCURSEL, 0, 0L);
    AssertSz(iIndex != LB_ERR,
            "Should have been able to get a selection in SetCurrentIsdnChannelSelection");

    *pnBChannel = iIndex;

    // Get the item data for the current selection
    //
    iItemData = SendDlgItemMessage(hwndDlg, iChannelLB,
                                   LB_GETITEMDATA, iIndex, (LPARAM)0);
    AssertSz(iItemData != (INT_PTR)LB_ERR, "LB_ERR returned from LB_GETITEMDATA on "
             "Channel LB. Bogus.");

    // It's valid data, so cast it to the struct form.
    // Note: Use the cost new casting operators.
    //
    pisdnbc = (PISDN_B_CHANNEL) iItemData;

    // Populate the edit controls with the newly selected data.
    //
    SetDataToEditControls(hwndDlg, iPhoneControl, iSpidControl, pisdnci,
                          pisdnbc);
}

//+---------------------------------------------------------------------------
//
//  Function:   PopulateIsdnChannels
//
//  Purpose:    Fills in the channel listboxes and edit controls for the
//              second page of the wizard.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      iLineLB       [in]  Item ID of "Line" listbox
//      iChannelLB    [in]  Item ID of "Channel" or "Terminal" listbox
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//
//  Returns:    Nothing.
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID PopulateIsdnChannels(HWND hwndDlg, INT iSpidControl, INT iPhoneControl,
                          INT iLineLB, INT iChannelLB,
                          PISDN_CONFIG_INFO pisdnci)
{
    DWORD           iBChannel = 0;
    PISDN_D_CHANNEL pisdndc = NULL;
    DWORD           iDChannel;
    WCHAR           szChannelName[c_iMaxChannelName + 1];

    Assert(hwndDlg);
    Assert(iSpidControl);
    Assert(iPhoneControl);
    Assert(iLineLB);
    Assert(iChannelLB);
    Assert(pisdnci);

    // Set the maximum lengths of the SPID and Phone number controls
    //
    SendDlgItemMessage(hwndDlg, iSpidControl, EM_SETLIMITTEXT,
                       RAS_MaxPhoneNumber, 0L);
    SendDlgItemMessage(hwndDlg, iPhoneControl, EM_SETLIMITTEXT,
                       RAS_MaxPhoneNumber, 0L);

    SendDlgItemMessage(hwndDlg, iLineLB, LB_RESETCONTENT, 0, 0);

    // Loop thru the D channels (lines)
    for (iDChannel = 0; iDChannel < pisdnci->dwNumDChannels; iDChannel++)
    {
        // Create the string for the channel display. The user will see them
        // enumerated from 1, even though in memory and in the registry, they are
        // enumerated from 0.
        //
        wsprintfW(szChannelName, L"%d", iDChannel + 1);

        // Insert the text
        //
        SendDlgItemMessage(hwndDlg, iLineLB, LB_ADDSTRING, 0,
                           (LPARAM) szChannelName);
    }

    // Get the pointer to the first D Channel's data
    //
    pisdndc = &(pisdnci->pDChannel[0]);

    // Loop through the B channels, and fill the listbox with the channel numbers.
    // Also, fill the channel information for the first B Channel
    //
    SendDlgItemMessage(hwndDlg, iChannelLB, LB_RESETCONTENT, 0, 0);
    for (iBChannel = 0; iBChannel < pisdndc->dwNumBChannels; iBChannel++)
    {
        INT             iInsertionIndex = 0;
        PISDN_B_CHANNEL pisdnbc;

        // Create the string for the channel display. The user will see them
        // enumerated from 1, even though in memory and in the registry, they are
        // enumerated from 0.
        //
        wsprintfW(szChannelName, L"%d", iBChannel + 1);

        // Insert the text
        //
        iInsertionIndex = (INT)SendDlgItemMessage(hwndDlg, iChannelLB,
                                                  LB_ADDSTRING, 0,
                                                  (LPARAM) szChannelName);
        if (iInsertionIndex == LB_ERR)
        {
            AssertSz(FALSE, "Unable to add channel name to listbox in "
                     "PopulateIsdnChannels");
            goto Exit;
        }

        pisdnbc = &pisdndc->pBChannel[iBChannel];

        // Init the item data with the first D channel's information
        //
        SendDlgItemMessage(hwndDlg, iChannelLB, LB_SETITEMDATA,
                           iInsertionIndex, (LPARAM) pisdnbc);

        // If we're on the 0'th member, then we want to fill in the edit controls
        // for that particular channel,
        //
        if (iBChannel == 0)
        {
            SetDataToEditControls(hwndDlg, iPhoneControl, iSpidControl,
                                  pisdnci, pisdnbc);
        }
    }

    // Select first item in each list box
    //
    SendDlgItemMessage(hwndDlg, iChannelLB, LB_SETCURSEL, 0, 0L);
    SendDlgItemMessage(hwndDlg, iLineLB, LB_SETCURSEL, 0, 0L);

Exit:
    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetDataToEditControls
//
//  Purpose:    Sets the in-memory state information to the page's edit
//              controls.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//      pisdnbc       [in]  Currently selected B-channel's data
//
//  Returns:    Nothing
//
//  Author:     danielwe   16 Mar 1998
//
//  Notes:
//
VOID SetDataToEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                           PISDN_CONFIG_INFO pisdnci, PISDN_B_CHANNEL pisdnbc)
{
    switch (pisdnci->idd)
    {
    case IDW_ISDN_SPIDS:
    case IDD_ISDN_SPIDS:
        SetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSpid);
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    case IDW_ISDN_EAZ:
    case IDD_ISDN_EAZ:
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    case IDW_ISDN_JAPAN:
    case IDD_ISDN_JAPAN:
        SetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSubaddress);
        SetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetDataFromEditControls
//
//  Purpose:    Retrieves contents of the edit controls into the in-memory
//              state for the given B-channel.
//
//  Arguments:
//      hwndDlg       [in]  Handle to dialog
//      iSpidControl  [in]  Item ID of "spid" edit control
//      iPhoneControl [in]  Item ID of "Phone number" edit control
//      pisdnci       [in]  Configuration information as read from the
//                          registry
//      pisdnbc       [in]  Currently selected B-channel's data
//
//  Returns:    Nothing
//
//  Author:     danielwe   16 Mar 1998
//
//  Notes:
//
VOID GetDataFromEditControls(HWND hwndDlg, INT iPhoneControl, INT iSpidControl,
                             PISDN_CONFIG_INFO pisdnci,
                             PISDN_B_CHANNEL pisdnbc)
{
    switch (pisdnci->idd)
    {
    case IDW_ISDN_SPIDS:
    case IDD_ISDN_SPIDS:
        GetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSpid,
                       celems(pisdnbc->szSpid));
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    case IDW_ISDN_EAZ:
    case IDD_ISDN_EAZ:
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    case IDW_ISDN_JAPAN:
    case IDD_ISDN_JAPAN:
        GetDlgItemText(hwndDlg, iSpidControl, pisdnbc->szSubaddress,
                       celems(pisdnbc->szSubaddress));
        GetDlgItemText(hwndDlg, iPhoneControl, pisdnbc->szPhoneNumber,
                       celems(pisdnbc->szPhoneNumber));
        break;
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   SetModifiedIsdnChannelInfo
//
//  Purpose:    Stores the contents of the
//
//  Arguments:
//      hwndDlg         [in]    Handle to dialog.
//      iSpidControl    [in]    Item ID of "spid" edit control
//      iPhoneControl   [in]    Item ID of "Phone number" edit control
//      iChannelLB      [in]    Item ID of "Channel" or "Terminal" listbox
//      iCurrentChannel [in]    Currently selected B-channel
//      pisdnci         [in]    ISDN config info
//
//  Returns:    Nothing
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
VOID SetModifiedIsdnChannelInfo(HWND hwndDlg, INT iSpidControl,
                                INT iPhoneControl, INT iChannelLB,
                                INT iCurrentChannel,
                                PISDN_CONFIG_INFO pisdnci)
{
    INT_PTR         iSelectionData      = 0;
    PISDN_B_CHANNEL pisdnbc             = NULL;

    // Get the item data from the current selection
    //
    iSelectionData = SendDlgItemMessage(hwndDlg, iChannelLB, LB_GETITEMDATA,
                                        iCurrentChannel, (LPARAM)0);
    AssertSz(iSelectionData != (INT_PTR)LB_ERR,
             "We should not have failed to get the item data from the Channel LB");

    // Convert the item data to the real structure
    //
    pisdnbc = (PISDN_B_CHANNEL) iSelectionData;

    AssertSz(pisdnbc,
            "Someone forgot to set the item data. Bad someone!...Bad!");

    GetDataFromEditControls(hwndDlg, iPhoneControl, iSpidControl, pisdnci,
                            pisdnbc);
}

//
// Helper functions
//

//+---------------------------------------------------------------------------
//
//  Function:   DwGetCurrentCountryCode
//
//  Purpose:    Returns current country code for the system
//
//  Arguments:
//      (none)
//
//  Returns:    Country code from winnls.h (CTRY_*)
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
DWORD DwGetCurrentCountryCode()
{
    WCHAR   szCountry[10];

    GetLocaleInfo(LOCALE_SYSTEM_DEFAULT, LOCALE_ICOUNTRY, szCountry,
                  celems(szCountry));

    return wcstoul(szCountry, NULL, 10);
}

//+---------------------------------------------------------------------------
//
//  Function:   FIsDefaultForLocale
//
//  Purpose:    Determines if the given switch type is the default switch
//              type for the given locale.
//
//  Arguments:
//      nCountry     [in]   Country code from winnls.h (CTRY_*)
//      dwSwitchType [in]   Switch type mask ISDN_SWITCH_* (from above)
//
//  Returns:    TRUE if switch type is the default, FALSE if not
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
BOOL FIsDefaultForLocale(DWORD nCountry, DWORD dwSwitchType)
{
    switch (nCountry)
    {
    case CTRY_UNITED_STATES:
        return ((dwSwitchType == ISDN_SWITCH_NI1) ||
                (dwSwitchType == ISDN_SWITCH_NI2));

    case CTRY_JAPAN:
        return (dwSwitchType == ISDN_SWITCH_INS64);

    case CTRY_TAIWAN:
    case CTRY_PRCHINA:
    case CTRY_NEW_ZEALAND:
    case CTRY_AUSTRALIA:
    case CTRY_ARMENIA:
    case CTRY_AUSTRIA:
    case CTRY_BELGIUM:
    case CTRY_BULGARIA:
    case CTRY_CROATIA:
    case CTRY_CZECH:
    case CTRY_DENMARK:
    case CTRY_FINLAND:
    case CTRY_FRANCE:
    case CTRY_GERMANY:
    case CTRY_GREECE:
    case CTRY_HONG_KONG:
    case CTRY_HUNGARY:
    case CTRY_ICELAND:
    case CTRY_IRELAND:
    case CTRY_ITALY:
    case CTRY_LITHUANIA:
    case CTRY_LUXEMBOURG:
    case CTRY_MACEDONIA:
    case CTRY_NETHERLANDS:
    case CTRY_NORWAY:
    case CTRY_ROMANIA:
    case CTRY_SERBIA:
    case CTRY_SLOVAK:
    case CTRY_SLOVENIA:
    case CTRY_SPAIN:
    case CTRY_SWEDEN:
    case CTRY_SWITZERLAND:
    case CTRY_UNITED_KINGDOM:
        return (dwSwitchType == ISDN_SWITCH_DSS1);

    default:
        return FALSE;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   DestroyWizardData
//
//  Purpose:    Callback for the all wizard pages.  Cleans up when page is
//              being destroyed.
//
//  Arguments:
//      hwnd    [in]   See win32 SDK for property page callback
//      uMsg    [in]
//      ppsp    [in]
//
//  Returns:    1 (See win32 sdk)
//
//  Author:     BillBe   22 Apr 1998
//
//  Notes:
//
UINT CALLBACK
DestroyWizardData(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    if (PSPCB_RELEASE == uMsg)
    {
        PAGE_DATA *     pPageData;

        pPageData = (PAGE_DATA *)ppsp->lParam;

        if (pPageData->idd == IDW_ISDN_SWITCH_TYPE)
        {
            PISDN_CONFIG_INFO   pisdnci;

            // If this is the switch type dialog being destroyed, we'll
            // destroy the ISDN info. Since it's shared among all pages,
            // we should only do this for one of the pages.
            //
            pisdnci = pPageData->pisdnci;
            FreeIsdnPropertiesInfo(pisdnci);
        }

        delete pPageData;
    }

    return 1;
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDC_LBX_Line,           2003230,  2003230 },
    { IDC_LBX_Variant,        2003240,  2003240 },
    { IDC_EDT_PhoneNumber,    2003250,  2003255 },
    { IDC_EDT_SPID,           2003265,  2003260 },
    { IDC_EDT_MSN,            2003270,  2003270 },
    { IDC_PSB_ADD,            2003280,  2003280 },
    { IDC_LBX_MSN,            2003290,  2003290 },
    { IDC_PSB_REMOVE,         2003300,  2003300 },
    { IDC_CMB_SwitchType,     2003310,  2003310 },
    { IDC_PSB_Configure,      2003320,  2003320 },
};

static const DWORD c_cdwContextIdMap = celems(c_adwContextIdMap);

//+---------------------------------------------------------------------------
//
//  Function:   DwContextIdFromIdc
//
//  Purpose:    Converts the given control ID to a context help ID
//
//  Arguments:
//      idControl [in]  Control ID to convert
//
//  Returns:    Context help ID for that control (mapping comes from help
//              authors)
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
DWORD DwContextIdFromIdc(PISDN_CONFIG_INFO pisdnci, INT idControl)
{
    DWORD   idw;

    for (idw = 0; idw < c_cdwContextIdMap; idw++)
    {
        if (idControl == c_adwContextIdMap[idw].idControl)
        {
            if (pisdnci->idd == IDD_ISDN_JAPAN)
            {
                return c_adwContextIdMap[idw].dwContextIdJapan;
            }
            else
            {
                return c_adwContextIdMap[idw].dwContextId;
            }
        }
    }

    // Not found, just return 0
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   OnHelpGeneric
//
//  Purpose:    Handles help generically
//
//  Arguments:
//      hwnd   [in]     HWND of parent window
//      lParam [in]     lParam of the WM_HELP message
//
//  Returns:    Nothing
//
//  Author:     danielwe   27 May 1998
//
//  Notes:
//
VOID OnHelpGeneric(PISDN_CONFIG_INFO pisdnci, HWND hwnd, LPARAM lParam)
{
    LPHELPINFO  lphi;

    static const WCHAR c_szIsdnHelpFile[] = L"devmgr.hlp";

    lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (lphi->iContextType == HELPINFO_WINDOW)
    {
        if (lphi->iCtrlId != IDC_STATIC)
        {
            WinHelp(hwnd, c_szIsdnHelpFile, HELP_CONTEXTPOPUP,
                    DwContextIdFromIdc(pisdnci, lphi->iCtrlId));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnreg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N R E G . C P P
//
//  Contents:   ISDN Wizard/PropertySheet registry functions
//
//  Notes:
//
//  Author:     VBaliga   14 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "isdncfg.h"
#include "ncreg.h"

#define NUM_D_CHANNELS_ALLOWED  16
#define NUM_B_CHANNELS_ALLOWED  50

// Reg key value names

// For each ISDN card instance
static const WCHAR c_szWanEndpoints[]       = L"WanEndpoints";
static const WCHAR c_szIsdnNumDChannels[]   = L"IsdnNumDChannels";
static const WCHAR c_szIsdnSwitchTypes[]    = L"IsdnSwitchTypes";

// For each D-channel
static const WCHAR c_szIsdnSwitchType[]     = L"IsdnSwitchType";
static const WCHAR c_szIsdnNumBChannels[]   = L"IsdnNumBChannels";

// For each B-channel
static const WCHAR c_szIsdnSpid[]           = L"IsdnSpid";
static const WCHAR c_szIsdnPhoneNumber[]    = L"IsdnPhoneNumber";
static const WCHAR c_szIsdnSubaddress[]     = L"IsdnSubaddress";
static const WCHAR c_szIsdnMultiNumbers[]   = L"IsdnMultiSubscriberNumbers";

/*

Function:
    HrReadNthDChannelInfo

Returns:
    HRESULT

Description:
    Read the information for the dwIndex'th D-channel into pDChannel. If this
    function succeeds, it allocates pDChannel->pBChannel, which has to be freed
    by calling LocalFree().

    If there is an error in reading IsdnSwitchType, this function returns
    S_FALSE.

    If there is an error in opening the a B-channel key, or there is an error
    in reading IsdnSpid or IsdnPhoneNumber, this function returns S_FALSE, but
    with empty strings in pBChannel->szSpid and pBChannel->szPhoneNumber for
    that B-channel.

*/

HRESULT
HrReadNthDChannelInfo(
    HKEY            hKeyIsdnBase,
    DWORD           dwDChannelIndex,
    PISDN_D_CHANNEL pDChannel
)
{
    WCHAR           szKeyName[20];      // _itow() uses only 17 wchars
    HKEY            hKeyDChannel        = NULL;
    HKEY            hKeyBChannel        = NULL;
    DWORD           dwBChannelIndex;
    PISDN_B_CHANNEL pBChannel;
    HRESULT         hr                  = E_FAIL;
    BOOL            fReturnSFalse       = FALSE;
    DWORD           cbData;

    Assert(NULL == pDChannel->pBChannel);

    _itow(dwDChannelIndex, szKeyName, 10 /* radix */);

    hr = HrRegOpenKeyEx(hKeyIsdnBase, szKeyName, KEY_READ, &hKeyDChannel);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error opening D-channel %d. hr: %d",
            dwDChannelIndex, hr);
        goto LDone;
    }

    hr = HrRegQueryMultiSzWithAlloc(hKeyDChannel, c_szIsdnMultiNumbers,
                                    &pDChannel->mszMsnNumbers);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d. hr: %d",
                 c_szIsdnMultiNumbers, dwDChannelIndex, hr);

        // Initialize to empty string
        //
        pDChannel->mszMsnNumbers = new WCHAR[1];

		if (pDChannel->mszMsnNumbers == NULL)
		{
			return(ERROR_NOT_ENOUGH_MEMORY);
		}

        *pDChannel->mszMsnNumbers = 0;

        // May not be present
        hr = S_OK;
    }

    hr = HrRegQueryDword(hKeyDChannel, c_szIsdnNumBChannels,
            &(pDChannel->dwNumBChannels));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d. hr: %d",
            c_szIsdnNumBChannels, dwDChannelIndex, hr);
        goto LDone;
    }

    if (NUM_B_CHANNELS_ALLOWED < pDChannel->dwNumBChannels ||
        0 == pDChannel->dwNumBChannels)
    {
        // Actually, dwNumBChannels <= 23. We are protecting ourselves from
        // a corrupt registry.

        TraceTag(ttidISDNCfg, "%S in D-channel %d has invalid value: %d",
            c_szIsdnNumBChannels, dwDChannelIndex, pDChannel->dwNumBChannels);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);
        goto LDone;
    }

    pDChannel->pBChannel = (PISDN_B_CHANNEL)
        LocalAlloc(LPTR, sizeof(ISDN_B_CHANNEL) * pDChannel->dwNumBChannels);

    if (NULL == pDChannel->pBChannel)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    ZeroMemory(pDChannel->pBChannel, sizeof(ISDN_B_CHANNEL) *
                                     pDChannel->dwNumBChannels);

    for (dwBChannelIndex = 0;
         dwBChannelIndex < pDChannel->dwNumBChannels;
         dwBChannelIndex++)
    {
        pBChannel = pDChannel->pBChannel + dwBChannelIndex;
        _itow(dwBChannelIndex, szKeyName, 10 /* radix */);

        hr = HrRegOpenKeyEx(hKeyDChannel, szKeyName, KEY_READ, &hKeyBChannel);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error opening B-channel %d in D-channel "
                     "%d. hr: %d", dwBChannelIndex, dwDChannelIndex, hr);
            goto LForEnd;
        }

        cbData = sizeof(pBChannel->szSpid);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnSpid, pBChannel->szSpid,
                &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnSpid,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

        cbData = sizeof(pBChannel->szPhoneNumber);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnPhoneNumber,
                pBChannel->szPhoneNumber, &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnPhoneNumber,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

        cbData = sizeof(pBChannel->szSubaddress);

        hr = HrRegQuerySzBuffer(hKeyBChannel, c_szIsdnSubaddress,
                                pBChannel->szSubaddress, &cbData);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error reading %S in D-channel %d, "
                     "B-channel %d. hr: %d", c_szIsdnSubaddress,
                     dwDChannelIndex, dwBChannelIndex, hr);

            // May not be present
            hr = S_OK;
        }

LForEnd:

        if (FAILED(hr))
        {
            fReturnSFalse = TRUE;
            hr = S_OK;
            pBChannel->szSpid[0] = L'\0';
            pBChannel->szPhoneNumber[0] = L'\0';
        }

        RegSafeCloseKey(hKeyBChannel);
    }

LDone:

    RegSafeCloseKey(hKeyDChannel);

    if (FAILED(hr))
    {
        LocalFree(pDChannel->pBChannel);
        pDChannel->pBChannel = NULL;
    }

    if (SUCCEEDED(hr) && fReturnSFalse)
    {
        TraceTag(ttidISDNCfg, "HrReadNthDChannelInfo(%d) returning S_FALSE",
            dwDChannelIndex);
        hr = S_FALSE;
    }

    TraceError("HrReadNthDChannelInfo", (S_FALSE == hr) ? S_OK: hr);
    return(hr);
}

/*

Function:
    HrReadDChannelsInfo

Returns:
    HRESULT

Description:
    Read the D-channel information into *ppDChannel. If the function fails,
    *ppDChannel will be NULL.

*/

HRESULT
HrReadDChannelsInfo(
    HKEY                hKeyISDNBase,
    DWORD               dwNumDChannels,
    PISDN_D_CHANNEL*    ppDChannel
)
{
    HRESULT         hr              = E_FAIL;
    BOOL            fReturnSFalse   = FALSE;
    PISDN_D_CHANNEL pDChannel;
    DWORD           dwIndex;

    pDChannel = (PISDN_D_CHANNEL)
                LocalAlloc(LPTR, sizeof(ISDN_D_CHANNEL) * dwNumDChannels);

    if (NULL == pDChannel)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    // If there is an error, we will free these variables if they are not NULL.
    for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
    {
        Assert(NULL == pDChannel[dwIndex].pBChannel);
    }

    for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
    {
        hr = HrReadNthDChannelInfo(hKeyISDNBase, dwIndex, pDChannel + dwIndex);

        if (FAILED(hr))
        {
            goto LDone;
        }

        if (S_FALSE == hr)
        {
            fReturnSFalse = TRUE;
        }
    }

LDone:

    if (FAILED(hr))
    {
        if (NULL != pDChannel)
		{
			for (dwIndex = 0; dwIndex < dwNumDChannels; dwIndex++)
			{
				LocalFree(pDChannel[dwIndex].pBChannel);
			}

			LocalFree(pDChannel);

			*ppDChannel = NULL;
		}
    }
    else
    {
        *ppDChannel = pDChannel;
    }

    if (SUCCEEDED(hr) && fReturnSFalse)
    {
        TraceTag(ttidISDNCfg, "HrReadDChannelsInfo() returning S_FALSE");
        hr = S_FALSE;
    }

    TraceError("HrReadDChannelsInfo", (S_FALSE == hr) ? S_OK : hr);
    return(hr);
}

/*

Function:
    HrReadISDNPropertiesInfo

Returns:
    HRESULT

Description:
    Read the ISDN registry structure into the config info. If the function
    fails, *ppISDNConfig will be NULL. Else, *ppISDNConfig has to be freed
    by calling FreeISDNPropertiesInfo().

*/

HRESULT
HrReadIsdnPropertiesInfo(
    HKEY                hKeyIsdnBase,
    HDEVINFO            hdi,
    PSP_DEVINFO_DATA    pdeid,
    PISDN_CONFIG_INFO*  ppIsdnConfig
)
{
    HRESULT             hr              = E_FAIL;
    PISDN_CONFIG_INFO   pIsdnConfig;
    DWORD               dwIndex;

    pIsdnConfig = (PISDN_CONFIG_INFO)
                  LocalAlloc(LPTR, sizeof(ISDN_CONFIG_INFO));

    if (NULL == pIsdnConfig)
    {
        hr = HrFromLastWin32Error();
        TraceTag(ttidISDNCfg, "Couldn't allocate memory. hr: %d", hr);
        goto LDone;
    }

    ZeroMemory(pIsdnConfig, sizeof(ISDN_CONFIG_INFO));

    pIsdnConfig->hdi = hdi;
    pIsdnConfig->pdeid = pdeid;

    // If there is an error, we will free these variables if they are not NULL.
    Assert(NULL == pIsdnConfig->pDChannel);

    hr = HrRegQueryDword(hKeyIsdnBase, c_szWanEndpoints,
            &(pIsdnConfig->dwWanEndpoints));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szWanEndpoints,
            hr);
        goto LDone;
    }

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnNumDChannels,
            &(pIsdnConfig->dwNumDChannels));

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szIsdnNumDChannels,
            hr);
        goto LDone;
    }

    if (NUM_D_CHANNELS_ALLOWED < pIsdnConfig->dwNumDChannels ||
        0 == pIsdnConfig->dwNumDChannels)
    {
        // Actually, dwNumDChannels <= 8. We are protecting ourselves from
        // a corrupt registry.

        TraceTag(ttidISDNCfg, "%S has invalid value: %d", c_szIsdnNumDChannels,
            pIsdnConfig->dwNumDChannels);

        hr = HRESULT_FROM_WIN32(ERROR_INVALID_DATA);

        // Setting dwNumDChannels to 0 will help us when we try to free the
        // allocated ISDN_B_CHANNEL's

        pIsdnConfig->dwNumDChannels = 0;

        goto LDone;
    }

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnSwitchTypes,
                         &pIsdnConfig->dwSwitchTypes);

    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error reading %S. hr: %d", c_szIsdnSwitchTypes,
                 hr);
        goto LDone;
    }

    hr = HrReadDChannelsInfo(hKeyIsdnBase, pIsdnConfig->dwNumDChannels,
            &(pIsdnConfig->pDChannel));

    if (FAILED(hr))
    {
        goto LDone;
    }

    // A PRI adapter is one that has more than 2 B channels per D channel.
    // Since all D channels should have the same number of B channels, the
    // safest thing to do is pick the first D channel
    //
    pIsdnConfig->fIsPri = (pIsdnConfig->pDChannel[0].dwNumBChannels > 2);

#if DBG
    if (pIsdnConfig->fIsPri)
    {
        TraceTag(ttidISDNCfg, "This is a PRI adapter!");
    }
#endif

    hr = HrRegQueryDword(hKeyIsdnBase, c_szIsdnSwitchType,
                         &(pIsdnConfig->dwCurSwitchType));

    if (FAILED(hr))
    {
        Assert(ISDN_SWITCH_NONE == pIsdnConfig->dwCurSwitchType);

        TraceTag(ttidISDNCfg, "Error reading %S. If this is a new install, "
                 "then this is expected. hr: %d", c_szIsdnSwitchType,
                 hr);

        // Switch type won't exist on a new install of the card so this is ok
        hr = S_OK;
    }

LDone:

    if (FAILED(hr))
    {
        if (NULL != pIsdnConfig)
		{
			if (NULL != pIsdnConfig->pDChannel)
			{
				for (dwIndex = 0;
					 dwIndex < pIsdnConfig->dwNumDChannels;
					 dwIndex++)
				{
					LocalFree(pIsdnConfig->pDChannel[dwIndex].pBChannel);
				}

				LocalFree(pIsdnConfig->pDChannel);
			}

			LocalFree(pIsdnConfig);
			*ppIsdnConfig = NULL;
        }
    }
    else
    {
        *ppIsdnConfig = pIsdnConfig;
    }

    TraceError("HrReadIsdnPropertiesInfo", hr);
    return(hr);
}

/*

Function:
    HrWriteIsdnPropertiesInfo

Returns:
    HRESULT

Description:
    Write the ISDN config info back into the registry.

*/

HRESULT
HrWriteIsdnPropertiesInfo(
    HKEY                hKeyIsdnBase,
    PISDN_CONFIG_INFO   pIsdnConfig
)
{
    WCHAR           szKeyName[20];      // _itow() uses only 17 wchars
    HRESULT         hr                  = E_FAIL;
    HKEY            hKeyDChannel        = NULL;
    HKEY            hKeyBChannel        = NULL;
    DWORD           dwDChannelIndex;
    DWORD           dwBChannelIndex;
    PISDN_D_CHANNEL pDChannel;
    PISDN_B_CHANNEL pBChannel;

    Assert(NUM_D_CHANNELS_ALLOWED >= pIsdnConfig->dwNumDChannels);

    hr = HrRegSetDword(hKeyIsdnBase, c_szIsdnSwitchType,
                       pIsdnConfig->dwCurSwitchType);
    if (FAILED(hr))
    {
        TraceTag(ttidISDNCfg, "Error writing %S. hr: %d",
                 c_szIsdnSwitchType, hr);
        goto LOuterForEnd;
    }

    for (dwDChannelIndex = 0;
         dwDChannelIndex < pIsdnConfig->dwNumDChannels;
         dwDChannelIndex++)
    {
        pDChannel = pIsdnConfig->pDChannel + dwDChannelIndex;
        _itow(dwDChannelIndex, szKeyName, 10 /* radix */);

        hr = HrRegOpenKeyEx(hKeyIsdnBase, szKeyName, KEY_WRITE,
                            &hKeyDChannel);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error opening D-channel %d. hr: %d",
                dwDChannelIndex, hr);
            goto LOuterForEnd;
        }

        hr = HrRegSetMultiSz(hKeyDChannel, c_szIsdnMultiNumbers,
                             pDChannel->mszMsnNumbers);

        if (FAILED(hr))
        {
            TraceTag(ttidISDNCfg, "Error writing %S. hr: %d",
                     c_szIsdnMultiNumbers, hr);
            goto LOuterForEnd;
        }

        Assert(NUM_B_CHANNELS_ALLOWED >= pDChannel->dwNumBChannels);

        for (dwBChannelIndex = 0;
             dwBChannelIndex < pDChannel->dwNumBChannels;
             dwBChannelIndex++)
        {
            pBChannel = pDChannel->pBChannel + dwBChannelIndex;
            _itow(dwBChannelIndex, szKeyName, 10 /* radix */);

            hr = HrRegCreateKeyEx(hKeyDChannel, szKeyName,
                    REG_OPTION_NON_VOLATILE, KEY_WRITE,
                    NULL, &hKeyBChannel, NULL);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error opening B-channel %d in "
                         "D-channel %d. hr: %d", dwBChannelIndex,
                         dwDChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnSpid, pBChannel->szSpid);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnSpid,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnPhoneNumber,
                            pBChannel->szPhoneNumber);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnPhoneNumber,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

            hr = HrRegSetSz(hKeyBChannel, c_szIsdnSubaddress,
                            pBChannel->szSubaddress);

            if (FAILED(hr))
            {
                TraceTag(ttidISDNCfg, "Error writing %S in D-channel %d, "
                         "B-channel %d. hr: %d", c_szIsdnSubaddress,
                         dwDChannelIndex, dwBChannelIndex, hr);
                goto LInnerForEnd;
            }

LInnerForEnd:

            RegSafeCloseKey(hKeyBChannel);

            if (FAILED(hr))
            {
                goto LOuterForEnd;
            }
        }

LOuterForEnd:

        RegSafeCloseKey(hKeyDChannel);

        if (FAILED(hr))
        {
            goto LDone;
        }
    }

LDone:

    TraceError("HrWriteIsdnPropertiesInfo", hr);
    return(hr);
}

/*

Function:
    FreeIsdnPropertiesInfo

Returns:
    HRESULT

Description:
    Free the structure allocated by HrReadIsdnPropertiesInfo.

*/

VOID
FreeIsdnPropertiesInfo(
    PISDN_CONFIG_INFO   pIsdnConfig
)
{
    DWORD   dwIndex;

    if (NULL == pIsdnConfig)
    {
        return;
    }

    if (NULL != pIsdnConfig->pDChannel)
    {
        for (dwIndex = 0; dwIndex < pIsdnConfig->dwNumDChannels; dwIndex++)
        {
            LocalFree(pIsdnConfig->pDChannel[dwIndex].pBChannel);
            delete [] pIsdnConfig->pDChannel[dwIndex].mszMsnNumbers;
        }

        LocalFree(pIsdnConfig->pDChannel);
    }

    LocalFree(pIsdnConfig);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnpage.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N P A G E . C P P
//
//  Contents:   Contains the isdn page for enumerated net class devices
//
//  Notes:
//
//  Author:     BillBe 9 Sep 1997
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "isdnpage.h"
#include "isdnshts.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"

CIsdnPage::CIsdnPage()
:   m_fDirty(FALSE),
    m_hkeyDriver(NULL),
    m_hdi(NULL),
    m_pdeid(NULL),
    m_pisdnci(NULL)
{
}

CIsdnPage::~CIsdnPage()
{
    if (m_pisdnci)
    {
        // Free the structure. This was allocated by
        // HrReadIsdnPropertiesInfo.
        //
        FreeIsdnPropertiesInfo(m_pisdnci);
    }
    RegSafeCloseKey(m_hkeyDriver);
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::CreatePage
//
//  Purpose:    Creates the Isdn page only if there the device is an isdn
//                  adapter
//
//  Arguments:
//      hdi    [in] SetupApi HDEVINFO for device
//      pdeid  [in] SetupApi PSP_DEVINFO_DATA for device
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     billbe 9 Sep 1997
//
//  Notes:
//
HPROPSHEETPAGE
CIsdnPage::CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(INVALID_HANDLE_VALUE != hdi);
    Assert(hdi);
    Assert(pdeid);

    HPROPSHEETPAGE hpsp = NULL;

    // Open the device's instance key
    HRESULT     hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
                        DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
                        &m_hkeyDriver);

    // If the key was opened and this adapter is ISDN
    if (SUCCEEDED(hr) && FShowIsdnPages(m_hkeyDriver))
    {
        // read the adapter's properties from the registry
        hr = HrReadIsdnPropertiesInfo(m_hkeyDriver, hdi, pdeid, &m_pisdnci);
        if (SUCCEEDED(hr))
        {
            m_hdi = hdi;
            m_pdeid = pdeid;

            hpsp = CPropSheetPage::CreatePage(IDP_ISDN_SWITCH_TYPE, 0);
        }
    }

    return hpsp;
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::OnInitDialog
//
//  Purpose:    Handler for the WM_INITDIALOG window message.  Initializes
//              the dialog window.
//
//  Author:     BillBe   09 Sep 1997
//
//  Notes:
//
//
LRESULT
CIsdnPage::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the switch types from the multi-sz that we read
    PopulateIsdnSwitchTypes(m_hWnd, IDC_CMB_SwitchType, m_pisdnci);
    SetSwitchType(m_hWnd, IDC_CMB_SwitchType, m_pisdnci->dwCurSwitchType);

    //Enable or disable the Configure button depending on the switch type selected.

    EnableDisableConfigure();

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = (INT)SendDlgItemMessage(IDC_LBX_Variant,
                                                      LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = (INT)SendDlgItemMessage(IDC_LBX_Line,
                                                      LB_GETCURSEL, 0, 0);
    return 0;
}

LRESULT
CIsdnPage::OnSwitchType(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    if (wNotifyCode == CBN_SELCHANGE)
    {
        m_fDirty = TRUE;
        SetChangedFlag();

        //Enable or disable the Configure button depending on the switch type selected.

        EnableDisableConfigure();
    }

    return 0;
}

//+--------------------------------------------------------------------------
//
//  Member:     CIsdnPage::OnApply
//
//  Purpose:    Handler for the PSN_APPLY message
//
//  Author:     BillBe   10 Sep 1997
//
//  Notes:
//
//
LRESULT
CIsdnPage::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{

    // only do something if data has changed.
    if (m_fDirty)
    {
        // Update the switch type
        m_pisdnci->dwCurSwitchType = DwGetSwitchType(m_hWnd, m_pisdnci,
                                                     IDC_CMB_SwitchType);

        // Write the parameters back out into the registry.
        (void) HrWriteIsdnPropertiesInfo(m_hkeyDriver, m_pisdnci);

        // Notify the UI that its display might need updating
        //
        SP_DEVINSTALL_PARAMS deip;
        // Try to get the current params
        (void) HrSetupDiGetDeviceInstallParams(m_hdi, m_pdeid, &deip);
        deip.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;
        // Try to set the new params. If it fails, it is not
        // catastrophic so we ignore return values
        (void) HrSetupDiSetDeviceInstallParams(m_hdi, m_pdeid, &deip);

        // Changes have been applied so clear our dirty flag
        m_fDirty = FALSE;
    }

    return 0;
}

LRESULT
CIsdnPage::OnConfigure(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                       BOOL& bHandled)
{
    DWORD   dwSwitchType;

    dwSwitchType = DwGetSwitchType(m_hWnd, m_pisdnci, IDC_CMB_SwitchType);

    switch (dwSwitchType)
    {
    case ISDN_SWITCH_ATT:
    case ISDN_SWITCH_NI1:
    case ISDN_SWITCH_NI2:
    case ISDN_SWITCH_NTI:
        if (m_pisdnci->fIsPri)
        {
            // PRI adapters use the EAZ page instead
            DoEazDlg();
        }
        else
        {
            DoSpidsDlg();
        }
        break;

    case ISDN_SWITCH_INS64:
        DoJapanDlg();
        break;

    case ISDN_SWITCH_1TR6:
    case ISDN_SWITCH_AUTO:
        DoEazDlg();
        break;

    case ISDN_SWITCH_VN3:
    case ISDN_SWITCH_DSS1:
    case ISDN_SWITCH_AUS:
    case ISDN_SWITCH_BEL:
    case ISDN_SWITCH_VN4:
    case ISDN_SWITCH_SWE:
    case ISDN_SWITCH_ITA:
    case ISDN_SWITCH_TWN:
        DoMsnDlg();
        break;

    default:
        AssertSz(FALSE, "Where do we go from here.. now that all of our "
                 "children are growin' up?");
        break;
    }

    return 0;
}

VOID CIsdnPage::DoSpidsDlg()
{
    CSpidsDlg   dlg(m_pisdnci);
    INT_PTR     nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoJapanDlg()
{
    CJapanDlg   dlg(m_pisdnci);
    INT_PTR     nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoEazDlg()
{
    CEazDlg     dlg(m_pisdnci);
    INT_PTR     nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

VOID CIsdnPage::DoMsnDlg()
{
    CMsnDlg     dlg(m_pisdnci);
    INT_PTR     nRet;

    m_pisdnci->idd = dlg.IDD;
    nRet = dlg.DoModal(m_hWnd);
    if (nRet)
    {
        m_fDirty = TRUE;
        SetChangedFlag();
    }
}

static const CONTEXTIDMAP c_adwContextIdMap[] =
{
    { IDC_LBX_Line,           2003230,  2003230 },
    { IDC_LBX_Variant,        2003240,  2003240 },
    { IDC_EDT_PhoneNumber,    2003250,  2003255 },
    { IDC_EDT_SPID,           2003265,  2003260 },
    { IDC_EDT_MSN,            2003270,  2003270 },
    { IDC_PSB_ADD,            2003280,  2003280 },
    { IDC_LBX_MSN,            2003290,  2003290 },
    { IDC_PSB_REMOVE,         2003300,  2003300 },
    { IDC_CMB_SwitchType,     2003310,  2003310 },
    { IDC_PSB_Configure,      2003320,  2003320 },
    { 0,                      0,        0 },        // end marker
};

LRESULT CIsdnPage::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

LRESULT CIsdnPage::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                                BOOL& bHandled)
{
	HELPINFO  hi;

	HMENU h = CreatePopupMenu();
	POINT pScreen;
	TCHAR szWhat[MAX_PATH];

    if (h == NULL)
	{
		return FALSE;
	}

	LoadString(_Module.GetResourceInstance(), IDS_ISDN_WHATS_THIS, szWhat, MAX_PATH);

	InsertMenu(h, -1, MF_BYPOSITION, 777, szWhat);

	pScreen.x = ((int)(short)LOWORD(lParam));
	pScreen.y = ((int)(short)HIWORD(lParam));

	int n;
	switch(n = TrackPopupMenu(h, TPM_NONOTIFY | TPM_RETURNCMD, pScreen.x, pScreen.y, 0, m_hWnd, NULL))
	{
	case 777:
		hi.iContextType = HELPINFO_WINDOW;
		hi.iCtrlId = ::GetWindowLong((HWND)wParam, GWL_ID);

		OnHelpGeneric(m_hWnd, &hi, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);
		break;
	}

    DestroyMenu(h);
    return TRUE;
}

VOID CIsdnPage::EnableDisableConfigure ()
{
    DWORD dwSwitchType;
    HWND  hwndConfigure;

    dwSwitchType = DwGetSwitchType(m_hWnd, m_pisdnci, IDC_CMB_SwitchType);
    hwndConfigure = ::GetDlgItem(m_hWnd, IDC_PSB_Configure);

    Assert(hwndConfigure);

    if (hwndConfigure)
    {
        switch (dwSwitchType)
        {
        case ISDN_SWITCH_ATT:
        case ISDN_SWITCH_NI1:
        case ISDN_SWITCH_NI2:
        case ISDN_SWITCH_NTI:
        case ISDN_SWITCH_AUTO:
            if (m_pisdnci->fIsPri)
            {
                ::EnableWindow(hwndConfigure, FALSE);
            }
            else
            {
                ::EnableWindow(hwndConfigure, TRUE);
            }
            break;

        default:
                ::EnableWindow(hwndConfigure, TRUE);
        }
    }

    return;
}
//+---------------------------------------------------------------------------
//
//  Function:   HrGetIsdnPage
//
//  Purpose:    Creates the Isdn page for enumerated net devices.
//                  This function is called by the NetPropPageProvider fcn.
//
//  Arguments:
//      hdi     [in]   See SetupApi for info
//      pdeid   [in]   See SetupApi for for info
//      phpsp   [out]  Pointer to the handle to the isdn property page
//
//  Returns:
//
//  Author:     billbe 9 Sep 1997
//
//  Notes:
//
HRESULT
HrGetIsdnPage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
              HPROPSHEETPAGE* phpsp)
{
    Assert(hdi);
    Assert(pdeid);
    Assert(phpsp);

    HRESULT hr;
    HPROPSHEETPAGE hpsp;

    CIsdnPage* pisdn = new CIsdnPage();

	if (pisdn == NULL)
	{
		return(ERROR_NOT_ENOUGH_MEMORY);
	}

    // create the isdn page
    hpsp = pisdn->CreatePage(hdi, pdeid);

    // if successful, set the out param
    if (hpsp)
    {
        *phpsp = hpsp;
        hr = S_OK;
    }
    else
    {
        // Either there is no isdn page to display or there
        // was an error.
        hr = E_FAIL;
        *phpsp = NULL;
        delete pisdn;
    }

    TraceErrorOptional("HrGetIsdnPage", hr, E_FAIL == hr);
    return (hr);
}

LRESULT CSpidsDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CSpidsDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CSpidsDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = (INT)SendDlgItemMessage(IDC_LBX_Variant,
                                                     LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = (INT)SendDlgItemMessage(IDC_LBX_Line,
                                                     LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_SPID, EM_LIMITTEXT, c_cchMaxSpid, 0);
    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CSpidsDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                               BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CSpidsDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CEazDlg Implementation
//

LRESULT CEazDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                              BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = (INT)SendDlgItemMessage(IDC_LBX_Variant,
                                                     LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = (INT)SendDlgItemMessage(IDC_LBX_Line,
                                                     LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CEazDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                      BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CEazDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CEazDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                             BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CEazDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                        BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CMsnDlg Implementation
//

LRESULT CMsnDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                              BOOL& bHandled)
{
    OnMsnPageInitDialog(m_hWnd, m_pisdnci);

    // Note the current selections
    //
    m_pisdnci->nOldDChannel = (INT)SendDlgItemMessage(IDC_LBX_Line,
                                                     LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_MSN, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CMsnDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    INT     iCurSel;

    iCurSel = (INT)SendDlgItemMessage(IDC_LBX_Line, LB_GETCURSEL, 0, 0);
    if (iCurSel != LB_ERR)
    {
        GetDataFromListBox(iCurSel, m_hWnd, m_pisdnci);
    }

    EndDialog(TRUE);

    return 0;
}

LRESULT CMsnDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CMsnDlg::OnAdd(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                       BOOL& bHandled)
{
    OnMsnPageAdd(m_hWnd, m_pisdnci);
    return 0;
}

LRESULT CMsnDlg::OnRemove(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    OnMsnPageRemove(m_hWnd, m_pisdnci);
    return 0;
}

LRESULT CMsnDlg::OnChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                          BOOL& bHandled)
{
    OnMsnPageEditSelChange(m_hWnd, m_pisdnci);

    return 0;
}

LRESULT CMsnDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                             BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnMsnPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CMsnDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                        BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}

//
// CJapanDlg Implementation
//

LRESULT CJapanDlg::OnInitDialog(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                BOOL& bHandled)
{
    // Populate the channels from the array of B-Channels stored in our
    // config info for the first D-Channel
    //
    PopulateIsdnChannels(m_hWnd, IDC_EDT_SPID, IDC_EDT_PhoneNumber,
                         IDC_LBX_Line, IDC_LBX_Variant, m_pisdnci);

    ::SetFocus(GetDlgItem(IDC_EDT_PhoneNumber));

    // Note the current selections
    //
    m_pisdnci->nOldBChannel = (INT)SendDlgItemMessage(IDC_LBX_Variant,
                                                      LB_GETCURSEL, 0, 0);
    m_pisdnci->nOldDChannel = (INT)SendDlgItemMessage(IDC_LBX_Line,
                                                      LB_GETCURSEL, 0, 0);

    SendDlgItemMessage(IDC_EDT_PhoneNumber, EM_LIMITTEXT, c_cchMaxOther, 0);
    SendDlgItemMessage(IDC_EDT_SPID, EM_LIMITTEXT, c_cchMaxOther, 0);

    return FALSE;
}

LRESULT CJapanDlg::OnOk(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                        BOOL& bHandled)
{
    OnIsdnInfoPageTransition(m_hWnd, m_pisdnci);
    EndDialog(TRUE);

    return 0;
}

LRESULT CJapanDlg::OnCancel(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                            BOOL& bHandled)
{
    EndDialog(FALSE);

    return 0;
}

LRESULT CJapanDlg::OnSelChange(WORD wNotifyCode, WORD wID, HWND hWndCtl,
                               BOOL& bHandled)
{
    if (wNotifyCode == LBN_SELCHANGE)
    {
        OnIsdnInfoPageSelChange(m_hWnd, m_pisdnci);
    }

    return 0;
}

LRESULT CJapanDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& bHandled)
{
    OnHelpGeneric(m_hWnd, (LPHELPINFO)lParam, c_adwContextIdMap, m_pisdnci->idd == IDD_ISDN_JAPAN, c_szIsdnHelpFile);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnwiz.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N W I Z . C P P
//
//  Contents:   Wizard pages and helper functions for the ISDN Wizard
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "isdncfg.h"
#include "resource.h"
#include "isdnshts.h"
#include "isdncfg.h"
#include "isdnwiz.h"
#include "ncsetup.h"

//+---------------------------------------------------------------------------
//
//  Function:   AddWizardPage
//
//  Purpose:    Adds a wizard page to the hardware wizard's new device
//                  wizard structure
//
//  Arguments:
//      ppsp  [in]    PropSheetPage structure of page to add
//      pndwd [inout] New device wizard structure to add pages to
//
//  Returns:    None
//
//  Author:     BillBe  24 Apr 1998
//
//  Notes:
//
void inline
AddWizardPage(PROPSHEETPAGE* ppsp, PSP_NEWDEVICEWIZARD_DATA pndwd)
{
    // Don't add pages to the new deice wizard if there is no more room
    //
    if (pndwd->NumDynamicPages < MAX_INSTALLWIZARD_DYNAPAGES)
    {
        // Add the handle to the array
        pndwd->DynamicPages[pndwd->NumDynamicPages] =
                CreatePropertySheetPage(ppsp);

        // If we were successful, increment the count of pages
        //
        if (pndwd->DynamicPages[pndwd->NumDynamicPages])
        {
            pndwd->NumDynamicPages++;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   FillInIsdnWizardPropertyPage
//
//  Purpose:    Fills in the given PROPSHEETPAGE structure
//
//  Arguments:
//      psp        []   PropSheetPage structure to fill
//      iDlgID     []   DialogID to use.
//      pszTitle   []   Title of the prop sheet page
//      pfnDlgProc []   Dialog Proc to use.
//      pPageData  []   Pointer to structure for the individual page proc
//
//  Returns:    None
//
//  Author:     jeffspr   15 Jun 1997
//
//  Notes:
//
VOID FillInIsdnWizardPropertyPage(  HINSTANCE          hInst,
                                    PROPSHEETPAGE *    psp,
                                    INT                iDlgID,
                                    PCWSTR             pszTitle,
                                    DLGPROC            pfnDlgProc,
                                    PCWSTR             pszHeaderTitle,
                                    PCWSTR             pszHeaderSubTitle,
                                    LPVOID             pPageData)
{
    // Initialize all of the psp parameters, including the ones that
    // we're not going to use.
    psp->dwSize             = sizeof(PROPSHEETPAGE);
    psp->dwFlags            = PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE |
                              PSP_USETITLE;
    psp->hInstance          = hInst;
    psp->pszTemplate        = MAKEINTRESOURCE(iDlgID);
    psp->pszIcon            = NULL;
    psp->pfnDlgProc         = pfnDlgProc;
    psp->pszTitle           = (PWSTR) pszTitle;
    psp->lParam             = (LPARAM) pPageData;
    psp->pszHeaderTitle     = (PWSTR) pszHeaderTitle;
    psp->pszHeaderSubTitle  = (PWSTR) pszHeaderSubTitle;

    // Unused data
    //
    psp->pfnCallback        = NULL;
    psp->pcRefParent        = NULL;
}

struct WIZ_PAGE_INFO
{
    UINT        uiResId;
    UINT        idsPageTitle;
    UINT        idsPageDesc;
    DLGPROC     pfnDlgProc;
};

static const WIZ_PAGE_INFO  c_aPages[] =
{
    {IDW_ISDN_SWITCH_TYPE,
        IDS_ISDN_SWITCH_TYPE_TITLE,
        IDS_ISDN_SWITCH_TYPE_SUBTITLE,
        IsdnSwitchTypeProc},
    {IDW_ISDN_SPIDS,
        IDS_ISDN_SPIDS_TITLE,
        IDS_ISDN_SPIDS_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_JAPAN,
        IDS_ISDN_JAPAN_TITLE,
        IDS_ISDN_JAPAN_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_EAZ,
        IDS_ISDN_EAZ_TITLE,
        IDS_ISDN_EAZ_SUBTITLE,
        IsdnInfoPageProc},
    {IDW_ISDN_MSN,
        IDS_ISDN_MSN_TITLE,
        IDS_ISDN_MSN_SUBTITLE,
        IsdnInfoPageProc},
};

static const INT c_cPages = celems(c_aPages);

//+---------------------------------------------------------------------------
//
//  Function:   HrCreateIsdnWizardPages
//
//  Purpose:    Creates the various pages for the ISDN wizard
//
//  Arguments:
//      hwndParent [in]     Parent window
//      pisdnci    [in]     Configuration information as read from the
//                          registry
//
//  Returns:    S_OK if success, Win32 error code otherwise
//
//  Author:     danielwe   11 Mar 1998
//
//  Notes:
//
HRESULT HrAddIsdnWizardPagesToDevice(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                     PISDN_CONFIG_INFO pisdnci)
{
    HRESULT             hr = S_OK;
    PROPSHEETPAGE       psp = {0};
    HINSTANCE           hInst = _Module.GetResourceInstance();
    INT                 iPage;

    AssertSz(pisdnci, "HrCreateIsdnWizardPages - the CONFIG_INFO struct is"
             " NULL");
    AssertSz(pisdnci->dwWanEndpoints, "No WanEndpoints? What does this adapter"
             " DO, anyway?");
    AssertSz(pisdnci->dwNumDChannels, "No D Channels. No Shoes. No Service");
    AssertSz(pisdnci->dwSwitchTypes, "Switch types was NULL. We need a list"
             ", eh?");


    SP_NEWDEVICEWIZARD_DATA ndwd;

    hr = HrSetupDiGetFixedSizeClassInstallParams(hdi, pdeid,
            reinterpret_cast<PSP_CLASSINSTALL_HEADER>(&ndwd), sizeof(ndwd));

    if (SUCCEEDED(hr))
    {
        PWSTR       pszTitle = NULL;
        PWSTR       pszDesc = NULL;

        hr = HrSetupDiGetDeviceName(hdi, pdeid, &pszDesc);
        if (SUCCEEDED(hr))
        {
            DwFormatStringWithLocalAlloc(SzLoadIds(IDS_ISDN_WIZARD_TITLE),
                                         &pszTitle, pszDesc);

            for (iPage = 0; iPage < c_cPages; iPage++)
            {
                PAGE_DATA *     pPageData;

                pPageData = new PAGE_DATA;

				if (pPageData == NULL)
				{
					return(ERROR_NOT_ENOUGH_MEMORY);
				}

                pPageData->pisdnci = pisdnci;
                pPageData->idd = c_aPages[iPage].uiResId;

                // Fill in the propsheet page data
                //
                FillInIsdnWizardPropertyPage(hInst, &psp,
                                             c_aPages[iPage].uiResId,
                                             pszTitle,
                                             c_aPages[iPage].pfnDlgProc,
                                             SzLoadIds(c_aPages[iPage].idsPageTitle),
                                             SzLoadIds(c_aPages[iPage].idsPageDesc),
                                             pPageData);

                // The last page gets the job of cleaning up
                if ((c_cPages - 1) == iPage)
                {
                    psp.dwFlags |= PSP_USECALLBACK;
                    psp.pfnCallback = DestroyWizardData;
                }

                AddWizardPage(&psp, &ndwd);
            }

            LocalFree(pszTitle);
            MemFree(pszDesc);
        }

        hr = HrSetupDiSetClassInstallParams(hdi, pdeid,
                reinterpret_cast<PSP_CLASSINSTALL_HEADER>(&ndwd),
                sizeof(ndwd));
    }

    TraceError("HrAddIsdnWizardPagesToDevice", hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdncfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N C F G . H
//
//  Contents:   ISDN Wizard/PropertySheet configuration structures
//
//  Notes:
//
//  Author:     jeffspr   14 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once

#include "ncsetup.h"
#include <ras.h>

// ISDN Switch type flags
const DWORD ISDN_SWITCH_NONE    = 0x00000000;
const DWORD ISDN_SWITCH_AUTO    = 0x00000001;
const DWORD ISDN_SWITCH_ATT     = 0x00000002;
const DWORD ISDN_SWITCH_NI1     = 0x00000004;
const DWORD ISDN_SWITCH_NTI     = 0x00000008;
const DWORD ISDN_SWITCH_INS64   = 0x00000010;
const DWORD ISDN_SWITCH_1TR6    = 0x00000020;
const DWORD ISDN_SWITCH_VN3     = 0x00000040;
const DWORD ISDN_SWITCH_NET3    = 0x00000080; // retained for backward compatibility
const DWORD ISDN_SWITCH_DSS1    = 0x00000080;
const DWORD ISDN_SWITCH_AUS     = 0x00000100;
const DWORD ISDN_SWITCH_BEL     = 0x00000200;
const DWORD ISDN_SWITCH_VN4     = 0x00000400;
const DWORD ISDN_SWITCH_NI2     = 0x00000800;
const DWORD ISDN_SWITCH_SWE     = 0x00001000;
const DWORD ISDN_SWITCH_ITA     = 0x00002000;
const DWORD ISDN_SWITCH_TWN     = 0x00004000;

//---[ Structures for ISDN Config info ]--------------------------------------

// Configuration structure for an ISDN B Channel
//
struct _ISDNBChannel
{
    WCHAR   szSpid[RAS_MaxPhoneNumber + 1];
    WCHAR   szPhoneNumber[RAS_MaxPhoneNumber + 1];
    WCHAR   szSubaddress[RAS_MaxPhoneNumber + 1];
};

typedef struct _ISDNBChannel    ISDN_B_CHANNEL;
typedef struct _ISDNBChannel *  PISDN_B_CHANNEL;

// Configuration structure for an ISDN D Channel. Can contain multiple
// B Channel structures
//
struct _ISDNDChannel
{
    DWORD           dwNumBChannels;
    PWSTR          mszMsnNumbers;
    PISDN_B_CHANNEL pBChannel;
};

typedef struct _ISDNDChannel    ISDN_D_CHANNEL;
typedef struct _ISDNDChannel *  PISDN_D_CHANNEL;

// Overall configuration for an ISDN adapter. Can contain multiple
// D Channel structures
//
struct _ISDNConfigInfo
{
    DWORD           dwWanEndpoints;
    DWORD           dwNumDChannels;
    DWORD           dwSwitchTypes;
    DWORD           dwCurSwitchType;
    INT             nOldDChannel;
    INT             nOldBChannel;
    BOOL            fIsPri;             // TRUE if this is a PRI adapter
    BOOL            fSkipToEnd;         // TRUE if we should skip the rest
                                        // of the wizard pages
    UINT            idd;                // Dialog resource ID of wizard page
                                        // we used
    PISDN_D_CHANNEL pDChannel;
    HDEVINFO        hdi;
    PSP_DEVINFO_DATA pdeid;
};

typedef struct _ISDNConfigInfo      ISDN_CONFIG_INFO;
typedef struct _ISDNConfigInfo *    PISDN_CONFIG_INFO;

//---[ Prototypes ]-----------------------------------------------------------

// Read the ISDN registry structure into the config info
//
HRESULT
HrReadIsdnPropertiesInfo(HKEY hkeyISDNBase, HDEVINFO hdi,
                         PSP_DEVINFO_DATA pdeid,
                         PISDN_CONFIG_INFO * ppISDNConfig);

// Write the ISDN config info back into the registry
//
HRESULT
HrWriteIsdnPropertiesInfo(HKEY hkeyISDNBase,
                          PISDN_CONFIG_INFO pISDNConfig);

// Free the structure allocated by HrReadISDNPropertiesInfo
//
VOID
FreeIsdnPropertiesInfo( PISDN_CONFIG_INFO   pISDNConfig);

BOOL
FAdapterIsIsdn(HKEY hkeyDriver);
BOOL
FShowIsdnPages(HKEY hkey);

// Set the next, back and cancel buttons depending if we are in GUI setup mode or stand-alone
//
VOID 
SetWizardButtons(HWND hWnd, BOOLEAN bFirstPage, PISDN_CONFIG_INFO pISDNConfig);

const DWORD c_cchMaxDChannelName = 3;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\isdnwiz.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       I S D N W I Z . H
//
//  Contents:   Prototypes for the ISDN Wizard functionality
//
//  Notes:
//
//  Author:     jeffspr   15 Jun 1997
//
//----------------------------------------------------------------------------

#pragma once
#ifndef _ISDNWIZ_H_
#define _ISDNWIZ_H_

HRESULT HrAddIsdnWizardPagesToDevice(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                                     PISDN_CONFIG_INFO pisdnci );

#endif  // _ISDNWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\msclidlg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I D L G . H
//
//  Contents:   Dialog box handling for the MSCLient object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#ifndef _MSCLIDLG_H
#define _MSCLIDLG_H
#pragma once
#include "mscliobj.h"

//
// RPC Configuration Dialog
//
class CRPCConfigDlg: public CPropSheetPage
{
public:
    BEGIN_MSG_MAP(CRPCConfigDlg)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        MESSAGE_HANDLER(WM_HELP, OnHelp);
        COMMAND_CODE_HANDLER(CBN_SELCHANGE, OnChange)
        COMMAND_CODE_HANDLER(EN_CHANGE, OnChange)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnOk)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
    END_MSG_MAP()

    CRPCConfigDlg(CMSClient *pmsc): m_pmsc(pmsc), m_isel(-1) {};
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                        LPARAM lParam, BOOL& bHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& Handled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                      LPARAM lParam, BOOL& bHandled);
    LRESULT OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);
    LRESULT OnChange(WORD wNotifyCode, WORD wID,
                    HWND hWndCtl, BOOL& bHandled)
    {
       SetState();
       SetChangedFlag();
       return 0;
    };

private:
    HRESULT HrGetDCEProvider(VOID);
    HRESULT HrOpenRegKeys(VOID);
    HRESULT HrValidateRpcData(VOID);
    VOID SetState(VOID);

    INT         m_isel;
    CMSClient * m_pmsc;
};

BOOL FIsValidDomainName(PCWSTR szName);

#endif //!_MSCLIDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\msclidlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I D L G . C P P
//
//  Contents:   Dialog box handling for the MSCLient object.
//
//  Notes:
//
//  Author:     danielwe   28 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "msclidlg.h"

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetupPropSheets
//
//  Purpose:    Inits the prop sheet page objects and creates the pages to be
//              returned to the installer object.
//
//  Arguments:
//      pahpsp [out]    Array of handles to property sheet pages.
//      cPages [in]     Number of pages to create.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages)
{
    HRESULT         hr = S_OK;
    HPROPSHEETPAGE *ahpsp = NULL;

    Assert(pahpsp);

    *pahpsp = NULL;

    // Allocate a buffer large enough to hold the handles to all of our
    // property pages.
    ahpsp = (HPROPSHEETPAGE *)CoTaskMemAlloc(sizeof(HPROPSHEETPAGE)
                                             * cPages);
    if (!ahpsp)
    {
        hr = E_OUTOFMEMORY;
        goto err;
    }

    if (!m_apspObj[0])
    {
        // Allocate each of the CPropSheetPage objects
        m_apspObj[0] = new CRPCConfigDlg(this);
    }
#ifdef DBG
    else
    {
        // Don't bother creating new classes if they already exist.
        AssertSz(m_apspObj[0], "Not all prop page objects are non-NULL!");

    }
#endif

    // Create the actual PROPSHEETPAGE for each object.
    // This needs to be done regardless of whether the classes existed before.
    ahpsp[0] = m_apspObj[0]->CreatePage(DLG_RPCConfig, 0);

    Assert(SUCCEEDED(hr));

    *pahpsp = ahpsp;

cleanup:
    TraceError("HrSetupPropSheets", hr);
    return hr;

err:
    CoTaskMemFree(ahpsp);
    goto cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::CleanupPropPages
//
//  Purpose:    Loop thru each of the pages and free the objects associated
//              with them.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   28 Feb 1997
//
//  Notes:
//
VOID CMSClient::CleanupPropPages()
{
    INT     ipage;

    for (ipage = 0; ipage < c_cPages; ipage++)
    {
        delete m_apspObj[ipage];
        m_apspObj[ipage] = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\msclihlp.h ===
//This file is used by msclicfg.rc
//
// Generated by Melissa Simmons, 4-6-99

#define IDH_CMB_NameService 80000000
#define IDH_EDT_NetAddress 80000001
#define IDH_DISABLEHELP ((DWORD)-1)



const DWORD g_aHelpIDs_DLG_RPCConfig[]=
{
	IDC_STATIC, IDH_DISABLEHELP,
	CMB_NameService,IDH_CMB_NameService,
	IDC_TXT_NetAddress, IDH_EDT_NetAddress,
	EDT_NetAddress,IDH_EDT_NetAddress,
	0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\browsdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       B R O W S D L G . C P P
//
//  Contents:   Dialog box handling for Browser configuration.
//
//  Notes:
//
//  Author:     danielwe   3 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include <lm.h>
#include <icanon.h>

#include "mscliobj.h"
#include "ncreg.h"
#include "ncui.h"

static const WCHAR c_szWksParams[] = L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\Parameters";
static const WCHAR c_szBrowserParams[] = L"System\\CurrentControlSet\\Services\\Browser\\Parameters";
static const WCHAR c_szOtherDomains[] = L"OtherDomains";

//+---------------------------------------------------------------------------
//
//  Function:   FIsValidDomainName
//
//  Purpose:    Returns TRUE if the given domain name is a valid NetBIOS name.
//
//  Arguments:
//      pszName [in]     Domain name to validate
//
//  Returns:    TRUE if the name is valid, FALSE otherwise.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:      $REVIEW (danielwe): Use new netsetup function instead?
//
BOOL FIsValidDomainName(PCWSTR pszName)
{
    NET_API_STATUS  nerr;

    // Make sure the given name is a valid domain name
    nerr = NetpNameValidate(NULL, const_cast<PWSTR>(pszName),
                            NAMETYPE_DOMAIN, 0L);

    return !!(NERR_Success == nerr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrGetBrowserRegistryInfo
//
//  Purpose:    Read data from the registry into an in-memory copy.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrGetBrowserRegistryInfo()
{
    HRESULT     hr = S_OK;
    HKEY        hkeyWksParams = NULL;

    Assert(!m_szDomainList);

    // Open LanmanWorkstation Parameters key
    hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWksParams,
                        KEY_READ, &hkeyWksParams);
    if (FAILED(hr))
    {
        if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
        {
            // Optional value. Ok if not there.
            hr = S_OK;
        }
        else
        {
            goto err;
        }
    }

    if (hkeyWksParams)
    {
        hr = HrRegQueryMultiSzWithAlloc(hkeyWksParams, c_szOtherDomains,
                                        &m_szDomainList);
        if (FAILED(hr))
        {
            if (hr == HRESULT_FROM_WIN32 (ERROR_FILE_NOT_FOUND))
            {
                AssertSz(!m_szDomainList, "Call failed, so why is this not "
                         "still NULL?");
                // No problem if value is not there.
                hr = S_OK;
            }
            else
            {
                goto err;
            }
        }
    }

    Assert(SUCCEEDED(hr));

    // If we didn't get a domain list yet, make a new default one.
    if (!m_szDomainList)
    {
        // Allocate space for empty string
        m_szDomainList = new WCHAR[1];

		if (m_szDomainList != NULL)
		{
            *m_szDomainList = 0;
		}
    }

err:
    RegSafeCloseKey(hkeyWksParams);
    TraceError("CMSClient::HrGetBrowserRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetBrowserRegistryInfo
//
//  Purpose:    Write what we have saved in memory into the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetBrowserRegistryInfo()
{
    HRESULT     hr = S_OK;

    if (m_fBrowserChanges)
    {
        HKEY    hkeyBrowserParams = NULL;

        // Verify that the Browser Parameters key exists. If not, we can't
        // continue.
        hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szBrowserParams,
                            KEY_ALL_ACCESS, &hkeyBrowserParams);
        if (SUCCEEDED(hr))
        {
            HKEY    hkeyWksParams = NULL;

            // Open LanmanWorkstation Parameters key
            hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szWksParams,
                                KEY_ALL_ACCESS, &hkeyWksParams);
            if (SUCCEEDED(hr))
            {
                hr = HrRegSetMultiSz(hkeyWksParams, c_szOtherDomains,
                                     m_szDomainList);
                RegSafeCloseKey(hkeyWksParams);
            }
            RegSafeCloseKey(hkeyBrowserParams);
        }
    }

    TraceError("CMSClient::HrSetBrowserRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::SetBrowserDomainList
//
//  Purpose:    Replace the current domain list with a new copy (obtained from
//              the dialog).
//
//  Arguments:
//      pszNewList [in]  New domain list in MULTI_SZ format.
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
VOID CMSClient::SetBrowserDomainList(PWSTR pszNewList)
{
    delete [] m_szDomainList;
    m_szDomainList = pszNewList;
    m_fBrowserChanges = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\mscapply.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C A P P L Y . C P P
//
//  Contents:   Functions called when MSClient is applied.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "ncnetcfg.h"
#include "mscliobj.h"
#include "ncmisc.h"
#include "ncsvc.h"

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrApplyChanges
//
//  Purpose:    Writes out changes that occurred during the lifetime of our
//              object.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   25 Feb 1997
//
//  Notes:      This will do several things.
//              1) Set info for the RPC nameservice and security service that
//                 was indicated by the UI for the RPC config dialog.
//              2) Set the parameters for the browser configuration to the
//                 registry.
//
//              If no changes were detected, this will do nothing.
//
HRESULT CMSClient::HrApplyChanges()
{
    HRESULT hr;

    // Write out any changes to RPC info
    hr = HrSetRPCRegistryInfo();
    if (SUCCEEDED(hr))
    {
        // Write out any changes to Browser info
        hr = HrSetBrowserRegistryInfo();
    }

    if (SUCCEEDED(hr) && (m_fOneTimeInstall || m_fUpgradeFromWks))
    {
        // Note: This function will do the workstation/server detection,
        // and won't install if we're running the workstation build.
        //
        hr = HrInstallDfs();
    }

    TraceError("CMSClient::HrApplyChanges", hr);
    return hr;
}

static const CHAR   c_szaDfsCheck[]     = "DfsCheckForOldDfsService";
static const CHAR   c_szaDfsSetupDfs[]  = "DfsSetupDfs";
static const WCHAR  c_szDfsSetupDll[]   = L"dfssetup.dll";

typedef BOOLEAN (APIENTRY *PDFSCHECKFOROLDDFSSERVICE)(void);
typedef DWORD (APIENTRY *PDFSSETUPDFS)(DWORD, PSTR, PSTR *);

//+---------------------------------------------------------------------------
//
//  Function:   HrInstallDfs
//
//  Purpose:    Take care of installation of DFS components
//
//  Arguments:
//      (none)
//
//  Returns:    Win32 HRESULT if failure.
//
//  Author:     danielwe   23 Jul 1997
//
//  Notes:      Shortcut creation is handled by this function and not
//              the netmscli.inf file because it is conditional on whether
//              the DFS components are installed.
//
HRESULT HrInstallDfs()
{
    HRESULT         hr = S_OK;
    PRODUCT_FLAVOR  pf;                     // Server/Workstation

    // Get the product flavor (PF_WORKSTATION or PF_SERVER). Use this
    // to decide whether or not we need to install DFS.
    //
    GetProductFlavor(NULL, &pf);
    if (PF_SERVER == pf)
    {
        PDFSCHECKFOROLDDFSSERVICE pfnDfsCheckForOldDfsService = NULL;
        HMODULE     hMod = NULL;

        TraceTag(ttidMSCliCfg, "Attempting to install DFS, since we're in a "
                 "server install");

        hr = HrLoadLibAndGetProc(c_szDfsSetupDll, c_szaDfsCheck, &hMod,
                                 reinterpret_cast<FARPROC *>(&pfnDfsCheckForOldDfsService));
        if (SUCCEEDED(hr))
        {
            AssertSz(hMod, "Module handle cannot be NULL!");
            BOOL fDFSInstalled = pfnDfsCheckForOldDfsService();

            // If DFS is not installed, go ahead and install it now.
            if (!fDFSInstalled)
            {
                PDFSSETUPDFS    pfnDfsSetupDfs = NULL;
                hr = HrGetProcAddress(hMod, c_szaDfsSetupDfs,
                                      reinterpret_cast<FARPROC *>(&pfnDfsSetupDfs));
                if (SUCCEEDED(hr))
                {
                    PSTR   szResult = NULL;

                    if (!pfnDfsSetupDfs(0, NULL, &szResult))
                    {
                        // DFS setup failed!

                        hr = HRESULT_FROM_WIN32(ERROR_INTERNAL_ERROR);
                        TraceError("HrInstallDfs - pfnDfsSetupDfs", hr);
                    }
                }
            }

            FreeLibrary(hMod);
        }
    }
    else
    {
        TraceTag(ttidMSCliCfg, "Not attempting to install DFS, since we're in a "
                 "workstation install");
    }

    TraceError("HrInstallDfs", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrEnableBrowserService
//
//  Purpose:    Enables the 'Browser' service
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error if not
//
//  Author:     danielwe   9 Sep 1998
//
//  Notes:
//
HRESULT HrEnableBrowserService()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, L"Browser");
    if (SUCCEEDED(hr))
    {
        DWORD       dwStartType;

        hr = srv.HrQueryStartType(&dwStartType);
        if (SUCCEEDED(hr) && (dwStartType != SERVICE_DISABLED))
        {
            // Change the Browser StartType registry setting back to auto start
            hr = srv.HrSetStartType(SERVICE_AUTO_START);
        }
    }

    TraceError("HrEnableBrowserService",hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Function:   HrDisableBrowserService
//
//  Purpose:    Disables the 'Browser' service
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error if not
//
//  Author:     danielwe   9 Sep 1998
//
//  Notes:
//
HRESULT HrDisableBrowserService()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, L"Browser");
    if (SUCCEEDED(hr))
    {
        DWORD       dwStartType;

        hr = srv.HrQueryStartType(&dwStartType);
        if (SUCCEEDED(hr) && (dwStartType != SERVICE_DISABLED))
        {
            // Change the Browser StartType registry setting to demand start
            hr = srv.HrSetStartType(SERVICE_DEMAND_START);
            if (SUCCEEDED(hr))
            {
                hr = sm.HrStopServiceNoWait(L"Browser");
            }
        }
    }

    TraceError("CNbfObj::HrDisableNetBEUI",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\isdncfg\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by isdncfg.rc
//
#define IDS_ISDN_WIZARD_TITLE           1
#define IDS_ISDN_SPIDS_TITLE            2
#define IDS_ISDN_SPIDS_SUBTITLE         3
#define IDS_ISDN_JAPAN_TITLE            4
#define IDS_ISDN_JAPAN_SUBTITLE         5
#define IDS_ISDN_MSN_TITLE              6
#define IDS_ISDN_MSN_SUBTITLE           7
#define IDS_ISDN_EAZ_TITLE              8
#define IDS_ISDN_EAZ_SUBTITLE           9
#define IDS_ISDN_SWITCH_TYPE_TITLE      10
#define IDS_ISDN_SWITCH_TYPE_SUBTITLE   11
#define IDS_ISDN_SWITCH_AUTO            12
#define IDS_ISDN_SWITCH_ATT             13
#define IDS_ISDN_SWITCH_NI1             14
#define IDS_ISDN_SWITCH_NTI             15
#define IDS_ISDN_SWITCH_INS64           16
#define IDS_ISDN_SWITCH_1TR6            17
#define IDS_ISDN_SWITCH_VN3             18
#define IDS_ISDN_SWITCH_DSS1            19
#define IDS_ISDN_SWITCH_AUS             20
#define IDS_ISDN_SWITCH_BEL             21
#define IDS_ISDN_SWITCH_UNKNOWN         22
#define IDS_ISDN_SWITCH_NI2             23
#define IDS_ISDN_SWITCH_VN4             24
#define IDS_ISDN_SWITCH_SWE             25
#define IDS_ISDN_SWITCH_ITA             26
#define IDS_ISDN_SWITCH_TWN             27
#define IDS_ISDN_WHATS_THIS             28
#define IDC_CMB_SwitchType              1000
#define IDC_EDIT1                       1001
#define IDC_EDT_MSN                     1001
#define IDC_BUTTON1                     1002
#define IDC_PSB_ADD                     1002
#define IDC_BUTTON2                     1003
#define IDC_PSB_REMOVE                  1003
#define IDC_LBX_Line                    1005
#define IDC_EDT_PhoneNumber             1008
#define IDC_LBX_Variant                 1010
#define IDC_PSB_Configure               1011
#define IDC_LBX_MSN                     1014
#define IDD_ISDN_SPIDS                  1407
#define IDC_LBX_CHANNEL                 14101
#define IDC_LBX_CHANNEL2                14102
#define IDC_EDT_SPID                    14103
#define IDC_EDT_PHONE_NUMBER            14105
#define IDC_EDT_PHONE_NUMBER2           14106
#define IDC_EDT_SubAddress              14106
#define IDW_ISDN_SPIDS                  14112
#define IDW_ISDN_JAPAN                  14113
#define IDW_ISDN_MSN                    14114
#define IDW_ISDN_EAZ                    14115
#define IDP_ISDN_SWITCH_TYPE            14116
#define IDD_ISDN_EAZ                    14117
#define IDD_ISDN_JAPAN                  14118
#define IDD_ISDN_MSN                    14119
#define IDW_ISDN_SWITCH_TYPE            14120
#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        105
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1015
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\mscliobj.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997-1999.
//
//  File:       M S C L I O B J . C P P
//
//  Contents:   Implementation of the CMSClient notify object model
//
//  Notes:
//
//  Author:     danielwe   22 Feb 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include <ncsvc.h>
#include "mscliobj.h"
#include "nb30.h"
#include "ncerror.h"
#include "ncperms.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncsvc.h"
#include <ntsecapi.h>
#include <lm.h>

static const WCHAR c_szBrowseDomains[] = L"BrowseDomains";
static const WCHAR c_szNameServiceNetAddr[] = L"NameServiceNetworkAddress";
static const WCHAR c_szNameServiceProt[] = L"NameServiceProtocol";

extern const WCHAR c_szInfId_MS_NetBIOS[];
extern const WCHAR c_szInfId_MS_Server[];


// Defined in rpcdlg.cpp
extern const WCHAR c_szDefNetAddr[];
extern const WCHAR c_szProtWinNT[];

// Registry paths
static const WCHAR c_szRegKeyBrowser[]      = L"System\\CurrentControlSet\\Services\\Browser\\Parameters";
static const WCHAR c_szRegKeyNetLogon[]     = L"System\\CurrentControlSet\\Services\\NetLogon\\Parameters";

// Answer file constants
static const WCHAR c_szNetLogonParams[]     = L"NetLogon.Parameters";
static const WCHAR c_szBrowserParams[]      = L"Browser.Parameters";

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::CMSClient
//
//  Purpose:    Constructs the CMSClient object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
CMSClient::CMSClient()
:   m_pncc(NULL),
    m_pnc(NULL),
    m_fBrowserChanges(FALSE),
    m_fRPCChanges(FALSE),
    m_fOneTimeInstall(FALSE),
    m_fUpgrade(FALSE),
    m_fRemoving(FALSE),
    m_hkeyRPCName(NULL),
    m_eSrvState(eSrvNone),
    m_fUpgradeFromWks(FALSE),
    m_szDomainList(NULL)
{
    ZeroMemory(&m_rpcData, sizeof(RPC_CONFIG_DATA));
    ZeroMemory(&m_apspObj, sizeof(m_apspObj));
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::~CMSClient
//
//  Purpose:    Destructs the CMSClient object.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
CMSClient::~CMSClient()
{
    ReleaseObj(m_pncc);
    ReleaseObj(m_pnc);

    RegSafeCloseKey(m_hkeyRPCName);

    m_rpcData.strProt.erase();
    m_rpcData.strNetAddr.erase();
    m_rpcData.strEndPoint.erase();

    CleanupPropPages();

#ifdef DBG
        {
            INT     ipage;

            for (ipage = 0; ipage < c_cPages; ipage++)
            {
                AssertSz(!m_apspObj[ipage], "Prop page object not cleaned up!");
            }
        }

#endif

    delete [] m_szDomainList;
}

//
// INetCfgComponentControl
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Initialize
//
//  Purpose:    Initializes the notify object.
//
//  Arguments:
//      pnccItem    [in]    INetCfgComponent that we are handling
//                          notifications for.
//      pnc         [in]    INetCfg master object.
//      fInstalling [in]    TRUE if we are being installed, FALSE if not.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Initialize(INetCfgComponent *pnccItem, INetCfg *pnc,
                                   BOOL fInstalling)
{
    HRESULT             hr = S_OK;
    INetCfgComponent *  pnccServer = NULL;

    Validate_INetCfgNotify_Initialize(pnccItem, pnc, fInstalling);

    m_pncc = pnccItem;
    m_pnc = pnc;

    AssertSz(m_pncc, "Component object is NULL!");
    AssertSz(m_pnc, "INetCfg object is NULL!");

    // We're hanging on to these, so AddRef 'em.
    AddRefObj(m_pncc);
    AddRefObj(m_pnc);

    // Check to see if MS_SERVER is installed. If not, set the browser service
    // to be disabled.
    //
    hr = m_pnc->FindComponent(c_szInfId_MS_Server, &pnccServer);
    if (S_FALSE == hr)
    {
        // Server component is not present. Set browser to be disabled on
        // apply
        m_eSrvState = eSrvDisable;
    }
    else if (S_OK == hr)
    {
        ReleaseObj(pnccServer);
    }

    if (SUCCEEDED(hr))
    {
        // Read in data for the RPC config dialog from the registry
        hr = HrGetRPCRegistryInfo();
        if (SUCCEEDED(hr))
        {
            // Read in data for the browser config dialog from the registry
            hr = HrGetBrowserRegistryInfo();
        }
    }

    Validate_INetCfgNotify_Initialize_Return(hr);

    TraceError("CMSClient::Initialize", hr);
    return hr;
}

STDMETHODIMP CMSClient::Validate()
{
    return S_OK;
}

STDMETHODIMP CMSClient::CancelChanges()
{
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::ApplyRegistryChanges
//
//  Purpose:    Called when changes to this component should be applied.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if successful, S_FALSE if no changes occurred,
//              NETCFG_S_REBOOT if a reboot is required, otherwise a NETCFG_E
//              error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::ApplyRegistryChanges()
{
    TraceFileFunc(ttidMSCliCfg);
    HRESULT     hr = S_OK;

    if (m_fUpgrade)
    {
        m_fUpgrade = FALSE;

        hr = HrRestoreRegistry();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrRestoreRegistry - non-fatal",
                       hr);
            hr = S_OK;
        }
    }

    // Do we need to enable or disable the browser service??
    //
    switch (m_eSrvState)
    {
    case eSrvEnable:
        TraceTag(ttidMSCliCfg, "Enabling the Browser service...");
        hr = HrEnableBrowserService();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrEnableBrowserService failed."
                       " non-fatal.", hr);
            hr = S_OK;
        }
        break;

    case eSrvDisable:
        TraceTag(ttidMSCliCfg, "Disabling the Browser service...");
        hr = HrDisableBrowserService();
        if (FAILED(hr))
        {
            TraceError("CMSClient::ApplyRegistryChanges - HrDisableBrowserService failed."
                       " non-fatal.", hr);
            hr = S_OK;
        }
        break;
    }

    if (m_fRPCChanges || m_fBrowserChanges ||
        m_fOneTimeInstall || m_fUpgradeFromWks)
    {
        hr = HrApplyChanges();
        if (SUCCEEDED(hr))
        {
            m_fRPCChanges = FALSE;
            m_fBrowserChanges = FALSE;
            m_fOneTimeInstall = FALSE;

            // Make NetLogon dependend on LanmanServer for Domain Controllers, and Automatic start for Domain Members
            hr = HrSetNetLogonDependencies();
        }
    }
    else
    {
        // No relevant changes were detected (netbios changes do not affect
        // netcfg so we can return S_FALSE even if things changed
        hr = S_FALSE;
    }

    Validate_INetCfgNotify_Apply_Return(hr);

    TraceError("CMSClient::ApplyRegistryChanges", (hr == S_FALSE) ? S_OK : hr);
    return hr;
}

STDMETHODIMP
CMSClient::ApplyPnpChanges (
    IN INetCfgPnpReconfigCallback* pICallback)
{
    HRESULT hr;

    hr = S_OK;

    if (m_fRemoving)
    {
        // Make sure Mrxsmb and Rdbss have been removed.  (They are stopped
        // when LanmanWorkstation stops, but the binding engine has no idea
        // that Mrxsmb and Rdbss are part of this component.  Hence, the
        // status of the DeleteService that is performed as part of the INF
        // is not communicated back out.)  We make sure that these services
        // do not exist here, and if they do, we report that we need a
        // reboot.
        //
        CServiceManager scm;
        CService svc;

        TraceTag(ttidMSCliCfg, "Checking to see that Mrxsmb and Rdbss "
            "are stopped and removed");

        hr = scm.HrOpenService (&svc, L"Mrxsmb",
                    NO_LOCK, SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

        if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
        {
            TraceHr(ttidMSCliCfg, FAL, hr, FALSE, "OpenService(MrxSmb)");
            TraceTag(ttidMSCliCfg, "Mrxsmb still exists");
            hr = NETCFG_S_REBOOT;
        }
        else
        {
            // Mrxsmb does not exist.  Now check Rdbss.
            //
            hr = scm.HrOpenService (&svc, L"Rdbss",
                        NO_LOCK, SC_MANAGER_CONNECT, SERVICE_QUERY_STATUS);

            if (HRESULT_FROM_WIN32(ERROR_SERVICE_DOES_NOT_EXIST) != hr)
            {
                TraceHr(ttidMSCliCfg, FAL, hr, FALSE, "OpenService(Rdbss)");
                TraceTag(ttidMSCliCfg, "Rdbss still exists");
                hr = NETCFG_S_REBOOT;
            }
            else
            {
                // Rdbss does not exist.  This is good.
                //
                hr = S_OK;
            }
        }
    }

    return hr;
}

//
// INetCfgComponentSetup
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Install
//
//  Purpose:    Called when this component is being installed
//
//  Arguments:
//      dwSetupFlags [in] Flags that describe the type of setup
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Install(DWORD dwSetupFlags)
{
    HRESULT hr;

    Validate_INetCfgNotify_Install (dwSetupFlags);

    m_fRPCChanges = TRUE;
    m_fBrowserChanges = TRUE;
    m_fOneTimeInstall = TRUE;

    if ((NSF_WINNT_WKS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SBS_UPGRADE & dwSetupFlags) ||
        (NSF_WINNT_SVR_UPGRADE & dwSetupFlags))
    {
        m_fUpgrade = TRUE;
    }

    // Install the NetBIOS sub-component
    hr = HrInstallComponentOboComponent(m_pnc, NULL,
            GUID_DEVCLASS_NETSERVICE,
            c_szInfId_MS_NetBIOS,
            m_pncc,
            NULL);

    TraceError("CMSClient::Install", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Upgrade
//
//  Purpose:    Called when this component is upgraded
//
//  Arguments:
//      dwSetupFlags        [in] Flags describing setup
//      dwUpgradeFomBuildNo [in] Build number from which we are upgrading
//
//  Returns:    S_OK if success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Upgrade(DWORD dwSetupFlags,
                                DWORD dwUpgradeFomBuildNo)
{
    if (dwSetupFlags & NSF_WINNT_WKS_UPGRADE)
    {
        TraceTag(ttidMSCliCfg, "Upgrading from workstation...");
        m_fUpgradeFromWks = TRUE;
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::ReadAnswerFile
//
//  Purpose:    Reads the appropriate fields from the given answer file into
//              our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in] File name of answer file
//      pszAnswerSection   [in] Section of answer file to look in
//
//  Returns:    S_OK if successful, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:      IMPORTANT: During install or upgrade, this MUST be called
//              *before* Upgrade() or Install()! (see bug #100995)
//
STDMETHODIMP CMSClient::ReadAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT     hr = S_OK;

    if (pszAnswerSection && pszAnswerFile)
    {
        // There's an answer file. We must process it now.
        hr = HrProcessAnswerFile(pszAnswerFile, pszAnswerSection);
        if (FAILED(hr))
        {
            TraceError("CMSClient::ReadAnswerFile- Answer file has "
                       "errors. Defaulting all information as if "
                       "answer file did not exist.",
                       NETSETUP_E_ANS_FILE_ERROR);
            hr = S_OK;
        }
    }

    TraceError("CMSClient::ReadAnswerFile", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::Removing
//
//  Purpose:    Called whent this component is being removed
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK of success, OLE or Win32 error otherwise
//
//  Author:     danielwe   30 Oct 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::Removing()
{
    m_fRemoving = TRUE;

    // Remove the NetBIOS service. This doesn't actually remove the
    // component, it simply marks it as needing to be removed, and in
    // Apply() it will be fully removed.
    HRESULT hr = HrRemoveComponentOboComponent(m_pnc,
                                       GUID_DEVCLASS_NETSERVICE,
                                       c_szInfId_MS_NetBIOS,
                                       m_pncc);

    TraceError("CMSClient::Removing", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrRestoreRegistry
//
//  Purpose:    Restores the registry settings for various services on upgrade
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK if success, WIN32 error otherwise
//
//  Author:     danielwe   8 Aug 1997
//
//  Notes:
//
HRESULT CMSClient::HrRestoreRegistry()
{
    HRESULT             hr = S_OK;
    HKEY                hkey;
    TOKEN_PRIVILEGES *  ptpRestore = NULL;
    static const WCHAR c_szSvcDLLName[]     = L"%SystemRoot%\\System32\\browser.dll";
    static const WCHAR c_szServiceDll[]     = L"ServiceDll";

    if (!m_strBrowserParamsRestoreFile.empty() ||
        !m_strNetLogonParamsRestoreFile.empty())
    {
        hr = HrEnableAllPrivileges(&ptpRestore);
        if (SUCCEEDED(hr))
        {
            if (!m_strBrowserParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyBrowser,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey,
                                         m_strBrowserParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - "
                                   "HrRestoreRegistry for Browser Parameters",
                                   hr);
                        hr = S_OK;
                    }

                    hr = HrRegSetValueEx(hkey, c_szServiceDll, REG_EXPAND_SZ, (const BYTE *)c_szSvcDLLName, (wcslen(c_szSvcDLLName) + 1) * sizeof(TCHAR));
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - HrRestoreRegistry for "
                                "ServiceDll", hr);
                                hr = S_OK;
                    }
                    RegSafeCloseKey(hkey);
                }
            }

            if (!m_strNetLogonParamsRestoreFile.empty())
            {
                hr = HrRegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegKeyNetLogon,
                                    KEY_ALL_ACCESS, &hkey);
                if (SUCCEEDED(hr))
                {
                    hr = HrRegRestoreKey(hkey,
                                         m_strNetLogonParamsRestoreFile.c_str(),
                                         0);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrRestoreRegistry - "
                                   "HrRestoreRegistry for NetLogon Parameters",
                                   hr);
                        hr = S_OK;
                    }
					
					//
					// The following key has to be set here because of new changes introduced
					// by SCE (Security Configuration Engine). SCE runs early in GUI mode setup to 
					// set out-of-the-box security by setting some registry values. During NT4 
					// upgrades we don't see those registry values set because during NT4 upgrades, 
					// some services including Lanmanserver and Netlogon gets deleted and reinstalled 
					// for PnP requirements. To maintain the services configuration between deleting 
					// and reinstalling, some of their Keys including the "Parameters" keys for 
					// LanManServer and Netlogon get backed up early during upgrade and restored 
					// later with the service installation. This backing up and restoring action 
					// happens through the services own notify objects (like this one). The problem 
					// is, backing up of the Keys happens before SCE sets the values in those keys and
					// they get restored after SCE sets the values. So we lose the values set. So, we 
					// are setting those keys here separately to the secure values.
					// See Windows Raid bug #691952 for more details.
					//

					static const WCHAR  c_szRequireSignOrSeal[]  = L"RequireSignOrSeal";
					DWORD				value = 1;

					hr = HrRegSetValueEx(hkey, c_szRequireSignOrSeal, REG_DWORD, (const BYTE *)&value, 4);

					if (FAILED(hr)) 
					{
						TraceError("CMSClicfg::HrRestoreRegistry - setting RequireSignOrSeal to DWORD 1 failed", hr);
						hr = S_OK;
					}

                    RegCloseKey(hkey);
                }
            }

            hr = HrRestorePrivileges(ptpRestore);

            delete [] reinterpret_cast<BYTE *>(ptpRestore);
        }
    }

    TraceError("CMSClient::HrRestoreRegistry", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrProcessAnswerFile
//
//  Purpose:    Processes the answer file. Any parameters that have been set
//              are read into our in-memory state.
//
//  Arguments:
//      pszAnswerFile     [in]     Filename of answer file.
//      pszAnswerSection [in]     Comma-separated list of sections in the
//                                  file appropriate to this component.
//
//  Returns:    S_OK if successful, NETCFG error code otherwise.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:      Errors returned from this function should be ignored so as to
//              prevent blocking the rest of network install.
//
HRESULT CMSClient::HrProcessAnswerFile(PCWSTR pszAnswerFile,
                                       PCWSTR pszAnswerSection)
{
    HRESULT         hr = S_OK;
    CSetupInfFile   csif;
    PWSTR           mszDomainList = NULL;

    AssertSz(pszAnswerFile, "Answer file string is NULL!");
    AssertSz(pszAnswerSection, "Answer file sections string is NULL!");

    // Open the answer file.
    hr = csif.HrOpen(pszAnswerFile, NULL, INF_STYLE_OLDNT | INF_STYLE_WIN4, NULL);
    if (FAILED(hr))
        goto err;

    if (m_fUpgrade)
    {
        // Restore portions of the registry based on file names from the answer
        // file

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szNetLogonParams,
                              &m_strNetLogonParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CMSClient::HrProcessAnswerFile - Error reading "
                       "NetLogon.Parameters from answer file", hr);

            // oh well, just continue
            hr = S_OK;
        }

        // Get restore file for "Parameters" key
        hr = csif.HrGetString(pszAnswerSection, c_szBrowserParams,
                              &m_strBrowserParamsRestoreFile);
        if (FAILED(hr))
        {
            TraceError("CMSClient::HrProcessAnswerFile - Error reading "
                       "Browser.Parameters from answer file", hr);

            // oh well, just continue
            hr = S_OK;
        }
    }

    // Get the BrowseDomains field.
    hr = HrSetupGetFirstMultiSzFieldWithAlloc(csif.Hinf(),
                                              pszAnswerSection,
                                              c_szBrowseDomains,
                                              &mszDomainList);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on BrowseDomains field. "
                   "Using default value", hr);
    }
    else
    {
        // Set the new domain list.
        SetBrowserDomainList(mszDomainList);
    }

    // Get the NameServiceNetworkAddress value
    hr = csif.HrGetString(pszAnswerSection,
                          c_szNameServiceNetAddr,
                          &m_rpcData.strNetAddr);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on NetworkAddress field. "
                   "Defaulting value", hr);
        m_rpcData.strNetAddr = c_szDefNetAddr;
    }
    else
    {
        m_fRPCChanges = TRUE;
    }

    // Get the NameServiceProtocol value.
    hr = csif.HrGetString(pszAnswerSection,
                          c_szNameServiceProt,
                          &m_rpcData.strProt);
    if (FAILED(hr))
    {
        // ignore line not found errors
        if (hr == HRESULT_FROM_SETUPAPI(ERROR_LINE_NOT_FOUND))
        {
            hr = S_OK;
        }

        TraceError("HrProcessAnswerFile - Error on NameServiceProtocol field. "
                   "Defaulting value", hr);
        m_rpcData.strProt = c_szProtWinNT;
    }
    else
    {
        m_fRPCChanges = TRUE;
    }

err:
    TraceError("CMSClient::HrProcessAnswerFile", hr);
    return hr;
}

//
// INetCfgProperties
//

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::MergePropPages
//
//  Purpose:    Called when this component's properties are about to be
//              brought up.
//
//  Arguments:
//      pdwDefPages   [out] Number of default pages to show.
//      pahpspPrivate [out] Array of property sheet handles to pages that this
//                          component will show.
//      pcPrivate     [out] Number of pages in array.
//      hwndParent    [in]  Parent window for any UI.
//      pszStartPage  [out] Pointer to start page.
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   22 Feb 1997
//
//  Notes:
//
STDMETHODIMP CMSClient::MergePropPages(
    IN OUT DWORD* pdwDefPages,
    OUT LPBYTE* pahpspPrivate,
    OUT UINT* pcPages,
    IN HWND hwndParent,
    OUT PCWSTR* pszStartPage)
{
    Validate_INetCfgProperties_MergePropPages (
        pdwDefPages, pahpspPrivate, pcPages, hwndParent, pszStartPage);

    HPROPSHEETPAGE *ahpsp = NULL;
    HRESULT hr = HrSetupPropSheets(&ahpsp, c_cPages);
    if (SUCCEEDED(hr))
    {
        *pahpspPrivate = (LPBYTE)ahpsp;

        // We don't want any default pages to be shown
        *pdwDefPages = 0;
        *pcPages = c_cPages;
    }

    Validate_INetCfgProperties_MergePropPages_Return(hr);

    TraceError("CMSClient::MergePropPages", hr);
    return hr;
}

STDMETHODIMP CMSClient::ValidateProperties(HWND hwndSheet)
{
    return S_OK;
}

STDMETHODIMP CMSClient::CancelProperties()
{
    return S_OK;
}

STDMETHODIMP CMSClient::ApplyProperties()
{
    return S_OK;
}

//
// INetCfgSystemNotify
//
STDMETHODIMP CMSClient::GetSupportedNotifications (DWORD* pdwNotificationFlag)
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwNotificationFlag);

    *pdwNotificationFlag = NCN_NETTRANS | NCN_NETSERVICE |
                           NCN_ENABLE | NCN_DISABLE |
                           NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP CMSClient::SysQueryBindingPath (DWORD dwChangeFlag,
                                             INetCfgBindingPath* pncbp)
{
    return S_OK;
}

STDMETHODIMP CMSClient::SysQueryComponent (DWORD dwChangeFlag,
                                           INetCfgComponent* pncc)
{
    return S_OK;
}

STDMETHODIMP CMSClient::SysNotifyBindingPath (DWORD dwChangeFlag,
                                              INetCfgBindingPath* pncbpItem)
{
    return S_FALSE;
}

STDMETHODIMP CMSClient::SysNotifyComponent(DWORD dwChangeFlag,
                                           INetCfgComponent* pncc)
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pncc);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (dwChangeFlag & (NCN_ADD | NCN_REMOVE))
    {
        if (FIsComponentId(c_szInfId_MS_Server, pncc))
        {
            if (dwChangeFlag & NCN_ADD)
            {
                m_eSrvState = eSrvEnable;
                hr = S_OK;
            }
            else if (dwChangeFlag & NCN_REMOVE)
            {
                m_eSrvState = eSrvDisable;
                hr = S_OK;
            }
        }
    }

    return hr;
}

HRESULT CMSClient::HrSetNetLogonDependencies(VOID)
{
    static const WCHAR c_szLanmanServer[]   = L"LanmanServer";
    static const WCHAR c_szNetLogon[]       = L"NetLogon";
    
    HRESULT hr = S_OK;
    NT_PRODUCT_TYPE   ProductType;
    if (RtlGetNtProductType(&ProductType))
    {
        if (NtProductLanManNt == ProductType)
        {
            // If domain controller, make NetLogon wait for LanmanServer
            CServiceManager sm;
            CService        svc;
            hr = sm.HrOpen();
            if (SUCCEEDED(hr))
            {
                hr = sm.HrAddServiceDependency(c_szNetLogon, c_szLanmanServer);
                sm.Close();
            }
            if (FAILED(hr))
            {
                TraceError("CMSClient::HrSetNetLogonDependencies - "
                    "Creating dependency of NetLogon on LanmanServer",
                    hr);
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        LSA_HANDLE h=0;
        POLICY_PRIMARY_DOMAIN_INFO* ppdi;
        LSA_OBJECT_ATTRIBUTES loa;
        ZeroMemory (&loa, sizeof(loa));
        loa.Length = sizeof(LSA_OBJECT_ATTRIBUTES);

        NTSTATUS ntstatus;
        ntstatus = LsaOpenPolicy(NULL, &loa, POLICY_VIEW_LOCAL_INFORMATION, &h);
        if (FALSE != LSA_SUCCESS(ntstatus))
        {
            ntstatus = LsaQueryInformationPolicy(h, PolicyPrimaryDomainInformation, (VOID **) &ppdi);
            if (LSA_SUCCESS(ntstatus))
            {
                if (ppdi->Sid > 0) // Domain Member
                {
                    hr = HrChangeServiceStartType(c_szNetLogon, SERVICE_AUTO_START);
                    if (FAILED(hr))
                    {
                        TraceError("CMSClient::HrSetNetLogonDependencies - "
                            "Install for Start - NetLogon",
                            hr);
                    }

                }
                LsaFreeMemory(ppdi);
            }
            LsaClose(h);
        }
    }

    TraceError("CMSClient::HrSetNetLogonDependencies",hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nbfcfg\resource.h ===
#include <ncres.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\resource.h ===
#include <ncres.h>

#define STR_DCELocator                  IDS_NC_MSCLICFG +  1
#define STR_DCESecurity                 IDS_NC_MSCLICFG +  2
#define STR_ErrorCaption                IDS_NC_MSCLICFG +  3
#define STR_InvalidDomainName           IDS_NC_MSCLICFG +  6
#define STR_InvalidNetAddress           IDS_NC_MSCLICFG +  7
#define STR_NTLocator                   IDS_NC_MSCLICFG +  9
#define STR_NTSecurity                  IDS_NC_MSCLICFG + 10
#define STR_Route                       IDS_NC_MSCLICFG + 11

#define DLG_RPCConfig                   1202

#define CMB_NameService                 215
#define EDT_NetAddress                  216
#define CMB_SecService                  217
#define IDC_TXT_NetAddress              220
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nbfcfg\nbfobj.h ===
#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include "resource.h"


/////////////////////////////////////////////////////////////////////////////
// Netnbf

class ATL_NO_VTABLE CNbfObj :
    public CComObjectRoot,
    public CComCoClass<CNbfObj, &CLSID_CNbfObj>,
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal
{
public:
    CNbfObj();
    ~CNbfObj();

    BEGIN_COM_MAP(CNbfObj)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CNbfObj)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_NBFCFG)

// Install Action (Unknown, Install, Remove)
    enum INSTALLACTION {eActConfig, eActInstall, eActRemove};
    enum NBFSTATE      {eStateNoChange, eStateDisable, eStateEnable};

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Install)             (DWORD);
    STDMETHOD (Upgrade)             (DWORD, DWORD) {return S_OK;}
    STDMETHOD (Removing)            ();

// INetCfgNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

private:
    HRESULT HrEnableNetBEUI();
    HRESULT HrDisableNetBEUI();
    HRESULT HrUpdateNetBEUI();

private:
    INetCfgComponent* m_pNCC;
    INetCfg*          m_pNetCfg;
    BOOL              m_fFirstTimeInstall;
    BOOL              m_fRebootNeeded;
    NBFSTATE          m_eNBFState;
    INSTALLACTION     m_eInstallAction;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\nbfcfg\nbfobj.cpp ===
// Nbfobj.cpp : Implementation of CNbfObj

#include "pch.h"
#pragma hdrstop
#include "nbfobj.h"
#include "ncsvc.h"

static const WCHAR c_szNbfServiceName[] = L"Nbf";

/////////////////////////////////////////////////////////////////////////////
//

//
// Function:    CNbfObj::CNbfObj
//
// Purpose:     ctor for the CNbfObj class
//
// Parameters:  none
//
// Returns:     none
//
CNbfObj::CNbfObj() : m_pNetCfg(NULL),
             m_pNCC(NULL),
             m_fFirstTimeInstall(FALSE),
             m_eNBFState(eStateNoChange),
             m_eInstallAction(eActConfig)
{
}

//
// Function:    CNbfObj::CNbfObj
//
// Purpose:     dtor for the CNbfObj class
//
// Parameters:  none
//
// Returns:     none
//
CNbfObj::~CNbfObj()
{
    ReleaseObj(m_pNetCfg);
    ReleaseObj(m_pNCC);
}


// INetCfgNotify
STDMETHODIMP CNbfObj::Initialize ( INetCfgComponent* pnccItem,
    INetCfg* pNetCfg, BOOL fInstalling )
{
    Validate_INetCfgNotify_Initialize(pnccItem, pNetCfg, fInstalling);

    ReleaseObj(m_pNCC);
    m_pNCC    = pnccItem;
    AddRefObj(m_pNCC);
    ReleaseObj(m_pNetCfg);
    m_pNetCfg = pNetCfg;
    AddRefObj(m_pNetCfg);
    m_fFirstTimeInstall = fInstalling;

    INetCfgComponent* pncc = NULL;

    // See if DNS is already installed.  If it is we need to be disabled
    if (S_OK == pNetCfg->FindComponent( L"MS_DNSServer", &pncc))
    {
        m_eNBFState = eStateDisable;
        ReleaseObj(pncc);
    }

    return S_OK;
}

STDMETHODIMP CNbfObj::ReadAnswerFile (PCWSTR pszAnswerFile,
                                      PCWSTR pszAnswerSection )
{
    Validate_INetCfgNotify_ReadAnswerFile(pszAnswerFile, pszAnswerSection );
    return S_OK;
}

STDMETHODIMP CNbfObj::Install (DWORD)
{
    m_eInstallAction = eActInstall;

    return S_OK;
}

STDMETHODIMP CNbfObj::Removing ()
{
    m_eInstallAction = eActRemove;
    return S_OK;
}

STDMETHODIMP CNbfObj::Validate ()
{
    return S_OK;
}

STDMETHODIMP CNbfObj::CancelChanges ()
{
    return S_OK;
}

STDMETHODIMP CNbfObj::ApplyRegistryChanges ()
{
    HRESULT hr = S_OK;

    switch(m_eInstallAction)
    {
    case eActInstall:
        hr = HrUpdateNetBEUI();
        break;

    case eActRemove:
        hr = S_OK;
        break;

    default:
        // Update NetBEUI's state if necessary
        hr = HrUpdateNetBEUI();
        break;
    }

    TraceError("CNbfObj::ApplyRegistryChanges", hr);
    return hr;
}

STDMETHODIMP CNbfObj::ApplyPnpChanges (
    IN INetCfgPnpReconfigCallback* pICallback )
{
    HRESULT             hr = S_OK;
    CServiceManager     sm;
    CService            service;

    // RAID #336321: (danielwe) Query the RemoteAccess service to see if
    // it's running and if so, return that a reboot is necessary (assumimg we
    // are installing or removing Nbf)
    //
    hr = sm.HrOpenService(&service, L"RemoteAccess");
    if (SUCCEEDED(hr))
    {
        DWORD   dwState;

        hr = service.HrQueryState(&dwState);
        if (SUCCEEDED(hr) &&
            (SERVICE_STOPPED != dwState) && (SERVICE_STOP_PENDING != dwState) &&
            ((m_eInstallAction == eActRemove) ||
             (m_eInstallAction == eActInstall)))
        {
            hr = NETCFG_S_REBOOT;
        }
    }

    TraceError("CNbfObj::ApplyPnpChanges", hr);
    return hr;
}


// INetCfgSystemNotify
STDMETHODIMP CNbfObj::GetSupportedNotifications (
    DWORD* pdwNotificationFlag )
{
    Validate_INetCfgSystemNotify_GetSupportedNotifications(pdwNotificationFlag);

    // Want to know when DNS comes and goes
    *pdwNotificationFlag = NCN_NETSERVICE | NCN_ADD | NCN_REMOVE;

    return S_OK;
}

STDMETHODIMP CNbfObj::SysQueryBindingPath ( DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgSystemNotify_SysQueryBindingPath(dwChangeFlag,
                             pncbpItem);
    return S_OK;
}

STDMETHODIMP CNbfObj::SysQueryComponent ( DWORD dwChangeFlag,
    INetCfgComponent* pnccItem )
{
    Validate_INetCfgSystemNotify_SysQueryComponent(dwChangeFlag,
                           pnccItem);
    return S_OK;
}

STDMETHODIMP CNbfObj::SysNotifyBindingPath ( DWORD dwChangeFlag,
    INetCfgBindingPath* pncbpItem )
{
    Validate_INetCfgSystemNotify_SysNotifyBindingPath(dwChangeFlag,
                              pncbpItem);
    return S_FALSE;
}

STDMETHODIMP CNbfObj::SysNotifyComponent ( DWORD dwChangeFlag,
    INetCfgComponent* pnccItem )
{
    HRESULT hr;

    Validate_INetCfgSystemNotify_SysNotifyComponent(dwChangeFlag, pnccItem);

    // Assume we won't be dirty as a result of this notification.
    //
    hr = S_FALSE;

    if (FIsComponentId(L"MS_DnsServer", pnccItem))
    {
        // Disable/Enable NetBEUI when DNS is Added/Removed
        if (dwChangeFlag & NCN_ADD)
        {
            // Disable NetBEUI, and shutdown NetBEUI
            m_eNBFState = eStateDisable;
            hr = S_OK;
        }
        else if (dwChangeFlag & NCN_REMOVE)
        {
            // Re-enable NetBEUI
            m_eNBFState = eStateEnable;
            hr = S_OK;
        }
    }

    return hr;
}

//
// Function:    CNbfObj::HrEnableNetBEUI
//
// Purpose:     Enable NetBEUI
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrEnableNetBEUI()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, c_szNbfServiceName);
    if (SUCCEEDED(hr))
    {
        // Change the Nbf StartType registry setting back to demand_start
        hr = srv.HrSetStartType(SERVICE_DEMAND_START);
    }

    // TODO: LogError any errors
    TraceError("CNbfObj::HrEnableNetBEUI",hr);
    return hr;
}

//
// Function:    CNbfObj::HrDisableNetBEUI
//
// Purpose:     Disable NetBEUI and shut down the service if it is running
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrDisableNetBEUI()
{
    HRESULT         hr;
    CServiceManager sm;
    CService        srv;

    hr = sm.HrOpenService(&srv, c_szNbfServiceName);
    if (SUCCEEDED(hr))
    {
    // Note: (shaunco) 8 Jan 1998: Need the SCM to be locked.

        // Change the Nbf StartType registry setting to disabled
        hr = srv.HrSetStartType(SERVICE_DISABLED);
        if (SUCCEEDED(hr))
        {
            hr = sm.HrStopServiceNoWait(c_szNbfServiceName);
        }
    }

    // TODO: LogError any errors
    TraceError("CNbfObj::HrDisableNetBEUI",hr);
    return hr;
}

//
// Function:    CNbfObj::HrUpdateNetBEUI
//
// Purpose:     Enable, Disable, or no nothing to NetBEUI
//              based on the presence of DNS Server
//
// Parameters:  none
//
// Returns:     HRESULT, S_OK on success
//
HRESULT CNbfObj::HrUpdateNetBEUI()
{
    HRESULT hr = S_OK;

    switch(m_eNBFState)
    {
    case eStateDisable:
        hr = HrDisableNetBEUI();
        break;
    case eStateEnable:
        hr = HrEnableNetBEUI();
        break;
    default:
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advanced.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "advanced.h"
#include "advstrs.h"
#include "kkcwinf.h"
#include "ncatlui.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"
#include "resource.h"

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::CAdvancedParams (constructor)
//
//  Purpose:    Init some variables.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      The bulk of the setting up occurs in FInit().
//
CAdvancedParams::CAdvancedParams()
:   m_hkRoot(NULL),
    m_pparam(NULL),
    m_nCurSel(0),
    m_fInit(FALSE),
    m_hdi(NULL),
    m_pdeid(NULL)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::HrInit
//
//  Purpose:    Initializes the class.
//
//  Arguments:
//      pnccItem [in]       ptr to my INetCfgComponent interface.
//
//  Returns:    TRUE if initialization was okay, FALSE if couldn't init.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      We needed to separate this from the constructor since the
//              initialization can fail.
//
HRESULT CAdvancedParams::HrInit(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    HKEY hkNdiParamKey;

    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    // Open the device's instance key
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
            &m_hkRoot);

    if (SUCCEEDED(hr))
    {
        hr = HrRegOpenKeyEx(m_hkRoot, c_szRegKeyParamsFromInstance,
                KEY_READ | KEY_SET_VALUE, &hkNdiParamKey);
        // populate the parameter list
        if (SUCCEEDED(hr))
        {
            FillParamList(m_hkRoot, hkNdiParamKey);
            RegSafeCloseKey(hkNdiParamKey);
            m_fInit = TRUE;
            m_hdi = hdi;
            m_pdeid = pdeid;
            hr = S_OK;
        }
    }

    TraceErrorOptional("CAdvancedParams::HrInit", hr,
                       HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr);
    return hr;
}


CAdvancedParams::~CAdvancedParams()
{
    vector<CParam *>::iterator ppParam;

    // delete everything from the list
    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        delete *ppParam;
    }

    RegSafeCloseKey(m_hkRoot);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FSave
//
//  Purpose:    Saves values from InMemory storage to the registry.
//
//  Returns:    TRUE if something was changed; FALSE if nothig changed
//              registry.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
BOOL CAdvancedParams::FSave()
{
    vector<CParam *>::iterator ppParam;
    BOOL    fErrorOccurred = FALSE;

    // Save any changed params
    BOOL fDirty = FALSE;
    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        Assert(ppParam);
        Assert(*ppParam);
        if ((*ppParam)->FIsModified())
        {
            fDirty = TRUE;
            TraceTag(ttidNetComm, "Parameter %S has changed",
                    (*ppParam)->SzGetKeyName());
            if (!(*ppParam)->Apply())
            {
                fErrorOccurred = TRUE;
            }
        }
    }

    if (fErrorOccurred)
    {
        TraceTag(ttidError, "An error occurred saving adapter's %S "
                "parameter.", (*ppParam)->GetDesc());
    }

    return fDirty;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FillParamList
//
//  Purpose:    Populates the internal parameter list (m_listpParam) with
//              values from the registry.
//
//  Arguments:
//      hk  [in]    The key from which to enumerate the parameters.
//                  Normally obtained from a call to INCC->OpenNdiParamKey().
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvancedParams::FillParamList(HKEY hkRoot, HKEY hk)
{
    DWORD       iValue;
    CParam     *pParam;
    WCHAR       szRegValue[_MAX_PATH];
    DWORD       cchRegValue;
    HRESULT     hr = S_OK;
    FILETIME    ft;

    // Initialize the list.
    m_listpParam.erase(m_listpParam.begin(), m_listpParam.end());

    iValue = 0;

    for (iValue = 0; SUCCEEDED(hr); iValue++)
    {
        cchRegValue = celems(szRegValue);

        hr = HrRegEnumKeyEx(hk, iValue, szRegValue, &cchRegValue,
                            NULL,NULL,&ft);

        if (SUCCEEDED(hr))
        {
            // Create the param structure
            pParam = new CParam;

			if (pParam == NULL)
			{
				return;
			}

            if (pParam->FInit(hkRoot, hk,szRegValue))
            {
                // Add parameter to list.
                m_listpParam.push_back(pParam);
            }
            else
            {
                // couldn't Create() it...
                delete pParam;
            }
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FValidateAllParams
//
//  Purpose:    Validates values of all parameters.  Displays optional
//              error UI.
//
//  Arguments:
//      fDisplayUI  [in]    TRUE - on error, focus is set to offending
//                          parameter and the error message box is displayed.
//                          FALSE - don't do any UI thing on error.  Useful
//                          when the dialog has not been initialized.
//  Returns:    TRUE - everything validated okay.
//              FALSE - error with one of the parameters.  If (fDisplayUI),
//              then the currently displayed parameter is the offending one.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      Calls FValidateSingleParam() for each parameter.
//
BOOL CAdvancedParams::FValidateAllParams(BOOL fDisplayUI, HWND hwndParent)
{
    BOOL fRetval = TRUE;
    for (size_t i = 0; i < m_listpParam.size(); i++)
    {
        if (!FValidateSingleParam(m_listpParam[i], fDisplayUI, hwndParent))
        {
            TraceTag(ttidError, "NetComm : %S parameter failed validation",
                    m_listpParam[i]->GetDesc());
            fRetval = FALSE;
            break;
        }
    }
    return fRetval;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::FValidateSingleParam
//
//  Purpose:    Validates a single parameter.  Displaying an optional
//              error UI.
//
//  Arguments:
//      pparam     [in]     ptr to the param to be validated.  If
//                          (fDisplayUI), then this must be the currently
//                          displayed parameter.
//      fDisplayUI [in]     TRUE - error UI is to be displayed.
//                          FALSE - no error UI is to be displayed.
//
//  Returns:    TRUE - parameter validated okay; FALSE - error in parameter.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      If fDisplayUI, then pparam must be the currently displayed
//              param, since the error box will pop up indicating the error.
//
BOOL CAdvancedParams::FValidateSingleParam(CParam * pparam, BOOL fDisplayUI, HWND hwndParent)
{
    BOOL fRetval = FALSE;
    WCHAR szMin[c_cchMaxNumberSize];
    WCHAR szMax[c_cchMaxNumberSize];
    WCHAR szStep[c_cchMaxNumberSize];

    // ensure we're the currently displayed param if fDisplayUI
    AssertSz(FImplies(fDisplayUI, m_pparam == pparam),
             "Not the currently displayed param.");

    switch (pparam->Validate())
    {
        case VALUE_OK:
            fRetval = TRUE;
            break;

        case VALUE_BAD_CHARS:
            if (fDisplayUI)
            {
                NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_ERR_VALUE_BAD_CHARS,
                         MB_ICONWARNING);
            }
            break;

        case VALUE_EMPTY:
            if (fDisplayUI)
            {
                NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_ERR_VALUE_EMPTY,
                         MB_ICONWARNING);
            }
            break;

        case VALUE_OUTOFRANGE:
            Assert(pparam->GetValue()->IsNumeric());
            pparam->GetMin()->ToString(szMin, celems(szMin));
            pparam->GetMax()->ToString(szMax, celems(szMax));
            if (fDisplayUI)
            {
                // need to select between two dialogs depending on the step size.
                if (pparam->GetStep()->GetNumericValueAsDword() == 1)
                {
                    // no step
                    NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_PARAM_RANGE,
                             MB_ICONWARNING, szMin, szMax);
                }
                else
                {
                    pparam->GetStep()->ToString(szStep, celems(szStep));
                    NcMsgBox(hwndParent, IDS_ERROR_CAPTION, IDS_PARAM_RANGE_STEP,
                             MB_ICONWARNING, szMin, szMax, szStep);
                }
            }
            else
            {
                TraceTag(ttidNetComm, "The parameter %S was out of range. "
                        "Attempting to correct.", pparam->SzGetKeyName());
                // Since we can't bring up UI, we will try to correct the
                // error for the user
                //
                if (pparam->GetMin() > pparam->GetValue())
                {
                    // Try to set to the minimum value.  If it fails, we must still
                    // continue
                    (void) FSetParamValue(pparam->SzGetKeyName(), szMin);
                }

                if (pparam->GetMax() < pparam->GetValue())
                {
                    // Try to set to the maximum value.  If it fails, we must still
                    // continue
                    (void) FSetParamValue(pparam->SzGetKeyName(), szMax);
                }
            }
            break;
        default:
            AssertSz(FALSE,"Hit the default on a switch");
    }

    return fRetval;
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::UseAnswerFile
//
//  Purpose:    Get adapter specific params from the answerfile
//
//  Arguments:
//      szAnswerFile  [in]       path of answerfile
//      szSection     [in]       section within answerfile
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvancedParams::UseAnswerFile(const WCHAR * szAnswerFile,
                              const WCHAR * szSection)
{
    CWInfFile AnswerFile;
    CWInfSection* pSection;
    const WCHAR* szAFKeyName;
    const WCHAR* szAFKeyValue;
    const WCHAR* szAdditionalParamsSection;

    // initialize answer file class
	if (AnswerFile.Init() == FALSE)
	{
        AssertSz(FALSE,"CAdvancedParams::UseAnswerFile - Failed to initialize CWInfFile");
		return;
	}
	
	// Open the answerfile and find the desired section.
    AnswerFile.Open(szAnswerFile);
    pSection = AnswerFile.FindSection(szSection);

    if (pSection)
    {

        // go through all the keys in this section.
        CWInfKey * pInfKey;

        // Now, go to AdditionalParams section and read key values from there
        szAdditionalParamsSection =
                pSection->GetStringValue(L"AdditionalParams", L"");
        Assert(szAdditionalParamsSection);
        if (lstrlenW(szAdditionalParamsSection) < 1)
        {
            TraceTag(ttidNetComm, "No additional params section");
        }
        else
        {
            pSection = AnswerFile.FindSection(szAdditionalParamsSection);
            if (!pSection)
            {
                TraceTag(ttidNetComm, "Specified AdditionalParams section not "
                        "found.");
            }
            else
            {
                for (pInfKey = pSection->FirstKey();
                    pInfKey;
                    pInfKey = pSection->NextKey())
                {
                    // get key name
                    szAFKeyName = pInfKey->Name();
                    szAFKeyValue = pInfKey->GetStringValue(L"");
                    Assert(szAFKeyName && szAFKeyValue);
                    if (!FSetParamValue(szAFKeyName, szAFKeyValue))
                    {
                        TraceTag(ttidNetComm, "Key %S not in ndi\\params. "
                                "Assuming it is a static parameter.",
                                szAFKeyName);
                    }
                } // for
            } // if
        } // if
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvancedParams::SetParamValue
//
//  Purpose:    Sets a parameter's value
//
//  Arguments:
//      szName    [in]       Name of parameter.
//      szValue   [in]       value (in text) to give param (from Answerfile)
//
//  Returns:    TRUE if szName was found.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
BOOL
CAdvancedParams::FSetParamValue (
    const WCHAR* pszName,
    const WCHAR* const pszValue)
{
    for (size_t i = 0; i < m_listpParam.size(); i++)
    {
        if (0 == lstrcmpiW (pszName, m_listpParam[i]->SzGetKeyName()))
        {
            // found the param
            // set it's current value
            m_listpParam[i]->GetValue()->FromString (pszValue);
            m_listpParam[i]->SetModified (TRUE);
            return TRUE; // found
        }
    }
    return FALSE; // not found
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advanced.h ===
#pragma once
#include "netcfgx.h"
#include "global.h"
#include "param.h"

class CAdvancedParams
{
public:

    CAdvancedParams ();
    ~CAdvancedParams ();
    HRESULT HrInit(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);
    BOOL FValidateAllParams(BOOL fDisplayUI, HWND hwndParent);
    BOOL FSave();
    VOID UseAnswerFile(const WCHAR *, const WCHAR *);

protected:
    HKEY                m_hkRoot;   // instance root
    CParam *            m_pparam;   // current param
    int                 m_nCurSel;  // current item
    CValue              m_vCurrent; // control param value
    BOOL                m_fInit;
    HDEVINFO            m_hdi;
    PSP_DEVINFO_DATA    m_pdeid;

    vector<CParam*> m_listpParam;

    // protected methods
    BOOL FList(WORD codeNotify);
    VOID FillParamList(HKEY hkRoot, HKEY hk);
    VOID SetParamRange();
    int EnumvalToItem(const PWSTR psz);
    int ItemToEnumval(int iItem, PWSTR psz, UINT cb);
    VOID BeginEdit();
    BOOL FValidateCurrParam();
    BOOL FValidateSingleParam(CParam * pparam, BOOL fDisplayUI,
            HWND hwndParent);
    BOOL FSetParamValue(const WCHAR * szName, const WCHAR * const szValue);

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\rpcdlg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       R P C D L G . C P P
//
//  Contents:   Dialog box handling for RPC configuration.
//
//  Notes:
//
//  Author:     danielwe   3 Mar 1997
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "mscliobj.h"
#include "msclidlg.h"
#include "ncatlui.h"
#include "ncerror.h"
#include "ncreg.h"
#include "ncui.h"
#include "msclihlp.h"

//
// Name service provider struct. Just holds some data used by the dialog.
//
struct NSP
{
    PCWSTR      pszProtocol;
    PCWSTR      pszEndPoint;
    WCHAR       szNetAddr[c_cchMaxNetAddr];
    BOOL        fUsesNetAddr;
};

static const WCHAR c_szRegKeyNameSvc[]  = L"Software\\Microsoft\\Rpc\\NameService";
static const WCHAR c_szNetAddress[]     = L"NetworkAddress";
static const WCHAR c_szSrvNetAddress[]  = L"ServerNetworkAddress";
static const WCHAR c_szProtocol[]       = L"Protocol";
static const WCHAR c_szValueEndPoint[]  = L"Endpoint";
static const WCHAR c_szProtDCE[]        = L"ncacn_ip_tcp";
static const WCHAR c_szEndPoint[]       = L"\\pipe\\locator";

// Used externally
extern const WCHAR c_szDefNetAddr[]     = L"\\\\.";
extern const WCHAR c_szProtWinNT[]      = L"ncacn_np";

// Helpfile
extern const WCHAR c_szNetCfgHelpFile[];


//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrGetRPCRegistryInfo
//
//  Purpose:    Reads the current state of the RPC configuration from the
//              registry into an in-memory struct. All changes occur to the
//              struct until Apply() is called at which time all changes are
//              written from the struct to the registry. Any values that
//              cannot be obtained are given reasonable defaults.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrGetRPCRegistryInfo()
{
    HRESULT     hr = S_OK;

    // This key *will* be there because it's in the system hive.
    hr = HrRegOpenKeyBestAccess(HKEY_LOCAL_MACHINE, c_szRegKeyNameSvc,
                                &m_hkeyRPCName);
    if (FAILED(hr))
    {
        goto err;
    }

    // Find out what protocol the current name service provider is using.
    // This will allow us to set the default selection for the combo box.
    hr = HrRegQueryString(m_hkeyRPCName, c_szProtocol,
                          &m_rpcData.strProt);
    if (FAILED(hr))
    {
        goto err;
    }

    // Get the current value of the end point
    hr = HrRegQueryString(m_hkeyRPCName, c_szValueEndPoint,
                          &m_rpcData.strEndPoint);
    if (FAILED(hr))
    {
        if (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr)
        {
            // Use default value
            m_rpcData.strEndPoint = c_szEndPoint;
            hr = S_OK;
        }
        else
        {
            goto err;
        }
    }

    // If the name service provider uses a network address, we need to get it
    // too so we can fill in that nice little edit box with it.
    hr = HrRegQueryString(m_hkeyRPCName, c_szNetAddress,
                          &m_rpcData.strNetAddr);
    if (FAILED(hr))
    {
        goto err;
    }

err:
    TraceError("CMSClient::HrGetRPCRegistryInfo", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CMSClient::HrSetRPCRegistryInfo
//
//  Purpose:    Write out changes to the data structure (if there were any) to
//              the registry.
//
//  Arguments:
//      (none)
//
//  Returns:    HRESULT, Error code.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
HRESULT CMSClient::HrSetRPCRegistryInfo()
{
    HRESULT     hr = S_OK;

    struct REG_SET
    {
        PCWSTR          pszValue;
        const tstring * pstrData;
    };

    const REG_SET     aregs[] =
    {
        {c_szNetAddress,    &m_rpcData.strNetAddr},
        {c_szSrvNetAddress, &m_rpcData.strNetAddr},
        {c_szValueEndPoint, &m_rpcData.strEndPoint},
        {c_szProtocol,      &m_rpcData.strProt},
    };
    static const INT cregs = celems(aregs);

    if (m_fRPCChanges)
    {
        INT     iregs;

        for (iregs = 0; iregs < cregs; iregs++)
        {
            Assert(aregs[iregs].pstrData);
            hr = HrRegSetString(m_hkeyRPCName, aregs[iregs].pszValue,
                                *aregs[iregs].pstrData);
            if (FAILED(hr))
            {
                goto err;
            }
        }
    }
err:
    TraceError("CMSClient::HrSetRPCRegistryInfo", hr);
    return hr;
}


//
// Dialog handlers
//

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnInitDialog
//
//  Purpose:    Called when this dialog is first brought up.
//
//  Arguments:
//      uMsg     [in]
//      wParam   [in] See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& bHandled)
{
    HRESULT     hr = S_OK;
    PCWSTR      pszCBItem;
    NSP *       pnspNT = NULL;
    NSP *       pnspDCE = NULL;
    INT         iItem;
    INT         cItems;

    const RPC_CONFIG_DATA * prpcData;

    // Make sure selection is always undetermined when the dialog is invoked.
    m_isel = -1;

    prpcData = m_pmsc->RPCData();
    Assert(prpcData);

    // Allocate some structs to associate with item data.
    pnspNT = new NSP;
    pnspDCE = new NSP;

	if ((pnspNT == NULL) ||
		(pnspDCE == NULL))
	{
		return(E_OUTOFMEMORY);
	}

    pnspNT->pszProtocol = c_szProtWinNT;
    pnspNT->pszEndPoint = c_szEndPoint;

    // This field is unused by NT name service. Just zero it out. When it
    // comes time to save the network address, we'll see that fUsesNetAddr is
    // FALSE and the szNetAddr string is empty and just save a hardcoded
    // net address.
    *pnspNT->szNetAddr = 0;
    pnspNT->fUsesNetAddr = FALSE;

    pnspDCE->pszProtocol = c_szProtDCE;
    pnspDCE->pszEndPoint = L"";
    *pnspDCE->szNetAddr = 0;
    pnspDCE->fUsesNetAddr = TRUE;

    //
    // Setup Name Service combo box
    //

    pszCBItem = SzLoadIds(STR_NTLocator);
    iItem = (INT)SendDlgItemMessage(CMB_NameService, CB_ADDSTRING, 0,
                                    (LPARAM)pszCBItem);
    SendDlgItemMessage(CMB_NameService, CB_SETITEMDATA, iItem,
                       (LPARAM)pnspNT);

    pszCBItem = SzLoadIds(STR_DCELocator);
    iItem = (INT)SendDlgItemMessage(CMB_NameService, CB_ADDSTRING, 0,
                                    (LPARAM)pszCBItem);
    SendDlgItemMessage(CMB_NameService, CB_SETITEMDATA, iItem,
                       (LPARAM)pnspDCE);

    cItems = (INT)SendDlgItemMessage(CMB_NameService, CB_GETCOUNT);

    // Find the item in the list that has the same protocol as the one from
    // the registry and make it the current selection.
    for (iItem = 0; iItem < cItems; iItem++)
    {
        NSP *pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                              CB_GETITEMDATA, iItem, 0);
        Assert(pnsp);
        if (!lstrcmpiW (pnsp->pszProtocol, prpcData->strProt.c_str()))
        {
            lstrcpyW (pnsp->szNetAddr, prpcData->strNetAddr.c_str());
            SendDlgItemMessage (CMB_NameService, CB_SETCURSEL, iItem, 0);
            break;
        }
    }

    AssertSz(iItem != cItems, "Protocol not found!");

    // Limit the edit box to the maximum length of a network address.
    SendDlgItemMessage(EDT_NetAddress, EM_LIMITTEXT, c_cchMaxNetAddr, 0);

    SetState();

    TraceError("CRPCConfigDlg::OnInitDialog", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Method: CRPCConfigDlg::OnContextMenu
//
//  Desc:   Bring up context-sensitive help
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
LRESULT
CRPCConfigDlg::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    if (g_aHelpIDs_DLG_RPCConfig != NULL)
    {
        ::WinHelp(m_hWnd,
                  c_szNetCfgHelpFile,
                  HELP_CONTEXTMENU,
                  (ULONG_PTR)g_aHelpIDs_DLG_RPCConfig);
    }
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method: CRPCConfigDlg::OnHelp
//
//  Desc:   Bring up context-sensitive help when dragging ? icon over a control
//
//  Args:   Standard command parameters
//
//  Return: LRESULT
//
//
LRESULT
CRPCConfigDlg::OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled)
{
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);
    Assert(lphi);

    if ((g_aHelpIDs_DLG_RPCConfig != NULL) && (HELPINFO_WINDOW == lphi->iContextType))
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle),
                  c_szNetCfgHelpFile,
                  HELP_WM_HELP,
                  (ULONG_PTR)g_aHelpIDs_DLG_RPCConfig);
    }
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::SetState
//
//  Purpose:    Set the state of the edit control when selection changes.
//
//  Arguments:
//      (none)
//
//  Returns:    Nothing.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
VOID CRPCConfigDlg::SetState()
{
    INT     iItem;
    NSP *   pnsp;
    NSP *   pnspOld = NULL;
    HWND    hwndEdit = GetDlgItem(EDT_NetAddress);

    iItem = (INT)SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    Assert(iItem != CB_ERR);

    // If the selection hasn't changed, just return
    if (iItem == m_isel)
        return;

    if (m_isel != -1)
    {
        // Get the item data of the previous selection
        pnspOld = (NSP *)SendDlgItemMessage(CMB_NameService,
                                         CB_GETITEMDATA, m_isel, 0);
    }

    m_isel = iItem;

    // Get the item data of the new selection
    pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                     CB_GETITEMDATA, iItem, 0);
    Assert(pnsp);

    if (pnsp->fUsesNetAddr)
    {
        // This provider uses the NetAddress field. Set the edit control with
        // its text.
        ::SetWindowText(hwndEdit, pnsp->szNetAddr);
    }
    else
    {
        // Doesn't use NetAddress. Blank it out and save the old one.
        if (pnspOld)
        {
            ::GetWindowText(hwndEdit, pnspOld->szNetAddr, c_cchMaxNetAddr);
        }
        ::SetWindowText(hwndEdit, L"");
    }

    // Disable the edit box for name service providers that don't use the
    // network address field.
    ::EnableWindow(hwndEdit, pnsp->fUsesNetAddr);
    ::EnableWindow(GetDlgItem(IDC_TXT_NetAddress), pnsp->fUsesNetAddr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::HrValidateRpcData
//
//  Purpose:    Ensures that the RPC data entered in the dialog is valid.
//
//  Arguments:
//      (none)
//
//  Returns:    S_OK, if no errors, or NETCFG_E_PSNRET_INVALID_NCPAGE if there
//              were errors.
//
//  Author:     danielwe   21 Apr 1997
//
//  Notes:
//
HRESULT CRPCConfigDlg::HrValidateRpcData()
{
    HRESULT     hr = S_OK;
    INT         iItem;
    NSP *       pnsp;
    HWND        hwndEdit = GetDlgItem(EDT_NetAddress);

    iItem = (INT)SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    if (iItem != CB_ERR)
    {
        // Get current name service info.
        pnsp = (NSP *)SendDlgItemMessage(CMB_NameService, CB_GETITEMDATA,
                                         iItem, 0);
        Assert(pnsp);

        if (pnsp->fUsesNetAddr)
        {
            INT     cch;

            // This name service uses the network address field. Make sure it
            // is not empty
            cch = ::GetWindowTextLength(hwndEdit);
            if (!cch)
            {
                // DCE doesn't allow empty network addresses
                NcMsgBox(m_hWnd, STR_ErrorCaption, STR_InvalidNetAddress,
                             MB_OK | MB_ICONEXCLAMATION);
                ::SetFocus(hwndEdit);
                hr = NETCFG_E_PSNRET_INVALID_NCPAGE;
            }
        }
    }

    TraceError("CRPCConfigDlg::HrValidateRpcData", hr);
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnKillActive
//
//  Purpose:    Called when the current page is switched away from or the
//              property sheet is closed.
//
//  Arguments:
//      idCtrl   []
//      pnmh     []     See the ATL documentation for return results.
//      bHandled []
//
//  Returns:    S_OK, if no errors, or NETCFG_E_PSNRET_INVALID_NCPAGE if there
//              were errors.
//
//  Author:     danielwe   21 Apr 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT     hr = S_OK;

    hr = HrValidateRpcData();

    TraceError("CRPCConfigDlg::OnKillActive", hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnOk
//
//  Purpose:    Called when the OK button is pressed.
//
//  Arguments:
//      idCtrl   [in]
//      pnmh     [in]   See the ATL documentation for params.
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnOk(int idCtrl, LPNMHDR pnmh, BOOL& bHandled)
{
    HRESULT             hr = S_OK;
    INT                 iItem;
    NSP *               pnsp;
    HWND                hwndEdit = GetDlgItem(EDT_NetAddress);
    RPC_CONFIG_DATA *   prpcData;

    // Get a read-write version of the in-memory RPC data
    prpcData = m_pmsc->RPCDataRW();
    Assert(prpcData);

    iItem = (INT)SendDlgItemMessage(CMB_NameService, CB_GETCURSEL, 0, 0);
    Assert(iItem != CB_ERR);

    pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                     CB_GETITEMDATA, iItem, 0);
    Assert(pnsp);

    if (pnsp->fUsesNetAddr)
    {
#ifdef DBG
        INT     cch;

        cch = ::GetWindowTextLength(hwndEdit);
        AssertSz(cch, "I though we validated this was not empty!");
#endif
        // obtain network address from edit control
        ::GetWindowText(hwndEdit, pnsp->szNetAddr, c_cchMaxNetAddr);
    }
    else
    {
        // copy in a default network address
        lstrcpyW (pnsp->szNetAddr, c_szDefNetAddr);
    }

    // Set the in-memory RPC data
    prpcData->strNetAddr = pnsp->szNetAddr;
    prpcData->strEndPoint = pnsp->pszEndPoint;
    prpcData->strProt = pnsp->pszProtocol;
    m_pmsc->SetRPCDirty();

    TraceError("CRPCConfigDlg::OnOk", hr);
    return LresFromHr(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CRPCConfigDlg::OnDestroy
//
//  Purpose:    Called when the dialog is destroyed.
//
//  Arguments:
//      uMsg     [in]
//      wParam   [in]   See the ATL documentation for params.
//      lParam   [in]
//      bHandled [in]
//
//  Returns:    See the ATL documentation for return results.
//
//  Author:     danielwe   3 Mar 1997
//
//  Notes:
//
LRESULT CRPCConfigDlg::OnDestroy(UINT uMsg, WPARAM wParam,
                                 LPARAM lParam, BOOL& bHandled)
{
    INT     iItem;
    INT     cItems;
    NSP *   pnsp;

    // Walk the list of name service providers and free the NSP structs we
    // allocated before.
    cItems = (INT)SendDlgItemMessage(CMB_NameService, CB_GETCOUNT, 0, 0);
    for (iItem = 0; iItem < cItems; iItem++)
    {
        pnsp = (NSP *)SendDlgItemMessage(CMB_NameService,
                                         CB_GETITEMDATA, iItem, 0);
        AssertSz(pnsp, "This should not be NULL!");
        delete pnsp;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\msclicfg\mscliobj.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M S C L I O B J . H
//
//  Contents:   Declaration of CMSClient and helper functions.
//
//  Notes:
//
//  Author:     danielwe   25 Feb 1997
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include <nceh.h>
#include <notifval.h>
#include <ncatlps.h>
#include "resource.h"

// constant defined in MSDN
static const c_cchMaxNetAddr = 80;

struct RPC_CONFIG_DATA
{
    tstring strProt;
    tstring strNetAddr;
    tstring strEndPoint;
};

/////////////////////////////////////////////////////////////////////////////
// MSClient

class ATL_NO_VTABLE CMSClient :
    public INetCfgComponentControl,
    public INetCfgComponentSetup,
    public INetCfgComponentNotifyGlobal,
    public INetCfgComponentPropertyUi,
    public CComObjectRoot,
    public CComCoClass<CMSClient,&CLSID_CMSClient>
{
public:
    CMSClient();
    ~CMSClient();

    BEGIN_COM_MAP(CMSClient)
        COM_INTERFACE_ENTRY(INetCfgComponentControl)
        COM_INTERFACE_ENTRY(INetCfgComponentSetup)
        COM_INTERFACE_ENTRY(INetCfgComponentNotifyGlobal)
        COM_INTERFACE_ENTRY(INetCfgComponentPropertyUi)
    END_COM_MAP()
    // DECLARE_NOT_AGGREGATABLE(CMSClient)
    // Remove the comment from the line above if you don't want your object to
    // support aggregation.  The default is to support it

    DECLARE_REGISTRY_RESOURCEID(IDR_REG_MSCLICFG)

// INetCfgComponentControl
    STDMETHOD (Initialize) (
        IN INetCfgComponent* pIComp,
        IN INetCfg* pINetCfg,
        IN BOOL fInstalling);
    STDMETHOD (ApplyRegistryChanges) ();
    STDMETHOD (ApplyPnpChanges) (
        IN INetCfgPnpReconfigCallback* pICallback);
    STDMETHOD (CancelChanges) ();
    STDMETHOD (Validate) ();

// INetCfgComponentSetup
    STDMETHOD (Install)             (DWORD dwSetupFlags);
    STDMETHOD (Upgrade)             (DWORD dwSetupFlags,
                                     DWORD dwUpgradeFomBuildNo);
    STDMETHOD (ReadAnswerFile)      (PCWSTR pszAnswerFile,
                                     PCWSTR pszAnswerSection);
    STDMETHOD (Removing)            ();


// INetCfgComponentNotifyGlobal
    STDMETHOD (GetSupportedNotifications) (DWORD* pdwNotificationFlag );
    STDMETHOD (SysQueryBindingPath)       (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysQueryComponent)         (DWORD dwChangeFlag, INetCfgComponent* pncc);
    STDMETHOD (SysNotifyBindingPath)      (DWORD dwChangeFlag, INetCfgBindingPath* pncbp);
    STDMETHOD (SysNotifyComponent)        (DWORD dwChangeFlag, INetCfgComponent* pncc);

// INetCfgProperties
    STDMETHOD (QueryPropertyUi) (
        IN IUnknown* pUnk) { return S_OK; }
    STDMETHOD (SetContext) (
        IN IUnknown* pUnk) {return S_OK;}
    STDMETHOD (MergePropPages) (
        IN OUT DWORD* pdwDefPages,
        OUT LPBYTE* pahpspPrivate,
        OUT UINT* pcPrivate,
        IN HWND hwndParent,
        OUT PCWSTR* pszStartPage);
    STDMETHOD (ValidateProperties) (
        HWND hwndSheet);
    STDMETHOD (CancelProperties) ();
    STDMETHOD (ApplyProperties) ();

public:

    // Accessors for RPC data
    const RPC_CONFIG_DATA *RPCData() const
        {return (const RPC_CONFIG_DATA *)&m_rpcData;};
    RPC_CONFIG_DATA *RPCDataRW() {return &m_rpcData;};

    // Accessors for Browser data
    PCWSTR SzGetBrowserDomainList()
        {return const_cast<PCWSTR>(m_szDomainList);};
    VOID SetBrowserDomainList(PWSTR szNewList);

    // Dirty bit functions
    VOID SetRPCDirty() {m_fRPCChanges = TRUE;};
    VOID SetBrowserDirty() {m_fBrowserChanges = TRUE;};

    // RPC config dialog members
    RPC_CONFIG_DATA     m_rpcData;          // data used to handle the RPC
                                            // configuration dialog
// Private state info
private:
    enum ESRVSTATE
    {
        eSrvNone = 0,
        eSrvEnable = 1,
        eSrvDisable = 2,
    };

    INetCfgComponent    *m_pncc;            // Place to keep my component
                                            // object
    INetCfg             *m_pnc;             // Place to keep my INetCfg object
    BOOL                m_fRPCChanges;      // TRUE if RPC config settings have
                                            // changed (dialog)
    BOOL                m_fBrowserChanges;  // Same for browser dialog
    BOOL                m_fOneTimeInstall;  // TRUE if need to perform one-time
                                            // install tasks
    BOOL                m_fUpgrade;         // TRUE if upgrading with answer
                                            // file
    BOOL                m_fUpgradeFromWks;  // TRUE if we are upgrading from WKS
    BOOL                m_fRemoving;        // TRUE we are being removed
    ESRVSTATE           m_eSrvState;

    HKEY                m_hkeyRPCName;      // NameService key

    // Browser config dialog members
    PWSTR              m_szDomainList;     // null-separated, double null
                                            // terminated list of OtherDomains

    // number of property sheet pages
    enum PAGES
    {
        c_cPages = 1
    };

    // Generic dialog data
    CPropSheetPage *    m_apspObj[c_cPages];// pointer to each of the prop
                                            // sheet page objects

    tstring             m_strBrowserParamsRestoreFile;
    tstring             m_strNetLogonParamsRestoreFile;

    HRESULT HrApplyChanges(VOID);
    HRESULT HrSetupPropSheets(HPROPSHEETPAGE **pahpsp, INT cPages);
    VOID CleanupPropPages(VOID);
    HRESULT HrProcessAnswerFile(PCWSTR pszAnswerFile, PCWSTR pszAnswerSection);
    HRESULT HrRestoreRegistry(VOID);
    HRESULT HrSetNetLogonDependencies(VOID);

    // Dialog access functions for RPC config
    HRESULT HrGetRPCRegistryInfo(VOID);
    HRESULT HrSetRPCRegistryInfo(VOID);

    // Dialog access functions for Browser config
    HRESULT HrGetBrowserRegistryInfo(VOID);
    HRESULT HrSetBrowserRegistryInfo(VOID);

    // Help function used by NotifyBindingPath
    BOOL FIsComponentOnPath(INetCfgBindingPath * pncbp, PCWSTR szCompId);
};

HRESULT HrInstallDfs(VOID);
HRESULT HrEnableBrowserService(VOID);
HRESULT HrDisableBrowserService(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advstrs.cpp ===
#include "pch.h"
#pragma hdrstop
#include "advstrs.h"

const WCHAR c_szRegKeyParamsFromInstance[]     = L"Ndi\\Params";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advstrs.h ===
#pragma once

extern const WCHAR c_szRegKeyParamsFromInstance[];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advpage.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V P A G E . H
//
//  Contents:   Advanced property page for Net Adapters
//
//  Notes:
//
//  Author:     nabilr   11 Mar 1997
//
//  History:    BillBe (24 June 1997) took over ownership
//
//----------------------------------------------------------------------------

#pragma once
#include <ncxbase.h>
#include "advanced.h"
#include "param.h"
#include "listbox.h"
#include "ncatlps.h"
#include "resource.h"

// WM_USER message to call OnValidate method
static const UINT c_msgValidate  = WM_USER;

enum CTLTYPE    // ctl
{
    CTLTYPE_UNKNOWN,
    CTLTYPE_SPIN,
    CTLTYPE_DROP,
    CTLTYPE_EDIT,
    CTLTYPE_NONE    // use the present radio buttons only..
};


class CAdvanced: public CPropSheetPage, public CAdvancedParams
{
public:
    BEGIN_MSG_MAP(CAdvanced)
        MESSAGE_HANDLER(WM_INITDIALOG, OnInitDialog)
        MESSAGE_HANDLER(WM_DESTROY, OnDestroy)
        MESSAGE_HANDLER(WM_HELP, OnHelp)
        MESSAGE_HANDLER(WM_CONTEXTMENU, OnContextMenu);
        COMMAND_ID_HANDLER(IDD_PARAMS_EDIT, OnEdit)
        COMMAND_ID_HANDLER(IDD_PARAMS_DROP, OnDrop)
        COMMAND_ID_HANDLER(IDD_PARAMS_PRESENT, OnPresent)
        COMMAND_ID_HANDLER(IDD_PARAMS_NOT_PRESENT, OnPresent)
        COMMAND_ID_HANDLER(IDD_PARAMS_LIST, OnList)
        NOTIFY_CODE_HANDLER(PSN_APPLY, OnApply)
        NOTIFY_CODE_HANDLER(PSN_KILLACTIVE, OnKillActive)
    END_MSG_MAP()

    CAdvanced ();
    ~CAdvanced();
    VOID DestroyPageCallbackHandler()
    {
        delete this;
    }

    BOOL FValidateAllParams(BOOL fDisplayUI);
    VOID Apply();
    HPROPSHEETPAGE CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid);

    // ATL message handlers
    LRESULT OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled);
    LRESULT OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                          BOOL& fHandled);
    LRESULT OnEdit(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnDrop(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnPresent(WORD wNotifyCode, WORD wID,
                      HWND hWndCtl, BOOL& fHandled);
    LRESULT OnList(WORD wNotifyCode, WORD wID,
                   HWND hWndCtl, BOOL& fHandled);
    LRESULT OnInitDialog(UINT uMsg, WPARAM wParam,
                                    LPARAM lParam, BOOL& fHandled);
    LRESULT OnDestroy(UINT uMsg, WPARAM wParam,
                         LPARAM lParam, BOOL& fHandled);
    LRESULT OnHelp(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& fHandled);

private:
    // UI controls
    CListBox *    m_plbParams;   // see listbox.h for class defn
    CEdit *       m_pedtEdit;    // see listbox.h for class defn
    CComboBox *   m_pcbxDrop;    // see listbox.h for class defn
    CButton *     m_pbmPresent;  // present radio button
    CButton *     m_pbmNotPresent; // not present radio button
    HWND          m_hwndSpin;       // spin control
    HWND          m_hwndPresentText; // Text for use with KeyOnly type

    HKEY          m_hkRoot;        // instance root
    int           m_nCurSel;        // current item
    CTLTYPE       m_ctlControlType;       // control type
    CValue        m_vCurrent;         // control param value
    BOOL          m_fInitializing;

    // private methods
    VOID FillParamListbox();
    VOID SelectParam();
    VOID SetParamRange();
    VOID UpdateParamDisplay();
    VOID UpdateDisplay();
    VOID GetParamValue();
    int EnumvalToItem(const PWSTR psz);
    int ItemToEnumval(int iItem, PWSTR psz, UINT cb);
    VOID BeginEdit();
    BOOL FValidateCurrParam();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\global.h ===
#pragma once

// default parameter values
static const WCHAR c_szRegParamDefault[] =  L"Default";

// Required param info
static const WCHAR c_szRegParamDesc[] =  L"ParamDesc";
static const WCHAR c_szRegParamType[] =  L"Type";

// Values for "Type"
static const WCHAR c_szRegParamTypeInt[] =     L"int";
static const WCHAR c_szRegParamTypeLong[] =    L"long";
static const WCHAR c_szRegParamTypeWord[] =    L"word";
static const WCHAR c_szRegParamTypeDword[] =   L"dword";
static const WCHAR c_szRegParamTypeEnum[] =    L"enum";
static const WCHAR c_szRegParamTypeEdit[] =    L"edit";
static const WCHAR c_szRegParamTypeKeyonly[] = L"keyonly";

// General parameter info
static const WCHAR c_szRegParamOptional[] =   L"Optional";
static const WCHAR c_szRegParamHelpFile[] =   L"HelpFile";
static const WCHAR c_szRegParamHelpContext[] = L"HelpContext";

// Ranges for numeric types
static const WCHAR c_szRegParamBase[] =       L"Base";
static const WCHAR c_szRegParamStep[] =       L"Step";
static const WCHAR c_szRegParamMin[] =        L"Min";
static const WCHAR c_szRegParamMax[] =        L"Max";
static const WCHAR c_szRegParamMultiplier[] = L"";
static const WCHAR c_szRegParamParagraph[] =  L"Paragraph";

// Styles for edit types
static const WCHAR c_szRegParamLimitText[] = L"LimitText";
static const WCHAR c_szRegParamOEMText[] =   L"OEMText";
static const WCHAR c_szRegParamUppercase[] = L"Uppercase";
static const WCHAR c_szRegParamReadOnly[] =  L"ReadOnly";
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\advpage.cpp ===
//+--------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       A D V P A G E . C P P
//
//  Contents:   Contains the advanced page for enumerated net class devices
//
//  Notes:
//
//  Author:     nabilr   16 Mar 1997
//
//  History:    BillBe (24 June 1997) Took over ownership
//
//---------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "advpage.h"
#include "pagehelp.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "ncui.h"

const DWORD c_cchMaxRegStrLen = 256;

// name of Answerfile section that contains our Additional (adapter-specific)
// parameters.
static const WCHAR c_szDevMgrHelpFile[] = L"devmgr.hlp";

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::CAdvanced (constructor)
//
//  Purpose:    Init some variables.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      The bulk of the setting up occurs in FInit().
//
CAdvanced::CAdvanced()
:   m_plbParams(NULL),
    m_pedtEdit(NULL),
    m_pcbxDrop(NULL),
    m_pbmPresent(NULL),
    m_pbmNotPresent(NULL),
    m_hwndSpin(NULL),
    m_hwndPresentText(NULL),
    m_nCurSel(0),
    m_ctlControlType(CTLTYPE_UNKNOWN),
    m_fInitializing(FALSE)
{
}

//+--------------------------------------------------------------------------
//
//  Member:     CAdvanced::CreatePage
//
//  Purpose:    Creates the advanced page only if there is information
//                  to populate the ui
//
//  Arguments:
//      hdi    [in] SetupApi HDEVINFO for device
//      pdeid  [in] SetupApi PSP_DEVINFO_DATA for device
//
//  Returns:    HPROPSHEETPAGE
//
//  Author:     billbe 1 Jul 1997
//
//  Notes:
//
HPROPSHEETPAGE
CAdvanced::CreatePage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    HPROPSHEETPAGE hpsp = NULL;

    if (SUCCEEDED(HrInit(hdi, pdeid)))
    {
        hpsp = CPropSheetPage::CreatePage(DLG_PARAMS, 0);
    }

    return hpsp;

}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnInitDialog
//
//  Purpose:    Handler for the WM_INITDIALOG windows message.  Initializes
//              the dialog window.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
//
LRESULT CAdvanced::OnInitDialog(UINT uMsg, WPARAM wParam,
                                LPARAM lParam, BOOL& fHandled)
{
    const       WCHAR * szText;

    // We are initializing the property page
    m_fInitializing = TRUE;

    // Control Pointers
    m_plbParams = new CListBox(m_hWnd, IDD_PARAMS_LIST);

    if (m_plbParams == NULL)
	{
		return(0);
	}

    m_pedtEdit = new CEdit(m_hWnd, IDD_PARAMS_EDIT);
    m_pcbxDrop = new CComboBox(m_hWnd, IDD_PARAMS_DROP);

    m_pbmPresent = new CButton(m_hWnd, IDD_PARAMS_PRESENT);
    m_pbmNotPresent = new CButton(m_hWnd, IDD_PARAMS_NOT_PRESENT);

    m_hwndSpin        = GetDlgItem(IDD_PARAMS_SPIN);
    Assert(m_hwndSpin);
    m_hwndPresentText = GetDlgItem(IDD_PARAMS_PRESENT_TEXT);
    Assert(m_hwndPresentText);

    // Fill the parameter list box
    FillParamListbox();

    // No current selection
    m_pparam = NULL;

    // Clear the initial params value
    m_vCurrent.Init(VALUETYPE_INT,0);

    // Check if there are any parameters
    if (m_plbParams->GetCount() > 0)
    {
        // Select the first item
        m_plbParams->SetCurSel(0);
        SelectParam();
    }

    m_fInitializing = FALSE;
    return 0;
}


LRESULT CAdvanced::OnApply(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if (FValidateCurrParam())
    {
        // Show the saved value
        UpdateParamDisplay();

        Apply();
    }

    TraceError("CAdvanced::OnApply",hr);
    return LresFromHr(hr);
}

LRESULT CAdvanced::OnKillActive(int idCtrl, LPNMHDR pnmh, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if (!FValidateCurrParam())
    {
        // Problems with validation.  Keep page from deactivating.
        hr = E_FAIL;
    }

    TraceError("CAdvanced::OnKillActive",hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnEdit(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // If the edit box contents have changed, call BeginEdit
    if (wNotifyCode == EN_CHANGE)
    {
        BeginEdit();
    }

    TraceError("CAdvanced::OnEdit", hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnDrop(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    // If the combo box contents have changed and we are not initializing
    // (i.e. the user changed it, we didn't) then notify the property
    // sheet
    if ((wNotifyCode == CBN_SELCHANGE) && !m_fInitializing)
    {
        // selection in dropdownbox has changed
        SetChangedFlag();
        BeginEdit();
    }

    TraceError("CAdvanced::OnDrop", hr);
    return LresFromHr(hr);
}


LRESULT CAdvanced::OnPresent(WORD wNotifyCode, WORD wID,
                                 HWND hWndCtl, BOOL& fHandled)
{
    HRESULT hr = S_OK;

    if ((wID == IDD_PARAMS_PRESENT && !m_pbmPresent->GetCheck()) ||
        (wID == IDD_PARAMS_NOT_PRESENT && !m_pbmNotPresent->GetCheck() ))
    {
        // selection has changed
        // change the value
        if (wID == IDD_PARAMS_PRESENT)
        {
            m_vCurrent.SetPresent(TRUE);
        }
        else
        {
            GetParamValue();
            m_vCurrent.SetPresent(FALSE);
        }

        // Update the value
        UpdateParamDisplay();

    }

    TraceError("CAdvanced::OnPresent", hr);
    return LresFromHr(hr);
}

LRESULT CAdvanced::OnList(WORD wNotifyCode, WORD wID,
                          HWND hWndCtl, BOOL& fHandled)
{
    LRESULT lr = 0;

    // Changes the listbox selection.  If current value is not
    // valid, then the selection is not changed.
    // Work to do only if selection changes
    if (wNotifyCode == LBN_SELCHANGE)
    {
        // Accept the current value.
        // If it isn't valid, change the selection back
        if (!FValidateCurrParam())
        {
            m_plbParams->SetCurSel(m_plbParams->FindItemData(0, m_pparam));
            // We handled things so set lr to 1;
            lr = 1;
        }
        else
        {
            // Select the new param
            SelectParam();
        }
    }

    return lr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnDestroy
//
//  Purpose:    Handles the WM_DESTROY message.  Does general memory
//              releasing and registry key closing.  See ATL docs.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
LRESULT CAdvanced::OnDestroy(UINT uMsg, WPARAM wParam,
                             LPARAM lParam, BOOL& fHandled)
{
    HRESULT hr = S_OK;
    int cItems, iItem;
    WCHAR *  sz;

    // Clean up memory from list boxes
    AssertSz(m_pcbxDrop, "Combo box should have been created!");
    cItems = m_pcbxDrop->GetCount();
    for (iItem=0; iItem < cItems; iItem++)
    {
        sz = static_cast<WCHAR *>(m_pcbxDrop->GetItemData(iItem));
        delete sz;
    }
    m_pcbxDrop->ResetContent();


    // Clean up
    m_vCurrent.Destroy();

    // Clean up window elements
    delete m_plbParams;
    m_plbParams = NULL;
    delete m_pedtEdit;
    m_pedtEdit = NULL;
    delete m_pcbxDrop;
    m_pcbxDrop = NULL;
    delete m_pbmPresent;
    m_pbmPresent = NULL;
    delete m_pbmNotPresent;
    m_pbmNotPresent = NULL;

    TraceError("CAdvanced::OnDestroy",hr);
    return LresFromHr(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::OnHelp
//
//  Purpose:    Handler for the WM_HELP windows message.
//
//  Author:     BillBe   01 Jul 1998
//
//  Notes:
//
//
LRESULT CAdvanced::OnHelp(UINT uMsg, WPARAM wParam,
                          LPARAM lParam, BOOL& fHandled)
{
    LRESULT lr = 0;
    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    Assert(lphi);

    if (HELPINFO_WINDOW == lphi->iContextType)
    {
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), c_szDevMgrHelpFile,
                HELP_WM_HELP, reinterpret_cast<UINT_PTR>(g_aHelpIds));
        lr = 1;
    }

    return lr;
}

LRESULT CAdvanced::OnContextMenu(UINT uMsg, WPARAM wParam, LPARAM lParam,
                                 BOOL& fHandled)
{
    ::WinHelp(reinterpret_cast<HWND>(wParam), c_szDevMgrHelpFile,
            HELP_CONTEXTMENU, reinterpret_cast<UINT_PTR>(g_aHelpIds));

    return TRUE;
}

CAdvanced::~CAdvanced()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::Apply
//
//  Purpose:    Applies values from InMemory storage. to the registry
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::Apply()
{
    if (FSave())
    {
        SP_DEVINSTALL_PARAMS deip;
        // Set the properties change flag in the device info to
        // let the property page host know that the property change function
        // shuld be sent to the driver
        // We can't let any failures here stop us so we ignore
        // return values
        (void) HrSetupDiGetDeviceInstallParams(m_hdi, m_pdeid, &deip);
        deip.FlagsEx |= DI_FLAGSEX_PROPCHANGE_PENDING;
        (void) HrSetupDiSetDeviceInstallParams(m_hdi, m_pdeid, &deip);
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::FillParamListbox
//
//  Purpose:    Populates the UI's parameter listbox using the parameters
//              from m_listpParam.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::FillParamListbox()
{
    vector<CParam *>::iterator ppParam;
    INT        iItem;
    WCHAR      szRegValue[c_cchMaxRegStrLen];

    m_plbParams->ResetContent();

    for (ppParam = m_listpParam.begin(); ppParam != m_listpParam.end();
         ppParam++)
    {
        Assert (*ppParam != NULL);

        // Get text string
        (*ppParam)->GetDescription(szRegValue,celems(szRegValue));

        // Add the description string to the listbox
        iItem = m_plbParams->AddString(szRegValue);
        if (iItem >= 0)
        {
            m_plbParams->SetItemData(iItem,*ppParam);
        }
    }
}


//
//  FValidateCurrParam
//
//  Purpose:
//      Validates the current parameter.  Displays UI and reverts back to
//      original value on error.
//
//  Parameters:
//      None - validates the param currently being edited.
//
//  Notes:
//      How is this different from FValidateSingleParam?  This function
//      is intended to be used when the user is interacting with the
//      current param.  If there's an error with the current parameter,
//      the parameter is reverted back to it's old value (before the user's
//      changes).
//$ REVIEW (t-nabilr) Is it good to revert the user's changes on error?
//                      (see above)
//
BOOL CAdvanced::FValidateCurrParam()
{
    CValue   vPrevious;
    BOOL    fRetval = FALSE;

    // Save the previous param value - so we can restore it
    // if the control value is invalid
    vPrevious.InitNotPresent(m_pparam->GetType());
    vPrevious.Copy(m_pparam->GetValue());

    // Get the current control value and validate it
    GetParamValue();
    m_pparam->GetValue()->Copy(&m_vCurrent);

    if (FValidateSingleParam(m_pparam, TRUE, m_hWnd))
    {
        // Update the modified bit
        m_pparam->SetModified(
            (m_pparam->GetValue()->Compare(m_pparam->GetInitial()) != 0));

        fRetval = TRUE;
    }

    // Restore the original value if there was an error
    if (!fRetval)
        m_pparam->GetValue()->Copy(&vPrevious);
    // Cleanup
    vPrevious.Destroy();

    return fRetval;
}

//  UpdateDisplay
//
//  Purpose:
//      Sets up the screen to display -- and displays -- the current param.
//      Changes the UI's control type, etc.
//
VOID CAdvanced::UpdateDisplay()
{
    int cItems;
    WCHAR * psz;
    // Clean up memory from list boxes
    cItems = m_pcbxDrop->GetCount();
    for (int iItem=0; iItem < cItems; iItem++)
    {
        psz = (WCHAR *)m_pcbxDrop->GetItemData(iItem);
        delete psz;
    }
    m_pcbxDrop->ResetContent();

    // set appropriate Control Type
    switch (m_pparam->GetType())
    {
    case VALUETYPE_ENUM:
        m_ctlControlType = CTLTYPE_DROP;
        break;

    case VALUETYPE_EDIT:
        m_ctlControlType = CTLTYPE_EDIT;
        break;

    case VALUETYPE_DWORD:
        // The spin control only fits up to signed 32-bit values
        // So we must use an edit control for larger numbers
        if (m_pparam->GetMax()->GetDword() > LONG_MAX)
        {
            m_ctlControlType = CTLTYPE_EDIT;
        }
        else
        {
            m_ctlControlType = CTLTYPE_SPIN;
        }
        break;

    case VALUETYPE_KONLY:
        m_ctlControlType = CTLTYPE_NONE;
        break;

    default:
        m_ctlControlType = CTLTYPE_SPIN;
    }
    // Hide all controls
    m_pedtEdit->Show(FALSE);
    m_pcbxDrop->Show(FALSE);
    ::ShowWindow(m_hwndSpin,SW_HIDE);
    ::ShowWindow(m_hwndPresentText,SW_HIDE);
    // Show the appropriate control
    switch (m_ctlControlType)
    {
    case CTLTYPE_EDIT:
        m_pedtEdit->Show(TRUE);
        break;

    case CTLTYPE_DROP:
        m_pcbxDrop->Show(TRUE);
        break;

    case CTLTYPE_SPIN:
        m_pedtEdit->Show(TRUE);
        ::ShowWindow(m_hwndSpin,SW_NORMAL);
        break;

    case CTLTYPE_NONE:
        ::ShowWindow(m_hwndPresentText,SW_NORMAL);
        break;

    default:
        AssertSz(FALSE, "Invalid Control Type");
    }

    // Show the "optional" radio buttons
    if (m_pparam->FIsOptional())
    {
        m_pbmPresent->Show(TRUE);
        m_pbmNotPresent->Show(TRUE);
    }
    else
    {
        m_pbmPresent->Show(FALSE);
        m_pbmNotPresent->Show(FALSE);
    }

    SetParamRange();
    // show the param's value
    UpdateParamDisplay();
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::SelectParam
//
//  Purpose:    Takes the parameter selection from the listbox
//              and makes it the current parameter.  The display is updated
//              to show the newly selected parameter.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::SelectParam()
{
    int         nCurSel;
    register    CParam *pparam;
    int         cItems, iItem;
    PSTR        psz;


    // Determine the new parameter list selection
    nCurSel = m_plbParams->GetCurSel();
    if (nCurSel >= 0)
    {
        // Get the new current parameter
        pparam = (CParam *)m_plbParams->GetItemData(nCurSel);
        Assert(pparam != NULL);

        // only do work if it's not the same parameter.
        if (pparam != m_pparam)
        {
            m_pparam = pparam;
            m_vCurrent.Destroy();
            m_vCurrent.InitNotPresent(m_pparam->GetType());
            m_vCurrent.Copy(m_pparam->GetValue());
            // show the param
            UpdateDisplay();
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::SetParamRange
//
//  Purpose:
//      Sets "range" values for the current param, depending on it's type.
//      For enum values, it reads the enums into a dropbox.
//      For spin control, it sets the min/max and acceleration values.
//      For edit box, it sets the edit style.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::SetParamRange()
{
    DWORD       cbValue;
    DWORD       dwType;
    DWORD       dwStyle;
    DWORD       iValue;
    int         iItem;
    #define     NUM_UDACCELS 3
    UDACCEL     aUDAccel[NUM_UDACCELS];
    UINT        uBase;
    WCHAR *     pszValueName;
    WCHAR       szRegValueName[c_cchMaxRegStrLen];
    DWORD       cchRegValueName;
    WCHAR       szRegValue[c_cchMaxRegStrLen];
    HRESULT hr = S_OK;

    // We are initializing so we need to set a flag so the UI doesn't think
    // it's the user who is changing things
    m_fInitializing = TRUE;

    switch (m_ctlControlType)
    {
    case CTLTYPE_DROP:

        // Reset the combobox
        m_pcbxDrop->ResetContent();

        for (iValue = 0; SUCCEEDED(hr); iValue++)
        {
            cchRegValueName = celems(szRegValueName);
            cbValue = sizeof(szRegValue);

            hr = HrRegEnumValue(m_pparam->GetEnumKey(), iValue, szRegValueName,
                                &cchRegValueName,
                                &dwType, (BYTE *)szRegValue, &cbValue);

            if (SUCCEEDED(hr) && dwType == REG_SZ)
            {
                TraceTag(ttidNetComm, "Enum String %S index %d",
                         szRegValueName, iValue);

                // Got the next registry value, and it's a string.
                pszValueName = new WCHAR[wcslen(szRegValueName) + 1];

				if (pszValueName == NULL)
				{
					break;
				}

                lstrcpyW(pszValueName,szRegValueName);

                // Add the text string
                iItem = m_pcbxDrop->AddString(szRegValue);

                if (iItem >= 0)
                {
                    m_pcbxDrop->SetItemData(iItem,pszValueName);
                }
                else
                {
                    delete pszValueName;
                }
            }
        }
        break;

    case CTLTYPE_SPIN:
        int     nStep;
        int     nMin;
        int     nMax;

        // Set the numeric base
        uBase = m_pparam->GetValue()->IsHex() ? 16 : 10;
        ::SendMessage(m_hwndSpin,UDM_SETBASE,(WPARAM)uBase,0L);

        nStep = m_pparam->GetStep()->GetNumericValueAsDword();
        nMin = m_pparam->GetMin()->GetNumericValueAsSignedInt();
        nMax = m_pparam->GetMax()->GetNumericValueAsSignedInt();

        ::SendMessage(m_hwndSpin,UDM_SETRANGE32, nMin, nMax);

        // Set the range-accelerator values
        aUDAccel[0].nSec = 0;
        aUDAccel[0].nInc = nStep;
        aUDAccel[1].nSec = 1;
        aUDAccel[1].nInc = 2 * nStep;
        aUDAccel[2].nSec = 3;
        aUDAccel[2].nInc = uBase * nStep;

        ::SendMessage(m_hwndSpin, UDM_SETACCEL,NUM_UDACCELS,
                      (LPARAM)(LPUDACCEL)aUDAccel);

        break;


    case CTLTYPE_EDIT:

        m_pedtEdit->LimitText(m_pparam->GetLimitText());

        dwStyle = m_pedtEdit->GetStyle();
        if (m_pparam->FIsUppercase())
            dwStyle |= ES_UPPERCASE;
        else
            dwStyle &= ~ES_UPPERCASE;
        if (m_pparam->FIsOEMText())
            dwStyle |= ES_OEMCONVERT;
        else
            dwStyle &= ~ES_OEMCONVERT;
        if (m_pparam->FIsReadOnly())
            dwStyle |= ES_READONLY;
        else
            dwStyle &= ~ES_READONLY;
        m_pedtEdit->SetStyle(dwStyle);
        break;

    case CTLTYPE_NONE:
        break;

    default:
        AssertSz(FALSE,"Hit default case in CAdvanced::SetParamRange");
    }
    m_fInitializing = FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::UpdateParamDisplay
//
//  Purpose:    Updates the value of the parameter on the UI.  Used when
//              the param value has progmatically changed, and needs to be
//              updated on the UI.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:      You could use UpdateDisplay to refresh the param value, but
//              UpdateDisplay() does a lot of extra work such as setting
//              the control type.  (BTW, UpdateDisplay calls
//              UpdateParamDisplay().)
//
VOID CAdvanced::UpdateParamDisplay()  // was SetParam
{
    WCHAR   szValue[VALUE_SZMAX];
    int     iItem;

    // We are initializing so we need to set a flag so the UI doesn't think
    // it's the user who is changing things
    m_fInitializing = TRUE;

    // Set present/not present radio button.
    // If an optional value is not present, clear the control and return.
    Assert(m_pparam);
    if (m_pparam->FIsOptional())
    {
        m_pbmPresent->SetCheck(m_vCurrent.IsPresent());
        m_pbmNotPresent->SetCheck(!m_vCurrent.IsPresent());
    }

    // Show/Hide the parameter
    if (!m_pparam->FIsOptional() || m_vCurrent.IsPresent())
    {
        // Show the value
        switch (m_ctlControlType)
        {
        case CTLTYPE_SPIN:
            {
                // The spin control message UDM_SETPOS only handles 16-bit
                // numbers even though the control can handle 32 bit ranges.
                // This means we need to set the number by using the buddy
                // window.
                //
                WCHAR szNumber[c_cchMaxNumberSize];
                m_vCurrent.ToString(szNumber, c_cchMaxNumberSize);
                HWND hwndBuddy = reinterpret_cast<HWND>(::SendMessage(m_hwndSpin,
                                                                 UDM_GETBUDDY,
                                                                 0,
                                                                 0));
                ::SetWindowText(hwndBuddy, szNumber);
            }
            break;

        case CTLTYPE_DROP:
            iItem = EnumvalToItem(m_vCurrent.GetPsz());
            m_pcbxDrop->SetCurSel(iItem);
            break;

        case CTLTYPE_EDIT:
            m_vCurrent.ToString(szValue,VALUE_SZMAX);
            m_pedtEdit->SetText(szValue);
            break;

        case CTLTYPE_NONE:
            break;

        default:
            AssertSz(FALSE,"Invalid control type in function UpdateParamDisplay");
        }
    }
    else
    {
        // Hide the value
        switch (m_ctlControlType)
        {
        case CTLTYPE_EDIT:
        case CTLTYPE_SPIN:
            m_pedtEdit->SetText(L"");
            break;

        case CTLTYPE_DROP:
            m_pcbxDrop->SetCurSel(CB_ERR);
            break;

        case CTLTYPE_NONE:
            break;

        default:
            Assert(FALSE); //DEBUG_TRAP;
        }
    }

    // Remove inhibition
    m_fInitializing = FALSE;

}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::GetParamValue
//
//  Purpose:    Gets the value of the current parameter from the UI and puts
//              in in m_vCurrent.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
VOID CAdvanced::GetParamValue()
{
    WCHAR    szValue[VALUE_SZMAX];
    int     iItem;

    // Get the "present" value for an optional param
    if (m_pparam->FIsOptional() && !m_pbmPresent->GetCheck())
    {
        m_vCurrent.SetPresent(FALSE);

        // Not present - don't read the control value
        return;
    }

    // The value is present
    m_vCurrent.SetPresent(TRUE);

    // Get the control value
    switch (m_ctlControlType)
    {

    case CTLTYPE_SPIN:
        {
            // The spin control can handle 32-bit ranges but the message
            // UDM_GETPOS will only return a 16-bit number.  This means we
            // should get the number from the buddy window if we want the
            // exact value.
            //
            WCHAR szBuffer[c_cchMaxNumberSize];
            HWND hwndBuddy = reinterpret_cast<HWND>(::SendMessage(m_hwndSpin,
                                                             UDM_GETBUDDY,
                                                             0,
                                                             0));
            ::GetWindowText(hwndBuddy, szBuffer, c_cchMaxNumberSize);
            m_vCurrent.FromString(szBuffer);
        }
        break;


    case CTLTYPE_EDIT:
        m_pedtEdit->GetText(szValue, VALUE_SZMAX);
        m_vCurrent.FromString(szValue);
        break;

    case CTLTYPE_DROP:
        iItem = m_pcbxDrop->GetCurSel();
        if (iItem == CB_ERR)
            break;
        ItemToEnumval(iItem,szValue,VALUE_SZMAX);
        m_vCurrent.FromString(szValue);
        break;

    case CTLTYPE_NONE:
        break;              // No data to return (present/not present is all were interested in)

    default:
       Assert(FALSE);// DEBUG_TRAP;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::EnumvalToItem
//
//  Purpose:    Converts a combobox string into an integer representing the
//              location withing the drop down combobox (for enums).
//
//  Arguments:
//      psz      [in]       string to look for.
//
//  Returns:    Combobox item number where this string can be found.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
int CAdvanced::EnumvalToItem(const PWSTR psz)
{
    int     cItems;
    int     iItem;
    PWSTR   pszValueName;

    Assert(m_pparam->GetType() == VALUETYPE_ENUM);
    cItems = m_pcbxDrop->GetCount();
    for (iItem = 0; iItem < cItems; iItem++)
    {
        pszValueName = (PWSTR)m_pcbxDrop->GetItemData (iItem);
        if (lstrcmpiW (pszValueName,psz) == 0)
        {
            return iItem;
        }
    }

    // Not found.
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::ItemToEnumval
//
//  Purpose:    Converts the item number within the combobox dropdown
//              into a string.
//
//  Arguments:
//      iItem    [in]       item number within combobox.
//      psz      [out]      ptr to string to populate
//      cch      [in]       length (characters) of psz buffer.
//
//  Returns:    length of string (# of characters) put in psz.
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//
int CAdvanced::ItemToEnumval(int iItem, PWSTR psz, UINT cch)
{
    PWSTR    pszValueName;

    pszValueName = (PWSTR)m_pcbxDrop->GetItemData (iItem);
    if ((PWSTR)CB_ERR == pszValueName)
    {
        return 0;
    }
    lstrcpynW (psz,pszValueName,cch);
    return lstrlenW (psz);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAdvanced::
//
//  Purpose:
//
//  Arguments:
//      nID      [in]       ID of thingy.
//      fInstall [in]       TRUE if installing, FALSE otherwise.
//      ppv      [in,out]   Old value is freed and this returns new value.
//
//  Returns:
//
//  Author:     t-nabilr   06 Apr 1997
//
//  Notes:
//


VOID CAdvanced::BeginEdit()
{
    // Check if we need to update the radio buttons
    if (!m_fInitializing)
    {
        SetChangedFlag();
        if (m_vCurrent.IsPresent() == FALSE)
        {
            // we've begun editing, so select the present radiobutton
            m_vCurrent.SetPresent(TRUE);
            m_pbmPresent->SetCheck(1);
            m_pbmNotPresent->SetCheck(0);
        }
    }

}



//+---------------------------------------------------------------------------
//
//  Function:   HrGetAdvancedPage
//
//  Purpose:    Creates the advanced page for enumerated net devices
//                  This is called by NetPropPageProvider
//
//  Arguments:
//      hdi     [in]   See SetupApi for info
//      pdeid   [in]   See SetupApi for for info
//      phpsp   [out]  Pointer to the handle to the advanced property page
//
//  Returns:
//
//  Author:     billbe 24 June 1997
//
//  Notes:
//
HRESULT
HrGetAdvancedPage(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                  HPROPSHEETPAGE* phpsp)
{
    Assert(hdi);
    Assert(pdeid);
    Assert(phpsp);

    HRESULT hr;
    HPROPSHEETPAGE hpsp;

    CAdvanced* padv = new CAdvanced();

    // create the advanced page
    hpsp = padv->CreatePage(hdi, pdeid);

    // if successful set the out param
    if (hpsp)
    {
        *phpsp = hpsp;
        hr = S_OK;
    }
    else
    {
        // Either there is no advanced page to display or there
        // was an error.
        hr = E_FAIL;
        *phpsp = NULL;
        delete padv;
    }

    TraceErrorOptional("HrGetAdvancedPage", hr, E_FAIL == hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\hwres.h ===
#pragma once
#include "netcfgx.h"
#include "global.h"
#include "param.h"

const int c_nMaxLCStrLen = 128;
const int c_nMaxResStrLen = 50;
const int c_nMaxResCtls = 4;

// Holds a possible IRQ value.
typedef struct tagIRQ_LIST_ELEMENT {
    DWORD dwIRQ;      // A possible value for the IRQ.
    BOOL  fConflict;  // Is there a conflict with another device?
    BOOL  fAllocated; // Is this the IRQ we're currently allocated?
} IRQ_LIST_ELEMENT, *PIRQ_LIST_ELEMENT;

// Holds a possible DMA value.
typedef struct tagDMA_LIST_ELEMENT {
    DWORD dwDMA;      // A possible value for the DMA.
    BOOL  fConflict;  // Is there a conflict with another device?
    BOOL  fAllocated; // Is this the IRQ we're currently allocated?
} DMA_LIST_ELEMENT, *PDMA_LIST_ELEMENT;

// Holds a possible IO base/end pair.
typedef struct tagIO_LIST_ELEMENT {
    DWORD dwIO_Base;
    DWORD dwIO_End;
    BOOL fConflict;
    BOOL fAllocated;
} IO_LIST_ELEMENT, *PIO_LIST_ELEMENT;

// Holds a possible Mem base/end pair.
typedef struct tagMEM_LIST_ELEMENT {
    DWORD dwMEM_Base;
    DWORD dwMEM_End;
    BOOL fConflict;
    BOOL fAllocated;
} MEM_LIST_ELEMENT, *PMEM_LIST_ELEMENT;


// Define the different types of lists.
typedef vector<PIRQ_LIST_ELEMENT>  IRQ_LIST;
typedef IRQ_LIST* PIRQ_LIST;
typedef vector<PDMA_LIST_ELEMENT> DMA_LIST;
typedef DMA_LIST* PDMA_LIST;
typedef vector<PIO_LIST_ELEMENT> IO_LIST;
typedef IO_LIST* PIO_LIST;
typedef vector<PMEM_LIST_ELEMENT> MEM_LIST;
typedef MEM_LIST* PMEM_LIST;


typedef struct {
    RESOURCEID ResourceType;
    RES_DES ResDes;
    union {
        PIRQ_LIST pIRQList;  // These really are STL vectors
        PDMA_LIST pDMAList;
        PIO_LIST  pIOList;
        PMEM_LIST pMEMList;
    };
    size_t pos;  // current index within vector
    size_t applied_pos; // pos that was last applied (the "in-memory" state);
} RESOURCE, *PRESOURCE;

typedef struct tagCONFIGURATION {
    LOG_CONF LogConf;
    BOOL fBoot;
    BOOL fAlloc;
    RESOURCE aResource[c_nMaxResCtls];
    UINT cResource; // number of elements in aResource;
} CONFIGURATION, *PCONFIGURATION;

typedef vector<PCONFIGURATION> CONFIGURATION_LIST;


class CHwRes {
public:

    CHwRes();
    ~CHwRes();
    HRESULT HrInit(const DEVNODE& devnode);
    VOID UseAnswerFile(const WCHAR * const szAnswerfile,
                       const WCHAR * const szSection);
    HRESULT HrValidateAnswerfileSettings(BOOL fDisplayUI);
    BOOL FCommitAnswerfileSettings();


private:
    CONFIGURATION_LIST   m_ConfigList;
    RESOURCE             m_Resource[c_nMaxResCtls];

    // Config Manager stuff
    DEVNODE              m_DevNode;  // devnode for this netcard

    // COM stuff
    INetCfgComponent* m_pnccItem;

    // state flags
    BOOL m_fInitialized;
    BOOL m_fHrInitCalled;
    BOOL m_fDirty;     // Do we need to save?

    // holds answerfile values
    CValue m_vAfDma;
    CValue m_vAfIrq;
    CValue m_vAfMem;
    CValue m_vAfIo;
    CValue m_vAfMemEnd;
    CValue m_vAfIoEnd;

private:
    HRESULT HrInitConfigList ();
    BOOL FInitResourceList(PCONFIGURATION pConfiguration);
    VOID InitIRQList(PIRQ_LIST* ppIRQList, PIRQ_RESOURCE pIRQResource);
    VOID InitDMAList(PDMA_LIST* ppDMAList, PDMA_RESOURCE pDMAResource);
    VOID InitMEMList(PMEM_LIST* ppMEMList, PMEM_RESOURCE pMEMResource);
    VOID InitIOList(PIO_LIST* ppIOList, PIO_RESOURCE pIOResource);
    VOID GetNextElement(PRESOURCE pResource, PVOID *ppeList, BOOL fNext);
    BOOL FValidateAnswerfileResources();
    BOOL FCreateBootConfig(
        CValue * pvMEM,
        CValue * pvMEMEnd,
        CValue * pvIO,
        CValue * pvIOEnd,
        CValue * pvDMA,
        CValue * pvIRQ);
    BOOL FValidateIRQ(PCONFIGURATION pConfig, ULONG ulIRQ);
    BOOL FValidateDMA(PCONFIGURATION pConfig, ULONG ulDMA);
    BOOL FGetIOEndPortGivenBasePort(PCONFIGURATION pConfig, DWORD dwBase,
                                   DWORD* pdwEnd);
    BOOL FGetMEMEndGivenBase(PCONFIGURATION pConfig, DWORD dwBase,
                            DWORD* pdwEnd);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\netobj.cpp ===
#include "pch.h"
#pragma hdrstop
#include "advanced.h"
#include "hwres.h"
#include "ncreg.h"
#include "ncsetup.h"
#include "netcomm.h"
#include "netsetup.h"


HRESULT
HrDoOemUpgradeProcessing(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid,
                         PCWSTR pszAnswerFile, PCWSTR pszAnswerSections)
{
    // Open the driver key
    //
    HKEY hkey;
    HRESULT hr = HrSetupDiOpenDevRegKey(hdi, pdeid,
            DICS_FLAG_GLOBAL, 0, DIREG_DRV, KEY_ALL_ACCESS,
            &hkey);

    if (S_OK == hr)
    {
        TraceTag(ttidNetComm, "Calling OEM Upgrade Code");
        hr = HrOemUpgrade (hkey, pszAnswerFile, pszAnswerSections);
        RegCloseKey(hkey);
    }

    TraceError("HrDoOemUpgradeProcessing", hr);
    return hr;
}

VOID
UpdateAdvancedParametersIfNeeded(HDEVINFO hdi, PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;

    // initialize advanced params class.  This will load parameters and check
    // if current values exist.  For each parameter with no current value,
    // a modifed flag is set which will cause the default to be written
    // as the current value on FSave.
    //
    if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
    {
        // Save any modified values.
        (void) Advanced.FSave();
    }
}

BOOL
ProcessAnswerFile(
    PCWSTR pszAnswerFile,
    PCWSTR pszAnswerSections,
    HDEVINFO hdi,
    PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;
    BOOL fAdvanced = FALSE;
    BOOL fResources = FALSE;
    BOOL fModified = FALSE;

    if (pszAnswerFile && pszAnswerSections)
    {
        CHwRes Resources;

        HRESULT hr = Resources.HrInit(pdeid->DevInst);

        // Only continue to use the HwRes class if S_OK is returned.
        //
        if (S_OK == hr)
        {
            Resources.UseAnswerFile(pszAnswerFile, pszAnswerSections);
            fResources = TRUE;
        }
        else
        {
            hr = S_OK;
        }

        // initialize
        if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
        {
            // We need the advanced params class.
            fAdvanced = TRUE;
        }


        // If the device has advanced paramters, have the advanced class
        // read the parameters from the answerfile.
        if (fAdvanced)
        {
            Advanced.UseAnswerFile(pszAnswerFile, pszAnswerSections);
        }

        hr = HrDoOemUpgradeProcessing(hdi, pdeid, pszAnswerFile,
                pszAnswerSections);

        if (S_OK == hr)
        {
            fModified = TRUE;
        }

        if (fResources)
        {
            // Validate answerfile params for pResources (hardware resources)
            // and apply if validated.
            hr = Resources.HrValidateAnswerfileSettings(FALSE);
            if (S_OK == hr)
            {
                Resources.FCommitAnswerfileSettings();
                fModified = TRUE;
            }
#ifdef ENABLETRACE
            else
            {
                TraceTag(ttidNetComm, "Error in answerfile concerning "
                        "hardware resources. Base section %S",
                        pszAnswerSections);
            }
#endif
        }

        // Validate the advanced parameters from the answerfile
        // This will attempt to correct bad params.  Even though an
        // error status is returned, it shouldn't stop us and we should
        // still apply changes.
        //
        if (fAdvanced)
        {
            (void) Advanced.FValidateAllParams(FALSE, NULL);
            // Save any advanced params
            fModified = Advanced.FSave();
        }

        TraceError("Netcomm::HrUpdateAdapterParameters",
                (S_FALSE == hr) ? S_OK : hr);
    }

    return fModified;
}

BOOL
FUpdateAdapterParameters(PCWSTR pszAnswerFile,
                         PCWSTR pszAnswerSection,
                         HDEVINFO hdi,
                         PSP_DEVINFO_DATA pdeid)
{
    Assert(IsValidHandle(hdi));
    Assert(pdeid);

    CAdvancedParams Advanced;
    BOOL            fAdvanced = FALSE;
    BOOL            fResources = FALSE;

    // initialize
    if (SUCCEEDED(Advanced.HrInit(hdi, pdeid)))
    {
        // We need the advanced params class
        fAdvanced = TRUE;
    }

    if (pszAnswerFile && pszAnswerSection)
    {
        CHwRes Resources;

        HRESULT hr = Resources.HrInit(pdeid->DevInst);

        // Only continue to use the HwRes class if S_OK is returned,
        // otherwise set a flag to ignore the class (Note: ignore the
        // class on S_FALSE as well)
        if (S_OK == hr)
        {
            Resources.UseAnswerFile(pszAnswerFile, pszAnswerSection);
            fResources = TRUE;
        }
        else
        {
            hr = S_OK;
        }

        // If the device has advanced paramters, have the advanced class
        // read the parameters from the answerfile
        if (fAdvanced)
        {
            Advanced.UseAnswerFile(pszAnswerFile, pszAnswerSection);
        }

        hr = HrDoOemUpgradeProcessing(hdi, pdeid, pszAnswerFile,
                pszAnswerSection);

        if (fResources)
        {
            // Validate answerfile params for pResources (hardware resources)
            // and apply if validated
            hr = Resources.HrValidateAnswerfileSettings(FALSE);
            if (S_OK == hr)
            {
                Resources.FCommitAnswerfileSettings();
            }
#ifdef ENABLETRACE
            else
            {
                TraceTag(ttidNetComm, "Error in answerfile concerning "
                        "hardware resources. Base section %S",
                        pszAnswerSection);
            }
#endif
        }

        // Validate the advanced parameters from the answerfile
        // This will attempt to correct bad params.  Even though an
        // error status is returned, it shouldn't stop us and we should
        // still apply changes
        //
        if (fAdvanced)
        {
            (void) Advanced.FValidateAllParams(FALSE, NULL);
        }

        TraceError("Netcomm::HrUpdateAdapterParameters",
                (S_FALSE == hr) ? S_OK : hr);
    }

    // Save any advanced params
    // Note: we have to do this even if there was no answerfile
    // Since the parameters might have defaults
    if (fAdvanced)
    {
        Advanced.FSave();
    }

    // return TRUE if we had advanced parameters or resources updated
    return (fAdvanced || fResources);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\pagehelp.h ===
// IDs for the advanced tab in device manager snap-in
// Created 2/19/98 by WGruber NTUA and BillBe NTDEV

#define IDH_NOHELP  (DWORD(-1))
#define IDH_devmgr_advanced_property_list   1101    // list box
#define IDH_devmgr_advanced_editbox     1102    // edit box
#define IDH_devmgr_advanced_drop        1103    // dropdown
#define IDH_devmgr_advanced_spin        1104    // spinner control
#define IDH_devmgr_advanced_present     1105    // option button
#define IDH_devmgr_advanced_not_present     1106    // option button


const DWORD g_aHelpIds[]=
{
    IDD_PARAMS_LIST,    IDH_devmgr_advanced_property_list,  // listBox
    IDD_PARAMS_EDIT,    IDH_devmgr_advanced_editbox,    // edit box
    IDD_PARAMS_DROP,    IDH_devmgr_advanced_drop,   // dropdown
    IDD_PARAMS_SPIN,    IDH_devmgr_advanced_spin,   // spinner control
    IDD_PARAMS_PRESENT, IDH_devmgr_advanced_present,    // option button
    IDD_PARAMS_NOT_PRESENT, IDH_devmgr_advanced_not_present,// option button
    IDD_ADVANCED_TEXT,  IDH_NOHELP, // static text
    IDD_PARAMS_PRESENT_TEXT,IDH_NOHELP,     // static text
    IDD_PARAMS_VALUE,   IDH_NOHELP, // static text
    0, 0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\listbox.h ===
#pragma once

// Hungarian: lb
class CListBox
{
private:
    HWND m_hDlgItem;

public:
    CListBox(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    INT GetCount()
    {
        return (int)SendMessage(m_hDlgItem, LB_GETCOUNT, 0L, 0L);
    }

    VOID ResetContent()
    {
        SendMessage(m_hDlgItem, LB_RESETCONTENT, 0L, 0L);
    }

    INT AddString(WCHAR * psz)
    {
        return (int)SendMessage(m_hDlgItem, LB_ADDSTRING, 0L, (LPARAM)psz);
    }

    VOID * GetItemData(INT index)
    {
        return (VOID *)SendMessage(m_hDlgItem, LB_GETITEMDATA, (WPARAM)index, 0L);
    }

    VOID SetItemData(INT index, VOID * data)
    {
        SendMessage(m_hDlgItem, LB_SETITEMDATA, (WPARAM)index, (LPARAM)(data));
    }

    INT FindItemData(INT indexStart, VOID * data)
    {
        // Go through each list item and compare its item data with
        // the data parameter.  Return the index if found or -1 if not
        //
        int nCount = (int)SendMessage(m_hDlgItem, LB_GETCOUNT, 0, 0);

        for (int i = indexStart ; i < nCount; i++)
        {
            if (GetItemData(i) == data)
            {
                return i;
            }
        }

        return -1;
    }

    INT GetCurSel()
    {
        return (int)SendMessage(m_hDlgItem, LB_GETCURSEL, 0L, 0L);
    }

    VOID SetCurSel(int index)
    {
        SendMessage(m_hDlgItem, LB_SETCURSEL, (WPARAM)index, 0L);
    }

};

// Hungarian: bm
class CButton
{
private:
    HWND m_hDlgItem;

public:
    CButton(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    BOOL GetCheck()
    {
        return (BOOL)SendMessage(m_hDlgItem, BM_GETCHECK, 0L, 0L);
    }

    VOID SetCheck(BOOL fCheck)
    {
        SendMessage(m_hDlgItem, BM_SETCHECK, (WPARAM)(fCheck), 0L);
    }
};


// Hungarian: cbx
class CComboBox
{
private:
    HWND m_hDlgItem;

public:
    CComboBox(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    INT GetCount()
    {
        return (int)SendMessage(m_hDlgItem, CB_GETCOUNT, 0L, 0L);
    }

    VOID ResetContent()
    {
        SendMessage(m_hDlgItem, CB_RESETCONTENT, 0L, 0L);
    }

    VOID * GetItemData(INT index)
    {
        return (void *)SendMessage(m_hDlgItem, CB_GETITEMDATA,
                                  (WPARAM)index, 0L);
    }

    VOID SetItemData(INT index, VOID *data)
    {
        SendMessage(m_hDlgItem, CB_SETITEMDATA, (WPARAM)index, (LPARAM)data);
    }

    INT AddString(WCHAR *psz)
    {
        return (INT)SendMessage(m_hDlgItem, CB_ADDSTRING, 0L, (LPARAM)psz);
    }

    INT GetCurSel()
    {
        return (INT)SendMessage(m_hDlgItem, CB_GETCURSEL, 0L, 0L);
    }

    VOID SetCurSel(int index)
    {
        SendMessage(m_hDlgItem, CB_SETCURSEL, (WPARAM)index, 0L);
    }
};


// Hungarian: edt
class CEdit
{
private:
    HWND m_hDlgItem;

public:
    CEdit(HWND hDlg, INT nIDDlgItem)
    {
        m_hDlgItem = GetDlgItem(hDlg, nIDDlgItem);
    }

    VOID Show(BOOL fShow)
    {
        ShowWindow(m_hDlgItem, fShow ? SW_SHOW : SW_HIDE);
    }

    VOID SetStyle(LONG lStyle)
    {
        SetWindowLong(m_hDlgItem, GWL_STYLE, (LONG)lStyle);
    }

    LONG GetStyle()
    {
        return GetWindowLong(m_hDlgItem, GWL_STYLE);
    }

    VOID LimitText(INT cchMax)
    {
        SendMessage(m_hDlgItem, EM_LIMITTEXT, (WPARAM)(cchMax), 0L);
    }

    INT GetText(WCHAR * psz, INT cchMax)
    {
        return GetWindowText(m_hDlgItem, psz, cchMax);
    }

    VOID SetText(WCHAR * psz)
    {
        SetWindowText(m_hDlgItem, psz);
    }
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\config\netcfg\netcomm\hwres.cpp ===
#include "pch.h"
#pragma hdrstop
#include <ncxbase.h>
#include "hwres.h"
#include "kkcwinf.h"
#include "ncreg.h"

extern const WCHAR c_szAfIoAddr[];
extern const WCHAR c_szAfIrq[];
extern const WCHAR c_szAfDma[];
extern const WCHAR c_szAfMem[];
extern const WCHAR c_szBusType[];

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::CHwRes
//
//  Purpose:    Class constructor.  (Variable initialization)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      Doesn't do much.  Just some member variable initialization.
//              Bulk of the init work is done in HrInit().
//
CHwRes::CHwRes()
:   m_DevNode(NULL),
    m_pnccItem(NULL),
    m_fInitialized(FALSE),
    m_fHrInitCalled(FALSE),
    m_fDirty(FALSE)
{
    m_vAfDma.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIrq.InitNotPresent(VALUETYPE_DWORD);
    m_vAfMem.InitNotPresent(VALUETYPE_DWORD);
    m_vAfMemEnd.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIo.InitNotPresent(VALUETYPE_DWORD);
    m_vAfIoEnd.InitNotPresent(VALUETYPE_DWORD);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::HrInit
//
//  Purpose:    Initialize class
//
//  Arguments:
//      hInst    [in]       Handle to our instance.
//      pnccItem [in]       Our INetCfgComponent.
//
//  Returns:    S_OK - init successfull;
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) - no config
//              info for device; E_FAIL - other failure (device not found,etc)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      - should initialize all non-ui stuff
//              - initialize configuration and resource lists.
//
HRESULT CHwRes::HrInit(const DEVNODE& devnode)
{
    HRESULT hr = E_FAIL;

    m_fHrInitCalled = TRUE;


    // use the config manager to get devnode
    // Since the devnode might have a problem, e.g. resources not set
    // correctly, we need to retrieve possible phantoms
    //
    CONFIGRET crRet = ERROR_SUCCESS;
    HKEY hkey;

    // We only do work on Isa adapters so we need to get the bustype
    // value from the driver (software) key
    crRet = CM_Open_DevNode_Key(devnode, KEY_READ, 0,
            RegDisposition_OpenExisting, &hkey, CM_REGISTRY_SOFTWARE);

    if (CR_SUCCESS == crRet)
    {
        // Get BusType
        ULONG ulBusType;
        hr = HrRegQueryStringAsUlong(hkey, c_szBusType, c_nBase10,
                &ulBusType);

        RegCloseKey(hkey);

        // If Isa, than we can continue
        if (SUCCEEDED(hr) && (Isa == ulBusType))
        {
            m_DevNode = devnode;
            // read configuration current config info
            hr = HrInitConfigList();
        }
        else
        {
            hr = S_FALSE;
        }

    }

    if (S_OK == hr)
    {
        m_fInitialized = TRUE;
    }

    TraceError("CHwRes::HrInit",
        (HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr ||
        S_FALSE == hr) ? S_OK : hr);
    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::GetNextElement
//
//  Purpose:    Gets the next (or prev) element in a resource list
//
//  Arguments:
//      pResource [in]       resource list to traverse.
//      ppeList   [out]      the "next" element is returned.
//      fNext     [in]       TRUE - moving fwd in list; FALSE - move bkwrds.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::GetNextElement(PRESOURCE pResource, PVOID *ppeList, BOOL fNext)
{
    UINT size = 0;

    AssertSz(m_fInitialized,
             "GetNextElement called before CHwRes is HrInit'ed");

    Assert(pResource != NULL);
    // get the vector size (dependant on resource type)
    switch (pResource->ResourceType) {
    case ResType_IRQ:
        size = pResource->pIRQList->size();
        break;
    case ResType_DMA:
        size = pResource->pDMAList->size();
        break;
    case ResType_IO:
        size = pResource->pIOList->size();
        break;
    case ResType_Mem:
        size = pResource->pMEMList->size();
        break;
    default:
        Assert(FALSE);
        break;
    }

    // increment/decrement current position within vector
    if (fNext)
    {
        pResource->pos++;
    }
    else
    {
        pResource->pos--;
    }
    // Check for wrapping
    if ((int)(pResource->pos) < 0)
    {
        Assert(pResource->pos == -1);
        Assert(!fNext);  // we're going backwards
        pResource->pos = size-1;
    }
    else if (pResource->pos >= size)
    {
        Assert(pResource->pos == size);
        Assert(fNext);
        pResource->pos = 0;
    }

    // return the current vector element (dependant on res type)
    // REVIEW: do we ever use the element that's gathered below?
    switch (pResource->ResourceType) {
    case ResType_IRQ:
        *ppeList = (*pResource->pIRQList)[pResource->pos];
        break;
    case ResType_DMA:
        *ppeList = (*pResource->pDMAList)[pResource->pos];
        break;
    case ResType_IO:
        *ppeList = (*pResource->pIOList)[pResource->pos];
        break;
    case ResType_Mem:
        *ppeList = (*pResource->pMEMList)[pResource->pos];
        break;
    default:
        Assert(FALSE);
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::HrInitConfigList
//
//  Purpose:    Initialize m_ConfigList (the internal vector of
//              configurations.)
//
//  Returns:    S_OK - init successful;
//              HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) if no device configs
//              found; E_FAIL otherwise (invalid device, etc.)
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      "Lists" are actually implemented as STL vectors.
//
HRESULT CHwRes::HrInitConfigList() {
    HRESULT hr = S_OK;
    PCONFIGURATION pConfiguration;
    CONFIGRET ConfigRet;
    LOG_CONF lcCurrent, lcNext;
    UINT iBasicConfig;
    BOOL fFoundConfig = FALSE;

    Assert(NULL != m_DevNode);

    // erase all elements
    m_ConfigList.erase(m_ConfigList.begin(), m_ConfigList.end());

    // Boot Configuration
    if (CM_Get_First_Log_Conf(&lcCurrent, m_DevNode, BOOT_LOG_CONF)
            == CR_SUCCESS)
    {
        TraceTag(ttidNetComm, "Boot config already exists");
        hr = HRESULT_FROM_WIN32(ERROR_FILE_EXISTS);
    }

    if (SUCCEEDED(hr))
    {
        // Basic Configurations (may be more than one)
        iBasicConfig = 0;
        ConfigRet = CM_Get_First_Log_Conf(&lcCurrent, m_DevNode, BASIC_LOG_CONF);

#ifdef ENABLETRACE
if (CR_SUCCESS != ConfigRet)
{
    TraceTag(ttidNetComm, "CM_Get_First_Log_conf returned %lX", ConfigRet);
}
#endif // ENABLETRACE
        while (CR_SUCCESS == ConfigRet)
        {
            pConfiguration = new CONFIGURATION;

			if (pConfiguration == NULL)
			{
                TraceError("pConfiguration == NULL", E_FAIL);
                goto error;
			}

            pConfiguration->LogConf = lcCurrent;
            pConfiguration->fBoot = FALSE;
            pConfiguration->fAlloc = FALSE;

            if (!FInitResourceList(pConfiguration))
            {
                hr = E_FAIL;
                TraceError("CHwRes::FInitResourceList",hr);
                goto error;
            }

            m_ConfigList.push_back(pConfiguration);

            // Move on to the next basic config
            iBasicConfig++;
            ConfigRet = CM_Get_Next_Log_Conf(&lcNext, lcCurrent, 0);
            lcCurrent = lcNext;
            fFoundConfig = TRUE;
        }

        if (!fFoundConfig)
        {
            TraceTag(ttidNetComm, "No basic configs");

            // if no config entries found, return ERROR_FILE_NOT_FOUND.
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);
        }
    }

error:
    // ERROR_FILE_NOT_FOUND is an okay error message.
    TraceError("CHwRes::HrInitConfigList",
               (HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND) == hr ||
                HRESULT_FROM_WIN32(ERROR_FILE_EXISTS) == hr ) ? S_OK : hr);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::FInitResourceList
//
//  Purpose:    Initializes the resource list for a given logical config.
//
//  Arguments:
//      pConfiguration  [in]    configuration who's resource list is to
//                              be initialized.
//
//  Returns:    TRUE if init sucessful; FALSE otherwise.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:      Requires pConfiguration->LogConf to be initialized.
//
BOOL CHwRes::FInitResourceList(PCONFIGURATION pConfiguration)
{
    RES_DES rdCurrent;
    RES_DES rdNext;
    RESOURCEID ResType;
    UINT iResource;
    #define RESOURCE_BUFFER_SIZE 4096
    BYTE Buffer[RESOURCE_BUFFER_SIZE];
    ULONG ulDataSize;
    RESOURCE * pRes;
    CONFIGRET cr;

    Assert(pConfiguration->LogConf);
    rdCurrent = (RES_DES) pConfiguration->LogConf;
    iResource = 0;
    while ((cr = CM_Get_Next_Res_Des(&rdNext, rdCurrent,
                               ResType_All, &ResType, 0)) == CR_SUCCESS)
    {
        rdCurrent = rdNext;
        // Only process this resource if the ignore bit is not set
        if (ResType_Ignored_Bit != ResType)
        {
            pRes = &(pConfiguration->aResource[iResource]);
            pRes->ResDes = rdCurrent;
            pRes->ResourceType = ResType;
            cr = CM_Get_Res_Des_Data_Size(&ulDataSize, rdCurrent, 0);
            if (CR_SUCCESS != cr)
            {
                TraceTag (ttidDefault, "CM_Get_Res_Des_Data_Size returned 0x%08x", cr);
                goto error;
            }

            AssertSz (ulDataSize, "CM_Get_Res_Des_Data_Size returned 0!");
            AssertSz (ulDataSize <= sizeof(Buffer), "CHwRes::FInitResourceList: buffer is too small.");;

            cr = CM_Get_Res_Des_Data(rdCurrent, Buffer, sizeof(Buffer), 0);
            if (CR_SUCCESS != cr)
            {
                TraceTag (ttidDefault, "CM_Get_Res_Des_Data returned 0x%08x", cr);
                goto error;
            }

            // Depending on the ResType, we have to initialize our resource list.
            switch (ResType)
            {
            case ResType_Mem:
                InitMEMList(&(pRes->pMEMList), (PMEM_RESOURCE)Buffer);
                break;
            case ResType_IO:
                InitIOList(&(pRes->pIOList), (PIO_RESOURCE)Buffer);
                break;
            case ResType_DMA:
                InitDMAList(&(pRes->pDMAList), (PDMA_RESOURCE)Buffer);
                break;
            case ResType_IRQ:
                InitIRQList(&(pRes->pIRQList), (PIRQ_RESOURCE)Buffer);
                break;
            default:
                AssertSz (ResType_None != ResType, "ResType_None hit caught in CHwRes::FInitResourceList.");
                break;
            }
            // set the list position to the first element;
            // applied_pos will get copied to pos when dialog box is created.
            pRes->applied_pos = 0;

            iResource++;
            pConfiguration->cResource = iResource;
            if (iResource >= c_nMaxResCtls)
            {
                break; // we're done.
            }
        }
    } //while
    if ((CR_SUCCESS != cr) && (CR_NO_MORE_RES_DES != cr))
    {
        TraceTag (ttidDefault, "CM_Get_Next_Res_Des returned 0x%08x", cr);
        goto error;
    }

    return TRUE;
error:
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitIRQList
//
//  Purpose:    Initialize an IRQ resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppIRQList    [out]    returns IRQ_LIST that will be created.
//      pIRQResource [in]     IRQ_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitIRQList(PIRQ_LIST* ppIRQList, PIRQ_RESOURCE pIRQResource) {
    PIRQ_DES pIRQHeader;
    PIRQ_RANGE pIRQData;
    PIRQ_LIST_ELEMENT pIRQListElement;

    pIRQHeader = &(pIRQResource->IRQ_Header);
    pIRQData = &(pIRQResource->IRQ_Data[0]);

    // Create a new list.
    *ppIRQList = new IRQ_LIST;

	if (*ppIRQList == NULL)
	{
		return;
	}

    ULONG iData;
    ULONG iIRQ;

    for (iData = 0; iData < pIRQHeader->IRQD_Count; iData++) 
	{
        for (iIRQ = pIRQData[iData].IRQR_Min;
                iIRQ <= pIRQData[iData].IRQR_Max;
                iIRQ++) 
		{
            // For each IRQ that falls within the given range,
            // create new IRQ List Element, populate its fields and insert
            // it into the m_IRQList.
            pIRQListElement = new IRQ_LIST_ELEMENT;

			if (pIRQListElement == NULL)
			{
				continue;
			}

            pIRQListElement->dwIRQ = iIRQ;
            pIRQListElement->fConflict = FALSE;
            pIRQListElement->fAllocated = FALSE;
            (*ppIRQList)->push_back(pIRQListElement);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CHwRes::InitDMAList
//
//  Purpose:    Initialize a DMA resource vector given a config manager
//              resource structure.
//
//  Arguments:
//      ppDMAList    [out]    returns DMA_LIST that will be created.
//      pDMAResource [in]     DMA_RESOURCE structure from config manager.
//
//  Author:     t-nabilr   07 Apr 1997
//
//  Notes:
//
VOID CHwRes::InitDMAList(PDMA_LIST* ppDMAList, PDMA_RESOURCE pDMAResource) {
    PDMA_DES pDMAHeader;
    PDMA_RANGE pDMAData;
    PDMA_LIST_ELEMENT peDMAList;

    pDMAHeader = &(pDMAResource->DMA_Header);
    pDMAData = &(pDMAResource->DMA_Data[0]);

    // Create a new list.
    *ppDMAList = new DMA_LIST;

	if (*ppDMAList == NULL)
	{
		return;
	}

    ULONG iData;  // index of DMA_Range structure we're looking at.
    ULONG iDMA;   // current DMA number we're adding to the list.

    // Go through all the DMA_Range structures, and all DMAs in the
    // specified range to the list.

    for (iData = 0; iData < pDMAHeader->DD_Count; iData++)
    {
        for (iDMA = pDMAData[iData].DR_Min;
                iDMA <= pDMAData[iData].DR_Max;
                iDMA++)
        {
            // For each DMA that falls within the given range,
            // create new DMA List Element, populate its fields and insert
            // it into the DMAList.
          