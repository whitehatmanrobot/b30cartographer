NVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);


    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        TcpsvcsDbgAssert(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
    }

    ENDEXCEPT

Cleanup:

    if (abCacheEntryInfoBuffer)
        delete [] abCacheEntryInfoBuffer;

    return dwError;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\conlist.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  conlist.cxx

Abstract:

    Linked list of URL_CONTAINERs
    
Author:
    Adriaan Canter (adriaanc) 04-02-97
    
--*/

#include <cache.hxx>

/*------------------------ CConElem -----------------------------------------*/

/*-----------------------------------------------------------------------------
CConElem constructor
  ---------------------------------------------------------------------------*/
CConElem::CConElem(URL_CONTAINER* pUrlCon)
{
    _pUrlCon = pUrlCon;
    _pNext = NULL;
}

/*-----------------------------------------------------------------------------
CConElem destructor. Destructs URL_CONTAINER* member.
  ---------------------------------------------------------------------------*/
CConElem::~CConElem()
{
    delete _pUrlCon;
}


/*------------------------ CConList Private Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList::Seek      Sets current pointer to element of index nElem.
  ---------------------------------------------------------------------------*/
BOOL CConList::Seek(DWORD nElem)
{   
    // Bad list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Seek to element from current.
    if (nElem > _nCur)        
    {
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

//
// BUGBUG: VC5 optimizer assumes if (a < b), then (b > a), so check (a != b) instead
//
    else if (nElem != _nCur) // if (nElem < _nCur)
    {
        // Seek to element from head.
        _nCur = 0;
        _pCur = _pHead;
        while (_nCur < nElem)
        {
            _pCur = _pCur->_pNext;
            _nCur++;
        }
    }

    INET_ASSERT(_nCur != 0 || (_pCur == _pHead));

    return TRUE;
}


/*------------------------ CConList Public Functions------------------------*/


/*-----------------------------------------------------------------------------
CConList constructor.
  ---------------------------------------------------------------------------*/
CConList::CConList()
: _n(0), _nCur(0), _pCur(NULL), _pHead(NULL)
{
}

/*-----------------------------------------------------------------------------
CConList destructor.
  ---------------------------------------------------------------------------*/
CConList::~CConList()
{
}

/*-----------------------------------------------------------------------------
CConList::Size      Returns number of elements in list.
  ---------------------------------------------------------------------------*/
DWORD CConList::Size()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD n = (_pHead ? _n+1 : 0);
    return n;
}

/*-----------------------------------------------------------------------------
CConList::Free      Removes and destructs each element in list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Free()
{
    LOCK_CACHE();

    DWORD i = Size();

    //  Delete CONTENT last, as we reference fields of it's header (dwChangeCount)
    //  in destructors of extensible containers
    while (i)
    {
        Remove(--i);
    }
    UNLOCK_CACHE();
    return TRUE;
}


/*-----------------------------------------------------------------------------
CConList::Add      Appends new element to list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Add(URL_CONTAINER * pUrlCon)
{
    LOCK_CACHE();
    BOOL bSuccess = FALSE;
    CConElem *pNew;
    DWORD i;
    
    // Bad pointer.
    if (!pUrlCon)
    {
        INET_ASSERT(FALSE);
        goto exit;        
    }

    if (_pHead)
    {
        //  try to reuse a Container which has been deleted
        for (i = 0; i <= _n; i++)
        {
            if (Seek(i))
            {
                if (_pCur->_pUrlCon->GetDeleted())
                {
                    delete _pCur->_pUrlCon;
                    _pCur->_pUrlCon = pUrlCon;
                    bSuccess = TRUE;
                    goto exit;
                }
            }
        }
    }

    // Construct new element.
    pNew = new CConElem(pUrlCon);

    if (!pNew)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // If valid list, seek to last element and add element.
    if (_pHead)
    {
        if (_n == LARGEST_INDEX)
        {
            delete pNew;
            INET_ASSERT(FALSE);
            goto exit;        
        }
        Seek(_n);
        _pCur->_pNext = pNew;
        pNew->_pNext = _pHead;
        _n++;
    }
    // If empty list, set head and current to new element.
    else
    {
        _pHead = _pCur = pNew;
        pNew->_pNext = _pHead;
        _n = _nCur = 0;
    }
    
    bSuccess = TRUE;
exit:
    
    UNLOCK_CACHE();
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::Remove      Removes nElem'th element from list.
  ---------------------------------------------------------------------------*/
BOOL CConList::Remove(DWORD nElem)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
{
    DWORD     nPrev;
    CConElem *pElem;
    BOOL bSuccess = FALSE;

    // Empty list or index too high.
    if (!_pHead || nElem > _n)
    {
        INET_ASSERT(FALSE);
        goto exit;
    }

    // Seek to previous element, or last if removing head.
    nPrev = (nElem == 0 ? _n : nElem - 1);
    Seek(nPrev);

    // Save pointer to element, update prevous' next pointer.
    pElem = _pCur->_pNext;
    _pCur->_pNext = _pCur->_pNext->_pNext;

    // Update head if necessary.
    if (nElem == 0)
        _pHead = _pHead->_pNext;

    // Decrement index of last, zero out values if empty.
    if (_n > 0)
        _n--;
    else
    {
        _pHead = _pCur = NULL;
        _n = _nCur = 0;
    }    
    
    // Destruct element.
    delete pElem;
    
    bSuccess = TRUE;
exit:
    return bSuccess;
}

/*-----------------------------------------------------------------------------
CConList::operator Get Returns Addref'ed reference to URL_CONTAINER* of index nElem.
  ---------------------------------------------------------------------------*/
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC
URL_CONTAINER* CConList::Get (DWORD nElem)
{
    URL_CONTAINER* pUrlCon;
    if (Seek(nElem))
        pUrlCon = _pCur->_pUrlCon;
    else
        pUrlCon = NULL;
        
    if (pUrlCon) pUrlCon->AddRef();
    return pUrlCon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\contain.cxx ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Abstract-for-module.

    Contents:

Author:

     16-Nov-1995

[Environment:]

    optional-environment-info (e.g. kernel mode only...)

[Notes:]

    optional-notes

Revision History:

    16-Nov-1995
        Created

    Shishir Pardikar (shishirp) added: (as of 7/6/96)

    1) Container allows any size file. The file is cleanedup at scavneging time
    2) Free 100% uses cleanupallurls, reinitializes memorymappedfile and cleansup
       all directories
    3) CurrentCacheSIze and Cache Limit in the memorymapped file itself
    4) FileCreation time and lastcheckedtime added
    5) friendly naming scheme

    25-Sep-1997

    Ahsan Kabir (akabir) made minor alterations to GetFileSizeAndTimeByName.

--*/

/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    contain.cxx

Abstract:

    Contains code that implements CONTAINER classes defined in
    contain.hxx.

Author:

    Madan Appiah (madana)  28-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/


#include <cache.hxx>

// Beta logging
#ifdef BETA_LOGGING
#define BETA_LOG(stat) \
    {DWORD dw; INET_ASSERT (IsContentContainer()); \
    IncrementHeaderData (CACHE_HEADER_DATA_##stat, &dw);}
#else
#define BETA_LOG(stat) do { } while(0)
#endif

// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
extern PFNGETFILEATTREX gpfnGetFileAttributesEx;


// private functions
DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    )
/*++

Routine Description:

    Get the size and creation time and file attributes of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    lpFindData : pointer to a WIN32_FIND_DATA structure where the size and time value is
        returned. On WinNT, only the size and time fields are valid.

Return Value:

    Windows Error Code.

--*/
{
    INET_ASSERT(lpFileAttrData != NULL);

    if (gpfnGetFileAttributesEx)
    {
        if(!gpfnGetFileAttributesEx(FileName, GetFileExInfoStandard, (LPVOID)lpFileAttrData))
            return( GetLastError() );
    }
    else
    {
        HANDLE hHandle;
        WIN32_FIND_DATA FindData;

        hHandle = FindFirstFile(FileName, &FindData);
        if( hHandle == INVALID_HANDLE_VALUE ) {
            return( GetLastError() );
        }
        memset(lpFileAttrData, 0, sizeof(WIN32_FILE_ATTRIBUTE_DATA));
        lpFileAttrData->dwFileAttributes = FindData.dwFileAttributes;
        lpFileAttrData->nFileSizeLow = FindData.nFileSizeLow;
        lpFileAttrData->nFileSizeHigh = FindData.nFileSizeHigh;
        lpFileAttrData->ftCreationTime = FindData.ftCreationTime;

        FindClose(hHandle);
    }

    return(ERROR_SUCCESS);
}

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    )
/*++

Routine Description:

    Get the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : pointer to a longlong location where the size value is
        returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwError = ERROR_SUCCESS;

    // get the size of the file being cached.
    //  since we do not handle 4+gb files, we can safely ignore the high dword

    INET_ASSERT(pdwFileSize!=NULL);

    if (gpfnGetFileAttributesEx)
    {
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
        if(!gpfnGetFileAttributesEx(pszFileName, GetFileExInfoStandard, &FileAttrData))
            return( GetLastError() );

        *pdwFileSize = FileAttrData.nFileSizeLow;
    }
    else
    {
        HANDLE hfFileHandle = CreateFile(
                        pszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( hfFileHandle == INVALID_HANDLE_VALUE )
            return(GetLastError());

        *pdwFileSize = GetFileSize( hfFileHandle, NULL);
        if(*pdwFileSize == 0xFFFFFFFF)
            dwError = GetLastError();

        CloseHandle( hfFileHandle );
    }
    return dwError;
}

// -------------------------------URL_CONTAINER----------------------------------- //

/*-----------------------------------------------------------------------------
URL_CONTAINER::URL_CONTAINER Sets path, prefix and limit.
-----------------------------------------------------------------------------*/
URL_CONTAINER::URL_CONTAINER(LPTSTR CacheName, LPTSTR CachePath,
                             LPTSTR CachePrefix, LONGLONG CacheStartUpLimit,
                             DWORD dwOptions)
{
    _fIsInitialized = FALSE;
    _fPerUserItem = TRUE;
    _dwLastReference = GetTickCountWrap();
    _fDeleted = FALSE;
    _fMarked = FALSE;
    _fDeletePending = FALSE;
    _fMustLaunchScavenger = FALSE;
//#ifdef CHECKLOCK_NORMAL
    _dwTaken = 0;
//#endif
    _dwRefCount = 0;
    _dwOptions = dwOptions;
    _dwBytesDownloaded = _dwItemsDownloaded = 0;
    _CacheEntryType = 0;
    _CacheName = NULL;
    _CachePath = NULL;
    _CachePrefix = NULL;


    if (!CachePath || !*CachePath || !CachePrefix || !CacheStartUpLimit)
    {
        _Status = ERROR_INVALID_PARAMETER;
        return;
    }

    _CacheName = NewString(CacheName == NULL ? TEXT(""):CacheName);

    _CachePathLen = strlen(CachePath);

    if (CachePath[_CachePathLen-1] != DIR_SEPARATOR_CHAR)
    {
        _CachePath = CatString(CachePath, DIR_SEPARATOR_STRING);
        _CachePathLen++;
    }
    else
        _CachePath = NewString(CachePath);

    _CachePrefix = NewString(CachePrefix);

    if (!_CachePath || !_CachePrefix || !_CacheName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _CachePrefixLen = strlen(_CachePrefix);

    _CacheStartUpLimit = CacheStartUpLimit;

    _UrlObjStorage = NULL;
    _FileManager = NULL;

    if (!memcmp(_CachePrefix, CONTENT_PREFIX, sizeof(CONTENT_PREFIX)))
        _CacheEntryType = NORMAL_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, COOKIE_PREFIX, sizeof(COOKIE_PREFIX)))
        _CacheEntryType = COOKIE_CACHE_ENTRY;
    else if (!memcmp(_CachePrefix, HISTORY_PREFIX, sizeof(HISTORY_PREFIX)))
        _CacheEntryType = URLHISTORY_CACHE_ENTRY;

    _Status = ERROR_SUCCESS;
}


#ifdef CHECKLOCK_PARANOID
void URL_CONTAINER::CheckNoLocks(DWORD dwThreadId)
{
    INET_ASSERT(_dwTaken == 0 || _dwThreadLocked != dwThreadId);
}
#endif

/*-----------------------------------------------------------------------------
URL_CONTAINER::Init
-----------------------------------------------------------------------------*/
DWORD URL_CONTAINER::Init()
{
    _Status = ERROR_SUCCESS;
    _FileMapEntrySize = NORMAL_ENTRY_SIZE;
    MemMapStatus eMMStatus;
    BOOL fMustUnlock = FALSE;
    DWORDLONG dlSize;

    // Generate the mutex name based on the cache path.
    DWORD i;
    LPSTR szPrefix;
    CHAR MutexName[MAX_PATH + 1];
    LPTSTR pCachePath, pMutexName;

    i = 0;
    pCachePath = _CachePath,
    pMutexName = (LPSTR) MutexName;
    while( *pCachePath != '\0'  && (i++ < MAX_PATH))
    {
        if( *pCachePath == DIR_SEPARATOR_CHAR )
            *pMutexName = '!';
        else
            *pMutexName = tolower(*pCachePath);

        pMutexName++;
        pCachePath++;
    }
    *pMutexName = '\0';

    // Open the existing mutex, or if first process, create a new one.
    BOOL fFirstProcess = FALSE;

    _MutexHandle = OpenMutex(SYNCHRONIZE, FALSE, (LPTSTR)MutexName);
    if (_MutexHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        SECURITY_ATTRIBUTES* psa = SHGetAllAccessSA();
        if (psa)
        {
            _MutexHandle = CreateMutex(psa, FALSE, (LPTSTR)MutexName);
        }
        if (_MutexHandle != NULL)
            fFirstProcess = TRUE;
    }

    if (_MutexHandle == NULL)
    {
        _Status = GetLastError();
        goto Cleanup;
    }

    // Lock the container.
    if (!LockContainer(&fMustUnlock))
    {
        if (fMustUnlock) ReleaseMutex(_MutexHandle);
        fMustUnlock = FALSE;
        _Status = GetLastError();
        if (_MutexHandle)
        {
            CloseHandle(_MutexHandle);
            _MutexHandle = NULL;
        }
        goto Cleanup;
    }
    if ((_CachePathLen > 1) && (_CachePath[_CachePathLen-1] != PATH_CONNECT_CHAR))
    {
        lstrcat( _CachePath, PATH_CONNECT_STRING );
        _CachePathLen++;
    }

    // Initialize _ClusterSizeMinusOne and _ClusterSizeMask
    if (!GetDiskInfo(_CachePath, &_ClusterSizeMinusOne, &dlSize, NULL))
    {
        _Status = GetLastError();
        goto Cleanup;
    }
    _ClusterSizeMinusOne--;
    _ClusterSizeMask = ~_ClusterSizeMinusOne;

    // Construct and initialize the memory mapped file object.
    _UrlObjStorage = new MEMMAP_FILE;
    if( _UrlObjStorage == NULL )
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    eMMStatus = _UrlObjStorage->Init(_CachePath, _FileMapEntrySize, _fPerUserItem);

    if((_Status = _UrlObjStorage->GetStatus()) != ERROR_SUCCESS )
        goto Cleanup;

    // for first process attach, we need to clean up the notification
    // hwnd, msg, gid and filter
    if( fFirstProcess && (_CacheEntryType == NORMAL_CACHE_ENTRY ))
    {
        RegisterCacheNotify(0, 0, 0, 0);
    }

    _UrlObjStorage->SetCacheLimit(_CacheStartUpLimit);

    // Construct and initialize the file manager.
    // Cookies and history don't use random subdirs.
    // BUGBUG - move this off to container manager.
    szPrefix = GetCachePrefix();

    if (!strcmp(szPrefix, COOKIE_PREFIX)
        || !strcmp(szPrefix, HISTORY_PREFIX)
        || (_dwOptions & INTERNET_CACHE_CONTAINER_NOSUBDIRS))
    {
        // Insecure cache -no random cache subdirs.
        _FileManager = new CFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }
    else
    {
        // Secure cache - random cache subdirs.
        _FileManager = new CSecFileMgr(_UrlObjStorage, GetOptions());
        if (!_FileManager)
        {
            _Status = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
    }

    // If first process to attach, unlock any locked entries.
    if (fFirstProcess)
        UnlockAllItems();

    // If the memory mapped file was reinitialized
    // cleanup old files.
    if (eMMStatus == MEMMAP_STATUS_REINITIALIZED)
        _FileManager->Cleanup();
    else
        eMMStatus = MEMMAP_STATUS_OPENED_EXISTING;

    _fIsInitialized = TRUE;
    if (dlSize <= (DWORDLONG)(4*1024*1024))
    {
        // Yeah, this hurts start-up perf. We also have little room to maneuvre in, so we're going to try anyway.
        CleanupUrls(DEFAULT_CLEANUP_FACTOR, 0);
    }

Cleanup:

    if( _Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "URL_CONTAINER::URL_CONTAINER() failed, %ld\n", _Status ));
        SetLastError(_Status);
    }
    if (fMustUnlock) UnlockContainer();

    if (_Status == ERROR_SUCCESS)
        return (eMMStatus == MEMMAP_STATUS_OPENED_EXISTING ? ERROR_ALREADY_EXISTS : ERROR_SUCCESS);

    return _Status;
}

void URL_CONTAINER::CloseContainerFile()
{

    // Cleanup.
    // _Filemanager holds a pointer to _UrlObjStorage and
    // must be deleted before _UrlObjStorage.
    delete _FileManager;
    delete _UrlObjStorage;

    _FileManager = NULL;
    _UrlObjStorage = NULL;

    if (!_fDeleted)
    {
        // Keep fixed container files from being deleted.
        if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
        {
            _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
            if (_fDeleted) _fDeletePending = FALSE;
        }
    }
}

URL_CONTAINER::~URL_CONTAINER(
    VOID
    )
/*++

Routine Description:

    URL_CONTAINER destructor

Arguments:

    None.

Return Value:

    None.

--*/
{
    BOOL fMustUnlock;

    // If not initialized, only delete path and prefix.
    if (!IsInitialized())
    {
        //  Free pending deleted container, even if someone has
        //  a enum handle open on it.  This is our last chance as we handle process
        //  detach

        LOCK_CACHE();
        TryToUnmap(0xFFFFFFFF);
        UNLOCK_CACHE();

        if(_CacheName) delete _CacheName;
        if(_CachePath) delete _CachePath;
        if(_CachePrefix) delete _CachePrefix;
        return;
    }

    LockContainer(&fMustUnlock);

    // Otherwise, do a full destruct.
    CloseContainerFile();

    if (fMustUnlock) UnlockContainer();

    // Delete mutex.
    if( _MutexHandle != NULL )
        CloseHandle( _MutexHandle );

    if(_CacheName) delete _CacheName;
    if(_CachePath) delete _CachePath;
    if(_CachePrefix) delete _CachePrefix;
}

DWORD URL_CONTAINER::GetOptions()
{
    return _dwOptions;
}

DWORD URL_CONTAINER::GetLastReference()
{
    return _dwLastReference;
}

BOOL URL_CONTAINER::IsVisible()
{
    return !(_fDeletePending || _fDeleted);
}

void URL_CONTAINER::Mark(BOOL fMarked)
{
    _fMarked = fMarked;
}

BOOL URL_CONTAINER::GetMarked()
{
    return _fMarked;
}

BOOL URL_CONTAINER::GetDeleted()
{
    return _fDeleted;
}

void URL_CONTAINER::SetDeleted(BOOL fDeleted)
{
    if (!_fIsInitialized) _fDeleted = fDeleted;
}

BOOL URL_CONTAINER::GetDeletePending()
{
    return _fDeletePending;
}

void URL_CONTAINER::SetDeletePending(BOOL fDeletePending)
{
    _fDeletePending = fDeletePending;
}

void URL_CONTAINER::AddRef()
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    _dwRefCount++;
}

void URL_CONTAINER::TryToUnmap(DWORD dwAcceptableRefCount)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    BOOL fMustUnlock;

    if (_dwRefCount <= dwAcceptableRefCount)
    {
        if (_fIsInitialized)
        {
            LockContainer(&fMustUnlock);

            CloseContainerFile();

            if (fMustUnlock) UnlockContainer();

            // Delete mutex.
            if( _MutexHandle != NULL )
            {
                CloseHandle( _MutexHandle );
                _MutexHandle = NULL;
            }
            _fIsInitialized = FALSE;
        }
        else
        {
            if (!_fDeleted)
            {
                //  Never CONTENT, COOKIES or HISTORY container.
                if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
                {
                    if(GlobalUrlContainers)
                    {
                        _fDeleted = GlobalUrlContainers->DeleteFileIfNotRegistered(this);
                        if (_fDeleted) _fDeletePending = FALSE;
                    }
                }
            }
        }
    }
}

DWORD URL_CONTAINER::Release(BOOL fTryToUnmap)
// THIS FUNCTION MUST BE CALLED WITH THE CACHE CRIT SEC.
{
    DWORD dwRefCount = 0;

    INET_ASSERT(_dwRefCount);
    if (_dwRefCount)
    {
        dwRefCount = --_dwRefCount;
        if (fTryToUnmap && _dwRefCount == 0)
        {
            //  Never CONTENT, COOKIES or HISTORY container.
            if (!(_CacheEntryType & (NORMAL_CACHE_ENTRY | COOKIE_CACHE_ENTRY | URLHISTORY_CACHE_ENTRY)))
            {
                if (_fDeletePending)
                {
                    TryToUnmap(0);
                }
            }
        }
    }
    return dwRefCount;
}


BOOL URL_CONTAINER::LockContainer(BOOL *fMustUnlock)
/*++

Routine Description:

    This function waits for the container to be free.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    _dwLastReference = GetTickCountWrap();

    *fMustUnlock = FALSE;

    if( _MutexHandle == NULL )
    {
        // Bad mutex handle.
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Container Mutex Handle is NULL.\n" ));
        return FALSE;
    }

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "LockContainer called by thread %x\n", GetCurrentThreadId()));

    //
    // Wait the for the mutex to be signalled.
    //

    DWORD Result;

    #if DBG
        DWORD MutexTimeoutCount;
        MutexTimeoutCount = 0;

    Waitagain:

    #endif

    // Check the mutex.
    #if DBG
        Result = WaitForSingleObject(_MutexHandle, MUTEX_DBG_TIMEOUT);
    #else
        Result = WaitForSingleObject(_MutexHandle, INFINITE);
    #endif

    switch ( Result )
    {
        case WAIT_OBJECT_0:

            // Mutex is signalled (normal result). We now have ownership of the mutex.
            // Do a CheckSizeGrowAndRemapAddress.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                {
                    return (FALSE);
                }
            }
            return TRUE;

    #if DBG
        case WAIT_TIMEOUT:

            // Exceeded debug timeout count. Try again.
            MutexTimeoutCount++;
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait time-out (count = %ld).\n", MutexTimeoutCount ));
            goto Waitagain;
    #endif

        case WAIT_ABANDONED :

            // The thread owning the mutex failed to release it before it terminated.
            // We still get ownership of the mutex.
            _dwTaken++;
#ifdef CHECKLOCK_NORMAL
            _dwThreadLocked = GetCurrentThreadId();
#endif
            *fMustUnlock = TRUE;

            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex ABANDONED.\n" ));
            if (_UrlObjStorage)
            {
                if (_UrlObjStorage->CheckSizeGrowAndRemapAddress() != ERROR_SUCCESS)
                    return (FALSE);
            }

            return TRUE;

        case WAIT_FAILED :

            // Failed to obtain mutex.
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Mutex wait failed (%ld).\n", GetLastError() ));
            return FALSE;

    }

    INET_ASSERT( FALSE );
    return FALSE;
}


VOID URL_CONTAINER::UnlockContainer(VOID)
/*++

Routine Description:

    This function frees the container to be used by someone else.

Arguments:

    NONE.

Return Value:

    NONE.

--*/
{
    BOOL fMustLaunchScavenger = FALSE;

    //TcpsvcsDbgPrint((DEBUG_ERRORS, "UnlockContainer called by thread %x\n", GetCurrentThreadId()));
    _dwLastReference = GetTickCountWrap();

    _dwTaken--;

#ifdef CHECKLOCK_NORMAL
    if( _MutexHandle)
    {
        INET_ASSERT(_dwThreadLocked == GetCurrentThreadId());

        if (_dwTaken == 0)
            _dwThreadLocked = 0;
#endif
        if (_dwTaken == 0)
        {
            fMustLaunchScavenger = _fMustLaunchScavenger;
            _fMustLaunchScavenger = FALSE;
        }
        if (ReleaseMutex( _MutexHandle ) == FALSE )
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "ReleaseMutex failed (%ld).\n", GetLastError() ));
        }

        if (fMustLaunchScavenger)
            LaunchScavenger();

#ifdef CHECKLOCK_NORMAL
    }
#endif
    return;
}

BOOL URL_CONTAINER::UpdateOfflineRedirect
(
    DWORD dwUrlItemOffset, // offset to hash table item of URL entry
    LPCSTR pszUrl,         // URL string
    DWORD cbUrl,           // URL length
    LPCSTR pszRedir        // redirect string
)
/*++
Routine Description:
    Marks a hash table item as allowing a redirect to add trailing slash,
    or creates a new redirect hash table item and memory mapped file entry.

    Addendum: We keep track of redirects in the cache and simulate them when
    offline. Often the redirected URL is the same as the original URL plus
    trailing slash.

WARNING: this function has multiple calls which can grow and remap the
memory map file, invalidating any pointers into the file.  Be careful.

Return Value: TRUE if redirect was cached

--*/

{
    DWORD cbRedir = strlen (pszRedir);
    DWORD dwUrlHash;
    DWORD dwRedirItemOffset;

    // Ignore the redirect URL if same as original URL.
    if (cbRedir == cbUrl && !memcmp(pszUrl, pszRedir, cbRedir))
        return FALSE;

    { // limit scope of pUrlItem

        HASH_ITEM* pUrlItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + dwUrlItemOffset);

        // Special case trailing slash redirect.
        if (   cbRedir + 1 == cbUrl
            && pszUrl [cbRedir] == '/'
            && !memcmp (pszUrl, pszRedir, cbRedir)
           )
        {
            pUrlItem->SetSlash();
            return TRUE;
        }

        // Record high bits of target URL hash value.
        dwUrlHash = pUrlItem->GetValue();
    }

    //
    // BUGBUG: we do not handle the case of redirect that once added a
    // trailing slash to redirect to another URL altogether.  We should
    // scan the entire hash table slot and unset the trailing slash bit
    // if we find a match.
    //

    REDIR_FILEMAP_ENTRY* pEntry;

    { // limit scope of pRedirItem

        HASH_ITEM* pRedirItem = NULL;

        if (HashFindItem (pszRedir, LOOKUP_REDIR_CREATE, &pRedirItem))
        {
            // Found existing redirect entry; update it.
            pEntry = (REDIR_FILEMAP_ENTRY*) HashGetEntry (pRedirItem);
            INET_ASSERT (pEntry->dwSig == SIG_REDIR);
            pEntry->dwHashValue = dwUrlHash;
            pEntry->dwItemOffset = dwUrlItemOffset;
            INET_ASSERT (!lstrcmp (pEntry->szUrl, pszRedir));
            return TRUE;
        }

        if (!pRedirItem)
            return FALSE;

        dwRedirItemOffset = (DWORD) ((LPBYTE) pRedirItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

    // Created new hash table item so allocate a redir entry.
    DWORD cbEntry = sizeof(*pEntry) + cbRedir;
    pEntry = (REDIR_FILEMAP_ENTRY *) _UrlObjStorage->AllocateEntry (cbEntry);

    // Associate entry with hash table item.
    HASH_ITEM *pRedirItem =
        (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwRedirItemOffset);
    if (!pEntry)
    {
        pRedirItem->MarkFree();
        return FALSE;
    }
    HashSetEntry (pRedirItem, (LPBYTE) pEntry);
    pRedirItem->SetRedir();

    // Initialize the redirect entry.
    pEntry->dwSig        = SIG_REDIR;
    pEntry->dwHashValue  = dwUrlHash;
    pEntry->dwItemOffset = dwUrlItemOffset;
    memcpy (pEntry->szUrl, pszRedir, cbRedir + 1);

    return TRUE;
}

LPSTR URL_CONTAINER::GetPrefixMap()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeLabel()
{
    return TEXT("");
}

LPSTR URL_CONTAINER::GetVolumeTitle()
{
    return TEXT("");
}

DWORD URL_CONTAINER::AddIdentityUrl (AddUrlArg* pArgs)
{
    DWORD dwError = ERROR_SUCCESS;
    pArgs->dwEntryType |= IDENTITY_CACHE_ENTRY;

    // Lookup or create a hash item for the 0-URL entry.
    HASH_ITEM *pItem;
    BOOL fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_DONT_FOLLOW, &pItem);

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
        if (pOld && !IsPerUserEntry(pOld))
        {
            DeleteUrlEntry(pOld, pItem, SIG_DELETE);
            fUpdate = FALSE;
        }
    }
    if (!fUpdate)
    {
        DWORD dwIdentity = pArgs->dwIdentity;
        PTSTR pszFilePath = (PTSTR)pArgs->pszFilePath;
        pArgs->pszFilePath = NULL;
        pArgs->dwIdentity = 0;
        
//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// Calling AddUrl recursively may be hazardous to your health
// SUPERWARNING !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

        dwError = AddUrl(pArgs);
        pArgs->dwIdentity = dwIdentity;            
        pArgs->pszFilePath = pszFilePath;
    }
    else
    {            
        DWORD dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
        DWORD dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }
    
    return dwError;
}


DWORD URL_CONTAINER::AddUrl (AddUrlArg* pArgs)

/*++

Routine Description:

    This member functions adds an URL to the container and moves the
    cache file to cache path.

Arguments:

    UrlName : pointer to an URL string.

    lpszNewFileName : pointer to a cache file (full) name.

    ExpireTime : expire time of the file.

    LastModifiedTime : Last modified time of this file. if this value is
        zero, current time is set as the last modified time.

    dwCacheEntryType : type of this new entry.

    HeaderInfo : if this pointer is non-NULL, it stores the HeaderInfo
        data as part of the URL entry in the memory mapped file, otherwise
        the app may store it else where. The size of the header info is
        specified by the HeaderSize parameter.

    dwHeaderSize : size of the header info associated with this URL, this
        can be non-zero even if the HeaderInfo specified above is NULL.

    FileExtension : file extension used to create this file.

Return Value:

    Windows Error Code.

--*/
{
    DWORD dwReturn;
    BOOL fMustUnlock;
    DWORD dwCurrentOffset;
    DWORD dwUrlNameSize;
    LPTSTR FileName;
    DWORD dwFileNameSize;
    DWORD dwUrlFileExtSize;
    DWORD dwEntrySize;
    FILETIME ftCreate;
    DWORD dwFileSize;
    LONGLONG CacheSize, CacheLimit;
    DWORD dwItemOffset;
    BOOL fUpdate;
    LPURL_FILEMAP_ENTRY NewEntry;
    HASH_ITEM *pItem;
    GROUP_ENTRY* pGroupEntry;
    GroupMgr    gm;
    DWORD dwFileMapEntrySizeAligned;
    BOOL fPlaceAnyRedirect = TRUE;

    if (!LockContainer(&fMustUnlock))
    {
        dwReturn = GetLastError();
        goto exit;
    }

    // If this is an identity-specific entry, we need to setup an identity-0
    // referrer
    if (pArgs->dwIdentity)
    {
        dwReturn = AddIdentityUrl(pArgs);
        if (dwReturn!=ERROR_SUCCESS)
        {
            goto exit;
        }
        fPlaceAnyRedirect = FALSE;
    }
    
    // Calculate dwUrlNameSize.
    dwUrlNameSize = lstrlen(pArgs->pszUrl) + 1;

    // FileName points to the filename sans cachepath.  Calculate dwFileNameSize.
    if(pArgs->pszFilePath)
    {

        // Is this an absolute path (edited)?
        if (!(pArgs->dwEntryType & EDITED_CACHE_ENTRY))
        // No, so find the last slash in the file name path.
        // This delimits the file name.

        {
            CHAR  *pSlash = NULL,
                  *ptr = (LPSTR) pArgs->pszFilePath;
            while (*ptr)
            {
                if (*ptr == DIR_SEPARATOR_CHAR)
                    pSlash = ptr;

                ptr=CharNext(ptr);
            }
            FileName = pSlash  + 1;
            dwFileNameSize = (DWORD) (ptr - FileName + 1); // 64BIT
        }
        // Have an absolute path so use the full path
        else
        {
            FileName = (char *)pArgs->pszFilePath;
            dwFileNameSize = lstrlen(FileName)+1;
        }
    }
    else
    {
        FileName = NULL;
        dwFileNameSize = 0;
    }

    // Calculate dwUrlFileExtSize
    if (FileName)
    {
        dwUrlFileExtSize =
            (pArgs->pszFileExt? (lstrlen(pArgs->pszFileExt) + 1) : sizeof("txt"));

    }
    else
    {
        dwUrlFileExtSize = 0;
    }

    // Get the file size.
    if (!pArgs->pszFilePath)
        dwFileSize = 0;
    else
    {
        if (!pArgs->dwFileSize)
        {
            WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

            dwReturn = GetFileSizeAndTimeByName(pArgs->pszFilePath, &FileAttrData);
            // If not succeed, return a uniform error.
            if ((ERROR_SUCCESS!=dwReturn) || FileAttrData.nFileSizeHigh) // Accept 0 length files too ...
            {
                // Reject files of length 0 or larger than 4 GB.
                dwReturn = ERROR_INVALID_DATA;
                goto exit;
            }
            dwFileSize = FileAttrData.nFileSizeLow;
            ftCreate = FileAttrData.ftCreationTime;
        }
        else
        {
            dwFileSize = pArgs->dwFileSize;
            ftCreate = pArgs->ftCreate;
        }
    }

    dwReturn = ERROR_SUCCESS;

    { // Open a new block to limit the scope of pointer variables.

        HASH_ITEM *pItem;

        // Lookup or create a hash item for the URL entry.

        fUpdate = HashFindItem (pArgs->pszUrl, LOOKUP_URL_CREATE, &pItem);

//////////////////////////////////////////////////////////////////////////////
// WARNING: LOOKUP_URL_CREATE set,thus the file might be grown and remapped //
// so all pointers into the file must be recalculated from their offsets!   //
//////////////////////////////////////////////////////////////////////////////

        if (fUpdate)
        {
            // Check existing entry for refcount.
            URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);
            if (pOld->NumReferences)
            {
                dwReturn = ERROR_SHARING_VIOLATION;
                goto exit;
            }

            // Validate the size of data to be copied from existing entry.
            // If the entry version is IE5, the value could be random, so
            // force it to the correct value.  If the value is otherwise
            // bogus, also set it to the IE5 size for safety.
            if (    pOld->bVerCreate == ENTRY_VERSION_IE5
                ||  pOld->CopySize > pOld->nBlocks * NORMAL_ENTRY_SIZE
                ||  pOld->CopySize & 3 // should be dword aligned
               )
            {
                pOld->CopySize = ENTRY_COPYSIZE_IE5;
            }

            dwFileMapEntrySizeAligned = pOld->CopySize;
        }
        else if (!pItem)
        {
            // Item was not found but could not allocate another hash table.
            dwReturn = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
        else // brand new entry
        {
           dwFileMapEntrySizeAligned = ENTRY_COPYSIZE_CURRENT;
        }

        // Save offsets in case the memmap file must be grown and remapped.
        dwItemOffset = (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart()); // 64BIT
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

    // Create/update offline redirect as necessary.
    if (pArgs->pszRedirect && fPlaceAnyRedirect)
    {
        UpdateOfflineRedirect
            (dwItemOffset, pArgs->pszUrl, dwUrlNameSize - 1, pArgs->pszRedirect);
    }

    DWORD dwUrlNameSizeAligned;
    DWORD dwFileNameSizeAligned;
    DWORD dwHeaderSizeAligned;
    DWORD dwUrlFileExtSizeAligned;

    // Calculate the total size of the entry, rounding up for alignment.
    dwUrlNameSizeAligned        = ROUNDUPDWORD(dwUrlNameSize);
    dwFileNameSizeAligned       = ROUNDUPDWORD(dwFileNameSize);
    dwHeaderSizeAligned         = (pArgs->pbHeaders) ? ROUNDUPDWORD(pArgs->cbHeaders) : 0;
    dwUrlFileExtSizeAligned     = ROUNDUPDWORD(dwUrlFileExtSize);

    INET_ASSERT (dwFileMapEntrySizeAligned % sizeof(DWORD) == 0);
    INET_ASSERT (sizeof(FILEMAP_ENTRY) % sizeof(DWORD) == 0);
    dwFileMapEntrySizeAligned += sizeof(FILEMAP_ENTRY);

    dwEntrySize =         dwFileMapEntrySizeAligned
                        + dwUrlNameSizeAligned
                        + dwFileNameSizeAligned
                        + dwHeaderSizeAligned
                        + dwUrlFileExtSizeAligned;

    NewEntry = (LPURL_FILEMAP_ENTRY) _UrlObjStorage->AllocateEntry(dwEntrySize);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

    // Restore pointer to hash table item.
    pItem = (HASH_ITEM*) (*_UrlObjStorage->GetHeapStart() + dwItemOffset);

    if (!NewEntry)
    {
        if (!fUpdate)
            pItem->MarkFree();
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }


/*
    Handle any differences between cache entry versions.

    IE5 inits bVerUpdate to 0 when creating an entry, but incorrectly preserves 
    the value when updating instead of forcing it to 0.  Fortunately IE6 does 
    not care since IE5 will not be able to find an identity-specific entry in 
    order to update it.

    However, we should have a safety hatch for IE7+ to realize that a downlevel 
    urlcache updated its entry and just copied over the opaque data.  Of course 
    the solution will be a total ugly hack.  One possibility is for the uplevel 
    urlcache to set dwUrlNameOffset to be dwCopySizeAligned + 4.  This will 
    leave an uninitialized dword "hole" between the fixed fields and the 4 
    variable size fields.  Once this hack is used, by IE7 for example, it 
    should correctly set bVerUpdate2 so that IE8+ can detect both IE5-6 and IE7 
    updates without creating further holes.
*/

    if (fUpdate)
    {
        URL_FILEMAP_ENTRY* pOld = HashGetEntry (pItem);

        if ((pOld->dwSig != SIG_URL)
            || (pOld->CopySize > PAGE_SIZE))
        {
            INET_ASSERT(FALSE);
            pItem->MarkFree();
            _UrlObjStorage->FreeEntry(NewEntry);
            dwReturn = ERROR_INTERNET_INTERNAL_ERROR;
            goto exit;
        }
        
        CopyMemory (((LPBYTE) NewEntry) + sizeof(FILEMAP_ENTRY),
                    ((LPBYTE) pOld) + sizeof(FILEMAP_ENTRY),
                    pOld->CopySize);
        INET_ASSERT (NewEntry->CopySize == pOld->CopySize);
        if (NewEntry->CopySize == ENTRY_COPYSIZE_IE5)
            NewEntry->bVerCreate = ENTRY_VERSION_IE5;
        INET_ASSERT (NewEntry->bVerCreate == pOld->bVerCreate);
    }
    else
    {
        NewEntry->CopySize   = ENTRY_COPYSIZE_CURRENT;
        NewEntry->bVerCreate = ENTRY_VERSION_CURRENT;
        NewEntry->bVerUpdate = ENTRY_VERSION_CURRENT;
    }

    // Invalidate the signature during the update.
    NewEntry->dwSig = 0;

    // We must set entry type, file size, and exempt delta before
    // calling SetExemptDelta.  We leave the sticky bit out of the
    // entry type in case we have no more room for sticky items.
    NewEntry->CacheEntryType = _CacheEntryType
                                | (pArgs->dwEntryType & ~STICKY_CACHE_ENTRY);

    NewEntry->dwFileSize = dwFileSize;

    if (!fUpdate)
    {
        // This is a brand new entry.
        NewEntry->dwGroupOffset = 0;
        NewEntry->NumAccessed   = 1;

        if (pArgs->fImage)
        {
            NewEntry->bSyncState = SYNCSTATE_IMAGE;
            BETA_LOG (SYNCSTATE_IMAGE);
        }
        else
        {
            NewEntry->bSyncState = SYNCSTATE_VOLATILE;
            if (IsContentContainer())
                BETA_LOG (SYNCSTATE_VOLATILE);
        }

        NewEntry->dwExemptDelta = 0;
        if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
            SetExemptDelta (NewEntry, 24 * 60 * 60, dwItemOffset); // one day
    }
    else // if (fUpdate)
    {
        URL_FILEMAP_ENTRY* ExistingEntry = HashGetEntry (pItem);

        // This is an update of an existing entry.
        INET_ASSERT (NewEntry->dwGroupOffset == ExistingEntry->dwGroupOffset);

        NewEntry->NumAccessed++;  // BUGBUG: blowing off wraparound

        if (ExistingEntry->bSyncState == SYNCSTATE_STATIC)
            BETA_LOG (SYNCSTATE_STATIC_VOLATILE);

        NewEntry->bSyncState = SYNCSTATE_VOLATILE;


        if (ExistingEntry->dwExemptDelta ||
            ExistingEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            // If item was previously sticky, it is preserved upon update.
            NewEntry->dwExemptDelta = ExistingEntry->dwExemptDelta;
            INET_ASSERT (ExistingEntry->CacheEntryType | STICKY_CACHE_ENTRY);
            NewEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
        }
        else
        {
            // If the item wasn't previously sticky, it might be made so.
            NewEntry->dwExemptDelta = 0;
            if (pArgs->dwEntryType & STICKY_CACHE_ENTRY)
                SetExemptDelta (NewEntry, 24 * 60 * 60 * 1000, dwItemOffset); // one day
        }

        // if belongs to a group, adjust the group usage
        if( ExistingEntry->dwGroupOffset &&
            ExistingEntry->dwFileSize != NewEntry->dwFileSize )
        {
            LONGLONG llDelta = RealFileSize(NewEntry->dwFileSize) -
                               RealFileSize(ExistingEntry->dwFileSize);
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                if( gm.Init(this) )
                {
                    // dwGroupOffset is now offset to head of group list
                    gm.AdjustUsageOnList(ExistingEntry->dwGroupOffset, llDelta);
                }
            }
            else
            {
                // single group
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                    ExistingEntry->dwGroupOffset, pItem);

                // WARNING: quota can be reached by usage increase
                if( pGroupEntry )
                {
                    AdjustGroupUsage(pGroupEntry, llDelta);
                }
            }
        }

        // Delete the old entry if it's not an installed entry or an EDITED_CACHE_ENTRY
        // (Unless the new entry replacing it is also an EDITED_CACHE_ENTRY),
        // either way the hash table item is preserved. We also check the filesize if
        // we've determined the old entry was ECE but the new one is not, just in case
        // the client deletes the file but doesn't get around to deleting from the
        // cache index. The logic is optimized for the most likely case (want to del).
        if ((ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
            && (!(ExistingEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            // IDK=0 ECE=0 NECE=? FS=?
            DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
        }
        else if (ExistingEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        {
            // IDK=0 ECE=1 NECE=? FS=?
            if (NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)
            {
                // IDK=0 ECE=1 NECE=1 FS=?
                DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
            }
            else
            {
                // IDK=0 ECE=1 NECE=0 FS=?
                // Only want to go out to the FS to get filesize if absolutely necessary

                WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

                FileAttrData.nFileSizeLow = 0;
                dwReturn = GetFileSizeAndTimeByName(
                    (LPTSTR) OFFSET_TO_POINTER (ExistingEntry, ExistingEntry->InternalFileNameOffset),
                    &FileAttrData);
                if (!FileAttrData.nFileSizeLow)
                {
                    // IDK=0 ECE=1 NECE=0 FS=0 or not-exist
                    // if filesize is zero, might as well trounce it
                    DeleteUrlEntry (ExistingEntry, NULL, SIG_UPDATE);
                }
                else if (dwReturn == ERROR_SUCCESS)
                {
                    // IDK=0 ECE=1 NECE=0 FS>0
                    // found a non-zero length file
                    _UrlObjStorage->FreeEntry(NewEntry);
                    pItem->MarkFree();
                    dwReturn = ERROR_SHARING_VIOLATION;
                    goto exit;
                }
            }
        }
        else
        {
            // IDK=1 ECE=? NECE=? FS=?
            // Installed directory item
            _UrlObjStorage->FreeEntry(NewEntry);
            pItem->MarkFree();
            dwReturn = ERROR_SHARING_VIOLATION;
            goto exit;
        }

    } // end else if (fUpdate)

    // Record the new offset in the hash table item.
    HashSetEntry (pItem, (LPBYTE) NewEntry);

    // Initialize NewEntry fields.
    NewEntry->dwRedirHashItemOffset = 0;
    NewEntry->NumReferences        = 0;
    NewEntry->HeaderInfoSize       = pArgs->cbHeaders;
    NewEntry->LastModifiedTime     = pArgs->qwLastMod;
    GetCurrentGmtTime ((FILETIME*) &NewEntry->LastAccessedTime);

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwExpires) ),
        &(NewEntry->dostExpireTime)   );

    FileTime2DosTime(
        *LONGLONG_TO_FILETIME( &(pArgs->qwPostCheck) ),
        &(NewEntry->dostPostCheckTime)   );

    // GetDirIndex will fail if the entry is stored at an absolute path outside
    // the cache dir, This is valid for EDITED_CACHE_ENTRYs such as offline
    // Office9 docs. Even tho the call fails in this case, NewEntry->DirIndex
    // will be set to NOT_A_CACHE_SUBDIRECTORY

    DWORD dwIndex;
    if ((!_FileManager->GetDirIndex((LPSTR) pArgs->pszFilePath, &dwIndex))
        && !((pArgs->dwEntryType & EDITED_CACHE_ENTRY)
             || ((pArgs->dwEntryType & IDENTITY_CACHE_ENTRY) && !pArgs->dwIdentity)))
    {
        _UrlObjStorage->FreeEntry(NewEntry);
        pItem->MarkFree();
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    NewEntry->DirIndex = (BYTE) dwIndex;

    // If this entry points to the store directory, set
    // the INSTALLED_CACHE_ENTRY bit so that retrieval
    // from cache will not result in requests to the wire
    // from wininet except for refresh requests.

    if ((NewEntry->DirIndex == INSTALLED_DIRECTORY_KEY) ||
        (pArgs->dwEntryType & EDITED_CACHE_ENTRY))
    {
        NewEntry->CacheEntryType |= INSTALLED_CACHE_ENTRY;
    }

    FileTimeToDosDateTime( (FILETIME *)&(NewEntry->LastAccessedTime),
                           (LPWORD)&(NewEntry->dostLastSyncTime),
                           ((LPWORD)&(NewEntry->dostLastSyncTime)+1));

    // Specify identity.
    NewEntry->dwIdentity = pArgs->dwIdentity;
    if (pArgs->dwIdentity)
    {
        NewEntry->CacheEntryType |= IDENTITY_CACHE_ENTRY;
    }
    
    // The URL_FILEMAP_ENTRY will point to
    //
    // [URL_FILEMAP_ENTRY][UrlName][FileName][HeaderInfo][FileExtension]
    //                    ^        ^         ^           ^
    //                    |        |         |           FileExtensionOffset
    //                    |        |         |
    //                    |        |         HeaderInfoOffset
    //                    |        |
    //                    |        FileNameOffset
    //                    |
    //                    UrlNameOffset
    //


    dwCurrentOffset = dwFileMapEntrySizeAligned;
    NewEntry->UrlNameOffset = dwCurrentOffset;

    // Copy UrlName into NewEntry
    memcpy((LPSTR) OFFSET_TO_POINTER(NewEntry, NewEntry->UrlNameOffset),
        pArgs->pszUrl, dwUrlNameSize);

    dwCurrentOffset += dwUrlNameSizeAligned;

    // Copy FileName into NewEntry
    if(FileName)
    {
        NewEntry->InternalFileNameOffset = dwCurrentOffset;
        memcpy((LPTSTR) OFFSET_TO_POINTER (NewEntry,
            NewEntry->InternalFileNameOffset), FileName, dwFileNameSize);

        // Get file creation time of cache file.
        if (!pArgs->pszFilePath)
            NewEntry->dostFileCreationTime = 0;
        else
        {
            FileTimeToDosDateTime (&ftCreate,
                (LPWORD)&(NewEntry->dostFileCreationTime),
                ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
        }

        dwCurrentOffset += dwFileNameSizeAligned;
    }
    else
    {
        NewEntry->InternalFileNameOffset = 0;
        NewEntry->dostFileCreationTime = 0;
    }

    // Copy HeaderInfo into NewEntry
    if(pArgs->pbHeaders)
    {
        NewEntry->HeaderInfoOffset = dwCurrentOffset;
        memcpy((LPBYTE)NewEntry + NewEntry->HeaderInfoOffset,
            pArgs->pbHeaders, pArgs->cbHeaders);
        dwCurrentOffset += dwHeaderSizeAligned;
    }
    else
    {
        NewEntry->HeaderInfoOffset = 0;
    }

    // Copy FileExtension into NewEntry
    if(pArgs->pszFileExt)
    {
        NewEntry->FileExtensionOffset = dwCurrentOffset;
        memcpy ((LPTSTR) ((LPBYTE)NewEntry + NewEntry->FileExtensionOffset),
            pArgs->pszFileExt, dwUrlFileExtSize);
        dwCurrentOffset += dwUrlFileExtSizeAligned;
    }
    else
    {
        NewEntry->FileExtensionOffset = 0;
    }

    // Restore the signature.
    NewEntry->dwSig = SIG_URL;

    // Increment the FileManager's count
    if (FileName)
    {
        // This is a no-op for the COOKIES and HISTORY containers.
        _FileManager->NotifyCommit(NewEntry->DirIndex);

        // Adjust CacheSize if not an installed entry or stored outside of cache dir.
        // If disk quota is exceeded, initiate cleanup.
        // NOTE: this attempts to take the critical section, so we must defer it
        // until we have released the container mutex to avoid potential deadlock
        if ((NewEntry->DirIndex != INSTALLED_DIRECTORY_KEY) && (!(NewEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
        {
            _dwBytesDownloaded += (DWORD)RealFileSize(dwFileSize);
            _dwItemsDownloaded++;

            _UrlObjStorage->AdjustCacheSize(RealFileSize(dwFileSize));
            CacheSize = _UrlObjStorage->GetCacheSize();
            CacheLimit = _UrlObjStorage->GetCacheLimit();
            if (CacheSize > CacheLimit)
                _fMustLaunchScavenger = TRUE;

            // We also want to scavenge if, even though there's plenty of space available in the
            // cache, the amount of total disk space available falls below a certain threshold.
            // We'll arbitrarily set the threshold to be 4MB (below which, things are likely to get
            // painful.

            if (!_fMustLaunchScavenger && ((_dwBytesDownloaded>(1024*1024)) || (_dwItemsDownloaded>100)))
            {
                DWORDLONG dlSize = 0;

                _dwBytesDownloaded = _dwItemsDownloaded = 0;
                if (GetDiskInfo(_CachePath, NULL, &dlSize, NULL))
                {
                    _fMustLaunchScavenger = (BOOL)(dlSize <= (DWORDLONG)GlobalDiskUsageLowerBound);
                }
            }
        }
    }

    // Flush index if this is an edited document or Cookie to mitigate the risk of dirty shutdown losing changes a client
    // like Office9 might have made (they store edited docs in our cache).

    if (pArgs->dwEntryType & EDITED_CACHE_ENTRY )
    {
        FlushViewOfFile((LPCVOID)NewEntry, dwCurrentOffset);
    }

    if( pArgs->dwEntryType & COOKIE_CACHE_ENTRY )
    {
        FlushViewOfFile( (void*)(*_UrlObjStorage->GetHeapStart()), 0 );
    }


    // Notification
    // If item was previously sticky, it is preserved upon update.
    // only need to report non sticky -> sticky
    if( !fUpdate )
    {
        NotifyCacheChange(CACHE_NOTIFY_ADD_URL, dwItemOffset);
    }
    else
    {
        NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL, dwItemOffset);
    }

exit:

    if (fMustUnlock) UnlockContainer();
    return dwReturn;
}



DWORD URL_CONTAINER::AddLeakFile (LPCSTR pszFilePath)
{
    DWORD dwReturn;

    BOOL fUnlock;
    if (!LockContainer(&fUnlock))
    {
        if(fUnlock)
            ReleaseMutex(_MutexHandle);

        return GetLastError();
    }

    //
    // Calculate the size of the filename, after the last slash.
    //

    LPSTR pszSlash = NULL;
    LPSTR pszScan = (LPSTR) pszFilePath;
    while (*pszScan)
    {
        if (*pszScan == DIR_SEPARATOR_CHAR)
            pszSlash = pszScan;

        pszScan = CharNext(pszScan);
    }
    LPSTR pszFileName = pszSlash + 1;
    DWORD cbFileName = (DWORD) (pszScan - pszFileName + 1); // 64BIT

    //
    // Determine the directory bucket.
    //

    DWORD nDirIndex;
    if (!_FileManager->GetDirIndex((LPSTR) pszFilePath, &nDirIndex))
    {
        dwReturn = ERROR_INVALID_PARAMETER;
        goto exit;
    }

    //
    // Get the file size and create time.
    //

    WIN32_FILE_ATTRIBUTE_DATA FileAttrData;
    dwReturn = GetFileSizeAndTimeByName (pszFilePath, &FileAttrData);
    if (!FileAttrData.nFileSizeLow || FileAttrData.nFileSizeHigh)
    {
        // Reject files of length 0 or larger than 4 GB.
        dwReturn = ERROR_INVALID_DATA;
        goto exit;
    }

    //
    // Allocate a leaked file entry.
    //

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////


    URL_FILEMAP_ENTRY* NewEntry;
    NewEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->AllocateEntry
        (sizeof(URL_FILEMAP_ENTRY) + cbFileName);
    if (!NewEntry)
    {
        dwReturn = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////


    //
    // Fill only the fields important to WalkLeakList method.
    //

    NewEntry->dwSig = SIG_LEAK;
    NewEntry->dwFileSize = FileAttrData.nFileSizeLow;
    NewEntry->InternalFileNameOffset = sizeof(URL_FILEMAP_ENTRY);
    memcpy ((LPBYTE) (NewEntry + 1), pszFileName, cbFileName);
    NewEntry->DirIndex = (BYTE) nDirIndex;
    FileTimeToDosDateTime( &FileAttrData.ftCreationTime,
                           (LPWORD)&(NewEntry->dostFileCreationTime),
                           ((LPWORD)&(NewEntry->dostFileCreationTime)+1));
    NewEntry->NumReferences = 0;

    //
    // Add this entry on to the head of the scavenger leak list.
    //
    _UrlObjStorage->GetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &NewEntry->dwNextLeak);
    _UrlObjStorage->SetHeaderData
        (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
         OffsetFromPointer (NewEntry));

    //
    // Update the cache usage and directory count.
    //

    _UrlObjStorage->AdjustCacheSize(RealFileSize(NewEntry->dwFileSize));
    _FileManager->NotifyCommit(NewEntry->DirIndex);

    //
    // We could check here if usage exceeds quota then launch scavenger,
    // but it will probably happen soon enough anyway upon AddUrl.
    //

    dwReturn = ERROR_SUCCESS;

exit:
    if (fUnlock)
        UnlockContainer();

    return dwReturn;
}

DWORD URL_CONTAINER::RetrieveUrl
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppInfo,
    LPDWORD pcbInfo,
    DWORD dwLookupFlags, // e.g. redirect
    DWORD dwRetrievalFlags
)

/*++

Routine Description:

    This member function retrives an url from the cache. The url is marked
    as referenced, so that caller should call UnlockUrl when he is done
    using it.

Arguments:

    UrlName : pointer to the url name.

    ppInfo :  ptr to ptr to an entry info buffer, where the url entry info
        is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
        above buffer, on return it has the size of the buffer consumed or
        size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find the item.
    HASH_ITEM *pItem;

    if (!HashFindItem (UrlName, dwLookupFlags, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Get the hash entry.
    UrlEntry = HashGetEntry (pItem);
    if (UrlEntry->InternalFileNameOffset == 0)
    {
        Error = ERROR_INVALID_DATA;
        goto exit;
    }
    
    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = TRUE; IsCorrectUser() = %s \r\n",
            (IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))? "TRUE" : "FALSE"
            ));

        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }
    else
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "RetrieveUrl (contain.cxx): IsContentContainer() = FALSE\r\n"));
    }
    // Hide sparse cache entries from non-wininet clients.

    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
            && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Found the entry. Copy URL info in the return buffer first.
    Error = CopyUrlInfoGuard( UrlEntry, ppInfo, pcbInfo, dwRetrievalFlags );
    if( Error != ERROR_SUCCESS )
        goto Cleanup;

    if ((*ppInfo)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {
        // Delete the item and entry but not the file.
        UrlEntry->InternalFileNameOffset = 0;
        DeleteUrlEntry (UrlEntry, pItem, SIG_DELETE);
        Error = ERROR_SUCCESS;
        goto Cleanup;
    }

    // Verify the file size is what it is supposed to be.
    if (dwRetrievalFlags & RETRIEVE_WITH_CHECKS)
    {
        DWORD dwFileSize;
        Error = GetFileSizeByName
            ((LPCSTR)((*ppInfo)->lpszLocalFileName), &dwFileSize);
        if (Error != ERROR_SUCCESS)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }

        if (dwFileSize != UrlEntry->dwFileSize)
        {
            Error = ERROR_INVALID_DATA;
            goto Cleanup;
        }
    }

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount++;

    // Increment the reference count before returning.
    if (UrlEntry->NumReferences)
    {
        if( !pItem->IsLocked() )
        {
            //
            // corrupted index file
            // entry says it's locked, hash table say it's not
            // believe the hash table by fixing up the entry
            //
            INET_ASSERT (FALSE);
            UrlEntry->NumReferences = 0;
        }
    }
    else
        pItem->SetLocked();

    UrlEntry->NumReferences++;

    // Update last accessed time.
    GetCurrentGmtTime ((FILETIME*) &UrlEntry->LastAccessedTime);
 
    // And the number of times this was accessed
    UrlEntry->NumAccessed++;

Cleanup:

    if (Error != ERROR_SUCCESS)
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "RetrieveUrl call failed, %ld.\n",
            Error ));
        SetLastError(Error);
    }
exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


DWORD URL_CONTAINER::DeleteUrl(LPCSTR  UrlName)
/*++

Routine Description:

    This member function deletes the specified url from the cache.

Arguments:

    UrlName : pointer to the url name.

Return Value:

    Windows Error Code.

--*/
{
    BOOL fMustUnlock;
    DWORD Error;
    URL_FILEMAP_ENTRY *pEntry;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Find (and validate) the entry.
    if (!HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    pEntry = HashGetEntry(pItem);

    // Delete the hash table item and entry from the index.
    Error = DeleteUrlEntry (pEntry, pItem, SIG_DELETE);

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "DeleteUrl: RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    // Notify
    NotifyCacheChange(
        CACHE_NOTIFY_DELETE_URL,
        (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
    );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}


/*++
Routine Description:
    This member functions deletes an URL from the container and also
    deletes the cache file from cache path.

    dwSig - if we must put an uplevel entry on the async fixup list,
       this param distinguishes between updates and deletions.

Return Value:
    Windows Error Code.
--*/

DWORD URL_CONTAINER::DeleteUrlEntry
    (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM *pItem, DWORD dwSig)
{
    INET_ASSERT (pItem? dwSig == SIG_DELETE : dwSig == SIG_UPDATE);

    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }

    DWORD Error;
    GROUP_ENTRY* pGroupEntry = NULL;
    GroupMgr     gm;

    // Check for locked entry.
    if (pEntry->NumReferences)
    {
        // Mark the entry for pending delete.
        pEntry->CacheEntryType |= PENDING_DELETE_CACHE_ENTRY;
        Error = ERROR_SHARING_VIOLATION;
        goto Cleanup;
    }

    // If the entry version is beyond our understanding...
    if (pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK)
    {
        INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));

        pEntry->dwSig = dwSig; // mark as either updated or deleted

        // Add entry to head of fixup list.
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET, &pEntry->dwNextLeak);
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_OFFSET,
             OffsetFromPointer (pEntry));

        // Increment count of items on fixup list, maybe trigger fixup.
        DWORD dwCount, dwTrigger;
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, &dwCount);
        _UrlObjStorage->GetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_TRIGGER, &dwTrigger);
        if (++dwCount > dwTrigger)
            _fMustLaunchScavenger = TRUE;
        _UrlObjStorage->SetHeaderData
            (CACHE_HEADER_DATA_ROOT_FIXUP_COUNT, dwCount);

        goto delete_hash_item;
    }

    // If group associated, Adjust Group's disk Usage
    // if pItem == NULL, we should perserve all the group info
    if( pEntry->dwGroupOffset && pItem )
    {
        if( pItem->HasMultiGroup() )
        {
            // multiple group
            if( gm.Init(this) )
            {
                // dwGroupOffset now offset to head of group list
                gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
            }
        }
        else
        {
            // single group
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);

            if( pGroupEntry )
            {
                AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize) );
            }
        }
    }

    // Delete any associated file.
    if (pEntry->InternalFileNameOffset
        && (pEntry->DirIndex != INSTALLED_DIRECTORY_KEY)
        && (!(pEntry->CacheEntryType & EDITED_CACHE_ENTRY)))
    {
        // Reduce the exempt usage for sticky item (could be an update)
        if ( pEntry->dwExemptDelta ||
             (pEntry->CacheEntryType & STICKY_CACHE_ENTRY) )
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));

        // Get the absolute path to the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];
        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            && _FileManager->DeleteOneCachedFile
            (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));
            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // Link the entry at the head of leaked files list.
            INET_ASSERT(pEntry->NumReferences==0);

            pEntry->dwSig = SIG_LEAK;
            _UrlObjStorage->GetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, &pEntry->dwNextLeak);
            _UrlObjStorage->SetHeaderData
                (CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                 OffsetFromPointer (pEntry));
        }
    }
    else
    {
        // NOTE: In the case that the entry is in a store (INSTALLED_DIRECTORY_KEY)
        // we do allow the cache entry to be deleted, but we do NOT allow the associated
        // file to be deleted. This at least allows us to delete these entries from
        // the cache without affecting their (permanent) backing store files.

        _UrlObjStorage->FreeEntry(pEntry);
    }

delete_hash_item:

    // Delete this item from the hash table.
    if (pItem)
        pItem->MarkFree();

    Error = ERROR_SUCCESS;

Cleanup:

    TcpsvcsDbgPrint ((DEBUG_ERRORS,
        "URL_CONTAINER::DeleteUrlEntry() returning %ld\n", Error));
    return Error;
}


DWORD URL_CONTAINER::UnlockUrl(LPCSTR UrlName)
/*++

Routine Description:

    This member function unreferences the url entry, so that it can be
    freed up when used no one.

Arguments:

    Url : pointer to an URL name.

Return Value:

    Windows Error Code.

--*/
 {
    DWORD Error;
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    HASH_ITEM* pItem;
    URL_FILEMAP_ENTRY* pEntry;

    // Look up the entry.
    if (HashFindItem (UrlName, LOOKUP_URL_NOCREATE, &pItem))
        pEntry = HashGetEntry (pItem);
    else
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    TcpsvcsDbgPrint((DEBUG_CONTAINER,
        "RefCount=%d, DeletePending=%d \r\n",
        pEntry->NumReferences,
        (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)? 1 : 0
        ));

    UnlockItem (pEntry, pItem);

    // Hack to keep track of if any entries have locks.
    GlobalRetrieveUrlCacheEntryFileCount--;
    Error = ERROR_SUCCESS;

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

DWORD URL_CONTAINER::GetUrlInfo
(
    LPCSTR UrlName,
    LPCACHE_ENTRY_INFO* ppUrlInfo,
    LPDWORD UrlInfoLength,
    DWORD dwLookupFlags,
    DWORD dwEntryFlags,
    DWORD dwRetrievalFlags
)
/*++

Routine Description:

    This member function retrieves the url info.

Arguments:

    UrlName : name of the url file (unused now).

    ppUrlInfo : pointer to the pointer to the url info structure that receives the url
        info.

    UrlInfoLength : pointer to a location where length of
        the above buffer is passed in. On return, this contains the length
        of the above buffer that is fulled in.

    dwLookupFlags: flags, e.g. translate through redirects

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY UrlEntry;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    // Look up the entry.
    UrlEntry = HashFindEntry (UrlName, dwLookupFlags);
    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // For content container, check that username matches.
    if (IsContentContainer())
    {
        LPSTR pszHeaders = ((LPSTR) UrlEntry) + UrlEntry->HeaderInfoOffset;
        if (!IsCorrectUser(pszHeaders, UrlEntry->HeaderInfoSize))
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
    }

    // Hide sparse cache entries from non-wininet clients.
    if (UrlEntry->CacheEntryType & SPARSE_CACHE_ENTRY
        && !(dwLookupFlags & LOOKUP_BIT_SPARSE))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Find only installed entry types.
    if ((dwEntryFlags & INTERNET_CACHE_FLAG_INSTALLED_ENTRY)
        && (!(UrlEntry->CacheEntryType & INSTALLED_CACHE_ENTRY)))
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if (UrlInfoLength)
    {
        if (!ppUrlInfo || !*ppUrlInfo)
            *UrlInfoLength = 0;

       Error = CopyUrlInfoGuard( UrlEntry, ppUrlInfo, UrlInfoLength,
                            (dwEntryFlags & INTERNET_CACHE_FLAG_ADD_FILENAME_ONLY ?
                                RETRIEVE_ONLY_FILENAME : 0) |
                            (dwEntryFlags & INTERNET_CACHE_FLAG_GET_STRUCT_ONLY ? 
                                RETRIEVE_ONLY_STRUCT_INFO : 0) |
                            dwRetrievalFlags);
    }
    else
       Error = ERROR_SUCCESS;

exit:
   if (fMustUnlock) UnlockContainer();
   return( Error );
}


DWORD URL_CONTAINER::SetExemptDelta
    (URL_FILEMAP_ENTRY* UrlEntry, DWORD dwExemptDelta, DWORD dwItemOffset)
{
    // Expanded history calls with STICKY_CACHE_ENTRY for no good reason.
    // INET_ASSERT (UrlEntry->FileSize);

    DWORD dwError = ERROR_SUCCESS;

    if (dwExemptDelta)
    {
        if (!UrlEntry->dwExemptDelta)
        {
            // Entry is changing from non-exempt to exempt.
            // (exempt limit check should be done at UpdateStickness
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_SET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }
    else // if (!dwExemptDelta)
    {
        if (UrlEntry->dwExemptDelta)
        {
            // Entry is changing from exempt to non-exempt.
            dwError = UpdateStickness(UrlEntry, URLCACHE_OP_UNSET_STICKY, dwItemOffset);
            if( dwError != ERROR_SUCCESS )
                goto End;
        }
    }

    UrlEntry->dwExemptDelta = dwExemptDelta;
End:
    return dwError;
}



DWORD URL_CONTAINER::SetUrlInfo(LPCSTR UrlName,
                                LPCACHE_ENTRY_INFO UrlInfo, DWORD FieldControl)
/*++

Routine Description:

Arguments:

    UrlName : name of the url file (unused now).

    UrlInfo : pointer to the url info structure that has the url info to
        be set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPURL_FILEMAP_ENTRY UrlEntry;
    BOOL fMustUnlock;
    HASH_ITEM *pItem;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    // Look up the entry.
    if (HashFindItem (UrlName, 0, &pItem))
    {
        UrlEntry = HashGetEntry (pItem);
    }
    else
    {
        UrlEntry = NULL;
    }

    if (!UrlEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    // Set cache entry ATTRIBUTE.
    if(FieldControl & CACHE_ENTRY_ATTRIBUTE_FC)
    {
        // We must preserve IDENTITY_CACHE_ENTRY bits, if they set
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType 
                                   | (UrlEntry->CacheEntryType & IDENTITY_CACHE_ENTRY);
    }
    
    // Reset cache entry HITRATE.
    if(FieldControl & CACHE_ENTRY_HITRATE_FC)
        UrlEntry->NumAccessed = UrlInfo->dwHitRate;

    // Set last modified time.
    if(FieldControl & CACHE_ENTRY_MODTIME_FC)
         UrlEntry->LastModifiedTime = FT2LL(UrlInfo->LastModifiedTime);

    // Set expire time.
    if( FieldControl & CACHE_ENTRY_EXPTIME_FC)
    {
        FileTime2DosTime(UrlInfo->ExpireTime, &(UrlEntry->dostExpireTime) );
    }

    // Set last access time.
    if(FieldControl & CACHE_ENTRY_ACCTIME_FC)
        UrlEntry->LastAccessedTime = FT2LL(UrlInfo->LastAccessTime);

    // Set last sync time.
    if(FieldControl & CACHE_ENTRY_SYNCTIME_FC)
    {
        FileTimeToDosDateTime( &(UrlInfo->LastSyncTime),
                                (LPWORD)&(UrlEntry->dostLastSyncTime),
                               ((LPWORD)&(UrlEntry->dostLastSyncTime)+1));

        if (   UrlEntry->bSyncState != SYNCSTATE_VOLATILE
            && UrlEntry->bSyncState < SYNCSTATE_STATIC)
        {
            // See if we should transition to SYNCSTATE_STATIC.
            if (UrlEntry->bSyncState == SYNCSTATE_IMAGE)
            {
                // We have not had the image long enough to
                // conclude it is static.  See if it is older
                // than MIN_AGESYNC.

                LONGLONG qwCreate;
                INET_ASSERT (UrlEntry->dostFileCreationTime);
                DosDateTimeToFileTime(
                    * (LPWORD)&(UrlEntry->dostFileCreationTime),
                    *((LPWORD)&(UrlEntry->dostFileCreationTime)+1),
                    (FILETIME*) &qwCreate);

                if (FT2LL(UrlInfo->LastSyncTime) > qwCreate + MIN_AGESYNC)
                {
                    UrlEntry->bSyncState++;
                }
            }
            else
            {
                if (++UrlEntry->bSyncState == SYNCSTATE_STATIC)
                    BETA_LOG (SYNCSTATE_IMAGE_STATIC);
            }

        }
    }

    if (FieldControl & CACHE_ENTRY_TYPE_FC)
    {
        UrlEntry->CacheEntryType = UrlInfo->CacheEntryType;
    }
    
    // Set exemption delta.
    if (FieldControl & CACHE_ENTRY_EXEMPT_DELTA_FC)
    {
        Error = SetExemptDelta (
            UrlEntry,
            UrlInfo->dwExemptDelta,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

        if (Error != ERROR_SUCCESS)
            goto Cleanup;
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Adds or removes a URL from a group.  If adding, may set exemption time.
--*/
DWORD URL_CONTAINER::SetUrlGroup (LPCSTR lpszUrl, DWORD dwFlags, GROUPID GroupId)
{
    DWORD Error;
    BOOL fMustUnlock;
    LPURL_FILEMAP_ENTRY pEntry;
    GROUP_ENTRY* pGroupEntry = NULL;
    GROUP_ENTRY* pOldGroupEntry = NULL;
    GROUPID      gid = 0;
    HASH_ITEM    *pItem = NULL;
    GroupMgr gm;

    if (dwFlags & INTERNET_CACHE_GROUP_NONE)
        return ERROR_SUCCESS;

    if (!GroupId)
        return ERROR_INVALID_PARAMETER;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto exit;
    }

    //
    // HashFindEntry will do the same thing, however, we need pItem
    // here so that we can set/clear the group bit
    //
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
    {
        Error = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    if( !gm.Init(this) )
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;
    }

    if (dwFlags & INTERNET_CACHE_GROUP_REMOVE)
    {
        // offset to GROUP_ENTRY*
        DWORD dwGEOffset = 0;

        // find the group via GroupOffset
        if( !pEntry->dwGroupOffset )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Get GroupEntry Offset
        if( pItem->HasMultiGroup() )
        {
            // multiple group, get from list
            Error = gm.GetOffsetFromList(
                pEntry->dwGroupOffset, GroupId, &dwGEOffset);
            if( Error != ERROR_SUCCESS )
                goto exit;
        }
        else
        {
            dwGEOffset = pEntry->dwGroupOffset;
        }

        // get group entry from the offset
        pGroupEntry = _UrlObjStorage->ValidateGroupOffset(dwGEOffset, pItem);

        if( !pGroupEntry )
        {
            Error = ERROR_FILE_NOT_FOUND;
            goto exit;
        }

        // Remove the group from list
        if( pItem->HasMultiGroup() )
        {
            // remove it from list
            DWORD dwNewHeaderOffset = pEntry->dwGroupOffset;

            Error = gm.RemoveFromGroupList(
                pEntry->dwGroupOffset, dwGEOffset, &dwNewHeaderOffset );

            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            //
            // header may have been changed (if head is the one we want)
            // newHeaderOffset = 0 means last group has been removed
            //
            // NOTE: even we may have one item left on the list, we
            //       are not changing the multiGroup flag on this
            //       entry, so the dwGroupOffset are still points to
            //       the list
            pEntry->dwGroupOffset = dwNewHeaderOffset;

        }
        else
        {
            // set offset to 0 (single group)
            pEntry->dwGroupOffset = 0;

        }

        // if dwExamptDelta is set, we should leave the stick bit
        if(!pEntry->dwExemptDelta)
        {
            //
            // if the unassociated group is sticky, we are remove
            // the sticky bit of this url
            //
            // For multiple groups, we will have to make sure all
            // the remaining groups are non-sticky
            //

            if( IsStickyGroup(pGroupEntry->gid ) &&
                ( !pItem->HasMultiGroup()  ||
                  gm.NoMoreStickyEntryOnList(pEntry->dwGroupOffset) )
            )
            {
                Error = UpdateStickness(
                    pEntry,
                    URLCACHE_OP_UNSET_STICKY,
                    (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
                );
                if( Error != ERROR_SUCCESS )
                    goto exit;
            }
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, -RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, -RealFileSize(pEntry->dwFileSize));
        }

        //
        // update hash bit indicating no group associate with this url
        // we won't clear the multiple group flag even if there is single
        // group left on the group list.
        //
        if( !pEntry->dwGroupOffset )
        {
            pItem->ClearGroup();
            pItem->ClearMultGroup();
        }

    }
    else
    {

        // Find Group via gid
        Error = gm.FindEntry(GroupId, &pGroupEntry, FALSE);
        if( Error != ERROR_SUCCESS )
        {
            goto exit;
        }

        if( pItem->HasGroup() )
        {
            // multiple group

            LPBYTE  lpBase;
            DWORD dwGroupEntryOffset = 0;

            lpBase = *_UrlObjStorage->GetHeapStart();
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            DWORD dwListEntryOffset = 0;
            DWORD dwEntryOffset = 0;
            DWORD dwItemOffset = 0;
            DWORD dwOldGroupEntryOffset = 0;

            if( !pItem->HasMultiGroup() )
            {
                //
                // switch from a single group to multiple
                // group, need to
                //  1) create a new group list
                //  2) add the existing single group to the newly created list
                //


//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                //
                // get a new List (memfile may grown)
                //
                Error = gm.CreateNewGroupList(&dwListEntryOffset);
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                // restore pointers based on (possible) new base addr
                lpBase = *_UrlObjStorage->GetHeapStart();

                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////

                //
                // add the original group (whose offset is indicated
                // with dwGroupOffset of the url entry)
                // to the newly created list
                //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                // save offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                dwEntryOffset = PtrDiff32(pEntry, lpBase);
                dwItemOffset = PtrDiff32(pItem, lpBase);
                dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);
                if( pOldGroupEntry )
                {
                    dwOldGroupEntryOffset = PtrDiff32(pOldGroupEntry, lpBase);
                }

                Error = gm.AddToGroupList(
                        dwListEntryOffset, pEntry->dwGroupOffset);

                // restore offset
                lpBase = *_UrlObjStorage->GetHeapStart();
                pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
                pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
                pItem = (HASH_ITEM*) (lpBase + dwItemOffset);
                if( pOldGroupEntry )
                {
                    pOldGroupEntry
                        = (GROUP_ENTRY*) (lpBase + dwOldGroupEntryOffset);
                }


                
//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
                if( Error != ERROR_SUCCESS )
                {
                    goto exit;
                }

                //
                // the dwGroupOffset of the url entry now
                // points the the head of a group list
                //
                pEntry->dwGroupOffset = dwListEntryOffset;
                pItem->MarkMultGroup();

            }

            //
            // Multiple group, just add the new group to the list
            //
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
            // save offset
            lpBase = *_UrlObjStorage->GetHeapStart();
            dwEntryOffset = PtrDiff32(pEntry, lpBase);
            dwItemOffset = PtrDiff32(pItem, lpBase);
            dwGroupEntryOffset = PtrDiff32(pGroupEntry, lpBase);

            Error = gm.AddToGroupList(
                pEntry->dwGroupOffset, dwGroupEntryOffset);


            if( Error != ERROR_SUCCESS )
            {
                goto exit;
            }

            // remap since multiple group may cause memfile grow
            lpBase = *_UrlObjStorage->GetHeapStart();
            pEntry =  (URL_FILEMAP_ENTRY*)(lpBase + dwEntryOffset);
            pGroupEntry = (GROUP_ENTRY*)(lpBase + dwGroupEntryOffset);
            pItem = (HASH_ITEM*) (lpBase + dwItemOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might have grown and remapped, so all  //
// pointers into the file after this point must be recalculated //
// from offsets.                                                //
//////////////////////////////////////////////////////////////////
        }
        else
        {
            // single group, dwGroupOffset points the real group
            pEntry->dwGroupOffset = PtrDiff32(pGroupEntry, *_UrlObjStorage->GetHeapStart());
        }



        // update hash bit indicating group associate with this url
        pItem->MarkGroup();

        // if group is sticky, mark the entry to sticky as well
        if( IsStickyGroup(pGroupEntry->gid) )
        {
            Error = UpdateStickness(
                pEntry,
                URLCACHE_OP_SET_STICKY,
                (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
            );
            if( Error != ERROR_SUCCESS )
                goto exit;
        }

        // update the usage
        if( pItem->HasMultiGroup() )
        {
            // dwGroupOffset now offset to head of group list
            gm.AdjustUsageOnList(
                    pEntry->dwGroupOffset, RealFileSize(pEntry->dwFileSize) );
        }
        else
        {
            AdjustGroupUsage(pGroupEntry, RealFileSize(pEntry->dwFileSize) );
        }

        //
        // track the usage and quota
        // NOTE: we still allow this url to be added to the group
        //       even if usage > quota, DISK_FULL error will be
        //       returned, so the client is responsible to take
        //       futher action
        //
        if( pGroupEntry->llDiskUsage > (pGroupEntry->dwDiskQuota * 1024) )
        {
            Error = ERROR_NOT_ENOUGH_QUOTA;
            goto  exit;
        }
    }

    Error = ERROR_SUCCESS;

    NotifyCacheChange(CACHE_NOTIFY_UPDATE_URL,
            (DWORD)( ((LPBYTE) pItem) - *_UrlObjStorage->GetHeapStart())
        );

exit:
    if (fMustUnlock) UnlockContainer();
    return Error;
}

/*++
Gets group ID and exemption time for a particular URL.
--*/
DWORD URL_CONTAINER::GetUrlInGroup
    (LPCSTR lpszUrl, GROUPID* pGroupId, LPDWORD pdwExemptDelta)
{
    DWORD dwError;
    BOOL fMustUnlock;
    URL_FILEMAP_ENTRY* pEntry;
    GROUP_ENTRY*       pGroupEntry = NULL;
    HASH_ITEM*          pItem = NULL;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }


    // Look up the entry.
    if (HashFindItem (lpszUrl, 0, &pItem))
    {
        pEntry = HashGetEntry (pItem);
    }
    else
    {
        pEntry = NULL;
    }

    if (!pEntry)
        dwError = ERROR_FILE_NOT_FOUND;
    else
    {
        if( pEntry->dwGroupOffset )
        {
            pGroupEntry = _UrlObjStorage->ValidateGroupOffset(
                pEntry->dwGroupOffset, pItem);
            if( pGroupEntry )
            {

                INET_ASSERT(pGroupEntry->gid);
                *((LONGLONG*) pGroupId) = pGroupEntry->gid;
            }
            else
            {
                dwError = ERROR_FILE_NOT_FOUND;
            }
        }
        else
        {
            *((LONGLONG*) pGroupId) = 0;
        }

        *pdwExemptDelta = pEntry->dwExemptDelta;
        dwError = ERROR_SUCCESS;
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}


DWORD URL_CONTAINER::CreateUniqueFile(LPCSTR UrlName, DWORD ExpectedSize,
                                   LPCSTR lpszFileExtension, LPTSTR FileName,
                                   HANDLE *phfHandle, BOOL fCreatePerUser)
/*++

Routine Description:

    This function creates a temperary file in the cache storage. This call
    is called by the application when it receives a url file from a
    server. When the receive is completed it caches this file to url cache
    management, which will move the file to permanent cache file. The idea
    is the cache file is written only once directly into the cache store.

Arguments:

    UrlName : name of the url file (unused now).

    ExpectedSize : expected size of the incoming file. If it is unknown
        this value is set to null.

    lpszFileExtension: extension for the filename created

    FileName : pointer to a buffer that receives the full path name of the
        the temp file.

    phfHandle : pointer to a handle that receives the handle of the file
        being create; pass null if we don't care (the file will be closed).

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    BOOL fMustUnlock;

    // BUGBUG - adding LockContainer here.
    if (!LockContainer(&fMustUnlock))
    {
        Error = (GetLastError());
        goto exit;
    }

    Error = _FileManager->CreateUniqueFile((LPSTR) UrlName, (LPSTR) FileName,
        (LPSTR) lpszFileExtension, (HANDLE*) phfHandle, (BOOL)fCreatePerUser);

exit:
    if (fMustUnlock) UnlockContainer();
    return( Error );
}



DWORD URL_CONTAINER::FindNextEntry
    (LPDWORD lpdwEnum, LPCACHE_ENTRY_INFO *ppCEI, LPDWORD lpdwCEI, DWORD dwFilter, GROUPID GroupId, DWORD dwFlags, DWORD dwRetrievalFlags)
{

    DWORD Error;
    URL_FILEMAP_ENTRY* pEntry;
    DWORD dwEnumSave;
    BOOL fMustUnlock;
    DWORD dwCopyFlags;

    if (!LockContainer(&fMustUnlock))
    {
        Error = GetLastError();
        goto Cleanup;
    }

    BOOL fCheckUser;
    fCheckUser = IsContentContainer() && !(dwFilter & OTHER_USER_CACHE_ENTRY);
    dwCopyFlags = 0;
    if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO)
    {
        dwCopyFlags = RETRIEVE_ONLY_STRUCT_INFO;
    }
    else if (dwFlags & FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME)
    {
        dwCopyFlags = RETRIEVE_ONLY_FILENAME;
    }
    dwCopyFlags |= dwRetrievalFlags;
    while (1)
    {
        dwEnumSave = *lpdwEnum;
        pEntry = (URL_FILEMAP_ENTRY*) _UrlObjStorage->FindNextEntry(lpdwEnum, dwFilter, GroupId);

        if(!pEntry)
        {
            Error = ERROR_NO_MORE_ITEMS;
            goto Cleanup;
        }

        // For content container, skip items marked for another user.
        if (fCheckUser)
        {
            LPSTR pszHeaders = ((LPSTR) pEntry) + pEntry->HeaderInfoOffset;
            if (!IsCorrectUser(pszHeaders, pEntry->HeaderInfoSize))
                continue;
        }

        // Copy the data
        Error = CopyUrlInfoGuard(pEntry, ppCEI, lpdwCEI, dwCopyFlags);
        switch (Error)
        {
            case ERROR_INSUFFICIENT_BUFFER:
                // Restore current enum position.
                *lpdwEnum = dwEnumSave;
                goto Cleanup;

            case ERROR_FILE_NOT_FOUND:
                continue;

            default:
                INET_ASSERT (FALSE);
            // intentional fall through
            case ERROR_SUCCESS:
                goto Cleanup;
        }
    } // end while(1)

Cleanup:
    if (fMustUnlock) UnlockContainer();
    return Error;
}



/*------------------------------------------------------------------------------
    CopyUrlInfo

Routine Description:

    Copy URL info data from an URL_FILEMAP_ENTRY in the memory mapped file
    to CACHE_ENTRY_INFO output buffer. If the buffer given is sufficient,
    it returns ERROR_INSUFFICIENT_BUFFER, and pcbInfo will contain
    buffer size required.

Arguments:

    pEntry     : pointer to the source of the URL info.

    ppInfo   : ptr to ptr to an entry info buffer, where the url entry info
               is returned.

    pcbInfo : pointer to a DWORD location containing the size of the
               above buffer, on return it has the size of the buffer consumed or
               size of the buffer required for successful retrieval.

Return Value:

    Windows Error Code.

------------------------------------------------------------------------------*/
DWORD URL_CONTAINER::CopyUrlInfo(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD cbRequired;
    DWORD dwError = ERROR_SUCCESS;
    DWORD cbSourceUrlName;
    DWORD cbLocalFileName;
    DWORD cbHeaderInfo;
    DWORD cbFileExt;

    INET_ASSERT(!((dwFlags & RETRIEVE_WITH_ALLOCATION) &&
                  (dwFlags & RETRIEVE_ONLY_FILENAME
                    || dwFlags & RETRIEVE_ONLY_STRUCT_INFO)));
    // Check signature
    if (pEntry->dwSig != SIG_URL)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Verify url string exists.
    if (!pEntry->UrlNameOffset)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
        goto exit;
    }

    // Hate using goto's but, don't want to clutter anymore than I have to.
    // We assume that anything functions that pass these flags will have allocated
    // enough memory before hand.
    if ((dwFlags & RETRIEVE_ONLY_FILENAME) || (dwFlags & RETRIEVE_ONLY_STRUCT_INFO))
    {
        if (ppInfo && *ppInfo)
        {
            memset(*ppInfo, 0, sizeof(INTERNET_CACHE_ENTRY_INFO));
        }
        goto ShortCircuit;
    }

    // -----------------  Calculate embedded data sizes ------------------------
    // All byte counts are sizes.

    // SourceUrlName length;
    cbSourceUrlName = strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset)) + 1;

    // LocalFileName length.
    if(pEntry->InternalFileNameOffset)
    {
        cbLocalFileName =
            _FileManager->GetDirLen(pEntry->DirIndex)
            + strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset))
            + 1;
    }
    else
        cbLocalFileName = 0;

    // HeaderInfo length.
    cbHeaderInfo = (pEntry->HeaderInfoOffset) ? pEntry->HeaderInfoSize + 1 : 0;

    // File extension length.
    if (pEntry->FileExtensionOffset)
    {
        cbFileExt =
              strlen((LPSTR) OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset)) + 1;
    }
    else
        cbFileExt = 0;

    // Alignment - these quantities are already aligned in
    // URL_FILEMAP_ENTRY and should be reflected in its size.
    cbSourceUrlName  = ROUNDUPDWORD(cbSourceUrlName);
    cbLocalFileName  = ROUNDUPDWORD(cbLocalFileName);
    cbHeaderInfo     = ROUNDUPDWORD(cbHeaderInfo);
    cbFileExt        = ROUNDUPDWORD(cbFileExt);

    cbRequired = *pcbInfo;
    *pcbInfo = sizeof(CACHE_ENTRY_INFO)
                   + cbSourceUrlName
                   + cbLocalFileName
                   + cbHeaderInfo
                   + cbFileExt;

    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are allocating entry info, use the ex version.
        *pcbInfo += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
        *ppInfo = (LPCACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbInfo);
        if (!*ppInfo)
        {
            dwError = ERROR_NOT_ENOUGH_MEMORY;
            goto exit;
        }
    }
    else
    {
        // Second check for required buffer size.
        if (cbRequired < *pcbInfo )
        {
            dwError = ERROR_INSUFFICIENT_BUFFER;
            goto exit;
        }
    }

    // ----------------------  Copy embedded data --------------------------------

    // A Typical CACHE_ENTRY_INFO will look like
    //
    // [CACHE_ENTRY_INFO][UrlName][FileName][Headers][FileExtension]
    //
    //                   ^        ^         ^        ^
    //                   |        |         |        |
    //                   |        |         |        lpszFileExtension
    //                   |        |         |
    //                   |        |         lpHeaderInfo
    //                   |        |
    //                   |        lpszLocalFileName
    //                   |
    //                   lpszSourceUrlName
    //

    // Pointer walks through CACHE_ENTRY_INFO appended data.
    LPBYTE pCur;
    pCur = (LPBYTE) *ppInfo + sizeof(CACHE_ENTRY_INFO);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        // If we are creating the -ex version, skip over those fields.
        pCur += sizeof(CACHE_ENTRY_INFOEX) - sizeof(CACHE_ENTRY_INFO);
    }

    // UrlName.
    memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->UrlNameOffset), cbSourceUrlName);
    (*ppInfo)->lpszSourceUrlName = (LPSTR) pCur;
    pCur += cbSourceUrlName;

    // FileName
    if (cbLocalFileName)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) pCur, &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        
        (*ppInfo)->lpszLocalFileName = (LPTSTR) pCur;
        pCur += cbLocalFileName;
    }
    else
        (*ppInfo)->lpszLocalFileName = NULL;


    // HeaderInfo
    if (cbHeaderInfo)
    {
        memcpy (pCur, OFFSET_TO_POINTER(pEntry, pEntry->HeaderInfoOffset),
            pEntry->HeaderInfoSize);
        pCur[pEntry->HeaderInfoSize] = 0;
        (*ppInfo)->lpHeaderInfo = (LPTSTR)pCur;
        pCur += cbHeaderInfo;
    }
    else
        (*ppInfo)->lpHeaderInfo = NULL;


    // FileExt
    if (cbFileExt)
    {
        memcpy(pCur, OFFSET_TO_POINTER(pEntry, pEntry->FileExtensionOffset), cbFileExt);
        (*ppInfo)->lpszFileExtension = (LPTSTR) pCur;
        pCur += cbFileExt;
    }
    else
        (*ppInfo)->lpszFileExtension = NULL;


    // ------------  Set remaining CACHE_ENTRY_INFO members -------------
ShortCircuit:
    // Struct size, entry type, use count and hit rate.
    (*ppInfo)->dwStructSize = URL_CACHE_VERSION_NUM;
    (*ppInfo)->CacheEntryType = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
    if (pEntry->bSyncState == SYNCSTATE_STATIC)
        (*ppInfo)->CacheEntryType |= STATIC_CACHE_ENTRY;
    (*ppInfo)->dwUseCount     = pEntry->NumReferences;
    (*ppInfo)->dwHitRate      = pEntry->NumAccessed;

    // File size.
    (*ppInfo)->dwSizeLow      = pEntry->dwFileSize;
    (*ppInfo)->dwSizeHigh     = 0;

    // Last modified, expire, last access and last sync times, maybe download time.
    (*ppInfo)->LastModifiedTime   = *LONGLONG_TO_FILETIME(&pEntry->LastModifiedTime);

    // expire time may be 0

    DosTime2FileTime(pEntry->dostExpireTime, &((*ppInfo)->ExpireTime));

    (*ppInfo)->LastAccessTime     = *LONGLONG_TO_FILETIME(&pEntry->LastAccessedTime);
    if (dwFlags & RETRIEVE_WITH_ALLOCATION)
    {
        CACHE_ENTRY_INFOEX* pCEI = (CACHE_ENTRY_INFOEX*) *ppInfo;
        DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostFileCreationTime),
                             *((LPWORD)&(pEntry->dostFileCreationTime)+1),
                             &pCEI->ftDownload);

        DosTime2FileTime(pEntry->dostPostCheckTime, &pCEI->ftPostCheck);

    }

    DosDateTimeToFileTime(*(LPWORD)&(pEntry->dostLastSyncTime),
                          *((LPWORD)&(pEntry->dostLastSyncTime)+1),
                          &((*ppInfo)->LastSyncTime));


    // Header info size and exempt delta.
    (*ppInfo)->dwHeaderInfoSize   = pEntry->HeaderInfoSize;
    (*ppInfo)->dwExemptDelta      = pEntry->dwExemptDelta;

    // If we want only struct info and filename, we'll assume that we've preallocated
    // enough memory.
    if (dwFlags & RETRIEVE_ONLY_FILENAME)
    {
        DWORD cb;
        if (!_FileManager->GetFilePathFromEntry(pEntry, (LPSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO),
            &(cb = MAX_PATH)))
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto exit;
        }
        (*ppInfo)->lpszLocalFileName = (LPTSTR) (*ppInfo) + sizeof(INTERNET_CACHE_ENTRY_INFO);
    }

exit:
    return dwError;
}


// CopyUrlInfoGuard puts an exception handler around CopyUrlInfo
// for those case when we don't get a chance to flush the memory-mapped
// file, thus corrupting the cache.

// We put the try in this function, rather than in CopyUrlInfo, to
// avoid affecting the perf characteristics.
DWORD URL_CONTAINER::CopyUrlInfoGuard(LPURL_FILEMAP_ENTRY   pEntry,
                                 LPCACHE_ENTRY_INFO*   ppInfo,
                                 LPDWORD               pcbInfo,
                                 DWORD                 dwFlags)
{
    DWORD dwError;
    
    __try
    {
        dwError = CopyUrlInfo(pEntry, ppInfo, pcbInfo, dwFlags);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_FILE_NOT_FOUND;
    }
    ENDEXCEPT
    return dwError;
}


void URL_CONTAINER::UnlockItem (URL_FILEMAP_ENTRY* pEntry, HASH_ITEM* pItem)
{
    // Possibly a bogus assert due to using lazy-write mappings?
    //INET_ASSERT (pEntry->NumReferences);


    if (pEntry->NumReferences)
    {
        if (--pEntry->NumReferences)
        {
            if( !pItem->IsLocked() )
            {
                // corrupted index file, we have to believe the hash table
                // to fixup the cache entry
                INET_ASSERT (FALSE);
                pEntry->NumReferences = 0;
            }
        }
        else
        {
            pItem->ClearLocked();

            // If the item is marked for pending delete, do it now.
            if (pEntry->CacheEntryType & PENDING_DELETE_CACHE_ENTRY)
                DeleteUrlEntry (pEntry, pItem, SIG_DELETE);
        }
    }
}


void URL_CONTAINER::UnlockAllItems (void)
{
    DWORD dwEnum = *(_UrlObjStorage->GetPtrToHashTableOffset());

    // Enumerate hash table items.
    while (dwEnum)
    {
        HASH_ITEM *pItem = HashGetNextItem
            (_UrlObjStorage, *(_UrlObjStorage->GetHeapStart()), &dwEnum, 0);

        if (pItem && (pItem->IsLocked()))
        {
            // Validate and unlock the entry.
            URL_FILEMAP_ENTRY *pEntry =
                _UrlObjStorage->ValidateUrlOffset (pItem->dwOffset);
            if (!pEntry)
                pItem->MarkFree(); // invalid item
            else
            {
                // Clear the lockcount.
                pEntry->NumReferences = 1;
                UnlockItem (pEntry, pItem);
            }
        }
    }
}


DWORD URL_CONTAINER::RegisterCacheNotify( HWND      hWnd,
                                          UINT      uMsg,
                                          GROUPID   gid,
                                          DWORD     dwFilter)
{
    BOOL fUnlock;
    LockContainer(&fUnlock);

    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_HWND,    GuardedCast((DWORD_PTR)hWnd));
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_MESG,    (DWORD)uMsg);
    _UrlObjStorage->SetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER,  (DWORD)dwFilter);

    if (fUnlock) UnlockContainer();

    return ERROR_SUCCESS;
}


// update stickness will do:
//      1. flip the bit
//      2. update the exempt usage
//      3. send notification
DWORD URL_CONTAINER::UpdateStickness( URL_FILEMAP_ENTRY* pEntry,
                                      DWORD              dwOp,
                                      DWORD              dwItemOffset)
{
    DWORD dwError = ERROR_SUCCESS;

    if( dwOp == URLCACHE_OP_SET_STICKY )
    {
        if( !( pEntry->CacheEntryType & STICKY_CACHE_ENTRY ) )
        {
            // Ensure that exempt items do not crowd the cache.
            LONGLONG FileUsage = RealFileSize(pEntry->dwFileSize);
            LONGLONG ExemptUsage = _UrlObjStorage->GetExemptUsage();
            LONGLONG CacheLimit  = _UrlObjStorage->GetCacheLimit();
            LONGLONG MaxExempt = (CacheLimit * MAX_EXEMPT_PERCENTAGE) / 100;
            if (ExemptUsage + FileUsage > MaxExempt)
                return ERROR_DISK_FULL;

            pEntry->CacheEntryType |= STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_SET_STICKY, dwItemOffset);
        }
    }

    else
    if( dwOp == URLCACHE_OP_UNSET_STICKY )
    {
        if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY )
        {
            pEntry->CacheEntryType &= ~STICKY_CACHE_ENTRY;
            _UrlObjStorage->AdjustExemptUsage(-RealFileSize(pEntry->dwFileSize));
            NotifyCacheChange(CACHE_NOTIFY_URL_UNSET_STICKY, dwItemOffset);
        }
    }
    else
    {
        dwError = ERROR_INVALID_PARAMETER;
    }

    return dwError;
}

VOID FileTime2DosTime(FILETIME ft, DWORD* pdt)
{
    INET_ASSERT(pdt);

    *pdt = 0;
    if( FT2LL(ft) != LONGLONG_ZERO )
    {
        if( FT2LL(ft) == MAX_FILETIME)
        {
            *pdt = MAX_DOSTIME;
        }
        else
        {
            FileTimeToDosDateTime(
                &ft,
                ((LPWORD)(pdt)    ),
                ((LPWORD)(pdt) + 1)
            );
        }
    }
}

VOID DosTime2FileTime(DWORD dt, FILETIME* pft)
{
    INET_ASSERT(pft);

    LONGLONG llZero = LONGLONG_ZERO;
    LONGLONG llMax = MAX_FILETIME;
    if( dt )
    {
        if( dt == MAX_DOSTIME )
        {
            *pft = *LONGLONG_TO_FILETIME(&llMax);
        }
        else
        {
            DosDateTimeToFileTime(
                *((LPWORD)&(dt)    ),
                *((LPWORD)&(dt) + 1),
                pft
            );
        }
    }
    else
    {
        *pft = *LONGLONG_TO_FILETIME(&llZero);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\downsize.cxx ===
/*++
Copyright (c) 1997  Microsoft Corp.

Module Name: downsize.cxx

Abstract:

    Implementation of heuristic pruning and wholesale purge of cache index.

Author:

    Rajeev Dujari (rajeevd) 15-Apr-97

    RajeevD rewrote scoring and pruning algo, Aug-98.

--*/

#include <cache.hxx>

#ifdef BETA_LOGGING
#define SCAVENGER_TRACE
#define TRACE_FACTOR 99
#endif


BOOL // whether memory mapped index file was deleted
URL_CONTAINER::DeleteIndex (void)
{                                        
    BOOL fRetVal = FALSE;
    BOOL fMustUnlock;

    // Get the full path name of the cache directory.
    if (!LockContainer(&fMustUnlock))
        goto exit;

    CHAR szFullPath[MAX_PATH];
    memcpy(szFullPath, _UrlObjStorage->GetFullPathName(),
        _UrlObjStorage->GetFullPathNameLen() + 1);

    if (fMustUnlock)
    {
        UnlockContainer();
        fMustUnlock = FALSE;
    }

    // Delete the cache files not in use (index.dat is open by us)
    CFileMgr::DeleteCache (szFullPath);

    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(szFullPath);


    if (!LockContainer(&fMustUnlock))
        goto exit;

#ifdef NUKE_CACHE_INDEX_FILE

    // If no handles are actively in use by this process,
    // attempt to shrink the index file.
    if (!AnyFindsInProgress(0) && !GlobalRetrieveUrlCacheEntryFileCount)
    {

        LONGLONG qwLimit = _UrlObjStorage->GetCacheLimit();
        fRetVal = _UrlObjStorage->Reinitialize();
        if (fRetVal)
        {
            _UrlObjStorage->SetCacheLimit (qwLimit);
            _FileManager->Init();
            // BUGBUG: call SetCacheSize with total not deleted by DeleteCache.

        }
    }

#endif

exit:
    if (fMustUnlock)
        UnlockContainer();
    return fRetVal;
}

// Weightings of various score components...
#define IDLETIME_WEIGHT     (60000)
#define EXPIRY_WEIGHT       ( 3000)
#define NUMACCESS_WEIGHT    ( 3000)

/*=======================================================================
ScoreEntry computes the score for the given url entry.

    The lower the score the more likely is an entry to be
    removed from the cache. Entries with higher scores are
    considered more useful.  Only the relative values matter.

    The components that contribute to the score are as follows...
        idle time since last access
        number of times accessed
        expiry, last-modified, and other sync factors
    They are weighted so that idle time predominates if the
    item has been accessed recently while older items are
    more easily influenced by the other factors.

    IDLE TIME is measured as number of days since last access,
    not rounded to an integer but including a fraction.  Then
    the score decays as 1/(days+1).  To illustrate:

        Elapsed Time    Rel. Score
        ============    ==========
        0                   60
        12 hours            40
        1 day               30
        1.5 days            24
        2 days              20
        5 days              10
        9 days               6
        29 days              2
        30-59 days           1
        60+ days             0

    NUMBER OF TIMES ACCESSED is a predictor of both the likelihood
    the item will ever be accessed again and the frequency of future
    access.  This subscore is scaled by (1 - 1/num).  For example:

        Num         Rel. Score
        ===         ==========
         1               0
         2              10
         4              15
        10              18
        20+             20

    EXPIRY in the future is worth full credit because we need
    not issue if-modified-since requests (except upon refresh.)

    Similarly, an item which is approaching SYNCSTATE_VOLATILE
    gets checked rarely and gets nearly full credit.  Items on
    the way to approaching this state get pro-rated credit.

    An expiry in the past is treated same has no expiry at all.

    An item gets half credit if last-modified-time is set.
    Otherwise any net hit would download  new content so the
    cache entry is of limited value.

    To summarize:

        Expiry  LastMod SyncState   Rel. Score
        ======  ======= =========   ==========
        future  n/a     n/a             14
        other   present static          13
        other   present image            8
        other   present volatile         7
        other   none    n/a              0

    We are agnostic about file size.  Pruning a larger file means
    we reclaim a lot of disk space, but it takes longer to download.
    Small files often waste a lot of disk space on a FAT partition,
    but incur the same fixed cost as downloading a large file.

Arguments:
    pEntry :  pointer to the Url entry.
    CurrentGmtTime : Current GMT time.

Return Value: DWORD score.
=======================================================================*/
DWORD ScoreEntry
(
    URL_FILEMAP_ENTRY* pEntry,
    LONGLONG CurrentGmtTime
)
{
    INET_ASSERT(pEntry->dwSig == SIG_URL);

    // Compute scored based on days since last access.

    // We're adding 15 minutes to the CurrentGmtTime to account for the continual 
    // readjustments to the pc's internal clock; this will handle occasional blips
    // (cases when the gmt is suddenly earlier than the LastAccessedTime, for example)
    CurrentGmtTime += (15*60*FILETIME_SEC);

    LONGLONG IdleTime = CurrentGmtTime - pEntry->LastAccessedTime;

    // In case the Last Accessed Time is later than the GMT, we want to protect against
    // a negative time
    if (IdleTime < 0)
    {
        IdleTime = 0;
    }

    DWORD dwScore = (DWORD) (((LONGLONG) IDLETIME_WEIGHT * FILETIME_DAY)
        / (IdleTime + FILETIME_DAY));

#ifdef UNIX
    {
       /* We don't want to delete items that were just created.
        * On Win32, because the InternetLockRequestFile will hold onto
        * the entries. This will not work on Unix because they use
        * InternetLockRequestFile uses CreateFile, which does not really
        * lock the file on unix, because of the lack of file handles.
        * 
        * So, just like in IE4, we will give a grace period for the cache
        * item.
        */
       #define UNIX_STICKY_SCORE 0L
       if (IdleTime < (1 * 60 * (LONGLONG)10000000))
          return UNIX_STICKY_SCORE;
    }
#endif /* UNIX */

    // Add to score based on number of times accessed.
    DWORD dwAccess = pEntry->NumAccessed;
    if (!dwAccess)
    {
        INET_ASSERT (pEntry->NumAccessed);
        dwAccess = 1;
    }
    dwScore += NUMACCESS_WEIGHT - NUMACCESS_WEIGHT/dwAccess;

    // Add to score based on expiry and syncstate.
    FILETIME ftExpireTime;
    DosTime2FileTime(pEntry->dostExpireTime, &ftExpireTime);
    if (FT2LL(ftExpireTime) > CurrentGmtTime)
        dwScore += EXPIRY_WEIGHT;
    else if (pEntry->LastModifiedTime)
    {
        // Add a bonus for having a last-modified time.
        dwScore += EXPIRY_WEIGHT / 2;

        // Add more as the item approaches auto sync mode.
        INET_ASSERT (pEntry->bSyncState <= SYNCSTATE_STATIC);
        dwScore += (EXPIRY_WEIGHT * pEntry->bSyncState)
            / (2 * (SYNCSTATE_STATIC + 1));
    }

    INET_ASSERT (dwScore <=
        IDLETIME_WEIGHT + EXPIRY_WEIGHT + NUMACCESS_WEIGHT);
    return dwScore;
}


/*=======================================================================
WalkLeakList attempts to delete files that we couldn't delete earlier.
========================================================================*/
BOOL URL_CONTAINER::WalkLeakList (void)
{
    BOOL fMustUnlock;
    LockContainer(&fMustUnlock);

    // Set loop variables to head of list.
    DWORD dwPrevOffset = OffsetFromPointer(_UrlObjStorage->GetPtrToLeakListOffset());
    DWORD dwCurrOffset, dwFirstItemOffset;
    _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwCurrOffset);

    // Validate offset and block signature.
    URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
    if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
        || pEntry->dwSig != SIG_LEAK)
    {
        INET_ASSERT(dwCurrOffset==0);
        
        // Replace the bad link with a terminator.
        _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET, 
                                      0);
        return fMustUnlock;
    }
    dwFirstItemOffset = dwCurrOffset;
    
    while (1)
    {
        // Extract full path of the file.
        // and attempt to delete the file.
        DWORD cb;
        TCHAR szFile[MAX_PATH];

        if (_FileManager->GetFilePathFromEntry(pEntry, szFile, &(cb = MAX_PATH))
            &&
            (!pEntry->NumReferences)
            &&
            (_FileManager->DeleteOneCachedFile
                (szFile, pEntry->dostFileCreationTime, pEntry->DirIndex)))
        {
            // Adjust cache usage.
            _UrlObjStorage->AdjustCacheSize(-RealFileSize(pEntry->dwFileSize));

            // Remove this item from the list.
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = pEntry->dwNextLeak;

            if (dwFirstItemOffset==dwCurrOffset)
            {
                _UrlObjStorage->SetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  pEntry->dwNextLeak);
            }
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }

            _UrlObjStorage->FreeEntry(pEntry);
        }
        else
        {
            // We don't have permission to delete this entry
            dwPrevOffset = OffsetFromPointer (&pEntry->dwNextLeak);
            if( dwCurrOffset != pEntry->dwNextLeak )
            {
                dwCurrOffset = pEntry->dwNextLeak;
            }
            else
            {
                // we have a circular list, break now
                // Replace the bad link with a terminator.
                dwCurrOffset = 0;
                LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
                *pdwPrev = 0;
            }
        }
    
        // If the shutdown event signalled, call it quits.
        // Also, if we've reached the end of the list, quit
        if (GlobalPleaseQuitWhatYouAreDoing || (dwCurrOffset==0))
            break;

        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        if (_UrlObjStorage->IsBadOffset (dwCurrOffset)
            || pEntry->dwSig != SIG_LEAK)
        {
            // Replace the bad link with a terminator.
            INET_ASSERT (FALSE);
            LPDWORD pdwPrev = (LPDWORD) PointerFromOffset (dwPrevOffset);
            *pdwPrev = 0;
            break;
        }
        pEntry->NumReferences++;

        // Relinquish the lock and time slice so other threads don't get starved.
        if (fMustUnlock)
        {
            UnlockContainer();
            fMustUnlock = FALSE;
        }

        SuspendCAP();
        Sleep (0);
        ResumeCAP();

        LockContainer(&fMustUnlock);
        _UrlObjStorage->GetHeaderData(CACHE_HEADER_DATA_ROOT_LEAK_OFFSET,
                                  &dwFirstItemOffset);
        pEntry = (URL_FILEMAP_ENTRY*) PointerFromOffset (dwCurrOffset);
        pEntry->NumReferences--;
    }

    return fMustUnlock;
}

/*=======================================================================
IsUrlEntryExemptFromScavenging filters out items exempt from scavenging.

Returns BOOL: TRUE indicating the item should not be scavenged.
========================================================================*/
BOOL URL_CONTAINER::IsUrlEntryExemptFromScavenging
(
    HASH_ITEM* pItem,
    URL_FILEMAP_ENTRY* pEntry,
    DWORD dwFilter,
    LONGLONG qwGmtTime,
    GroupMgr* pgm
)
{
    // If entry points to a store directory, ignore it.
    if ((pEntry->DirIndex == INSTALLED_DIRECTORY_KEY)
    || (pEntry->CacheEntryType & EDITED_CACHE_ENTRY))
    {
        return TRUE;
    }

    // If filter==0, trash everything, son.
    if (dwFilter==0)
    {
        return FALSE;
    }
    
    // If entry type excluded by filter, ignore it.
    if (pEntry->CacheEntryType & dwFilter)
        return TRUE;

    // If not deleting all entries, check for exemption from scavenging.
    if( pEntry->CacheEntryType & STICKY_CACHE_ENTRY)
    {
        // sticky + exemptDelta == 0 means sticky forever
        // because item must belong to non-purgeable group
        // or the cache entry type would not have sticky bit.
        if( !(pEntry->dwExemptDelta) )
            return TRUE;

        // sticky group == sticky forever! no exempt delta
        // needs to be looked.

        if( pEntry->dwGroupOffset )
        {
            if( pItem->HasMultiGroup() )
            {
                // multiple group
                // if there are other sticky groups attached to
                // this url entry, leave this entry alone
                if(!pgm->NoMoreStickyEntryOnList(pEntry->dwGroupOffset))
                    return TRUE;
            }
            else
            {
                // single group
                // if the group attached to this url entry is
                // sticky, leave this entry alone
                GROUP_ENTRY* pGroupEntry = NULL;
                pGroupEntry = _UrlObjStorage->ValidateGroupOffset
                    (pEntry->dwGroupOffset, pItem);
                if(pGroupEntry && IsStickyGroup(pGroupEntry->gid) )
                    return TRUE;
            }
        }

        // Skip over the item if it's within its exemption period.
        // FILETIME units are 100-ns ticks, exempt delta in seconds.

        LONGLONG qwExemptDelta = FILETIME_SEC * pEntry->dwExemptDelta;
        if (qwGmtTime < pEntry->LastAccessedTime + qwExemptDelta)
            return TRUE;
    }

    return FALSE;
}

/*=======================================================================
ScavengeItem deletes a cache entry and yields with the lock unowned.

Returns BOOL: FALSE if dll shutdown has been signalled.
========================================================================*/
BOOL URL_CONTAINER::ScavengeItem (HASH_ITEM* pItem, BOOL* pfMustUnlock)
{
    DeleteUrlEntry (HashGetEntry (pItem), pItem, SIG_DELETE);

    // If the shutdown event signalled, call it quits.
    if (GlobalPleaseQuitWhatYouAreDoing)
        return FALSE;

    // Relinquish the lock and time slice so other threads don't get starved.
    if (*pfMustUnlock)
    {
        UnlockContainer();
        *pfMustUnlock = FALSE;
    }

    SuspendCAP();
    Sleep (0);
    ResumeCAP();

    LockContainer(pfMustUnlock);
    return TRUE;
}


#define NUM_SCORE_ITEMS 100

//=======================================================================
#define FIND_MIN 1
#define FIND_MAX 0

PRIVATE SCORE_ITEM* FindMinOrMaxScoreItem
    (SCORE_ITEM* pScore, DWORD cScore, DWORD MinOrMax)
{
    INET_ASSERT (cScore);
    INET_ASSERT (MinOrMax == FIND_MIN || MinOrMax == FIND_MAX);

    SCORE_ITEM* pRet = pScore;
    DWORD dwScore = pScore->dwScore;

    for (DWORD iScore=1; iScore<cScore; iScore++)
    {
        pScore++;
        if ((dwScore < pScore->dwScore ? TRUE : FALSE) ^ MinOrMax)
        {
            pRet = pScore;
            dwScore = pScore->dwScore;
        }
    }

    return pRet;
}

//=======================================================================
PRIVATE void SwapScoreItems (SCORE_ITEM *p1, SCORE_ITEM *p2)
{
    SCORE_ITEM t;
    memcpy (&t, p1, sizeof(SCORE_ITEM));
    memcpy (p1, p2, sizeof(SCORE_ITEM));
    memcpy (p2, &t, sizeof(SCORE_ITEM));
}

//=======================================================================
PRIVATE void SortScoreItems (SCORE_ITEM* pScore, DWORD cScore)
{

    while (cScore > 1)
    {
        SCORE_ITEM *pMax =
            FindMinOrMaxScoreItem (pScore, cScore--, FIND_MAX);
        SwapScoreItems (pScore + cScore, pMax);
    }
}

//=======================================================================
void URL_CONTAINER::ScavengerDebugSpew
    (SCORE_ITEM* pScoreItem, LONGLONG* pqwDeleted)
{
    HASH_ITEM* pItem = (HASH_ITEM*)
        (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
    if (pScoreItem->dwHashValue == pItem->GetValue()
        && pScoreItem->dwHashOffset == pItem->dwOffset)
    {
        URL_FILEMAP_ENTRY* pEntry = HashGetEntry (pItem);
        char szBuf[1024];
        LPSTR pszOp;

        if (!pqwDeleted)
            pszOp = "IGNORE";
        else
        {
            pszOp = "DELETE";
            *pqwDeleted += RealFileSize (pEntry->dwFileSize);
        }

        wsprintf (szBuf, "%s %05d ", pszOp, pScoreItem->dwScore);
        OutputDebugString (szBuf);
        if (pqwDeleted)
        {
            wsprintf (szBuf, "%02d%% ", (*pqwDeleted * 100) / GetCacheLimit());
            OutputDebugString (szBuf);
        }
        PrintFileTimeInInternetFormat ((FILETIME*)
            &pEntry->LastAccessedTime , szBuf, sizeof(szBuf));
        OutputDebugString (szBuf);
        wsprintf (szBuf, " %s\n", ((LPSTR) pEntry) + pEntry->UrlNameOffset);
        OutputDebugString (szBuf);
    }
}


#ifndef SCAVENGER_TRACE
#define ScavengerTrace(x,y,z) { }
#else
#define ScavengerTrace(dwFactor, pScoreItem, pdwDel) \
    if (dwFactor==TRACE_FACTOR) {ScavengerDebugSpew(pScoreItem, pdwDel);}
#endif

/*========================================================================*/
DWORD URL_CONTAINER::FixupHandler (DWORD dwFactor, DWORD dwFilter)
{
    LOCK_CACHE();
    
    if (!g_pfnFixup)
    {
        // This is the first time we needed the handler; initialize.
        char szDll[MAX_PATH + 80];
        DWORD cbDll = sizeof(szDll);
        
        // Look up the fixup handler for the highest cache version installed.
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);
        if (ERROR_SUCCESS != roCache.GetStatus())
            goto err;
        if (ERROR_SUCCESS != roCache.GetValue (g_szFixup, (LPBYTE) szDll, &cbDll))
            goto err;
            
        LPSTR pszEntryPoint;

        // The dll name and entry point are delimited by a comma; tokenize.
        pszEntryPoint = StrChr (szDll, TEXT(','));
        if (!pszEntryPoint)
            goto err;
        *pszEntryPoint++ = 0;
        
        g_hFixup = LoadLibrary (szDll);
        if (!g_hFixup)
            goto err;
                
        g_pfnFixup = (PFN_FIXUP) GetProcAddress (g_hFixup, pszEntryPoint);
        if (!g_pfnFixup)
        {
            FreeLibrary (g_hFixup);
            goto err;
        }
    }

    UNLOCK_CACHE();
    
    return (*g_pfnFixup)
        (ENTRY_VERSION_CURRENT, _CachePath, _CachePrefix, 
        &GlobalPleaseQuitWhatYouAreDoing, dwFactor, dwFilter, NULL);

err:
    // We couldn't locate async fixup handler; fail gracefully.
    g_szFixup[0] = 0;
    UNLOCK_CACHE();
    return ERROR_INTERNET_INTERNAL_ERROR;
}


/*=======================================================================
Routine Description:

Arguments:
    Factor : amount of free space to make. Factor of 25 means delete
        sufficient files to make CacheSize <= .75 * CacheLimit.

The index does not maintain a list of items sorted by score because the cost
of scavenging would be amortized across update operations, which are
performed on a foreground thread.  Such a list would be doubly linked because
updating an item would change its score and probably change its rank.  If the
items were directly linked together, this would likely result in touching two
other random pages on update.  A lookaside list would be a better approach
but would still require hitting another page on update or increasing the size
of the lookup hash table.  Furthermore, the ranking would need to be strictly
LRU, or else we would have to a 16-bit score in the entry and an updated item
might not go to the head of the list and require some traversal.

The scavenger thread scores items on the fly.  It attempts to avoid a full
enumeration of the cache and sorting of the scores.  Instead, it attempts to
track items that fall below a cutoff score and delete the lowest-scoring
among this set, possibly before completing the enumeration.  Specifically, it
starts by enumerating 100 items and sorting them.  Since the rank of the
items is uniformly distributed, by definition, the score of the 10th lowest
item is an estimate of the 10th percentile.  Of course, deleting 10% of the
items in the cache is no guarantee 10% of disk usage will be reclaimed.
However hitting the low-water mark of 90% of cache quota is not a strict goal
and will probably get the cache under the quota.  Even if not, the scavenger
will be invoked again on the next update and establish a higher cutoff.

If this cutoff score proves to be too low, then it's possible the scavenger
will enumerate the entire cache without bringing it below quota, in which
case it will be restarted by the next cache update, probably with a higher
threshhold.  On the other hand, if the cutoff score is too high, then we
might end the enumeration early and delete some items in the 20th or even
30th percentiles.  The latter outcome seems better since we never promised to
be perfect anyway, so we bias the algorithm by picking the 20th lowest
item for the threshhold score.

Once the cutoff score is established, the enumeration continues.  The list is
not kept sorted.  If all of the items in the 100-item list are below the
cutoff, then the lowest-scoring one is deleted.  Otherwise the highest-scoring
item is merely removed from the list and forgotten.  The the next item in the
enumeration is added to the list.  If the enumeration completes without
reaching the target usage, then the lowest-scoring item is deleted until the
list is empty, even those items that fall above the cutoff, which after all was
too low.

After each file deletion, the scavenger thread yields without holding the
container lock.  Otherwise another thread wanting to acquire the lock would
block, wake up the scavenger thread, and switch back after the scavenger
unlocked.

Return Value: ERROR_SUCCESS
========================================================================*/
DWORD URL_CONTAINER::CleanupUrls(DWORD dwFactor, DWORD dwFilter)
{
    DWORD Error = ERROR_SUCCESS;

    // dwFactor must be between 1 and 100 inclusive.
    INET_ASSERT (dwFactor >= 1 && dwFactor <= 100);

    // If an uplevel fixup handler is installed, delegate.

    if (g_szFixup[0])
        return FixupHandler (dwFactor, dwFilter);
    
    // Special case purging entire container.
    BOOL fPurge = (dwFactor == 100 && dwFilter == 0);
    if (fPurge && DeleteIndex())
        return ERROR_SUCCESS;

    // First loop through the leaked files and try to delete them.
    BOOL fMustUnlock = WalkLeakList();

    // before index get nuked, we need to send out last notification
    // about the whole cache gets deleted
    DWORD dwHWnd = 0;
    DWORD dwUMsg = 0;
    DWORD dwNotifFilter = 0;

    GroupMgr gm;
    if( !gm.Init(this) )
    {
        INET_ASSERT(FALSE);
    }

    BOOL fLowDiskSpace = FALSE;
    
    _UrlObjStorage->GetHeaderData(
            CACHE_HEADER_DATA_NOTIFICATION_FILTER, &dwNotifFilter);
    if( dwNotifFilter & CACHE_NOTIFY_DELETE_ALL)
    {
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_HWND, &dwHWnd);
        _UrlObjStorage->GetHeaderData( CACHE_HEADER_DATA_NOTIFICATION_MESG, &dwUMsg);
    }

    // Calculate usage goal.
    LONGLONG qwQuota = _UrlObjStorage->GetCacheLimit();
    LONGLONG qwGoal = (qwQuota * (100 - dwFactor)) / 100;
    LONGLONG qwGmtTime;
    GetCurrentGmtTime ((FILETIME*) &qwGmtTime);

    DWORDLONG dlAvail = 0;
    if (GetDiskInfo(_CachePath, NULL, &dlAvail, NULL)
        &&
        (BOOL)(dlAvail <= (DWORDLONG)GlobalDiskUsageLowerBound))
    {
        fLowDiskSpace = TRUE;
        // We'll set the goal even lower, if the disk space falls below the 4 GIG threshold
        // qwResult contains how much disk space would be available with the current goal
        LONGLONG qwResult = dlAvail + (_UrlObjStorage->GetCacheSize() - qwGoal);
        if (qwResult < (LONGLONG)GlobalDiskUsageLowerBound)
        {
            qwGoal = _UrlObjStorage->GetCacheSize() - ((LONGLONG)(GlobalDiskUsageLowerBound - dlAvail));

            // At the very least, we'll preserve 128K (about three pages)
            if (qwGoal<(LONGLONG)(128*1024))
            {
                qwGoal = (LONGLONG)(128*1024);
            }
        }
    }

#ifdef SCAVENGER_TRACE

    // If we are simulating a scavenging, we accumulate the number
    // of bytes, adjusted for cluster slop, that would be reclaimed
    // if this were for real.  By setting the usage target to 0, we
    // also stress the scavenger to see how well it selects items
    // in edge cases where we just can't seem to delete enough.

    LONGLONG qwDeleted = 0;
    if (dwFactor == TRACE_FACTOR)
        qwGoal = 0;

#endif

    SCORE_ITEM ScoreList[NUM_SCORE_ITEMS];
    DWORD cScore = 0;  // number of valid entries in score list

    DWORD dwCutoffScore = 0;

    DWORD dwEnum = GetInitialFindHandle();

    // The loop code below is organized in two parts.
    // Part 1 - enum the cache to add another item to the list.
    // Part 2 - remove an item from a list, by throwing out a
    //   a high-scoring item or deleting a low-scoring item.

    // The looping occurs in 3 phases.
    // A. Do part 1 only until there are 100 items or enum is complete.
    // B. Do part 1 and part 2 until the enum is complete.
    // C. Do part 2 only until the list is empty.
    // Note that it's possible to skip directly from phase A to C.

    while (1) // until goal is met or score list is empty
    {

        // PART 1 OF LOOP: Enumerate another item from the cache.

        HASH_ITEM* pItem = HashGetNextItem
            (_UrlObjStorage, *_UrlObjStorage->GetHeapStart(), &dwEnum, fPurge);

        if (pItem)
        {
            // Validate offset.
            if (_UrlObjStorage->IsBadOffset (pItem->dwOffset))
            {
                pItem->MarkFree();
                continue;
            }

            // Get the signature.
            FILEMAP_ENTRY* pBlock = (FILEMAP_ENTRY*)
                (((LPBYTE) *_UrlObjStorage->GetHeapStart()) + pItem->dwOffset);

            if (pBlock->dwSig != SIG_URL)
            {
                if (fPurge && (pBlock->dwSig == SIG_REDIR))
                    _UrlObjStorage->FreeEntry (pBlock);
                else
                {
                //INET_ASSERT (pBlock->dwSig == SIG_LEAK );  //commented for RAID item 33669
                }
                
                pItem->MarkFree();
                continue;
            }

            // Filter out items exempt from scavenging.
            URL_FILEMAP_ENTRY* pEntry = (URL_FILEMAP_ENTRY*) pBlock;

            // The entry should not be from an uplevel cache, or
            // we ought to be deferring to its scavenger.
            INET_ASSERT (!(pEntry->bVerCreate & ENTRY_VERSION_NONCOMPAT_MASK));
            
            if (IsUrlEntryExemptFromScavenging
                (pItem, pEntry, dwFilter, qwGmtTime, &gm))
            {
#ifdef SCAVENGER_TRACE
                if (dwFactor == TRACE_FACTOR)
                {
                    char szBuf[1024];
                    wsprintf (szBuf, "EXEMPT %s\n",
                        ((LPSTR) pEntry) + pEntry->UrlNameOffset);
                    OutputDebugString (szBuf);
                }
#endif
                continue;
            }

            // If we are deleting all items, no need to score.
            if (dwFactor==100)
            {
                if (ScavengeItem (pItem, &fMustUnlock))
                    continue;
                else
                    goto done;
            }

            // If we've fallen below the 4MB threshold, we won't exempt anything from 
            // scavenging.

            // Otherwise, we look at the size of the item. If its size is greater than
            // whatever 90% of the cache quota is (arbitrary), then we won't scavenge it
            // for this session. 

            // For all other instances, we won't scavenge items we've seen in the past
            // ten minutes.

            if (!fLowDiskSpace)
            {
                if (((LONGLONG)pEntry->dwFileSize > (LONGLONG)((LONGLONG)(qwQuota * (LONGLONG)9)/(LONGLONG)10))
                    && (dwdwSessionStartTime < pEntry->LastAccessedTime))
                    continue;
                
                if (qwGmtTime < (pEntry->LastAccessedTime + (LONGLONG)(GlobalScavengeFileLifeTime*FILETIME_SEC)))
                    continue;
            }
            
            // Otherwise score the entry.
            SCORE_ITEM* pScoreItem = ScoreList + cScore;

            pScoreItem->dwScore = ScoreEntry (pEntry, qwGmtTime);

#ifdef UNIX
            if (!pScoreItem->dwScore)
               continue;
#endif /* UNIX */

            // Add to the list.
            pScoreItem->dwItemOffset =          // 64BIT
                (DWORD) ((LPBYTE) pItem - *_UrlObjStorage->GetHeapStart());
            pScoreItem->dwHashValue  = pItem->GetValue();
            pScoreItem->dwHashOffset = pItem->dwOffset;

             // Check if list is full.
            if (++cScore != NUM_SCORE_ITEMS)
                continue;

            if (!dwCutoffScore)
            {
                // Establish a cutoff score.
                SortScoreItems (ScoreList, cScore);
                DWORD nIndex; // of item used as cutoff

                switch (dwFactor)
                {
                    case DEFAULT_CLEANUP_FACTOR:
#ifdef SCAVENGER_TRACE
                    case TRACE_FACTOR:
#endif
                        nIndex = NUM_SCORE_ITEMS / 5;
                        break;

                    default:
                        nIndex = (NUM_SCORE_ITEMS * dwFactor) / 100;
                        break;
                }

                dwCutoffScore = ScoreList[nIndex].dwScore;
            }
        } // end if (pItem)

        // PART 2 OF LOOP: remove an item from the list

        // If enumeration complete and list is empty, then
        // break out of the infinite loop.
        if (!cScore)
            break;

        SCORE_ITEM *pScoreItem;

        // Is the score list full?
        if (cScore == NUM_SCORE_ITEMS)
        {
            // Find the highest scoring item.
            pScoreItem = FindMinOrMaxScoreItem
                (ScoreList, NUM_SCORE_ITEMS, FIND_MAX);
            if (pScoreItem->dwScore > dwCutoffScore)
            {
                ScavengerTrace (dwFactor, pScoreItem, NULL);

                // Some of the items are above the cutoff score.
                // Remove the highest-scoring item from the list
                // by swapping it to the end and reducing count.
                cScore--;
                SwapScoreItems (pScoreItem, ScoreList + cScore);
                continue;
            }
        }

        // Either the score list isn't full or all of the items
        // are below the cutoff score.  Delete lowest scoring item.
        pScoreItem = FindMinOrMaxScoreItem (ScoreList, cScore, FIND_MIN);

        // We yield the lock between deletes, so do some sanity
        // checking before attemptint to delete the item.
        pItem = (HASH_ITEM*)
            (*_UrlObjStorage->GetHeapStart() + pScoreItem->dwItemOffset);
        if (pScoreItem->dwHashValue == pItem->GetValue()
            && pScoreItem->dwHashOffset == pItem->dwOffset)
        {
            ScavengerTrace (dwFactor, pScoreItem, &qwDeleted);

            if (!ScavengeItem (pItem, &fMustUnlock))
                goto done;

            // If we met our goal, call it quits.
            if (dwFactor != 100 && _UrlObjStorage->GetCacheSize() < qwGoal)
                break;
        }

        // Remove the lowest-scoring item from the list.
        cScore--;
        SwapScoreItems (pScoreItem, ScoreList + cScore);

    } // end while (1)

    if( dwHWnd && dwUMsg && IsWindow((HWND)DWORD_PTR(dwHWnd)) )
    {
        PostMessage(
            (HWND)DWORD_PTR(dwHWnd),
            (UINT)dwUMsg,
            (WPARAM)CACHE_NOTIFY_DELETE_ALL,
            (LPARAM)0
        );
    }

done:
    if (fMustUnlock)
        UnlockContainer();
    return ERROR_SUCCESS;
}

VOID CacheScavenger(LPVOID Parameter)
/*++

Routine Description:

    This function is the main  function for the cache management scavenger
    thread. This function performs verious time critical operations.

Arguments:

    NONE.

Return Value:

    NONE

--*/
{
    DWORD Error;
    DWORD WaitStatus;

    //StartCAP();

    // Set a global to indicate the thread is no longer suspended.
    LOCK_CACHE();
    if (!GlobalPleaseQuitWhatYouAreDoing)
    {
        UNLOCK_CACHE();

        // Why aren't we locking in this case?
        
        // Attempt to reduce the cache usage below the quota.
        GlobalUrlContainers->CleanupUrls (NULL, DEFAULT_CLEANUP_FACTOR, 0);

        // Clear a global to indicate the scavenger thread has exited.
        InterlockedDecrement(&GlobalScavengerRunning);

        LOCK_CACHE();
    }
    UNLOCK_CACHE();

    //StopCAP();
}


void LaunchScavenger (void)
{
#ifdef unix
    INET_ASSERT(!g_ReadOnlyCaches);
#endif /* unix */

    LOCK_CACHE(); 

    // only if scavenger is not already running.
    if (!InterlockedIncrement(&GlobalScavengerRunning))
    {
        // don't fire off new thread. Just queue scavenger as work item for
        // thread pool
        SHQueueUserWorkItem((LPTHREAD_START_ROUTINE)CacheScavenger,
                            NULL,
                            0,
                            (DWORD_PTR)0,
                            (DWORD_PTR *)NULL,
                            NULL,
                            0
                            );
    }
    else
    {
        InterlockedDecrement(&GlobalScavengerRunning);
    }
    
    UNLOCK_CACHE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\global.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachedef.h

Abstract:

    contains global data declerations.

Author:

    Madan Appiah (madana)  12-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _GLOBAL_
#define _GLOBAL_

#ifdef __cplusplus
extern "C" {
#endif

// Prototype for async fixup callback.
typedef DWORD (CALLBACK* PFN_FIXUP) 
(
    DWORD   dwVer,      // version of cache
    LPSTR   pszPath,    // directory containing index file
    LPSTR   pszPrefix,  // protocol prefix
    BOOL*   pfDetach,   // ptr. to global indicating dll shutdown
    DWORD   dwFactor,   // as passed to CleanupUrls
    DWORD   dwFilter,   // as passed to CleanupUrls
    LPVOID  lpvReserved // reserved: pass null
);

//
// global variables.
//

extern CRITICAL_SECTION GlobalCacheCritSect;
extern BOOL GlobalCacheInitialized;
extern CConMgr *GlobalUrlContainers;
#define GlobalMapFileGrowSize (PAGE_SIZE * ALLOC_PAGES)
extern LONG GlobalScavengerRunning;
extern MEMORY *CacheHeap;
extern HNDLMGR HandleMgr;
extern DWORD GlobalRetrieveUrlCacheEntryFileCount;

// globals for async fixup handler
extern char       g_szFixup[sizeof(DWORD)];
                                 // regkey to lookup fixup dll,entry point
extern HINSTANCE  g_hFixup;      // dll containing fixup handler
extern PFN_FIXUP  g_pfnFixup;    // entry point of fixup handler


#ifdef unix
extern BOOL g_ReadOnlyCaches;
extern char* gszLockingHost;
#endif /* unix */

#ifdef __cplusplus
}
#endif

#endif  // _GLOBAL_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\flock.cxx ===
#include "flock.hxx"
#include <resource.h>
#include <cache.hxx>

#undef inet_ntoa
#undef inet_addr
#undef gethostname
#undef gethostbyname
#undef gethostbyaddr

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#ifdef sunos5
extern "C" int gethostname(char*,int);
#endif

extern HANDLE MwOpenProcess(pid_t, BOOL);
extern "C" MwAtExit(void (*f)(void));

//locally used functions
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len);
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len);

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400

#define REG_READONLYCACHE TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\ReadOnlyCacheWarning")
#define REG_READONLYCACHEKEY TEXT("ShowCacheWarning")
#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))
#define SECONDSINDAY 86400


// lock region relative to whence starting at offset upto len bytes
int lock_reg(int fd, int cmd, int type, off_t offset, int whence, off_t len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK     
  lock.l_start = offset;    //byte offset, relative to l_whence
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = len;     //#bytes (0 means to EOF)

  return( fcntl(fd, cmd, &lock) );
}

// test region for locks relative to whence starting at offset for len bytes
off_t lock_test(int fd, int type, off_t *offset, int whence, off_t *len) {

  struct flock lock;

  lock.l_type = type;       //F_RDLCK, F_WRLCK, F_UNLCK 
  lock.l_start = *offset;   //byte offset, relative to l_whence     
  lock.l_whence = whence;   //SEEK_SET, SEEK_CUR, SEEK_END  
  lock.l_len = *len;        // #bytes (0 means to EOF)      

  if (fcntl(fd, F_GETLK, &lock) < 0)
    return(-1);

  if (lock.l_type == F_UNLCK)
    return(0);          // nobody has lock in this region
  else if (lock.l_type == F_RDLCK) {
    *offset = lock.l_start;
    *len = lock.l_len;
    return(lock.l_start);   // byte offset of host with read lock
  } else {          // dont support extended semantics of
    return(-1);         // write lock yet
  }
}


extern "C" void unixCleanupWininetCacheLockFile()
{
//    if(!g_ReadOnlyCaches)
        //unlink(szLockDBName);
}

BOOL CreateAtomicCacheLockFile(BOOL *pfReadOnlyCaches, char **pszLockingHost)
{
    int fdlockdbf, fdlock, envLen, hostbynameerr;
    off_t IPOffset=0, IPLen=0, ownIPOffset, ownIPLen;
    char *hostname, hostbynamebuf[512];
    char szLockFileName[MAX_PATH+1], szLockDBName[MAX_PATH+1];
    struct hostent hostbynameresult;
#ifdef ux10
    struct hostent_data hostentdata;
#endif

    char *pEnv = getenv("MWUSER_DIRECTORY");

    /* Don't process the ielock file for Mainwin Lite programs */
    if (MwIsInitLite())
       goto Cleanup;

    if (pEnv == 0)
    return FALSE;

    envLen = strlen(pEnv);
    if (envLen > MAX_PATH-256)
        return FALSE;

    strcpy(szLockFileName, pEnv);
    if (szLockFileName[envLen-1] != '/') {
      szLockFileName[envLen] = '/';
      szLockFileName[envLen+1] = 0x00;
    }
    strcpy(szLockDBName, pEnv);
    if (szLockDBName[envLen-1] != '/') {
      szLockDBName[envLen] = '/';
      szLockDBName[envLen+1] = 0x00;
    }
    strcat(szLockFileName, LF);
    strcat(szLockDBName, LOCKDBF);

    hostname = (char *)malloc(256*sizeof(char));
    if ((hostname == NULL) || (gethostname(hostname, 256) == -1)) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

#ifdef sunos5
    if (!(gethostbyname_r(hostname, &hostbynameresult, hostbynamebuf,
                 sizeof(hostbynamebuf), &hostbynameerr))) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
#ifdef ux10
    if (gethostbyname_r(hostname, &hostbynameresult, &hostentdata) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }
#endif
    struct in_addr *ptr = (struct in_addr *)*hostbynameresult.h_addr_list;
    ownIPOffset = inet_netof(*ptr);
    ownIPLen = inet_lnaof(*ptr);

    if ((fdlock = open(szLockFileName, O_WRONLY|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlock = open(szLockFileName, O_WRONLY)) < 0) {
          *pfReadOnlyCaches = TRUE;
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        return FALSE;
      }
    }

    if (writew_lock(fdlock, 0, SEEK_SET, 0) < 0) {
      *pfReadOnlyCaches = TRUE;
      return FALSE;
    }

    /*under this lock, now do all the examination of szLockDBName*/
    if ((fdlockdbf = open(szLockDBName, O_RDWR|O_CREAT|O_EXCL, FILE_MODE)) < 0) {
      if (errno == EEXIST) {
        if ((fdlockdbf = open(szLockDBName, O_RDWR)) < 0) {
          *pfReadOnlyCaches = TRUE;
          un_lock(fdlock, 0, SEEK_SET, 0);
          return FALSE;
        }
      } else {
        *pfReadOnlyCaches = TRUE;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return FALSE;
      }
    }

    /* check entire file for locking */
    if ((can_writelock(fdlockdbf, &IPOffset, SEEK_SET, &IPLen)) >= 0) {
      if ((IPOffset == 0) || ((IPOffset == ownIPOffset) && (IPLen == ownIPLen))){
    // either no IE writing to cache or IE on own host writing to cache
    // (IP address is identical)..either way we have write access
    *pfReadOnlyCaches = FALSE;
    *pszLockingHost = hostname;
    //lock at "network part" position for "host part" bytes
    read_lock(fdlockdbf, ownIPOffset, SEEK_SET, ownIPLen);
    un_lock(fdlock, 0, SEEK_SET, 0);
    return TRUE;
      } else {
    //some other host writing to cache
        *pfReadOnlyCaches = TRUE;
        u_long addr = inet_addr(inet_ntoa(inet_makeaddr(IPOffset, IPLen)));
        struct hostent * hp = gethostbyaddr((char *)&addr, sizeof(addr), AF_INET);
        if (!hp)
          ;       //cant find hostname from offset & length of locked bytes..
        else
          *pszLockingHost = hp->h_name;
        un_lock(fdlock, 0, SEEK_SET, 0);
        return TRUE;
      }
    } else {
      //can_writelock returned -1 with some fcntl error
      *pfReadOnlyCaches = TRUE;
      un_lock(fdlock, 0, SEEK_SET, 0);
      return FALSE;
    }

Cleanup:
    return TRUE;
}

BOOL DeleteAtomicCacheLockFile()
{
    /* Don't process for MainWin Lite programs */
    /* Right now, the code below does not make sense because all
     * we do is return TRUE. So, commenting out this code for now.
     */
#if 0
    if (MwIsInitLite())
       goto Cleanup;

Cleanup:
#endif /* 0 */
    //unlink(szLockDBName);
    return TRUE;
}

#if 0 // Back out till we get a consensus on this

BOOL CALLBACK ReadOnlyCache_DlgProc(HWND   hDlg,
                                    UINT   uMsg,
                                    WPARAM wParam,
                                    LPARAM lParam) {
     switch (uMsg) {
            case WM_INITDIALOG:
            {
                 LPTSTR lpszMessageStr = (LPTSTR)lParam;
                 TCHAR  pszText[MAX_PATH];
                 TCHAR  pszFormattedText[MAX_PATH];

                 if (lpszMessageStr)
                 {
                    if (LoadString(GlobalDllHandle,
                                   IDS_READONLYCACHE,
                                   pszText,
                                   ARRAYSIZE(pszText))) {
                       wsprintf(pszFormattedText,pszText, lpszMessageStr);
                       SetDlgItemText(hDlg, IDC_READONLYCACHE, pszFormattedText);
                    }
                 }

                 SetFocus(GetDlgItem(hDlg, IDOK));
            }
            break;

            case WM_COMMAND:
                 switch (LOWORD(wParam))
                 {
                        case IDOK:
                        {
                             if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                                EndDialog(hDlg, 1);
                             else
                                EndDialog(hDlg, 0);
                             break;
                        }

                        default:
                             return FALSE;
                 }
                 return TRUE;
            case WM_CLOSE:
            {
                 if (IsDlgButtonChecked(hDlg, IDC_DONT_WANT_WARNING))
                    EndDialog(hDlg, 1);
                 else
                    EndDialog(hDlg, 0);
            }
            return TRUE;
     }

     return FALSE;
}

void ShowReadOnlyCacheDialog(char* pszHostName) {
     DWORD dwError = E_FAIL;
     HKEY  hKey = NULL;
     DWORD dwValue = 0;
     DWORD dwValueType;
     DWORD dwValueSize = sizeof(DWORD);

     if ((dwError = REGOPENKEYEX(HKEY_CURRENT_USER,
                            REG_READONLYCACHE,
                            0,
                            KEY_READ|KEY_WRITE,
                            &hKey)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if ((dwError = RegQueryValueEx(hKey,
                               REG_READONLYCACHEKEY,
                               0,
                               &dwValueType,
                               (LPBYTE)&dwValue,
                               &dwValueSize)) != ERROR_SUCCESS)
     {
        goto Cleanup;
     }

     if (dwValue)
     {
        int fRet = 0;

        if ((fRet = DialogBoxParam(GlobalDllHandle,
                              MAKEINTRESOURCE(IDD_READONLYCACHE),
                              NULL,
                              ReadOnlyCache_DlgProc,
                              (LPARAM)pszHostName)) < 0)
        {
           goto Cleanup;
        }

        /*
         * we are here, because the registry told us to show this dialog.
         * now, we check if fRet == TRUE, in which case we don't show this
     * dialog in the future. And, we update the registry.
         */

        if (fRet == 1) {
           /* ShowCacheWarning will be set to False in the registry */
           dwValue = 0;

           /*
            * we don't check for the error here, because we close the key next
            * and if we did not save successfully, we will show this dialog again
            */

           RegSetValueEx(hKey,
                         REG_READONLYCACHEKEY,
                         0,
                         dwValueType,
                         (LPBYTE)&dwValue,
                         dwValueSize);
        }
     }

Cleanup:

     if (hKey)
        REGCLOSEKEY(hKey);

     return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\filemgr.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  filemgr.cxx

Abstract:

    Manages cache file & directory creation/deletion.

Author:
    Adriaan Canter (adriaanc) 04-02-97

Modifications:
    Ahsan Kabir (akabir) 25-Sept-97 made minor alterations.
    
--*/


#include <cache.hxx>
#define WWW_DOT "www."

#define MAP_KEY_TO_PATH    0
#define MAP_PATH_TO_KEY    1


//
//==================== CFileMgr Public Functions =============================
//


/*-----------------------------------------------------------------------------
CFileMgr::CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::CFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : _mmFile(mmFile), _dwOptions(dwOptions)
{
    INET_ASSERT(_mmFile);

    // GetFullPathNameLen includes trailing backslash.
    _cbBasePathLen = _mmFile->GetFullPathNameLen();
}


/*-----------------------------------------------------------------------------
CFileMgr::~CFileMgr
----------------------------------------------------------------------------*/
CFileMgr::~CFileMgr()
{}


/*-----------------------------------------------------------------------------
virtual CFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CFileMgr::Init()
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual GetDirLen
Returns length of cache dir path.
----------------------------------------------------------------------------*/
DWORD CFileMgr::GetDirLen(DWORD nKey)
{
    return _cbBasePathLen;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::CreateUniqueFile
Generates cache files.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR szUrl, LPTSTR szFileName,
                                LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    return CreateUniqueFile((LPCSTR) szUrl, (LPTSTR) _mmFile->GetFullPathName(),
        (LPTSTR) szFileName, (LPTSTR) szFileExtension, (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::NotifyCommit
No-op.
----------------------------------------------------------------------------*/
BOOL CFileMgr::NotifyCommit(DWORD nDirIndex)
{
    return TRUE;
}


/*-----------------------------------------------------------------------------
CFileMgr::DeleteCache
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteCache(LPSTR szRoot)
{
    BOOL fHasCacheVu = IsValidCacheSubDir(szRoot);

    if ( fHasCacheVu)
        DisableCacheVu(szRoot);
        
    if (DeleteCachedFilesInDir(szRoot) == ERROR_SUCCESS)
    {
        SetFileAttributes(szRoot, FILE_ATTRIBUTE_DIRECTORY);
        RemoveDirectory(szRoot);
    }

    if( fHasCacheVu)
        EnableCacheVu( szRoot);
    
    return TRUE;
}

/*-----------------------------------------------------------------------------
CFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CFileMgr::Cleanup()
{
    return TRUE;
}

/*-----------------------------------------------------------------------------
virtual CFileMgr::GetDirIndex
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetDirIndex(LPSTR szFilePath, LPDWORD pnIndex)
{
    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                    LPSTR szSubDirPath, LPDWORD pcb)
{
    INET_ASSERT(pEntry && szSubDirPath && pcb && *pcb);

    // "anyuser@msn.txt"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);

    // Lengths of path and file.
    DWORD cbFile = strlen(szFile);
    DWORD cbPath = _mmFile->GetFullPathNameLen();

    // Don't overflow output buffer.
    DWORD cbSubDirPath = cbPath + cbFile;
    if (cbSubDirPath + 1 > *pcb)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // "C:\Windows\Profiles\anyuser\Cookies\"
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cbPath);

    // "C:\Windows\Profiles\anyuser\Cookies\anyuser@msn.txt"
    memcpy(szSubDirPath + cbPath, szFile, cbFile + 1);

    *pcb = cbSubDirPath;

    return TRUE;
}


/*-----------------------------------------------------------------------------
virtual CFileMgr::DeleteOneCachedFile
Deletes a single cache file given the absolute path.
----------------------------------------------------------------------------*/
BOOL CFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                                   DWORD dostEntry, DWORD nIndex)
{
    return ::DeleteOneCachedFile(lpszFileName, dostEntry);
}


/*-----------------------------------------------------------------------------
    virtual BOOL  CreateDirWithSecureName( LPSTR);

Creates a cache directory with a given name to allow existing directories
to be copied into another cache file.  Just the eight letters of the new
directory are given.
----------------------------------------------------------------------------*/
BOOL CFileMgr::CreateDirWithSecureName( LPSTR szDirName)
{
    return _mmFile->CreateDirWithSecureName( szDirName);
}


//
//================== CFileMgr Protected Functions =============================
//

/*-----------------------------------------------------------------------------
CFileMgr::GetStoreDirectory
    Returns "%windir%\web\" - ie "C:\Windows\Web\" and length. There
    is currently only ONE store directory and this is it.
----------------------------------------------------------------------------*/
BOOL CFileMgr::GetStoreDirectory(LPSTR szPath, LPDWORD pcbPath)
{
    DWORD cb;

    // Hardwired to "%windir%\Web\"
    if ((cb = GetWindowsDirectory(szPath, MAX_PATH)) && cb<=MAX_PATH)
    {
        AppendSlashIfNecessary(szPath, &cb);
        memcpy(szPath + cb, WEBDIR_STRING, sizeof(WEBDIR_STRING));
        cb += sizeof(WEBDIR_STRING) - 1;
        *pcbPath = cb;
        return TRUE;
    }
    INET_ASSERT(FALSE);
    return FALSE;
}

/*-----------------------------------------------------------------------------
CFileMgr::MapStoreKey
    Maps path to storage directory key (stored in the FILEMAP_ENTRY::DirIndex)
    or storage directory key to path (ie C:\Windows\Web\). There is currently
    only one key and it is INSTALLED_DIRECTORY_KEY. Mapping depends on dwFlag.
----------------------------------------------------------------------------*/
BOOL CFileMgr::MapStoreKey(LPSTR szPath, LPDWORD pcbPath, 
                           LPDWORD dwKey, DWORD dwFlag)
{
    DWORD cb;
    BOOL fReturn = FALSE;
    CHAR szStoreDir[MAX_PATH];

    // Must be able to get store dir in any case.
    if (GetStoreDirectory(szStoreDir, &cb))
    {
        // Mapping a path to a key requested.
        if (dwFlag == MAP_PATH_TO_KEY)
        {
            // Path matches?
            if ((*pcbPath == cb) 
                && !strnicmp(szStoreDir, szPath, cb))
            {
                // We only map one directory for now.
                *dwKey = INSTALLED_DIRECTORY_KEY;
                fReturn = TRUE;
            }
        }

        // Mapping a key to a path requested.    
        else if (dwFlag == MAP_KEY_TO_PATH)
        {
            if (*dwKey == INSTALLED_DIRECTORY_KEY)
            {
                memcpy(szPath, szStoreDir, cb+1);
                *pcbPath = cb;
                fReturn = TRUE;
            }
        }
    }
    //INET_ASSERT(fReturn);
    return fReturn;
}

/*-----------------------------------------------------------------------------
CreateUniqueFile

Routine Description:

Arguments:

    UrlName : pointer to url name.

    Path : pointer to cache path.

    FileName : pointer to a buffer that receives the full path name of the
        newly created file.

    Extension : if specified the extension is used to make random file.

Return Value:

    Windows Error Code.
----------------------------------------------------------------------------*/
DWORD CFileMgr::CreateUniqueFile(LPCSTR UrlName, LPTSTR Path, 
                                 LPTSTR FileName, LPTSTR Extension, 
                                 HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD cbPath, cbName, cbFull;
    cbPath = strlen(Path);

    DWORD Error=ERROR_SUCCESS, len, lenExt=0;

    TCHAR RandomFileName[MAX_PATH];

    TCHAR FullFileName[MAX_PATH];

    HANDLE FileHandle;

    DWORD dwCollision = 0, dwTotalCollissionCount;
    char szHost[MAX_PATH], szExtraInfo[MAX_PATH];
    URL_COMPONENTS sUrl;
    char *pszUrlPath = (char *) ALLOCATE_FIXED_MEMORY(INTERNET_MAX_PATH_LENGTH);

    LPTSTR FileNamePtr = FileName, lpT;
    
    BOOL fUseFileName = FALSE, fPrettyName = FALSE;

    DWORD cbFileName;
    CHAR szExt[MAX_PATH];
    *szExt = '\0';  

    if (phfHandle)
        *phfHandle = INVALID_HANDLE_VALUE;
    
    if (pszUrlPath == NULL)
    {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    // If a filename has been passed in attempt to use it.
    if (FileName[0] != '\0')
    {
        // Various checks to determine validity of name.

        // First strip any trailing whitespace.
        cbFileName = strlen(FileName);
        StripTrailingWhiteSpace(FileName, &cbFileName);

        // Check length.
        if (cbFileName < MAX_PATH)
        {            

            // '.' and '..' are illegal.
            if (memcmp(FileName, ".", sizeof("."))
                && memcmp(FileName, "..", sizeof("..")))
            {
                // slashes and backslashes are illegal.
                LPTSTR ptr = FileName;
                while (*ptr != '\0')
                {
                    if (IsDBCSLeadByte(*ptr))
                        ++ptr;
                    else
                    if (*ptr == '\\' || *ptr == '/')
                        break;
                    ptr++;
                }
                

                // Filename has no slashes in it.
                if (!*ptr)
                {
                    // Preliminary judgment. Creating
                    // this file could possibly fail,
                    // depending on further tests.
                    fUseFileName = TRUE;
                }
            }
        }
    }

    // Preliminary checks indicate valid filename.
    if (fUseFileName)
    {
        // Attempt to parse a file extension.

        CHAR* pExt = StrChr(FileName, '.');

        // Found a file extension delimiter.
        if (pExt)
        {
            // '.' but no extension (eg "foo.")
            if (*(pExt + 1) == '\0')
            {
                *pExt = '\0';
                len = cbFileName - 1;
            }

            // '.' at beginning (eg ".foo") Valid file, no extension.
            else if (pExt == FileName)
            {
                len = cbFileName;
            }

            // Common case (eg foo.bar)
            else
            {
                // Separate out the file extension w/o '.'
                lenExt = (DWORD) (cbFileName - (pExt - FileName) - 1);  // 64BIT
                memcpy(szExt, pExt+1, lenExt + 1);

                // Filename without extension.
                *pExt = '\0';
                len = (DWORD) (pExt - FileName);     // 64BIT
            }
        }     

        // No file extension found
        else
        {
            len = cbFileName;
        }
        fPrettyName = TRUE;
        goto have_file_name;
    }

    // No or bad filename passed in.
    else
    {
        // Copy over any extension passed in,
        // limiting the length as necessary.
        if (Extension)
        {
            lenExt = strlen(Extension);
            if (lenExt >= MAX_PATH)
            {
                lenExt = MAX_PATH - 1;
            }
            memcpy(szExt, Extension, lenExt);
            szExt[lenExt] = '\0';
        }
        else
        {
            *szExt = '\0';
            lenExt = 3;
        }
    }

    memset(&sUrl, 0, sizeof(sUrl));

    sUrl.dwStructSize = sizeof(sUrl);

    sUrl.lpszHostName = szHost;
    sUrl.dwHostNameLength = sizeof(szHost);

    sUrl.lpszUrlPath = pszUrlPath;
    sUrl.dwUrlPathLength = INTERNET_MAX_PATH_LENGTH;


    sUrl.lpszExtraInfo = szExtraInfo;
    sUrl.dwExtraInfoLength = sizeof(szExtraInfo);



    if (InternetCrackUrl(UrlName, lstrlen(UrlName), 0, &sUrl)) {
        fPrettyName = TRUE;

        if ((sUrl.dwUrlPathLength == 1) && (pszUrlPath[0] == '/')) {

            FileNamePtr = szHost;
            len = sUrl.dwHostNameLength;

            // strip out www., this info is redundant

            if (!strnicmp(FileNamePtr, WWW_DOT, sizeof(WWW_DOT)-1)) {

                len -= (sizeof(WWW_DOT)-1);

                // copy the NULL terminator too

                memmove(FileNamePtr, FileNamePtr+sizeof(WWW_DOT)-1,len+1);

            }
        }
        else {

            FileNamePtr = pszUrlPath;
            len = sUrl.dwUrlPathLength;

            // if there is a terminating slash let us fix it.
            // len-1 wont' break because we know the url is more than 1 char
            // Above assumption not valid.
            if (len && (FileNamePtr[len-1] == '/')) 
            {
                FileNamePtr[len-1] = 0;
                --len;
            }

            // get the tail
            if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '/'))
            {
                ++lpT;

                len = len - (DWORD)PtrDifference(lpT, FileNamePtr);

                //
                // truncate the FileNamePtr if it is too long -
                //   the "fudge-factor" number is to allow room for stuff like "[%d]"
                //    in the URL -- this number doesn't have to be accurate since
                //    the worst-case scenario is us using a random (ugly) filename.
                //
                unsigned int newlen;
						
                if(GlobalTruncateFileName)
                    newlen = /*excel limit*/218 - (cbPath + lenExt + 2 + /*fudge-factor*/5);
                else
                    newlen = MAX_PATH - (cbPath + lenExt + 2 + /*fudge-factor*/5);

                if ((newlen > 2) && (newlen < len))
                {
                    // For UTF-8, we don't want to chop in the middle of a %XX
                    if (lpT[newlen - 2] == '%')
                        newlen -= 2;
                    else if (lpT[newlen - 1] == '%')
                        newlen -= 1;

                    len      = newlen;
                    lpT[len] = '\0';
                }

                // copy the NULL terminator as well
                memmove(FileNamePtr, lpT, len+1);
            }
		
            // Special hack for cookies: Ensure that the username is
            // prepended on to the filename. The preceding filename
            // generation code does not generate this for cookies
            // which specify paths in addition to domains.      
            if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
            {                
                // This is a cookie url of the form Cookie:username@domain/path
                if (GetWininetUserName())
                {
                    DWORD cb = vdwCurrentUserLen;
                    if (len + cb + 1 < MAX_PATH)
                    {
                        if (memcmp(FileNamePtr, vszCurrentUser, cb) 
                            || FileNamePtr[cb] != '@'
                            || FileNamePtr[cb+1] == '\0')
                        {
                            memmove(FileNamePtr + cb + 1, FileNamePtr, len+1);
                            FileNamePtr[cb] = '@';
                            memcpy(FileNamePtr, vszCurrentUser, cb);
                            len += cb + 1;
                        }
                    }
                }
            }
        
        }

        
        if (lpT=StrRChrA(FileNamePtr, FileNamePtr+len-1, '.'))
        {
            *lpT = 0;
            len = (DWORD) PtrDifference(lpT, FileNamePtr);
        }

        // convert all invalid char (including '%') to '_'
        for(lpT = FileNamePtr; *lpT; ++lpT) 
        {
            if (IsDBCSLeadByte(*lpT))
                ++lpT;
            else if ((strchr(vszInvalidFilenameChars, *lpT))) 
                *lpT = '_';
        }

        if ((cbPath+len+lenExt+2) > MAX_PATH) {

            fPrettyName = FALSE;

        }
    }
    else {

        fPrettyName = FALSE;
    }


have_file_name:


    for(dwTotalCollissionCount = 0;
        dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS;
        dwTotalCollissionCount++) {


        //
        // make a random file name.
        //
        if (!fPrettyName) 
        {
            // If fUseFileName is TRUE, it means we've attempted to create
            // a file using the filename passed in and failed. We still want 
            // to create a cache file, but since the extension parsed from the
            // filename is also suspect, we want to create a cache filename
            // without any passed in extension, or NULL.
            if (fUseFileName)
            {
                if (Extension)
                {
                    lenExt = strlen(Extension);
                    memcpy(szExt, Extension, lenExt+1);
                }
                else
                {
                    lenExt = 0;
                    *szExt = '\0';
                }
            }

            Error = MakeRandomFileName(UrlName, RandomFileName, szExt);

        }
        else {

            DWORD digit;
            DWORD cb = strlen(FileNamePtr);
            memcpy(RandomFileName, FileNamePtr, cb+1);

            lpT = RandomFileName+len;

            // Always decorate the cache file name with [1-99]
            // We use square brackets instead of parens because
            // NT cmd shell barfs on parens.
            
            if (++dwCollision > 99)
            {
                fPrettyName = FALSE;
                continue;
            }

#ifndef UNIX
            if (fCreatePerUser && GlobalIdentity)
            {
                lpT += wsprintf (lpT, "[%d][%d]", GlobalIdentity, dwCollision);
            }
            else
            {
                lpT += wsprintf (lpT, "[%d]", dwCollision);
            }
#else
            /* Square brackets cause problems on UNIX */
            lpT += wsprintf (lpT, "(%d)", dwCollision);
#endif /* UNIX */
                
            if (*szExt)
            {
                *lpT++ = '.';
                memcpy(lpT, szExt, lenExt + 1);
            }
            
            Error = ERROR_SUCCESS;

        }

        if (Error != ERROR_SUCCESS) {
            INET_ASSERT(FALSE);
            goto Cleanup;

        }

        cbName = strlen(RandomFileName);
        cbFull = cbPath + cbName + 1;

        if (cbFull > MAX_PATH)
        {
            INET_ASSERT(FALSE);
            Error = ERROR_FILENAME_EXCED_RANGE;
            goto Cleanup;
        }
#ifndef UNIX
        // Hack for special DOS filenames:
        // aux.*, com[0-9].*, con.*, lpt[0-9].*, 
        // nul.* and prn.* on non-NT platforms.
        if (!IsPlatformWinNT())
        {
            DWORD cbMajor = cbName - lenExt;
            if (cbMajor == 4 || cbMajor == 5)
            {
                switch(tolower(*RandomFileName))
                {
                    // Test for aux.*
                    case 'a':
                    if (!strnicmp(RandomFileName + 1, "ux.", 3))
                    {
                        continue;
                    }
                    break;

                    // Test for com[0-9].* and con.*
                    case 'c':
                    if (tolower(RandomFileName[1]) == 'o')
                    {
                        CHAR c = tolower(RandomFileName[2]);
                        if (c == 'm')
                        {
                            if (isdigit(RandomFileName[3])
                                && RandomFileName[4] == '.')
                            {
                                continue;
                            }
                        }
                        else if (c == 'n')
                        {
                            if (RandomFileName[3] == '.')
                            {
                                continue;
                            }
                        }
                    }
                    break;
    
                    // Test for lpt[0-9].*
                    case 'l':
                    {
                        if (!strnicmp(RandomFileName + 1, "pt", 2)
                            && isdigit(RandomFileName[3])
                            && RandomFileName[4] == '.')
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for nul.*
                    case 'n':
                    {
                        if (!strnicmp(RandomFileName + 1, "ul.", 3))
                        {
                            continue;
                        }
                        break;
                    }

                    // Test for prn.*
                    case 'p':
                    {
                        if (!strnicmp(RandomFileName + 1, "rn.", 3))
                        {
                            continue;
                        }
                        break;
                    }
                }
            }
        }
#endif /* !UNIX */

        // Make full path name.
        memcpy(FullFileName, Path, cbPath);
        memcpy(FullFileName + cbPath, RandomFileName, cbName + 1);

        // Check if this file exists.
        if (GetFileAttributes(FullFileName)!=0xffffffff) 
        {
            // A file or dir by this name exists.
            // This will also take care of special DOS filenames
            // on NT, which return !0xffffffff.
            continue;
        }



        FileHandle = CreateFile(
                        FullFileName,
                        GENERIC_WRITE,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        CREATE_NEW,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

        if( FileHandle != INVALID_HANDLE_VALUE ) 
        {
            // successfully create a new file either return handle or close it and return.
            if ( phfHandle )
                *phfHandle = FileHandle;
            else
                CloseHandle( FileHandle );

            break;
        }
        else
        {
            // Couldn't create the file. This is possibly due to the file
            // already existing or to the fact that the directory was deleted.

            // Check for the existance of the directory:
            if (GetFileAttributes(Path) == 0xffffffff)
            {
                // Directory was deleted. Create one and then
                // create the file.
                if (CreateDirectory(Path, NULL))
                {
                    // Set system attribute.
                    SetFileAttributes(Path, FILE_ATTRIBUTE_SYSTEM);

                    // Enable cachevu in this directory
                    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
                        EnableCacheVu(Path);

                    FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            CREATE_NEW,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

                    // We just created the directory and the
                    // child file, so the file handle should
                    // be valid.
                    if( FileHandle != INVALID_HANDLE_VALUE ) 
                    {
                        // successfully create a new file either return handle or close it and return.
                        if ( phfHandle )
                            *phfHandle = FileHandle;
                        else
                            CloseHandle( FileHandle );

                        break;
                    }
                }
            }
        }

        Error = GetLastError();

        if( Error != ERROR_FILE_EXISTS )
        {
            if (!fPrettyName)
            {
                INET_ASSERT(FALSE);
                goto Cleanup;
            }
            else
            {
                fPrettyName = FALSE;
                Error = ERROR_SUCCESS;
            }
        }
        else {

            // We found that the file exists
            // if it is zero size, let us just use it.
            // this in itself is an unlikely occurrence
            // but we any way try to work around the IBM virus software

            // ACHTUNG!!! this is a special hack for IBM antivirus software

            FileHandle = CreateFile(
                            FullFileName,
                            GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

            if (FileHandle != INVALID_HANDLE_VALUE) {

                // this looks usable
                if (GetFileSize(FileHandle, NULL) == 0)
                {
                    if (phfHandle)
                        *phfHandle = FileHandle;
                    else
                        CloseHandle( FileHandle );
                    break;
                }
                    
                CloseHandle( FileHandle );
                INET_ASSERT(FALSE);
            }
            Error = ERROR_DISK_FULL;
            goto Cleanup;
        }

        //
        // try another random file.
        //
    } // end of the for loop

    if (dwTotalCollissionCount < MAX_COLLISSION_ATTEMPTS) {

        memcpy(FileName, FullFileName, cbFull);
        Error = ERROR_SUCCESS;

    }
    else {
        INET_ASSERT(FALSE);
        Error = ERROR_DISK_OPERATION_FAILED;

    }
Cleanup:
    if (pszUrlPath)
        FREE_MEMORY(pszUrlPath);

    return Error;
}

/*-----------------------------------------------------------------------------
MakeRandomFileName

  Routine Description:

    Creates a random 8.3 file name. The format of the name will be as
    below:

        ca(0-99999).(0-999)

    Ex ca19200.340
    Ex ca19354.tmp - if an extension (tmp) is specified.

Arguments:

    UrlName : pointer to an URL string

    FileName : pointer to a string buffer where the random file name is
        returned. The buffer length must be atleast 8+3+1+1= 13 wchars.

    Extension : pointer to an extension string. if this is non-NULL, then
        the specified extension is used otherwise random extension as
        explained above is used.

Return Value:

    none.
----------------------------------------------------------------------------*/
DWORD CFileMgr::MakeRandomFileName(LPCSTR UrlName,
                                      LPTSTR FileName, LPTSTR Extension)
{
    DWORD RandNum;
    LPTSTR FileNamePtr = FileName;
    static Counter;
    DWORD i;
    DWORD cbExtension = 0;

    if (Extension)
        cbExtension = lstrlen(Extension) + 1;

    if (cbExtension > (MAX_PATH-(8+1)))
    {
        return(ERROR_FILENAME_EXCED_RANGE);
    }

    // Additional special hack for cookie urls.
    if (!memcmp(UrlName, COOKIE_PREFIX, sizeof(COOKIE_PREFIX) - 1))
    {                
        // This is a cookie url of the form Cookie:username@domain/path
        if (GetWininetUserName())
        {
          DWORD cb = vdwCurrentUserLen;
          
          if (cb + 8 + cbExtension + 1 < MAX_PATH)
          {
              memcpy(FileName, vszCurrentUser, cb);
              FileName[cb] = '@';
              FileNamePtr += (cb + 1);
          }
        }
    }
    
    // Check that the total name doesn't exceed MAX_PATH
    // Our total name is 8 chars basename + a dot + the extension + 0


    *FileNamePtr++ = L'C';
    *FileNamePtr++ = L'A';

    //
    // generate a six digits random string;
    //

    //
    // We can't use rand() alone to generate a random number because it will
    // repeat the same sequence for each new thread that comes in.  We can't
    // use the TickCount alone because it is a little too predicable.  But
    // the two combined should be nice.  Adding in Counter will take care of
    // the case of two brand-new threads coming in at the same time.
    //


    for ( i = 0; i < 6; i++) {
        UINT digit;

        RandNum = (GetTickCount() * rand()) + Counter++;

        digit = RandNum % 36; // 10 digits + 26 letters

        *FileNamePtr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *FileNamePtr++ = L'.';
  
    
    //
    // if an extension is specified, use it.
    //
    if( Extension != NULL )
    {
        // if a 0 extension if provided, we will create a
        // file with no extension
        memcpy(FileNamePtr, Extension, cbExtension);
        return ERROR_SUCCESS;
    }

    // Append default file extension.
    memcpy(FileNamePtr, DEFAULT_FILE_EXTENSION, sizeof(DEFAULT_FILE_EXTENSION));
    return ERROR_SUCCESS;
}






//
//===================== CSecFileMgr Public Functions ==========================
//


/*-----------------------------------------------------------------------------
CSecFileMgr::CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::CSecFileMgr(MEMMAP_FILE* mmFile, DWORD dwOptions) : CFileMgr(mmFile, dwOptions)
{
    INET_ASSERT(_mmFile);

    // BUGBUG - have to guard against getting out of sync with dirs.
    if (_mmFile->GetDirCount() == 0)
        Init();
}


/*-----------------------------------------------------------------------------
CSecFileMgr::~CSecFileMgr
----------------------------------------------------------------------------*/
CSecFileMgr::~CSecFileMgr()
{}


/*-----------------------------------------------------------------------------
CSecFileMgr::Init
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Init()
{
    if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
        EnableCacheVu(_mmFile->GetFullPathName());

    return CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
}


/*-----------------------------------------------------------------------------
GetDirLen()
Returns cache dir path length.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::GetDirLen(DWORD nKey)
{
    DWORD cb = 0;

    if (nKey < DEFAULT_MAX_DIRS)
    {    
        // + 1 to account for trailing backslash.
        cb = _cbBasePathLen + DIR_NAME_SIZE + 1;
    }
    else
    {
        CHAR szStoreDir[MAX_PATH];
        GetStoreDirectory(szStoreDir, &cb);
    }
    INET_ASSERT(cb);
    return cb;
}

/*-----------------------------------------------------------------------------
CSecFileMgr::CreateUniqueFile
Creates a cache file.
----------------------------------------------------------------------------*/
DWORD CSecFileMgr::CreateUniqueFile(LPCSTR szUrl, LPTSTR szFileName,
                                   LPTSTR szFileExtension, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    DWORD nDir, nFiles;
    DWORD nDirCount = _mmFile->GetDirCount();

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    FindMinFilesSubDir(nDir, nFiles);

    if (nFiles >= MAX_FILES_PER_CACHE_DIRECTORY
        && nDirCount < DEFAULT_MAX_DIRS)
    {
        if (CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE))
            nDir++;
    }

    // Get the cache path and subdirectory
    // from the memory mapped file
    CHAR szSubDirPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szSubDirPath, _mmFile->GetFullPathName(), cb);

    _mmFile->GetDirName(nDir, szSubDirPath + cb);
    memcpy(szSubDirPath + cb + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    return CFileMgr::CreateUniqueFile((LPCSTR) szUrl, (LPTSTR) szSubDirPath,
                                      (LPTSTR) szFileName, (LPTSTR) szFileExtension,
                                      (HANDLE*) phfHandle, fCreatePerUser);
}


/*-----------------------------------------------------------------------------
CSecFileMgr::NotifyCommit
Tracks committed cache file counts.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::NotifyCommit(DWORD nDirIndex)
{
    INET_ASSERT(_mmFile->GetDirCount() <= DEFAULT_MAX_DIRS);

    // Regular random subdir
    if (nDirIndex < _mmFile->GetDirCount())
    {
        _mmFile->IncrementFileCount(nDirIndex);
        return TRUE;
    }
    // Not a directory.
    else if (nDirIndex == NOT_A_CACHE_SUBDIRECTORY)
    {
        //INET_ASSERT(FALSE);
        //return FALSE;
        // May be an absolute path EDITED_CACHE_ENTRY so pass
        return TRUE;
    }

    // Otherwise this had better be an installed directory.
    INET_ASSERT(nDirIndex == INSTALLED_DIRECTORY_KEY);
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::Cleanup
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::Cleanup()
{

    CHAR szPath[MAX_PATH];

    DWORD cb = _mmFile->GetFullPathNameLen();
    memcpy(szPath, _mmFile->GetFullPathName(), cb+1);

    if (!AppendSlashIfNecessary(szPath, &cb))
        return FALSE;

    memcpy(szPath + cb, "*.*", sizeof("*.*"));

    WIN32_FIND_DATA fd;

    HANDLE handle = FindFirstFile(szPath, &fd);

    if (handle == INVALID_HANDLE_VALUE)
        return FALSE;

    do
    {
        if ((fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            && (strcmp(fd.cFileName, ".") && strcmp(fd.cFileName, "..")))
        {
            memcpy(szPath + cb, fd.cFileName, strlen(fd.cFileName) + 1);

            // Only delete directory if it is a valid subdirectory.
            if (IsValidCacheSubDir(szPath))
            {
                if (_mmFile->GetDirIndex(szPath) == NOT_A_CACHE_SUBDIRECTORY)
                {
                    DisableCacheVu(szPath);
                    if (DeleteCachedFilesInDir(szPath) == ERROR_SUCCESS)
                    {
                        SetFileAttributes(szPath, FILE_ATTRIBUTE_DIRECTORY);
                        RemoveDirectory(szPath);
                    }
                }
            }
        }
    } while (FindNextFile(handle, &fd));


    FindClose(handle);

  return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::GetDirIndex
Returns index of random cache subdirectory from an absolute file path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetDirIndex(LPSTR szAbsPath, LPDWORD pnIndex)
{
    BOOL fReturn = FALSE;
    DWORD idx;

    INET_ASSERT(pnIndex);

    if (szAbsPath && *szAbsPath)
    {
        // First look in mem map file for regular dir.
        idx = _mmFile->GetDirIndex(szAbsPath);

        // If didn't find it in the mem map file,
        // check if it is the storage directory.
        if (idx == NOT_A_CACHE_SUBDIRECTORY)
        {
            // First we need to find the path to the file sans \filename.ext
            DWORD cbAbsPath = strlen(szAbsPath);
            LPSTR ptr = StrRChr(szAbsPath, szAbsPath + cbAbsPath, DIR_SEPARATOR_CHAR);
            if (ptr)
            {
                // Separate path from filename and attempt to map.
                // Note - trailing slash is included in path mapped.
                DWORD cbPath = (DWORD) (ptr - szAbsPath + 1);   // 64BIT
                if (MapStoreKey(szAbsPath, &cbPath, &idx, MAP_PATH_TO_KEY))
                {
                    *pnIndex = idx;
                    fReturn = TRUE;
                }
                // Must be an EDITED_CACHE_ENTRY set at an absolute path so just update the idx and fail
                else
                {
                    *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
                }
            }
        }

        // Otherwise, this should be a valid cache subdirectory.
        else
        {
            *pnIndex = idx;
            fReturn = TRUE;
        }
    }
    else
    {
        *pnIndex = NOT_A_CACHE_SUBDIRECTORY;
    }
    
    return fReturn;
}



/*-----------------------------------------------------------------------------
CSecFileMgr::GetFilePathFromEntry

Retrieves the full path to the cache subdirectory for a cache entry.
Maps the directory index from the URL_FILEMAP_ENTRY pointer passed in
to a string containing the full path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::GetFilePathFromEntry(URL_FILEMAP_ENTRY *pEntry,
                                       LPSTR szAbsPath, LPDWORD pcb)
{
    DWORD cbSubDirPath, cbFile;

    INET_ASSERT(pEntry && szAbsPath && pcb && *pcb);
    
    // Get file name and length - eg "default.html"
    LPTSTR szFile = (LPTSTR) OFFSET_TO_POINTER(pEntry, pEntry->InternalFileNameOffset);
    cbFile = strlen(szFile);
    
    // Make real time check?
    if (cbFile && (cbFile < MAX_PATH))
    {
        // Does entry reside in on of the random subdirs?
        if (pEntry->DirIndex != NOT_A_CACHE_SUBDIRECTORY 
            && pEntry->DirIndex < DEFAULT_MAX_DIRS)
        {
            // Path length.
            DWORD cbFull = _mmFile->GetFullPathNameLen();

            // Don't overflow output buffer.
            cbSubDirPath =
                  cbFull
                + DIR_NAME_SIZE
                + sizeof(DIR_SEPARATOR_STRING) - 1
                + cbFile;

            if (cbSubDirPath + 1 > *pcb)
            {
                // INET_ASSERT(FALSE);
                return FALSE;
            }

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\"
            memcpy(szAbsPath, _mmFile->GetFullPathName(), cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7"
            _mmFile->GetDirName(pEntry->DirIndex, szAbsPath + cbFull);

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE, DIR_SEPARATOR_STRING, sizeof (DIR_SEPARATOR_STRING));

            // "C:\Windows\Profiles\anyuser\Temporary Internet Files\XAQRTLY7\default.htm"
            memcpy(szAbsPath + cbFull + DIR_NAME_SIZE + sizeof(DIR_SEPARATOR_STRING) - 1, szFile, cbFile + 1);
        }
     
        // There is no cache subdirectory which has been can be mapped
        // from the index. See if there is an existing store mapping.
        else
        {

            if (pEntry->DirIndex == NOT_A_CACHE_SUBDIRECTORY) 
            // Assume an ECE absolute path item as AddURL only writes NACS entries with ECE set
            {
                cbSubDirPath = cbFile + 1;  // Add terminator to size
                if (cbSubDirPath > *pcb)
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
                memcpy(szAbsPath, szFile, cbSubDirPath);
            }
            else
            {

                INET_ASSERT(pEntry->DirIndex == INSTALLED_DIRECTORY_KEY);
        
                DWORD cbPath = 0;
                DWORD dwIndex = INSTALLED_DIRECTORY_KEY;
                if (MapStoreKey(szAbsPath, &cbPath, &dwIndex, MAP_KEY_TO_PATH))
                {
                    // "C:\Winnt\Web\"
                    cbSubDirPath = cbPath + cbFile;
                    if (cbSubDirPath + 1 > *pcb)
                    {
                        INET_ASSERT(FALSE);                
                        return FALSE;
                    }
                    // "C:\Winnt\Web\default.html"
                    memcpy(szAbsPath + cbPath, szFile, cbFile + 1);
                }
                else
                {
                    INET_ASSERT(FALSE);
                    return FALSE;
                }
            }            
            
        }

        // Hand out the absolute path to the file.
        *pcb = cbSubDirPath;
        
        return TRUE;
    }

    INET_ASSERT(FALSE);
    return FALSE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::DeleteOneCachedFile
Deletes one cache file and decrements the file count.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::DeleteOneCachedFile(LPSTR lpszFileName,
                         DWORD dostEntry, DWORD nDirIndex)
{
    if (!::DeleteOneCachedFile(lpszFileName, dostEntry))
        return FALSE;

    INET_ASSERT(nDirIndex != NOT_A_CACHE_SUBDIRECTORY);
    _mmFile->DecrementFileCount(nDirIndex);

    return TRUE;
}



//
//==================== CSecFileMgr Protected Functions =======================
//



/*-----------------------------------------------------------------------------
CSecFileMgr::CreateRandomDirName
Creates a random subdirectory name under the root container path.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateRandomDirName(LPSTR szDirName)
{
    DWORD RandNum;
    LPSTR ptr = szDirName;
    static Counter;

    INET_ASSERT(szDirName);

    // Stolen from MakeRandomFileName.
    for (DWORD i = 0; i < DIR_NAME_SIZE; i++)
    {
        UINT digit;
        RandNum = (GetTickCount() * rand()) + Counter++;

        // 10 digits + 26 letters
        digit = RandNum % 36;
        *ptr++  = ( digit < 10 ) ? (CHAR)('0' + digit) : (CHAR)('A' + (digit - 10));
    }

    *ptr = '\0';

    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateAdditionalSubDirectories
Creates nAdditionalDirs random subdirectories, up to DEFAULT_MAX_DIRS.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateAdditionalSubDirectories(DWORD nAdditionalDirs)
{
    DWORD nTotalDirs;
    DWORD nDirCount = _mmFile->GetDirCount();
    BOOL bSuccess = TRUE;

    INET_ASSERT(nDirCount <= DEFAULT_MAX_DIRS);

    // Don't create more than the max allowed dirs.
    nTotalDirs = nAdditionalDirs + nDirCount;
    INET_ASSERT(nTotalDirs <= DEFAULT_MAX_DIRS);

    // Create the dir and set the file count to 0.
    DWORD i = nDirCount;
    DWORD nTotalTries = 0;
    do
    {
        if (CreateSubDirectory(i))
        {
            _mmFile->SetFileCount(i, 0);
            _mmFile->IncrementDirCount();
            i++;
        }
        else
        {
            INET_ASSERT(FALSE);
            bSuccess = FALSE;
        }

        if (nTotalTries++ > 100)
        {
            bSuccess = FALSE;
            break;
        }

    } while (i < nTotalDirs);

    return bSuccess;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::CreateSubDirectory(DWORD nIdx)
Actual creation of subdirectory.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::CreateSubDirectory(DWORD nIdx)
{
    CHAR szCacheDir[MAX_PATH];
    CHAR szSubDir[DIR_NAME_SIZE + 1];

    // Generate full path to random dir.
    CreateRandomDirName(szSubDir);
    DWORD cb = _mmFile->GetFullPathNameLen();

    memcpy(szCacheDir, _mmFile->GetFullPathName(), cb);
    memcpy(szCacheDir + cb, szSubDir, DIR_NAME_SIZE + 1);

    // Create the directory and add it to
    // the list of directories in the index.
    if (CreateDirectory(szCacheDir, NULL))
    {
        _mmFile->SetDirName(nIdx, szSubDir);

        // For cachevu must be hidden and system.
        // BUGBUG - sure it must be hidden?
        SetFileAttributes(szCacheDir, FILE_ATTRIBUTE_SYSTEM);

        if (!(GetOptions() & INTERNET_CACHE_CONTAINER_NODESKTOPINIT))
           EnableCacheVu(szCacheDir);

    }
    else
    {
        // Couldn't create the directory.
        INET_ASSERT(FALSE);
        return FALSE;
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
CSecFileMgr::FindMinFilesSubDir
Determines the cache subdirectory with the minimum file count for load balancing.
----------------------------------------------------------------------------*/
BOOL CSecFileMgr::FindMinFilesSubDir(DWORD& nMinFileDir, DWORD& nFiles)
{
    DWORD nDirCount = _mmFile->GetDirCount();

    if (nDirCount == 0 || nDirCount > DEFAULT_MAX_DIRS)
    {
        INET_ASSERT(FALSE);
        _mmFile->SetDirCount(0);
        CreateAdditionalSubDirectories(DEFAULT_DIR_TABLE_GROW_SIZE);
        nDirCount = _mmFile->GetDirCount();
    }

    nMinFileDir = 0;
    DWORD nMinFiles = _mmFile->GetFileCount(0);

    for (DWORD i = 1; i < nDirCount; i++)
    {
        if (_mmFile->GetFileCount(i) < nMinFiles)
        {
            nMinFiles = _mmFile->GetFileCount(i);
            nMinFileDir = i;
        }

    }
    nFiles = _mmFile->GetFileCount(nMinFileDir);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\filemap.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    filemap.cxx

Abstract:

    contains implementation of MEMMAP_FILE class.

Author:

    Madan Appiah (madana)  28-April-1995

Environment:

    User Mode - Win32

Revision History:

    Shishir Pardikar (shishirp) added: (as of (7/6/96)

    1) Fix crossproces problems on win95 in checksizegrowandremap
    2) Exception handling to deal with badsector being memorymapped
    3) More robust validation at init time
    4) Reinitialization code to really clear the cache
    5) Bug fixes in GrowMap while growing partially filled dword

--*/

#include <cache.hxx>


#define FILE_SIZE_MAX_DIGITS 16


DWORD
ValidateAndCreatePath(
    LPTSTR PathName
    )
{
    DWORD Error, len;
    DWORD FileAttribute;
    LPTSTR PathDelimit;

    //
    // check to see the path specified is there.
    //

    FileAttribute = GetFileAttributes( PathName );

    if( FileAttribute != 0xFFFFFFFF ) {

        //
        // check to see the attribute says it is a dir.
        //

        if( !(FileAttribute & FILE_ATTRIBUTE_DIRECTORY) ) {
            
            return( ERROR_INVALID_PARAMETER );
        }

        // We found the file and it is a dir.
        // Set the system attribute just in case
        // it has been unset.
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( (Error != ERROR_FILE_NOT_FOUND) &&
        (Error != ERROR_PATH_NOT_FOUND) ) {

        return( Error );
    }

    //
    // we did not find the path, so create it.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //
        SetFileAttributes(PathName, FILE_ATTRIBUTE_SYSTEM);
        return( ERROR_SUCCESS );
    }

    Error = GetLastError();

    if( Error != ERROR_PATH_NOT_FOUND ) {

        return( Error );
    }

    //
    // sub-path is not found, create it first.
    //

    len = lstrlen( PathName );

    if (len < 5) {

        SetLastError(ERROR_INVALID_NAME);

        return (ERROR_INVALID_NAME);
    }

    PathDelimit = PathName + len -1 ;

    // step back from the trailing backslash

    if( *PathDelimit == PATH_CONNECT_CHAR ) {
        PathDelimit--;
    }

    //
    // find the last path delimiter.
    //

    while( PathDelimit >  PathName ) {
        if( *PathDelimit == PATH_CONNECT_CHAR ) {
            break;
        }

        PathDelimit--;
    }

    if( PathDelimit == PathName ) {
        return( ERROR_INVALID_PARAMETER );
    }

    *PathDelimit = TEXT('\0');

    //
    // validate sub-path now.
    //

    Error = ValidateAndCreatePath( PathName ) ;

    //
    // replace the connect char anyway.
    //

    *PathDelimit = PATH_CONNECT_CHAR;

    if( Error != ERROR_SUCCESS ) {

        return( Error );
    }

    //
    // try to create one more time.
    //

    if( CreateDirectory( PathName, NULL ) ) {

        //
        // done.
        //

        return( ERROR_SUCCESS );
    }

    Error = GetLastError();
    return( Error );
}


DWORD
MEMMAP_FILE::CheckSizeGrowAndRemapAddress(
    VOID
    )
{
    DWORD dwNewFileSize;

#ifdef WIN95_BUG
    if( _FileSize == (dwNewFileSize = _HeaderInfo->FileSize )) {
        return( ERROR_SUCCESS );
    }
#endif //WIN95_BUG

    // ideally we would have liked to do as in the above two lines
    // this works right on NT but doesn't on win95.

    // This is because the filesize is a part of the mapname
    // In the initial state the index file size is 8192. So the
    // memorymap name is c:_windows_temporaray internet files_8192.
    // Both the processes have this map in their address space.
    // Process B starts pumping in the data, and at some point the index
    // file needs to be grown. Process B, increases the index file to 16384,
    // updates the filesize in the header "while it is still mapped in the
    // map corresponding to the old filesize" and then remaps to the new map
    // with the name c:_windows_temporaray internet files_16384.
    // Any subsequent growth is now recorded in this map.
    // The old map c:_windows_temporaray internet files_8192 still has only
    // the first transition.


    // the work around is to actually get the filesize from the filesystem
    // This works correctly on win95 and NT both. Optimally, we would
    // check for a transition and then get the real size, but we will do that
    // after IE30 ships.



    //NB!!!!!!! The check below is the basis of our cross process
    // cache. All APIs finally make this call before touching the memory
    // mapped file. If there is a chneg, they remap it to the new size
    // with the sizename as part of the mapping, so they get the latest
    // stuff.
    // When anyone gets here, they are protected by a crossprocess mutex


    if( _FileSize == (dwNewFileSize = GetFileSize(_FileHandle, NULL))) {
        return( ERROR_SUCCESS );
    }

    //
    // so other user of the memmap file has increased the file size,
    // let's remap our address space so that the new portion is
    // visible to us too.
    //

    DWORD Error;
    DWORD OldFileSize;
    DWORD OldNumBitMapDWords;

   //
   // set our internal file size and num bit map entries.
   //

    OldFileSize = _FileSize;
    OldNumBitMapDWords = _NumBitMapDWords;


    _FileSize = dwNewFileSize;

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        //
        // reset the file size.
        //

        _FileSize = OldFileSize;
        _NumBitMapDWords = OldNumBitMapDWords;
    }
    else {

#if INET_DEBUG
        if ((GetFileSize(_FileHandle, NULL)) != (_HeaderInfo->FileSize)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);

        }
#endif //INET_DEBG

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

    return( Error );
}

BOOL
MEMMAP_FILE::ValidateCache(
    VOID
    )
/*++

    This private member function validates the cache file content.

Arguments:

    NONE.

Return Value:

    TRUE - if the cache is valid.
     FALSE - otherwise.

--*/
{
    BOOL ReturnCode = FALSE;
    int i, k;
    DWORD BitPosition, TotalAlloced, MaxAllocedPosition, RunningCounter;


    __try {

        // validate signatue.
        if( memcmp(
                _HeaderInfo->FileSignature,
                CACHE_SIGNATURE,
                MAX_SIG_SIZE * sizeof(TCHAR) ) != 0 ) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "File signature does not match.\n" ));
            goto Cleanup;
        }

        // Also check the index does not contain entries with a higher
        // version than the current machine can handle.  This can happen
        // due to Windows kludgy concept of roaming, which replicates 
        // parts of the file system and registry hkcu.
        
        LPSTR pszHighVer = (LPSTR) (_HeaderInfo->dwHeaderData
            + CACHE_HEADER_DATA_HIGH_VERSION_STRING);
        if (pszHighVer[0] != 'V' || pszHighVer[3] != 0)
            memset (pszHighVer, 0, sizeof(DWORD));
        else if (!g_szFixup[0] || strcmp (g_szFixup, pszHighVer) < 0)
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Cannot handle uplevel index file.\n" ));
            goto Cleanup;
        }

        // check the hash table root offset is valid
        if( _HeaderInfo->dwHashTableOffset != 0 ) {

            if( _HeaderInfo->dwHashTableOffset > _FileSize ) {
                TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "invalid b-tree root offset.\n" ));
                goto Cleanup;
            }
        }

        // check file size.
        if( _HeaderInfo->FileSize != _FileSize ) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "invalid file size.\n" ));
            goto Cleanup;
        }

        // one more file size check.
        DWORD ExpectedFileSize;
        ExpectedFileSize =
            HEADER_ENTRY_SIZE +
                _HeaderInfo->NumUrlInternalEntries * _EntrySize;

        // cell the size to GlobalMapFileGrowSize.
        if( ExpectedFileSize % GlobalMapFileGrowSize ) {
                ExpectedFileSize =
                ((ExpectedFileSize /  GlobalMapFileGrowSize) + 1) *
                        GlobalMapFileGrowSize;
        }

        if( _FileSize != ExpectedFileSize ) {

            // it is ok if the file size is one block bigger.
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid file size.\n" ));
            goto Cleanup;
        }


        if(_HeaderInfo->NumUrlInternalEntries < _HeaderInfo->NumUrlEntriesAlloced) {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc entires.\n" ));
            goto Cleanup;
        }


        TotalAlloced = 0;
        MaxAllocedPosition = 0;
        RunningCounter = 0;

        // scan the enire bitmap and do some consistency check for allocated bits

        for(i=0; i<BIT_MAP_ARRAY_SIZE; ++i) {
            // k goes from 0 to 31
            // BitPosition goes from 0x00000001 to 0x80000000

            for(BitPosition=1, k=0; k<NUM_BITS_IN_DWORD; ++k, BitPosition <<=1) {

                ++RunningCounter;
                if(_HeaderInfo->AllocationBitMap[i] & BitPosition) {

                    ++TotalAlloced;

                    MaxAllocedPosition = RunningCounter;

                }

            }
        }

        // if the max allocated bit is greter than the number of
        // possible entries for this filesize,
        // or the total allocated bits are greater (the above condition subsumes
        // this one, but it is OK to be paranoid)
        // or totalbits alloced don't match the count
        // there this header is not OK

        if ((MaxAllocedPosition > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced > _HeaderInfo->NumUrlInternalEntries)
            ||(TotalAlloced != _HeaderInfo->NumUrlEntriesAlloced)) {

            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "Invalid alloc bitmap\n" ));
            goto Cleanup;

        }
        //
        // every thing is fine.
        //

        ReturnCode = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        ReturnCode = FALSE;

        _Status = ERROR_WRITE_FAULT;
    }
    ENDEXCEPT

Cleanup:

    if( ReturnCode == FALSE ) {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE, "Invalid Cache, or bad disk\n" ));
    }

    return( ReturnCode );
}

void MEMMAP_FILE::CloseMapping (void)
{
    if (_BaseAddr) // view
    {
        UnmapViewOfFile(_BaseAddr);
        _BaseAddr = NULL;
    }
    if (_FileMappingHandle) // mapping
    {
        CloseHandle (_FileMappingHandle);
        _FileMappingHandle = NULL;
    }
    if (_FileHandle) // file
    {
        CloseHandle (_FileHandle);
        _FileHandle = NULL;
    }
}


DWORD
MEMMAP_FILE::RemapAddress(
    VOID
    )
/*++

    This private member function remaps the memory mapped file just after
    the file size has been modified.

    Container must be locked when this function is called.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error = ERROR_SUCCESS;
    PVOID OldBaseAddr;
    DWORD OldViewSize;
    PVOID VirtualBase;
    BOOL BoolError;
    LPTSTR MapName = NULL;
    SECURITY_ATTRIBUTES* psa = NULL;

    CloseMapping();
    
    //
    // Create/Open memory mapped file.
    //
    if (!_PerUser)
    {
        psa = SHGetAllAccessSA();
    }

    if (_PerUser || psa)
    {
        _FileHandle =
            CreateFile(
                _FileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                    // share this file with others while it is being used.
                psa,
                OPEN_ALWAYS,
                FILE_FLAG_RANDOM_ACCESS,
                NULL );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) {

        Error = _Status = GetLastError();
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:File open failed, %ld.\n",_Status));

        TcpsvcsDbgAssert( FALSE );

        _FileHandle = NULL;
        goto Cleanup;
    }


#ifndef unix
    /*******
     * UNIX:
     *       Mainwin does not support MapName in CreateFileMapping API
     *       Let us leave the MapName as NULL till this functionality
     *       is available.
     */

    //
    // make a map name.
    //

    DWORD MapNameSize;

    MapNameSize =
        (lstrlen(_FullPathName) +
            lstrlen( _FileName) +
                1 +
                FILE_SIZE_MAX_DIGITS ) * sizeof(TCHAR) ;

    MapName = (LPTSTR) CacheHeap->Alloc( MapNameSize );

    if( MapName == NULL ) {
        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    memcpy(MapName, _FileName, _FullPathNameLen + sizeof(MEMMAP_FILE_NAME));
    memcpy(MapName + _FullPathNameLen + sizeof(MEMMAP_FILE_NAME) - 1, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    wsprintf(MapName + lstrlen(MapName), "%u", _FileSize);

#ifndef unix
#define BACKSLASH_CHAR          TEXT('\\')
#else
#define BACKSLASH_CHAR          TEXT('/')
#endif /* unix */
#define UNDERSCORE_CHAR         TEXT('_')
#define TERMINATING_CHAR        TEXT('\0')

    LPTSTR ScanMapName;

    //
    // Replace '\' with '_'.
    //

    ScanMapName = MapName;

    while( *ScanMapName != TERMINATING_CHAR ) {

        if( *ScanMapName == BACKSLASH_CHAR ) {
            *ScanMapName = UNDERSCORE_CHAR;
        }

        ScanMapName++;
    }
#endif /* !unix */



    //
    // re-create memory mapping.
    //
    _FileMappingHandle = OpenFileMapping(FILE_MAP_WRITE, FALSE, MapName);

    if (_FileMappingHandle == NULL && (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_INVALID_NAME))
    {
        _FileMappingHandle =
            CreateFileMapping(
                _FileHandle,
                psa,
                PAGE_READWRITE,
                0, // high dword of max memory mapped file size.
    #if defined(UNIX) && defined(ux10)
                1024 * 1024, // map entire file.
    #else
                0, // map entire file.
    #endif
                MapName);
    }

    if( _FileMappingHandle == NULL ) {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    //
    // remap view region.
    //

    _BaseAddr =
        MapViewOfFileEx(
            _FileMappingHandle,
            FILE_MAP_WRITE,
            0,
            0,
#if defined(UNIX) && defined(ux10)
            1024 * 1024,   // MAP entire file.
#else
            0,   // MAP entire file.
#endif
            NULL );

#if defined(UNIX) && defined(ux10)
    DWORD FilePointer = SetFilePointer(
                            _FileHandle,
                            _FileSize,
                            NULL,
                            FILE_BEGIN );
    if (FilePointer == 0xFFFFFFFF)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if (BoolError == FALSE)
    {
        Error = _Status = GetLastError();
        goto Cleanup;
    }
#endif

    if( _BaseAddr == NULL ) 
    {
        Error = _Status = GetLastError();
        TcpsvcsDbgAssert( FALSE );

        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MapViewOfFile failed to extend address space, %ld.\n",
                Error ));

       goto Cleanup;
    }

    //
    // reset other pointers.
    //

    _HeaderInfo = (LPMEMMAP_HEADER)_BaseAddr;
    _EntryArray = ((LPBYTE)_BaseAddr + HEADER_ENTRY_SIZE );

    _Status = Error = ERROR_SUCCESS;

Cleanup:


    if( MapName != NULL ) {
        CacheHeap->Free( MapName );
    }

        return( Error );
}

DWORD
MEMMAP_FILE::GrowMapFile(DWORD dwMapFileGrowSize)
/*++

    This private member function extends the memory mapped file and
    creates more free url store entries.

Arguments:

    NONE.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error, i;
    BOOL BoolError;
    DWORD FilePointer;
    DWORD OldNumUrlInternalEntries;

    //
    // check to see that we have reached the limit.
    // we can hold only MAX_URL_ENTRIES url entries.
    // so the file size can grow more than
    //
    //  HEADER_ENTRY_SIZE + MAX_URL_ENTRIES * _EntrySize
    //

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif //INET_DEBG

    //BUGBUG - need to fix this
    if( (_FileSize + dwMapFileGrowSize) >=
            (HEADER_ENTRY_SIZE +
                MAX_URL_ENTRIES * _EntrySize) ) {

        //
        // best matching error code.
        //

        Error = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    FilePointer = SetFilePointer(
                            _FileHandle,
                            dwMapFileGrowSize,
                            NULL,
                            FILE_END );


    if (FilePointer != (_FileSize + dwMapFileGrowSize))
    {
        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "FilePointer != (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);
        
        _Status = GetLastError();
        Error = _Status;

        goto Cleanup;
    }

    if( FilePointer == 0xFFFFFFFF ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    BoolError = SetEndOfFile( _FileHandle );

    if( BoolError != TRUE ) {
        Error = GetLastError();
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

#if INET_DEBUG
    if (GetFileSize(_FileHandle, NULL) != (_FileSize + dwMapFileGrowSize)) {

        TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                "GetFileSize!= (_FileSize + dwMapFileGrowSize)\n" ));

        TcpsvcsDbgAssert(FALSE);

    }
#endif

    //
    // adjust internal size parameters.
    //

    _FileSize += dwMapFileGrowSize;

    //
    // also set the new file size in the memory mapped file so that
    // other user will remap their address space and view the new portion.
    //

    _HeaderInfo->FileSize = _FileSize;

    OldNumUrlInternalEntries = _HeaderInfo->NumUrlInternalEntries;
    _HeaderInfo->NumUrlInternalEntries +=
        dwMapFileGrowSize / _EntrySize;

    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; // cell

    //
    // remap
    //

    Error = RemapAddress();

    if( Error != ERROR_SUCCESS ) {

        goto Cleanup;
    }

    memset(
          (_EntryArray + _EntrySize * OldNumUrlInternalEntries),
           0,
          dwMapFileGrowSize );

    Error = ERROR_SUCCESS;


Cleanup:

    return( Error );
}

BOOL MEMMAP_FILE::CheckNextNBits(DWORD& nArrayIndex, DWORD &dwStartMask, 
                                DWORD nBitsRequired, DWORD& nBitsFound)
{
/*++
    Determines if the next N bits are unset.

Arguments:
    [IN/OUT]
    DWORD &nArrayIndex, DWORD &dwMask

    [IN]
    DWORD nBitsRequired

    [OUT]
    DWORD &nBitsFound

Return Value:

    TRUE if the next N bits were found unset.
    FALSE otherwise.

Notes:
    This function assumes that the range of bits to be checked lie
    within a valid area of the bit map. 
--*/
    DWORD i, j;
    DWORD nIdx = nArrayIndex;
    DWORD dwMask = dwStartMask;
    BOOL fFound = FALSE;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    nBitsFound = 0;

    // Check if the next nBitsRequired bits are unset
    for (i = 0; i < nBitsRequired; i++)
    {
        // Is this bit unset?
        if ((*BitMap & dwMask) == 0)
        {
            // Have sufficient unset bits been found?
            if (++nBitsFound == nBitsRequired)
            {
                // Found sufficient bits. Success.
                fFound = TRUE;
                goto exit;
            }
        }

        // Ran into a set bit. Fail.
        else
        {
            // Indicate the array and bit index 
            // of the set bit encountered.
            nArrayIndex = nIdx;
            dwStartMask = dwMask;
            goto exit;
        }

        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }

    } // Loop nBitsRequired times.


exit:
    return fFound;
}
 

BOOL MEMMAP_FILE::SetNextNBits(DWORD nIdx, DWORD dwMask, 
                                DWORD nBitsRequired)
/*++
    Given an array index and bit mask, sets the next N bits.

Arguments:
    [IN]
    DWORD nIdx, DWORD dwMask, DWORD nBitsRequired

Return Value:

    TRUE if the next N bits were found unset, and successfully set.
    FALSE if unable to set all the required bits.

Notes:
    This function assumes that the range of bits to be set lie
    within a valid area of the bit map. If the function returns
    false, no bits are set.
 --*/
{
    DWORD i, j, nBitsSet = 0;
    LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nIdx];
    BitMap = &_HeaderInfo->AllocationBitMap[nIdx];

    for (i = 0; i < nBitsRequired; i++)
    {    
        // Check that this bit is not already set.
        if (*BitMap & dwMask)
        {
            INET_ASSERT(FALSE);

            // Fail. Unset the bits we just set and exit.
            for (j = nBitsSet; j > 0; j--)
            {
                INET_ASSERT((*BitMap & dwMask) == 0);

                // Right rotate the bit mask.
                dwMask >>= 1;
                if (dwMask == 0x0)
                {
                    dwMask = 0x80000000;
                    BitMap = &_HeaderInfo->AllocationBitMap[--nIdx];
                }                        
                *BitMap &= ~dwMask;
            }             
            return FALSE;
        }

        *BitMap |= dwMask;
        nBitsSet++;
    
        // Left rotate the bit mask.
        dwMask <<= 1;
        if (dwMask == 0x0)
        {
            dwMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nIdx];
        }                        
    
    }

    // Success.
    return TRUE;
}


DWORD
MEMMAP_FILE::GetAndSetNextFreeEntry(
    DWORD nBitsRequired
    )
/*++
    This private member function computes the first available free entry
    index.

Arguments:

    DWORD nBitsRequired

Return Value:

    Next available free entry Index.
--*/
{
    DWORD i, nReturnBit = 0xFFFFFFFF;
    
    // Align if 4k or greater
    BOOL fAlign = (nBitsRequired >= NUM_BITS_IN_DWORD ? TRUE : FALSE);            
    
    // Scan DWORDS from the beginning of the byte array.
    DWORD nArrayIndex = 0;
    while (nArrayIndex < _NumBitMapDWords)
    {
        // Process starting from this DWORD if alignment is not required 
        // and there are free bits, or alignment is required and all bits
        // are free. 
        if (_HeaderInfo->AllocationBitMap[nArrayIndex] !=  0xFFFFFFFF
            && (!fAlign || (fAlign && _HeaderInfo->AllocationBitMap[nArrayIndex] == 0)))
        {
            DWORD nBitIndex = 0;
            DWORD dwMask = 0x1;
            LPDWORD BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];

            // Find a candidate slot.
            while (nBitIndex < NUM_BITS_IN_DWORD)
            {
                // Found first bit of a candidate slot.
                if ((*BitMap & dwMask) == 0)
                {
                    // Calculate leading bit value.
                    DWORD nLeadingBit = NUM_BITS_IN_DWORD * nArrayIndex + nBitIndex;
          
                    // Don't exceed the number of internal entries.
                    if (nLeadingBit + nBitsRequired > _HeaderInfo->NumUrlInternalEntries)
                    {
                        // Overstepped last internal entry
                        goto exit;
                    }

                    // If we just need one bit, then we're done.
                    if (nBitsRequired == 1)
                    {
                        *BitMap |= dwMask;
                        nReturnBit = nLeadingBit;
                        _HeaderInfo->NumUrlEntriesAlloced += 1;
                        goto exit;
                    }

                    // Additional bits required.
                    DWORD nBitsFound;
                    DWORD nIdx = nArrayIndex;

                    // Check the next nBitsRequired bits. Set them if free.
                    if (CheckNextNBits(nIdx, dwMask, nBitsRequired, nBitsFound))
                    {
                        if (SetNextNBits(nIdx, dwMask, nBitsRequired))
                        {
                            // Return the offset of the leading bit.
                            _HeaderInfo->NumUrlEntriesAlloced += nBitsRequired;
                            nReturnBit = nLeadingBit;
                            goto exit;
                        }
                        // Bad news.
                        else
                        {
                            // The bits are free, but we couldn't set them. Fail.
                            goto exit;
                        }
                    }
                    else
                    {
                        // This slot has insufficient contiguous free bits. 
                        // Update the array index. We break back to looping
                        // over the bits in the DWORD where the interrupting
                        // bit was found.
                        nArrayIndex = nIdx;
                        nBitIndex = (nBitIndex + nBitsFound) % NUM_BITS_IN_DWORD;
                        break;
                    }

                } // Found a free leading bit.
                else                
                {
                    // Continue looking at bits in this DWORD.
                    nBitIndex++;
                    dwMask <<= 1;
                }

            } // Loop over bits in DWORD.

        } // If we found a candidate DWORD.

        nArrayIndex++;

    } // Loop through all DWORDS.
	exit:
    return nReturnBit;
}


MemMapStatus MEMMAP_FILE::Init(LPTSTR PathName, DWORD EntrySize, BOOL PerUser)
/*++

    MEMMAP_FILE object constructor.

Arguments:

    PathName : full path name of the memory mapped file.

    EntrySize : size of the each entry in this container.

Return Value:

    NONE.

--*/
{
    DWORD cb;

    _EntrySize =  EntrySize;
    _PerUser = PerUser;
    _FullPathName = NULL;
    _FileName = NULL;
    _FileSize = 0;
    _FileHandle = NULL;
    _FileMappingHandle = NULL;
    _BaseAddr = NULL;
    _HeaderInfo = NULL;
    _EntryArray = NULL;
    _NumBitMapDWords = 0;

    // Validate the path and create the path if it is not already there.
    _Status = ValidateAndCreatePath( PathName );
    if( _Status != ERROR_SUCCESS ) 
        goto Cleanup;

    // Path to memory mapped file.
    cb = strlen(PathName);
    _FullPathName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(DIR_SEPARATOR_STRING));

    if( _FullPathName == NULL ) 
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }

    memcpy(_FullPathName, PathName, cb + 1);
    AppendSlashIfNecessary(_FullPathName, &cb);
    
    _FullPathNameLen = cb;

    // Construct memory mapped file name.
    _FileName = (LPTSTR)CacheHeap->Alloc(cb + sizeof(MEMMAP_FILE_NAME));
    if (!_FileName)
    {
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        INET_ASSERT(FALSE);
        goto Cleanup;
    }
    memcpy(_FileName, _FullPathName, cb);
    memcpy(_FileName + cb, 
        MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    
    SECURITY_ATTRIBUTES* psa = NULL;
    if (!_PerUser)
    {
        psa = SHGetAllAccessSA();
    }

    if (_PerUser || psa)
    {
        // Create/Open memory mapped file.
        _FileHandle =
            CreateFile(
                _FileName,
                GENERIC_READ | GENERIC_WRITE,
                FILE_SHARE_READ | FILE_SHARE_WRITE,
                psa,
                OPEN_ALWAYS,
                FILE_FLAG_RANDOM_ACCESS,
                NULL );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    _Status = GetLastError();

    if( _FileHandle ==  INVALID_HANDLE_VALUE ) 
    {
        _FileHandle = NULL;
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }
    else
    {
        SetFileTime(_FileHandle, NULL, NULL, (LPFILETIME)&dwdwSessionStartTime);
    }

    // Check to this file is new.
    if ( _Status == ERROR_ALREADY_EXISTS ) 
    {

        // Old file.

        _Status = ERROR_SUCCESS;
       _NewFile = FALSE;

       _FileSize = GetFileSize( _FileHandle, NULL );

       if( _FileSize == 0xFFFFFFFF ) 
       {
           _Status = GetLastError();
           TcpsvcsDbgAssert(FALSE);
           goto Cleanup;
       }

       if ((_FileSize < GlobalMapFileGrowSize) || ((_FileSize %GlobalMapFileGrowSize) != 0)) 
       {
            TcpsvcsDbgAssert(FALSE);
            if(!Reinitialize()) 
            {
                TcpsvcsDbgAssert(FALSE);
                SetLastError(_Status);
                goto Cleanup;
            }
            // Reinitialization results in new file.
            _NewFile = TRUE;
       }
    }
    else if( _Status == ERROR_SUCCESS) 
    {
        BOOL BoolError;
        DWORD FilePointer;

        // New file.
        _NewFile = TRUE;

        // Set initial file size.
        _FileSize = GlobalMapFileGrowSize;
        FilePointer = SetFilePointer( _FileHandle, _FileSize, NULL, FILE_BEGIN );

        if( FilePointer == 0xFFFFFFFF ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }

        if (FilePointer != _FileSize )
        {
            TcpsvcsDbgPrint(( DEBUG_FILE_VALIDATE,
                    "FilePointer != (_FileSize)\n" ));

            TcpsvcsDbgAssert(FALSE);
        }

        BoolError = SetEndOfFile( _FileHandle );

        if( BoolError != TRUE ) 
        {
            _Status = GetLastError();
            goto Cleanup;
        }
    }
    else 
    {
        // We should not reach here.
        TcpsvcsDbgAssert(FALSE);
    }
    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgAssert(FALSE);
        goto Cleanup;
    }

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Header Size, %ld.\n",
                    HEADER_ENTRY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Size of elements, %ld.\n",
                        sizeof(MEMMAP_HEADER_SMALL)));


    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Bit Array size, %ld.\n",
                    BIT_MAP_ARRAY_SIZE));

    TcpsvcsDbgPrint(( DEBUG_ERRORS,
                        "Memmap Header Size, %ld.\n",
                    sizeof(MEMMAP_HEADER)));

    TcpsvcsDbgAssert( HEADER_ENTRY_SIZE >= sizeof(MEMMAP_HEADER) );

    // validate the file content if the file is not new.
    if( _NewFile != TRUE ) 
    {
        if( ValidateCache() == FALSE) 
        {
            if (!Reinitialize()) 
            {
                _Status = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;
            }

            // Succeeded in re-initializing the file, we 
            // treat this as if we created a new file.
            _NewFile = TRUE;
        }
    }
    else
    {
        // It is a brand new file. Initialize file header.
        if(!InitHeaderInfo()) 
        {
            // This can happen if there is an exception while
            // initializing headers
            _Status = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;

        }
    }

    // Compute number of bitmap DWORDs used.
    _NumBitMapDWords =
        (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
            NUM_BITS_IN_DWORD; //cell

    // We are done.
    _Status = ERROR_SUCCESS;

Cleanup:

    if( _Status != ERROR_SUCCESS ) 
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "MEMMAP_FILE::Initfailed, %ld\n", _Status ));
        
        SetLastError(_Status);
    }

    if (_NewFile)
        return MEMMAP_STATUS_REINITIALIZED;
    else
        return MEMMAP_STATUS_OPENED_EXISTING;
}

MEMMAP_FILE::~MEMMAP_FILE(
    VOID
    )
/*++

Routine Description:

    MEMMAP_FILE object destructor.

Arguments:

    None.

Return Value:

    None.

--*/
{
    CloseMapping();
    CacheHeap->Free( _FileName );
    CacheHeap->Free( _FullPathName );
}


BOOL MEMMAP_FILE::ReAllocateEntry(LPFILEMAP_ENTRY pEntry, DWORD cbBytes)
/*++

Routine Description:

    Attempts to reallocate an entry at the location given.

Arguments:

    LPFILEMAP_ENTRY pEntry: Pointer to location in file map.
    DWORD cbBytes : Number of bytes requested

Return Value:

    Original value of pEntry if successful. pEntry->nBlocks is set to the new
    value, but all other fields in the entry are unmodified. If insufficient contiguous 
    bits are found at the end of the original entry, NULL is returned, indicating failure.
    In this case the entry remains unmodified. 

Notes:
    
    The Map file should *not* be grown if insufficient additional bits are not found.

--*/
{
    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Validate pEntry.
    DWORD cbEntryOffset = (DWORD) PtrDifference(pEntry, _EntryArray);
    if (IsBadOffset(cbEntryOffset))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Calculate number of blocks required for this entry.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    
    // Sufficient space in current slot?
    if (nBlocksRequired <= pEntry->nBlocks)
    {
        // We're done.
        return TRUE;
    }
    else
    {           
        // Determine if additional free bits are 
        // available at the end of this entry.
        // If not, return NULL.

        // Determine the array and bit indicese of the first
        // free bit immediately following the last set bit of
        // the entry.
        DWORD nTrailingIndex = cbEntryOffset / _EntrySize + pEntry->nBlocks;
        DWORD nArrayIndex = nTrailingIndex / NUM_BITS_IN_DWORD;
        DWORD nBitIndex = nTrailingIndex % NUM_BITS_IN_DWORD;
        DWORD dwMask = 0x1 << nBitIndex;
        DWORD nAdditionalBlocksRequired = nBlocksRequired - pEntry->nBlocks;
        DWORD nBlocksFound;

        // Don't exceed the number of internal entries.
        if (nTrailingIndex + nAdditionalBlocksRequired 
            > _HeaderInfo->NumUrlInternalEntries)
        {
            // Overstepped last internal entry. Here we should fail
            // by returning NULL. Note - DO NOT attempt to grow the 
            // map file at this point. The caller does not expect this.
            return FALSE;
        }

        if (CheckNextNBits(nArrayIndex, dwMask, 
            nAdditionalBlocksRequired, nBlocksFound))
        {
            // We were able to grow the entry.
            SetNextNBits(nArrayIndex, dwMask, nAdditionalBlocksRequired);
            pEntry->nBlocks = nBlocksRequired;
            _HeaderInfo->NumUrlEntriesAlloced += nAdditionalBlocksRequired;
            return TRUE;
        }
        else
            // Couldn't grow the entry.
            return FALSE;
    }
}

LPFILEMAP_ENTRY MEMMAP_FILE::AllocateEntry(DWORD cbBytes)
/*++

Routine Description:

    Member function that returns an free entry from the cache list. If
    none is available free, it grows the map file, makes more free
    entries.

Arguments:

    DWORD cbBytes : Number of bytes requested
    DWORD cbOffset: Offset from beginning of bit map where allocation is requested.

Return Value:

    If NULL, GetStatus() will return actual error code.

--*/
{
    LPFILEMAP_ENTRY NewEntry;

    // Validate cbBytes
    if (cbBytes > MAX_ENTRY_SIZE)
    {
        INET_ASSERT(FALSE);
        return 0;
    }

    // Find and mark off a set of contiguous bits
    // spanning the requested number of bytes.
    DWORD nBlocksRequired = NUMBLOCKS(ROUNDUPBLOCKS(cbBytes));
    DWORD FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

    // Failed to find space.
    if( FreeEntryIndex == 0xFFFFFFFF ) 
    {
        // Map file is full, grow it now.
        _Status = GrowMapFile(cbBytes <= GlobalMapFileGrowSize ?
            GlobalMapFileGrowSize : ROUNDUPTOPOWEROF2(cbBytes, ALLOC_PAGES * PAGE_SIZE) );

        // Failed to grow map file.
        if( _Status != ERROR_SUCCESS ) 
        {
            return NULL;
        }

        // Retry with enlarged map file.
        FreeEntryIndex = GetAndSetNextFreeEntry(nBlocksRequired);

        TcpsvcsDbgAssert( FreeEntryIndex != 0xFFFFFFFF );

        // Failed to allocate bytes after enlarging map file.
        if( FreeEntryIndex == 0xFFFFFFFF ) 
        {
            return NULL;
        }
    }

    INET_ASSERT(  (cbBytes < PAGE_SIZE) 
        || ( (cbBytes >= PAGE_SIZE) && !((_EntrySize * FreeEntryIndex) % PAGE_SIZE)) );
    
    // Cast the memory.
    NewEntry = (LPFILEMAP_ENTRY)
        (_EntryArray + _EntrySize * FreeEntryIndex);
    
    // Mark the allocated space.
    #ifdef DBG
        ResetEntryData(NewEntry, SIG_ALLOC, nBlocksRequired);
    #else
        NewEntry->dwSig = SIG_ALLOC;
    #endif // DBG

    // Set the number of blocks in the entry.
    NewEntry->nBlocks = nBlocksRequired;
        
    return NewEntry;
}


BOOL MEMMAP_FILE::FreeEntry(LPFILEMAP_ENTRY Entry)
/*++

    This public member function frees up a file cache entry.

Arguments:

    UrlEntry : pointer to the entry that being freed.

Return Value:

    TRUE - if the entry is successfully removed from the cache.
    FALSE - otherwise.

--*/
{
    DWORD nIndex, nArrayIndex, 
        nOffset, nBlocks, BitMask;

    LPDWORD BitMap;

    //
    // Validate the pointer passed in.
    //
    if( ((LPBYTE)Entry < _EntryArray) 
        || ((LPBYTE)Entry >=
           (_EntryArray + _EntrySize *
           _HeaderInfo->NumUrlInternalEntries) ) ) 
    {
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }

    // Compute and check offset (number of bytes from start).
    nOffset = (DWORD) PtrDifference(Entry, _EntryArray);
    if( nOffset % _EntrySize ) 
    {
        // Pointer does not point to a valid entry.
        TcpsvcsDbgAssert(FALSE);
        return FALSE;
    }
    
    nBlocks = Entry->nBlocks;

    if (nBlocks > (MAX_ENTRY_SIZE / NORMAL_ENTRY_SIZE))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Compute indicese
    nIndex = nOffset / _EntrySize;
    nArrayIndex = nIndex / NUM_BITS_IN_DWORD;

    //
    // Unmark the index bits in the map.
    //

    BitMap = &_HeaderInfo->AllocationBitMap[nArrayIndex];
    BitMask = 0x1 << (nIndex % NUM_BITS_IN_DWORD);
    for (DWORD i = 0; i < nBlocks; i++)
    {
        // Check we don't free unset bits
        if (!(*BitMap & BitMask))
        {
            TcpsvcsDbgPrint(( DEBUG_ERRORS, "Attempted to free unset bits. Ignoring...\n"));
            return FALSE;
        }

        *BitMap &= ~BitMask;
        BitMask <<= 1;
        if (BitMask == 0x0)
        {
            BitMask = 0x1;
            BitMap = &_HeaderInfo->AllocationBitMap[++nArrayIndex];
        }
    }

    // Mark the freed space.
    ResetEntryData(Entry, SIG_FREE, nBlocks);

    // Reduce the count of allocated entries.
    TcpsvcsDbgAssert(_HeaderInfo->NumUrlEntriesAlloced  > 0);
    _HeaderInfo->NumUrlEntriesAlloced -= nBlocks;

return TRUE;
}


BOOL
MEMMAP_FILE::Reinitialize(void)
/*++

    This  member function reinitializes a cache index file

Arguments:



Return Value:

    Windows error code


--*/
{
    TcpsvcsDbgAssert( _FileHandle != NULL );

    // Close view, mapping, and file.
    CloseMapping();
    
    BOOL BoolError, fReinited = FALSE;
    DWORD FilePointer;

    // If we're re-initialising, that means we're losing all our cached data. 
    // Time to delete all the old stuff

    // But wait -- we only want to do this for the content cache, since we can regen
    // the index from the cookies, and history stores all its info in index file
    // We'll check for "content.ie5" in the path

    if (StrStrI(_FullPathName, "content.ie5"))
    {
        DeleteCachedFilesInDir(_FullPathName);
    }
    
    SECURITY_ATTRIBUTES* psa = NULL;
    if (!_PerUser)
    {
        psa = SHGetAllAccessSA();
    }
    if (_PerUser || psa)
    {
        // check for exclusive access, we do this by opening the
        // file in exclsive mode, if we succeed we are the only one
        _FileHandle = CreateFile
            (
                _FileName,
                GENERIC_WRITE,
                0,    // no read/write sharing
                psa,
                OPEN_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
            );
    }
    else
    {
        _FileHandle = INVALID_HANDLE_VALUE;
    }

    if (_FileHandle == INVALID_HANDLE_VALUE)
    {
        _FileHandle = NULL;
    }
    else
    {
        DWORD FilePointer = SetFilePointer
            ( _FileHandle, GlobalMapFileGrowSize, NULL, FILE_BEGIN);
    
        if( FilePointer != 0xFFFFFFFF)
        {
            if (SetEndOfFile (_FileHandle))
            {
                // Success!
                _FileSize = GlobalMapFileGrowSize;
                fReinited = TRUE;
            }
            else
            {
                TcpsvcsDbgPrint(( DEBUG_ERRORS, "SetEndOfFile failed: %u\n",
                    GetLastError()));
            }
        }            

        // Following will be done by RemapAddress calling CloseMapping
        // CloseHandle (_FileHandle);
        // _FileHandle = NULL
    }

    // Re-attach to the file.

    _Status = RemapAddress();

    if( _Status != ERROR_SUCCESS )
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "Reinitialize:Remap failed, %ld.\n",_Status));
        TcpsvcsDbgAssert( FALSE );
        goto Cleanup;
    }

    if (fReinited)
    {
        // if there is an exception due to bad sector, this will set
        // _status to something other than ERROR_SUCCESS
        if(!InitHeaderInfo()) 
            goto Cleanup;

        _NumBitMapDWords =
            (_HeaderInfo->NumUrlInternalEntries + (NUM_BITS_IN_DWORD - 1)) /
                NUM_BITS_IN_DWORD; // cell
    }

Cleanup:

    return fReinited;
}

BOOL
MEMMAP_FILE::InitHeaderInfo()
/*++

    This  member function intializes the memorymapped headerinfo
    structure

Arguments:



Return Value:

    None

--*/
{
    //
    // initialize file header.
    //
    BOOL fSuccess = TRUE;

    __try {
        TcpsvcsDbgAssert( _HeaderInfo != NULL );

        memcpy(_HeaderInfo->FileSignature, CACHE_SIGNATURE, sizeof(CACHE_SIGNATURE));

        _HeaderInfo->FileSize = _FileSize; // set file size in the memmap file.
        _HeaderInfo->dwHashTableOffset = 0;
        _HeaderInfo->CacheSize = (LONGLONG)0;
        _HeaderInfo->CacheLimit = (LONGLONG)0;
        _HeaderInfo->ExemptUsage = (LONGLONG)0;
        _HeaderInfo->nDirCount = 0;
        
        for (int i = 0; i < DEFAULT_MAX_DIRS; i++)
        {
            _HeaderInfo->DirArray[i].nFileCount = 0;
            _HeaderInfo->DirArray[i].sDirName[0] = '\0';
        }
        
        _HeaderInfo->NumUrlInternalEntries =
            ((_FileSize - HEADER_ENTRY_SIZE ) /
                _EntrySize );

        _HeaderInfo->NumUrlEntriesAlloced = 0;

        memset( _HeaderInfo->AllocationBitMap, 0,  sizeof(_HeaderInfo->AllocationBitMap) );
        memset( _EntryArray, 0, (_FileSize - HEADER_ENTRY_SIZE) );
        memset( _HeaderInfo->dwHeaderData, 0, sizeof(DWORD) * NUM_HEADER_DATA_DWORDS);

        _Status = ERROR_SUCCESS;
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {

        _Status = ERROR_WRITE_FAULT;
        fSuccess = FALSE;
    }
    ENDEXCEPT

    return (fSuccess);
}

LPFILEMAP_ENTRY MEMMAP_FILE::FindNextEntry (DWORD* pdwEnum, DWORD dwFilter, GROUPID GroupId, DWORD dwMatch)
{
    while (1)
    {
        // Get the next item in the hash table.
        HASH_ITEM *pItem = HashGetNextItem (this, (LPBYTE)_BaseAddr, pdwEnum, 0);
        if (!pItem)
            return NULL;

        // continue if search entry within group but hash bit says no group 
        // (may avoid unnecessary page hit by pulling non-relevent pEntry)
        if( GroupId && !pItem->HasGroup() )
            continue;

            
        // Get the entry from the item.
        URL_FILEMAP_ENTRY* pEntry = ValidateUrlOffset (pItem->dwOffset);
        if (!pEntry)
        {
            pItem->MarkFree();
            continue;
        }
        
        // No filter - continue enum until ERROR_NO_MORE_ITEMS.
        if (!dwFilter)
            continue;

        // IDENTITY_CACHE_ENTRY is an identity-specific entry.
        // We don't want these to be shown inappropriately to a client.
        // We may want to be able to display all of these for debug, though.
        if ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY)
            && ((pEntry->dwIdentity != dwMatch)
                || (!pEntry->dwIdentity)))
            continue;

        DWORD cet = pEntry->CacheEntryType & ~IDENTITY_CACHE_ENTRY;
        
        // Temporary hack to always show 1.1 entries 
        // until we have a better way of dealing with them.
        dwFilter |= INCLUDE_BY_DEFAULT_CACHE_ENTRY;

        // Continue enum if no match on cache entry type.
        if ((dwFilter & cet) != cet)
            continue;

        // Continue enum if no match on group.
        if (GroupId ) 
        {
            if( pItem->HasMultiGroup() )
            {
                // need to search the list
                LIST_GROUP_ENTRY*   pListGroup = NULL;
                pListGroup = ValidateListGroupOffset(pEntry->dwGroupOffset);
                if( !pListGroup )
                    continue;

                BOOL fFoundOnList = FALSE;
                while( pListGroup && pListGroup->dwGroupOffset )
                {
                    GROUP_ENTRY* pGroup = NULL;
                    pGroup = ValidateGroupOffset( 
                                pListGroup->dwGroupOffset, pItem); 
                    if( !pGroup )
                    {
                        break;
                    }

                    if( GroupId ==  pGroup->gid )
                    {
                        fFoundOnList = TRUE;
                        break;
                    }

                    if( !pListGroup->dwNext )
                    {
                        break;
                    }

                    // next group on list
                    pListGroup = ValidateListGroupOffset(pListGroup->dwNext);
                }
               
                if( !fFoundOnList )
                    continue; 

            }
            else if( GroupId != 
                        ((GROUP_ENTRY*)( (LPBYTE)_BaseAddr + 
                                 pEntry->dwGroupOffset))->gid ) 
            { 
                continue;
            }

        }

        return (LPFILEMAP_ENTRY) (((LPBYTE)_BaseAddr) + pItem->dwOffset);
    }
}

BOOL MEMMAP_FILE::IsBadOffset (DWORD dwOffset)
{

    ASSERT_ISPOWEROF2 (_EntrySize);
    return (dwOffset == 0
        || (dwOffset & (_EntrySize-1))
        || (dwOffset >= _FileSize));

    return FALSE;

}


BOOL MEMMAP_FILE::IsBadGroupOffset (DWORD dwOffset)
{
    return (dwOffset == 0 || (dwOffset >= _FileSize));
    return FALSE;
}


GROUP_ENTRY* MEMMAP_FILE::ValidateGroupOffset (DWORD dwOffset, HASH_ITEM* hItem)
{
    GROUP_ENTRY *pEntry = NULL;

    // if hash item is available, check the group bit first.
    if( hItem && !hItem->HasGroup())
    {
        return NULL;
    }

    // check the offset 
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    
    // Get the Group.
    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (GROUP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}



URL_FILEMAP_ENTRY* MEMMAP_FILE::ValidateUrlOffset (DWORD dwOffset)
{
    // Validate offset.
    if (IsBadOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL;
    }

    // Validate signature.
    URL_FILEMAP_ENTRY *pEntry =
        (URL_FILEMAP_ENTRY *) ((LPBYTE) _BaseAddr + dwOffset);
    if (pEntry->dwSig != SIG_URL)
    {
        //INET_ASSERT (FALSE);    //  commented out for RAID item 33684
        return NULL;
    }
    
    // TODO: validate entry offsets, string terminations etc.
    return pEntry;
}


LIST_GROUP_ENTRY* MEMMAP_FILE::ValidateListGroupOffset (DWORD dwOffset)
{
    LIST_GROUP_ENTRY *pEntry = NULL;

    // Validate offset.
    if (IsBadGroupOffset (dwOffset))
    {
        INET_ASSERT (FALSE);
        return NULL ;
    }

    //
    // Validate page signature.
    // since we know all the allocated page are aligned with
    // 4K boundary, so from the offset, we can get the 
    // the offset of this page by:
    //   pageOffset = Offset - Offset(mod)4K
    //

    DWORD dwOffsetInPage = dwOffset & 0x00000FFF;
    FILEMAP_ENTRY* pFM = (FILEMAP_ENTRY*) 
        ( (LPBYTE)_BaseAddr + dwOffset - dwOffsetInPage );
    

    if( pFM->dwSig == SIG_ALLOC && pFM->nBlocks )
    {
        pEntry = (LIST_GROUP_ENTRY*) ((LPBYTE) _BaseAddr + dwOffset);
    }
    
    return pEntry;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hndlmgr.cxx ===
#include <cache.hxx>

#ifdef TEST

#include <stdlib.h>
#include <stdio.h>
#include <windows.h>
#include "hndlmgr.hxx"

#define ALLOCATE_FIXED_MEMORY(size) malloc(size)
#define REALLOCATE_MEMORY(ptr, size, flags) realloc(ptr, size)
#define FREE_MEMORY(ptr) free(ptr)

int main ()
{
    HNDLMGR HandleMgr;
    HANDLE h[10];
    HANDLE hBad = (HANDLE) 5150;

    // Test alloc and realloc of handle heap.
    for (int i=9; i>=0; i--)
    {
        h[i] = HandleMgr.Alloc (54);
        printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    }

    // Test invalid, valid, and double free.
    printf ("Free(%d) returns %d\n", NULL, HandleMgr.Free(NULL));
    printf ("Free(%d) returns %d\n", hBad, HandleMgr.Free(hBad));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[3], HandleMgr.Free(h[3]));
    printf ("Free(%d) returns %d\n", h[9], HandleMgr.Free(h[9]));

    // Test mapping of invalid, free, and valid handles.
    printf ("Map(%d) = %d\n", NULL, HandleMgr.Map(NULL));
    printf ("Map(%d) = %d\n", hBad, HandleMgr.Map(hBad));
    printf ("Map(%d) = %d\n", h[3], HandleMgr.Map(h[3]));
    printf ("Map(%d) = %d\n", h[5], HandleMgr.Map(h[5]));

    // Test recycling of handles from free list.
    i = 3;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);
    i = 9;
    h[i] = HandleMgr.Alloc (42);
    printf ("Alloc h[%d] = %d\n", i, (DWORD) h[i]);

    return 1;
}

#endif // TEST

#define INC_GROW 8

//=========================================================================
void HNDLMGR::Destroy (void)
{
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if ((DWORD_PTR) pHeap->pvHandles[iHandle] >= pHeap->dwMaxHandles)
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
        }
        FREE_MEMORY (pHeap);
    }        
}

//=========================================================================
BOOL HNDLMGR::IsValidOffset (DWORD_PTR dwp)
{
    return (pHeap && (dwp < pHeap->dwNumHandles) && 
        ((DWORD_PTR) pHeap->pvHandles[dwp]) >= pHeap->dwMaxHandles);
}

//=========================================================================
HANDLE HNDLMGR::Alloc (DWORD cbAlloc)
{
    PVOID pTemp;

    if (!pHeap)
    {
        // Allocate the heap.
        pHeap = (HNDLHEAP*) ALLOCATE_FIXED_MEMORY
            (sizeof(HNDLHEAP) + INC_GROW * sizeof(LPVOID));
        if (!pHeap)
            return NULL;

        // Initialize the heap.
        pHeap->dwNumHandles = 0;
        pHeap->dwNumInUse = 0;
        pHeap->dwMaxHandles = 0xFFFFFFFF;
        pHeap->dwFirstFree = 0;
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    else if (pHeap->dwFirstFree == pHeap->dwNumHandles)
    {
        // Reallocate the heap.
        if (pHeap->dwNumHandles + INC_GROW >= pHeap->dwMaxHandles)
        {
            // Uh oh, heap is hit the lower bound set by the allocator.
            return NULL; 
        }
        pTemp = REALLOCATE_MEMORY (pHeap, sizeof(HNDLHEAP)
            + (pHeap->dwNumHandles + INC_GROW) * sizeof(LPVOID), LMEM_MOVEABLE);
        if (!pTemp)
            return NULL;
        pHeap = (HNDLHEAP*) pTemp;

        // Extend the free list.
        for (DWORD iHandle = 0; iHandle < INC_GROW; iHandle++)
        {
            pHeap->pvHandles[pHeap->dwNumHandles] =
                (HANDLE) (pHeap->dwNumHandles + 1);
            pHeap->dwNumHandles++;
        }
    }

    // Allocate a handle.
    pTemp = ALLOCATE_FIXED_MEMORY (cbAlloc);
    if (!pTemp)
        return NULL;
    if ((DWORD_PTR) pTemp < pHeap->dwNumHandles)
    {
        // Uh oh, allocator returned a low value!
        FREE_MEMORY (pTemp);
        return NULL;
    }
    if (pHeap->dwMaxHandles >= ((DWORD_PTR) pTemp))
        pHeap->dwMaxHandles = ((DWORD_PTR) pTemp);

    INET_ASSERT(pHeap->dwFirstFree < pHeap->dwNumHandles);
    // Pop the handle off the top of the free list.
    DWORD_PTR dwOffset = pHeap->dwFirstFree;
    pHeap->dwFirstFree = (DWORD_PTR) pHeap->pvHandles[pHeap->dwFirstFree];
    pHeap->pvHandles[dwOffset] = pTemp;
    pHeap->dwNumInUse++;
    return (HANDLE) (dwOffset + 1);
}

//=========================================================================
LPVOID HNDLMGR::Map (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;
    if (!IsValidOffset (dwOffset) || (((DWORD_PTR) pHeap->pvHandles[dwOffset]) == -1))
    {
        return NULL;
    }
    else
        return pHeap->pvHandles[dwOffset];
}

//=========================================================================
BOOL HNDLMGR::Free (HANDLE h)
{
    // Subtract one from handle to get offset.
    DWORD_PTR dwOffset = (DWORD_PTR)h - 1;

    if (!IsValidOffset (dwOffset))
        return FALSE;

    if (((DWORD_PTR) pHeap->pvHandles[dwOffset]) != -1)
    {
        // Push the handle on the top of the free list.
        FREE_MEMORY (pHeap->pvHandles[dwOffset]);
    }

    INET_ASSERT(pHeap->dwFirstFree <= pHeap->dwNumHandles);
    pHeap->pvHandles[dwOffset] = (LPVOID) pHeap->dwFirstFree;
    pHeap->dwFirstFree = dwOffset;
    pHeap->dwNumInUse--;
    return TRUE;
}

//=========================================================================
VOID HNDLMGR::InvalidateAll()
{
    // We're in the process of switching identities; all cache handles
    // should be invalidated so that they can no longer be used.
    
    if (pHeap)
    {
        for (DWORD iHandle=0; iHandle < pHeap->dwNumHandles; iHandle++)
        {
            if (((DWORD_PTR) pHeap->pvHandles[iHandle] > pHeap->dwNumHandles)
                && ((DWORD_PTR) pHeap->pvHandles[iHandle] != -1))
            {
                FREE_MEMORY (pHeap->pvHandles[iHandle]);
                pHeap->pvHandles[iHandle] = (HANDLE)-1;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\proto.h ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    proto.h

Abstract:

    Contains proto type definitions of several functions.

Author:

    Madan Appiah (madana) 15-Nov-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _PROTO_
#define _PROTO_

extern "C"
{
    VOID CacheScavenger(LPVOID Parameter);
}

LONGLONG GetGmtTime(VOID);

DWORD GetFileSizeAndTimeByName(
    LPCTSTR FileName,
    WIN32_FILE_ATTRIBUTE_DATA *lpFileAttrData
    );

DWORD
GetFileSizeByName(
    LPCTSTR pszFileName,
    DWORD *pdwFileSize
    );

BOOL InitGlobals (void);

void LaunchScavenger (void);

DWORD
CreateUniqueFile(
    LPCSTR UrlName,
    LPTSTR Path,
    LPTSTR FileName,
    LPTSTR Extension,
    HANDLE *phfHandle
    );

#endif  // _PROTO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hashutil.cxx ===
/*++
Copyright (c) 1996  Microsoft Corp.

Module Name: hashutil.cxx

Abstract:

    Implementation of linked list of hash tables for cache index lookup.

Author:
    Rajeev Dujari (rajeevd) 22-Oct-96

--*/

#include <cache.hxx>

#define SIG_HASH ('H'|('A'<<8)|('S'<<16)|('H'<<24))

typedef LIST_FILEMAP_ENTRY HASH_FILEMAP_ENTRY;

// hash table parameters
#define BYTES_PER_PAGE 4096

#define ITEMS_PER_BUCKET ((BYTES_PER_PAGE - sizeof(HASH_FILEMAP_ENTRY))\
    / (SLOT_COUNT * sizeof(HASH_ITEM)))
#define BYTES_PER_TABLE (sizeof(HASH_FILEMAP_ENTRY) \
    + SLOT_COUNT * ITEMS_PER_BUCKET * sizeof(HASH_ITEM))


//
// Hash Function: Pearson's method
//

PRIVATE DWORD HashKey (LPCSTR lpsz, DWORD dwAddedHash)
{
    union
    {
        DWORD dw;
        BYTE c[4];
    }
    Hash, Hash2;
        
    const static BYTE bTranslate[256] =
    {
        1, 14,110, 25, 97,174,132,119,138,170,125,118, 27,233,140, 51,
        87,197,177,107,234,169, 56, 68, 30,  7,173, 73,188, 40, 36, 65,
        49,213,104,190, 57,211,148,223, 48,115, 15,  2, 67,186,210, 28,
        12,181,103, 70, 22, 58, 75, 78,183,167,238,157,124,147,172,144,
        176,161,141, 86, 60, 66,128, 83,156,241, 79, 46,168,198, 41,254,
        178, 85,253,237,250,154,133, 88, 35,206, 95,116,252,192, 54,221,
        102,218,255,240, 82,106,158,201, 61,  3, 89,  9, 42,155,159, 93,
        166, 80, 50, 34,175,195,100, 99, 26,150, 16,145,  4, 33,  8,189,
        121, 64, 77, 72,208,245,130,122,143, 55,105,134, 29,164,185,194,
        193,239,101,242,  5,171,126, 11, 74, 59,137,228,108,191,232,139,
        6, 24, 81, 20,127, 17, 91, 92,251,151,225,207, 21, 98,113,112,
        84,226, 18,214,199,187, 13, 32, 94,220,224,212,247,204,196, 43,
        249,236, 45,244,111,182,153,136,129, 90,217,202, 19,165,231, 71,
        230,142, 96,227, 62,179,246,114,162, 53,160,215,205,180, 47,109,
        44, 38, 31,149,135,  0,216, 52, 63, 23, 37, 69, 39,117,146,184,
        163,200,222,235,248,243,219, 10,152,131,123,229,203, 76,120,209
    };

    // Seed the hash values based on the first character.
    Hash.c[0] = bTranslate[ *lpsz];
    Hash.c[1] = bTranslate[(*lpsz+1) & 255];
    Hash.c[2] = bTranslate[(*lpsz+2) & 255];
    Hash.c[3] = bTranslate[(*lpsz+3) & 255];
    Hash.dw += dwAddedHash;
    
    while (*++lpsz)
    {
        // Allow URLs differing only by trailing slash to collide.
        if (lpsz[0] == '/' && lpsz[1] == 0)
            break;

        Hash2.c[0] = Hash.c[0] ^ *lpsz;
        Hash2.c[1] = Hash.c[1] ^ *lpsz;
        Hash2.c[2] = Hash.c[2] ^ *lpsz;
        Hash2.c[3] = Hash.c[3] ^ *lpsz;
            
        Hash.c[0] = bTranslate[Hash2.c[0]];
        Hash.c[1] = bTranslate[Hash2.c[1]];
        Hash.c[2] = bTranslate[Hash2.c[2]];
        Hash.c[3] = bTranslate[Hash2.c[3]];
    }

    return Hash.dw;
}
    
//
// HashLookupItem support functions specific to urlcache:
//      AllocTable
//      IsMatch
//


PRIVATE HASH_FILEMAP_ENTRY* AllocTable
    (LPVOID pAllocObj, LPBYTE* ppBase, LPDWORD* ppdwOffset)
{
    // Save the offset to the table offset.
    DWORD_PTR dpOffsetToTableOffset = (LPBYTE)*ppdwOffset - *ppBase;  // 64BIT
    
    // Ask for BYTES_PER_PAGE instead of BYTES_PER_TABLE
    // so the allocator knows to align on a page boundary.
    INET_ASSERT (BYTES_PER_PAGE >= BYTES_PER_TABLE);
    MEMMAP_FILE* pmmf = (MEMMAP_FILE*) pAllocObj;
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY *) pmmf->AllocateEntry (BYTES_PER_PAGE);
    if (!pTable)
        return NULL;  
    INET_ASSERT (! (((LPBYTE) pTable - *pmmf->GetHeapStart()) & (BYTES_PER_PAGE-1)) );

    // Chain new table to previous table.
    *ppBase = *pmmf->GetHeapStart();
    *ppdwOffset = (DWORD*) (*ppBase + dpOffsetToTableOffset);
    **ppdwOffset = (DWORD) ((LPBYTE)pTable - *ppBase);             // 64BIT
    
    // Initialize the header.
    pTable->dwSig = SIG_HASH;
    pTable->dwNext = 0;
    
    // Fill the rest of the entry with HASH_END
    DWORD* pdw = (DWORD *) (pTable + 1);
    DWORD cdw = SLOT_COUNT * ITEMS_PER_BUCKET * (sizeof(HASH_ITEM)/sizeof(DWORD));
    INET_ASSERT (!(sizeof(HASH_ITEM) % sizeof(DWORD)));
    while (cdw--)
        *pdw++ = HASH_END;

    // Return the new table.
    return pTable;
}

//
// IsMatch: determine if hash table item with a matching 32-bit hash value
// is an actual match or return NULL if a collision.
//

PRIVATE HASH_ITEM* URL_CONTAINER::IsMatch
    (HASH_ITEM *pItem, LPCSTR pszKey, DWORD dwFlags)
{
    MEMMAP_FILE* pmmf = _UrlObjStorage;

    dwFlags &= (LOOKUP_BIT_REDIR | LOOKUP_BIT_CREATE);

    if (pmmf->IsBadOffset (pItem->dwOffset))
    {
        // Fix up a bad hash table item.  This could happen if a thread
        // died between allocating a hash table item and setting the offset.
        pItem->MarkFree();
        return NULL;
    }

    FILEMAP_ENTRY* pEntry = (FILEMAP_ENTRY*)
        (*pmmf->GetHeapStart() + pItem->dwOffset);

    switch (pEntry->dwSig)
    {
        case SIG_URL:
        {        
            // Fail if lookup flags are inconsistent with url entry type.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_NOTURL));

            // Get pointer to URL.
            URL_FILEMAP_ENTRY *pUrlEntry = (URL_FILEMAP_ENTRY *) pEntry;
            LPSTR pszUrl = ((LPSTR) pUrlEntry) + pUrlEntry->UrlNameOffset;
            LPCSTR pszKey2 = pszKey, pszUrl2 = pszUrl;
            
            while ( *pszKey2 && *pszUrl2 && *pszKey2 == *pszUrl2 )
            {
                pszKey2++;
                pszUrl2++;
            }

            if (!*pszKey2 && ! *pszUrl2)
            {
                // Found exact match.

                if (dwFlags == LOOKUP_REDIR_CREATE)
                {
                    // We are have a cache entry for a URL which is now
                    // redirecting.  Delete the cache entry.
                    DeleteUrlEntry (pUrlEntry, pItem, SIG_DELETE);
                    return NULL;
                }

                return pItem;
            }

            // If redirects allowed, check for trailing slash match.
            if ((dwFlags == LOOKUP_URL_TRANSLATE)
                && (pItem->dwHash & HASH_BIT_REDIR))
            {
                DWORD cbUrl = strlen (pszUrl);
                DWORD cbKey = strlen (pszKey);
                INET_ASSERT (cbUrl && pszUrl[cbUrl - 1] == '/');
                if (cbUrl == (cbKey + 1) && !memcmp (pszUrl, pszKey, cbKey))
                    return pItem;
            }
                
            return NULL;
        }
        
        case SIG_REDIR:
        {
            // When online, filter out offline redirect entries.
            if (dwFlags == LOOKUP_URL_NOCREATE)
                return NULL;

            // Check that redirect URL matches exactly.
            REDIR_FILEMAP_ENTRY* pRedir = (REDIR_FILEMAP_ENTRY *) pEntry;
            if (lstrcmp (pszKey, pRedir->szUrl))
                return NULL;

            switch (dwFlags)
            {
                case LOOKUP_URL_CREATE:

                    // We are creating a new entry for a URL that once
                    // redirected.  Delete the stale redirect entry.
                    pmmf->FreeEntry (pRedir);
                    pItem->MarkFree();
                    return NULL;

                case LOOKUP_REDIR_CREATE:
                
                    // Return the redirect item if we're looking for it.
                    return pItem;

                case LOOKUP_URL_TRANSLATE:

                    // Otherwise, translate through the redirect item.
                    pItem = (HASH_ITEM *)
                        (*pmmf->GetHeapStart() + pRedir->dwItemOffset);

                    // Perform some consistency checks.
                    if (pItem->dwHash & HASH_BIT_NOTURL)
                        return NULL; // not an URL entry
                    if ((pItem->dwHash & ~SLOT_MASK) != pRedir->dwHashValue)
                        return NULL; // not a matching URL entry
                    return pItem;

                default:
                    INET_ASSERT (FALSE);                
            }
        }
        
        default:
        {
            // Fix up a bad hash table entry.  This can happen if a thread
            // died between allocating a hash table item and setting the offset.
            pItem->MarkFree();
            return NULL;
        }            
    }
}


//
// HashFindItem: finds a matching entry or else the first free slot
//

BOOL URL_CONTAINER::HashFindItem
    (LPCSTR pszKey, DWORD dwFlags, HASH_ITEM** ppItem)
{    
    INET_ASSERT(!((dwFlags & LOOKUP_URL_DONT_FOLLOW) && (dwFlags & LOOKUP_BIT_CREATE)));
    DWORD dwFind = 0;
    BOOL fLookAgain = !(dwFlags & LOOKUP_URL_DONT_FOLLOW) && GlobalIdentity;
again:
    LPVOID pAllocObj = (LPVOID) _UrlObjStorage;
    LPBYTE pBase = *_UrlObjStorage->GetHeapStart();
    LPDWORD pdwTableOffset = _UrlObjStorage->GetPtrToHashTableOffset();
    
    // Scan flags.
    BOOL fCreate = dwFlags & LOOKUP_BIT_CREATE;

    HASH_ITEM* pFree = NULL;
    DWORD nBlock = 0;
    
    // Hash the URL and calculate the slot.
    DWORD dwHash = HashKey(pszKey, dwFind);
    DWORD iSlot = dwHash & SLOT_MASK;
    dwHash &= ~SLOT_MASK;

    // Walk through the list of hash tables.
    while (*pdwTableOffset && !_UrlObjStorage->IsBadOffset(*pdwTableOffset))
    {
        // Calculate offset to next hash table and validate signature.
        HASH_FILEMAP_ENTRY* pTable =
            (HASH_FILEMAP_ENTRY*) (pBase + *pdwTableOffset);
        if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock++)
            break;

        // Calculate offset to bucket in this table.
        HASH_ITEM* pItem = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;

        // Scan the bucket.
        for (DWORD iSeat=0; iSeat<ITEMS_PER_BUCKET; iSeat++, pItem++)
        {
            // No reserved bits should ever be set on an item.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));

            switch (pItem->dwHash)
            {
                case HASH_FREE: // free item but more items might follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    // If caller wants a free item, record the first one we find.
                    if (!pFree && fCreate)
                        pFree = pItem;
                }                        
                    continue;

                case HASH_END: // first previously unused free item; no more to follow
                {
                    INET_ASSERT (!(pItem->dwHash & ~SLOT_MASK)); 
                    if (!fCreate)
                        *ppItem = NULL;
                    else
                    {
                        // Hand out the first free slot.
                        if (pFree)
                        {
                            // Invalidate offset in case caller neglects to set it.
                            pFree->dwOffset = HASH_END;
                            *ppItem = pFree;
                        }
                        else
                        {
                            // The first free slot has never been used before.
                            INET_ASSERT (pItem->dwOffset == HASH_END);
                            *ppItem = pItem;
                        }
                        (*ppItem)->dwHash = dwHash;
                    }
                }
                    return FALSE;

                default:
                {
                    // Check if the key matches.
                    if (dwHash == (pItem->dwHash & ~SLOT_MASK))
                    {
                        if (dwFlags & INTERNET_CACHE_FLAG_ALLOW_COLLISIONS)
                        {
                            *ppItem = pItem;
                            return TRUE;
                        }
                        
                        HASH_ITEM* pItem2 = IsMatch(pItem, pszKey, dwFlags);
                        if (pItem2)
                        {
                            LPURL_FILEMAP_ENTRY pEntry = 
                                (URL_FILEMAP_ENTRY*)(*(((MEMMAP_FILE*)_UrlObjStorage)->GetHeapStart())
                                                + pItem2->dwOffset);

                            // This will check for a ~U: header or IDENTITY_CACHE_ENTRY
                            // We use the first for compatibility with Wininet5
                            // We use IDENTITY_CACHE_ENTRY for entries we wish to hide from Wininet5
                            if ((pEntry->dwSig==SIG_URL)
                                && (!(dwFlags & LOOKUP_URL_DONT_FOLLOW) 
                                   && ((pEntry->CacheEntryType & IDENTITY_CACHE_ENTRY) 
                                       || IsPerUserEntry(pEntry))))
                            {
                                // We'll search again for an entry corresponding to GlobalIdentity
                                if (fLookAgain)
                                {
                                    fLookAgain = FALSE;
                                    dwFind = GlobalIdentity;
                                    goto again;
                                }

                                // Guarantee that this is what we want
                                if (pEntry->GetIdentity()!=GlobalIdentity)
                                {
                                    continue;
                                }
                                // If we're looking for an identity-0 cache entry
                                // and there is no filename, we need to do the following:
                                // 1. if we're trying to create an entry, then return this
                                // 2. otherwise, say No, the entry is not present
                                if (!pEntry->InternalFileNameOffset && !fCreate)
                                {
                                    *ppItem = NULL;
                                    return FALSE;
                                }
                            }
                            *ppItem = pItem2;
                            return TRUE;
                        }
                    }                    
                }
                    continue;
                    
            } // end switch
          
        } // end for loop to scan seats in bucket
        
        // Follow the link to the next table.
        pdwTableOffset = &pTable->dwNext;

    } // end while (*pdwTableOffset)

    // If we've encountered a corrupt table, we'll have to recover
    if (*pdwTableOffset)
    {
        INET_ASSERT(FALSE);
        *pdwTableOffset = 0;
    }
   
    // We are out a buckets, so an item hasn't been found.

    if (fCreate && !pFree)
    {
        // Caller wanted a free item but we didn't find one.
       
        HASH_FILEMAP_ENTRY* pTable = AllocTable
            (pAllocObj, &pBase, &pdwTableOffset);

//////////////////////////////////////////////////////////////////////
// WARNING: the file might have grown and remapped, so any pointers //
// hereafter must be recalculated by offsets from the new base.     //
//////////////////////////////////////////////////////////////////////

        if (pTable)
        {
            pTable->nBlock = nBlock;
            // Calculate next free slot.
            pFree = ((HASH_ITEM*) (pTable + 1)) + iSlot * ITEMS_PER_BUCKET;
            INET_ASSERT (pFree->dwHash   == HASH_END);
            INET_ASSERT (pFree->dwOffset == HASH_END);
        }
    }

    // Return free item if desired and indicate no item found.
    if (pFree)
    {
        INET_ASSERT (fCreate);
        pFree->dwHash   = dwHash;
        pFree->dwOffset = HASH_END; // invalid in case caller neglects to set it
    }
    *ppItem = pFree;
    return FALSE;
}

//
// HashFindNextItem: scans the table for the next valid URL item
//

PUBLIC
HASH_ITEM*
HashGetNextItem
(
    IN     LPVOID       pAllocObj,      // allocator object
    IN     LPBYTE       pBase,          // base for all offsets
    IN OUT LPDWORD      pdwItemOffset,  // current item offset
    IN     DWORD        dwFlags         // include redirects?
)
{
    INET_ASSERT (!(dwFlags & ~LOOKUP_BIT_REDIR));
    
    // Check if there if the hash table is empty (or we are at the end already.)
    if (!*pdwItemOffset)
        return NULL;

    HASH_ITEM* pItem = (HASH_ITEM*) (pBase + *pdwItemOffset);

    // Calculate current table offset, assuming it's the previous page boundary.
    INET_ASSERT (BYTES_PER_TABLE <= BYTES_PER_PAGE);
    HASH_FILEMAP_ENTRY* pTable =
        (HASH_FILEMAP_ENTRY*) (((DWORD_PTR)pItem) & ~(BYTES_PER_PAGE - 1));

    // Advance item pointer to next location.
    if (pItem == (HASH_ITEM*) pTable)
        pItem = (HASH_ITEM*) (pTable + 1); // first location in table
    else
        pItem++; // next location in table

    do // Scan the list of tables.
    {
        if (pTable->dwSig != SIG_HASH)
            break;
            
        // Scan the current table.
        for (; (LPBYTE) pItem < ((LPBYTE) pTable) + BYTES_PER_TABLE; pItem++)
        {
            // No reserved bits should be set.
            INET_ASSERT (!(pItem->dwHash & HASH_BIT_RESERVED));
            
            if (!(pItem->dwHash & HASH_BIT_NOTURL)
                ||      (dwFlags /* & LOOKUP_BIT_REDIR */)
                    &&  ((pItem->dwHash & HASH_FLAG_MASK) == HASH_REDIR))
            {
                // Found a valid entry.
                *pdwItemOffset = (DWORD) ((LPBYTE)pItem - pBase);  // 64BIT
                return pItem;
            }
        }

        // Follow the link to the next table.
        if (!pTable->dwNext)
            pTable = NULL;
        else
        {
            // Validate the table signature and sequence number.
            DWORD nBlock = pTable->nBlock;
            pTable = (HASH_FILEMAP_ENTRY*) (pBase + pTable->dwNext);
            if (pTable->dwSig != SIG_HASH || pTable->nBlock != nBlock + 1)
                pTable = NULL;

            // Set pointer to first location in table.
            pItem = (HASH_ITEM*) (pTable + 1);
        }
    }
        while (pTable);

    // We reached the end of the last table.
    *pdwItemOffset = 0;
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\group.cxx ===
/*++
Copyright (c) 1998  Microsoft Corporation

Module Name:  group.hxx

Abstract:

    Manages cache group.
    
Author:
    Danpo Zhang (DanpoZ) 02-08-98
--*/

#include <cache.hxx>

GroupMgr::GroupMgr()
{
    _pContainer = NULL;
}

GroupMgr::~GroupMgr()
{
    if( _pContainer )
    {
        _pContainer->Release(FALSE);
    }
}

BOOL
GroupMgr::Init(URL_CONTAINER* pCont)
{
    BOOL fRet = TRUE;

    if( pCont )
    {
        _pContainer = pCont;
        _pContainer->AddRef();
    }
    else
    {
        SetLastError(ERROR_INTERNET_INTERNAL_ERROR);
        fRet = FALSE;
    }

    return fRet;
}

DWORD
GroupMgr::CreateGroup(DWORD dwFlags, GROUPID* pGID)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGID);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    *pGID = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }

    if( dwFlags & CACHEGROUP_FLAG_GIDONLY )
    {
        // only needs to return GID, no group needs to be created
        *pGID = ObtainNewGID();
        if( *pGID )
            dwError = ERROR_SUCCESS;
        else
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            

        goto exit;
    }

    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // get a new gid
    *pGID = ObtainNewGID();

    if( *pGID )
    {
        // insert gid into the first available entry
        
        // set the sticky bit for non purgable group
        if( dwFlags & CACHEGROUP_FLAG_NONPURGEABLE )
        {
            *pGID = SetStickyBit(*pGID);
        }

        pGroupEntry->gid = *pGID;
        pGroupEntry->dwGroupFlags = dwFlags;
        dwError = ERROR_SUCCESS;
    } 
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::CreateDefaultGroups()
{
    
    INET_ASSERT(_pContainer);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwOffsetHead = 0;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }

    if(    GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetHead)
        && dwOffsetHead )
    {
        BOOL fBadHead = FALSE;

        // dwOffsetHead may point to a page which has not actually mapped in
        if( _pContainer->_UrlObjStorage->IsBadGroupOffset(dwOffsetHead) ) 
        {
            fBadHead = TRUE;
        }
        else
        {
            
            // if offset is too big, invalid
            FILEMAP_ENTRY* pFM = NULL;

            pFM = (FILEMAP_ENTRY*) 
                    (*_pContainer->_UrlObjStorage->GetHeapStart() + 
                    dwOffsetHead - sizeof(FILEMAP_ENTRY) );                                   
            if(pFM->dwSig != SIG_ALLOC || !pFM->nBlocks )
            {
                fBadHead = TRUE;
            }
        }
            
        if( fBadHead )
        {
            // dwOffsetHead is invalid, reset!
            SetHeaderData(CACHE_HEADER_DATA_ROOTGROUP_OFFSET, 0);
        }
    }

    // if already created, just return success
    dwError = FindEntry(CACHEGROUP_ID_BUILTIN_STICKY, &pGroupEntry, FALSE);
    if( dwError == ERROR_SUCCESS )
    {
        goto exit;
    }

    //
    // not found, need to create new default groups
    //
    // find the first available entry by using FindEntry()
    // passing gid = 0 means looking for empty entry 
    // passing TRUE means create new page if no entry available
    //
    dwError = FindEntry(0, &pGroupEntry, TRUE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // set the sticky bit for non purgable group
    pGroupEntry->gid = CACHEGROUP_ID_BUILTIN_STICKY;
    pGroupEntry->dwGroupFlags = CACHEGROUP_FLAG_NONPURGEABLE;
    dwError = ERROR_SUCCESS;
   
exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::DeleteGroup(GROUPID gid, DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid);

    BOOL                fMustUnlock;
    DWORD               dwError;
    GROUP_ENTRY*        pGroupEntry = NULL;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               hUrlFindHandle = 0;
    URL_FILEMAP_ENTRY*  pUrlEntry = 0;
    DWORD               dwFindFilter;
    HASH_ITEM*          pItem = NULL; 


    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;    
    }


    // find the first available entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }
     

    // Look for all the url associated with this group
    // mark the groupid to 0
    hUrlFindHandle = _pContainer->GetInitialFindHandle();       

    // set up find filter (do not care about cookie/history)
    dwFindFilter = URLCACHE_FIND_DEFAULT_FILTER 
                    & ~COOKIE_CACHE_ENTRY 
                    & ~URLHISTORY_CACHE_ENTRY;
    
    //
    // loop find all url belongs to this group
    // WARNING: this can be slow!
    //
    do 
    {
        // next url in this group
        pUrlEntry = (URL_FILEMAP_ENTRY*)
                        _pContainer->_UrlObjStorage->FindNextEntry( 
                                &hUrlFindHandle, dwFindFilter, gid); 

        if( pUrlEntry )
        {
            INET_ASSERT(hUrlFindHandle);
            pItem = (HASH_ITEM*)(
                    (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart() +
                    hUrlFindHandle );

            if( pItem->HasMultiGroup() )
            {
                //
                // examing the group list and remove this group
                // from the list
                //
                DWORD       dwNewHeaderOffset       = pUrlEntry->dwGroupOffset;
                DWORD       dwGroupEntryOffset      = PtrDiff32(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                //
                // find the to be deleted group entry in the list
                // of groups associated with this url, we need to
                // fix this by removing the to be dead group from 
                // the list
                //
                DWORD Error = RemoveFromGroupList(
                    pUrlEntry->dwGroupOffset, 
                    dwGroupEntryOffset,
                    &dwNewHeaderOffset 
                );
                    
            
                //
                // found the entry and head offset has been changed
                //
                if( Error == ERROR_SUCCESS && 
                    dwNewHeaderOffset != pUrlEntry->dwGroupOffset )
                {
                    pUrlEntry->dwGroupOffset = dwNewHeaderOffset;
               
                    // 
                    // no more group associated with this url 
                    // let's update the hash flags 
                    //
                    if( !dwNewHeaderOffset )
                    {
                        pItem->ClearMultGroup();
                        pItem->ClearGroup();
                    }
                }

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {
                    //
                    // unset sticky bit for this url IFF 
                    // 1) we are about to delete the last group of this url
                    // 2) there is no more sticky group associated with this
                    //    url other than the to be deleted group
                    //
                    if( !pUrlEntry->dwGroupOffset ||
                        (  pUrlEntry->dwGroupOffset &&
                           NoMoreStickyEntryOnList(pUrlEntry->dwGroupOffset)))
                    {
                    
                        _pContainer->UpdateStickness(
                            pUrlEntry,
                            URLCACHE_OP_UNSET_STICKY,
                            hUrlFindHandle        
                        );
                    }
                }
            }
            else
            {
                //
                // do not move the url entry now, so we just
                // need to reset the GroupOffset and re-exam the
                // stick bit
                //
                pUrlEntry->dwGroupOffset = 0;

                // sticky bit
                if(!pUrlEntry->dwExemptDelta && IsStickyGroup(gid) )
                {

                    _pContainer->UpdateStickness(
                        pUrlEntry,
                        URLCACHE_OP_UNSET_STICKY,
                        hUrlFindHandle        
                    );
                }

            }


            if( dwFlags & CACHEGROUP_FLAG_FLUSHURL_ONDELETE)
            {
                //
                // Container's DeleteUrlEntry method takes two 
                // param, the url entry and hash item.
                // The hUrlFindHandle actually contains the
                // offset of the Hash Item, so we can get 
                // the hash item from there. 
                //

                // if this url belongs to other groups, 
                // do not delete it
                if( !pItem->HasMultiGroup() )
                {
                    _pContainer->DeleteUrlEntry(pUrlEntry, pItem, SIG_DELETE);
                }
            }

        } // find next url
    } while( pUrlEntry);
                    
    // if data entry exists, we should free them as well 
    if( pGroupEntry->dwGroupNameOffset )
    {
        dwError = FindDataEntry(pGroupEntry, &pData, FALSE); 
        if( dwError == ERROR_SUCCESS )
        {
            FreeDataEntry(pData);
        }
    }

    memset(pGroupEntry, 0, sizeof(GROUP_ENTRY) );
    dwError = ERROR_SUCCESS;

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}



DWORD
GroupMgr::GetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pOutGroupInfo, 
    DWORD*                              pdwOutGroupInfoSize
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(gid && pOutGroupInfo && pdwOutGroupInfoSize);

    BOOL            fMustUnlock;
    DWORD           dwError;
    GROUP_ENTRY*    pGroupEntry = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR; 
        goto exit;    
    }

    
    *pdwOutGroupInfoSize = 0;

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE); 
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // init out param
    memset(pOutGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );

    // copy over GROUP_ENTRY -> GROUP_INFO
    Translate(
            dwAttrib,
            pOutGroupInfo, 
            pGroupEntry, 
            GROUP_ENTRY_TO_INFO, 
            pdwOutGroupInfoSize 
    ); 
    dwError = ERROR_SUCCESS; 

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::SetGroup(
    GROUPID                             gid, 
    DWORD                               dwAttrib, 
    INTERNET_CACHE_GROUP_INFOA*         pGroupInfo 
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupInfo && gid);

    BOOL  fMustUnlock;
    DWORD dwError;
    GROUP_ENTRY* pGroupEntry;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = GetLastError();
        goto Cleanup;    
    }

    pGroupEntry = NULL;

    INET_ASSERT(pGroupInfo);

    if( dwAttrib & ~(CACHEGROUP_READWRITE_MASK) ) 
    {
        //
        // read only fields are being requested
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) &&
        (strlen(pGroupInfo->szGroupName) >= GROUPNAME_MAX_LENGTH ) ) 
    {
        //
        // name too long, exceed the buffer limit 
        //
        dwError = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    // find the entry
    dwError = FindEntry(gid, &pGroupEntry, FALSE);
    if( dwError != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    // copy over GROUP_INFO -> GROUP_ENTRY
    Translate(
            dwAttrib,
            pGroupInfo, 
            pGroupEntry, 
            GROUP_INFO_TO_ENTRY, 
            0 
    ); 
    dwError = ERROR_SUCCESS;
    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError; 
}


DWORD
GroupMgr::GetNextGroup(
    DWORD*                          pdwLastItemOffset, 
    GROUPID*                        pOutGroupId
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pOutGroupId);

    BOOL            fMustUnlock;
    BOOL            fEndOfGroups;
    GROUP_ENTRY*    pGroupEntry;
    DWORD           dwNewOffset;
    DWORD           dwError;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        fEndOfGroups = TRUE;
        goto Cleanup;    
    }

    pGroupEntry = NULL;
    dwNewOffset = 0;
    fEndOfGroups = FALSE;

    if( *pdwLastItemOffset == 0 )
    {
        // get root
        dwError = FindRootEntry(&pGroupEntry, FALSE );
        if( dwError != ERROR_SUCCESS )
        {
            //
            // new find and we can not get the root entry
            // this means there are no group at all. 
            //
            fEndOfGroups = TRUE;
            goto Cleanup;
        }
    } // IF: no previous offset, this is a new Find 

    else if( *pdwLastItemOffset == OFFSET_NO_MORE_GROUP )
    {
        // this group of search has completed already
        fEndOfGroups = TRUE;
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;

    } // ELSE IF: previous FindNext has already reached the end of the groups 

    else
    {
        //
        // use the offset to jump to the last returned item's entry  
        //
        pGroupEntry = (GROUP_ENTRY*) 
            (*_pContainer->_UrlObjStorage->GetHeapStart() + *pdwLastItemOffset);                                   
        //
        // one step forward 
        //
        INET_ASSERT(pGroupEntry);                      // can't be null
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) ); // can't be index item
        pGroupEntry++;

    } // ELSE: walk to the item which has been returned by previous FindNext()


    // loop for next entry 
    while(pGroupEntry)
    {
        //
        // if this entry is the last one of the page
        // it contains offset pointing to the next page
        //
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use dwFlags to indicating if
            // this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                //
                // walk to next page
                //
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart() 
                          + pGroupEntry->dwGroupFlags );                                   
            } // IF: index entry point to next page

            else
            {
                //
                // we are done 
                //
                fEndOfGroups = TRUE;
                dwError = ERROR_FILE_NOT_FOUND;
                break; 

            } // ELSE: index page contains nothing (this is the last page)

        } // special case: current entry is the index(point to next page)


        // 
        // using gid to test if the entry is empty, if not, 
        // walk to the next entry  
        //
        if( !pGroupEntry->gid )
        {
            pGroupEntry++;
        } 
        else
        {
            break;    
        }

    } // while(pGroupEntry)
    

Cleanup:
    // update LastItemOffset
    if (!fEndOfGroups
        && pGroupEntry)
    {
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        dwNewOffset = PtrDiff32(pGroupEntry, lpbBase);
        *pdwLastItemOffset = dwNewOffset;

        // copy over GROUP_ENTRY -> GROUP_INFO
        *pOutGroupId = pGroupEntry->gid;
        dwError = ERROR_SUCCESS;

    } // IF:  find the item

    else
    {
        *pdwLastItemOffset = OFFSET_NO_MORE_GROUP;
        dwError = ERROR_FILE_NOT_FOUND;
    } // ELSE: not find 

    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    return dwError;
}


DWORD
GroupMgr::FindRootEntry(
    GROUP_ENTRY** ppOut,        // OUT: first empty entry
    BOOL fCreate                // allocate new page if needed
)
{
    INET_ASSERT(ppOut);
    *ppOut = NULL;
    
    GROUPS_ALLOC_FILEMAP_ENTRY* pPage = NULL;
    DWORD                       dwError;
    DWORD                       dwOffsetToRootEntry = 0;

    // get base offset 
    if( GetHeaderData( CACHE_HEADER_DATA_ROOTGROUP_OFFSET, &dwOffsetToRootEntry))
    {
        if( !dwOffsetToRootEntry && fCreate )
        {
            dwError = CreateNewPage(&dwOffsetToRootEntry, TRUE);

            if( dwError != ERROR_SUCCESS)
            {
                goto Cleanup;
            }
        } 
        else if( !dwOffsetToRootEntry && !fCreate )
        {
            //
            // there is no offset infomation on the mem file 
            // however, the flag says do not create a new page
            // failure is the only option here
            //
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        } 

    } // IF: retrieve base offset

    else
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 

    } // ELSE: failed to get base offset
    

    // 
    // At this point, we should either:
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetToRootEntry );
    *ppOut =  (GROUP_ENTRY*) 
        ( *_pContainer->_UrlObjStorage->GetHeapStart() + dwOffsetToRootEntry);                                   
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError; 
}



DWORD
GroupMgr::FindEntry(
    GROUPID         gid,          // gid, 0 means find first empty seat
    GROUP_ENTRY**   ppOut,        // OUT: entry with gid specified
    BOOL            fCreate       // allocate new page if needed 
                                  // (applied for searching empty seat only)
)
{
    INET_ASSERT(ppOut);

    // fCreate can only be associated with gid == 0
    INET_ASSERT( (fCreate && !gid ) || (!fCreate && gid ) );

    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD           dwError;

    // get Root Entry
    dwError = FindRootEntry(&pGroupEntry, fCreate);
    if( dwError != ERROR_SUCCESS )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    } // failed to get the root entry


    INET_ASSERT(pGroupEntry); // pGroupEntry should be available now

    while(1)
    {
        // special case for end of this page
        if( IsIndexToNewPage(pGroupEntry) )
        {
            //
            // BUGBUG
            // we currently use the dwFlags to indicating
            // if this is pointing to the next offset
            //
            if( pGroupEntry->dwGroupFlags )
            {
                // walk to next page
                pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pGroupEntry->dwGroupFlags );

            } // IF: index entry points to next page
    
            else if( fCreate)
            {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                DWORD dwOffsetToFirstEntry = 0;
                LPBYTE  lpbBase = NULL;

                // remember the old offset for pGroupEntry
                DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

                // create new page!
                dwError = CreateNewPage(&dwOffsetToFirstEntry, FALSE);
                if( dwError != ERROR_SUCCESS )
                {
                    goto Cleanup;
                }

                // recalculate pGroupEntry using the offset remembered 
                lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

                //
                // pGroupEntry currently is the index item, insert 
                // the offset of the first item to the newly created page
                //
                pGroupEntry->dwGroupFlags = dwOffsetToFirstEntry;

                // walk to the new page 
                pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwOffsetToFirstEntry);


            } // ELSE IF: index entry not point to new page, fCreate is
              //          set, a new page is being created  

            else
            {
                // this is the end of all groups, item still not found, 
                dwError = ERROR_FILE_NOT_FOUND;
                break;

            } // ELSE: index entry not point to new page, fCreate not set

        } // IF: this entry is an index entry


        //
        // now pGroupEntry must point to a normal group entry 
        //
        INET_ASSERT( !IsIndexToNewPage(pGroupEntry) );

        if( pGroupEntry->gid != gid )
        {
            // not found, walk to next entry
            pGroupEntry++;
        } 
        else
        {
            // found entry
            dwError = ERROR_SUCCESS;
            break;    
        }

    } // WHILE: (loop over all page)

    
Cleanup:
    if( dwError == ERROR_SUCCESS )
    {
        *ppOut = pGroupEntry;
    }
    else
    {
        *ppOut = NULL;
    }

    return dwError;
}

DWORD
GroupMgr::CreateNewPage(DWORD* dwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *dwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // mark the last entry as index to next page
        // (gid == GID_INDEX_TO_NEXT_PAGE) is the mark, 
        // the actual offset is stored at dwGroupFlags field
        //
        GROUP_ENTRY*    pEnd = (GROUP_ENTRY*) pPage->pGroupBlock;
        pEnd = pEnd + (GROUPS_PER_PAGE - 1);
        pEnd->gid = GID_INDEX_TO_NEXT_PAGE;

        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOTGROUP_OFFSET, *dwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *dwOffsetToFirstEntry = 0;
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }

        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



GROUPID
GroupMgr::ObtainNewGID()
{
    SYSTEMTIME  st;
    DWORD   dwC[2] = {0, 0};
    GROUPID gid = 0;

    // get counter from index file
    if( GetHeaderData(CACHE_HEADER_DATA_GID_LOW,  &dwC[0]) &&
        GetHeaderData(CACHE_HEADER_DATA_GID_HIGH, &dwC[1]) )
    {
        if( !dwC[0] && !dwC[1] )
        {
            // need to get the current system time
            GetSystemTime( &st );
            SystemTimeToFileTime(&st, (FILETIME*)dwC);

        } // IF: counter not initialized 

        else
        {
            // increment
            if( dwC[0] != 0xffffffff )
            {
                dwC[0] ++;
            }
            else
            {
                dwC[0] = 0;
                dwC[1] ++;
            }
        } // ELSE: counter initialized

        // send data back to cache
        if( SetHeaderData(CACHE_HEADER_DATA_GID_LOW,  dwC[0] ) &&
            SetHeaderData(CACHE_HEADER_DATA_GID_HIGH, dwC[1] ) ) 
        {
            //memcpy(&gid, dwC, sizeof(GROUPID) );
            gid = *((GROUPID *)dwC); 
        } 
    } 
    
    // apply the mask to newly created gid
    // the first 4 bits are reserved (one bit is used for stickness)  
    return (gid & GID_MASK); 
}


BOOL
GroupMgr::Translate(
    DWORD                           dwAttrib,
    INTERNET_CACHE_GROUP_INFOA*     pGroupInfo,
    GROUP_ENTRY*                    pGroupEntry, 
    DWORD                           dwFlag,
    DWORD*                          pdwSize                           
) 
{
    INET_ASSERT(pGroupInfo && pGroupEntry);
    BOOL fRet = TRUE;
    GROUP_DATA_ENTRY*   pData = NULL;
    DWORD               dwError;

    if( dwFlag == GROUP_ENTRY_TO_INFO )
    {
        INET_ASSERT(pdwSize);

        // clear
        memset(pGroupInfo, 0, sizeof(INTERNET_CACHE_GROUP_INFOA) );
        *pdwSize = 0;

        // basic entries 
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_BASIC )
        {
            pGroupInfo->dwGroupSize  = sizeof(INTERNET_CACHE_GROUP_INFOA);
            pGroupInfo->dwGroupFlags = pGroupEntry->dwGroupFlags;
            pGroupInfo->dwGroupType  = pGroupEntry->dwGroupType;
            pGroupInfo->dwDiskUsage  = (DWORD)(pGroupEntry->llDiskUsage / 1024);
            pGroupInfo->dwDiskQuota  = pGroupEntry->dwDiskQuota;
        }
        
        // user friendly name
        if( ( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
              (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  ) &&
              pGroupEntry->dwGroupNameOffset ) 
        {
            dwError = FindDataEntry(pGroupEntry, &pData, FALSE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                DWORD dwLen = strlen(pData->szName) + 1;
                INET_ASSERT( dwLen > GROUPNAME_MAX_LENGTH );

                memcpy( pGroupInfo->szGroupName, 
                        pData->szName, 
                        dwLen );

                memcpy( pGroupInfo->dwOwnerStorage,
                        pData->dwOwnerStorage, 
                        sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
            }
        }

        // set size
        *pdwSize = sizeof(INTERNET_CACHE_GROUP_INFOA);
    }

    else 
    if( dwFlag == GROUP_INFO_TO_ENTRY )
    {
        // copy
        if( dwAttrib & CACHEGROUP_ATTRIBUTE_FLAG )
        {
            pGroupEntry->dwGroupFlags = pGroupInfo->dwGroupFlags;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_TYPE )
        {
            pGroupEntry->dwGroupType = pGroupInfo->dwGroupType;
        }

        if( dwAttrib & CACHEGROUP_ATTRIBUTE_QUOTA )
        {
            pGroupEntry->dwDiskQuota = pGroupInfo->dwDiskQuota;
        }

        if( (dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME) | 
            (dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE  )  )
        {

            dwError = FindDataEntry(pGroupEntry, &pData, TRUE);
            if( dwError != ERROR_SUCCESS )
            {
                fRet = FALSE;
            } 
            else
            {
                
                if( dwAttrib & CACHEGROUP_ATTRIBUTE_GROUPNAME )  
                {
                    DWORD dwLen = strlen(pGroupInfo->szGroupName) + 1;
                    INET_ASSERT(dwLen > GROUPNAME_MAX_LENGTH);

                    memcpy( pData->szName, 
                            pGroupInfo->szGroupName, 
                            dwLen );
                }

                if( dwAttrib & CACHEGROUP_ATTRIBUTE_STORAGE ) 
                {
                    memcpy( pData->dwOwnerStorage, 
                            pGroupInfo->dwOwnerStorage,
                            sizeof(DWORD) * GROUP_OWNER_STORAGE_SIZE );
                }


                // BUGBUG
                // if both fields are set to be empty, we should free
                // the allocated data itam 
            }
        }
    }

    else
    {
        fRet = FALSE;
    }
    
    return fRet;
}

BOOL
GroupMgr::IsPageEmpty(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY* pGroupEntry = pHead;
    for( int i = 0; i < (GROUPS_PER_PAGE - 1); i ++)
    {
        if( pGroupEntry->gid )
        {
            break;
        }
        else
        {
            pGroupEntry++;
        }
    }

    // there is no item found on this page
    if( !pGroupEntry->gid && i == GROUPS_PER_PAGE - 1 )
    {
        fRet = TRUE; 
    }


    return fRet;
}

BOOL
GroupMgr::IsLastPage(GROUP_ENTRY* pHead)
{
    BOOL fRet = FALSE;

    GROUP_ENTRY*    pEnd = NULL;

    // jump to last item
    pEnd = pHead + GROUPS_PER_PAGE;

    //
    // the gid has to be marked as GID_INDEX_TO_NEXT_PAGE 
    // for index entry, and if the dwGroupFlags is 0, 
    // that means we are not pointing to any
    // other page, this is the last page indeed.
    //
    if( pEnd->gid == GID_INDEX_TO_NEXT_PAGE && !pEnd->dwGroupFlags )
    {
        fRet = TRUE;
    }

    return fRet;
}


BOOL
GroupMgr::FreeEmptyPages(DWORD dwFlags)
{
    INET_ASSERT(_pContainer);
    BOOL            fMustUnlock;

    BOOL            fRet = TRUE;
    GROUP_ENTRY*    pHead = NULL;
    GROUP_ENTRY*    pPrevHead = NULL;
    GROUP_ENTRY*    pEnd  = NULL;
    GROUP_ENTRY*    pTobeDeleted = NULL;
    BOOL            fFirstPage = TRUE;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        fRet = FALSE;
        goto Cleanup;    
    }

    // BUGBUG FindRootEntry changed the return code, check for dwError
    if( FindRootEntry(&pHead, FALSE ) )
    {
        pPrevHead = pHead; 
        while(pHead)
        {
            pTobeDeleted = NULL;

            if( IsPageEmpty(pHead) )
            {
                pTobeDeleted = pHead;

                //
                // find the offset of the next page
                // 0 which means the current page is the last one
                //
                DWORD dwOffsetNextPage = 0;
                pEnd = pHead + GROUPS_PER_PAGE;
                dwOffsetNextPage = pEnd->dwGroupFlags;

                //     
                // if the first page is to be deleted, we have to 
                // update the offset which points to the next page
                //
                if( fFirstPage)
                {
                    if( !SetHeaderData(
                        CACHE_HEADER_DATA_ROOTGROUP_OFFSET, dwOffsetNextPage))
                    {
                        fRet = FALSE;
                        goto Cleanup;
                    }
                } 
                else
                {
                
                    // 
                    // Link Prev page to Next page
                    //
                    GROUP_ENTRY* pPrevEnd = pPrevHead + GROUPS_PER_PAGE;
                    pPrevEnd->dwGroupFlags = dwOffsetNextPage;  
                }
            } 
        

            //
            // update pHead make it point to the next page 
            //
            if( !IsLastPage(pHead) )
            {
                // remember pPrev
                pPrevHead = pHead;

                // walk to next page
                pEnd = pHead + GROUPS_PER_PAGE;
                pHead = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                          + pEnd->dwGroupFlags );

                // not first page anymore
                fFirstPage = FALSE;
            }
            else
            {
                // this is the last page
                pHead = NULL;
            }

            // 
            // free the tobe deleted page
            //
            if( pTobeDeleted )
            {
                GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
                pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*) ((LPBYTE)pTobeDeleted - sizeof(FILEMAP_ENTRY));

                _pContainer->_UrlObjStorage->FreeEntry(pPage);
            }
        }
    }

    
Cleanup:
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }
    return fRet;
}


DWORD
GroupMgr::FindDataEntry(
    GROUP_ENTRY*        pGroupEntry, 
    GROUP_DATA_ENTRY**  pOutData,
    BOOL                fCreate
)
{
    INET_ASSERT(_pContainer);
    INET_ASSERT(pGroupEntry && pOutData );
    *pOutData = NULL;

    BOOL            fMustUnlock;
    DWORD           dwError;
    LPBYTE          lpbBase = NULL;

    if( !_pContainer->LockContainer(&fMustUnlock) )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR; 
        goto exit;    
    }

    if( pGroupEntry->dwGroupNameOffset )
    {
        lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
        *pOutData = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);
        dwError = ERROR_SUCCESS;
    }

    else if( fCreate)
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pGroupEntry
        DWORD_PTR   dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create new data entry
        *pOutData = GetHeadDataEntry(TRUE);
        if( *pOutData )
        {
            //
            // re-calc pGroupEntry
            //
            lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
            pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

            //
            // set entry's filename offset field 
            //
            pGroupEntry->dwGroupNameOffset = PtrDiff32(*pOutData, lpbBase);

            // succeed
            dwError = ERROR_SUCCESS;
            
        }
        else
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
        }
//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

exit: 
    if( fMustUnlock )
    {
        _pContainer->UnlockContainer();
    }

    if( fCreate && (dwError == ERROR_SUCCESS) )
    {
        // for new item, it's nice to mark the next link to 0
        (*pOutData)->dwOffsetNext = 0;
    }
    return dwError;
}


VOID
GroupMgr::FreeDataEntry(GROUP_DATA_ENTRY* pDataEntry)
{
    // get the head entry 
    GROUP_ENTRY*    pGroupEntry = NULL;
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        return;
    }

    //
    // walk to the index item whose dwGroupNameOffset 
    // contains offset the the head of free list
    //
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // memset the freed data entry
    memset(pDataEntry, 0, sizeof(GROUP_DATA_ENTRY) );

    // make data item's next link points to current head
    pDataEntry->dwOffsetNext = pGroupEntry->dwGroupNameOffset;

    // make the current head to be the just freed item's offset 
    LPBYTE lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart();
    pGroupEntry->dwGroupNameOffset = PtrDiff32(pDataEntry, lpbBase);
}


LPGROUP_DATA_ENTRY
GroupMgr::GetHeadDataEntry(BOOL fCreate)
{
    GROUP_DATA_ENTRY*   pDataEntry = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;         
    LPBYTE              lpbBase = NULL;

    // get the head entry 
    DWORD dwError = FindRootEntry(&pGroupEntry, FALSE );
    if( dwError != ERROR_SUCCESS )
    {
        goto exit;
    }

    // walk to the index item
    pGroupEntry += (GROUPS_PER_PAGE - 1);
    INET_ASSERT( pGroupEntry->gid == GID_INDEX_TO_NEXT_PAGE);

    // the dwGroupNameOffset contains offset the the head of free list
    if( pGroupEntry->dwGroupNameOffset)
    {
        // get the head
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pDataEntry = (GROUP_DATA_ENTRY*) (lpbBase + pGroupEntry->dwGroupNameOffset);

        // reset head to next one
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;
    }   

    else if( fCreate )
    {
//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

        // remember the old offset for pGroupEntry
        DWORD_PTR dwpEntryOffset = PtrDifference(pGroupEntry, *_pContainer->_UrlObjStorage->GetHeapStart());

        // create a new page
        GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
        DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

        pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
                _pContainer->_UrlObjStorage->AllocateEntry(cbSize);

        if( !pPage )
        {
            goto exit;
        }
    
        // memset
        memset(pPage->pGroupBlock, 0, PAGE_SIZE_FOR_GROUPS);

        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 
        GROUP_DATA_ENTRY*   pHead = (GROUP_DATA_ENTRY*)pPage->pGroupBlock;
        pDataEntry = pHead;

        // init list on the newly created page
        for(int i = 0; i < GROUPS_DATA_PER_PAGE - 1; i++)
        {
            // point to next offset 
            GROUP_DATA_ENTRY* pNext = pHead + 1;
            pHead->dwOffsetNext =  PtrDiff32(pNext, lpbBase);
            pHead = pNext;
        }

        //
        // pGroupEntry needs to be re-calc! 
        //
        pGroupEntry = (GROUP_ENTRY*)(lpbBase + dwpEntryOffset);

        // 
        // pGroupEntry currently is the index entry of the first 
        // page, it's dwGroupNameOffset field points the head of 
        // the list of a free group data entry
        //
        pGroupEntry->dwGroupNameOffset = pDataEntry->dwOffsetNext;

//////////////////////////////////////////////////////////////////
// END WARNING: The file might be grown and remapped, so all    //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    }

    else
    {
        goto exit;
    }
    
exit:
    return pDataEntry;
}

DWORD
GroupMgr::GetOffsetFromList(DWORD dwHeadOffset, GROUPID gid, DWORD* pdwOffset)
{
    DWORD dwError;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;
    
    *pdwOffset = 0;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    while(1)
    {
        
        if(!_pContainer->_UrlObjStorage->IsBadGroupOffset(pListGroup->dwGroupOffset))
        {
            pGroupEntry = (GROUP_ENTRY*)
                        (   *_pContainer->_UrlObjStorage->GetHeapStart()
                           + pListGroup->dwGroupOffset );
        }
        else
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;
        }

        if( pGroupEntry && pGroupEntry->gid == gid )
        {
            *pdwOffset = pListGroup->dwGroupOffset;
            break;
        }     

        // end of list, not found 
        if( !pListGroup->dwNext )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;
        }

        // walk to next
        pListGroup = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                pListGroup->dwNext); 

        if( !pListGroup )
        {
            dwError = ERROR_FILE_NOT_FOUND;
            goto Cleanup;
        }   
    } 

    if( *pdwOffset )    
    {
        dwError = ERROR_SUCCESS;
    }
    else
    {
        dwError = ERROR_FILE_NOT_FOUND;
    }

Cleanup:
    return dwError;
}


DWORD   
GroupMgr::CreateNewGroupList(DWORD* pdwHeadOffset)
{
    DWORD               dwError;
    
    // Find empty slot
    *pdwHeadOffset = 0;
    dwError = FindEmptySlotInListPage(pdwHeadOffset);
    if( ERROR_SUCCESS != dwError )
    {
        goto Cleanup;
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::AddToGroupList(DWORD dwHeadOffset, DWORD dwOffset)
{
    DWORD               dwError;
    DWORD               dwEmptySlot;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    // if the item already on the list, return success
    if( IsGroupOnList(dwHeadOffset, dwOffset) )
    {
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }

    if( !pListGroup->dwGroupOffset )
    {
        // list is empty, just need to fill up the Head
        pListGroup->dwGroupOffset = dwOffset;
    }
    else
    {
        // List is not empty, we have to walk to end of the list
        // also need to get another empty slot

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        // remember the old offset for pListGroup
        DWORD_PTR dwpListGroupOffset = PtrDifference(pListGroup, *_pContainer->_UrlObjStorage->GetHeapStart());

        // find empty slot
        dwError = FindEmptySlotInListPage(&dwEmptySlot);
        if( ERROR_SUCCESS != dwError )
        {
            goto Cleanup;
        }


        // recalculate pListGroup using the offset remembered 
        LPBYTE      lpbBase = *_pContainer->_UrlObjStorage->GetHeapStart(); 
        pListGroup = (LIST_GROUP_ENTRY*)(lpbBase + dwpListGroupOffset);

//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
        
        // walk to end of list
        while( pListGroup->dwNext )
        {
            pListGroup = 
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 
            if( !pListGroup )
            {
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;
            }
        }

        // Get ListGroupEmpty Object from the empty slot
        pListGroupEmpty = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwEmptySlot); 
        if( !pListGroupEmpty )
        {
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
            goto Cleanup;
        }

        // assign the new offset
        pListGroupEmpty->dwGroupOffset = dwOffset;

        // append empty slot at the end of the list
        // this need to be done at last to prevent some invalid
        // object get on the list
        pListGroup->dwNext = dwEmptySlot;
    }


    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}

DWORD   
GroupMgr::RemoveFromGroupList(
    DWORD      dwHeadOffset, 
    DWORD      dwOffset, 
    LPDWORD    pdwNewHeadOffset
)
{
    DWORD dwError = ERROR_SUCCESS;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    LIST_GROUP_ENTRY*   pListGroupPrev = NULL;
    LPBYTE              lpbBase = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

    // header is the one we need, we will have to assign new header
    if( pListGroup->dwGroupOffset == dwOffset )
    {
        // new head
        *pdwNewHeadOffset = pListGroup->dwNext;

        // empty removed head and added to free list
        pListGroup->dwGroupOffset = 0;
        pListGroup->dwNext= 0;
        AddToFreeList(pListGroup);

        // done
        dwError = ERROR_SUCCESS;
        goto Cleanup;
    }

    if( !pListGroup->dwNext )
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

    pListGroupPrev = pListGroup;
    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
    if( !pListGroup)
    {
        dwError = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }   

      
    while( pListGroup )
    {
        INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwOffset )
        {
            pListGroupPrev->dwNext = pListGroup->dwNext;

            // empty removed item and added it to free list
            pListGroup->dwGroupOffset = 0;
            pListGroup->dwNext= 0;
            AddToFreeList(pListGroup);

            dwError = ERROR_SUCCESS;
            break;
        }

        if( pListGroup->dwNext )
        {
            pListGroupPrev = pListGroup;
            pListGroup =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(pListGroup->dwNext); 
        }
        else
        {
            dwError = ERROR_FILE_NOT_FOUND;
            break;

        }
    }

Cleanup:
    return dwError;
}

DWORD
GroupMgr::FindEmptySlotInListPage(DWORD* pdwOffsetToSlot)
{

    DWORD   dwError;
    DWORD   dwOffsetRoot = 0;
    LPBYTE  lpbBase = NULL;
    LIST_GROUP_ENTRY*   pListGroupFreeHead = NULL;
    LIST_GROUP_ENTRY*   pListGroupEmpty = NULL;

    if( !GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 
    } 

    if( !dwOffsetRoot)
    {
        // new page needs to be created
        dwError = CreateNewListPage(&dwOffsetRoot, TRUE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;
    } 

    // 
    // At this point, we've got the root entry 
    //  1. retrieved valid dwOffsetToRootEntry or 
    //  2. get the new dwOffsetToRootEntry via CreateNewPage() call  
    //
    INET_ASSERT( dwOffsetRoot);

    lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
    pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwOffsetRoot);                                   
    if( !pListGroupFreeHead )
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup; 
    }

//////////////////////////////////////////////////////////////////
// BEGIN WARNING: The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////
    // get the next free item from the list
    if( !pListGroupFreeHead->dwNext )
    {
        // no free slot left!, let's create a new page!

        // remember the old offset free list head entry
        DWORD_PTR dwpFreeHeadOffset = PtrDifference(pListGroupFreeHead, lpbBase);

        // create a new page
        DWORD  dwNewList;
        dwError = CreateNewListPage(&dwNewList, FALSE);

        if( dwError != ERROR_SUCCESS)
            goto Cleanup;

        // restore
        lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart();
        pListGroupFreeHead =  (LIST_GROUP_ENTRY*) (lpbBase + dwpFreeHeadOffset);                                   
        //
        // add the newly created page contains a list of empty
        // slot (already chained together), now update the head 
        // of free list pointing to the head of the newly created
        // list
        //
        pListGroupFreeHead->dwNext = dwNewList;
    }
//////////////////////////////////////////////////////////////////
// END WARNING:   The file might be grown and remapped, so all  //
// pointers into the file before this point may be invalidated. //
//////////////////////////////////////////////////////////////////

     
    // get the empty slot offset
    *pdwOffsetToSlot = pListGroupFreeHead->dwNext;

    // update the free list to point to the next slot
    pListGroupEmpty = (LIST_GROUP_ENTRY*)(lpbBase + pListGroupFreeHead->dwNext);
    pListGroupFreeHead->dwNext = pListGroupEmpty->dwNext;
    
    memset(pListGroupEmpty, 0, sizeof(LIST_GROUP_ENTRY) );
    
    dwError = ERROR_SUCCESS;

Cleanup:
    return dwError;
}


DWORD
GroupMgr::CreateNewListPage(DWORD* pdwOffsetToFirstEntry, BOOL fIsFirstPage)
{
    DWORD                           dwError;
    GROUPS_ALLOC_FILEMAP_ENTRY*     pPage = NULL;
    DWORD cbSize = sizeof(GROUPS_ALLOC_FILEMAP_ENTRY);

    pPage = (GROUPS_ALLOC_FILEMAP_ENTRY*)
            _pContainer->_UrlObjStorage->AllocateEntry(cbSize);


    if( pPage )
    {
        // clean up allocated page
        cbSize = PAGE_SIZE_FOR_GROUPS;    
        memset(pPage->pGroupBlock, 0, cbSize );

        // calculate the group base offset 
        LPBYTE lpbBase = (LPBYTE) *_pContainer->_UrlObjStorage->GetHeapStart(); 

        *pdwOffsetToFirstEntry = PtrDiff32(pPage->pGroupBlock, lpbBase);

        //
        // chain all items together  
        // (Last item will have dwNext == 0 since we have alredy memset 
        //  the whole page ) 
        //
        LIST_GROUP_ENTRY*    pList = (LIST_GROUP_ENTRY*) pPage->pGroupBlock;

        for( DWORD dwi = 0; dwi < (LIST_GROUPS_PER_PAGE -1); dwi++)
        {
            pList->dwNext = PtrDiff32(pList+1, lpbBase);
            pList++ ;
        }


        if( fIsFirstPage )
        {
            //
            // for first page, we would have to set the offset 
            // back to the CacheHeader 
            //
            if( !SetHeaderData( 
                    CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, 
                    *pdwOffsetToFirstEntry))
            {
                // free allocated page
                _pContainer->_UrlObjStorage->FreeEntry(pPage);
        
                // set error and go
                *pdwOffsetToFirstEntry = 0;
                dwError = ERROR_INTERNET_INTERNAL_ERROR;
                goto Cleanup;

            } // IF: failed to set the offset 
        }
        
        // return the offset to the first entry of the new page
        dwError = ERROR_SUCCESS;

    } // IF: Allocate new page succeed

    else
    {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
    } // ELSE: failed to allocate new page

Cleanup:
    return dwError;
}



BOOL    
GroupMgr::IsGroupOnList(DWORD dwHeadOffset, DWORD dwGrpOffset)
{
    BOOL    fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;

    LIST_GROUP_ENTRY   *pMilestone  = NULL; // used for detecting cycles
    unsigned long       dwNodeCount = 1;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        if( pListGroup->dwGroupOffset == dwGrpOffset )
        {
            fRet = TRUE;
            break;
        }

        if( pListGroup->dwNext )
        {
            LIST_GROUP_ENTRY*   plgTemp =  
                _pContainer->_UrlObjStorage->ValidateListGroupOffset(
                    pListGroup->dwNext); 

            // Sometimes the list is corrupted and contains a cycle
            // This is detected by comparing against the saved pointer
            // (Revisiting an earlier milestone indicates a cycle)
            if (plgTemp==pMilestone)
                break;

            // Also check (and fix) simple self-loops
            if (plgTemp==pListGroup) 
            {
                pListGroup->dwNext = 0;
                break;
            }

            // Advance to next node
            pListGroup = plgTemp;

            // Choose new milestone when node count is power of 2
            dwNodeCount++;

            if ((dwNodeCount & (dwNodeCount-1)) == 0)
                pMilestone = pListGroup;
        }
        else
        {
            break;
        }
    }

Cleanup:
    return fRet;
}


BOOL    
GroupMgr::NoMoreStickyEntryOnList(DWORD dwHeadOffset)
{
    BOOL                fRet = FALSE;
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        //INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // IsSticky?
            if( IsStickyGroup(pGroupEntry->gid) )
            {
                goto Cleanup;
            }
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            break;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

    //
    // reach here means we are at end of the list and can not find
    // any sticky group, return TRUE
    //
    fRet = TRUE;

Cleanup:
    return fRet;


}


void
GroupMgr::AdjustUsageOnList(DWORD dwHeadOffset, LONGLONG llDelta)
{
    LIST_GROUP_ENTRY*   pListGroup = NULL;
    GROUP_ENTRY*        pGroupEntry = NULL;

    pListGroup = 
        _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwHeadOffset); 
    if( !pListGroup )
    {
        goto Cleanup;
    }

    while( pListGroup )
    {
        // INET_ASSERT(pListGroup->dwGroupOffset);

        // get the GroupEntry structure
        if( !_pContainer->_UrlObjStorage->IsBadGroupOffset(
                    pListGroup->dwGroupOffset) )
        {
            pGroupEntry = (GROUP_ENTRY*)
                ( *_pContainer->_UrlObjStorage->GetHeapStart() + 
                pListGroup->dwGroupOffset );

            // AdjustUsage
            _pContainer->AdjustGroupUsage(pGroupEntry, llDelta);
        } 


        // end of list
        if( !pListGroup->dwNext )
        {
            goto Cleanup;
        }

        // next item on list
        pListGroup =  _pContainer->_UrlObjStorage->ValidateListGroupOffset(
            pListGroup->dwNext); 
    }

Cleanup:
    return;

}

void
GroupMgr::AddToFreeList(LIST_GROUP_ENTRY* pFreeListGroup)
{
    DWORD dwOffsetRoot  = 0;
    LIST_GROUP_ENTRY*   pFreeListHead = NULL;
    
    if( GetHeaderData( CACHE_HEADER_DATA_ROOT_GROUPLIST_OFFSET, &dwOffsetRoot))
    {

        pFreeListHead = 
            _pContainer->_UrlObjStorage->ValidateListGroupOffset(dwOffsetRoot); 
   
        if( pFreeListHead && pFreeListGroup )
        {
            pFreeListGroup->dwNext = pFreeListHead->dwNext;

            pFreeListHead->dwNext = PtrDiff32(pFreeListGroup,
                                              *_pContainer->_UrlObjStorage->GetHeapStart());
        } 
    } 
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\unxcache.cxx ===
#include <cache.hxx>
#include <conmgr.hxx>
#include <time.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <fcntl.h>
#include <unistd.h>

#include <errno.h>


extern int errno;

/* Code swiped from cachecfg.cxx */
static BOOL _NormalisePath(LPCTSTR pszPath, LPCTSTR pszEnvVar,
                           LPTSTR pszResult, UINT cbResult)
{
     TCHAR szEnvVar[MAX_PATH];

     // don't count the NULL
     ExpandEnvironmentStrings(pszEnvVar, szEnvVar, sizeof(szEnvVar)-1);
     DWORD dwEnvVar = lstrlen(szEnvVar);

     if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szEnvVar,
                       dwEnvVar, pszPath, dwEnvVar) == 2)
     {
        if (lstrlen(pszPath) + dwEnvVar < cbResult)
        {
           strncpy(pszResult, pszEnvVar, MAX_PATH);
           strncat(pszResult, pszPath + dwEnvVar, MAX_PATH);
           return TRUE;
         }
     }

     return FALSE;
}

void UnixNormalisePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar)
{
     TCHAR szScratch[MAX_PATH];
    
     if (_NormalisePath(pszOrigPath,pszEnvVar,szScratch,sizeof(szScratch)))
        strncpy(pszOrigPath,szScratch,MAX_PATH);
}

void UnixNormaliseIfCachePath(LPTSTR pszOrigPath, LPCTSTR pszEnvVar,
                              LPCTSTR pszKeyName)
{
     if (!strncmp(pszKeyName,CACHE_PATH_VALUE,lstrlen(CACHE_PATH_VALUE)))
        UnixNormalisePath(pszOrigPath,pszEnvVar);
}

int UnixPathExists(LPCTSTR pszPath)
{
     struct stat statbuf;

     if (stat(pszPath, &statbuf) < 0)
     {
        /* If path does not exist */
        if (errno == ENOENT)
           return 0;
        else
           return -1;
     }
     
     /* TODO */
     /* Make sure path points to a directory */

     return 1;
}

void UnixGetValidParentPath(LPTSTR szDevice)
{
     TCHAR szDeviceExists[MAX_PATH];
     PTSTR pszDeviceExists = NULL;
     PTSTR pszEnd          = NULL;
 
     if (!szDevice)
        return;

     lstrcpy(szDeviceExists, szDevice);
 
     pszDeviceExists = szDeviceExists;
     pszEnd          = szDeviceExists + lstrlen(szDeviceExists);
 
     for(;;)
     {
        int   fPathExists;
 
        if (pszEnd == pszDeviceExists)
           break;
 
        fPathExists = UnixPathExists(pszDeviceExists);
        if (fPathExists == -1)
        {
           /* Error */
           break;
        }
        else
        if (fPathExists == 0)
        {
           /* Path does not exist */
           while (*pszEnd != DIR_SEPARATOR_CHAR &&
                  pszEnd != pszDeviceExists)
                 pszEnd--;
 
           *pszEnd = '\0';

           continue;
        }
        else
        {
           /* Path exists */
           lstrcpy(szDevice, pszDeviceExists);
           break;
        }
    }
}

/* CopyDir */

static int DoCopy();

static int UnixCopyCacheFile(const char* file_src,
                         const char* file_dest,
                         mode_t fmode);

static int UnixCreateCacheFolder( const char* dir_dest, mode_t fmode);

#ifndef BUFSIZ
#define BUFSIZ 4096
#endif /* BUFSIZ */

#define CUR_DIR  "."
#define PREV_DIR ".."

static char* pathdir1 = NULL;
static char* pathdir2 = NULL;

int CopyDir(const char* dirname1, const char* dirname2)
{
    int Error = 0;
    struct stat statdir1, statdir2;

    if (!dirname1 || !dirname2)
    {
       goto Cleanup;
    }

    /* We are assuming that dirname1 and dirname2 are absolute paths */
    if (stat(dirname1, &statdir1) < 0)
    {
       Error = errno;
       goto Cleanup;
    }
    else
    if (!S_ISDIR(statdir1.st_mode))
    {
       Error = -1; /* source is not directory */
       goto Cleanup;
    }

    if (stat(dirname2, &statdir2) < 0)
    {
       if (errno != ENOENT)
       {
          Error = errno;
          goto Cleanup;
       }
       /* It is fine if the destination dir does not exist
        * provided all directories above the leaf dir exist
        */
    }
    else
    if (!S_ISDIR(statdir2.st_mode))
    {
       Error = -1; /* destination is not directory */
       goto Cleanup; 
    }

    pathdir1 = (char*)malloc((MAX_PATH+1)*sizeof(char));
    pathdir2 = (char*)malloc((MAX_PATH+1)*sizeof(char));

    lstrcpy(pathdir1, dirname1);
    lstrcpy(pathdir2, dirname2);

    Error = DoCopy();

Cleanup:

    if (pathdir1)
       free(pathdir1);

    if (pathdir2)
       free(pathdir2);

    pathdir1 = pathdir2 = NULL;

    return Error;
}

int DoCopy()
{
    struct stat statbuf;
    struct dirent *dirp;
    DIR           *dp;
    int           Error;
    char          *ptr1, *ptr2;

    if (stat(pathdir1, &statbuf) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    /* Check if this is a regular file */
    if ((statbuf.st_mode & S_IFMT) == S_IFREG)
    {
       Error = UnixCopyCacheFile(pathdir1, pathdir2, statbuf.st_mode);
       goto Cleanup;
    }

    /* Now, we are dealing with a directory */
    if ((Error = UnixCreateCacheFolder(pathdir2, statbuf.st_mode)))
       goto Cleanup;

    ptr1 = pathdir1 + lstrlen(pathdir1);
    *ptr1++ = '/';
    *ptr1   = 0;

    ptr2 = pathdir2 + lstrlen(pathdir2);
    *ptr2++ = '/';
    *ptr2 = 0;

    if ((dp = opendir(pathdir1)) == NULL)
    {
       Error = errno;
       goto Cleanup;
    }

    while ((dirp = readdir(dp)) != NULL)
    {
          if (!lstrcmp(dirp->d_name, CUR_DIR) ||
              !lstrcmp(dirp->d_name, PREV_DIR))
             continue;

          lstrcpy(ptr1, dirp->d_name);
          lstrcpy(ptr2, dirp->d_name);

          if ((Error = DoCopy()))
             break;
    }
    ptr1[-1] = 0;
    ptr2[-1] = 0;

    /* If this fails, ignore this error */
    closedir(dp);

Cleanup:

    return Error;
}

static int UnixCreateCacheFolder( const char* path_dest, mode_t mode_src)
{
    int Error = 0;
    struct stat statbuf2;

    if (stat(path_dest, &statbuf2) < 0)
    {
       if (errno == ENOENT)
       {
          if (mkdir(path_dest, mode_src) < 0)
          {
             Error = errno;
             goto Cleanup;
          }
       }
       else
       {
          Error = errno;
          goto Cleanup;
       }
    }
    else
    if (!S_ISDIR(statbuf2.st_mode))
       Error = -1; /* we are expecting a directory */

Cleanup:
    return Error;
}

int UnixCopyCacheFile(const char* file_src, const char* file_dest, mode_t fmode)
{
    int Error = 0;
    int fd1, fd2;
    char buf[BUFSIZ];
    int  nread, nwrite;

    if ((fd1 = open(file_src, O_RDONLY)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    if ((fd2 = open(file_dest, O_CREAT|O_TRUNC|O_WRONLY, fmode)) < 0)
    {
       Error = errno;
       goto Cleanup;
    }

    while((nread = read(fd1, buf, BUFSIZ)) > 0)
    {
         if ((nwrite = write(fd2, buf, nread)) != nread)
         {
            Error = errno;
            goto Cleanup;
         }
    }

    Error = 0;

Cleanup:

    if (fd1 > 0)
       close(fd1);

    if (fd2 > 0)
       close(fd2);

    return Error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\makefile.inc ===
..\inc\urlcache.h: urlcache.w
    wcshdr < urlcache.w > $@

!IF "$(PROCESSOR_ARCHITECTURE)" == "x86"

urlcache.sym: urlcache.map
    ..\win32s\tools\mapsympe -o urlcache.sym urlcache.map
    binplace urlcache.map
    binplace urlcache.sym

!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\ids.cxx ===
/*++

Copyright (c) 1994-2000  Microsoft Corporation

Module Name:

    ids.cxx

Abstract:

    Contains functions responsible for managing identities in wininet
    
    Contents:

Author:

    July - September 1999. akabir

Environment:

    Win32 user-mode DLL

Revision History:


--*/


#include <cache.hxx>
#include <hlink.h>
#include <urlmon.h>
#include <shlobj.h>
#define HMONITOR_DECLARED    1
#include <shlobjp.h>



// -- whatever -----------------------------------------------------------------------------------------------
#undef SHGetFolderPath
HRESULT SHGetFolderPath(HWND hwnd, int csidl, HANDLE hToken, DWORD dwFlags, LPSTR pszPath);

typedef HRESULT (*PFNSHGETDESKTOPFOLDER)(IShellFolder**);

HRESULT _SHGetDesktopFolder(IShellFolder **psfDesktop)
{
    HMODULE h = LoadLibrary("shell32.dll");
    HRESULT hr = E_POINTER;
    if (h) 
    {
        PFNSHGETDESKTOPFOLDER pfn = (PFNSHGETDESKTOPFOLDER)GetProcAddress(h, "SHGetDesktopFolder");
        if (pfn)
        {
            hr = pfn(psfDesktop);
        }
        FreeLibrary(h);
    }
    return hr;
}

typedef VOID (*PFNILFREE)(LPITEMIDLIST);

VOID _ILFree(LPITEMIDLIST pidl)
{
    HMODULE h = LoadLibrary("shell32.dll");
    if (h) 
    {
        PFNILFREE pfn = (PFNILFREE)GetProcAddress(h, "ILFree");
        if (pfn)
        {
            pfn(pidl);
        }
        FreeLibrary(h);
    }
}


const GUID  DefaultGuid = { 0x00000000L, 0x0000, 0x0000, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
const GUID  IID_IHistSFPrivate = { 0x62e1261L, 0xa60e, 0x11d0, 0x82, 0xc2, 0x0, 0xc0, 0x4f, 0xd5, 0xae, 0x38 };


// -- Utility functions --------------------------------------------------------------------------------------

// Create an ansi representation of a guid.
VOID GuidToAnsiStr(GUID* pGuid, PSTR psz, DWORD dwSize)
{
    WCHAR   wszUid[MAX_PATH];
    StringFromGUID2(*pGuid, wszUid, ARRAY_ELEMENTS(wszUid));
    SHUnicodeToAnsi(wszUid, psz, dwSize);
}


REGISTRY_OBJ* CreateExtensiRegObjFor(HKEY hKey, GUID* pguid)
{
    REGISTRY_OBJ *pro = NULL;

    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(pguid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s\\%s", 
                              IDENTITIES_KEY, 
                              sz, 
                              EXTENSIBLE_CACHE_PATH_KEY) >= 0)
    {
        pro = new REGISTRY_OBJ(hKey, szBranches, CREATE_KEY_IF_NOT_EXISTS);
    }

    return pro;
}

#ifdef WININET6
DWORD IDRegDwordCore(LPCTSTR psz, PDWORD pdw, BOOL fSet)
{
    INET_ASSERT(GlobalIdentity);
    
    CHAR sz[MAX_PATH];    
    GuidToAnsiStr(&GlobalIdentityGuid, sz, ARRAY_ELEMENTS(sz));

    CHAR szBranches[MAX_PATH];
    DWORD dwError = ERROR_INVALID_PARAMETER;
    if (wnsprintf(szBranches, ARRAY_ELEMENTS(szBranches), 
                              "%s\\%s", 
                              IDENTITIES_KEY, 
                              sz) >= 0)
    {
        REGISTRY_OBJ ro(GlobalCacheHKey, szBranches);
        dwError = ro.GetStatus();
        if (dwError==ERROR_SUCCESS)
        {
            dwError = fSet ? ro.SetValue((LPTSTR)psz, pdw)
                           : ro.GetValue((LPTSTR)psz, pdw);
        }
    }
    return dwError;
}

DWORD ReadIDRegDword(LPCTSTR psz, PDWORD pdw)
{
    return IDRegDwordCore(psz, pdw, FALSE);
}

DWORD WriteIDRegDword(LPCTSTR psz, DWORD dw)
{
    return IDRegDwordCore(psz, &dw, TRUE);
}
#endif


VOID CreateCurrentHistory()
{
    INTERNET_CACHE_CONFIG_INFO icci;
    icci.dwStructSize = sizeof(icci);
    if (GlobalUrlContainers->GetUrlCacheConfigInfo(&icci, NULL, CACHE_CONFIG_HISTORY_PATHS_FC)
        && SUCCEEDED(CoInitialize(NULL)))
    {
        // We want to ensure that the history is valid for this user.
        IShellFolder *psfDesktop;
        if (SUCCEEDED(_SHGetDesktopFolder(&psfDesktop)))
        {
            WCHAR wszPath[MAX_PATH];
            LPITEMIDLIST pidlHistory;
            IShellFolder *psfHistory;
            MultiByteToWideChar(CP_ACP, 0, icci.CachePath, -1, wszPath, ARRAY_ELEMENTS(wszPath));
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // get the trailing slash
            PathRemoveFileSpecW(wszPath);  // trim the "content.ie5" junk
            if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL, wszPath, NULL, &pidlHistory, NULL)))
            {
                if (SUCCEEDED(psfDesktop->BindToObject(pidlHistory, NULL, IID_IShellFolder, (VOID**)&psfHistory)))
                {
                    IHistSFPrivate *phsf;
                    if (SUCCEEDED(psfHistory->QueryInterface(IID_IHistSFPrivate, (void**)&phsf)))
                    {
                        FILETIME ftBogus = { 0 };
                        // This forces the validation in shdocvw
                        phsf->WriteHistory(L"", ftBogus, ftBogus, NULL);
                        phsf->Release();
                    }
                    psfHistory->Release();
                }
                _ILFree(pidlHistory);
            }
            psfDesktop->Release();
        }
        CoUninitialize();
    }
}


CONST TCHAR c_szIdentityOrdinal[] = "Identity Ordinal";

DWORD MapGuidToOrdinal(GUID* lpGUID)
{
    DWORD dwOrdinal = 0;
    HKEY    hSourceSubKey;

    if (!memcmp(lpGUID, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return 0;
    }

    if (RegCreateKey(HKEY_CURRENT_USER, IDENTITIES_KEY, &hSourceSubKey) == ERROR_SUCCESS)
    {        
        CHAR    szUid[MAX_PATH];
        GuidToAnsiStr(lpGUID, szUid, ARRAY_ELEMENTS(szUid));

        DWORD   dwSize, dwType;
        DWORD   dwIdentityOrdinal = 1;

        dwSize = sizeof(dwIdentityOrdinal);
        RegQueryValueEx(hSourceSubKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwIdentityOrdinal, &dwSize);

        HKEY    hkUserKey;
        if (RegCreateKey(hSourceSubKey, szUid, &hkUserKey) == ERROR_SUCCESS)
        {
            if (RegQueryValueEx(hkUserKey, c_szIdentityOrdinal, NULL, &dwType, (LPBYTE)&dwOrdinal, &dwSize)!=ERROR_SUCCESS)
            {
                if (RegSetValueEx(hkUserKey, c_szIdentityOrdinal, NULL, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize)==ERROR_SUCCESS)
                {
                    dwOrdinal = dwIdentityOrdinal++;
                    RegSetValueEx(hSourceSubKey, c_szIdentityOrdinal, 0, REG_DWORD, (LPBYTE)&dwIdentityOrdinal, dwSize);
                }
            }            
            RegCloseKey(hkUserKey); 
        }
        RegCloseKey(hSourceSubKey);
    }

    INET_ASSERT(dwOrdinal);
    return dwOrdinal;
}


DWORD AlterIdentity(DWORD dwFlags)
{
    if (!GlobalIdentity)
    {
        return ERROR_INVALID_PARAMETER;
    }
    switch (dwFlags)
    {
    case INTERNET_IDENTITY_FLAG_PRIVATE_CACHE:
    case INTERNET_IDENTITY_FLAG_SHARED_CACHE:
    case INTERNET_IDENTITY_FLAG_CLEAR_DATA:
    case INTERNET_IDENTITY_FLAG_CLEAR_COOKIES:
    case INTERNET_IDENTITY_FLAG_CLEAR_HISTORY:
    case INTERNET_IDENTITY_FLAG_CLEAR_CONTENT:
        break;
    }    
    return ERROR_CALL_NOT_IMPLEMENTED;
}



DWORD RemoveIdentity(GUID* pguidIdentity)
{
    if (!pguidIdentity 
        || !memcmp(pguidIdentity, &DefaultGuid, sizeof(DefaultGuid)))
    {
        return ERROR_INVALID_PARAMETER;
    }

    CHAR    szUid[MAX_PATH];
    GuidToAnsiStr(pguidIdentity, szUid, ARRAY_ELEMENTS(szUid));
    DWORD dwIdentity = MapGuidToOrdinal(pguidIdentity);
    if (dwIdentity==GlobalIdentity)
    {
        DWORD dwErr = SwitchIdentity(NULL);
        if (dwErr!=ERROR_SUCCESS)
            return dwErr;
    }

    DWORD dwErr = ERROR_INVALID_PARAMETER;
    REGISTRY_OBJ roIds(HKEY_CURRENT_USER, IDENTITIES_KEY);
    if (roIds.GetStatus()==ERROR_SUCCESS)
    {        
        // We want to delete the containers before we delete the reg keys.
        // First the extensible containers
        REGISTRY_OBJ* pro = CreateExtensiRegObjFor(HKEY_CURRENT_USER, pguidIdentity);
        if (pro && (pro->GetStatus()==ERROR_SUCCESS))
        {
            CHAR szVendorKey[MAX_PATH];
            while (pro->FindNextKey(szVendorKey, MAX_PATH) == ERROR_SUCCESS)
            {
                REGISTRY_OBJ roVendor(pro, szVendorKey);
                if (roVendor.GetStatus()==ERROR_SUCCESS)
                {
                    TCHAR szPath[MAX_PATH];
                    DWORD ccKeyLen = ARRAY_ELEMENTS(szPath);
                    if (roVendor.GetValue(CACHE_PATH_VALUE, (LPBYTE) szPath, &ccKeyLen)==ERROR_SUCCESS)
                    {
                        TCHAR szScratch[MAX_PATH+1];
                        ExpandEnvironmentStrings(szPath, szScratch, ARRAY_ELEMENTS(szScratch)-1); // don't count the NULL
                        DeleteCachedFilesInDir(szScratch);
                        RemoveDirectory(szScratch);
                    }
                }
            }
        }
        if (pro)
        {
            delete pro;
        }
        TCHAR szPath[MAX_PATH];
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_COOKIES | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }
        if ((S_OK==SHGetFolderPath(NULL, CSIDL_HISTORY | CSIDL_FLAG_CREATE, NULL, 0, szPath))
            && (*szPath!='\0'))
        {
            StrCatBuff(szPath, "\\History.IE5", ARRAY_ELEMENTS(szPath));
            if (GenerateStringWithOrdinal(NULL, dwIdentity, szPath, ARRAY_ELEMENTS(szPath)))
            {
                DeleteCachedFilesInDir(szPath);
                RemoveDirectory(szPath);
            }
        }

        // We'll leave the content; it'll be scavenged anyway.        
        if (roIds.DeleteKey(szUid)==ERROR_SUCCESS)
        {
            dwErr = ERROR_SUCCESS;
        }
    }
    return dwErr;
}


DWORD SwitchIdentity(GUID* pguidIdentity)
{
    DWORD dwIdentity = pguidIdentity ? MapGuidToOrdinal(pguidIdentity) : 0;
    if (dwIdentity==GlobalIdentity)
        return ERROR_SUCCESS;

    DWORD dwErr = ERROR_SUCCESS;
    
    LOCK_CACHE();
    INET_ASSERT(dwIdentity!=GlobalIdentity);

    CloseTheCookieJar();

    DWORD dwTemp = GlobalIdentity;
    GUID guidTemp;
    GlobalIdentity = dwIdentity;
    GlobalCacheInitialized = FALSE;
    memcpy(&guidTemp, &GlobalIdentityGuid, sizeof(GlobalIdentityGuid));
    if (dwIdentity==0)
    {
        memset(&GlobalIdentityGuid, 0, sizeof(GlobalIdentityGuid));
    }
    else
    {
        memcpy(&GlobalIdentityGuid, pguidIdentity, sizeof(*pguidIdentity));
    }

    CConMgr* NewGUC = new CConMgr();

    if (!NewGUC 
        || (NewGUC->GetStatus()!=ERROR_SUCCESS)
        || (!InternetSetOption(NULL, INTERNET_OPTION_END_BROWSER_SESSION, NULL, 0)))
    {
        INET_ASSERT(FALSE);
        if (NewGUC)
            delete NewGUC;
        
        dwErr = ERROR_INTERNET_INTERNAL_ERROR;
        GlobalCacheInitialized = TRUE;
        GlobalIdentity = dwTemp;
        memcpy(&GlobalIdentityGuid, &guidTemp, sizeof(GlobalIdentityGuid));
        goto exit;
    }

    // We need to stop the scavenger
    GlobalPleaseQuitWhatYouAreDoing = TRUE;
    while (GlobalScavengerRunning!=-1)
    {
        Sleep(0);
    }
    
    delete GlobalUrlContainers;
    GlobalUrlContainers = NewGUC;
    GlobalCacheInitialized = TRUE;

    // It's safe now, you can scavenge
    GlobalPleaseQuitWhatYouAreDoing = FALSE;

    if (AnyFindsInProgress(0))
    {
        HandleMgr.InvalidateAll();
    }

    CreateCurrentHistory();
    
    // Note to ASK: check what this call does, if it affects identities
    if ((dwErr = GlobalUrlContainers->CreateDefaultGroups())!=ERROR_SUCCESS)
        goto exit;
        
    if (!OpenTheCookieJar()) 
    {
        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

#ifdef WININET6
    // Set warnings appropriately.
    GlobalWarnOnPost = FALSE;
    GlobalWarnAlways = FALSE;
    GlobalWarnOnZoneCrossing = TRUE;
    GlobalWarnOnBadCertSending = FALSE;
    GlobalWarnOnBadCertRecving = TRUE;
    GlobalWarnOnPostRedirect = TRUE;
    GlobalDataReadWarningUIFlags();
#endif

exit:
    UNLOCK_CACHE();
    INET_ASSERT((dwErr==ERROR_SUCCESS));
    return dwErr;
}

// CreateExtensiRegObj ----------------
// Create an identity-appropriate registry object
// for extensible cache containers.

REGISTRY_OBJ* CreateExtensiRegObj(HKEY hKey)
{
    REGISTRY_OBJ *pro = NULL;
    
    if (GlobalIdentity)
    {
        pro = CreateExtensiRegObjFor(hKey, &GlobalIdentityGuid);
    }
    else
    {
        REGISTRY_OBJ roCache(hKey, CACHE5_KEY);
        if (roCache.GetStatus()==ERROR_SUCCESS)
        {
            pro = new REGISTRY_OBJ(&roCache, EXTENSIBLE_CACHE_PATH_KEY, CREATE_KEY_IF_NOT_EXISTS);
        }
    }

    if (pro && pro->GetStatus()!=ERROR_SUCCESS)
    {
        delete pro;
        pro = NULL;
    }

    return pro;
}


// GenerateStringWithOrdinal ------------
// We want to append the identity ordinal to a string
// If psz is null, then pszBuffer better contain a 0-terminated string that we can
//      append the ordinal to.
// Otherwise, we copy psz to pszBuffer and append to that.
BOOL GenerateStringWithOrdinal(PCTSTR psz, DWORD dwOrdinal, PTSTR pszBuffer, DWORD dwMax)
{
    DWORD cc = psz ? lstrlen(psz) : lstrlen(pszBuffer);

    if (cc>dwMax)
        return FALSE;

    if (psz)
    {
        memcpy(pszBuffer, psz, cc*sizeof(*pszBuffer));
    }
    
    if (dwOrdinal)
    {
        if (!AppendSlashIfNecessary(pszBuffer, &cc))
            return FALSE;   

        if (wnsprintf(pszBuffer+cc, dwMax-cc,
                                "%d", 
                                dwOrdinal) < 0)
            return FALSE;
    }
    else
    {
        pszBuffer[cc] = TEXT('\0');
    }
    
    return TRUE;
}

// IsPerUserEntry
// Examine the headers of a cache entry to determine whether or 
// not it is user-specific

BOOL IsPerUserEntry(LPURL_FILEMAP_ENTRY pfe)
{
    INET_ASSERT(pfe);
    
    BOOL fRet = FALSE;
    PTSTR lpszHeaderInfo = (PTSTR)pfe + pfe->HeaderInfoOffset;
    DWORD dwHeaderSize = pfe->HeaderInfoSize;

    if (!lpszHeaderInfo || !dwHeaderSize)
    {
        return FALSE;
    }
    
    LPSTR lpTemp = lpszHeaderInfo+dwHeaderSize-1;
    LPSTR lpTemp2;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) 
    {
        if (*lpTemp ==':') 
        {
                   // compare with "~U:"
            fRet = (!strnicmp(lpTemp-2, vszUserNameHeader, sizeof(vszUserNameHeader)-1))
                   // guarantee that this is the beginning of a header
                   && (((lpTemp-2)==lpszHeaderInfo)
                       || isspace(*(lpTemp-3)));
            break;
        }
        --lpTemp;
    }
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\initglob.cxx ===
#include <cache.hxx>


// Typedef for GetFileAttributeEx function
typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);
#ifdef unix
#include <flock.hxx>
#endif /* unix */

//
// global variables definition.
//

CRITICAL_SECTION GlobalCacheCritSect;
BOOL GlobalCacheInitialized = FALSE;
CConMgr *GlobalUrlContainers = NULL;
LONG GlobalScavengerRunning = -1;
DWORD GlobalRetrieveUrlCacheEntryFileCount = 0;
PFNGETFILEATTREX gpfnGetFileAttributesEx = 0;

char       g_szFixup[sizeof(DWORD)];
HINSTANCE  g_hFixup;
PFN_FIXUP  g_pfnFixup;

MEMORY *CacheHeap = NULL;
HNDLMGR HandleMgr;

#ifdef unix
/***********************
 * ReadOnlyCache on Unix
 * *********************
 * When the cache resides on a file system which is shared over NFS
 * and the user can access the same cache from different work-stations,
 * it causes a problem. The fix is made so that, the first process has
 * write access to the cache and any subsequent browser process which
 * is started from a different host will receive a read-only version
 * of the cache and will not be able to get cookies etc. A symbolic
 * link is created in $HOME/.microsoft named ielock. Creation and
 * deletion of this symbolic link should be atomic. The functions
 * CreateAtomicCacheLockFile and DeleteAtomicCacheLockFile implement
 * this behavior. When a readonly cache is used, cache deletion is
 * not allowed (Scavenger thread need not be launched).
 *
 * g_ReadOnlyCaches denotes if a readonly cache is being used.
 * gszLockingHost denotes the host that holds the cache lock.
 */

BOOL g_ReadOnlyCaches = FALSE;
char *gszLockingHost = 0;

extern "C" void unixGetWininetCacheLockStatus(BOOL *pBool, char **pszLockingHost)
{
    if(pBool)
        *pBool = g_ReadOnlyCaches;
    if(pszLockingHost)
        *pszLockingHost = gszLockingHost;
}
#endif /* unix */

#ifdef CHECKLOCK_PARANOID

//  Code to enforce strict ordering on resources to prevent deadlock
//  One cannot attempt to take the critical section for the first time
//  if one holds a container lock
DWORD dwThreadLocked;
DWORD dwLockLevel;

void CheckEnterCritical(CRITICAL_SECTION *_cs)
{
    EnterCriticalSection(_cs);
    if (_cs == &GlobalCacheCritSect && dwLockLevel++ == 0)
    {
        dwThreadLocked = GetCurrentThreadId();
        if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
    }
}

void CheckLeaveCritical(CRITICAL_SECTION *_cs)
{
    if (_cs == &GlobalCacheCritSect)
    {
        INET_ASSERT(dwLockLevel);
        if (dwLockLevel == 1)
        {
            if (GlobalUrlContainers) GlobalUrlContainers->CheckNoLocks(dwThreadLocked);
            dwThreadLocked = 0;
        }
        dwLockLevel--;
    }
    LeaveCriticalSection(_cs);
}
#endif

//

/*++

--*/

BOOL InitGlobals (void)
{
    if (GlobalCacheInitialized)
        return TRUE;

    LOCK_CACHE();

    if (GlobalCacheInitialized)
        goto done;

    GetWininetUserName();

    // Read registry settings.
    EnsureInternetSettingsKeyCached();
    InternetReadRegistryDword(vszSyncMode, &GlobalUrlCacheSyncMode);

    { // Detect a fixup handler.  Open scope to avoid compiler complaint.
    
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, OLD_CACHE_KEY);

        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD cbFixup = sizeof(g_szFixup);
            if (ERROR_SUCCESS != roCache.GetValue
                ("FixupKey", (LPBYTE) g_szFixup, &cbFixup))
            {
                g_szFixup[0] = 0;
            }

            if (g_szFixup[0] != 'V' || g_szFixup[3] != 0)
            {
                g_szFixup[0] = 0;
            }                  
        }
    }
    {
        REGISTRY_OBJ roCache (HKEY_LOCAL_MACHINE, CACHE5_KEY);
        if (ERROR_SUCCESS == roCache.GetStatus())
        {
            DWORD dwDefTime;
            if (ERROR_SUCCESS == roCache.GetValue("SessionStartTimeDefaultDeltaSecs", &dwDefTime))
            {
                dwdwSessionStartTimeDefaultDelta = dwDefTime * (LONGLONG)10000000;
                dwdwSessionStartTime -= dwdwSessionStartTimeDefaultDelta;
            }
        }
    }
    
    // Seed the random number generator for random file name generation.
    srand(GetTickCount());

    GlobalUrlContainers = new CConMgr();
    GlobalCacheInitialized =
        GlobalUrlContainers && (GlobalUrlContainers->GetStatus() == ERROR_SUCCESS);

    if( GlobalCacheInitialized )
    {
        DWORD dwError = GlobalUrlContainers->CreateDefaultGroups();
        INET_ASSERT(dwError == ERROR_SUCCESS);
    }
    else
    {
        delete GlobalUrlContainers;
        GlobalUrlContainers = NULL;
    }

done:
    UNLOCK_CACHE();
    return GlobalCacheInitialized;
}


BOOL
DLLUrlCacheEntry(
    IN DWORD Reason
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    HMODULE ModuleHandleKernel;

    switch (Reason)
    {
        case DLL_PROCESS_ATTACH:
#ifdef CHECKLOCK_PARANOID
            dwThreadLocked = 0;
            dwLockLevel = 0;
#endif
            ModuleHandleKernel = GetModuleHandle("KERNEL32");
            if (ModuleHandleKernel)
            {
                gpfnGetFileAttributesEx = (PFNGETFILEATTREX)
                    GetProcAddress(ModuleHandleKernel, "GetFileAttributesExA");
            }

            InitializeCriticalSection (&GlobalCacheCritSect);
            // RunOnceUrlCache (NULL, NULL, NULL, 0); // test stub
#ifdef unix
            if(CreateAtomicCacheLockFile(&g_ReadOnlyCaches,&gszLockingHost) == FALSE)
                return FALSE;
#endif /* unix */
            break;

        case DLL_PROCESS_DETACH:

            // Clean up containers list.
            if (GlobalUrlContainers != NULL)
            {
                delete GlobalUrlContainers;
                GlobalUrlContainers = NULL;
            }
            
            // Unload fixup handler.
            if (g_hFixup)
                FreeLibrary (g_hFixup);
                
            HandleMgr.Destroy();
            
#ifdef unix
        DeleteAtomicCacheLockFile();
#endif /* unix */
        DeleteCriticalSection (&GlobalCacheCritSect);
        break;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\reg.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    reg.cxx

Abstract:

    Contains code that implements REGISTRY_OBJ class defined in reg.hxx.

Author:

    Madan Appiah (madana)  19-Dec-1994

Environment:

    User Mode - Win32

Revision History:

--*/

#include <cache.hxx>

REGISTRY_OBJ::REGISTRY_OBJ(
    HKEY Handle,
    DWORD Error
    )
/*++

Routine Description:

    This function is a inline function that initialize the registry
    object with given handle and status.

Arguments:

    Handle : registry object handle value.

    Error : registry object status value.

Return Value:

    None.

--*/
{
    _RegHandle = Handle;
    _Status = Error;
    _Index = 0;
    _ValIndex = 0;

    // Don't allow keys or values to be written to current user during
    // GUI mode setup because they will get slammed into all profiles.
    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
        _dwAccess = BASIC_ACCESS;
    else
        _dwAccess = DEFAULT_KEY_ACCESS;
    return;
};


DWORD REGISTRY_OBJ::WorkWith(
    HKEY ParentHandle,
    LPTSTR KeyName,
    DWORD dwFlags,
    DWORD dwAccess
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry key
    handle and this object's keyname.

Arguments:

    ParentHandle : registry handle of the parent key.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = dwAccess;
    
    if (ParentHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        // Don't allow anything other than query and enumerate
        // when working with HKCU hive during GUI mode setup
        _dwAccess &= BASIC_ACCESS;
    }

    _Status = REGOPENKEYEX(
                ParentHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        REGISTRY_OBJ roTemp(ParentHandle, (LPSTR)NULL);
        _Status = roTemp.GetStatus();
        if (_Status==ERROR_SUCCESS)
        {
            _Status = roTemp.Create(KeyName, &_RegHandle);
        }
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD REGISTRY_OBJ::WorkWith(
    REGISTRY_OBJ *ParentObj,
    LPTSTR KeyName,
    DWORD dwFlags
    )
/*++

Routine Description:

    Initializes the registry object from its parent's registry object
    and this object's keyname.

Arguments:

    ParentObj : registry object of the parent.

    Keyname : key name of the new registry object being created.

Return Value:

    None.

--*/
{
    if (_RegHandle)
    {
        REGCLOSEKEY(_RegHandle);
    }
    _Index = 0;
    _ValIndex = 0;
    _dwAccess = ParentObj->GetAccessFlags();
    _Status = REGOPENKEYEX(
                ParentObj->_RegHandle,
                KeyName,
                0,
                _dwAccess,
                &_RegHandle );

    if (_Status == ERROR_FILE_NOT_FOUND  && dwFlags == CREATE_KEY_IF_NOT_EXISTS)
    {
        _Status = ParentObj->Create(KeyName, &_RegHandle);
    }

    if( _Status != ERROR_SUCCESS )
    {
        _RegHandle = NULL;
    }

    return _Status;
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    HKEY* pChildHandle
    )
/*++

Routine Description:

    Creates a new subkey under this key.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    HKEY ChildHandle;
    DWORD KeyDisposition;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        _Status = ERROR_ACCESS_DENIED;
        return _Status;
    }

    _Status = REGCREATEKEYEX(
               _RegHandle,
               ChildName,
               0,
               DEFAULT_CLASS,
               REG_OPTION_NON_VOLATILE,
               DEFAULT_KEY_ACCESS,
               NULL,
               (pChildHandle) ? pChildHandle : &ChildHandle,
               &KeyDisposition );

    if( _Status != ERROR_SUCCESS )
    {
        return( _Status );
    }

    if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%ws) is created.\n", ChildName ));
#else
        TcpsvcsDbgPrint(( DEBUG_REGISTRY,
           "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
    }

    //
    // close the child handle before return.
    //

    if (!pChildHandle)
    {
        REGCLOSEKEY( ChildHandle );
    }

    return( ERROR_SUCCESS );
}


DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;
    DWORD KeyDisposition;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        return ERROR_ACCESS_DENIED;
    }

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                &KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::Create(
    LPTSTR ChildName,
    REGISTRY_OBJ **ChildObj,
    DWORD *KeyDisposition
    )
/*++

Routine Description:

    Creates a new subney and a new subney registry object.

Arguments:

    ChildName : name of the subkey being created.

    ChildObj : pointer to a location where the child registry object
        pointer is returned.

    KeyDisposition : pointer to a location where the child KeyDisposition
        value is returned.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    HKEY ChildHandle;

    if (_RegHandle == HKEY_CURRENT_USER && IsInGUIModeSetup())
    {
        return ERROR_ACCESS_DENIED;
    }

    Error = REGCREATEKEYEX(
                _RegHandle,
                ChildName,
                0,
                DEFAULT_CLASS,
                REG_OPTION_NON_VOLATILE,
                DEFAULT_KEY_ACCESS,
                NULL,
                &ChildHandle,
                KeyDisposition );


    if( Error != ERROR_SUCCESS ) {
        *ChildObj = new REGISTRY_OBJ( NULL, Error );
    }
    else {

        if( *KeyDisposition == REG_CREATED_NEW_KEY ) {
#ifndef unix
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%ws) is created.\n", ChildName ));
#else
            TcpsvcsDbgPrint(( DEBUG_REGISTRY,
               "Registry key (%s) is created.\n", ChildName ));
#endif /* unix */
        }

        *ChildObj = new REGISTRY_OBJ( ChildHandle, (DWORD)ERROR_SUCCESS );
    }

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    DWORD *Data
    )
/*++

Routine Description:

    Gets a REG_DWORD value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize = sizeof(DWORD);

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                (LPBYTE)Data,
                &ValueSize );

//    TcpsvcsDbgAssert( ValueSize == sizeof( DWORD ) );
//    TcpsvcsDbgAssert( ValueType == REG_DWORD );

    return( Error );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPTSTR *Data,
    DWORD *NumStrings
    )
/*++

Routine Description:

    Gets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE StringData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert(
        (ValueType == REG_SZ) ||
        (ValueType == REG_EXPAND_SZ) ||
        (ValueType == REG_MULTI_SZ) );

    StringData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( StringData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                StringData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( StringData );
        return( Error );
    }

#ifdef unix
    if (Error == ERROR_SUCCESS) {
       CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)StringData,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           CacheHeap->Free(StringData);
           return (Error);
        }

        CacheHeap->Free(StringData);
        StringData = (LPBYTE)CacheHeap->Alloc( Length );
        if(StringData == NULL){
            return( ERROR_NOT_ENOUGH_MEMORY );
        }
        memcpy(StringData,szExpand,Length+1);
    }
#endif /* unix */

    *Data = (LPTSTR)StringData;

    if( (ValueType == REG_SZ) || (ValueType == REG_EXPAND_SZ) ) {
        *NumStrings = 1;
    }
    else {

        DWORD Strings = 0;
        LPTSTR StrPtr = (LPTSTR)StringData;
        DWORD Len;

        while( (Len = lstrlen(StrPtr)) != 0 ) {
            Strings++;
            StrPtr = StrPtr + Len + 1;
        }

        *NumStrings = Strings;
    }

    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE *Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;
    DWORD ValueSize;
    LPBYTE BinaryData = NULL;

    Error = GetValueSizeAndType( ValueName, &ValueSize, &ValueType );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueType == REG_BINARY );

    BinaryData = (LPBYTE)CacheHeap->Alloc( ValueSize );

    if( BinaryData == NULL ) {
        return( ERROR_NOT_ENOUGH_MEMORY );
    }

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                BinaryData,
                &ValueSize );

    if( Error != ERROR_SUCCESS ) {
        CacheHeap->Free( BinaryData );
        return( Error );
    }

    *Data = BinaryData;
    *DataLen = ValueSize;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::GetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Gets a REG_BINARY value.

Arguments:

    ValueName : name of the value being retrived.

    Data : pointer to a buffer where the data will be read.

    Datalen : pointer to location where length of the above buffer is
        passed. On return this location will have the length of the
        data read.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueType;

    Error = RegQueryValueEx(
                _RegHandle,
                ValueName,
                0,
                &ValueType,
                Data,
                DataLen );

#ifdef unix
    {
    CHAR szExpand[MAX_PATH+1];
        DWORD Length = ExpandEnvironmentStrings((LPTSTR)Data,
                                                (LPTSTR)szExpand,
                                                MAX_PATH);
       if (Length == 0 || Length > MAX_PATH) {
           Error = GetLastError();
           return (Error);
        }
        memcpy(Data,szExpand,Length+1);
    }
#endif /* unix */
    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPDWORD Data
    )
/*++

Routine Description:

    Sets a REG_DWORD value.

Arguments:

    ValueName : name of the value being set.

    Date : pointer to a DWORD data.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_DWORD,
                (LPBYTE)Data,
                sizeof(DWORD) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPTSTR Data,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    UNIX_NORMALIZE_IF_CACHE_PATH((LPTSTR)Data,TEXT("%USERPROFILE%"),ValueName);

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                sizeof(TCHAR) * (lstrlen(Data) + 1) );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPSTR ValueName,
    LPSTR Data,
    DWORD DataLen,
    DWORD StringType
    )
/*++

Routine Description:

    Sets a REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ value.

    Data : pointer to STRING(s) data.

    DataLen : data length

    StringType : type of string data in the above buffer, it should be
        either of the following types :
            REG_SZ or REG_EXPAND_SZ or REG_MULTI_SZ

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                StringType,
                (LPBYTE)Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::SetValue(
    LPTSTR ValueName,
    LPBYTE Data,
    DWORD DataLen
    )
/*++

Routine Description:

    Sets a REG_BINARY value.

Arguments:

    ValueName : name of the value being set.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;

    Error = RegSetValueEx(
                _RegHandle,
                ValueName,
                0,
                REG_BINARY,
                Data,
                DataLen );

    return( Error );
}

DWORD
REGISTRY_OBJ::FindNextKey(
    LPTSTR Key,
    DWORD KeySize
    )
/*++

Routine Description:

    Retrieves the Next subkey name of this key.

Arguments:

    Key - pointer to a buffer that receives the subkey name.

    KeySize - size of the above buffer in CHARS.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD KeyLength;
    FILETIME KeyLastWrite;

    KeyLength = KeySize * sizeof(TCHAR);
    Error = RegEnumKeyEx(
                _RegHandle,
                _Index,
                Key,
                &KeyLength,
                0,                  // reserved.
                NULL,               // class string not required.
                0,                  // class string buffer size.
                &KeyLastWrite );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( KeyLength <= KeySize );

    //
    // increament the index to point to the next key.
    //

    _Index++;
    return( ERROR_SUCCESS );
}

DWORD
REGISTRY_OBJ::DeleteKey(
    LPTSTR ChildKeyName
    )
/*++

Routine Description:

    Deletes a subkey node.

Arguments:

    ChildKeyName : name of the subkey to be deleted.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    LPTSTR GChildKeyName[MAX_KEY_SIZE];
    REGISTRY_OBJ ChildObj( _RegHandle, ChildKeyName );

    Error = ChildObj.GetStatus();

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    //
    // delete all its subkeys.
    //

    Error = ChildObj.FindFirstKey(
                (LPTSTR)GChildKeyName,
                MAX_KEY_SIZE );

    while( Error == ERROR_SUCCESS ) {

        Error = ChildObj.DeleteKey( (LPTSTR)GChildKeyName );

        if( Error != ERROR_SUCCESS ) {
            return( Error );
        }

        Error = ChildObj.FindFirstKey(
                    (LPTSTR)GChildKeyName,
                    MAX_KEY_SIZE );
    }

    if( Error != ERROR_NO_MORE_ITEMS ) {
        return( Error );
    }

    //
    // delete this key.
    //

    Error = RegDeleteKey( _RegHandle, (LPTSTR)ChildKeyName );
    return( Error );
}

DWORD
REGISTRY_OBJ::DeleteValue(
    LPTSTR ValueName
    )
{
    DWORD Error;
    Error = RegDeleteValue(
                _RegHandle,
                ValueName
                );


    return( Error );
}


DWORD
REGISTRY_OBJ::FindNextValue(
    LPSTR ValueName,
    DWORD ValueSize,
    LPBYTE Data,
    DWORD *DataLen
    )
/*++

Routine Description:

    Retrieves the Next value name of this key.

Arguments:

    ValueName - pointer to a buffer that receives the Value name.

    ValueSize - size of the above buffer in CHARS.
    Data - pointer to a buffer that receives the Value data.
    DataLen - pointer to a buffer that receives data size.

Return Value:

    Windows Error Code.

--*/
{
    DWORD Error;
    DWORD ValueLength;
    DWORD ValueType;

    ValueLength = ValueSize * sizeof(CHAR);

    Error = RegEnumValue(
                _RegHandle,
                _ValIndex,
                ValueName,
                &ValueLength,
                NULL,                  // reserved.
                &ValueType,
                Data,
                DataLen );

    if( Error != ERROR_SUCCESS ) {
        return( Error );
    }

    TcpsvcsDbgAssert( ValueLength <= ValueSize );

    //
    // increment the value index to point to the next value.
    //

    _ValIndex++;
    return( ERROR_SUCCESS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\instcon.cxx ===
/*++
Copyright (c) 1997  Microsoft Corporation

Module Name:  instcon.cxx

Abstract:

    Installed container class derived from URL_CONTAINER
    
Author:
    Adriaan Canter (adriaanc) 04-10-97
    
--*/

#include <cache.hxx>

#define HTTP_OK "HTTP/1.0 200 OK\r\n\r\n"



/*--------------------- CInstCon Public Functions-----------------------------*/


/*-----------------------------------------------------------------------------
    CInstCon::CInstCon
-----------------------------------------------------------------------------*/
CInstCon::CInstCon(LPSTR CacheName, LPSTR VolumeLabel, LPSTR VolumeTitle,
                   LPSTR CachePath, LPSTR CachePrefix, LPSTR PrefixMap, 
                   LONGLONG CacheLimit, DWORD dwOptions)

    : URL_CONTAINER(CacheName, CachePath, CachePrefix, CacheLimit, dwOptions)
{
    if (_Status != ERROR_SUCCESS)
    {
        INET_ASSERT(FALSE);
        return;
    }
        
    _szVolumeLabel = NewString(VolumeLabel);
    _szVolumeTitle = NewString(VolumeTitle);
    _szPrefixMap   = NewString(PrefixMap);    
    
    if (!(_szVolumeLabel && _szVolumeTitle && _szPrefixMap))
    {
        INET_ASSERT(FALSE);
        _Status = ERROR_NOT_ENOUGH_MEMORY;
        return;
    }

    _cbPrefixMap = strlen(PrefixMap);
    _cbMaxFileSize = MAX_FILE_SIZE_TO_MIGRATE;
    _Status = ERROR_SUCCESS;
}

/*-----------------------------------------------------------------------------
    CInstCon::~CInstCon
-----------------------------------------------------------------------------*/
CInstCon::~CInstCon()
{
    delete _szPrefixMap;
    delete _szVolumeLabel;
    delete _szVolumeTitle;
}


/*------------------ URL_CONTAINER virtual overrides-------------------------*/

/*-----------------------------------------------------------------------------
    CInstCon::GetPrefixMap
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetPrefixMap()
{
    return _szPrefixMap;
}

/*-----------------------------------------------------------------------------
    CInstCon::GetVolumeLabel
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetVolumeLabel()
{
    return _szVolumeLabel;
}

/*-----------------------------------------------------------------------------
    CInstCon::GetVolumeTitle
-----------------------------------------------------------------------------*/
LPSTR CInstCon::GetVolumeTitle()
{
    return _szVolumeTitle;
}


/*-----------------------------------------------------------------------------
    CInstCon::AddUrl
-----------------------------------------------------------------------------*/
DWORD CInstCon::AddUrl (AddUrlArg* pArgs)
{
    pArgs->dwEntryType |= INSTALLED_CACHE_ENTRY;
    return URL_CONTAINER::AddUrl(pArgs);
}


/*-----------------------------------------------------------------------------
    CInstCon::RetrieveUrl
-----------------------------------------------------------------------------*/
DWORD CInstCon::RetrieveUrl(LPCSTR  UrlName, LPCACHE_ENTRY_INFO EntryInfo, 
                            LPDWORD EntryInfoSize, DWORD dwLookupFlags, 
                            DWORD dwRetrievalFlags)    
{
    DWORD dwError;
    BOOL fMustUnlock;

    INET_ASSERT(EntryInfo && EntryInfoSize);

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }

    dwError = GetEntry(UrlName, EntryInfo, EntryInfoSize, dwLookupFlags);

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}



/*-----------------------------------------------------------------------------
    CInstCon::GetUrlInfo
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetUrlInfo(LPCSTR  szUrlName, LPCACHE_ENTRY_INFO pei, 
                           LPDWORD pcbei, DWORD dwLookupFlags, DWORD dwEntryFlags)    
{
    DWORD dwError;
    DWORD cbeiTemp = 0x256;
    BYTE bTemp[0x256];
    BOOL fMustUnlock;

    if (!LockContainer(&fMustUnlock))
    {
        dwError = GetLastError();
        goto exit;
    }

    // Zero buffer case.
    if (pei && pcbei)
    {
        dwError = GetEntry(szUrlName, pei, pcbei, dwLookupFlags);
        goto exit;
    }

    // Zero buffer case.
    if (dwEntryFlags & INTERNET_CACHE_FLAG_ENTRY_OR_MAPPING)
    {
        // Return success to indicate that a mapping exists. 
        // We wouldn't have gotten here otherwise.
        dwError = ERROR_SUCCESS;
    }
    else
    {
        // Otherwise, no flag passed in. Only return
        // success if the entry has been successfully found.
        dwError = GetEntry(szUrlName, (LPCACHE_ENTRY_INFO) bTemp, 
            &cbeiTemp, dwLookupFlags);
    }

exit:
    if (fMustUnlock) UnlockContainer();
    return dwError;
}
    

/*--------------------- CInstCon Private Functions-----------------------------*/



/*-----------------------------------------------------------------------------
    CInstCon::GetEntry
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetEntry(LPCSTR  UrlName, LPCACHE_ENTRY_INFO EntryInfo, 
                         LPDWORD EntryInfoSize, DWORD dwLookupFlags)
{    
    INT cbOld, cbNew, cbDiff;
    DWORD cbOriginalInfoSize = *EntryInfoSize;
    DWORD dwError = ERROR_SUCCESS, dwCDStatus;

    DWORD cb;
    LPSTR ptr;
        

    // Try to get it from the CD.
    dwCDStatus = GetEntryFromCD(UrlName, EntryInfo, EntryInfoSize);

    switch(dwCDStatus)
    {
        // Couldn't find it on the CD.
        case ERROR_FILE_NOT_FOUND:
        case ERROR_PATH_NOT_FOUND:
 
            // Not on CD. Look in memory mapped file.
            dwError = URL_CONTAINER::RetrieveUrl(UrlName, (EntryInfo ? &EntryInfo : NULL), 
                                                 EntryInfoSize, dwLookupFlags,
                                                 RETRIEVE_WITH_CHECKS);
            break;
        
        // CD not in drive.        
        case ERROR_INVALID_DRIVE:
        case ERROR_NOT_READY:
        case ERROR_WRONG_DISK:
                
            dwError = ERROR_INTERNET_INSERT_CDROM;
            break;

        // Found it on the CD.
        case ERROR_SUCCESS:

            dwError = ERROR_SUCCESS;
            break;

        default:

            // Some other error.
            dwError = ERROR_INTERNET_INTERNAL_ERROR;
    }            

    return dwError;
}
    



/*-----------------------------------------------------------------------------
    CInstCon::MapUrlToAbsPath
-----------------------------------------------------------------------------*/
VOID CInstCon::MapUrlToAbsPath(LPSTR UrlName, 
                               LPSTR szAbsPath, LPDWORD pcbAbsPath)
{
    // Construct the absolute path to the file.
    memcpy(szAbsPath, _szPrefixMap, _cbPrefixMap + 1);

    LPSTR ptr = UrlName + _CachePrefixLen;
    DWORD cbSuffix = strlen(ptr);
 
    *pcbAbsPath = _cbPrefixMap + cbSuffix;
    memcpy(szAbsPath + _cbPrefixMap, ptr, cbSuffix + 1);
    
    // Convert all forward slashes to back slashes,
    // including any that were inadvertently placed
    // in the prefix map. This path might be returned 
    // to the caller.
    ptr = szAbsPath;
    while (*ptr++)
    {
#ifndef unix
        if (*ptr == '/')
            *ptr = '\\';
#else
        if (*ptr == '\\')
            *ptr = '/';
#endif /* unix */
    }

    // Unescape - final length may be less than
    // pcbAbsPath, but is always null terminated.
    UrlUnescapeInPlace(szAbsPath, NULL);
}


/*-----------------------------------------------------------------------------
    CInstCon::GetEntryFromCD
-----------------------------------------------------------------------------*/
DWORD CInstCon::GetEntryFromCD(LPCSTR UrlName, 
                               LPCACHE_ENTRY_INFO EntryInfo, 
                               LPDWORD EntryInfoSize)
{
    LPBYTE pb;
    CHAR szAbsPath[MAX_PATH], *ptr;
  
    DWORD cbUrl, cbSuffix, cbAbsPath, cbSizeRequired, cbExt, i,
          dwError = ERROR_SUCCESS;

    LONGLONG llZero        = (LONGLONG) 0;
    WIN32_FILE_ATTRIBUTE_DATA FileAttributes;

    CHAR szVolumeLabel[MAX_PATH];

    CHAR szVolRoot[4];
    memcpy(szVolRoot, _szPrefixMap, 2);
    memcpy(szVolRoot + 2, DIR_SEPARATOR_STRING, sizeof(DIR_SEPARATOR_STRING));
    // First check that the correct CD is inserted.
    if (GetVolumeInformation(szVolRoot, szVolumeLabel, MAX_PATH, 
                             NULL, NULL, NULL, NULL, 0))
    {
        if (strcmp(_szVolumeLabel, szVolumeLabel))
        {
            dwError = ERROR_WRONG_DISK;
            goto exit;
        }
    }
    else
    {
        dwError = ERROR_INVALID_DRIVE;
        goto exit;
    }

    // ---- Find the file and file info from the url -----


    cbUrl = strlen(UrlName);

    // Formulate path to file.
    MapUrlToAbsPath((LPSTR) UrlName, szAbsPath, &cbAbsPath);

    // Determine required CACHE_ENTRY_INFO buffer size.
    cbSizeRequired = sizeof(CACHE_ENTRY_INFO)
        + cbUrl + 1 + cbAbsPath + 1 + MAX_EXTENSION_LEN + 1 + sizeof(HTTP_OK);
    if (cbSizeRequired > *EntryInfoSize)
    {
        dwError = ERROR_INSUFFICIENT_BUFFER;
        goto exit;
    }
    
    // Get the file information. Shouldn't be a directory.
    dwError = GetFileSizeAndTimeByName(szAbsPath, &FileAttributes);
    if (dwError != ERROR_SUCCESS)
    {
        if (FileAttributes.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            dwError = ERROR_FILE_NOT_FOUND;
        }
        goto exit;
    }


    // ---- Assemble the CACHE_ENTRY_INFO structure to return ----   
    
    
    // Urlname.
    pb = (LPBYTE) EntryInfo + sizeof(CACHE_ENTRY_INFO);
    memcpy(pb, UrlName, cbUrl + 1);
    EntryInfo->lpszSourceUrlName = (LPSTR) pb;
    
    // Filename.
    pb += cbUrl + 1;
    strcpy((LPSTR) pb, szAbsPath);
    EntryInfo->lpszLocalFileName = (LPSTR) pb;
    
    // Header.
    pb += cbAbsPath + 1;
    memcpy(pb, HTTP_OK, sizeof(HTTP_OK));
    EntryInfo->lpHeaderInfo = (LPSTR)pb;    
        
    // File extension
    cbExt = 0;
    ptr = (LPSTR) UrlName + cbUrl;
    for (i = 0; i < MAX_EXTENSION_LEN+1; i++)
    {
        if (*(--ptr) == '.')
        {            
            cbExt = i+1;
            break;
        }
    }
    if (cbExt)
    {
        pb += sizeof(HTTP_OK);
        memcpy(pb, ptr+1, cbExt + 1);
        EntryInfo->lpszFileExtension = (LPSTR) pb;    
    }
    else
        EntryInfo->lpszFileExtension = NULL;

    pb += cbExt +1;

    INET_ASSERT((DWORD) ((LPCACHE_ENTRY_INFO) pb - EntryInfo) < cbSizeRequired);
    
    // Version , type, count, hit rate, file size.
    EntryInfo->dwStructSize = URL_CACHE_VERSION_NUM;
    EntryInfo->CacheEntryType = INSTALLED_CACHE_ENTRY;
    EntryInfo->dwUseCount = 0;
    EntryInfo->dwHitRate = 0;
    EntryInfo->dwSizeHigh = FileAttributes.nFileSizeHigh;
    EntryInfo->dwSizeLow = FileAttributes.nFileSizeLow;    

    // Times: modified, expired, accessed, synced.
    EntryInfo->LastModifiedTime = FileAttributes.ftCreationTime;
    EntryInfo->ExpireTime = *(FILETIME*) &llZero;

    // BUGBUG - getcurrent time for both.
    EntryInfo->LastAccessTime = FileAttributes.ftLastAccessTime;
    EntryInfo->LastSyncTime = *(FILETIME*) &llZero;

    // Header size, file extension, exempt delta.
    EntryInfo->dwHeaderInfoSize = sizeof(HTTP_OK);
    EntryInfo->dwExemptDelta = 0;
    
    // Buffer consumed.
    *EntryInfoSize = cbSizeRequired - sizeof(CACHE_ENTRY_INFO);


exit:
    return dwError;
}

/*-----------------------------------------------------------------------------
    CInstCon::AddEntryToIndex
-----------------------------------------------------------------------------*/
DWORD CInstCon::AddEntryToIndex(LPCACHE_ENTRY_INFO EntryInfo, 
                                LPDWORD EntryInfoSize) 
{
    DWORD dwError;
    AddUrlArg args;
    CHAR szFileName[MAX_PATH];

    // Create a local file name for the hard disk.
    *szFileName = '\0';
    dwError = URL_CONTAINER::CreateUniqueFile(EntryInfo->lpszSourceUrlName, 
        NULL, EntryInfo->lpszFileExtension, szFileName, NULL);
    if (dwError != ERROR_SUCCESS)
        goto exit;

    // Copy the file from the CD.
    // CreateUniqueFile has already created a file of 0 bytes.
    if (!CopyFile(EntryInfo->lpszLocalFileName, szFileName, FALSE))
    {
        dwError = ERROR_INTERNET_INTERNAL_ERROR;
        goto exit;
    }

    // Add the entry to the index.

    // Url, filename, file size and extension.
    memset(&args, 0, sizeof(args));
    args.pszUrl = EntryInfo->lpszSourceUrlName;
    args.pszFilePath = szFileName;
    args.dwFileSize = EntryInfo->dwSizeLow;
    args.pszFileExt = EntryInfo->lpszFileExtension;
    args.dwEntryType = EntryInfo->CacheEntryType;    
    // Headers.
    args.pbHeaders = EntryInfo->lpHeaderInfo;
    args.cbHeaders = EntryInfo->dwHeaderInfoSize;

    // Times: last modified and expired.
    args.qwLastMod = FT2LL(EntryInfo->LastModifiedTime);
    args.qwExpires = FT2LL(EntryInfo->ExpireTime);

    // Redirect.    
    args.pszRedirect = NULL;

    args.fImage      = FALSE;
    
    // Add the url to the index.
    dwError = AddUrl(&args);
    if (dwError != ERROR_SUCCESS)
        goto exit;
                   
    // Retrieve the entry from the index. We do this because the EntryInfo
    // structure returned from the CD references the CD filename.
    // PERFPERF - we could optimize this by fixing up the EntryInfo
    // structure to reference the CD filename.
    dwError = URL_CONTAINER::RetrieveUrl(EntryInfo->lpszSourceUrlName, 
        (EntryInfo ? &EntryInfo : NULL), EntryInfoSize, NULL, RETRIEVE_WITH_CHECKS);

exit:
    return dwError;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\util.cxx ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    util.cxx

Abstract:

    Contains the class implementation of UTILITY classes.

Author:

    Madan Appiah (madana)  16-Nov-1994

Environment:

    User Mode - Win32

Revision History:

    Ahsan Kabir (akabir)    24-Nov-1997

--*/


#include <cache.hxx>

typedef BOOL (WINAPI *PFNGETFILEATTREX)(LPCTSTR, GET_FILEEX_INFO_LEVELS, LPVOID);

static char vszDot[] = ".";
static char vszDotDot[] = "..";
#ifdef UNIX
static char vszIndexFile[] = "index.dat";
#endif /* UNIX */

static char vszSHClassInfo[]=".ShellClassInfo";

static char vszCLSIDKey[]="CLSID";
static char vszCLSID[]="{FF393560-C2A7-11CF-BFF4-444553540000}";

static char vszUICLSIDKey[]="UICLSID";
static char vszUICLSID[]="{7BD29E00-76C1-11CF-9DD0-00A0C9034933}";

typedef HRESULT (*PFNSHFLUSHCACHE)(VOID);

#ifdef UNIX
extern void UnixGetValidParentPath(LPTSTR szDevice);
#endif /* UNIX */

/*-----------------------------------------------------------------------------
DeleteOneCachedFile

    Deletes a file belonging to the cache.

Arguments:

    lpszFileName: Fully qualified filename

Return Value:

    TRUE if successful. If FALSE, GetLastError() returns the error code.

Comments:

  ---------------------------------------------------------------------------*/
BOOL
DeleteOneCachedFile(
    LPSTR   lpszFileName,
    DWORD   dostEntry)
{

    if (dostEntry)
    {
        DWORD dostCreate = 0;
        LPWORD pwCreate = (LPWORD) &dostCreate;
        WIN32_FILE_ATTRIBUTE_DATA FileAttrData;

        switch (GetFileSizeAndTimeByName(lpszFileName, &FileAttrData))
        {
            case ERROR_SUCCESS:
                break;
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }                    
    
        FileTimeToDosDateTime(&FileAttrData.ftCreationTime, pwCreate, pwCreate+1);

        if (dostCreate != dostEntry)
           return TRUE; // not our file, so consider it done!
    }


    if(!DeleteFile(lpszFileName))
    {
        TcpsvcsDbgPrint (( DEBUG_ERRORS, "DeleteFile failed on %s, Error=%ld\n",
            lpszFileName, GetLastError()));

        switch (GetLastError())
        {
            case ERROR_FILE_NOT_FOUND:
            case ERROR_PATH_NOT_FOUND:
                return TRUE;
            default:
                return FALSE;
        }
    }
    else
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS, "Deleted %s\n", lpszFileName ));
        return TRUE;
    }
}


/*-----------------------------------------------------------------------------
DeleteCachedFilesInDir
  ---------------------------------------------------------------------------*/
DWORD DeleteCachedFilesInDir(
    LPSTR   lpszPath,
    DWORD   dwLevel
    )
{
    TCHAR PathFiles[MAX_PATH+1];
    TCHAR FullFileName[MAX_PATH+1];
    LPTSTR FullFileNamePtr;
    WIN32_FIND_DATA FindData;

    HANDLE FindHandle = INVALID_HANDLE_VALUE;

    // Since this has become a recursive call, we don't want to go more than 6 levels.
    if (dwLevel>5)
    {
        INET_ASSERT(FALSE);
        return ERROR_INVALID_PARAMETER;
    }
    
    DWORD Error, len, cbUsed;
    BOOL fFindSuccess;

    DWORD cb = strlen(lpszPath);
    memcpy(PathFiles, lpszPath, cb + 1);

    if(!AppendSlashIfNecessary(PathFiles, &cb)) 
    {
        Error = ERROR_INVALID_NAME;
        goto Cleanup;
    }

    memcpy(FullFileName, PathFiles, cb + 1);
    memcpy(PathFiles + cb, ALLFILES_WILDCARD_STRING, sizeof(ALLFILES_WILDCARD_STRING));

    FullFileNamePtr = FullFileName + lstrlen( (LPTSTR)FullFileName );

    if ( IsValidCacheSubDir( lpszPath))
        DisableCacheVu( lpszPath);

    FindHandle = FindFirstFile( (LPTSTR)PathFiles, &FindData );

    if( FindHandle == INVALID_HANDLE_VALUE ) 
    {
        Error = GetLastError();
        goto Cleanup;
    }

    cbUsed = (unsigned int)(FullFileNamePtr-FullFileName);
    FullFileName[MAX_PATH] = '\0';
    do
    {
        cb = strlen(FindData.cFileName);
        if (cb+cbUsed+1 > MAX_PATH)
        {
            // Subtracting 1 extra so that the null terminator doesn't get overwritten
            cb = MAX_PATH - cbUsed - 2;
        }
        memcpy(FullFileNamePtr, FindData.cFileName, cb+1);

#ifndef UNIX
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#else
        if (!(!strnicmp(FindData.cFileName, vszDot, sizeof(vszDot)-1) ||
            !strnicmp(FindData.cFileName, vszIndexFile, sizeof(vszIndexFile)-1) || 
            !strnicmp(FindData.cFileName, vszDotDot, sizeof(vszDotDot)-1))) 
#endif /* UNIX */
        {
            if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                Error = DeleteCachedFilesInDir(FullFileName, dwLevel + 1);
                if (Error!=ERROR_SUCCESS)
                {
                    goto Cleanup;
                }
                SetFileAttributes(FullFileName, FILE_ATTRIBUTE_DIRECTORY);
                RemoveDirectory(FullFileName);
            }
            else
            {
                DeleteOneCachedFile( (LPTSTR)FullFileName, 0);
            }
        }

        //
        // find next file.
        //

    } while (FindNextFile( FindHandle, &FindData ));

    Error = GetLastError();
    if( Error == ERROR_NO_MORE_FILES) 
    {
        Error = ERROR_SUCCESS;
    }

Cleanup:

    if( FindHandle != INVALID_HANDLE_VALUE ) 
    {
        FindClose( FindHandle );
    }

    if( Error != ERROR_SUCCESS ) 
    {
        TcpsvcsDbgPrint(( DEBUG_ERRORS,
            "DeleteCachedFilesInDir failed, %ld.\n",
                Error ));
    }

    return( Error );
}


/*-----------------------------------------------------------------------------
AppendSlashIfNecessary
  ---------------------------------------------------------------------------*/
BOOL AppendSlashIfNecessary(LPSTR szPath, DWORD* pcbPath)
{
    if (*pcbPath > (MAX_PATH-2)) 
        return FALSE;
    if (szPath[*pcbPath-1] != DIR_SEPARATOR_CHAR)
    {
        szPath[*pcbPath] = DIR_SEPARATOR_CHAR;
        (*pcbPath)++;
        szPath[*pcbPath] = '\0';
    }
    return TRUE;
}


/*-----------------------------------------------------------------------------
EnableCachevu
  ---------------------------------------------------------------------------*/
BOOL EnableCacheVu(LPSTR szPath, DWORD dwContainer)
{       
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];
    DWORD dwFileAttributes;

    HMODULE hInstShell32 = 0;
    PFNSHFLUSHCACHE pfnShFlushCache = NULL;

#define DESIRED_ATTR (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM)

    // Calls with non-existant directory allowed and return false.
    dwFileAttributes = GetFileAttributes(szPath);
    if (dwFileAttributes == 0xFFFFFFFF)
        return FALSE;
    
    // Always be set to enable cachevu.
    SetFileAttributes(szPath, FILE_ATTRIBUTE_SYSTEM);
    
    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    if (dwFileAttributes == 0xFFFFFFFF)
    {
        dwFileAttributes = 0;

        // Always write out the UICLSID
        WritePrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  vszUICLSID,  szDesktopIni);    

        // HISTORY requires an additional CLSID.
        if (dwContainer == HISTORY)
            WritePrivateProfileString(vszSHClassInfo,  vszCLSIDKey,  vszCLSID,  szDesktopIni);    

        // Flush buffer - problems on Win95 if you don't.
        WritePrivateProfileString(NULL, NULL, NULL,  szDesktopIni);
    }

    if ((dwFileAttributes & DESIRED_ATTR) != DESIRED_ATTR)
    {
        // Should be hidden, read-only and system for cachevu to work correctly.
        SetFileAttributes(szDesktopIni, DESIRED_ATTR);
    }
/*
    BUGBUG - taking this code out for raid # 45710.
    // We now need to notify the shell that a new desktop.ini has been created.
    hInstShell32 = GetModuleHandle("shell32.dll");
    if (hInstShell32)
    {    
        pfnShFlushCache = (PFNSHFLUSHCACHE) GetProcAddress(hInstShell32, (LPSTR) 526);
        if (pfnShFlushCache)
        {
            __try
            {
                (*pfnShFlushCache)();
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
            }
            ENDEXCEPT
        }
    }
*/
    return TRUE;

}

/*-----------------------------------------------------------------------------
IsValidCacheSubDir
  ---------------------------------------------------------------------------*/
BOOL IsValidCacheSubDir(LPSTR szPath)
{
    DWORD dwFileAttributes, cb, cbPath;
    CHAR szDesktopIni[MAX_PATH];
    CHAR szCLSID     [MAX_PATH];
    CHAR szWindowsDir[MAX_PATH];
    CHAR szSystemDir [MAX_PATH];

    cbPath = strlen(szPath);
            
    // Root, Windows or System directories
    // are decidedly not cache subdirectories.
    cb = GetWindowsDirectory(szWindowsDir, MAX_PATH);
    if (!cb || cb>MAX_PATH)
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }
    AppendSlashIfNecessary(szWindowsDir, &cb);

    cb = GetSystemDirectory(szSystemDir, MAX_PATH);
    AppendSlashIfNecessary(szSystemDir, &cb);

    if (cbPath < 4 
        || !strnicmp(szPath, szWindowsDir, cbPath)
        || !strnicmp(szPath, szSystemDir, cbPath))
    {
        INET_ASSERT(FALSE);
        return FALSE;
    }

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
    
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));

    // Check for existing desktop.ini
    dwFileAttributes = GetFileAttributes(szDesktopIni);

    // No desktop.ini found or system attribute not set.
    if (dwFileAttributes == 0xFFFFFFFF)
    {
        return FALSE;
    }

    // Found UICLSID (CONTENT cachevu) ?
    if (GetPrivateProfileString(vszSHClassInfo,  vszUICLSIDKey,  
                                "", szCLSID, MAX_PATH, szDesktopIni)
        && !strcmp(szCLSID, vszUICLSID)) 
    {
        return TRUE;
    }

    return FALSE;
}


/*-----------------------------------------------------------------------------
DisableCachevu
  ---------------------------------------------------------------------------*/
BOOL DisableCacheVu(LPSTR szPath)
{
    DWORD cbPath = strlen(szPath);
    CHAR szDesktopIni[MAX_PATH];

    // Path to DESKTOP_INI_FILENAME
    memcpy(szDesktopIni, szPath, cbPath + 1);           
    AppendSlashIfNecessary(szDesktopIni, &cbPath);
            
    // Correct location for desktop.ini.
    memcpy(szDesktopIni + cbPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    SetFileAttributes(szDesktopIni, FILE_ATTRIBUTE_NORMAL);
    DeleteFile(szDesktopIni);
    return TRUE;
}

/*-----------------------------------------------------------------------------
StripTrailingWhiteSpace
  ---------------------------------------------------------------------------*/
VOID StripTrailingWhiteSpace(LPSTR szString, LPDWORD pcb)
{
    INET_ASSERT(szString);

    if (*pcb == 0)
        return;

    CHAR* ptr = szString + *pcb - 1;

    while (*ptr == ' ')
    {
        ptr--;
        if (--(*pcb) == 0)
            break;
    }
    *(ptr+1) = '\0';
}


/* PerformOperationOverUrlCache-----------------------

The purpose of this function is to iterate through the content cache and perform the same action (here, called
an operation) on each entry in the cache.

This function takes all the parameters that FindFirstUrlCacheEntryEx accepts, 
plus two more:

op              -- This is of type CACHE_OPERATOR, discussed below
pOperatorData   -- a pointer to an array of data that the calling process and op use to collect/maintain info
 */

/* CACHE_OPERATOR
    is a pointer to function, that takes three arguments(pointer to a cache entry, cache entry size, and a pointer to 
    state data.

    The operator can perform whatever operation (move/copy/data collection) it wishes on the supplied cache entry.
    It must return TRUE if the operation has succeeded and PerformOperationOverUrlCache can continue to iterate through
    the cache, FALSE otherwise.

    pOpData can be null, or a cast pointer to whatever structure the operator will use to maintain state information.
        
    PerformOperationOverUrlCache guarantees that each cache entry will have sufficient space for its information.
*/ 

typedef BOOL (*CACHE_OPERATOR)(INTERNET_CACHE_ENTRY_INFO* pcei, PDWORD pcbcei, PVOID pOpData);


// hAdjustMemory is a helper function
// that ensures that the buffer used by PerformOperationOverUrlCache
// is large enough to hold all of a cache entry's info

BOOL hAdjustMemory(LPINTERNET_CACHE_ENTRY_INFO* pbBuffer, PDWORD pcbAvail, PDWORD pcbNeeded)
{
    if (*pbBuffer)
    {
        FREE_MEMORY(*pbBuffer);
    }
    do
    {
        *pcbAvail += 1024;
    } 
    while (*pcbAvail < *pcbNeeded);
    *pcbNeeded = *pcbAvail;
    *pbBuffer = (LPINTERNET_CACHE_ENTRY_INFO)ALLOCATE_FIXED_MEMORY(*pcbAvail);
    return (*pbBuffer!=NULL);
}


// PerformOperationOverUrlCache
// described above
// uses FindFirstUrlCacheEntryEx and FindNext as any other wininet client would.
// and passes a complete cache entry to the operator for processing

BOOL PerformOperationOverUrlCacheA(
    IN     PCSTR     pszUrlSearchPattern,
    IN     DWORD     dwFlags,
    IN     DWORD     dwFilter,
    IN     GROUPID   GroupId,
    OUT    PVOID     pReserved1,
    IN OUT PDWORD    pdwReserved2,
    IN     PVOID     pReserved3,
    IN       CACHE_OPERATOR op, 
    IN OUT PVOID     pOperatorData
    )
{
    BOOL fResult = FALSE;

    DWORD cbAvail = sizeof(INTERNET_CACHE_ENTRY_INFO) + 1024;
    DWORD cbCEI = cbAvail;
    LPINTERNET_CACHE_ENTRY_INFO pCEI = (LPINTERNET_CACHE_ENTRY_INFO) ALLOCATE_FIXED_MEMORY(cbAvail);
    HANDLE hFind = NULL;

    if (pCEI == NULL)
        goto Cleanup;

    hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    if (!hFind && (GetLastError()!=ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(&pCEI, &cbAvail, &cbCEI))
    {
        hFind = FindFirstUrlCacheEntryEx(pszUrlSearchPattern, 
                                    dwFlags,
                                    dwFilter,
                                    GroupId,
                                    pCEI, 
                                    &cbCEI,
                                    pReserved1,
                                    pdwReserved2,
                                    pReserved3);
    }

    if (hFind!=NULL)
    {
        do
        {
            fResult = op(pCEI, &cbCEI, pOperatorData);
            if (fResult)
            {
                cbCEI = cbAvail;
                fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                if (!fResult && (GetLastError()==ERROR_INSUFFICIENT_BUFFER) && hAdjustMemory(&pCEI, &cbAvail, &cbCEI))
                {
                    fResult = FindNextUrlCacheEntryEx(hFind, pCEI, &cbCEI, NULL, NULL, NULL);
                }
            } 
        }
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = TRUE;
        } 
    }

Cleanup:
    if (pCEI)
    {
        FREE_MEMORY(pCEI);
    }
    return fResult;
}

// ------ MoveCachedFiles ---------------------------------------------------------------------------------------
// Purpose: Moves as many files as possible from the current Temporary Internet Files to the new location


// State information required for the move operation
struct MOVE_OP_STATE
{
    TCHAR szNewPath[MAX_PATH];
    TCHAR szOldPath[MAX_PATH];
    DWORD ccNewPath;
    DWORD ccOldPath;
    DWORDLONG dlCacheSize;
    DWORD dwClusterSizeMinusOne;
    DWORD dwClusterSizeMask;
};

// Helper function that, 
// given a string pointer, 
// returns the next occurrence of DIR_SEPARATOR_CHAR ('/' || '\\')
PTSTR hScanPastSeparator(PTSTR pszPath)
{
    while (*pszPath && *pszPath!=DIR_SEPARATOR_CHAR)
    {
        pszPath++;
    }
    if (*pszPath)
    {
        return pszPath+1;
    }
    return NULL;
}

// Helper function that,
// given a path,
// ensures that all the directories in the path exist
BOOL hConstructSubDirs(PTSTR pszBase)
{
    PTSTR pszLast = hScanPastSeparator(pszBase);

    if (NULL == pszLast)
        return TRUE;    // returning TRUE on purpose

    PTSTR pszNext = pszLast;
    while ((pszNext=hScanPastSeparator(pszNext))!=NULL)
    {
        *(pszNext-1) = '\0';
        CreateDirectory(pszBase, NULL);
        *(pszNext-1) = DIR_SEPARATOR_CHAR;
        pszLast = pszNext;
    }
    return TRUE;
}

// MoveOperation
// actually moves a cached file to the new location

BOOL MoveOperation(LPINTERNET_CACHE_ENTRY_INFO pCEI, PDWORD pcbCEI, PVOID pOpData)
{
    MOVE_OP_STATE* pmos = (MOVE_OP_STATE*)pOpData;
    BOOL fResult = TRUE;

    if (pCEI->lpszLocalFileName)
    {
        if (!strnicmp(pCEI->lpszLocalFileName, pmos->szOldPath, pmos->ccOldPath))
        {
            // Copy the file
            lstrcpy(pmos->szNewPath + pmos->ccNewPath, pCEI->lpszLocalFileName + pmos->ccOldPath);        
            fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
            if (!fResult && GetLastError()==ERROR_PATH_NOT_FOUND)
            {
                if (hConstructSubDirs(pmos->szNewPath))
                {
                    fResult = CopyFile(pCEI->lpszLocalFileName, pmos->szNewPath, FALSE);
                }
            }
            // If the move was successful, we need to adjust the size of the new cache
            if (fResult)
            {
                fResult = FALSE;
                
                HANDLE h1 = CreateFile(pCEI->lpszLocalFileName, 
                                      GENERIC_READ,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);

                // If we can't open the original file, then the new file will never
                // get scavenged because we'll never be able to match creation times
                if (h1!=INVALID_HANDLE_VALUE)
                {
                    HANDLE h2 = CreateFile(pmos->szNewPath, 
                                      GENERIC_WRITE,
                                      0,
                                      NULL,
                                      OPEN_EXISTING,
                                      FILE_ATTRIBUTE_NORMAL,
                                      NULL);
                    if (h2!=INVALID_HANDLE_VALUE)
                    {
                        FILETIME ft;
                        if (GetFileTime(h1, &ft, NULL, NULL))
                        {
                            fResult = SetFileTime(h2, &ft, NULL, NULL);
                        }
                        CloseHandle(h2);
                    }
                    CloseHandle(h1);
                }
            }

            // If we haven't been able to set the create time, then we've got a problem
            // we'd sooner not deal with.
            if (!fResult)
            {
                DeleteUrlCacheEntry(pCEI->lpszSourceUrlName);
                DeleteFile(pmos->szNewPath);
            }
            else
            {
                pmos->dlCacheSize += ((LONGLONG) (pCEI->dwSizeLow + pmos->dwClusterSizeMinusOne) 
                                        & pmos->dwClusterSizeMask);
            }

            // Delete the old one
            DeleteFile(pCEI->lpszLocalFileName);
        }
    }
    return TRUE;
}


DWORD
MoveCachedFiles(
    LPSTR     pszOldPath,
    LPSTR     pszNewPath
)
{
    MOVE_OP_STATE mos;
    INET_ASSERT(pszOldPath && pszNewPath);

    mos.ccNewPath = lstrlen(pszNewPath);
    memcpy(mos.szNewPath, pszNewPath, mos.ccNewPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);
    memcpy(mos.szNewPath + mos.ccNewPath, CONTENT_VERSION_SUBDIR, sizeof(CONTENT_VERSION_SUBDIR));
    mos.ccNewPath += sizeof(CONTENT_VERSION_SUBDIR)-1;
    AppendSlashIfNecessary(mos.szNewPath, &mos.ccNewPath);

    mos.ccOldPath = lstrlen(pszOldPath);
    memcpy(mos.szOldPath, pszOldPath, mos.ccOldPath*sizeof(TCHAR));
    AppendSlashIfNecessary(mos.szOldPath, &mos.ccOldPath);

    mos.dlCacheSize = 0;
    GetDiskInfo(mos.szNewPath, &mos.dwClusterSizeMinusOne, NULL, NULL);
    mos.dwClusterSizeMinusOne--;
    mos.dwClusterSizeMask = ~mos.dwClusterSizeMinusOne;
    
    GlobalUrlContainers->WalkLeakList(CONTENT);

    // We don't need to get all the information about each and every entry.
    PerformOperationOverUrlCacheA(
        NULL, 
        FIND_FLAGS_RETRIEVE_ONLY_FIXED_AND_FILENAME,
        NORMAL_CACHE_ENTRY | STICKY_CACHE_ENTRY | SPARSE_CACHE_ENTRY,
        NULL,
        NULL,
        NULL,
        NULL,
        MoveOperation, 
        (PVOID)&mos);

    GlobalUrlContainers->SetCacheSize(CONTENT, mos.dlCacheSize);
    
    // Copy desktop.ini and index.dat, since these aren't cached
    TCHAR szFile[MAX_PATH];
    DWORD ccOldPath = lstrlen(pszOldPath);
    memcpy(szFile, pszOldPath, ccOldPath);
    AppendSlashIfNecessary(szFile, &ccOldPath);
    memcpy(szFile + ccOldPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, MEMMAP_FILE_NAME, sizeof(MEMMAP_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    memcpy(szFile + ccOldPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    memcpy(mos.szNewPath + mos.ccNewPath, DESKTOPINI_FILE_NAME, sizeof(DESKTOPINI_FILE_NAME));
    CopyFile(szFile, mos.szNewPath, FALSE);

    return ERROR_SUCCESS;
}


/*-----------------------------------------------------------------------------
IsCorrectUser

Routine Description:

    checks to see from the headers whether there is any username in there and
    whether it matches the currently logged on user. If no one is logged on a
    default username string is used

Arguments:

    lpszHeaderInfo: headers to check

    dwheaderSize:   size of the headers buffer

Return Value:

    BOOL


---------------------------------------------------------------------------*/
BOOL
IsCorrectUserPrivate(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    LPSTR lpTemp, lpTemp2;

    INET_ASSERT (lpszHeaderInfo);

    lpTemp = lpszHeaderInfo+dwHeaderSize-1;

    // start searching backwards

    while (lpTemp >= lpszHeaderInfo) {

        if (*lpTemp ==':') {
            // If this is less than the expected header:
            // then we know that there is no such usernameheader 
            // <MH> i.e. it's not a peruseritem so allow access</MH>

            if ((DWORD)PtrDifference((lpTemp+1), lpszHeaderInfo) < (sizeof(vszUserNameHeader)-1)) {
                TcpsvcsDbgPrint((DEBUG_CONTAINER,
                    "IsCorrectUser (Util.cxx): Didn't find header <lpTemp = 0x%x %s> <lpszHeaderInfo = 0x%x %s> <vszCurrentUser = %s> <PtrDifference = %d> <sizeof(vszUserNameHeader)-1) = %d>\r\n",
                    lpTemp,
                    lpTemp,
                    lpszHeaderInfo,
                    lpszHeaderInfo,
                    vszCurrentUser,
                    PtrDifference(lpTemp, lpszHeaderInfo),
                    (sizeof(vszUserNameHeader)-1)
                    ));
                return (TRUE); // No such header. just ay it is OK
            }

            // point this puppy to the expected header start
            lpTemp2 = lpTemp - (sizeof(vszUserNameHeader)-2);

            // if the earlier char is not a white space [0x9-0xd or 0x20]
            // then this is not the beginning of the header
            // <MH> Also need to check for the first header which would not 
            // have whitespace preceding it. Want to first check lpTemp2 ==
            // lpszheaderInfo to prevent underflowing when dereferencing.</MH>

            if (((lpTemp2) == lpszHeaderInfo) || isspace(*(lpTemp2-1))) {

                // we have the beginning of a header
                if (!strnicmp(lpTemp2
                                , vszUserNameHeader
                                , sizeof(vszUserNameHeader)-1)) {

                    // right header, let us see whether this is the right person
                    if(!strnicmp(lpTemp+1, vszCurrentUser, vdwCurrentUserLen)) {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): Match!! %s header == %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));
                    
                        return (TRUE); // right guy
                    }
                    else {
                        TcpsvcsDbgPrint((DEBUG_CONTAINER,
                            "IsCorrectUser (Util.cxx): No match!! %s header != %s current user.\r\n",
                            lpTemp+1,
                            vszCurrentUser
                            ));

                    }

                    return(FALSE); // wrong guy
                }
            }
        }
        --lpTemp;
    }

    return (TRUE); // there was no UserName header, just say it is OK
}


BOOL
IsCorrectUser(
    IN LPSTR lpszHeaderInfo,
    IN DWORD dwHeaderSize
    )
{
    BOOL fRet = FALSE;
    
    __try
    {
        fRet = IsCorrectUserPrivate(lpszHeaderInfo, dwHeaderSize);
    } // __try
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        fRet = FALSE;
    }
    ENDEXCEPT
    return fRet;
}



#ifndef UNICODE
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExA"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionA"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionA"
#else
#define SZ_GETDISKFREESPACEEX   "GetDiskFreeSpaceExW"
#define SZ_WNETUSECONNECTION    "WNetUseConnectionW"
#define SZ_WNETCANCELCONNECTION "WNetCancelConnectionW"
#endif

typedef BOOL (WINAPI *PFNGETDISKFREESPACEEX)(LPCTSTR, PULARGE_INTEGER, PULARGE_INTEGER, PULARGE_INTEGER);
typedef BOOL (WINAPI *PFNWNETUSECONNECTION)(HWND, LPNETRESOURCE, PSTR, PSTR, DWORD, PSTR, PDWORD, PDWORD);
typedef BOOL (WINAPI *PFNWNETCANCELCONNECTION)(LPCTSTR, BOOL);

BOOL EstablishFunction(PTSTR pszModule, PTSTR pszFunction, PFN* pfn)
{
    if (*pfn==(PFN)-1)
    {
        *pfn = NULL;
        HMODULE ModuleHandle = GetModuleHandle(pszModule);
        if (ModuleHandle)
        {
            *pfn = (PFN)GetProcAddress(ModuleHandle, pszFunction);
        }
    }        

    return (*pfn!=NULL);
}


// GetPartitionClusterSize

// GetDiskFreeSpace has the annoying habit of lying about the layout
// of the drive; thus we've been ending up with bogus sizes for the cluster size.
// You can't imagine how annoying it is to think you've a 200 MB cache, but it
// starts scavenging at 20MB.

// This function will, if given reason to doubt the veracity of GDFS, go straight 
// to the hardware and get the information for itself, otherwise return the passed-in
// value.

// The code that follows is heavily doctored from msdn sample code. Copyright violation? I think not.

static PFNGETDISKFREESPACEEX pfnGetDiskFreeSpaceEx = (PFNGETDISKFREESPACEEX)-1;
#define VWIN32_DIOC_DOS_DRIVEINFO   6

typedef struct _DIOC_REGISTERS 
{
    DWORD reg_EBX;
    DWORD reg_EDX;
    DWORD reg_ECX;
    DWORD reg_EAX;
    DWORD reg_EDI;
    DWORD reg_ESI;
    DWORD reg_Flags;
} 
DIOC_REGISTERS, *PDIOC_REGISTERS;

// Important: All MS_DOS data structures must be packed on a 
// one-byte boundary. 

#pragma pack(1) 

typedef struct 
_DPB {
    BYTE    dpb_drive;          // Drive number (1-indexed)
    BYTE    dpb_unit;           // Unit number
    WORD    dpb_sector_size;    // Size of sector in bytes
    BYTE    dpb_cluster_mask;   // Number of sectors per cluster, minus 1
    BYTE    dpb_cluster_shift;  // The stuff after this, we don't really care about. 
    WORD    dpb_first_fat;
    BYTE    dpb_fat_count;
    WORD    dpb_root_entries;
    WORD    dpb_first_sector;
    WORD    dpb_max_cluster;
    WORD    dpb_fat_size;
    WORD    dpb_dir_sector;
    DWORD   dpb_reserved2;
    BYTE    dpb_media;
    BYTE    dpb_first_access;
    DWORD   dpb_reserved3;
    WORD    dpb_next_free;
    WORD    dpb_free_cnt;
    WORD    extdpb_free_cnt_hi;
    WORD    extdpb_flags;
    WORD    extdpb_FSInfoSec;
    WORD    extdpb_BkUpBootSec;
    DWORD   extdpb_first_sector;
    DWORD   extdpb_max_cluster;
    DWORD   extdpb_fat_size;
    DWORD   extdpb_root_clus;
    DWORD   extdpb_next_free;
} 
DPB, *PDPB;

#pragma pack()

DWORD GetPartitionClusterSize(PTSTR szDevice, DWORD dwClusterSize)
{
    switch (GlobalPlatformType)
    {
    case PLATFORM_TYPE_WIN95:
        // If GetDiskFreeSpaceEx is present _and_ we're running Win9x, this implies
        // that we must be doing OSR2 or later. We can trust earlier versions 
        // of the GDFS (we think; this assumption may be invalid.)

        // Since Win95 can't read NTFS drives, we'll freely assume we're reading a FAT drive.
        // Basically, we're performing an MSDOS INT21 call to get the drive partition record. Joy.
        
        if (pfnGetDiskFreeSpaceEx)
        {
            HANDLE hDevice;
            DIOC_REGISTERS reg;
            BYTE buffer[sizeof(WORD)+sizeof(DPB)];
            PDPB pdpb = (PDPB)(buffer + sizeof(WORD));
    
            BOOL fResult;
            DWORD cb;

            // We must always have a drive letter in this case
            int nDrive = *szDevice - TEXT('A') + 1;  // Drive number, 1-indexed

            hDevice = CreateFile("\\\\.\\vwin32", 0, 0, NULL, 0, FILE_FLAG_DELETE_ON_CLOSE, NULL);

            if (hDevice!=INVALID_HANDLE_VALUE)
            {
                reg.reg_EDI = PtrToUlong(buffer);
                reg.reg_EAX = 0x7302;        
                reg.reg_ECX = sizeof(buffer);
                reg.reg_EDX = (DWORD) nDrive; // drive number (1-based) 
                reg.reg_Flags = 0x0001;     // assume error (carry flag is set) 

                fResult = DeviceIoControl(hDevice, 
                                          VWIN32_DIOC_DOS_DRIVEINFO,
                                          &reg, sizeof(reg), 
                                          &reg, sizeof(reg), 
                                          &cb, 0);

                if (fResult && !(reg.reg_Flags & 0x0001))
                {
                    // no error if carry flag is clear
                    dwClusterSize = DWORD((pdpb->dpb_cluster_mask+1)*pdpb->dpb_sector_size);
                }
                CloseHandle(hDevice);
            }
        }
        break;

    default:
        // Do nothing. Trust the value we've been passed.
        // UNIX guys will have to treat this separately.

        // For NT, however, this might be another issue. We can't use the DOS INT21.
        // Questions:
        // NT5 (but not NT4) supports FAT32; will we get honest answers? Apparently, yes.
        // NT4/5: NTFS drives and other FAT drives -- do we still get honest answers? Investigation
        // so far says, Yes. 
        break;
    }
    
    return dwClusterSize;
}


/* GetDiskInfo
    A nice way to get volume information
*/
BOOL GetDiskInfoA(PTSTR pszPath, PDWORD pdwClusterSize, PDWORDLONG pdlAvail, PDWORDLONG pdlTotal)
{
    static PFNWNETUSECONNECTION pfnWNetUseConnection = (PFNWNETUSECONNECTION)-1;
    static PFNWNETCANCELCONNECTION pfnWNetCancelConnection = (PFNWNETCANCELCONNECTION)-1;

    if (!pszPath)
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    INET_ASSERT(pdwClusterSize || pdlAvail || pdlTotal);
    // If GetDiskFreeSpaceExA is available, we can be confident we're running W95OSR2+ || NT4
    EstablishFunction(TEXT("KERNEL32"), SZ_GETDISKFREESPACEEX, (PFN*)&pfnGetDiskFreeSpaceEx);
  
    BOOL fRet = FALSE;
    TCHAR szDevice[MAX_PATH];
    PTSTR pszGDFSEX = NULL;
   
    if (*pszPath==DIR_SEPARATOR_CHAR)
    {
        // If we're dealing with a cache that's actually located on a network share, 
        // that's fine so long as we have GetDiskFreeSpaceEx at our disposal.
        // _However_, if we need the cluster size on Win9x, we'll need to use
        // INT21 stuff (see above), even if we have GDFSEX available, so we need to map
        // the share to a local drive.
        
        if (pfnGetDiskFreeSpaceEx 
            && !((GlobalPlatformType==PLATFORM_TYPE_WIN95) && pdwClusterSize))
        {
            DWORD cbPath = lstrlen(pszPath);
            cbPath -= ((pszPath[cbPath-1]==DIR_SEPARATOR_CHAR) ? 1 : 0);
            if (cbPath>MAX_PATH-2)
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                return FALSE;
            }
            memcpy(szDevice, pszPath, cbPath);
            szDevice[cbPath] = DIR_SEPARATOR_CHAR;
            cbPath++;
            szDevice[cbPath] = '\0';
            pszGDFSEX = szDevice;
        }
        else
        {
            if (!(EstablishFunction(TEXT("MPR"), SZ_WNETUSECONNECTION, (PFN*)&pfnWNetUseConnection)
                &&
               EstablishFunction(TEXT("MPR"), SZ_WNETCANCELCONNECTION, (PFN*)&pfnWNetCancelConnection)))
            {
                return FALSE;
            }

           // If it's a UNC, map it to a local drive for backwards compatibility
            NETRESOURCE nr = { 0, RESOURCETYPE_DISK, 0, 0, szDevice, pszPath, NULL, NULL };
            DWORD cbLD = sizeof(szDevice);
            DWORD dwNull;
            if (pfnWNetUseConnection(NULL, 
                          &nr, 
                          NULL, 
                          NULL, 
                          CONNECT_INTERACTIVE | CONNECT_REDIRECT, 
                          szDevice,
                          &cbLD,
                          &dwNull)!=ERROR_SUCCESS)
            {
                SetLastError(ERROR_NO_MORE_DEVICES);        
                return FALSE;
            }
        }
    }
    else
    {
        memcpy(szDevice, pszPath, sizeof(TEXT("?:\\")));
        szDevice[3] = '\0';
        pszGDFSEX = pszPath;
    }
    if (*szDevice!=DIR_SEPARATOR_CHAR)
    {
        *szDevice = (TCHAR)CharUpper((LPTSTR)*szDevice);
    }

#ifdef UNIX
    /* On Unix, GetDiskFreeSpace and GetDiskFreeSpaceEx will work successfully
     * only if the path exists. So, let us pass a path that exists
     */
    UnixGetValidParentPath(szDevice);
#endif /* UNIX */

    // I hate goto's, and this is a way to avoid them...
    for (;;)
    {
        DWORDLONG cbFree = 0, cbTotal = 0;
    
        if (pfnGetDiskFreeSpaceEx && (pdlTotal || pdlAvail))
        {
            ULARGE_INTEGER ulFree, ulTotal;

            // BUG BUG BUG Is the following problematic? Also, we'll need to add checks to make sure that 
            // the  cKBlimit fits a DWORD (in the obscene if unlikely case drive spaces grow that large)
            // For instance, if this is a per user system with a non-shared cache, we might want to change
            // the ratios.
            INET_ASSERT(pszGDFSEX);
            fRet = pfnGetDiskFreeSpaceEx(pszGDFSEX, &ulFree, &ulTotal, NULL);

            // HACK Some versions of GetDiskFreeSpaceEx don't accept the whole directory; they
            // take only the drive letter. Pfft.
            if (!fRet)
            {
                fRet = pfnGetDiskFreeSpaceEx(szDevice, &ulFree, &ulTotal, NULL);
            }

            if (fRet)
            {
                cbFree = ulFree.QuadPart;
                cbTotal = ulTotal.QuadPart;
            }
        }

        if ((!fRet) || pdwClusterSize)
        {
            DWORD dwSectorsPerCluster, dwBytesPerSector, dwFreeClusters, dwClusters, dwClusterSize;
            if (!GetDiskFreeSpace(szDevice, &dwSectorsPerCluster, &dwBytesPerSector, &dwFreeClusters, &dwClusters))
            {
                fRet = FALSE;
                break;
            }
            
            dwClusterSize = dwBytesPerSector * dwSectorsPerCluster;

            if (!fRet)
            {
                cbFree = (DWORDLONG)dwClusterSize * (DWORDLONG)dwFreeClusters;
                cbTotal = (DWORDLONG)dwClusterSize * (DWORDLONG)dwClusters;
            }
            
            if (pdwClusterSize)
            {
                *pdwClusterSize = GetPartitionClusterSize(szDevice, dwClusterSize);
            }
        }

        if (pdlTotal)
        {
             *pdlTotal = cbTotal;
        }
        if (pdlAvail)
        {
             *pdlAvail = cbFree;
        }
        fRet = TRUE;
        break;
    };
    
    // We've got the characteristics. Now delete local device connection, if any.
    if (*pszPath==DIR_SEPARATOR_CHAR && !pfnGetDiskFreeSpaceEx)
    {
        pfnWNetCancelConnection(szDevice, FALSE);
    }

    return fRet;
}


// -- ScanToLastSeparator
// Given a path, and a pointer within the path, discover where the path separator prior to the path
// is located and return the pointer to it. If there is none, return NULL.

BOOL ScanToLastSeparator(PTSTR pszPath, PTSTR* ppszCurrent)
{
    PTSTR pszActual = *ppszCurrent;
    pszActual--;
    while ((pszActual>(pszPath+1)) && (*pszActual!=DIR_SEPARATOR_CHAR))
    {
        pszActual--;
    }
    if ((*pszActual==DIR_SEPARATOR_CHAR) && (pszActual!=*ppszCurrent))
    {
        *ppszCurrent = pszActual;
        return TRUE;
    }

    return FALSE;
}

// -- Centralised method of tracking mutexes
// class MUTEX_HOLDER

MUTEX_HOLDER::MUTEX_HOLDER()
{
    _hHandle = NULL;
    _dwState = WAIT_FAILED;
}

MUTEX_HOLDER::~MUTEX_HOLDER()
{
    if (_hHandle)
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "ERROR: Releasing ownership of mutex %d\r\n",
            _hHandle));
        ReleaseMutex(_hHandle);
    }
}

VOID MUTEX_HOLDER::Grab(HANDLE hHandle, DWORD dwTime)
{
    INET_ASSERT(hHandle);
    _hHandle = hHandle;
    _dwState = WaitForSingleObject(_hHandle, dwTime);
    if (_dwState==WAIT_ABANDONED)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of abandoned mutex %d\r\n",
            hHandle));
    }
    else if (_dwState==WAIT_OBJECT_0)
    {
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Gained ownership of mutex %d\r\n",
            hHandle));
    }
    else
    {
        INET_ASSERT(FALSE);
        TcpsvcsDbgPrint((DEBUG_CONTAINER,
            "Unable to gain ownership of mutex %d\r\n",
            hHandle));
    }
}

VOID MUTEX_HOLDER::Release()
{
    if (_hHandle)
    {
        if (_dwState==WAIT_ABANDONED || _dwState==WAIT_OBJECT_0)
        {
            ReleaseMutex(_hHandle);
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Released ownership of mutex %d\r\n",
                _hHandle));
        }
        else
        {
            TcpsvcsDbgPrint((DEBUG_CONTAINER,
                "Would release ownership of mutex %d, except we don't own it\r\n",
                _hHandle));
        }
    }
    _hHandle = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\urlcache.cxx ===
/*++

Copyright (c) 1997  Microsoft Corp.

Module Name: urlcache.cxx

Abstract:

    Urlcache API enhanced and optimized for internal use by wininet.

Author:
    Rajeev Dujari (rajeevd) 10-Apr-97

--*/

#include <cache.hxx>

DWORD
UrlCacheRetrieve
(
        IN  LPSTR                pszUrl,
        IN  BOOL                 fOffline,
        OUT HANDLE*              phStream,
        OUT CACHE_ENTRY_INFOEX** ppCEI
)
{
    BOOL fLocked = FALSE;
    HANDLE hStream = NULL;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD dwErr;

    if (!InitGlobals())
    {
        INET_ASSERT(FALSE);
        return ERROR_INTERNET_INTERNAL_ERROR;
    }

    DWORD dwLookupFlags = fOffline? LOOKUP_URL_TRANSLATE
        : (LOOKUP_BIT_SPARSE | LOOKUP_URL_NOCREATE);

    DWORD cbCEI;
    
    // Find the container and search the index.
    dwErr = GlobalUrlContainers->RetrieveUrl(
                    pszUrl, 
                    (CACHE_ENTRY_INFO **) ppCEI, 
                    &cbCEI, 
                    dwLookupFlags, 
                    RETRIEVE_WITHOUT_CHECKS | RETRIEVE_WITH_ALLOCATION);

    if (dwErr != ERROR_SUCCESS)
        goto Cleanup;

    fLocked = TRUE;
    if ((*ppCEI)->CacheEntryType & SPARSE_CACHE_ENTRY)
    {    
        *phStream = NULL;    
    }
    else
    {
        // Allocate a stream handle.
        CACHE_STREAM_CONTEXT_HANDLE* pStream;
        LOCK_CACHE();
        hStream = HandleMgr.Alloc (sizeof(CACHE_STREAM_CONTEXT_HANDLE));
        if (hStream)
        {
            pStream = (CACHE_STREAM_CONTEXT_HANDLE*) HandleMgr.Map (hStream);
            INET_ASSERT (pStream);
        }
        UNLOCK_CACHE();
        if (!hStream)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        // Open the file.
        hFile = CreateFile
        (
            (*ppCEI)->lpszLocalFileName,
            GENERIC_READ,
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
            NULL
        );
        if( hFile == INVALID_HANDLE_VALUE )
        {
            dwErr = GetLastError();
            goto Cleanup;
        }

        DWORD dwFileSize = GetFileSize(hFile, NULL);

        if (dwFileSize != (*ppCEI)->dwSizeLow) 
        {
            dwErr = (dwFileSize==0xFFFFFFFF) ? GetLastError() : ERROR_INVALID_DATA;
            goto Cleanup;
        }

        pStream->FileHandle = hFile;

        // Copy URL name storage.
        pStream->SourceUrlName = NewString(pszUrl);
        if( !pStream->SourceUrlName)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        *phStream = hStream;
    }
    
    dwErr = ERROR_SUCCESS;

Cleanup:

    if( dwErr != ERROR_SUCCESS )
    {
        if (*ppCEI)
        {
            FREE_MEMORY (*ppCEI);
            *ppCEI = NULL;
        }
        if (hStream)
            HandleMgr.Free (hStream);
        if (hFile)
            CloseHandle (hFile);
        if (fLocked)
            GlobalUrlContainers->UnlockUrl(pszUrl);
    }
    return dwErr;
}


void UrlCacheFlush (void)
{
    DWORD fPersist;
    
    REGISTRY_OBJ regCache (HKEY_CURRENT_USER, OLD_CACHE_KEY);
    
    if (    ERROR_SUCCESS == regCache.GetStatus()
        &&  ERROR_SUCCESS == regCache.GetValue (CACHE_PERSISTENT, &fPersist)
        &&  !fPersist
       )
    {
        FreeUrlCacheSpace (NULL, 100, STICKY_CACHE_ENTRY);
    }
}

DWORD UrlCacheCreateFile(LPCSTR szUrl, LPTSTR szExt, LPTSTR szFile, HANDLE *phfHandle, BOOL fCreatePerUser)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->CreateUniqueFile(szUrl, 0, szExt, szFile, phfHandle, fCreatePerUser);
}

DWORD UrlCacheCommitFile(AddUrlArg* pArgs)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else        
        return GlobalUrlContainers->AddUrl(pArgs);
}

DWORD UrlCacheSendNotification(DWORD   dwOp)
{
    DWORD Error;

    // Initialize globals.
    if (!InitGlobals())
    {
        Error = ERROR_INTERNET_INTERNAL_ERROR;
        goto Cleanup;
    }
        
    Error = GlobalUrlContainers->SendCacheNotification(dwOp);

Cleanup:
    return Error;
}

DWORD UrlCacheAddLeakFile (IN LPCSTR pszFile)
{
    if (!InitGlobals())
        return ERROR_INTERNET_INTERNAL_ERROR;
    else
        return GlobalUrlContainers->AddLeakFile (pszFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hist\generic.c ===
#include <windows.h>

#define ASSERT(x) if (!(x)) DebugBreak();


LPBYTE
MemFind (LPBYTE lpB, DWORD cbB, LPBYTE lpP, DWORD cbP)

{
	DWORD i, j;
	LPBYTE lpF = NULL;
//	LPBYTE lpB = (LPBYTE) lp1, lpP = (LPBYTE) lp2;
	
	if ( (!lpB) || (!cbB) || (!lpP) || (!cbP) )
		return NULL;
	
	for (i = 0; i < cbB ; i++)
	{
		for (j = 0; i < cbB, j < cbP ; i++, j++)
		{
			if (lpB[i] != lpP[j])
			{	
				lpF = NULL;
				break;
			}
			if (!j)  //the first letter
				lpF = &(lpB[i]);
		}
		if (lpF)
			return lpF;
	}
	return NULL;
}


BOOL
ParseArgsDyn(
    LPTSTR InBuffer,
    LPTSTR **pArgv,
    LPDWORD pArgc
    )

#define DEFAULT_ARGV_SIZE 16

{
    LPTSTR CurrentPtr = InBuffer;
    DWORD cArgv = DEFAULT_ARGV_SIZE;
	LPTSTR *temp = NULL;

	*pArgv = (LPTSTR *) LocalAlloc (LPTR, cArgv * sizeof(LPTSTR));
	if (!*pArgv)
		return FALSE;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr == ' ' ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        (*pArgv)[*pArgc] = CurrentPtr;
		(*pArgc)++;

        //
        // go to next space.
        //

        while( (*CurrentPtr != ' ') &&
                (*CurrentPtr != '\0') &&
                (*CurrentPtr != '\n') ) {
            CurrentPtr++;
        }

        if( *CurrentPtr == '\0' ) {
            break;
        }

        *CurrentPtr++ = '\0';
		
		ASSERT(*pArgc <= cArgv);

		if (*pArgc == cArgv)  //grow the array
		{
			temp = *pArgv;

			*pArgv = (LPTSTR *) LocalAlloc (LPTR, (cArgv + DEFAULT_ARGV_SIZE) * sizeof (LPTSTR));
			if (!*pArgv)
			{
				LocalFree (temp);
				return FALSE;
			}

			memcpy (*pArgv, temp, cArgv * sizeof(LPTSTR));

			LocalFree (temp);
			
			cArgv += DEFAULT_ARGV_SIZE;
		}
    }
    return TRUE;
}


DWORD 
AddArgvDyn (LPTSTR **pArgv, DWORD *pArgc, LPTSTR szNew)
{
	DWORD cArgv = (*pArgc / DEFAULT_ARGV_SIZE + ( *pArgc % DEFAULT_ARGV_SIZE ? 1 : 0 )) * DEFAULT_ARGV_SIZE;
	LPTSTR *temp = NULL;

	if (cArgv <= *pArgc)
	{
		temp = *pArgv;
		*pArgv = (LPTSTR *) LocalAlloc (LPTR, (cArgv + DEFAULT_ARGV_SIZE) * sizeof (LPTSTR));
		if (!*pArgv)
		{
			*pArgv = temp;
			return ERROR_NOT_ENOUGH_MEMORY;
		}
		

		memcpy (*pArgv, temp, cArgv * sizeof(LPTSTR));
		if (temp)
			LocalFree (temp);

		cArgv += DEFAULT_ARGV_SIZE;

		ASSERT (*pArgc < cArgv);
	}


	//this means there is room for another LPTSTR
	(*pArgv)[*pArgc] = szNew;	//NOTE this is volatile memory not alloc by us
	(*pArgc)++;
	return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\ckcnv\ckcnv.cxx ===
/*-----------------------------------------------------------------------------
Copyright (c) 1996  Microsoft Corporation

Module Name:  ckcnv.cxx

Abstract:
  Upgrades cookies to present urlcache format by enumerating cookie files in the
  cache cookies directory and creates cookie cache index entries in the format of 
  the current wininet.dll. 
    
Author:
    Adriaan Canter (adriaanc) 09-Jan-1997
        Created

    Adriaan Canter (adriaanc) 01-Feb-1997    
        Modified for per-user caches. The class CCookieLoader definition 
        can now be pasted into the urlcache build without re-definition
        and work correctly, as long as the HKLM and HKCU cache keys are
        not modified. BUGBUG - do this.

-----------------------------------------------------------------------------*/
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <wininet.h>
#include "cachedef.h"

#define INET_ASSERT(condition) Assert(condition)

/*-----------------------------------------------------------------------------
    class CCookieLoader

    Class used to perform cookie conversion
  ----------------------------------------------------------------------------*/
class CCookieLoader
{
private:
    DWORD GetHKLMCookiesDirectory(CHAR*);
    DWORD GetHKCUCookiesDirectory(CHAR*);
    CHAR* ParseNextCookie(CHAR*, CHAR**, FILETIME*, FILETIME*);
    
public:
    DWORD LoadCookies(BOOL);
};


// Debug assert code.
#if DBG
#define Assert(Predicate) \
    { \
        if (!(Predicate)) \
            AssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
AssertFailed(
    LPSTR FailedAssertion,
    LPSTR FileName,
    DWORD LineNumber,
    LPSTR Message
    )
{

    printf("Assert @ %s \n", FailedAssertion );
    printf("Assert Filename, %s \n", FileName );
    printf("Line Num. = %ld.\n", LineNumber );
    printf("Message is %s\n", Message );

    DebugBreak();
}
#else
#define Assert(_x_)
#endif // DBG

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKLMCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKLMCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;

    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, CACHE_SPECIAL_PATHS_KEY);
    strcat(szCookiesDirRegKey, "\\");    
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}

/*-----------------------------------------------------------------------------
    CCookieLoader::GetHKCUCookiesDirectory
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::GetHKCUCookiesDirectory(CHAR *szCookiesDirectory)
{
    HKEY hKey;
    DWORD dwError, dwKeyType, cbKeyLen = MAX_PATH;
    
    CHAR szCookiesDirRegKey[MAX_PATH];
    strcpy(szCookiesDirRegKey, CACHE_KEY);
    strcat(szCookiesDirRegKey, "\\");
    strcat(szCookiesDirRegKey, COOKIE_PATH_KEY);

    if (dwError = RegOpenKeyEx(HKEY_CURRENT_USER,
        szCookiesDirRegKey, NULL, KEY_ALL_ACCESS, &hKey) != ERROR_SUCCESS)
        goto exit;
    
    if (dwError = RegQueryValueEx(hKey, CACHE_DIRECTORY_VALUE, NULL, &dwKeyType, 
        (LPBYTE) szCookiesDirectory, &cbKeyLen) != ERROR_SUCCESS)
        goto exit;

exit:
    if (hKey != INVALID_HANDLE_VALUE)
        CloseHandle(hKey);

    return dwError;
}


/*-----------------------------------------------------------------------------
    CCookieLoader::ParseNextCookie

    Upgrades cookies from Cache Version 3.2 to Cache Version 4.0 
  ----------------------------------------------------------------------------*/
CHAR* CCookieLoader::ParseNextCookie(CHAR* ptr, CHAR** ppszHash,
    FILETIME* pftExpire, FILETIME* pftLast)
{
    CHAR *pszName, *pszValue, *pszFlags,
         *pszExpireTimeLow, *pszExpireTimeHigh,
         *pszLastTimeHigh,  *pszLastTimeLow,
         *pszDelimiter, *pszNextCookie;
   
    __try
    {
        // Get the first token (cookie name).
        pszName           = StrTokEx(&ptr, "\n");
        if (!pszName)                               // Cookie name.
        {
            // Normal termination of the parse.
            pszNextCookie = 0;
            goto exit;
        }

        // Parse the rest of the cookie
        pszValue          = StrTokEx(&ptr, "\n");      // Cookie value.
        *ppszHash         = StrTokEx(&ptr, "\n");      // Combo of domain and path.
        pszFlags          = StrTokEx(&ptr, "\n");      // Cookie flags.
        pszExpireTimeLow  = StrTokEx(&ptr, "\n");      // Expire time.
        pszExpireTimeHigh = StrTokEx(&ptr, "\n");             
        pszLastTimeLow    = StrTokEx(&ptr, "\n");      // Last Modified time.
        pszLastTimeHigh   = StrTokEx(&ptr, "\n");
        pszDelimiter      = StrTokEx(&ptr, "\n");      // Delimiter should be "*"

    
        // Abnormal termination of parse.
        if (!pszDelimiter || pszDelimiter[0] != '*')
        {
            INET_ASSERT(FALSE);
            pszNextCookie = 0;
            goto exit;
        }

        // Set the times.
        pftExpire->dwLowDateTime  = atoi(pszExpireTimeLow);
        pftExpire->dwHighDateTime = atoi(pszExpireTimeHigh);
        pftLast->dwLowDateTime    = atoi(pszLastTimeLow);
        pftLast->dwHighDateTime   = atoi(pszLastTimeHigh);        

        pszNextCookie = pszDelimiter+2;
    }
    
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        pszNextCookie = 0;
        goto exit;
    }

exit:
    return pszNextCookie;

}


/*-----------------------------------------------------------------------------
    CCookieLoader::LoadCookies
  ----------------------------------------------------------------------------*/
DWORD CCookieLoader::LoadCookies(BOOL fConvertToPerUser)
{
    HANDLE             hFind = INVALID_HANDLE_VALUE;
    HANDLE             hFile = INVALID_HANDLE_VALUE;

    FILETIME           ftExpire, ftLast;
    CHAR               szCookieFileName        [MAX_PATH],
                       szCookieFileNamePattern [MAX_PATH],
                       szHKLMCookiesPath       [MAX_PATH],
                       szHKCUCookiesPath       [MAX_PATH],
                       szCookieName            [MAX_PATH],    
                       szHKLMCookieFileName    [MAX_PATH],
                       szHKCUCookieFileName    [MAX_PATH];
                    
    CHAR               *pszHash, *ptr, *pszCookiesPath,
                       *pszCurrentCookie, *szBuffer;

    WIN32_FIND_DATA    FindData;
    BOOL               bReturn;
    DWORD              cbRead = 0, dwError = ERROR_SUCCESS;

    // Data for a single cookie should fit in 2 pages.
    BYTE bCacheEntryInfoBuffer[2 * PAGE_SIZE];
    INTERNET_CACHE_ENTRY_INFO *pCacheEntryInfo;
    DWORD cbCacheEntryInfoBuffer;

    __try
    {   
        szBuffer = 0;

        // Check to see if we are upgrading cookies
        // from local machine to per user.
        if (fConvertToPerUser)
        {
            DWORD cb = MAX_PATH;
            CHAR szUserName[MAX_PATH];

            // We are converting cookies from HKLM to HKCU.
            // This is done by enumerating the user's cookies
            // files and copying them to the per-user diretory.            
            // Once this is accomplished, cookie converting will
            // proceed normally.

            // Get the cookies directory as specified by HKLM.
            if (dwError = GetHKLMCookiesDirectory(szHKLMCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);

            // Get the cookies directory as specified by HKCU.
            if (dwError = GetHKCUCookiesDirectory(szHKCUCookiesPath) != ERROR_SUCCESS)
            {
                INET_ASSERT(FALSE);
                goto exit;
            }

            // Get the current user name.
            GetUserName(szUserName, &cb);

            // szCookieFileNamePattern will look like c:\winnt\cookies\joeuser@*.txt
            strcat(szCookieFileNamePattern, "\\");
            strcat(szCookieFileNamePattern, szUserName);
            strcat(szCookieFileNamePattern, "@*.txt");
        
            // Enumerate the users cache files        
            hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
            if (hFind == INVALID_HANDLE_VALUE)
            {
                // OK, No cookie files to upgrade.
                dwError = ERROR_SUCCESS;
                goto exit;
            }    
        
            // One or more cookie files exist.
            do
            {
                // Construct absolute path from HKLM to cookies file.
                strcpy(szHKLMCookieFileName, szHKLMCookiesPath);
                strcat(szHKLMCookieFileName, "\\");
                strcat(szHKLMCookieFileName, FindData.cFileName);
                
                // Construct absolute path from HKCU to cookies file.
                strcpy(szHKCUCookieFileName, szHKCUCookiesPath);
                strcat(szHKCUCookieFileName, "\\");
                strcat(szHKCUCookieFileName, FindData.cFileName);
            
                // Copy the file to the per-user directory.
                CopyFile(szHKLMCookieFileName, szHKCUCookieFileName, TRUE);

            } while (FindNextFile(hFind, &FindData)); 
        
            // Close the Find handle.
            if (hFind != INVALID_HANDLE_VALUE)
            {
                FindClose(hFind);        
                hFind = INVALID_HANDLE_VALUE;
            }

        } // Per-user upgrade.
        else
        {
            // No per-user upgrade. szCookieFileNamePattern will look like
            // c:\winnt\cookies\*@*.txt or c:\winnt\profiles\joeuser\cookies\*@*.txt.
            GetHKLMCookiesDirectory(szHKLMCookiesPath);
            strcpy(szCookieFileNamePattern, szHKLMCookiesPath);
            strcat(szCookieFileNamePattern, "\\*@*.txt");
        }

        // We now have the appropriate cookie filename pattern, also need a copy
        // of the cookies directory associated with the current user.
        pszCookiesPath = (fConvertToPerUser ? szHKCUCookiesPath : szHKLMCookiesPath);
        
        // Enumerate the cache files.
        hFind = FindFirstFile(szCookieFileNamePattern, &FindData);
        if (hFind == INVALID_HANDLE_VALUE)
        {
            // OK, No cookies files to upgrade.
            // BUGBUG - should we verify this?
            dwError = ERROR_SUCCESS;
            goto exit;
        }    

        // One or more cookie files exist.
        do
        {
            // Construct absolute path to cookie file.
            strcpy(szCookieFileName, pszCookiesPath);
            strcat(szCookieFileName, "\\");
            strcat(szCookieFileName, FindData.cFileName);
            
            // Open the cookie file.
            hFile = CreateFile(
                    szCookieFileName,       // Absolute path to cookies file.
                    GENERIC_READ,           // Read only.
                    FILE_SHARE_READ,        // Share.
                    0,                      // Security Attribute (ignored in W95).
                    OPEN_EXISTING,          // Fail if doesn't exist.
                    FILE_ATTRIBUTE_NORMAL,  // No special attributes.
                    0                       // Attribute template.
                    );                   

            // File handle must be valid.
            if (hFile != INVALID_HANDLE_VALUE)
            {
                // Allocate memory for cookie file contents.
                // BUGBUG - put an upper limit on this? -> 
                // 300 cookies * 4k/cookie = 1200k plus sundry.
                szBuffer = new CHAR[FindData.nFileSizeLow + 1];
                if (!szBuffer)
                {
                    dwError = ERROR_NOT_ENOUGH_MEMORY;
                    goto exit;
                }

                // Read the file into memory.
                bReturn = ReadFile(hFile, szBuffer, FindData.nFileSizeLow, &cbRead, NULL);

                // ReadFile must be successful.
                INET_ASSERT(bReturn);
                if (bReturn)
                {
                    // Null terminate buffer.
                    szBuffer[cbRead] = '\0';

                    // Parse each cookie out of the buffer.
                    pszCurrentCookie = szBuffer;
                    while (pszCurrentCookie = ParseNextCookie(pszCurrentCookie, 
                        &pszHash, &ftExpire, &ftLast))
                    {
                        // Construct the cookie name from the following strings:
                        // FindData.cFileName is like "user@foobar.txt"
                        // pszHash is like "foobar.com/"
                        // szCookieName should then be "Cookie:user@foobar.com/"            
                        strcpy(szCookieName, COOKIE_PREFIX);
                        strcat(szCookieName, FindData.cFileName);
                        ptr = strstr(szCookieName, "@");
                        strcpy(ptr+1, pszHash);

                        // Check to see if an earlier version of this cookie
                        // has already been added to the cache index file.
                        BOOL fAddToCache = TRUE;
                        pCacheEntryInfo = (INTERNET_CACHE_ENTRY_INFO*) bCacheEntryInfoBuffer;
                        cbCacheEntryInfoBuffer = sizeof(bCacheEntryInfoBuffer);

                        dwError = GetUrlCacheEntryInfo(szCookieName, pCacheEntryInfo, 
                            &cbCacheEntryInfoBuffer);

                        if (dwError == ERROR_SUCCESS 
                            && CompareFileTime(&pCacheEntryInfo->LastModifiedTime, &ftLast) > 0)
                            fAddToCache = FALSE;

                        if (fAddToCache)
                        {
                            // Either this cookie was not found in the index file or 
                            // it was found and the last modified time on it is 
                            // less than the currently parsed cookie. Proceed
                            // to add this cookie to the index file.
                            BOOL bCommit;
                            bCommit = CommitUrlCacheEntry(
                                szCookieName,           // cookie:user@foobar.com.
                                szCookieFileName,       // c:\winnt\cookies\user@foobar.txt.
                                ftExpire,               // Expire time.
                                ftLast,                 // Last modified time.
                                0,                      // CacheEntryType.
                                0,                      // HeaderInfo.
                                0,                      // HeaderSize.
                                0,                      // FileExtension.
                                0);                     // Reserved.

                            INET_ASSERT(bCommit);
                        } 

                    } // Successful next cookie field.

                } // Successful read.

                // Done with this cookie file. Delete the buffer.
                delete [] szBuffer;

                // And close the file
                CloseHandle(hFile);
                hFile = INVALID_HANDLE_VALUE;

            } // File handle is valid.
                    
        } while (FindNextFile(hFind, &FindData)); 

        
        // No more cookie files or an error occured.        
        if ((dwError = GetLastError()) != ERROR_NO_MORE_FILES)
            goto exit;

        // Normal termination.
        dwError = ERROR_SUCCESS;

    exit:

        // Close the file handle.
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);

        // Close the Find handle.
        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);

        return dwError;

    } // try

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // Cleanup.
        delete [] szBuffer;

        if (hFind != INVALID_HANDLE_VALUE)
            FindClose(hFind);
        if (hFile != INVALID_HANDLE_VALUE)
            CloseHandle(hFile);
                
        INET_ASSERT(FALSE);
        dwError = ERROR_EXCEPTION_IN_SERVICE;
        return dwError;
    }

}


int WINAPI WinMain(HINSTANCE hInstance,	HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
    DWORD dwError;
    CHAR szFilename[MAX_PATH];
    CCookieLoader cc;

    __try
    {
    
        // Convert cookies.
        dwError = cc.LoadCookies(FALSE);

        // See if we're supposed to delete this
        // executable after the user reboots.
        if (!_strnicmp(lpCmdLine, "/D", sizeof("/D")))
        {

            // Got this filename?
            if (GetModuleFileName(NULL, szFilename, MAX_PATH))
            {
                OSVERSIONINFO osVersionInfo;
                osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
        
                if (GetVersionEx(&osVersionInfo))
                {
                    // Two different methods of deleting this file
                    // depending on the platform ID.
                    if (osVersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT)
                    {
                        // Platform is Windows NT.
                        MoveFileEx(szFilename, NULL, MOVEFILE_DELAY_UNTIL_REBOOT);
                    }
                    else
                    {
                        // Platform is Windows 95
                        WriteProfileSection("NUL", szFilename);
                    }

                }
            }
        }
    }
    

    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        INET_ASSERT(FALSE);
        dwError = ERROR_EXTENDED_ERROR;
    }

    return (dwError == ERROR_SUCCESS ? 0 : 1);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hist\histapi.h ===
// history.
#ifndef _HISTAPI_
#define _HISTEAPI_

#ifdef __cplusplus
extern "C" {
#endif

#if !defined(_HISTORYAPI_)
#define HISTORYAPI          EXTERN_C DECLSPEC_IMPORT HRESULT STDAPICALLTYPE
#define HISTORYAPI_(type)   EXTERN_C DECLSPEC_IMPORT type STDAPICALLTYPE
#else
#define HISTORYAPI          EXTERN_C HRESULT STDAPICALLTYPE
#define HISTORYAPI_(type)   EXTERN_C type STDAPICALLTYPE
#endif

typedef struct _HISTORY_ITEM_INFO {
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;


HISTORYAPI_(BOOL)
FindCloseHistory (
    IN HANDLE hEnumHandle
    );


HISTORYAPI_(BOOL)
FindNextHistoryItem(
    IN HANDLE hEnumHandle,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    );



HISTORYAPI_(HANDLE)
FindFirstHistoryItem(
    IN LPCTSTR  lpszUrlSearchPattern,
    OUT LPHISTORY_ITEM_INFO lpFirstHistoryItemInfo,
    IN OUT LPDWORD lpdwFirstHistoryItemInfoBufferSize
    );

HISTORYAPI_(BOOL)
GetHistoryItemInfo (
    IN LPCTSTR lpszUrlName,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    );


HISTORYAPI_(BOOL)
RemoveHistoryItem (
    IN LPCTSTR lpszUrlName,
    IN DWORD dwReserved
    );


HISTORYAPI_(BOOL)
IsHistorical(
    IN LPCTSTR lpszUrlName
    );

HISTORYAPI_(BOOL)
AddHistoryItem(
    IN LPCTSTR lpszUrlName,		//direct correspondence in URLCACHE
    IN LPCTSTR lpszHistoryTitle,		// this needs to be added to lpHeaderInfo
	IN LPCTSTR lpszDependancies,
	IN DWORD dwFlags,
    IN DWORD dwReserved
    );




#ifdef __cplusplus
}
#endif


#endif  // _HISTAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\perf\fndquota\fndquota.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    fndquota.c

Abstract:

    Test program to fill you cache to just under your quota.

Author:

    Vince Roggero (vincentr)  27-Jun-1997


Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <wininet.h>
#include <winineti.h>

//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
#define URL_NAME_SIZE   (16 + 1)

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define CACHE_DATA_BUFFER_SIZE 1024

#define CACHE_HEADER_INFO_SIZE  2048
#define CACHE_HEADER_INFO_SIZE_NORMAL_MAX   256
#define CACHE_HEADER_INFO_SIZE_BIG_MAX      512

//=================================================================================
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];
BYTE GlobalCacheDataBuffer[CACHE_DATA_BUFFER_SIZE];
BYTE GlobalCacheHeaderInfo[CACHE_HEADER_INFO_SIZE];
DWORD g_dwFileSize = 16384;
DWORD g_dwNumEntries = 1;
DWORD g_dwInitEntries = 0;
BOOL g_bVerbose = FALSE;

//=================================================================================
DWORD SetFileSizeByName(LPCTSTR FileName, DWORD FileSize)
/*++

Routine Description:
    Set the size of the specified file.

Arguments:
    FileName : full path name of the file whose size is asked for.
    FileSize : new size of the file.

Return Value:
    Windows Error Code.

--*/
{
    HANDLE FileHandle;
    DWORD FilePointer;
    DWORD Error = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    DWORD dwCreate;
    BOOL BoolError;

    //
    // get the size of the file being cached.
    //
    dwFlags = 0;
    dwCreate = CREATE_ALWAYS;

    FileHandle = CreateFile(
                    FileName,
                    GENERIC_WRITE,
                    0,   //FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreate,
                    FILE_ATTRIBUTE_NORMAL | dwFlags,
                    NULL );

    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( GetLastError() );
    }

    FilePointer = SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN );

    if( FilePointer != 0xFFFFFFFF )
    {
        if(!SetEndOfFile( FileHandle ))
            Error = GetLastError();
    }
    else
    {
        Error = GetLastError();
    }

    CloseHandle( FileHandle );
    return( Error );
}

//=================================================================================
FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}


//=================================================================================
DWORD EnumUrlCacheEntries(DWORD *pdwTotal)
{
    DWORD BufferSize, dwSmall=0, dwLarge=0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD dwTotal = 0;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    BOOL bRC;
    char Str[256];
 
    //
    // start enum.
    //
    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx (
        NULL,         // search pattern
        0,            // flags
        0xffffffff,   // filter
        0,            // groupid
        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
        &BufferSize,
        NULL,
        NULL,
        NULL
    );

    if( EnumHandle == NULL ) 
    {
        return( GetLastError() );
    }

    ++dwTotal;

    //
    // get more entries.
    //
    for ( ;; )
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;
    }

    *pdwTotal = dwTotal;
    
    FindCloseUrlCache(EnumHandle);

    return(ERROR_SUCCESS);
}

//=================================================================================
DWORD ProcessSimulateCache(DWORD dwNumUrls)
{
    static DWORD dwUrlNum = 0;
    DWORD Error;
    DWORD i, j;
    CHAR UrlName[ URL_NAME_SIZE ];
    TCHAR LocalFileName[MAX_PATH];
    DWORD FileSize;
    LONGLONG ExpireTime;
    FILETIME LastModTime;
    CHAR TimeBuffer[MAX_PATH];
    DWORD UrlLife;
    DWORD BufferSize;
    DWORD CacheHeaderInfoSize;

    for( i = dwUrlNum; i < (dwUrlNum + dwNumUrls); i++ ) 
    {
        //
        // make a new url name.
        //
        sprintf(UrlName, "http://serv/URL%ld", i);

        //
        // create url file.
        //
        if( !CreateUrlCacheEntry(UrlName, 0, "tmp", LocalFileName, 0 ) ) 
        {
            Error = GetLastError();
            printf( "CreateUrlFile call failed, %ld.\n", Error );
            return( Error );
        }

        //
        // set file size.
        //
        Error = SetFileSizeByName(LocalFileName, g_dwFileSize);
        if( Error != ERROR_SUCCESS ) 
        {
            printf( "SetFileSizeByName call failed, %ld.\n", Error );
            return( Error );
        }

        UrlLife = rand() % 48;

        ExpireTime = (LONGLONG)UrlLife * (LONGLONG)36000000000;
        // in 100 of nano seconds.

        LastModTime = GetGmtTime();
        ExpireTime += *((LONGLONG *)&LastModTime);

        CacheHeaderInfoSize = CACHE_HEADER_INFO_SIZE_NORMAL_MAX;

        //
        // cache this file.
        //
        if( !CommitUrlCacheEntryA(
                        UrlName,
                        LocalFileName,
                        *((FILETIME *)&ExpireTime),
                        LastModTime,
                        NORMAL_CACHE_ENTRY,
                        (LPBYTE)GlobalCacheHeaderInfo,
                        CacheHeaderInfoSize,
                        TEXT("tst"),
                        0 ) ) {
            Error = GetLastError();
            printf( "CreateUrlFile call failed, %ld.\n", Error );
            return( Error );
        }

    }
    dwUrlNum = i;   // Save last for next call

    return( ERROR_SUCCESS );
}

//---------------------------------------------------------------------
void Display_Usage(const char *szApp)
{
    printf("Usage: %s [Options]\r\n\n", szApp);
    printf("Options:\r\n");
    printf("\t-f#   File size of cache entries in bytes.\r\n");
    printf("\t-i#   Initial number of entries to create\r\n");
    printf("\t-n#   Number of entries to create before checking total.\r\n");
    printf("\t-v    Turn on verbose output.\r\n");
}

//---------------------------------------------------------------------
BOOL ParseCommandLine(int argcIn, char *argvIn[])
{
    BOOL bRC = TRUE;
    int argc = argcIn;
    char **argv = argvIn;

    argv++; argc--;
    while( argc > 0 && argv[0][0] == '-' )  
    {
        switch (argv[0][1]) 
        {
            case 'f':
                g_dwFileSize = atoi(&argv[0][2]);
                break;
            case 'i':
                g_dwInitEntries= atoi(&argv[0][2]);
                break;
            case 'n':
                g_dwNumEntries = atoi(&argv[0][2]);
                break;
            case 'v':
                g_bVerbose = TRUE;
                break;
            case '?':
                bRC = FALSE;
                break;
            default:
                bRC = FALSE;
                break;
        }
        argv++; argc--;
    }

    if(bRC == FALSE)
    {
        Display_Usage(argvIn[0]);
        bRC = FALSE;
    }

    return(bRC);

}

//=================================================================================
void __cdecl main(int argc,char *argv[])
{

    DWORD Error;
    DWORD i;
    DWORD dwEntries = 0;
    DWORD dwOldEntries = 0;

    if(!ParseCommandLine(argc, argv))
        return;
    
    //
    // init GlobalCacheHeaderInfo buffer.
    //
    for( i = 0; i < CACHE_HEADER_INFO_SIZE; i++) {
        GlobalCacheHeaderInfo[i] = (BYTE)((DWORD)'0' + i % 10);
    }

    if(g_bVerbose)
        printf("FileSize=%d InitEntries=%d NumEntries=%d\r\n", g_dwFileSize, g_dwInitEntries, g_dwNumEntries);

    if(g_dwInitEntries)
        ProcessSimulateCache(g_dwInitEntries);
        
    while(TRUE)
    {
        ProcessSimulateCache(g_dwNumEntries);
        
        dwOldEntries = dwEntries;
        EnumUrlCacheEntries(&dwEntries);
        if(dwEntries < dwOldEntries)    // Quota has been exceeded
            break;

        if(g_bVerbose)
            printf("Entries=%d\r\n", dwEntries);
    }

    printf("setperfmode on\n");
    printf("setquietmode on\n");
    printf("setfilesize %d\n", g_dwFileSize);
    printf("simcache %d\n", dwOldEntries - 4);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hist\history.h ===
// history.

typedef struct _zHISTORY_ITEM_INFO {
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hist\histapi.c ===
#include <windows.h>
#include <stdio.h>
#include <urlcache.h>
#include <histapi.h>

//#include "cache.hxx"

//#include "history.h"
#include "generic.h"

#define DEFAULT_CEI_BUFFER_SIZE		512
	// 1k ~> sizeof (CEI) + lpszSourceUrlName + lpHeaderInfo(~<255) + lpszLocalFileName(<255)

#define ASSERT(x) if (!(x)) DebugBreak();

LPCTSTR lpszHistoryPrefix = "Hist:";
DWORD cbHistoryPrefix = sizeof("Hist:") -1;

LPCTSTR lpszTitleHeader = "Title: ";
DWORD cbTitleHeader = sizeof("Title: ") -1;

LPCTSTR lpszFragmentHeader = "Frags: ";
DWORD cbFragmentHeader = sizeof("Frags: ") -1;

LPCTSTR lpszHistoryFileExtension = "HSD";

LPTSTR szCRLF = "\r\n";
DWORD cbCRLF = sizeof("\r\n") -1;
LPTSTR szSPC = " ";
LPTSTR szPND = "#";
LPTSTR szFRAGB = " (#";
LPTSTR szFRAGE = ")";

typedef struct _HISTORY_SEARCH_OBJ 
{
	HANDLE hEnum;
	LPTSTR lpszPrefixedUrl;
	LPTSTR lpszFragment;
	LPCACHE_ENTRY_INFO lpCEI;
	LPTSTR *aFrags;
	DWORD cFrags;
	DWORD iFrags;
} HISTORY_SEARCH_OBJ, *LPHISTORY_SEARCH_OBJ;

typedef struct _HISTORY_ITEM_INFO 
{
    DWORD dwVersion;		//Version of History System
    LPSTR lpszSourceUrlName;    // embedded pointer to the URL name string.
	DWORD HistoryItemType;       // cache type bit mask.  
    FILETIME LastAccessTime;    // last accessed time in GMT format
    LPSTR lpszTitle;			// embedded pointer to the History-Title: info.
	LPSTR lpszDependancies;	// list of URLs that this page requires to be functional, SPC delimited
    DWORD dwReserved;           // reserved for future use.
} HISTORY_ITEM_INFO, *LPHISTORY_ITEM_INFO;



LPTSTR
GetDependanciesFromCEI (LPCACHE_ENTRY_INFO lpCEI)
{
	LPTSTR buf = NULL;
	HANDLE file = NULL;
	DWORD size = 0;
	LPTSTR pch = NULL;

	ASSERT (lpCEI);

	file = CreateFile(lpCEI->lpszLocalFileName,
		GENERIC_READ,
		FILE_SHARE_READ,
		NULL,
		OPEN_EXISTING,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (file == INVALID_HANDLE_VALUE)
		return NULL;

	size = GetFileSize(file, NULL);

	buf = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!buf)
	{
		CloseHandle(file);
		return NULL;
	}

	buf[size] = '\0';

//  we are going to store these as URL\nURL\nURL\n so just look for \n and replace with space

	for (pch = buf; *pch; pch++)
	{
		if (*pch == '\n')
			*pch = ' ';
	}

	CloseHandle (file);
	return buf;
}

LPTSTR
MakeDependanciesFile (LPCTSTR lpszDeps)
{
	HANDLE file = NULL;
	LPTSTR pch = NULL;
	LPTSTR path = NULL;
	LPTSTR temp = NULL;
	DWORD size = 0;

	path = _tempnam (NULL, "HS");
	if (!path)
		return NULL;

	file = CreateFile(path,
		GENERIC_WRITE,
		0,
		NULL,
		CREATE_ALWAYS,
		FILE_ATTRIBUTE_NORMAL,
		NULL);
	if (file == INVALID_HANDLE_VALUE)
	{
		LocalFree (path);
		return NULL;
	}

//  we are going to store these as URL\nURL\nURL\n 
	
	if(lpszDeps)
	{
		size = lstrlen (lpszDeps);

		temp = LocalAlloc (LPTR, size + 1);
		if (!temp)
		{
			LocalFree (path);
			CloseHandle (file);
			return NULL;
		}

		lstrcpy (temp, lpszDeps);

		for (pch = temp; *pch; pch++)
		{
			if (*pch == ' ')
				*pch = '\n';
		}

		WriteFile (file, temp, size, &size, NULL);
	}

	CloseHandle (file);
	return path;
}

LPTSTR
ConvertToUnprefixedUrl (
						LPCTSTR lpszPrefixedUrl,
						LPCTSTR lpszFragment
						)
{
	DWORD size = 0;
	LPTSTR lpszUrl = NULL;
	LPTSTR temp = NULL;

	temp = (LPTSTR) (lpszPrefixedUrl + cbHistoryPrefix) ;

	size = lstrlen(temp);

	if (lpszFragment)
	{
		size += lstrlen (lpszFragment);
		size += 1;	// for the fragment '#'
	}

	lpszUrl = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!lpszUrl)
		return NULL;

	lstrcpy (lpszUrl, temp);

	if (lpszFragment)
	{
		lstrcat (lpszUrl, szPND);
		lstrcat (lpszUrl, lpszFragment);
	}

	return lpszUrl;
}

BOOL
ConvertToPrefixedUrl (IN LPCTSTR lpszUrlName, 
					  OUT LPTSTR *lplpszPrefixedUrl, 
					  OUT LPTSTR *lplpszFragment)
{
	if (!lpszUrlName || !*lpszUrlName)
	{
		*lplpszPrefixedUrl = (LPTSTR) LocalAlloc (LPTR, cbHistoryPrefix + 1);
		if (!*lplpszPrefixedUrl)
			return FALSE;

		lstrcpy (*lplpszPrefixedUrl, lpszHistoryPrefix);
		return TRUE;
	}

	*lplpszPrefixedUrl = (LPTSTR) LocalAlloc (LPTR, cbHistoryPrefix + strlen (lpszUrlName) + 1);
	if (!*lplpszPrefixedUrl)
		return FALSE;

	lstrcpy (*lplpszPrefixedUrl, lpszHistoryPrefix);
	lstrcat (*lplpszPrefixedUrl, lpszUrlName);

	*lplpszFragment = strchr (*lplpszPrefixedUrl, '#');
	if(*lplpszFragment)
		*((*lplpszFragment)++) = '\0';

	return TRUE;
}

LPCACHE_ENTRY_INFO
RetrievePrefixedUrl (IN LPTSTR lpszUrl)
/*++

  The CEI returned must be freed and the lpszUrl unlocked
  
--*/
{
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
		return NULL;

	cbCEI = DEFAULT_CEI_BUFFER_SIZE;

	while (!RetrieveUrlCacheEntryFile (lpszUrl, 
								lpCEI,
								&cbCEI,
								0))
	{
		if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY)
		{
			LocalFree (lpCEI);

			lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
			if (!lpCEI)
				return NULL;

		}
		else 
			return NULL;
	}

	return lpCEI;
}


LPCACHE_ENTRY_INFO
RetrievePrefixedUrlInfo (IN LPTSTR lpszUrl)
/*++

  The CEI returned must be freed and the lpszUrl unlocked
  
--*/
{
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
		return NULL;

	cbCEI = DEFAULT_CEI_BUFFER_SIZE;

	while (!GetUrlCacheEntryInfo (lpszUrl, 
								lpCEI,
								&cbCEI
								))
	{
		if (GetLastError () == ERROR_NOT_ENOUGH_MEMORY)
		{
			LocalFree (lpCEI);

			lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
			if (!lpCEI)
				return NULL;

		}
		else 
			return NULL;
	}

	return lpCEI;
}

LPTSTR
GetTitleFromCEI (IN LPCACHE_ENTRY_INFO lpCEI, LPCTSTR lpszFragment)
{
	LPTSTR pHeader, pCurr;
	DWORD size = 0;

	pHeader = (LPTSTR) MemFind ((LPVOID) lpCEI->lpHeaderInfo, 
		lpCEI->dwHeaderInfoSize, 
		(LPVOID) lpszTitleHeader, 
		cbTitleHeader);
	if (!pHeader)
	{
		SetLastError (ERROR_FILE_NOT_FOUND);
		return NULL;
	}

	//Header was found

		
	pCurr = (LPTSTR) MemFind ( (LPVOID) pHeader,
		(lpCEI->dwHeaderInfoSize) - ((DWORD) (pHeader - (LPTSTR)lpCEI->lpHeaderInfo)), 
		(LPVOID) szCRLF, 
		cbCRLF);
	if (!pCurr)
	{
		// BUGBUG do what now?? found the header, but the title is not in a recognized
		// format.  lets bail with a internal prob
		ASSERT (FALSE);
		SetLastError (ERROR_FILE_NOT_FOUND);
		return NULL;
	}

	*pCurr = '\0';

	pCurr = pHeader + cbTitleHeader;
	while (*pCurr == ' ')
		pCurr++;

	size = lstrlen (pCurr) ;

	if (lpszFragment)	//must also include the fragment in Title
		size += lstrlen (lpszFragment) + 4;

	pHeader = (LPTSTR) LocalAlloc (LPTR, size + 1);
	if (!pHeader)
		return NULL;
	
	lstrcpy (pHeader, pCurr);

	if (lpszFragment)
	{
		lstrcat (pHeader, szFRAGB);
		lstrcat (pHeader, lpszFragment);
		lstrcat (pHeader, szFRAGE);
	}

	return pHeader;
		
}


DWORD
GetFragmentsFromCEI(IN LPCACHE_ENTRY_INFO lpCEI, 
						  OUT LPTSTR **paFrags, 
						  OUT DWORD *pcFrags)
{
	LPTSTR pHeader, pCurr;

	//need to get the string from the CEI, then parse into args
	pHeader = (LPTSTR) MemFind (lpCEI->lpHeaderInfo, 
		lpCEI->dwHeaderInfoSize, 
		(LPVOID) lpszFragmentHeader, 
		cbFragmentHeader);
	if (!pHeader)
		return ERROR_FILE_NOT_FOUND;

	//Header was found

		
	pCurr = (LPTSTR) MemFind ( (LPVOID) pHeader,
		lpCEI->dwHeaderInfoSize - (pHeader - lpCEI->lpHeaderInfo), 
		(LPVOID) szCRLF, 
		cbCRLF);
	if (!pCurr)
	{
		//this is a corrupted Entry
		ASSERT (FALSE);
		return ERROR_FILE_NOT_FOUND;
	}

	*pCurr = '\0';

	//
	//	pHeader is now  zero terminated string
	//	we want to parse the args of that string
	//
	if (!ParseArgsDyn(pHeader + cbFragmentHeader, paFrags, pcFrags))
		return ERROR_NOT_ENOUGH_MEMORY;

	return ERROR_SUCCESS;

}

LPBYTE
GenerateHeaderInfo(LPCTSTR lpszTitle, LPCTSTR *aFrags, DWORD cFrags)
{
	DWORD size = 0;
	LPBYTE hi = NULL;
	LPTSTR curr;
	DWORD i;

	//first need to find the size required of HeaderInfo
	if (lpszTitle)
	{
		size += lstrlen (lpszTitle);
		size += cbTitleHeader;
		size += cbCRLF;
	}

	if (cFrags)
	{
		size += cbFragmentHeader;
		size += cFrags;

		for (i = 0; i < cFrags; i++)
			size += lstrlen(aFrags[i]);

		size += cbCRLF;
	}
	
	hi = (LPBYTE) LocalAlloc (LPTR, ++size);
	if (!hi)
		return NULL;

	curr = (LPTSTR) hi;
	*curr = '\0';


	if (lpszTitle)
	{
		lstrcat (curr, lpszTitleHeader);
		lstrcat (curr, lpszTitle);
		lstrcat (curr, szCRLF);
	}

	if (cFrags)
	{
		lstrcat (curr, lpszFragmentHeader);

		for(i = 0; i < cFrags; i++)
		{
			if (!*(aFrags[i]))
				continue;

			lstrcat(curr, szSPC);
			lstrcat(curr, aFrags[i]);
		}
		lstrcat (curr, szCRLF);
	}

	return hi;
}

DWORD
CopyCEItoHII (
			  LPCTSTR lpszFragment,
			  LPHISTORY_ITEM_INFO lpHII,
			  LPDWORD lpcbHII,
			  LPCACHE_ENTRY_INFO lpCEI
			  )
{
	DWORD Error = ERROR_SUCCESS;
	DWORD cbNeeded = sizeof (HISTORY_ITEM_INFO);
	DWORD cbUsed = cbNeeded;
	LPTSTR lpszUrl = NULL;
	DWORD cbUrl  = 0;
	LPTSTR lpszTitle = NULL;
	DWORD cbTitle = 0;
	LPTSTR lpszDependancies = NULL;
	DWORD cbDependancies = 0;


	ASSERT (lpCEI->lpszSourceUrlName);
//
//	need to determine the necessary size
//

	// need the unprefixed name

	lpszUrl = ConvertToUnprefixedUrl (lpCEI->lpszSourceUrlName, (LPCTSTR) lpszFragment);
	if (!lpszUrl)
	{
		Error = ERROR_INTERNAL_ERROR;
		goto quit;
	}
	cbUrl = lstrlen (lpszUrl);

	cbNeeded += cbUrl + 1;
	
	
	lpszTitle = GetTitleFromCEI (lpCEI, (LPCTSTR) lpszFragment);
	if (lpszTitle)
	{
		cbTitle = lstrlen (lpszTitle);
		cbNeeded += cbTitle + 1;
	}

	lpszDependancies = GetDependanciesFromCEI (lpCEI);
	if (lpszDependancies)
	{
		cbDependancies = lstrlen (lpszDependancies);
		cbNeeded += cbDependancies + 1;
	}

	if (cbNeeded > *lpcbHII)
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		*lpcbHII = cbNeeded;
		goto quit;
	}
	
//
//	Add the other pieces
//

	lpHII->lpszSourceUrlName = (LPTSTR) (lpHII + cbUsed + 1);
	lstrcpy (lpHII->lpszSourceUrlName, lpszUrl);
	cbUsed += cbUrl + 1;

	if (lpszTitle)
	{
		lpHII->lpszTitle = (LPTSTR) (lpHII + cbUsed + 1);
		lstrcpy (lpHII->lpszTitle, lpszTitle);
		cbUsed += cbTitle + 1;
	}
	else 
		lpHII->lpszTitle = NULL;

	if (lpszDependancies)
	{
		lpHII->lpszDependancies = (LPTSTR) (lpHII + cbUsed + 1);
		lstrcpy (lpHII->lpszDependancies, lpszDependancies);
		cbUsed += cbDependancies + 1;
	}
	else 
		lpHII->lpszDependancies = NULL;

	lpHII->dwVersion = lpCEI->dwVersion;
	lpHII->HistoryItemType = lpCEI->CacheEntryType;
	lpHII->LastAccessTime.dwLowDateTime = lpCEI->LastAccessTime.dwLowDateTime;
	lpHII->LastAccessTime.dwHighDateTime = lpCEI->LastAccessTime.dwHighDateTime;
	lpHII->dwReserved = lpCEI->dwReserved;

quit:

	if (lpszUrl)
		LocalFree(lpszUrl);

	if (lpszTitle)
		LocalFree(lpszTitle);

	if (lpszDependancies)
		LocalFree(lpszDependancies);

	if (Error == ERROR_SUCCESS)
		*lpcbHII = cbUsed;
	
	return Error;
}




HISTORYAPI_(BOOL)
AddHistoryItem(
    IN LPCTSTR lpszUrlName,		//direct correspondence in URLCACHE
    IN LPCTSTR lpszHistoryTitle,		// this needs to be added to lpHeaderInfo
	IN LPCTSTR lpszDependancies,
	IN DWORD dwFlags,
    IN DWORD dwReserved
    )		
/*++

Routine Description:
	
	Places the specified URL into the history.
	
	If it does not exist, then it is created.  If it does exist it is overwritten.

Arguments:

    lpszUrlName			- The URL in question.

    lpszHistoryTitle	- pointer to the friendly title that should be associated
						with this URL. If NULL, no title will be added.

    Reserved			- Unused, for future implementations

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Extended error can be retrieved from GetLastError()

--*/


{
	LPBYTE NewHeaderInfo = NULL;
	DWORD cbNHI = 0;
	BOOL New = FALSE;
	
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	FILETIME ftExpires;
	FILETIME ftModified;
	SYSTEMTIME st;
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;
	BOOL found = FALSE;
	LPTSTR lpszDepsPath = NULL;
	DWORD type = NORMAL_CACHE_ENTRY;
	LPTSTR lpszOldTitle = NULL;


	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}

	lpCEI = RetrievePrefixedUrl (lpszPrefixedUrl);
	if (!lpCEI)
		New = TRUE;

	
	//  Buffer filled with data now
	//  BUGBUG must handle fragments

	if (!New)
	{
		type = lpCEI->CacheEntryType;
		GetFragmentsFromCEI (lpCEI, &aFrags, &cFrags);
		lpszOldTitle = GetTitleFromCEI (lpCEI, NULL);
	}

//	if (Error != ERROR_SUCCESS)

	if (lpszFragment)
	{
		for (i = 0; i < cFrags; i++)
		{
			if (lstrcmp (aFrags[i], lpszFragment) == 0)
			{
				found = TRUE;
				break;
			}
		}
		if (!found)
			AddArgvDyn (&aFrags, &cFrags, lpszFragment);
	}

	NewHeaderInfo = GenerateHeaderInfo (lpszHistoryTitle ? lpszHistoryTitle : lpszOldTitle, aFrags, cFrags);	
	cbNHI = lstrlen (NewHeaderInfo);

	lpszDepsPath = MakeDependanciesFile (lpszDependancies);
	if (!lpszDepsPath)
	{
		ASSERT(FALSE);
		Error = ERROR_INTERNAL_ERROR;
		goto quit;
	}

	GetLocalTime (&st);
	SystemTimeToFileTime(&st, &ftModified);

	st.wDay += 7;	//BUGBUG must get this setting from registry
	if(!SystemTimeToFileTime(&st, &ftExpires))
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
		lpCEI = NULL;
	}

	if (!CommitUrlCacheEntry(
		lpszPrefixedUrl,
		lpszDepsPath,	
		ftExpires,	
		ftModified,								//we dont care about last modified time
		type,	//this is set from dwFlags i think
		NewHeaderInfo,
		cbNHI ,
		lpszHistoryFileExtension,
		0))
	{
		Error = GetLastError ();
		goto quit;
	}
	// if we made it to here, we win!

quit:

	if (aFrags)
		LocalFree (aFrags);

	if (lpszDepsPath)
		LocalFree (lpszDepsPath);

	if (lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
	}

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (NewHeaderInfo)
		LocalFree (NewHeaderInfo);

	if (lpszOldTitle)
		LocalFree (lpszOldTitle);

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}

	

HISTORYAPI_(BOOL)
IsHistorical(
    IN LPCTSTR lpszUrlName
    )

/*++

Routine Description:
	
	Checks to see if Url is a valid History item

Arguments:

    lpszUrlName			- The URL in question.

Return Value:

    BOOL
        Success		- TRUE.  Item is in History

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_FILE_NOT_FOUND indicates the URL is not available
					

--*/

{
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrlInfo (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpszFragment)
	{

//
//	Need to check for IntraDocFrags
//

		Error = GetFragmentsFromCEI(lpCEI, & aFrags, & cFrags);
		if (Error != ERROR_SUCCESS)
			goto quit;

		for (i = 0; i < cFrags; i++)
		{
			if (strcmp(aFrags[i], lpszFragment) == 0)
				goto quit;
		}
		
		Error = ERROR_FILE_NOT_FOUND;
	}

quit:
	
	if (aFrags)
		LocalFree (aFrags);

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}



HISTORYAPI_(BOOL)
RemoveHistoryItem (
    IN LPCTSTR lpszUrlName,
    IN DWORD dwReserved
    )
/*++

Routine Description:
	
	Changes an entry from an History Item to a normal cache entry.  Removing
	the Title at the same time.

Arguments:

    lpszUrlName			- The URL in question.

    dwReserved			- Unused.  for future usage

Return Value:

    BOOL
        Success		- TRUE.  Item found and removed

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_FILE_NOT_FOUND indicates the URL is not available
					

--*/
{
	LPTSTR *aFrags = NULL;
	DWORD cFrags = 0;
	DWORD i;
	LPTSTR lpszTitle = NULL;
	LPBYTE NewHeaderInfo = NULL;
	
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrl (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	if (lpszFragment)
	{
		BOOL found = FALSE;
//
//	Need to check for IntraDocFrags
//

		Error = GetFragmentsFromCEI(lpCEI, & aFrags, & cFrags);
		if (Error != ERROR_SUCCESS)
			goto quit;

		for (i = 0; i < cFrags; i++)
		{
			if (strcmp(aFrags[i], lpszFragment) == 0)
			{
				//we need to delete this and reinsert

				*(aFrags[i]) = '\0';
				found = TRUE;
				break;
			}
		}	

		if (cFrags - 1 && found)
		{
			lpszTitle = GetTitleFromCEI (lpCEI, NULL);
			
			NewHeaderInfo = GenerateHeaderInfo (lpszTitle, aFrags, cFrags);

			if(!NewHeaderInfo)
			{
				Error = ERROR_NOT_ENOUGH_MEMORY;
				goto quit;
			}

			UnlockUrlCacheEntryFile(lpCEI->lpszSourceUrlName, 0);

			if (!CommitUrlCacheEntry(
				lpszPrefixedUrl,
				lpCEI->lpszLocalFileName,
				lpCEI->ExpireTime,
				lpCEI->LastModifiedTime,
				lpCEI->CacheEntryType ,		// only changes
				NewHeaderInfo,	// 
				lstrlen (NewHeaderInfo),
				lpCEI->lpszFileExtension,
				0))
			{
				Error = GetLastError ();
			}
			goto quit;
		}

		if (!found)
		{
			Error = ERROR_FILE_NOT_FOUND;
			goto quit;
		}
	}
//BUGBUG  looks like this will always delete a history item if there is only fragment
	//problem is we could have a frag and a unfragged Item
	UnlockUrlCacheEntryFile(lpCEI->lpszSourceUrlName, 0);

	if (!DeleteUrlCacheEntry(lpszPrefixedUrl))
	{
		Error = GetLastError ();
		goto quit;
	}



quit:
	if (aFrags)
		LocalFree (aFrags);

	if (lpszTitle)
		LocalFree (lpszTitle);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (NewHeaderInfo)
		LocalFree (NewHeaderInfo);

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(BOOL)
GetHistoryItemInfo (
    IN LPCTSTR lpszUrlName,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    )
/*++

Routine Description:
	
	Fills a buffer with a HISTORY_ITEM_INFO struct.

Arguments:

    lpszUrlName			- The URL in question.

    lpHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    BOOL
        Success		- TRUE.  

        Failure		- FALSE. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/


{
	LPTSTR lpszPrefixedUrl = NULL;
	LPTSTR lpszFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlName, &lpszPrefixedUrl, &lpszFragment))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}


	lpCEI = RetrievePrefixedUrlInfo (lpszPrefixedUrl);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}
	

	Error = CopyCEItoHII (lpszFragment, lpHistoryItemInfo, lpdwHistoryItemInfoBufferSize, lpCEI);

	

quit:

	if (lpszPrefixedUrl)
		LocalFree (lpszPrefixedUrl);

	if (lpCEI)
	{
		LocalFree (lpCEI);
	}

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(HANDLE)
FindFirstHistoryItem(
    IN LPCTSTR  lpszUrlSearchPattern,
    OUT LPHISTORY_ITEM_INFO lpFirstHistoryItemInfo,
    IN OUT LPDWORD lpdwFirstHistoryItemInfoBufferSize
    )

/*++

Routine Description:
	
	Searches through the History looking for URLs that match the search pattern,
	and copies the HISTORY_ITEM_INFO into the buffer.

Arguments:

    lpszUrlSearchPattern	- The URL in question.

    lpFirstHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwFirstHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    HANDLE
        Success		- Valid enumeration handle to pass into subsequent calls to
					FindNextHistoryItem ().

        Failure		- NULL. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/

{
	LPHISTORY_SEARCH_OBJ hso = NULL;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;
	LPTSTR lpszFoundFragment = NULL;
	DWORD Error = ERROR_SUCCESS;
	BOOL found = FALSE;

	hso = (LPHISTORY_SEARCH_OBJ) LocalAlloc (LPTR, sizeof (HISTORY_SEARCH_OBJ));
	if (!hso)
	{
		Error = GetLastError ();
		goto quit;
	}

	hso->aFrags = NULL;
	hso->cFrags = 0;
	hso->iFrags = 0;
	hso->lpszPrefixedUrl = NULL;
	hso->lpszFragment = NULL;

	if (!ConvertToPrefixedUrl (lpszUrlSearchPattern, &(hso->lpszPrefixedUrl), &(hso->lpszFragment)))
	{
		Error = ERROR_NOT_ENOUGH_MEMORY;
		goto quit;
	}

	lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);
	if (!lpCEI)
	{
		Error = GetLastError ();
		goto quit;
	}

	while (TRUE)
	{
		hso->hEnum = FindFirstUrlCacheEntry (hso->lpszPrefixedUrl,
			lpCEI,
			&cbCEI);

		if (!hso->hEnum)
		{
			Error = GetLastError ();
			if (Error == ERROR_NOT_ENOUGH_MEMORY)
			{
				LocalFree (lpCEI);

				lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
				if (!lpCEI)
				{
					Error = ERROR_INTERNAL_ERROR;
					goto quit;
				}
			}
			else 
				goto quit;
		}
		else break;
	}
	
	found = TRUE;	

	//BUGBUG have to handle enum of fragments
	Error = GetFragmentsFromCEI (lpCEI, &(hso->aFrags), &(hso->cFrags));
	switch (Error)
	{
	case ERROR_FILE_NOT_FOUND:	//only the default URL is used
		Error = ERROR_SUCCESS;
		break;

	case ERROR_SUCCESS:			//first return the default URL next call will get frags
		hso->lpCEI = lpCEI;
		break;

	default:
		goto quit;
		break;
	}

	if (hso->lpszFragment)
	{
		found = FALSE;

		for (; hso->iFrags < hso->cFrags; hso->iFrags++)
		{
			if (strncmp (hso->aFrags[hso->iFrags], hso->lpszFragment, lstrlen (hso->lpszFragment)) == 0)
			{
				found = TRUE;
				lpszFoundFragment = hso->aFrags[hso->iFrags];
				break;
			}
		}
	}

	if (!found)
	{
		Error = ERROR_FILE_NOT_FOUND;
		goto quit;
	}

	Error = CopyCEItoHII (
		lpszFoundFragment,
		lpFirstHistoryItemInfo,
		lpdwFirstHistoryItemInfoBufferSize,
		lpCEI);

quit:

	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		
		if (hso->lpszPrefixedUrl)
			LocalFree (hso->lpszPrefixedUrl);

		if (hso->aFrags)
			LocalFree (hso->aFrags);

		if (hso->lpCEI)
		{
			UnlockUrlCacheEntryFile (hso->lpCEI->lpszSourceUrlName, 0);
			LocalFree(hso->lpCEI);
		}

		if (hso)
			LocalFree (hso);

		return NULL;
	}
	
	if (lpCEI && !hso->lpCEI)
		LocalFree (lpCEI);

	return (HANDLE) hso;

}



HISTORYAPI_(BOOL)
FindNextHistoryItem(
    IN HANDLE hEnumHandle,
    OUT LPHISTORY_ITEM_INFO lpHistoryItemInfo,
    IN OUT LPDWORD lpdwHistoryItemInfoBufferSize
    )

/*++

Routine Description:
	
	Searches through the History looking for URLs that match the search pattern,
	and copies the HISTORY_ITEM_INFO into the buffer.

Arguments:

    lpszUrlSearchPattern	- The URL in question.

    lpFirstHistoryItemInfo	- Buffer that will hold the HISTORY_ITEM_INFO

	lpdwFirstHistoryItemInfoBufferSize	- IN: size of the lpHistoryItemInfo buffer
									 OUT: size of filled struct when successful
										  or necessary buffer size when failed


Return Value:

    HANDLE
        Success		- Valid enumeration handle to pass into subsequent calls to
					FindNextHistoryItem ().

        Failure		- NULL. Extended error can be retrieved from GetLastError()
						ERROR_NOT_ENOUGH_MEMORY indicates the buffer is insufficient
					

--*/

{
	DWORD Error = ERROR_SUCCESS;
	LPCACHE_ENTRY_INFO lpCEI = NULL;
	DWORD cbCEI = 0;
	LPHISTORY_SEARCH_OBJ hso = NULL;
	BOOL found = FALSE;
	LPTSTR lpszFoundFragment;

	if (!hEnumHandle)
	{
		SetLastError (ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	hso = (LPHISTORY_SEARCH_OBJ) hEnumHandle;
	
	while (!found)
	{
		if (hso->aFrags)
		{
			//this means that there are only fragments to find
			for (lpszFoundFragment = NULL; hso->iFrags < hso->cFrags; hso->iFrags++)
			{
				if (hso->lpszFragment)
				{
					if (strncmp (hso->aFrags[hso->iFrags], hso->lpszFragment, lstrlen (hso->lpszFragment)) == 0)
					{
						found = TRUE;
						lpCEI = hso->lpCEI;
						break;
					}
				}
				else
				{
					found = TRUE;
					break;
				}
			}
			if (!found)
			{
				if (hso->lpszFragment)
				{
					Error = ERROR_FILE_NOT_FOUND;
					goto quit;
				}
				else 
				{
					//this means that we went through all the frags
					//we need to drop through and find the Cache Entry that matches
					Error = ERROR_SUCCESS;
					
					ASSERT (hso->lpCEI);
					ASSERT (hso->aFrags);
					
					lpCEI = hso->lpCEI;		//reuse the buffer if possible
					LocalFree (hso->aFrags);

					hso->lpCEI = NULL;
					hso->aFrags = NULL;
				}
			}
			else
			{
				lpszFoundFragment = hso->aFrags[hso->iFrags];
				lpCEI = hso->lpCEI;
			}
		}
		
		else
		{
			if (!lpCEI)
				lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, DEFAULT_CEI_BUFFER_SIZE);

			if (!lpCEI)
			{
				Error = ERROR_INTERNAL_ERROR;
				goto quit;
			}

			while (TRUE)
			{
				if (!FindNextUrlCacheEntry (hso->hEnum,
					lpCEI,
					&cbCEI))
				{
					Error = GetLastError ();
					if (Error == ERROR_NOT_ENOUGH_MEMORY)
					{
						LocalFree (lpCEI);

						lpCEI = (LPCACHE_ENTRY_INFO) LocalAlloc (LPTR, cbCEI);
						if (!lpCEI)
						{
							Error = ERROR_INTERNAL_ERROR;
							goto quit;
						}
					}
					else 
						goto quit;
				}
				else 
					break;
			}

			Error = GetFragmentsFromCEI (lpCEI, &(hso->aFrags), &(hso->cFrags));
			switch (Error)
			{
			case ERROR_FILE_NOT_FOUND:	//only the default URL is used
				found = TRUE;
				Error = ERROR_SUCCESS;
				break;

			case ERROR_SUCCESS:			//first return the default URL next call will get frags
				hso->lpCEI = lpCEI;
				found = TRUE;
				break;

			default:
				goto quit;
				break;
			}
		}
	}

	Error = CopyCEItoHII(
		lpszFoundFragment,
		lpHistoryItemInfo,
		lpdwHistoryItemInfoBufferSize,
		lpCEI);

quit:


	if (lpCEI && !hso->lpCEI)
	{
		UnlockUrlCacheEntryFile (lpCEI->lpszSourceUrlName, 0);
		LocalFree (lpCEI);
	}


	if (Error != ERROR_SUCCESS)
	{
		SetLastError (Error);
		return FALSE;
	}
	else 
		return TRUE;

}


HISTORYAPI_(BOOL)
FindCloseHistory (
    IN HANDLE hEnumHandle
    )

{
	LPHISTORY_SEARCH_OBJ hso;
	HANDLE hEnum;

	//possibly we should be keeping track of valid hso's i dunno
	if (!hEnumHandle)
	{
		SetLastError (ERROR_INVALID_PARAMETER);
		return FALSE;
	}

	hso = (LPHISTORY_SEARCH_OBJ) hEnumHandle;

	hEnum = hso->hEnum;

	if (hso->aFrags)
		LocalFree (hso->aFrags);

	if (hso->lpszPrefixedUrl)
		LocalFree(hso->lpszPrefixedUrl);

	if (hso->lpCEI)
	{
		LocalFree (hso->lpCEI);
	}


	LocalFree (hso);

	return FindCloseUrlCache (hEnum);
}

BOOL
DLLHistoryEntry(
    IN HINSTANCE DllHandle,
    IN DWORD Reason,
    IN LPVOID Reserved
    )
/*++

Routine Description:

    Performs global initialization and termination for all protocol modules.

    This function only handles process attach and detach which are required for
    global initialization and termination, respectively. We disable thread
    attach and detach. New threads calling Wininet APIs will get an
    INTERNET_THREAD_INFO structure created for them by the first API requiring
    this structure

Arguments:

    DllHandle   - handle of this DLL. Unused

    Reason      - process attach/detach or thread attach/detach

    Reserved    - if DLL_PROCESS_ATTACH, NULL means DLL is being dynamically
                  loaded, else static. For DLL_PROCESS_DETACH, NULL means DLL
                  is being freed as a consequence of call to FreeLibrary()
                  else the DLL is being freed as part of process termination

Return Value:

    BOOL
        Success - TRUE

        Failure - FALSE. Failed to initialize

--*/
{
    BOOL ok;
    DWORD error;

//    UNREFERENCED_PARAMETER(DllHandle);

    //
    // perform global dll initialization, if any.
    //

    switch (Reason) {
    case DLL_PROCESS_ATTACH:

//        error = DllProcessAttachDiskCache();


        //
        // we switch off thread library calls to avoid taking a hit for every
        // thread creation/termination that happens in this process, regardless
        // of whether Internet APIs are called in the thread.
        //
        // If a new thread does make Internet API calls that require a per-thread
        // structure then the individual API will create one
        //

//        DisableThreadLibraryCalls(DllHandle);
        break;

    case DLL_PROCESS_DETACH:

        if (Reserved != NULL) {
                //
                //  Only Cleanup if there is a FreeLibrary() call.
                //
            break;
        }

//        DllProcessDetachDiskCache();

        break;
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\hist\generic.h ===
//generic.h

BOOL
ParseArgsDyn(
    LPSTR InBuffer,
    LPSTR **pArgv,
    LPDWORD pArgc
    );

DWORD 
AddArgvDyn (LPTSTR **pArgv, DWORD *pArgc, LPTSTR szNew);

LPBYTE
MemFind (LPBYTE lpB, DWORD cbB, LPBYTE lpP, DWORD cbP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\test\creatcon\creatcon.cxx ===
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <wininet.h>
#include <winineti.h>

#ifndef _CRTAPI1
#define _CRTAPI1
#endif

#define IS_ARG(c)   (((c) == '-') || ((c) == '/'))

void _CRTAPI1 main(int, char**);
void usage(void);

void _CRTAPI1 main(int argc, char** argv) {

    LPSTR name = NULL;

    for (--argc, ++argv; argc; --argc, ++argv) {
        if (IS_ARG(**argv)) {
            switch (*++*argv) {
            default:
                printf("error: unrecognized command line flag: '%c'\n", **argv);
                usage();
                break;
            }
        } else if (!name) {
            name = *argv;
        } else {
            printf("error: unrecognized command line argument: \"%s\"\n", *argv);
            usage();
        }
    }

    if (!name) {
        usage();
    }

    char buffer[1024];
    DWORD buflen = sizeof(buffer);
    BOOL ok = CreateUrlCacheContainer(name,
                                      "CreatConTest",
                                      "",
                                      10,
                                      INTERNET_CACHE_CONTAINER_AUTODELETE,
                                      0,
                                      (LPVOID)buffer,
                                      &buflen
                                      );

    if (!ok) {
        printf("CreateUrlCacheContainer() returns %d\n", GetLastError());
    }
    printf("Done.\n");
    exit(0);
}

void usage() {
    printf("usage: creatcon <cache container name>\n"
           );
    exit(1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\utils\cdcache\stdhdr.h ===
// stdhdr.h
//

// Only include this stuff once
#ifndef __STDHDR_H
#define __STDHDR_H

// Windows Header Files:
#include <windows.h>
#include <tchar.h>
#include <wininet.h>
#include <winineti.h>

// C RunTime Header Files
#include <stdlib.h>
#include <malloc.h>
#include <memory.h>

// Local Header Files
#include "cdcache.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\urlcache\test\cachetst.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    cachetst.c

Abstract:

    Test program to test cache apis.

Author:

    Madan Appiah (madana)  26-Apr-1995

Environment:

    User Mode - Win32

Revision History:

--*/

#define IE5

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <tchar.h>

#include <wininet.h>
#include <winineti.h>
#include <intlgent.hxx>


#define MAX_STRING_LENGTH   128

HMODULE hModule;

//---------------------------------------------------------------------------
// Call this exported function to enable/disable logging to "intlstr.log"
//	-disabled by default
//---------------------------------------------------------------------------
FNStringLogging fnStringLogging;

//typedef void FAR PASCAL (*FNStringLogging)(BOOL bActiveState);

FNGetRandIntlString fnGetRandIntlString;

FNGetIntlString fnGetIntlString;

FNGetProbCharString fnGetProbCharString;
                    
FNGetTop20String fnGetTop20String;

FNGetProbURTCString fnGetProbURTCString;

FNGetUniStrRandAnsi fnGetUniStrRandAnsi;

FNGetUniStrInvalidAnsi fnGetUniStrInvalidAnsi;

FNGetUniStrMappedAnsi fnGetUniStrMappedAnsi;

#pragma optimize("y",off)

#define PRINTF(s) printf s;

HMODULE hModule;

#define GET_PROC_ADDRESS(x) (FN ## x) GetProcAddress(hModule, #x );
/*
int 
_CRTAPI1 
_tmain( int, TCHAR ** );
*/

//#ifdef UNICODE
#define LSTRCMPI _tcsicmp
#define LSTRLEN _tcslen
//=================================================================================
#define MAX_COMMAND_ARGS    32
#define DEFAULT_BUFFER_SIZE 1024    // 1k
#define URL_NAME_SIZE   (16 + 1)
#define URL_NAME_LENGTH     2*URL_NAME_SIZE

#define CACHE_ENTRY_BUFFER_SIZE (1024 * 5)
#define CACHE_DATA_BUFFER_SIZE 1024

#define CACHE_HEADER_INFO_SIZE  2048
#define CACHE_HEADER_INFO_SIZE_NORMAL_MAX   256
#define CACHE_HEADER_INFO_SIZE_BIG_MAX      512

#define RESET_TIMER TRUE
#define ACCUM_TIMER FALSE

#define GENERIC_0 0
#define FILE_SHARE_NONE 0
//=================================================================================
typedef struct _PERF_INFO {
    DWORD ElapsedTime;
    DWORD TotalElapsedTime;
    DWORD TickCount;
    BOOL PrintResults;
} PERF_INFO, *LPPERF_INFO;

// The order of these must match the order in GlobalCommandInfo[]
typedef enum _COMMAND_CODE {
    CmdCreateUrlCacheEntry,
    CmdCommitUrlCacheEntry,
    CmdUpdateUrlCacheEntry,
    CmdRetrieveUrlCacheEntryFile,
    CmdRetrieveUrlCacheEntryStream,
#ifdef IE5
    CmdUnlockUrlCacheEntryFile,
#endif
    CmdGetUrlCacheEntryInfo,
    CmdSetUrlCacheEntryInfo,
#ifdef IE5
    CmdSetUrlCacheEntryGroup,
#endif
    CmdSetExempt,
#ifdef IE5
    CmdDeleteUrlCacheEntry,
#endif
    CmdEnumUrlCacheEntries,
    CmdEnumGroup,
    CmdSimulateCache,
    CmdCreateFile,
    CmdFreeCacheSpace,
    CmdUseFile,
    CmdShowTime,
    CmdLoopCnt,
    CmdCmdLoopCnt,
    CmdSetFileSize,
    CmdSetDiskCache1,
    CmdSetDiskCache2,
    CmdSetQuietMode,
    CmdSetPerfMode,
    CmdWriteFile,
    CmdCreateGroup,
    CmdDeleteGroup,
    CmdGetExQ,
    CmdHelp,
    CmdQuit,
    UnknownCommand
} COMMAND_CODE, *LPCOMMAND_CODE;

typedef struct _COMMAND_INFO {
    LPTSTR CommandName;
    LPTSTR AltCommandName;
    LPTSTR CommandParams;
    COMMAND_CODE CommandCode;
    PERF_INFO PerfInfo;
} COMMAND_INFO, *LPCOMMAND_INFO;

typedef struct _CREATE_FILE_INFO
{
    LPTSTR lpszVal;
    DWORD dwVal;
    DWORD *pdwArg;
    BOOL bExclusive;    // TRUE = Only one value can be used, FALSE - Any combination of values for given argument
} CREATE_FILE_INFO, *LPCREATE_FILE_INFO;

DWORD
CreateRandomString(
                    DWORD Size,
                    LPTSTR  szString);

VOID
MakeRandomUrlName(
    LPTSTR UrlName
    );
//=================================================================================
DWORD g_dwCreate_File_Access_Mode = GENERIC_0;
DWORD g_dwCreate_File_Share_Mode = FILE_SHARE_NONE;
DWORD g_dwCreate_File_Creation = OPEN_EXISTING;
DWORD g_dwCreate_File_Flags = FILE_ATTRIBUTE_NORMAL;
BYTE GlobalCacheEntryInfoBuffer[CACHE_ENTRY_BUFFER_SIZE];
BYTE GlobalCacheDataBuffer[CACHE_DATA_BUFFER_SIZE];
BYTE GlobalCacheHeaderInfo[CACHE_HEADER_INFO_SIZE];
FILE *UrlList = NULL;
TCHAR UrlBuffer[DEFAULT_BUFFER_SIZE];
LPTSTR UrlListKey = _T( "url:" );
LPTSTR g_lpWriteFileBuf = NULL;
FILE *DumpUrlList = NULL;
DWORD cCommands = 0;
DWORD cFails = 0;
DWORD g_dwNumIterations = 1;
DWORD g_dwIteration = 0;
DWORD g_dwNumCmdIterations = 1;
DWORD g_dwCmdIteration = 0;
DWORD g_dwFileSize = 0;
DWORD g_dwDiskCache = 0;
BOOL g_bWriteFile = FALSE;
BOOL g_bQuietMode = FALSE;
BOOL g_bPerfMode = FALSE;
BOOL g_bUseFile = FALSE;
PERF_INFO AppTimer;

COMMAND_INFO GlobalCommandInfo[] = {
    {_T( "Create" ),          _T( "cr" ), _T( "( UrlName | \"<rand>\" ) <ExpectedSize>\n " ), CmdCreateUrlCacheEntry, {0, 0, 0} },
    {_T( "Commit" ),          _T( "co" ), _T( "( UrlName | \"<rand>\" ) ( LocalFileName | \"<rand>\" ) <ExpireTime (in hours from now)>" ), CmdCommitUrlCacheEntry, {0, 0, 0} },
    {_T( "Update" ),          _T( "co" ), _T( "( UrlName | \"<rand>\" )" ), CmdUpdateUrlCacheEntry, {0, 0, 0} },
    {_T( "GetFile" ),         _T( "gf" ), _T( "( UrlName | \"<rand>\" )" ), CmdRetrieveUrlCacheEntryFile, {0, 0, 0} },
    {_T( "GetStream" ),       _T( "gs" ), _T( "( UrlName | \"<rand>\" ) [NoRead]"), CmdRetrieveUrlCacheEntryStream, {0, 0, 0} },
#ifdef IE5
    {_T( "UnlockFile" ),      _T( "uf" ), _T( "( UrlName | \"<rand>\" )" ), CmdUnlockUrlCacheEntryFile, {0, 0, 0} },
#endif
    {_T( "GetInfo" ),         _T( "gi" ), _T( "( UrlName | \"<rand>\" )" ), CmdGetUrlCacheEntryInfo, {0, 0, 0} },
    {_T( "SetInfo" ),         _T( "si" ), _T( "( UrlName | \"<rand>\" ) <ExpireTime (in hours from now)>" ), CmdSetUrlCacheEntryInfo, {0, 0, 0} },
#ifdef IE5
    {_T( "SetGroup" ),        _T( "sg" ), _T( "( UrlName | \"<rand>\" ) Flags GroupId" ), CmdSetUrlCacheEntryGroup, {0, 0, 0} },
#endif
    {_T( "SetExempt" ),       _T( "se" ), _T( "( UrlName | \"<rand>\" ) Exempt-Seconds"), CmdSetExempt, {0, 0, 0}},
#ifdef IE5
    {_T( "Delete" ),          _T( "d" ),  _T( "( UrlName | \"<rand>\" )" ), CmdDeleteUrlCacheEntry, {0, 0, 0} },
#endif
    {_T( "Enum" ),            _T( "e" ),  _T( "<q (quiet mode)>" ), CmdEnumUrlCacheEntries, {0, 0, 0} },
    {_T( "EnumGroup" ),       _T( "eg" ), _T( "GroupId" ), CmdEnumGroup, {0, 0, 0} },
    {_T( "SimCache" ),        _T( "sc" ), _T( "NumUrls <q (quiet mode)>" ), CmdSimulateCache, {0, 0, 0} },
    {_T( "CreateFile" ),      _T( "cf" ), _T( "FileName AccessMode ShareMode Creation FlagsAttrs" ), CmdCreateFile, {0, 0, 0} },
    {_T( "Free" ),            _T( "f" ),  _T( "CachePercent (0 to 100, history, cookies)"), CmdFreeCacheSpace, {0, 0, 0} },
    {_T( "UseFile" ),         _T( "use" ),_T( "FilePath (text file with one command per line)" ), CmdUseFile, {0, 0, 0} },
    {_T( "ShowTime" ),        _T( "st" ), _T( "HHHHHHHH LLLLLLLL (Hex HighDateTime and LowDateTime)" ), CmdShowTime, {0, 0, 0} },
    {_T( "SetLoopCnt" ),      _T( "slc" ),_T( "NumInterations" ), CmdLoopCnt, {0, 0, 0} },
    {_T( "SetCmdLoopCnt" ),   _T( "scc" ),_T( "NumInterations" ), CmdCmdLoopCnt, {0, 0, 0} },
    {_T( "SetFileSize" ),     _T( "sfs" ),_T( "NumBytes (0 = random size)" ), CmdSetFileSize, {0, 0, 0} },
    {_T( "SetNoBuffering" ),  _T( "snb" ),_T( "On|Off"), CmdSetDiskCache1, {0, 0, 0} },
    {_T( "SetWriteThrough" ), _T( "swt" ),_T( "On|Off"), CmdSetDiskCache2, {0, 0, 0} },
    {_T( "SetQuietMode" ),    _T( "sqm" ),_T( "On|Off"), CmdSetQuietMode, {0, 0, 0} },
    {_T( "SetPerfMode" ),     _T( "spm" ),_T( "On|Off"), CmdSetPerfMode, {0, 0, 0} },
    {_T( "SetWriteFile" ),    _T( "swf" ),_T( "On|Off (On=write a FileSize data blk, Off=garbage data)"), CmdWriteFile, {0, 0, 0} },

    {_T( "CreateGroup" ),    _T( "cg" ),_T( "Flags" ), CmdCreateGroup, {0, 0, 0} },
    {_T( "DeleteGroup" ),    _T( "dg" ),_T("GroupID, Flags"), CmdDeleteGroup, {0, 0, 0} },
    {_T( "GetExemptQuota" ), _T( "eq" ),  _T(""), CmdGetExQ, {0, 0, 0} },
    {_T( "Help" ),            _T("?"),  _T(""), CmdHelp, {0, 0, 0} },
    {_T( "Quit" ),            _T( "q" ),  _T(""), CmdQuit, {0, 0, 0} }
};

CREATE_FILE_INFO Create_File_Table[] =
{
    {_T( "FILE_FLAG_WRITE_THROUGH" ), FILE_FLAG_WRITE_THROUGH, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_OVERLAPPED" ), FILE_FLAG_OVERLAPPED, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_NO_BUFFERING" ), FILE_FLAG_NO_BUFFERING, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_RANDOM_ACCESS" ), FILE_FLAG_RANDOM_ACCESS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_SEQUENTIAL_SCAN" ), FILE_FLAG_SEQUENTIAL_SCAN, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_DELETE_ON_CLOSE" ), FILE_FLAG_DELETE_ON_CLOSE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_BACKUP_SEMANTICS" ), FILE_FLAG_BACKUP_SEMANTICS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_FLAG_POSIX_SEMANTICS" ), FILE_FLAG_POSIX_SEMANTICS, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_ARCHIVE" ), FILE_ATTRIBUTE_ARCHIVE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_COMPRESSED" ), FILE_ATTRIBUTE_COMPRESSED, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_HIDDEN" ), FILE_ATTRIBUTE_HIDDEN, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_NORMAL" ), FILE_ATTRIBUTE_NORMAL, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_OFFLINE" ), FILE_ATTRIBUTE_OFFLINE, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_READONLY" ), FILE_ATTRIBUTE_READONLY, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_SYSTEM" ), FILE_ATTRIBUTE_SYSTEM, &g_dwCreate_File_Flags, FALSE},
    {_T( "FILE_ATTRIBUTE_TEMPORARY" ), FILE_ATTRIBUTE_TEMPORARY, &g_dwCreate_File_Flags, FALSE},
    {_T( "CREATE_NEW" ), CREATE_NEW, &g_dwCreate_File_Creation, TRUE},
    {_T( "CREATE_ALWAYS" ), CREATE_ALWAYS, &g_dwCreate_File_Creation, TRUE},
    {_T( "OPEN_EXISTING" ), OPEN_EXISTING, &g_dwCreate_File_Creation, TRUE},
    {_T( "OPEN_ALWAYS" ), OPEN_ALWAYS, &g_dwCreate_File_Creation, TRUE},
    {_T( "TRUNCATE_EXISTING" ), TRUNCATE_EXISTING, &g_dwCreate_File_Creation, TRUE},
    {_T( "FILE_SHARE_DELETE" ), FILE_SHARE_DELETE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_READ" ), FILE_SHARE_READ, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_WRITE" ), FILE_SHARE_WRITE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "FILE_SHARE_NONE" ), FILE_SHARE_NONE, &g_dwCreate_File_Share_Mode, FALSE},
    {_T( "GENERIC_READ" ), GENERIC_READ, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "GENERIC_WRITE" ), GENERIC_WRITE, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "GENERIC_0" ), GENERIC_0, &g_dwCreate_File_Access_Mode, FALSE},
    {_T( "" ), 0, NULL, FALSE}
};

DWORD WINAPIV Format_String(LPTSTR *plpsz, LPTSTR lpszFmt, ...);
DWORD WINAPI Format_Error(DWORD dwErr, LPTSTR *plpsz);
DWORD WINAPI Format_StringV(LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs);

#define RAND_INTL_STRING    _T("<rand>")

DWORD
CreateRandomString(
                    DWORD Size,
                    LPTSTR  szString)
{
    DWORD cbRet = 0;

#ifdef INTERNATIONAL
    cbRet = fnGetRandIntlString(
                            Size, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 

                            szString); // string to be returned

    _tprintf(_T("\n\nGetRandIntlString returns %s\n\n"), szString );
#else
    //
    // IF this is not an international supported version,
    // we go back to MakeRandomUrlName()
    //
    MakeRandomUrlName( szString );
#endif

	return cbRet;
}

//===========================================================================================
// borrowed from MSDN
//===========================================================================================
DWORD WINAPI GetPerfTime(VOID)
{
    static DWORD freq;            // timer frequency
    LARGE_INTEGER curtime;

    if (!freq)
    {                          // determine timer frequency
        QueryPerformanceFrequency(&curtime);
#if STOPWATCH_DEBUG
        if (curtime.HighPart)
        {                       // timer is too fast
            if(g_dwStopWatchMode & SPMODE_DEBUGOUT)
                OutputDebugString(TEXT("High resolution timer counts too quickly for single-width arithmetic.\r\n"));
            freq = 1;
        }                       // timer is too fast
        else
#endif
            freq = curtime.LowPart / 1000; // i.e., ticks per millisecond
    }                          // determine timer frequency
    QueryPerformanceCounter(&curtime);
    return (DWORD)(curtime.QuadPart / (LONGLONG)freq);
}

//=================================================================================
void StartPerfTimer(LPPERF_INFO pInfo, BOOL ResetFlag)
{
    pInfo->TickCount = GetPerfTime();
    if(ResetFlag)
    {
        pInfo->ElapsedTime = 0;
        pInfo->TotalElapsedTime = 0;
    }
}

//=================================================================================
void StopPerfTimer(LPPERF_INFO pInfo)
{   
    DWORD BegCount = pInfo->TickCount;

    pInfo->TickCount = GetPerfTime();
    
    pInfo->ElapsedTime += pInfo->TickCount - BegCount;
    pInfo->TotalElapsedTime += pInfo->ElapsedTime;
}

//=================================================================================
void DisplayGlobalSettings(void)
{
    _tprintf("Interations = %ld, CmdIterations = %ld, FileSize = %ld, CreateFlags = %x (%s%s%s), WriteFile = %s, QuietMode = %s, PerfMode = %s\n",
        g_dwNumIterations, g_dwNumCmdIterations,
        g_dwFileSize,
        g_dwDiskCache,
        g_dwDiskCache & (FILE_FLAG_NO_BUFFERING | FILE_FLAG_WRITE_THROUGH) ?_T( "" ) :_T( "None" ),
        g_dwDiskCache & FILE_FLAG_NO_BUFFERING ?_T( "NoBuf " ) :_T( "" ),
        g_dwDiskCache & FILE_FLAG_WRITE_THROUGH ?_T( "WriteThru" ) :_T( "" ),
        g_bWriteFile ?_T( "On" ): _T( "Off" ),
        g_bQuietMode ?_T(  "On"  ): _T( "Off" ),
        g_bPerfMode ?_T(  "On"  ): _T( "Off" ));
}

//=================================================================================
DWORD WINAPIV DisplayPerfResults(LPPERF_INFO pInfo, LPTSTR lpszFmt, ...)
{
    LPTSTR lpsz = NULL;
    DWORD dwRet;
    DWORD dwCnt = (g_dwIteration <= g_dwNumIterations) ?(g_dwIteration ?g_dwIteration :1) :g_dwNumIterations;
    DWORD dwCmdCnt = (g_dwCmdIteration <= g_dwNumCmdIterations) ?(g_dwCmdIteration ?g_dwCmdIteration :1) :g_dwNumCmdIterations;
    va_list vArgs;

    if(lpszFmt != NULL)
    {
        va_start (vArgs, lpszFmt);
        dwRet = Format_StringV(&lpsz, lpszFmt, &vArgs);
        va_end (vArgs);
    }

    _tprintf(_T( "%s, " ), lpsz ?lpsz :_T( "" ));
    _tprintf(_T( "Time(ms) = %ld, MS/Iter = %ld, Iteration = %ld, CmdIteration = %ld, " ),
        pInfo->ElapsedTime,
        pInfo->ElapsedTime/dwCmdCnt,
        dwCnt,
        dwCmdCnt);
    DisplayGlobalSettings();

    if(lpsz)
        LocalFree(lpsz);
    return(dwRet);
}

//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPTSTR *CommandArgv
    );


DWORD
GetLeafLenFromPath(
    LPTSTR   lpszPath
    );


//=================================================================================
#if DBG

#define TestDbgAssert(Predicate) \
    { \
        if (!(Predicate)) \
            TestDbgAssertFailed( #Predicate, __FILE__, __LINE__, NULL ); \
    }

VOID
TestDbgAssertFailed(
    LPTSTR FailedAssertion,
    LPTSTR FileName,
    DWORD LineNumber,
    LPTSTR Message
    )
/*++

Routine Description:

    Assertion failed.

Arguments:

    FailedAssertion :

    FileName :

    LineNumber :

    Message :

Return Value:

    none.

--*/
{

    _tprintf(_T( "Assert @ %s \n" ), FailedAssertion );
    _tprintf(_T( "Assert Filename, %s \n" ), FileName );
    _tprintf(_T( "Line Num. = %ld.\n" ), LineNumber );
    _tprintf(_T( "Message is %s\n" ), Message );

    DebugBreak();
}
#else

#define TestDbgAssert(_x_)

#endif // DBG

//=================================================================================
VOID
ParseArguments(
    LPTSTR InBuffer,
    LPTSTR *CArgv,
    LPDWORD CArgc
    )
{
    LPTSTR CurrentPtr = InBuffer;
    DWORD i = 0;
    DWORD Cnt = 0;

    for ( ;; ) {

        //
        // skip blanks.
        //

        while( *CurrentPtr ==_T(  ' '  )) {
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        CArgv[i++] = CurrentPtr;

        //
        // go to next space.
        //

        while(  (*CurrentPtr != _T( '\0' )) &&
                (*CurrentPtr != _T( '\n' )) ) {
            if( *CurrentPtr ==_T(  '"'  )) {      // Deal with simple quoted args
                if( Cnt == 0 )
                    CArgv[i-1] = ++CurrentPtr;  // Set arg to after quote
                else
                    *CurrentPtr = _T( '\0' );     // Remove end quote
                Cnt = !Cnt;
            }
            if( (Cnt == 0) && (*CurrentPtr == _T( ' ' )) ||   // If we hit a space and no quotes yet we are done with this arg
                (*CurrentPtr == _T( '\0' )) )
                break;
            CurrentPtr++;
        }

        if( *CurrentPtr ==_T(  '\0'  )) {
            break;
        }

        *CurrentPtr++ = _T( '\0' );
    }

    *CArgc = i;
    return;
}

//=================================================================================
LPTSTR
GetUrlFromFile ()
{
    if (!UrlList)
    {
        UrlList = _tfopen (_T( "urllist" ), _T( "r" ));
        if (UrlList == NULL)
            return NULL;
    }
    if (fgets( UrlBuffer, DEFAULT_BUFFER_SIZE, UrlList))
    {
        UrlBuffer[_tcslen(UrlBuffer) -1] = _T( '\0' );  //kill line feed for no param cmds
        return UrlBuffer;
    }
    else
    {
        fclose (UrlList);
        UrlList = NULL;
        return GetUrlFromFile();
    }
}


//=================================================================================
VOID
MakeRandomUrlName(
    LPTSTR UrlName
    )
/*++

Routine Description:

    Creates a random url name. The format of the name will be as
    below:

        url(00000-99999)

    Ex ca00123

Arguments:

    UrlName : pointer to an URL name buffer

Return Value:

    none.

--*/
{
    DWORD RandNum;
    LPTSTR UrlNamePtr = UrlName;
    DWORD i;
    DWORD Size;

    Size = URL_NAME_SIZE;

    *UrlNamePtr++ = _T( 'U' );
    *UrlNamePtr++ = _T( 'R' );
    *UrlNamePtr++ = _T( 'L' );
    Size -=3*sizeof(TCHAR);

    //
    // generate a_T(  "Size"  )digits random string;
    //
#if 0

#define MAX_STRING_LENGTH   URL_NAME_SIZE

    i = fnGetRandIntlString(
                            Size, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 
                            UrlNamePtr); // string to be returned


    _tprintf(_T("\n\n *** GetRandIntlString() returns %s ***\n\n"), UrlNamePtr );
#else
    for ( i = 0; i < Size; i++) {
        RandNum = rand() % 36;
        *UrlNamePtr++  =
            ( RandNum < 10 ) ? (CHAR)(_T( '0' ) + RandNum) : (CHAR)(_T( 'A' ) + (RandNum - 10));
    }

    *UrlNamePtr = _T( '\0' );
#endif

    return;
}

//=================================================================================
VOID
TestMakeRandomUrlName(
    VOID
    )
{
#define MAX_BUFFERS 32
#define MAX_NAMES   (10 * 1024)
#define NAME_BUFFER_SIZE    (10 * 1024)

    CHAR UrlName[URL_NAME_SIZE];
    DWORD i;

    LPBYTE NameBuffers[MAX_BUFFERS];
    DWORD NumNameBuffer;

    LPTSTR *Names;
    DWORD NumNames;

    LPBYTE NextName;
    LPBYTE EndOfBuffer;

    DWORD NumRepeat;

    NumNames = 0;
    NumNameBuffer = 0;
    NumRepeat = 0;

    //
    // allocate names array.
    //

    Names = (LPTSTR *)  LocalAlloc(
                            LMEM_FIXED | LMEM_ZEROINIT,
                            sizeof(LPTSTR) * MAX_NAMES );

    if( Names == NULL ) {
        _tprintf(_T( "local alloc failed.\n" ));
        return;
    }

    //
    // allocate name buffer.
    //

    NextName = (LPBYTE) LocalAlloc(
                                LMEM_FIXED | LMEM_ZEROINIT,
                                NAME_BUFFER_SIZE );

    if( NextName == NULL ) {
        _tprintf(_T( "local alloc failed.\n" ));
        return;
    }

    EndOfBuffer = NextName + NAME_BUFFER_SIZE;

    NameBuffers[NumNameBuffer++] = NextName;

    for( i = 0; i < MAX_NAMES; i++ ) {

        DWORD j;

        MakeRandomUrlName( UrlName );

        // _tprintf( "%d : %s\n", i, UrlName );
        // _tprintf(".");


        //
        // look to see this name is already created.
        //

        for( j = 0; j < NumNames; j++ ) {

            if( _tcscmp( Names[j], UrlName ) == 0 ) {

                // _tprintf("%ld :%ld.\n",  ++NumRepeat, NumNames );
                break;
            }
        }

        if( j < NumNames ) {

            //
            // repeated name.
            //

            continue;
        }

        //
        // add this name to the list.
        //

        if( (NextName + _tcslen(UrlName) + 1) > EndOfBuffer ) {

            if( NumNameBuffer >= MAX_BUFFERS ) {
                _tprintf(_T( "too many buffers\n" ));
                return;
            }

            //
            // allocate another name buffer.
            //

            NextName = (LPBYTE) LocalAlloc(
                                        LMEM_FIXED | LMEM_ZEROINIT,
                                        NAME_BUFFER_SIZE );

            if( NextName == NULL ) {
                _tprintf(_T( "local alloc failed.\n" ));
                return;
            }

            EndOfBuffer = NextName + NAME_BUFFER_SIZE;

            NameBuffers[NumNameBuffer++] = NextName;

            _tprintf(_T( "Another buffer alloted.\n" ));

            if( (NextName + _tcslen(UrlName) + 1) > EndOfBuffer ) {
                _tprintf(_T( "Fatal error.\n" ));
                return;
            }
        }

        _tcscpy( NextName, UrlName );
        Names[NumNames++] = NextName;

        NextName += _tcslen(UrlName) + 1;
    }

    //
    // free buffers.
    //

    LocalFree( Names );

    for( i = 0; i < NumNameBuffer; i++ ) {
        LocalFree( NameBuffers[i] );
    }

    _tprintf(_T( "%ld unique names generated successfully.\n" ), NumNames );

    return;
}

//=================================================================================
DWORD
SetFileSizeByName(
    LPCTSTR FileName,
    DWORD FileSize
    )
/*++

Routine Description:

    Set the size of the specified file.

Arguments:

    FileName : full path name of the file whose size is asked for.

    FileSize : new size of the file.

Return Value:

    Windows Error Code.

--*/
{
    HANDLE FileHandle;
    DWORD FilePointer;
    DWORD Error = ERROR_SUCCESS;
    DWORD dwFlags = 0;
    DWORD dwCreate;
    BOOL BoolError;

    //
    // get the size of the file being cached.
    //
    dwFlags = g_dwDiskCache;

    if(g_bWriteFile)
        dwCreate = CREATE_ALWAYS;
    else
        dwCreate = OPEN_EXISTING;

    FileHandle = CreateFile(
                    FileName,
                    GENERIC_WRITE,
                    0,   //FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    dwCreate,
                    FILE_ATTRIBUTE_NORMAL | dwFlags,
                    NULL );

    if( FileHandle == INVALID_HANDLE_VALUE ) {
        return( GetLastError() );
    }

    if(g_bWriteFile)
    {
        DWORD dwBytesWritten;
        if(!WriteFile(FileHandle, g_lpWriteFileBuf, FileSize, &dwBytesWritten, NULL))
            Error = GetLastError();

        TestDbgAssert(FileSize == dwBytesWritten);
    }
    else
    {
        FilePointer = SetFilePointer(FileHandle, FileSize, NULL, FILE_BEGIN );

        if( FilePointer != 0xFFFFFFFF )
        {
            TestDbgAssert( FilePointer == FileSize );

            if(!SetEndOfFile( FileHandle ))
                Error = GetLastError();
        }
        else
        {
            Error = GetLastError();
        }
    }

    CloseHandle( FileHandle );
    return( Error );
}

//=================================================================================
COMMAND_CODE
DecodeCommand(
    LPTSTR CommandName
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        if(( _tcsicmp( CommandName, GlobalCommandInfo[i].CommandName ) == 0 ) ||
           ( _tcsicmp( CommandName, GlobalCommandInfo[i].AltCommandName ) == 0 )) {
            return( GlobalCommandInfo[i].CommandCode );
        }
    }
    return( UnknownCommand );
}

//=================================================================================
VOID
PrintCommands(
    VOID
    )
{
    DWORD i;
    DWORD NumCommands;

    NumCommands = sizeof(GlobalCommandInfo) / sizeof(COMMAND_INFO);
    TestDbgAssert( NumCommands <= UnknownCommand );
    for( i = 0; i < NumCommands; i++) {
        _ftprintf(stderr, _T( "    %s (%s) %s\n" ),
            GlobalCommandInfo[i].CommandName,
            GlobalCommandInfo[i].AltCommandName,
            GlobalCommandInfo[i].CommandParams );
    }
}

//=================================================================================
VOID
DisplayUsage(
    VOID
    )
{
    _ftprintf(stderr,_T( "Usage: command <command parameters>\n" ));

    _ftprintf(stderr, _T( "Commands : \n" ));
    PrintCommands();
    DisplayGlobalSettings();
    return;
}

//=================================================================================
VOID
DisplayExemptQuota()
{



    _ftprintf(stderr, _T( "Exempt Usage = \n" ));
    return;
}


FILETIME
GetGmtTime(
    VOID
    )
{
    SYSTEMTIME SystemTime;
    FILETIME Time;

    GetSystemTime( &SystemTime );
    SystemTimeToFileTime( &SystemTime, &Time );

    return( Time );
}

//=================================================================================
LPTSTR
ConvertGmtTimeToString(
    FILETIME Time,
    LPTSTR OutputBuffer
    )
{
    SYSTEMTIME SystemTime;
    FILETIME LocalTime;

    static FILETIME ftNone = {0, 0};
    
    if (!memcmp (&Time, &ftNone, sizeof(FILETIME)))
        _stprintf (OutputBuffer, _T( "<none>" ));
    else
    {
        FileTimeToLocalFileTime( &Time , &LocalTime );
        FileTimeToSystemTime( &LocalTime, &SystemTime );

        _stprintf( OutputBuffer,
                    _T( "%02u/%02u/%04u %02u:%02u:%02u " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );
    }
    
    return( OutputBuffer );
}

//=================================================================================
VOID
PrintUrlInfo(
    LPINTERNET_CACHE_ENTRY_INFO CacheEntryInfo,
    DWORD Index
    )
{
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    LPTSTR Tab = _T( "" );

    if( Index != (DWORD)(-1) ) {
        _tprintf( _T( "Index = %ld\n" ), Index);
        Tab = _T( "\t" );
    }

    _tprintf( _T( "%sUrlName = %s\n" ), Tab, CacheEntryInfo->lpszSourceUrlName );

#if UNICODE
    _tprintf( _T( "%sLocalFileName = %ws\n" ),
        Tab, CacheEntryInfo->lpszLocalFileName );
#else
    _tprintf( _T( "%sLocalFileName = %s\n" ),
        Tab, CacheEntryInfo->lpszLocalFileName );
#endif

    _tprintf( _T( "%sdwStructSize = %lx\n" ),
        Tab, CacheEntryInfo->dwStructSize );

    _tprintf( _T( "%sCacheEntryType = %lx\n" ),
        Tab, CacheEntryInfo->CacheEntryType );

    _tprintf( _T( "%sUseCount = %ld\n" ),
        Tab, CacheEntryInfo->dwUseCount );

    _tprintf( _T( "%sHitRate = %ld\n" ),
        Tab, CacheEntryInfo->dwHitRate );

    _tprintf( _T( "%sSize = %ld:%ld\n" ),
        Tab, CacheEntryInfo->dwSizeLow, CacheEntryInfo->dwSizeHigh );

    _tprintf( _T( "%sLastModifiedTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastModifiedTime, TimeBuffer) );

    _tprintf( _T( "%sExpireTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->ExpireTime, TimeBuffer) );

    _tprintf( _T( "%sLastAccessTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastAccessTime, TimeBuffer) );

    _tprintf( _T( "%sLastSyncTime = %s\n" ),
        Tab, ConvertGmtTimeToString( CacheEntryInfo->LastSyncTime, TimeBuffer) );

#if 1
    _tprintf( _T( "%sHeaderInfo = %s\n" ),
        Tab, CacheEntryInfo->lpHeaderInfo );
#endif

    _tprintf( _T( "%sHeaderInfoSize = %ld\n" ),
        Tab, CacheEntryInfo->dwHeaderInfoSize );

#if UNICODE
    _tprintf( _T( "%sFileExtension = %ws\n" ),
        Tab, CacheEntryInfo->lpszFileExtension );
#else
    _tprintf( _T( "%sFileExtension = %s\n" ),
        Tab, CacheEntryInfo->lpszFileExtension );
#endif

    _tprintf (_T( "%sExemptDelta = %d\n" ),
        Tab, CacheEntryInfo->dwExemptDelta);
}

#ifdef IE5
VOID
PrintGroupInfo(
    GROUPID gid
    )
{
    LPTSTR Tab = _T( "\t" );
    HANDLE EnumHandle = NULL; 
    DWORD BufferSize;

    INTERNET_CACHE_GROUP_INFOA  pInfo;
    DWORD                       dwInfo = sizeof(INTERNET_CACHE_GROUP_INFOA);
    if(GetUrlCacheGroupAttribute(gid, 0, 0xffffffff, &pInfo, &dwInfo, NULL))
    {
        _tprintf( _T( "%sdwGroupSize = %lx\n" ), Tab, pInfo.dwGroupSize);
        _tprintf( _T( "%sdwGroupFlags = %lx\n" ), Tab, pInfo.dwGroupFlags);
        _tprintf( _T( "%sdwGroupType  = %lx\n" ), Tab, pInfo.dwGroupType);
        _tprintf( _T( "%sdwDiskUsage  = %lx\n" ), Tab, pInfo.dwDiskUsage);
        _tprintf( _T( "%sdwDiskQuota  = %lx\n" ), Tab, pInfo.dwDiskQuota);

        _tprintf( _T( "%s%s======== URLS ========\n" ), Tab, Tab);
        

        // looking for all url associated with this group
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        EnumHandle = FindFirstUrlCacheEntryEx (
            NULL,         // search pattern
            0,            // flags
            0xffffffff,   // filter
            gid,          // groupid
            (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
            &BufferSize,
            NULL,
            NULL,
            NULL
        );

        if (EnumHandle) 
        {
            _tprintf(_T( "\t\t %s\n" ), 
                ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        } 


        // get more entries.
        for ( ;; )
        {
            memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
            BufferSize = CACHE_ENTRY_BUFFER_SIZE;
            if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
            {
                break;
            }

            _tprintf(_T( "\t\t %s\n" ), 
                ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        }


        FindCloseUrlCache(EnumHandle);
    
    }
    else
    {
        _tprintf(_T( "Failed to retrieve attribute for this group\n" ));
    }


}
#endif

//=================================================================================
DWORD
ProcessFreeCacheSpace (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error = ERROR_SUCCESS;
    DWORD dwSize = 0;
    TCHAR szCachePath[MAX_PATH+1];
    TCHAR szWinDir[MAX_PATH+1];

    if (argc < 1)
    {
        _ftprintf(stderr, _T( "Usage: %s %s\n" ),
            GlobalCommandInfo[CmdFreeCacheSpace].CommandName,
            GlobalCommandInfo[CmdFreeCacheSpace].CommandParams);
        return ERROR_INVALID_PARAMETER;
    }

    if((LSTRCMPI(argv[0], _T( "history" )) == 0) || (LSTRCMPI(argv[0], _T( "cookies" )) == 0))
    {
        dwSize = 100;
        GetWindowsDirectory(szWinDir, MAX_PATH);
        _stprintf(szCachePath, _T( "%s\\%s" ), szWinDir, argv[0]);
    }
    else
    {
        *szCachePath = _T( '\0' );
        dwSize = _tcstoul(argv[0], NULL, 0);
    }

    StartPerfTimer(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo, RESET_TIMER);

    if (!FreeUrlCacheSpace (szCachePath, dwSize, 0))
        Error = GetLastError();

    StopPerfTimer(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo);
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdFreeCacheSpace].PerfInfo, _T( "Free %1 %2!ld!" ), szCachePath, dwSize);

    return Error;
}

//=================================================================================
DWORD
CreateUCEHelper(
    DWORD argc,
    LPTSTR *argv,
    TCHAR* LocalFileName
    )
{
    DWORD Error;
    LPTSTR UrlName;
    DWORD ExpectedSize = 0;
    TCHAR *lpFileExtension = NULL;
    TCHAR   szIntlString1[2 * URL_NAME_LENGTH];
    TCHAR   szIntlString2[2 * URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: CreateUrlCacheEntry UrlName " )
                _T( "<ExpectedSize> <filextension (no dot)>\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szIntlString1 );
        UrlName = szIntlString1;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;
#if 0
    if (_tcsicmp (LocalFileName, RAND_INTL_STRING) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szIntlString2 );
        LocalFileName = szIntlString2;
    }
#endif

    if( argc > 1 ) {
        ExpectedSize = _tcstoul( argv[1], NULL, 0 );
    } else {
        ExpectedSize = 2000;
    }
    
    if (argc > 2) {
        lpFileExtension = argv[2];
    }

    if( !CreateUrlCacheEntry(
                UrlName,
                ExpectedSize,
                lpFileExtension,
                LocalFileName,
                0 )  ) {

        return( GetLastError() );
    }

    //
    // set file size.
    //
    Error = SetFileSizeByName (LocalFileName, ExpectedSize );
    if( Error != ERROR_SUCCESS )
    {
        _tprintf( _T( "SetFileSizeByName call failed, %ld.\n" ), Error );
        return( Error );
    }


#if UNICODE
    _tprintf( _T( "LocalFile Name : %ws \n" ), LocalFileName );
#else
    _tprintf( _T( "LocalFile Name : %s \n" ), LocalFileName );
#endif

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
CommitUCEHelper(
    DWORD argc,
    LPTSTR *argv,
    LPTSTR LocalFileName
    )
{
    DWORD Error;
    BOOL fSetEdited = FALSE;
    LPTSTR UrlName;
    FILETIME ExpireTime = {0, 0};
    FILETIME ZeroFileTime = {0, 0};
    TCHAR   szIntlString[2 * URL_NAME_LENGTH];
    TCHAR   szIntlString2[2 * URL_NAME_LENGTH];

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0) {
        UrlName = GetUrlFromFile ();
    } else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (_tcsicmp (LocalFileName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString2);
        LocalFileName = szIntlString2;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    if( argc > 2 ) {

		unsigned int edt;
        DWORD UrlLife;

        UrlLife = _tcstoul( argv[2], NULL, 0 );

        if( UrlLife != 0 ) {

            LONGLONG NewTime;

            ExpireTime = GetGmtTime();

            NewTime =
                *(LONGLONG *)(&ExpireTime) +
                (LONGLONG)UrlLife * (LONGLONG)36000000000;
                    // in 100 of nano seconds.

            ExpireTime = *((FILETIME *)(&NewTime)) ;
        }

		// See if user wants to set EDITED_CACHE_ENTRY
		for (edt = 2; edt < argc; edt++)
		{
		    if (_tcsicmp (argv[edt], _T( "edited" )) == 0)
		    {
		    	fSetEdited = TRUE;
	    	}
    	}

    }

    if( !CommitUrlCacheEntry(
                UrlName,
                LocalFileName,
                ExpireTime,
                ZeroFileTime,
                fSetEdited ? (NORMAL_CACHE_ENTRY | EDITED_CACHE_ENTRY) : NORMAL_CACHE_ENTRY,
                (LPBYTE)GlobalCacheHeaderInfo,
                (rand() % CACHE_HEADER_INFO_SIZE_NORMAL_MAX),
                TEXT("tst"),
                0
                ) ) {

        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}


//=================================================================================
DWORD ProcessCreateUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    TCHAR szPath[MAX_PATH];

    return CreateUCEHelper (argc, argv, szPath);
}

//=================================================================================
DWORD ProcessCommitUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    if( argc < 2 ) {
        _ftprintf(stderr, _T( "Usage: CommitUrlCacheEntry UrlName LocalFileName " )
               _T(  "<ExpireTime (in hours from now)>\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    return CommitUCEHelper (argc, argv, argv[1]);
}

//=================================================================================
DWORD ProcessUpdateUrlCacheEntry (DWORD argc, LPTSTR *argv)
{
    TCHAR szPath[MAX_PATH];

    DWORD dwRet = CreateUCEHelper (argc, argv, szPath);
    if (dwRet != ERROR_SUCCESS)
        return dwRet;
    return CommitUCEHelper (argc, argv, szPath);
}
    

//=================================================================================
DWORD
ProcessRetrieveUrlCacheEntryFile(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize;
    DWORD Error = ERROR_SUCCESS;
    TCHAR szIntlString[2 * URL_NAME_LENGTH ];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: RetrieveUrlCacheEntryFile UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
    
    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    StartPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo, RESET_TIMER);

    g_dwCmdIteration = 0;
    while(g_dwCmdIteration++ < g_dwNumCmdIterations)
    {
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !RetrieveUrlCacheEntryFile(
                    UrlName,
                    lpCacheEntryInfo,
                    &CacheEntryInfoBufferSize,
                    0 ) ) {

            if(Error == ERROR_SUCCESS)  // GetLastError on the first error to save a little time since we might be timing non existant files
                Error = GetLastError();
        }
    }

    StopPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo);

    if(!g_bQuietMode)
        PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].PerfInfo, _T( "%1 %2" ),
                GlobalCommandInfo[CmdRetrieveUrlCacheEntryFile].CommandName, argv[0]);

    return( Error );
}

//=================================================================================
DWORD
ProcessRetrieveUrlCacheEntryStream(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error = ERROR_SUCCESS;
    LPTSTR UrlName;
    HANDLE StreamHandle;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize;
    DWORD BufferSize;
    DWORD Offset;
    TCHAR TimeBuffer[DEFAULT_BUFFER_SIZE];
    TCHAR szIntlString[2*URL_NAME_LENGTH];

///    PERF_INFO piRead;
///    PERF_INFO piUnlock;

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: RetrieveUrlCacheEntryStream UrlName [NoRead]\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);


    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return( ERROR_INTERNET_INVALID_URL);

    StartPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo, RESET_TIMER);

    g_dwCmdIteration = 0;
    while(g_dwCmdIteration++ < g_dwNumCmdIterations)
    {
        CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;

        StreamHandle =
            RetrieveUrlCacheEntryStream(
                UrlName,
                lpCacheEntryInfo,
                &CacheEntryInfoBufferSize,
                FALSE,
                0 );

        if( StreamHandle != NULL )
        {
            if((argc == 1) || ((argc == 2) && (_tcsicmp(argv[1], _T( "noread" )) != 0)))
            {
                //
                // read file data.
                //

                Offset = 0;
                for(;;) {

                    BufferSize = CACHE_DATA_BUFFER_SIZE;
                    memset( GlobalCacheDataBuffer, 0x0, CACHE_DATA_BUFFER_SIZE );

                    if( !ReadUrlCacheEntryStream(
                            StreamHandle,
                            Offset,
                            GlobalCacheDataBuffer,
                            &BufferSize,
                            0
                            ) ) {

                        Error = GetLastError();
                        break;
                    }
                    Offset += BufferSize;

                    if( BufferSize != CACHE_DATA_BUFFER_SIZE ) {

                        TestDbgAssert(  BufferSize < CACHE_DATA_BUFFER_SIZE );
                        Error = ERROR_SUCCESS;
                        break;
                    }
                }
            }
            //
            // unlock the file.
            //

            if( !UnlockUrlCacheEntryStream( StreamHandle, 0 ) ) {
                TestDbgAssert(  FALSE );
            }
        }
        else
        {
            Error = GetLastError();
        }
    }
    StopPerfTimer(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo);

    if(!g_bQuietMode)
        PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );

    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].PerfInfo, _T( "%1 %2 %3 = Retrieve" ),
            GlobalCommandInfo[CmdRetrieveUrlCacheEntryStream].CommandName,
            argc >= 1 ?argv[0] :_T( "" ),
            argc >= 2 ?argv[1] :_T( "" ));

    return( Error );
}

//=================================================================================
#ifdef IE5
DWORD
ProcessUnlockUrlCacheEntryFile(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: UnlockUrlCacheEntryFile UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    if( !UnlockUrlCacheEntryFile( UrlName, 0 ) ) {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
#endif

//=================================================================================
DWORD
ProcessGetUrlCacheEntryInfo(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    DWORD CacheEntryInfoBufferSize = CACHE_ENTRY_BUFFER_SIZE;


    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: GetUrlCacheEntryInfo UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);


    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    StartPerfTimer(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo, RESET_TIMER);

    if( !GetUrlCacheEntryInfo(
        UrlName,
        lpCacheEntryInfo,
        &CacheEntryInfoBufferSize ) ) {

        return( GetLastError() );
    }

    StopPerfTimer(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo);

    PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdGetUrlCacheEntryInfo].PerfInfo, NULL);

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
ProcessSetUrlCacheEntryInfo(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    FILETIME ExpireTime = {0, 0};
    INTERNET_CACHE_ENTRY_INFO UrlInfo;
    LPINTERNET_CACHE_ENTRY_INFO lpCacheEntryInfo = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: SetUrlCacheEntryInfo UrlName " )
               _T(  "<ExpireTime (in hours from now)>\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    memset( &UrlInfo, 0x0, sizeof(INTERNET_CACHE_ENTRY_INFO) );

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    UrlInfo.LastModifiedTime = GetGmtTime();

    if( argc > 1 ) {

        DWORD UrlLife;

        UrlLife = _tcstoul( argv[1], NULL, 0 );

        if( UrlLife != 0 ) {

            LONGLONG NewTime;

            ExpireTime = UrlInfo.LastModifiedTime;

            NewTime =
                *(LONGLONG *)(&ExpireTime) +
                (LONGLONG)UrlLife * (LONGLONG)3600 * (LONGLONG)10000000;
                    // in 100 of nano seconds.

            ExpireTime = *((FILETIME *)(&NewTime)) ;
        }
    }

    UrlInfo.ExpireTime = ExpireTime;

    StartPerfTimer(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo, RESET_TIMER);


    if( !SetUrlCacheEntryInfo(
        UrlName,
        &UrlInfo,
        CACHE_ENTRY_MODTIME_FC  | CACHE_ENTRY_EXPTIME_FC
                ) ) {
        return( GetLastError() );
    }

    StopPerfTimer(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo);

    PrintUrlInfo( lpCacheEntryInfo, (DWORD)(-1) );
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdSetUrlCacheEntryInfo].PerfInfo, NULL);

    return( ERROR_SUCCESS );
}

//=================================================================================
#ifdef IE5
DWORD
ProcessSetUrlCacheEntryGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    DWORD dwFlags;
    GROUPID GroupId;
    LONGLONG ExemptTime;
    TCHAR szIntlString[2*URL_NAME_LENGTH];

    if (argc < 3)
    {
        _ftprintf(stderr, _T( "Usage: SetUrlCacheEntryGroup UrlName " )
               _T(  "Flags GroupId\n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    dwFlags = atoi(argv[1]);
    GroupId = atoi(argv[2]);
    if( !SetUrlCacheEntryGroup
        (UrlName, dwFlags, GroupId, NULL, 0, NULL))
    {
        return GetLastError();
    }
    
    return ERROR_SUCCESS;
}
#endif

//=================================================================================
DWORD ProcessSetExempt (DWORD argc, LPTSTR *argv)
{
    LPTSTR UrlName;
    INTERNET_CACHE_ENTRY_INFO cei;
    TCHAR szIntlString[2*URL_NAME_LENGTH];
    
    if (argc < 2)
    {
        _ftprintf (stderr, _T( "Usage: SetGroup UrlName ExemptDelta\n" ));
        return ERROR_INVALID_PARAMETER;
    }

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING) == 0) {
        CreateRandomString(URL_NAME_LENGTH, szIntlString);
        UrlName = szIntlString;
    }
    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;

    cei.dwStructSize = sizeof(cei);
    cei.dwExemptDelta = atoi(argv[1]);

    if (!SetUrlCacheEntryInfo (UrlName, &cei, CACHE_ENTRY_EXEMPT_DELTA_FC))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

//=================================================================================
#ifdef IE5

DWORD
ProcessDeleteUrlCacheEntry(
    DWORD argc,
    LPTSTR *argv
    )
{
    LPTSTR UrlName;
    DWORD BufferSize;
    HANDLE EnumHandle;
    DWORD Index = 0;
    DWORD dwTotal = 0;
    BOOL QuietMode = g_bQuietMode;
    TCHAR szInternationalString[ URL_NAME_LENGTH ];
    TCHAR Str[256];

    if( argc < 1 ) {
        _ftprintf(stderr,_T(  "Usage: DeleteUrlCacheEntry UrlName \n"  ));
        return( ERROR_INVALID_PARAMETER );
    }

    if((argc == 2) && (argv[1][0] == _T( 'q' )))
        QuietMode = TRUE;

    UrlName = argv[0];
    if (_tcsicmp (UrlName, UrlListKey) == 0)
        UrlName = GetUrlFromFile ();
    else
    if (_tcsicmp (UrlName, RAND_INTL_STRING ) == 0) {
        CreateRandomString( URL_NAME_LENGTH, szInternationalString );
        UrlName = szInternationalString;
    }
        

    if (!UrlName)
        return ERROR_INTERNET_INVALID_URL;
    if (_tcsicmp (UrlName, _T( "all" )) == 0)
    {
        StartPerfTimer(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo, RESET_TIMER);
        for ( ;; )
        {
            memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
            BufferSize = CACHE_ENTRY_BUFFER_SIZE;
            if( Index++ == 0)
            {
                EnumHandle = FindFirstUrlCacheEntryEx (
                    NULL,         // search pattern
                    0,            // flags
                    0xffffffff,   // filter
                    0,            // groupid
                    (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                    &BufferSize,
                    NULL,
                    NULL,
                    NULL
                );

                if( EnumHandle == NULL ) {
                    return( GetLastError() );
                }
            }
            else
            {
                if( !FindNextUrlCacheEntryEx(
                        EnumHandle,
                        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                        &BufferSize, NULL, NULL, NULL))
                {
                    DWORD Error;

                    Error = GetLastError();
                    if( Error != ERROR_NO_MORE_ITEMS ) {
                        return( Error );
                    }

                    break;
                }
            }
            
            if( !QuietMode )
                _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
                
            if( !DeleteUrlCacheEntry( ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName ) ) {
                DWORD dwGLE = GetLastError();
                _tprintf(_T( "DeleteUrlCacheEntry failed for %s. GLE=%d\r\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName, dwGLE);
                return( dwGLE );
            }
            dwTotal++;
        }
        StopPerfTimer(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo);
        if(g_bPerfMode)
        {
            _stprintf(Str, _T( "Deleted %d" ), dwTotal);
            DisplayPerfResults(&GlobalCommandInfo[CmdDeleteUrlCacheEntry].PerfInfo, Str);
        }
        
        return( ERROR_SUCCESS);
    }   // if UrlName == all

    if( !DeleteUrlCacheEntry( UrlName ) ) {
        return( GetLastError() );
    }

    return( ERROR_SUCCESS );
}
#endif

//=================================================================================
DWORD
ProcessEnumUrlCacheEntries(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD BufferSize, dwSmall=0, dwLarge=0, dwTotal = 0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD ActualSize;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI = (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer;
    BOOL QuietMode = g_bQuietMode;
    BOOL bRC;
    TCHAR Str[256];
    BOOL EnumUrlOnly = FALSE;

    if (argc)
    {
        if (LSTRCMPI(*argv, _T( "q" )) == 0)
            QuietMode = TRUE;
        else if (LSTRCMPI(*argv, _T( "u" )) == 0)
            EnumUrlOnly = TRUE;
    }

    //
    // start enum.
    //
    StartPerfTimer(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo, RESET_TIMER);

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);

    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx (
        NULL,         // search pattern
        0,            // flags
        0xffffffff,   // filter
        0,            // groupid
        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
        &BufferSize,
        NULL,
        NULL,
        NULL
    );

    if( EnumHandle == NULL ) {
        return( GetLastError() );
    }

    ++dwTotal;

///    ActualSize = BufferSize
///                    - LSTRLEN(lpCEI->lpszLocalFileName)
///                    + GetLeafLenFromPath(lpCEI->lpszLocalFileName);
    if(!QuietMode)
        if (EnumUrlOnly) {
            _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
        } else {
            PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
        }

    //
    // get more entries.
    //

    for ( ;; )
    {
        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx(
                EnumHandle,
                (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                &BufferSize, NULL, NULL, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;

        if(!QuietMode)
        {
///            ActualSize = BufferSize - GetLeafLenFromPath(lpCEI->lpszLocalFileName);
            if (EnumUrlOnly) {
                _tprintf(_T( "URL = %s\n" ), ((LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer)->lpszSourceUrlName);
            } else {
                PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
            }
        }
    }

    StopPerfTimer(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo);
    if(g_bPerfMode)
    {
        _stprintf(Str, _T( "Enum %d" ), dwTotal);
        DisplayPerfResults(&GlobalCommandInfo[CmdEnumUrlCacheEntries].PerfInfo, Str);
    }
    else
    {
        _tprintf(_T( "\r\nTotal = %d\n" ), dwTotal);
    }

    FindCloseUrlCache(EnumHandle);

    return( ERROR_SUCCESS );
}

//=================================================================================
DWORD
ProcessEnumGroup(
    DWORD argc,
    LPTSTR *argv
    )
{

#ifdef IE5
    HANDLE h = NULL;
    GROUPID gid = 0;
    h = FindFirstUrlCacheGroup(0, 0, NULL, 0, &gid, NULL);

    if( h )
    {
        _tprintf(_T( "GID = %x\n" ), gid);
        PrintGroupInfo(gid);
        while( FindNextUrlCacheGroup(h, &gid, NULL) )
        {
            _tprintf(_T( "GID = %x\n" ), gid);
            PrintGroupInfo(gid);
        }
    }
    else
    {
        _tprintf(_T( "no group found\n" ));
    }

    FindCloseUrlCache(h);
    return( ERROR_SUCCESS );

#else
    DWORD BufferSize, dwTotal = 0;
    HANDLE EnumHandle;
    DWORD Index = 1, len;
    DWORD ActualSize;
    LPINTERNET_CACHE_ENTRY_INFO lpCEI =
        (LPINTERNET_CACHE_ENTRY_INFO) GlobalCacheEntryInfoBuffer;
    GROUPID GroupId;
    FILETIME ftExempt;
    TCHAR Str[256];

    //
    // start enum.
    //

    if (argc != 1)
    {
        _ftprintf (stderr, "Usage: EnumGroup GroupId");
        return ERROR_INVALID_PARAMETER;
    }

    GroupId = atoi(argv[0]);

    StartPerfTimer(&GlobalCommandInfo[CmdEnumGroup].PerfInfo, RESET_TIMER);

    memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
    BufferSize = CACHE_ENTRY_BUFFER_SIZE;
    EnumHandle = FindFirstUrlCacheEntryEx
        (NULL, 0, 0, GroupId, lpCEI, &BufferSize, NULL, 0, NULL);

    if( EnumHandle == NULL ) {
        return( GetLastError() );
    }


    ++dwTotal;

///    ActualSize = BufferSize
///                    - LSTRLEN(lpCEI->lpszLocalFileName)
///                    + GetLeafLenFromPath(lpCEI->lpszLocalFileName);

    if(!g_bQuietMode)
        PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );

    //
    // get more entries.
    //

    for ( ;; ) {

        memset(GlobalCacheEntryInfoBuffer, 0, CACHE_ENTRY_BUFFER_SIZE);
        BufferSize = CACHE_ENTRY_BUFFER_SIZE;
        if( !FindNextUrlCacheEntryEx
            (EnumHandle, lpCEI, &BufferSize, NULL, 0, NULL))
        {
            DWORD Error;

            Error = GetLastError();
            if( Error != ERROR_NO_MORE_ITEMS ) {
                return( Error );
            }

            break;
        }

        ++dwTotal;

///        ActualSize = BufferSize - GetLeafLenFromPath(lpCEI->lpszLocalFileName);
        if(!g_bQuietMode)
            PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, Index++ );
    }

    FindCloseUrlCache (EnumHandle);

    StopPerfTimer(&GlobalCommandInfo[CmdEnumGroup].PerfInfo);
    if(g_bPerfMode)
    {
        _stprintf(Str, _T( "EnumGrp %d" ), dwTotal);
        DisplayPerfResults(&GlobalCommandInfo[CmdEnumGroup].PerfInfo, Str);
    }
    else
    {
        _tprintf(_T( "\r\nTotal = %d\n" ), dwTotal);
    }

    return( ERROR_SUCCESS );
#endif // IE5
}

//=================================================================================
DWORD
ProcessSimulateCache(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error;
    DWORD i, j;
    TCHAR szUrlName[ URL_NAME_SIZE ];
    TCHAR *UrlName = NULL;
    TCHAR LocalFileName[MAX_PATH];
    DWORD FileSize;
    LONGLONG ExpireTime;
    FILETIME LastModTime;
    TCHAR TimeBuffer[MAX_PATH];
    DWORD NumUrls;
    DWORD UrlLife;
    DWORD BufferSize;
    DWORD CacheHeaderInfoSize;
    DWORD CacheHeaderInfoSizeMax;
    BOOL QuietMode = g_bQuietMode;
    BOOL bRandomInternational = TRUE;
    TCHAR szInternationalString[2*URL_NAME_LENGTH];

    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessSimulateCache NumUrls <s (silent mode)>\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    NumUrls = _tcstoul( argv[0], NULL, 0 );

    while ( argc-- )
    {
        if(LSTRCMPI(argv[argc], _T( "q" )) == 0)
            QuietMode = TRUE;
        else if (!_tcsicmp(argv[argc], _T( "dump" )))
        {
            DumpUrlList = _tfopen (_T( "urllist.sim" ), _T( "a+" ));
            _ftprintf(stderr, _T("Dumping Urls to \"urllist.sim\"\n"));
        }
        else if (!_tcsicmp(argv[argc], RAND_INTL_STRING))
        {
            bRandomInternational= TRUE;
            _ftprintf(stderr, _T("Creating random international strings\n"));
        }
    }

    StartPerfTimer(&GlobalCommandInfo[CmdSimulateCache].PerfInfo, RESET_TIMER);

#ifdef TEST
    for (j=0; j<2; ++j) {
#endif //TEST
        for( i = 0; i < NumUrls; i++ ) {

            //
            // make a new url name.
            //
            if(!g_bPerfMode) {
                MakeRandomUrlName( szUrlName );
                UrlName = szUrlName;
            } else
            if( bRandomInternational ) {
                CreateRandomString( URL_NAME_LENGTH, szInternationalString );
                UrlName = szInternationalString;
            } else
                _stprintf(szUrlName, _T( "http://serv/URL%ld" ), i);

            
            //
            // create url file.
            //
            if( !CreateUrlCacheEntry(
                            UrlName,
                            0,
                            _T( "tmp" ),
                            LocalFileName,
                            0 ) ) {

                Error = GetLastError();
                _tprintf( _T( "CreateUrlFile call failed, %ld.\n" ), Error );
                return( Error );
            }

            //
            // create random file size.
            //
            if(g_dwFileSize == 0)
                FileSize = ((rand() % 10) + 1) * 1024 ;
            else
                FileSize = g_dwFileSize;

            //
            // set file size.
            //
            Error = SetFileSizeByName(
                            LocalFileName,
                            FileSize );
            if( Error != ERROR_SUCCESS ) {
                _tprintf( _T( "SetFileSizeByName call failed, %ld.\n" ), Error );
                return( Error );
            }

            UrlLife = rand() % 48;

            ExpireTime = (LONGLONG)UrlLife * (LONGLONG)36000000000;
            // in 100 of nano seconds.

            LastModTime = GetGmtTime();
            ExpireTime += *((LONGLONG *)&LastModTime);

            //
            // 90% of the time the header info will be less than 256 bytes.
            //
            CacheHeaderInfoSizeMax =
                ((rand() % 100) > 90) ?
                    CACHE_HEADER_INFO_SIZE_BIG_MAX :
                        CACHE_HEADER_INFO_SIZE_NORMAL_MAX;

            CacheHeaderInfoSize = rand() % CacheHeaderInfoSizeMax;

            //
            // cache this file.
            //
            if( !CommitUrlCacheEntry(
                            UrlName,
                            LocalFileName,
                            *((FILETIME *)&ExpireTime),
                            LastModTime,
                            NORMAL_CACHE_ENTRY,
                            (LPBYTE)GlobalCacheHeaderInfo,
                            CacheHeaderInfoSize,
                            TEXT("tst"),
                            0 ) ) {
                Error = GetLastError();
                _tprintf( _T( "CreateUrlFile call failed, %ld.\n" ), Error );
                return( Error );
            }

            if(!QuietMode)
            {
                //
                // GET and PRINT url info, we just added.
                //
                BufferSize = CACHE_ENTRY_BUFFER_SIZE;
                if( !GetUrlCacheEntryInfo(
                        UrlName,
                        (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer,
                        &BufferSize ) ) {

                    Error = GetLastError();
                    _tprintf( _T( "GetUrlCacheEntryInfoA call failed, %ld.\n" ), Error );
                    return( Error );
                }
                if (DumpUrlList)
                    _ftprintf(DumpUrlList,_T( "%s\n" ), UrlName);

                // PrintUrlInfo( (LPINTERNET_CACHE_ENTRY_INFO)GlobalCacheEntryInfoBuffer, (DWORD)(-1) );

                // Display info
                _tprintf(_T( "%d : %s\n" ), i, UrlName );
#if UNICODE
                _tprintf(_T( "\tTempFileName: %ws\n" ), LocalFileName );
#else
                _tprintf(_T( "\tTempFileName: %s\n" ), LocalFileName );
#endif
                _tprintf(_T( "\tSize : %ld\n" ), FileSize );
                _tprintf(_T( "\tExpires at : %s\n" ),
                    ConvertGmtTimeToString( *((FILETIME *)&ExpireTime), TimeBuffer ) );
                _tprintf(_T( "HeaderInfoSize=%d\n" ), CacheHeaderInfoSize);
            }
        }
#ifdef TEST
        if (j==0) {
            _tprintf(_T( "Freeingcache, OK?" ));
            gets(LocalFileName);
            FreeUrlCacheSpace (NULL, 100, 0);
            _tprintf(_T( "Freed cache, OK?" ));
            gets(LocalFileName);
        }
    }
#endif //TEST

    StopPerfTimer(&GlobalCommandInfo[CmdSimulateCache].PerfInfo);
    if(g_bPerfMode)
        DisplayPerfResults(&GlobalCommandInfo[CmdSimulateCache].PerfInfo, _T( "Create %1!ld!" ), NumUrls);

    return( ERROR_SUCCESS );
}

//=================================================================================

DWORD ProcessCreateFile(DWORD argc, LPTSTR *argv)
{
    DWORD Error = ERROR_SUCCESS;
    DWORD dwCnt;
    LPCREATE_FILE_INFO lpcfi;
    HANDLE hFile = NULL;
    TCHAR szResultStr[1024];

    if(argc >= 1)
    {
        _stprintf(szResultStr, _T( "%s %s " ), GlobalCommandInfo[CmdCreateFile].CommandName, argv[0]);

        // Process arguments
        for(dwCnt = 1; dwCnt < argc; dwCnt++)
        {
            lpcfi = Create_File_Table;
            lstrcat(szResultStr, argv[dwCnt]);
            lstrcat(szResultStr, _T( " " ));
            while(*lpcfi->lpszVal)
            {
                if(LSTRCMPI(lpcfi->lpszVal, argv[dwCnt]) == 0)
                {
                    if(lpcfi->bExclusive)
                        *lpcfi->pdwArg = lpcfi->dwVal;
                    else
                        *lpcfi->pdwArg |= lpcfi->dwVal;
                    break;
                }
                lpcfi++;
            }
        }

        StartPerfTimer(&GlobalCommandInfo[CmdCreateFile].PerfInfo, RESET_TIMER);

        g_dwCmdIteration = 0;
        while(g_dwCmdIteration++ < g_dwNumCmdIterations)
        {
            // Create the file
            hFile = CreateFile(
                        argv[0],
                        g_dwCreate_File_Access_Mode,
                        g_dwCreate_File_Share_Mode,
                        NULL,
                        g_dwCreate_File_Creation,
                        g_dwCreate_File_Flags,
                        NULL );

            if(Error == ERROR_SUCCESS && hFile == INVALID_HANDLE_VALUE)
            {
                Error = GetLastError();
            }

            if(g_bWriteFile)
            {
                DWORD dwBytesWritten;
                if(!WriteFile(hFile, g_lpWriteFileBuf, g_dwFileSize, &dwBytesWritten, NULL))
                    Error = GetLastError();
            }

            CloseHandle(hFile);
        }
        StopPerfTimer(&GlobalCommandInfo[CmdCreateFile].PerfInfo);

        if(g_bPerfMode)
            DisplayPerfResults(&GlobalCommandInfo[CmdCreateFile].PerfInfo, szResultStr);
    }
    else
    {
        Error = ERROR_INVALID_PARAMETER;
    }

    return(Error);
}
//=================================================================================
DWORD
ProcessLoopCnt(
    DWORD argc,
    LPTSTR *argv
    )
{
    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessLoopCnt NumIterations\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    if(g_dwNumIterations == 1)
    {
        g_dwNumIterations = _tcstoul( argv[0], NULL, 0 );
        if(g_dwNumIterations < 1)
            g_dwNumIterations = 1;
    }

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessCmdLoopCnt(
    DWORD argc,
    LPTSTR *argv
    )
{
    if( argc < 1 ) {
        _ftprintf(stderr, _T( "Usage: ProcessCmdLoopCnt NumIterations\n" ));
        return( ERROR_INVALID_PARAMETER );
    }

    g_dwNumCmdIterations = _tcstoul( argv[0], NULL, 0 );
    if(g_dwNumCmdIterations < 1)
        g_dwNumCmdIterations = 1;

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return ERROR_SUCCESS;
}

//=================================================================================
BOOL
ProcessUseFile (
    DWORD argc,
    LPTSTR *argv
    )
{
    FILE *BatchFile = NULL;
    DWORD Error;
    DWORD i;
    COMMAND_CODE CommandCode;
    TCHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPTSTR CArgv[MAX_COMMAND_ARGS];

    DWORD CommandArgc;
    LPTSTR *CommandArgv;

    if(argc != 1)
        return FALSE;

    AppTimer.ElapsedTime = 0;

    g_bUseFile = TRUE;
    g_dwNumIterations  = 1;
    g_dwIteration = 0;
    while(g_dwIteration++ < g_dwNumIterations)
    {
        if((BatchFile = _tfopen (argv[0], _T( "r" ))) == NULL)
            return FALSE;
        while (fgets( InBuffer, DEFAULT_BUFFER_SIZE, BatchFile ))
        {
            InBuffer[_tcslen(InBuffer) -1] = 0;  //kill line feed for no param cmds

            CArgc = 0;
            ParseArguments( InBuffer, CArgv, &CArgc );

            if( CArgc < 1 ) {
                continue;
            }

            //
            // decode command.
            //
            CommandCode = DecodeCommand( CArgv[0] );
            if( CommandCode == UnknownCommand ) {
                _ftprintf(stderr, _T( "Unknown Command '%s'.\n" ), CArgv[0]);
                continue;
            }

            CommandArgc = CArgc - 1;
            CommandArgv = &CArgv[1];

///            _tprintf(_T( "%s " ), CArgv[0]);
///            for(i = 0; i < CommandArgc; i++)
///                _tprintf(_T( "%s " ), CommandArgv[i]);
///            _tprintf(_T( ", " ));

            StartPerfTimer(&AppTimer, ACCUM_TIMER);
            Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);
            StopPerfTimer(&AppTimer);
        }
///        _tprintf(_T( "===================[ End processing file ]===================\n" ));
        fclose (BatchFile);
    }

    _tprintf(_T( "UseFile, " ));
    if(g_bPerfMode)
        DisplayPerfResults(&AppTimer, NULL);

return TRUE;
}

//=================================================================================
DWORD
ProcessShowTime (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD Error, dwSize;
    FILETIME ftTemp;
    SYSTEMTIME SystemTime;

#ifdef CONFIGTEST
    TCHAR buff[4096];
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO)buff;

    dwSize = sizeof(buff);

    if (GetUrlCacheConfigInfo(lpCCI, &dwSize, CACHE_CONFIG_DISK_CACHE_PATHS_FC)) {

        int i;

        for (i=0; i<lpCCI->dwNumCachePaths; ++i) {

            lpCCI->CachePaths[i].dwCacheSize++;
        }

        SetUrlCacheConfigInfo(lpCCI, CACHE_CONFIG_DISK_CACHE_PATHS_FC);
    }

#endif //CONFIGTEST

    if(argc != 2)
        return 0xffffffff;

    sscanf(argv[0], _T( "%x" ), &(ftTemp.dwHighDateTime));
    sscanf(argv[1], _T( "%x" ), &(ftTemp.dwLowDateTime));

    if(FileTimeToSystemTime( &ftTemp, &SystemTime )) {
        _tprintf(_T( "%02u/%02u/%04u %02u:%02u:%02u\n " ),
                    SystemTime.wMonth,
                    SystemTime.wDay,
                    SystemTime.wYear,
                    SystemTime.wHour,
                    SystemTime.wMinute,
                    SystemTime.wSecond );

    }
    else {
        _tprintf(_T( "Wrong Times \n" ));
    }

    return ERROR_SUCCESS;
}

//=================================================================================
DWORD AllocWriteFileBuf(void)
{
    DWORD dwRC = ERROR_SUCCESS;

     if(g_lpWriteFileBuf != NULL)
        LocalFree(g_lpWriteFileBuf);

     if((g_lpWriteFileBuf = LocalAlloc(LPTR, g_dwFileSize * sizeof(TCHAR))) != NULL)
     {
         DWORD dwCnt;
         for(dwCnt = 0; dwCnt < g_dwFileSize; dwCnt++)
             *(g_lpWriteFileBuf + dwCnt) = (TCHAR)dwCnt % 256;
     }
     else
     {
         dwRC = GetLastError();
     }

     return(dwRC);
}

//=================================================================================
DWORD
ProcessSetFileSize (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwOldSize = g_dwFileSize;
    DWORD dwRC = ERROR_SUCCESS;

    g_dwFileSize = _tcstoul( argv[0], NULL, 0 );
                   
    if((g_dwFileSize > 0) && (g_dwFileSize != dwOldSize) && g_bWriteFile)
        dwRC = AllocWriteFileBuf();

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));

    return(dwRC);
}

//=================================================================================
DWORD
ProcessSetDiskCache1 (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_dwDiskCache = ((argc == 0) || (LSTRCMPI(argv[0], _T( "on" )) == 0)) ?(g_dwDiskCache | FILE_FLAG_NO_BUFFERING) :(g_dwDiskCache & ~FILE_FLAG_NO_BUFFERING);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetDiskCache2 (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_dwDiskCache = ((argc == 0) || (LSTRCMPI(argv[0], _T( "on" )) == 0)) ?(g_dwDiskCache | FILE_FLAG_WRITE_THROUGH) :(g_dwDiskCache & ~FILE_FLAG_WRITE_THROUGH);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetQuietMode (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_bQuietMode = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessSetPerfMode (
    DWORD argc,
    LPTSTR *argv
    )
{
    g_bPerfMode = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);
    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return ERROR_SUCCESS;
}

//=================================================================================
DWORD
ProcessWriteFile (
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;

    if(g_dwFileSize == 0)
    {
        _tprintf(_T( "You must specify a FileSize in order to turn WriteFile On.\n" ));
        dwRC = ERROR_INVALID_FUNCTION;
    }
    else
    {
        g_bWriteFile = (argc ?(LSTRCMPI(argv[0], _T( "on" )) == 0) :TRUE);

        if(g_bWriteFile && g_dwFileSize)
            dwRC = AllocWriteFileBuf();
    }

    if(!g_bUseFile)
        DisplayGlobalSettings();
    else
        _tprintf(_T( "\n" ));
    return(dwRC);
}

//=================================================================================
DWORD
ProcessCreateGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;
    _tprintf(_T( "CreateGroup...\n" ));
    return dwRC;
}
     
DWORD
ProcessDeleteGroup(
    DWORD argc,
    LPTSTR *argv
    )
{
    DWORD dwRC = ERROR_SUCCESS;
    _tprintf(_T( "DeleteGroup...\n" ));
    return dwRC;
}


//=================================================================================
DWORD
ProcessCommandCode (
    DWORD CommandCode,
    DWORD CommandArgc,
    LPTSTR *CommandArgv
    )
{
    DWORD Error = ERROR_SUCCESS;

        switch( CommandCode ) {
        case CmdCreateUrlCacheEntry :
            Error = ProcessCreateUrlCacheEntry( CommandArgc, CommandArgv );
            break;

        case CmdCommitUrlCacheEntry :
            Error = ProcessCommitUrlCacheEntry( CommandArgc, CommandArgv );
            break;
            
        case CmdUpdateUrlCacheEntry :
            Error = ProcessUpdateUrlCacheEntry( CommandArgc, CommandArgv );
            break;

        case CmdRetrieveUrlCacheEntryFile :
            Error = ProcessRetrieveUrlCacheEntryFile( CommandArgc, CommandArgv );
            break;

        case CmdRetrieveUrlCacheEntryStream :
            Error = ProcessRetrieveUrlCacheEntryStream( CommandArgc, CommandArgv );
            break;
#ifdef IE5
        case CmdUnlockUrlCacheEntryFile :
            Error = ProcessUnlockUrlCacheEntryFile( CommandArgc, CommandArgv );
            break;
#endif
        case CmdGetUrlCacheEntryInfo :
            Error = ProcessGetUrlCacheEntryInfo( CommandArgc, CommandArgv );
            break;

        case CmdSetUrlCacheEntryInfo :
            Error = ProcessSetUrlCacheEntryInfo( CommandArgc, CommandArgv );
            break;

        case CmdSetExempt:
            Error = ProcessSetExempt (CommandArgc, CommandArgv);
            break;

#ifdef IE5
        case CmdSetUrlCacheEntryGroup:
            Error = ProcessSetUrlCacheEntryGroup (CommandArgc, CommandArgv );
            break;

        case CmdDeleteUrlCacheEntry :
            Error = ProcessDeleteUrlCacheEntry( CommandArgc, CommandArgv );
            break;
#endif

        case CmdEnumUrlCacheEntries :
            Error = ProcessEnumUrlCacheEntries( CommandArgc, CommandArgv );
            break;

        case CmdEnumGroup :
            Error = ProcessEnumGroup( CommandArgc, CommandArgv );
            break;

        case CmdSimulateCache :
            Error = ProcessSimulateCache( CommandArgc, CommandArgv );
            break;

        case CmdCreateFile :
            Error = ProcessCreateFile( CommandArgc, CommandArgv );
            break;

        case CmdLoopCnt :
            Error = ProcessLoopCnt( CommandArgc, CommandArgv );
            break;

        case CmdCmdLoopCnt :
            Error = ProcessCmdLoopCnt( CommandArgc, CommandArgv );
            break;

        case CmdFreeCacheSpace :
            Error = ProcessFreeCacheSpace( CommandArgc, CommandArgv );
            break;

        case CmdShowTime:
            Error = ProcessShowTime( CommandArgc, CommandArgv );
            break;

        case CmdSetFileSize:
            Error = ProcessSetFileSize( CommandArgc, CommandArgv );
            break;

        case CmdSetDiskCache1:
            Error = ProcessSetDiskCache1( CommandArgc, CommandArgv );
            break;

        case CmdSetDiskCache2:
            Error = ProcessSetDiskCache2( CommandArgc, CommandArgv );
            break;

        case CmdSetQuietMode:
            Error = ProcessSetQuietMode( CommandArgc, CommandArgv );
            break;

        case CmdSetPerfMode:
            Error = ProcessSetPerfMode( CommandArgc, CommandArgv );
            break;

        case CmdWriteFile:
            Error = ProcessWriteFile( CommandArgc, CommandArgv );
            break;

        case CmdCreateGroup:
            Error = ProcessCreateGroup( CommandArgc, CommandArgv );
            break;

        case CmdDeleteGroup:
            Error = ProcessDeleteGroup( CommandArgc, CommandArgv );
            break;

        case CmdHelp :
            DisplayUsage();
            break;

        case CmdGetExQ :
            DisplayExemptQuota();
            break;

        case CmdQuit :

            _tprintf( _T( "---Results---\n" )
                _T( "Total Commands:    %d\n" )
                _T( "Failed Commands:   %d\n" )
                _T( "Bye Bye..\n" ),
                cCommands, cFails);
            if (DumpUrlList)
                fclose(DumpUrlList);
            if (UrlList)
                fclose(UrlList);

            exit (0);

        case CmdUseFile:
            if (!ProcessUseFile (CommandArgc, CommandArgv))
            {
                Error = ERROR_FILE_NOT_FOUND;
                _tprintf(_T( "File Not Found\n" ));
            }
            break;

        default:
            TestDbgAssert( FALSE );
            _ftprintf(stderr, _T( "Unknown Command Specified.\n" ));
            DisplayUsage();
            break;
        }
        cCommands++;

        if( Error != ERROR_SUCCESS ) {
            LPTSTR LPTSTR;

            cFails++;
            Format_Error(Error, &LPTSTR);
            _tprintf(_T( "FAILED (%s), %ld-%s.\n" ),
                GlobalCommandInfo[CommandCode].CommandName, Error, LPTSTR );
            LocalFree(LPTSTR);
        }
        else {
            if(!g_bQuietMode)
                _tprintf(_T( "Command (%s) successfully completed.\n" ), GlobalCommandInfo[CommandCode].CommandName );
        }
        return Error;
}


//=================================================================================
int __cdecl // _CRTAPI1
_tmain(
    int argc,
    TCHAR *argv[],
	TCHAR **envp
    )
{
    TCHAR szInternational[32];
    DWORD cbRet;

    DWORD Error;
    DWORD i;
    COMMAND_CODE CommandCode;
    TCHAR InBuffer[DEFAULT_BUFFER_SIZE];
    DWORD CArgc;
    LPTSTR CArgv[MAX_COMMAND_ARGS];

    DWORD CommandArgc;
    LPTSTR *CommandArgv;

#ifdef INTERNATIONAL
    //
    // THis is code for testing international strings.
    // intlgent.dll is a module which implements "GetRandomIntlString"
    // You need to install an international langpack 
    // for this to work. Also, switch your default codepage
    // or locale to that of the intl pack
    //
    hModule = LoadLibrary(_T("intlgent.dll"));

    if( hModule == NULL ) {
        _tprintf(_T("Unable to Load Library Intlgent.dll , GLE=%d\n"), GetLastError() );
        return 0;
    }

    fnGetRandIntlString = (FNGetRandIntlString)GetProcAddress(hModule,"GetRandIntlString");

    if(!fnGetRandIntlString) {
        _tprintf(_T("Did not find GetRandIntlString\n") );
    	return 0;
    }

    cbRet = fnGetRandIntlString(
                            32, //int iMaxChars, 
                            TRUE,   // BOOL bAbs, 
                            TRUE,   // BOOL bCheck, 
                            szInternational); // string to be returned


    _tprintf(_T("GetRandIntlString() returns %s\n"), szInternational );
#endif

#if 0
    //
    // other tests.
    //
    time_t Seed;

    Seed = time(NULL);
    _tprintf(_T( "RAND_MAX = %ld\n" ), RAND_MAX);
    _tprintf(_T( "Seed Random gen. w/ %ld\n" ), Seed);
    srand( Seed );

    TestMakeRandomUrlName();
#else // 0
    //
    // init GlobalCacheHeaderInfo buffer.
    //

	memset(GlobalCacheHeaderInfo, 0, sizeof(GlobalCacheHeaderInfo));
    //for( i = 0; i < CACHE_HEADER_INFO_SIZE; i++) {
    //    GlobalCacheHeaderInfo[i] = (BYTE)((DWORD)_T( '0' ) + i % 10);
    //}
    /* must check for batch mode.  if there are command line parms, assume batch mode */
    if (argc > 1)
    {
        //this means that the arguments translate directly into CommandArgc....
        CommandCode = DecodeCommand( argv[1] );
        if( CommandCode == UnknownCommand ) {
            _tprintf(_T( "Unknown Command Specified.\n" ));
            return -1;
        }

        Sleep(2000);    // Allow wininet's worker thread to finish so we get good timing

        CommandArgc = argc - 2;
        CommandArgv = &argv[2];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

        if (DumpUrlList)
            fclose(DumpUrlList);
        if (UrlList)
            fclose(UrlList);

        return 0;
    }

    DisplayUsage();

    for(;;) {
        _ftprintf(stderr, _T( "[" ));

#ifdef INTERNATIONAL
        _ftprintf(stderr, _T( "INTL " ));
#endif

#ifdef UNICODE
        _ftprintf(stderr, _T( "UNICODE" ));
#else
        _ftprintf(stderr, _T( "ANSI" ));
#endif

        _ftprintf(stderr, _T( "] Command : "));

        _getts( InBuffer );

        CArgc = 0;
        ParseArguments( InBuffer, CArgv, &CArgc );

        if( CArgc < 1 ) {
            continue;
        }

        //
        // decode command.
        //

        CommandCode = DecodeCommand( CArgv[0] );
        if( CommandCode == UnknownCommand ) {
            _ftprintf(stderr, _T( "Unknown Command Specified.\n" ));
            continue;
        }

        CommandArgc = CArgc - 1;
        CommandArgv = &CArgv[1];

        Error = ProcessCommandCode (CommandCode,CommandArgc,CommandArgv);

    }
#endif // 0

    FreeLibrary( hModule );

    return 0;
}

//=================================================================================
DWORD
GetLeafLenFromPath(
    LPTSTR   lpszPath
    )
{
    DWORD len, i;
    LPTSTR   lpT;

    if(!lpszPath)
        return(0);

    len = LSTRLEN(lpszPath);

    if (len == 0) {

        return (len);

    }

    lpT = lpszPath+len-1;
    if (*lpT ==_T( '\\' )) {
        --lpT;
    }
    for (; lpT >= lpszPath; --lpT) {
        if (*lpT == _T( '\\' )) {
            break;
        }
    }
    return (LSTRLEN(lpT));
}

//=================================================================================
DWORD WINAPIV Format_String(LPTSTR *plpsz, LPTSTR lpszFmt, ...)
{
    const TCHAR c_Func_Name[] = _T( "[Format_String] " );
    DWORD dwRet;
    va_list vArgs;

    va_start (vArgs, lpszFmt);
    dwRet = Format_StringV(plpsz, lpszFmt, &vArgs);
    va_end (vArgs);

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_Error(DWORD dwErr, LPTSTR *plpsz)
{
    DWORD dwRet;

    if(dwErr != ERROR_SUCCESS)
    {
        dwRet = Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            dwErr, plpsz, NULL, NULL);
    }
    else
    {
        const TCHAR szMsg[] = _T( "No Error" );
        Format_String(plpsz, (LPTSTR)szMsg);
        dwRet = LSTRLEN(szMsg);
    }

    return(dwRet);
}

//=================================================================================
DWORD WINAPI Format_StringV(LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    return(Format_MessageV(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
        0, plpsz, lpszFmt, vArgs));
}

// ***************************************************************************
DWORD WINAPI Format_MessageV(DWORD dwFlags, DWORD dwErr, LPTSTR *plpsz, LPCSTR lpszFmt, va_list *vArgs)
{
    const TCHAR c_Func_Name[] = _T( "[Format_MessageV]" );

    DWORD dwRet;
    DWORD dwGLE;

    *plpsz = NULL;
    dwRet = FormatMessage(dwFlags, lpszFmt, dwErr, 0, (LPTSTR) plpsz, 0, vArgs);

    if (!dwRet || !*plpsz)
    {
        dwGLE = GetLastError();
        _tprintf(_T( "%s FormatMessage Failed: %s. dwRet: %#lx!. *plpsz:%#lx! GLE:%d\r\n" ), c_Func_Name, lpszFmt, dwRet, *plpsz, dwGLE);

        if (*plpsz)
            LocalFree ((HLOCAL) *plpsz);
        *plpsz = NULL;
        return 0;
    }

    return(dwRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\utils\cdcache\cdcache.h ===
#define IDM_NEW            100
#define IDM_OPEN           101
#define IDM_SAVE           102
#define IDM_SAVEAS         103
#define IDM_PRINT          104
#define IDM_PRINTSETUP     105
#define IDM_EXIT           106
#define IDM_UNDO           200
#define IDM_CUT            201
#define IDM_COPY           202
#define IDM_PASTE          203
#define IDM_LINK           204
#define IDM_LINKS          205
#define IDM_HELPCONTENTS   300
#define IDM_HELPSEARCH     301
#define IDM_HELPHELP       302
#define IDM_ABOUT          303
#define IDM_HELPTOPICS     304
#define IDM_INSTALL        305
#define IDM_UNINSTALL	   306
#define IDM_SUCCESS		   307
#define IDM_SUCCESS_REMOVE 308
#define IDM_HEADER		   309
#define IDM_FAILED	310
#define IDM_FAILED_REMOVE	311
#define IDM_NEEDIE4WININET 312
#define IDM_ERR_IE4REQFORUNINSTALL	313

#define IDD_MAINAPP			1000
#define IDC_LIST			1001
#define IDC_HEADER			1002
#define IDC_QUESTION		1003

#define IDC_STATIC -1

#define DLG_VERFIRST        400
#define IDC_COMPANY			DLG_VERFIRST
#define IDC_FILEDESC       	DLG_VERFIRST+1
#define IDC_PRODVER         DLG_VERFIRST+2
#define IDC_COPYRIGHT       DLG_VERFIRST+3
#define IDC_OSVERSION       DLG_VERFIRST+4
#define IDC_TRADEMARK       DLG_VERFIRST+5
#define DLG_VERLAST         DLG_VERFIRST+5

#define IDC_LABEL           DLG_VERLAST+1

#define ID_COMPANY			1
#define ID_INFNAME			2
#define ID_APPNAME			3
#define ID_CMDLINE			4

// ============ VALUES ============
#define INI_YES			_T("Yes")
#define INI_NO                 _T("No")
#define INI_TRUE               _T("TRUE")
#define INI_FALSE              _T("FALSE")
#define INI_ON                 _T("ON")
#define INI_OFF                _T("OFF")

typedef struct _INTERNET_CACHE_CONTAINER_INFO_MAX {
    DWORD dwCacheVersion;       // version of software
    LPSTR lpszName;             // embedded pointer to the container name string.
    LPSTR lpszCachePrefix;      // embedded pointer to the container URL prefix
	LPSTR lpszPrefixMap;		// embedded pointer to the container data location
	DWORD dwKBCacheLimit;
	DWORD dwContainerType;
	DWORD dwOptions;
} INTERNET_CACHE_CONTAINER_INFO_MAX, * LPINTERNET_CACHE_CONTAINER_INFO_MAX;


/////////////////////////////////////////////////////////////////////////////
// class CWaitCursor

class CWaitCursor
{
// Construction/Destruction
public:
	CWaitCursor()
	{
		m_hWait = LoadCursor(NULL, IDC_WAIT);
		m_hSave = SetCursor(m_hWait);
	};

	~CWaitCursor()
	{
		SetCursor(m_hSave);	
	};

	HCURSOR	m_hSave;
	HCURSOR m_hWait;

// Operations
public:
	void Restore()
	{
		SetCursor(m_hSave);
	};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\utils\refcount\refcount.h ===
//=--------------------------------------------------------------------------=
//  (C) Copyright 1997-1998 Microsoft Corporation. All Rights Reserved.
//	TriEdit SDK team
//	Author: Yury Polyakovsky
//	contact: a-yurip@microsof.com
//=--------------------------------------------------------------------------=
class CRefCount
{
public:
	CRefCount() {m_dwRefCount = 1;}
	void SetInstalFlag(BOOL flag) {m_fInstall = flag;}
	void Change(char *szName, PHKEY phkRef);
	BOOL ValueExist(char *sz_RegSubkey, char *sz_RegValue);
	void ValueGet(char *sz_RegSubkey, char *sz_ValueName, LPBYTE *p_Value, DWORD *pdwValueSize);
	void ValueSet(char *sz_RegSubkey, char *sz_RegValue);
	void ValueClear(char *sz_RegSubkey, char *sz_RegValue);
	DWORD GetCount() { return m_dwRefCount;}
private:
	BOOL m_fInstall;
	DWORD m_dwRefCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\utils\refcount\refcount.cxx ===
//=--------------------------------------------------------------------------=
//  (C) Copyright 1997-1998 Microsoft Corporation. All Rights Reserved.
//	TriEdit SDK team
//	Author: Yury Polyakovsky
//	contact: a-yurip@microsof.com
//=--------------------------------------------------------------------------=
// Refcount support for DLLs
// Call:	refcount < Install | Uninstall | CopyToClient | SetClient | ClearClient | Copy >, <registry key> [, <file name>[, <client subdirectory> I <destination for Copy>] | <component full path>]
// Call refcount.exe from an application's setup: 
// Install : Increment ref-count for the component if it was not installed before by the app
// Uninstall : Decrement ref-count for the component if it was installed before by the app, deletes it if ref-count goes to 0
// CopyToClient : Copies the component to the application's directory (from the registry)
// SetClient : Set the flag in the registry that the component was installed by the application
// CreateDir : Checks on the directory  "C:\Program Files\Common Files" and create one if it's not there
// ClearClient :  Clear the flag in the registry that the component was installed by the application
// Copy: Copy to specified destination.
#include <ctype.h>
#include <windef.h>
#include <stdarg.h>
#include <stdlib.h>
#include <winbase.h>
#include <winreg.h>
#include <winuser.h>
#include <crtdbg.h>
#include <shlwapi.h>
#include "RefCount.h"

#define STRINGOP(func, param1, param2) 	(func(param1, param2, sizeof(param1)/sizeof(param1[0])))
#define STRINGOPL(func, param1, param2) 	(func(param1, param2, strlen(param1)))
#define SKIPSPACES(psz)	{for (++psz; *psz == ' ' && *psz != '\0'; ++psz); if (!*psz) psz=NULL;}
BOOL PASCAL ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew);

int WINAPI WinMain(  HINSTANCE hInstance,  // handle to current instance
  HINSTANCE hPrevInstance,  // handle to previous instance
  LPSTR lpCmdLine,      // pointer to command line
  int nCmdShow)          // show state of window);int main(int argc, char** argv)
{
	_ASSERT(*lpCmdLine);
	if (!*lpCmdLine)
	{
		// No command line
		return 1;
	}

	CRefCount	RefCount;
	char szRegKey[MAX_PATH] = "";
	char szRegInstalling[MAX_PATH] = "";
	char szRegInstalled[MAX_PATH] = "";
	char sz_AppPath[MAX_PATH] = "";
	char sz_Application[MAX_PATH] = "";
	char sz_Dir[MAX_PATH] = "";
	char *pszAppPath = sz_AppPath;
	char *pszApplication = sz_Application;
	BOOL bMultiInstall = FALSE;
	BOOL *pbInstallMode = &bMultiInstall;
	DWORD dwValueSize = sizeof(sz_AppPath);

	//_ASSERT(FALSE);

	if (!STRINGOPL(_strnicmp, "CreateDir", lpCmdLine/*argv[1]*/))
	{
		dwValueSize = sizeof(sz_Application);
		RefCount.ValueGet("SOFTWARE\\Microsoft\\Windows\\CurrentVersion", "CommonFilesDir", (LPBYTE *)&pszApplication, &dwValueSize);
		_ASSERT(pszApplication);
		if (pszApplication)
		{
			if (!CreateDirectory(pszApplication, NULL))
				DWORD dwError = GetLastError();
		}
		return 0;
	}

	LPSTR pszRegName = strchr(lpCmdLine, ',');
	_ASSERT(pszRegName);
	if (!pszRegName)
		// command line not complete
		return 1;

	SKIPSPACES(pszRegName);
	_ASSERT(pszRegName);
	if (!pszRegName)
		// command line not complete
		return 1;

	LPSTR pszPathName = strchr(pszRegName, ',');
	if (pszPathName)
	{
		SKIPSPACES(pszPathName);
	}
	STRINGOP(strncpy, szRegKey, pszRegName/*argv[2]*/);
	if (LPSTR pszEndRegName = strchr(szRegKey, ','))
		*pszEndRegName = '\0';
	STRINGOP(strncpy, szRegInstalling, szRegKey/*argv[2]*/);
	STRINGOP(strncat , szRegInstalling, "\\InstallingClient");
	RefCount.ValueGet(szRegInstalling, "Path", (LPBYTE *)&pszAppPath, &dwValueSize);
	dwValueSize = sizeof(sz_Application);
	RefCount.ValueGet(szRegInstalling, "Application", (LPBYTE *)&pszApplication, &dwValueSize);
	dwValueSize = sizeof(BOOL);
	RefCount.ValueGet(szRegInstalling, "MultiInstall", (LPBYTE *)&pbInstallMode, &dwValueSize);
	if (pszAppPath && ((pbInstallMode && bMultiInstall) || !STRINGOPL(_strnicmp, "CopyToClient", lpCmdLine/*argv[1]*/)))
	{
		STRINGOP(strncat, pszAppPath, "\\");
		STRINGOP(strncpy, sz_Dir, pszAppPath);
		STRINGOP(strncat, sz_AppPath, sz_Application);
	}
	else 
		STRINGOP(strncpy, sz_AppPath, sz_Application);

	// FInd the path in InstalledClients
	STRINGOP(strncpy, szRegInstalled, szRegKey/*argv[2]*/);
	STRINGOP(strncat, szRegInstalled, "\\InstalledClients");

	char szTmp[MAX_PATH];
	strcpy(szTmp, pszPathName);
	char* x = strchr(szTmp, ',');
	char szGUID[MAX_PATH];
	char* pszGUID = NULL;

	if( x )
	{
		// IE passed component guid so we need to check...
		strcpy(szGUID, x);
		*x = '\0';
		strcpy(pszPathName, szTmp);

		// now szGuid = " , {aab-cc-dd-ee}", need to stript white space and ','
		pszGUID = szGUID;
		for( int i = 0; i < MAX_PATH; i++)
		{
			if( *pszGUID != ' ' && *pszGUID != ',')
				break;
			pszGUID++;
		}
		if( i == MAX_PATH || *pszGUID == '\0' )
        {
			pszGUID = NULL;
        }
	}


	if (!STRINGOPL(_strnicmp, "CopyToClient", lpCmdLine/*argv[1]*/))
	{
		_ASSERT(pszPathName);
		if (!pszPathName)
			return 2;
		else
		{
			LPSTR pszDestSubDir = strchr(pszPathName, ',');
			if (pszDestSubDir)
			{
				SKIPSPACES(pszDestSubDir);
				STRINGOP(strncat, sz_Dir, pszDestSubDir);
				STRINGOP(strncat, sz_Dir, "\\");
			}
			if (LPSTR pszPathNameEnd = strchr(pszPathName, ','))
				*pszPathNameEnd = '\0';
			// Copy files we need for Uninstall to the client location
			STRINGOP(strncat, sz_Dir, pszPathName);
			if (LPSTR pszDestDirEnd = strchr(sz_Dir, ','))
				*pszDestDirEnd = '\0';
			if (!CopyFile(pszPathName/*argv[3]*/, sz_Dir, FALSE))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
				return 2;
			}
			return 0;
		}
	}
	else if (!STRINGOPL(_strnicmp, "Copy", lpCmdLine/*argv[1]*/))
	{
		_ASSERT(pszPathName);
		if (!pszPathName)
			return 2;
		else
		{
			LPSTR pszDestSubDir = strchr(pszPathName, ',');
			if (pszDestSubDir)
			{
				SKIPSPACES(pszDestSubDir);
				STRINGOP(strncpy, sz_Dir, pszDestSubDir);
			}
			if (LPSTR pszPathNameEnd = strchr(pszPathName, ','))
				*pszPathNameEnd = '\0';
			// Copy files we need for Uninstall to the client location
			if (LPSTR pszDestDirEnd = strchr(sz_Dir, ','))
				*pszDestDirEnd = '\0';
			if (!CopyFile(pszPathName/*argv[3]*/, sz_Dir, FALSE))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
				return 2;
			}
			return 0;
		}
	}
		else if (!RefCount.ValueExist(szRegInstalled, sz_AppPath) && !STRINGOPL(_strnicmp, "Install", lpCmdLine/*argv[1]*/))
		{
			// Increment ref-count
			if( pszGUID )
			{
				// some check needed...
				// is the component installed?
				HKEY hkInstalled = NULL;
				char szKeyName[MAX_PATH];
				strcpy(szKeyName, "SOFTWARE\\Microsoft\\Active Setup\\Installed Components\\");
				strcat(szKeyName, pszGUID);

				if( ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szKeyName, 0, KEY_ALL_ACCESS, &hkInstalled) 
				)
				{
					DWORD dwType = 0;
					BYTE bValueData[16];
					DWORD cValueData = sizeof(bValueData);;
					if (ERROR_SUCCESS == RegQueryValueEx( hkInstalled, "IsInstalled", NULL, &dwType, bValueData, &cValueData))
					{
						if( *(LPDWORD)(bValueData) )
						{
							// this app has been installed, we need to do nothing... (do not perform refcount, just quit)
							RegCloseKey(hkInstalled);
							return 0;
						}
						
					}
					RegCloseKey(hkInstalled);
				}
			}

			// we are here because 
			// 1. no guid passed from cmd line
			// 2. or component not installed (the RegQueryValue failed..)
			// so we continue to do refcount...

			RefCount.SetInstalFlag(TRUE);
		}
		else if (!RefCount.ValueExist(szRegInstalled, sz_AppPath) && !STRINGOPL(_strnicmp, "SetClient", lpCmdLine/*argv[1]*/))
		{
			// Set the app's installed flag
			RefCount.ValueSet(szRegInstalled, sz_AppPath);
			RegDeleteKey (HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else if (!STRINGOPL(_strnicmp, "Uninstall", lpCmdLine/*argv[1]*/))
		{
			// Decrement ref-count
			RefCount.SetInstalFlag(FALSE);
		}
		else if (!STRINGOPL(_strnicmp, "ClearClient", lpCmdLine/*argv[1]*/))
		{
			// Remove the app's installed flag
			RefCount.ValueClear(szRegInstalled, sz_AppPath);
			RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else if (!STRINGOPL(_strnicmp, "SetClient", lpCmdLine/*argv[1]*/))
		{
			// Subsequent Installation
			RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			return 0;
		}
		else
			// Subsequent Installation
			return 0;

	HKEY hkRef;    // address of handle to open key
	DWORD dwDisposition;   // address of disposition value buffer
	LONG lRet;

	lRet = RegCreateKeyEx  (HKEY_LOCAL_MACHINE, "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDLLs", 
		0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkRef, &dwDisposition);
	_ASSERT(REG_OPENED_EXISTING_KEY == dwDisposition);
	_ASSERT(ERROR_SUCCESS == lRet);
	if (ERROR_SUCCESS != lRet)
	{
		return 3;
	}

	_ASSERT(pszPathName);
	if (pszPathName)
	{
		RefCount.Change(pszPathName/*argv[3]*/, &hkRef);
		if (RefCount.GetCount() <= 0)
		{
			_ASSERT(RefCount.GetCount() == 0);
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalling); // we don't need it anymore
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegInstalled); // we don't need it anymore
			//RegDeleteKey(HKEY_LOCAL_MACHINE, szRegKey); // we don't need it anymore
		}
	}

	RegCloseKey(hkRef);

	return 0;
}

void CRefCount::Change(char *szName, PHKEY phkRef)
{
	DWORD dwIndex = 0;
	DWORD cValueName = 0;
	DWORD dwType = 0;
	BYTE bValueData[16];
	DWORD cValueData = sizeof(bValueData);;

	// Check if the conponent exits
	if (ERROR_SUCCESS == RegQueryValueEx( *phkRef, szName, NULL, &dwType, bValueData, &cValueData))
	{
		// Found
		_ASSERT(dwType == REG_DWORD);
		m_dwRefCount = *(LPDWORD)(bValueData);
		(m_fInstall) ? ++m_dwRefCount : --m_dwRefCount;
	}
	else if (!m_fInstall)
	{
		// Trying to Uninstall the component that was not ref-counted before
		// Just delete it
//		_ASSERT(m_fInstall);
		if (!DeleteFile(szName))
		{
			if (!ReplaceFileOnReboot(szName, NULL))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
			}
		}
		return;
	}
	// If not found, create new else just overwrite it.
	*(LPDWORD)(bValueData) = m_dwRefCount;
	if (m_dwRefCount == 0)
	{
        char szDllFullPath[MAX_PATH+1];
        DWORD dwLen = 0;
        dwLen = strlen(szName);
        char* p = NULL;
        if( dwLen <= MAX_PATH )
        {
            strcpy(szDllFullPath, szName);
            for( int i = dwLen; i >= 0; i--)
            {
                if( szDllFullPath[i] == '\\' ) 
                {
                    p = &(szDllFullPath[i+1]);    
                    break;
                }
            }
        }

		if( p && 
            !_stricmp(p, "msdapml.dll") && 
            !_stricmp(p, "msonsext.dll") &&
            !_stricmp(p, "ragent.tlb") &&
            !_stricmp(p, "ragent.dll") &&
            !_stricmp(p, "fp4autl.dll") &&
            !_stricmp(p, "fp4anwi.dll") 
        ) {
		    // Last rererence deleted
		    HINSTANCE hInst = LoadLibrary(szName);
		    FARPROC pDllUnregisterServer = NULL;
		    if (hInst && (pDllUnregisterServer = GetProcAddress(hInst, "DllUnregisterServer")))
		    {
			    pDllUnregisterServer();
		    }
		    else
		    {
			    DWORD dwError = GetLastError();
		    }

		    FreeLibrary(hInst);
        }

		RegDeleteValue(*phkRef, szName);

		if (!DeleteFile(szName))
		{
			if (!ReplaceFileOnReboot(szName, NULL))
			{
				DWORD dwError = GetLastError();
				_ASSERTE(!dwError);
			}
		}
        

		if( p && !_stricmp(p, "msonsext.dll") )
		{
	        LONG lRet =0;

			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"CLSID\\{BDEADF00-C265-11d0-BCED-00A0C90AB50F}");
			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"CLSID\\{BDEADF04-C265-11d0-BCED-00A0C90AB50F}");
			lRet = RegDeleteKey (HKEY_CLASSES_ROOT,"Publishing Folder");
			lRet = RegDeleteKey (HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\NameSpace\\{BDEADF00-C265-11d0-BCED-00A0C90AB50F}");

	        HKEY hkRef = NULL;  
			lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", 0, KEY_ALL_ACCESS, &hkRef);
	
	        if (ERROR_SUCCESS == lRet)
	        {
		        RegDeleteValue(hkRef, "{BDEADF00-C265-11d0-BCED-00A0C90AB50F}"); 
                RegCloseKey(hkRef);
	        }
		}
	}
	else
		RegSetValueEx(*phkRef, szName, 0, REG_DWORD, bValueData, sizeof(DWORD));
}

BOOL CRefCount::ValueExist(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	BOOL fret = FALSE;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		return FALSE;
	}
	else 
	{
		lRet = RegQueryValueEx(hkRef, sz_RegValue, 0, NULL, NULL, NULL);
		if (ERROR_SUCCESS != lRet)
			fret = FALSE;
		else
			fret = TRUE;
	}
	RegCloseKey(hkRef);
	return fret;
}

void CRefCount::ValueSet(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;
	DWORD dwDisposition;   // address of disposition value buffer

	lRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hkRef, &dwDisposition);
	
	_ASSERT(ERROR_SUCCESS == lRet);
	if (ERROR_SUCCESS != lRet)
	{
		return;
	}
	else 
	{
		RegSetValueEx(hkRef, sz_RegValue, 0, REG_DWORD, (BYTE  *)&dwValiue, sizeof(dwValiue));
	}
}

void CRefCount::ValueGet(char *sz_RegSubkey,  char *sz_ValueName, LPBYTE *p_Value, DWORD *pdwValueSize)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		*p_Value = NULL;
	}
	else 
	{
		lRet = RegQueryValueEx(hkRef, sz_ValueName, 0, NULL, *p_Value, pdwValueSize);
		if (ERROR_SUCCESS != lRet)
		{
			*p_Value = NULL;
		}
	}
}

void CRefCount::ValueClear(char *sz_RegSubkey, char *sz_RegValue)
{
	HKEY hkRef = NULL;    // address of handle to open key
	LONG lRet =0;
	DWORD dwValiue = 1;

	lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, sz_RegSubkey, 
		0, KEY_ALL_ACCESS, &hkRef);
	
	if (ERROR_SUCCESS != lRet)
	{
		return;
	}
	else 
	{
		RegDeleteValue(hkRef, sz_RegValue);
	}
}

BOOL PASCAL ReplaceFileOnReboot (LPCTSTR pszExisting, LPCTSTR pszNew) 
{
//	_ASSERT(FALSE);
   // First, attempt to use the MoveFileEx function.
   BOOL fOk = MoveFileEx(pszExisting, pszNew, MOVEFILE_DELAY_UNTIL_REBOOT);
   if (fOk) return(fOk);

   // If MoveFileEx failed, we are running on Windows 95 and need to add
   // entries to the WININIT.INI file (an ANSI file).
   // Start a new scope for local variables.
   {
   char szRenameLine[1024];   
   TCHAR szExistingShort[_MAX_PATH];

   GetShortPathName(pszExisting, szExistingShort, sizeof(szExistingShort) / sizeof(szExistingShort[0]));
   int cchRenameLine = wsprintfA(szRenameLine, 
#ifdef UNICODE
      "%ls=%ls\r\n", 
#else
      "%hs=%hs\r\n", 
#endif
      (pszNew == NULL) ? __TEXT("NUL") : pszNew, szExistingShort);
      char szRenameSec[] = "[Rename]\r\n";
      int cchRenameSec = sizeof(szRenameSec) - 1;
      HANDLE hfile, hfilemap;
      DWORD dwFileSize, dwRenameLinePos;
      TCHAR szPathnameWinInit[_MAX_PATH];

      // Construct the full pathname of the WININIT.INI file.
      GetWindowsDirectory(szPathnameWinInit, _MAX_PATH);
      lstrcat(szPathnameWinInit, __TEXT("\\WinInit.Ini"));

      // Open/Create the WININIT.INI file.
      hfile = CreateFile(szPathnameWinInit,      
         GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_ALWAYS, 
         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);

      if (hfile == INVALID_HANDLE_VALUE) 
         return(fOk);	// It is still FALSE

      // Create a file mapping object that is the current size of 
      // the WININIT.INI file plus the length of the additional string
      // that we're about to insert into it plus the length of the section
      // header (which we might have to add).
      dwFileSize = GetFileSize(hfile, NULL);
      hfilemap = CreateFileMapping(hfile, NULL, PAGE_READWRITE, 0, 
         dwFileSize + cchRenameLine + cchRenameSec, NULL);

      if (hfilemap != NULL) {

         // Map the WININIT.INI file into memory.  Note: The contents 
         // of WININIT.INI are always ANSI; never Unicode.
         LPSTR pszWinInit = (LPSTR) MapViewOfFile(hfilemap, 
            FILE_MAP_WRITE, 0, 0, 0);
		 pszWinInit[dwFileSize] = 0;	// Make sure it is null terminated. Yury

         if (pszWinInit != NULL) {

            // Search for the [Rename] section in the file.
            LPSTR pszRenameSecInFile = strstr(pszWinInit, szRenameSec);

            if (pszRenameSecInFile == NULL) {

               // There is no [Rename] section in the WININIT.INI file.
               // We must add the section too.
               dwFileSize += wsprintfA(&pszWinInit[dwFileSize], "%s",
                                       szRenameSec);
               dwRenameLinePos = dwFileSize;

            } else {

               // We found the [Rename] section, shift all the lines down
               PSTR pszFirstRenameLine = strchr(pszRenameSecInFile, '\n');
               // Shift the contents of the file down to make room for 
               // the newly added line.  The new line is always added 
               // to the top of the list.
               pszFirstRenameLine++;   // 1st char on the next line
               memmove(pszFirstRenameLine + cchRenameLine, pszFirstRenameLine, 
                  pszWinInit + dwFileSize - pszFirstRenameLine);                  
               dwRenameLinePos = pszFirstRenameLine - pszWinInit;
            }

            // Insert the new line
            memcpy(&pszWinInit[dwRenameLinePos], szRenameLine, cchRenameLine);

            UnmapViewOfFile(pszWinInit);

            // Calculate the true, new size of the file.
            dwFileSize += cchRenameLine;

            // Everything was successful.
            fOk = TRUE; 
         }
         CloseHandle(hfilemap);
      }

      // Force the end of the file to be the calculated, new size.
      SetFilePointer(hfile, dwFileSize, NULL, FILE_BEGIN);
      SetEndOfFile(hfile);

      CloseHandle(hfile);
   }

   return(fOk);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\place51.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\placefil5.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!ifndef IIS_NO_BBT
NTBBT=1
!endif

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifndef IIS_NO_PDB
USE_PDB=1
!endif

!if $(386)
!ifndef IIS_NO_SYM
USE_MAPSYM=1
!endif
!endif



#  !ifdef _NT386TREE
#  !if ("$(COMPUTERNAME)" == "X86CHK")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "X86FRE")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !else
#  _NT386TREE=$(_NT386TREE)\iis
#  !endif
#  !endif


#  !ifdef _NTMIPSTREE
#  _NTMIPSTREE=$(_NTMIPSTREE)\iis
#  !endif


#  !ifdef _NTALPHATREE
#  !if ("$(COMPUTERNAME)" == "ALPHACHK")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "ALPHAFRE")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !else
#  _NTALPHATREE=$(_NTALPHATREE)\iis
#  !endif
#  !endif


#  !ifdef _NTPPCTREE
#  _NTPPCTREE=$(_NTPPCTREE)\iis
#  !endif

#
# Enable warning level 3, treat warnings as errors
#

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3 /WX
!endif

#
# Don't allow anyone to disable warnings as errors.
#
# If any of the {platform}_WARNING_LEVEL macros are defined without
# the /WX switch, append /WX to the macro and whine about it.
#
!if 0

!ifdef 386_WARNING_LEVEL
! if ("$(386_WARNING_LEVEL:/WX=x)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=x)" == "$(386_WARNING_LEVEL)")
!  message 386_WARNING_LEVEL defined without /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! endif
!endif

!ifdef MIPS_WARNING_LEVEL
! if ("$(MIPS_WARNING_LEVEL:/WX=x)" == "$(MIPS_WARNING_LEVEL)") && ("$(MIPS_WARNING_LEVEL:-WX=x)" == "$(MIPS_WARNING_LEVEL)")
!  message MIPS_WARNING_LEVEL defined without /WX
MIPS_WARNING_LEVEL=$(MIPS_WARNING_LEVEL) /WX
! endif
!endif

!ifdef ALPHA_WARNING_LEVEL
! if ("$(ALPHA_WARNING_LEVEL:/WX=x)" == "$(ALPHA_WARNING_LEVEL)") && ("$(ALPHA_WARNING_LEVEL:-WX=x)" == "$(ALPHA_WARNING_LEVEL)")
!  message ALPHA_WARNING_LEVEL defined without /WX
ALPHA_WARNING_LEVEL=$(ALPHA_WARNING_LEVEL) /WX
! endif
!endif

!ifdef PPC_WARNING_LEVEL
! if ("$(PPC_WARNING_LEVEL:/WX=x)" == "$(PPC_WARNING_LEVEL)") && ("$(PPC_WARNING_LEVEL:-WX=x)" == "$(PPC_WARNING_LEVEL)")
!  message PPC_WARNING_LEVEL defined without /WX
PPC_WARNING_LEVEL=$(PPC_WARNING_LEVEL) /WX
! endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetcore\wininet\utils\cdcache\cdcache.cpp ===
/******************************************************************************\
*
*	CDCACHE.EXE
*
*	Synopsis:
*		An AutoRun EXE to enable easy addition of CD-ROM content
*		into the Internet Explorer (WININET) Persistent URL Cache.
*
*	Usage:
*		Place an AUTORUN.INF at the root of the CD-ROM which has content
*		that you want to register with the WININET Persistent URL Cache.
*		Contents of AUTORUN.INF:
*
*			[autorun]
*			open=cdcache.exe
*			icon=cdcache.exe, 1
*
*		Additionally create a CDCACHE.INF at the root of the CD-ROM.
*		Typical contents:
*
*			[Add.CacheContainer]
*			<Friendly Unique Vendor Name>=<INF Section Name>
*
*			[INF Section Name]
*			CachePrefix=<string>
*			CacheRoot=<relative path on CD-ROM of data>
*			KBCacheLimit=<numerical amount in KB>
*			AutoDelete=Yes|No (default)
*			IncludeSubDirs=Yes (default) |No
*			NoDesktopInit=Yes|No (default)
*
*
*		CMD Line Options:
*		/Silent		Install Cache Container without showing UI
*		/Remove     Uninstall the cache container
*		/Uninstall  same as /Remove
*
*	History
*		23June97	robgil				created
*		06Aug97		robgil				add IE4 wininet.dll checks
*		26Aug97		robgil				manual register if no IE4
*
*	Copyright (C) 1994-1997 Microsoft Corporation.
*	All rights reserved.
*
\******************************************************************************/
#include "stdhdr.h"

/////////////////////////////////////////////////////////////////////////
// Defines and Type Declarations

#define STRING_BUFFER_SIZE		256

#define CACHE_ACTION_INSTALL			0
#define CACHE_ACTION_REMOVE				1
#define CACHE_ACTION_FILL_LB			2
#define CACHE_ACTION_MAKE_REG_ENTRIES	3

typedef BOOL (CALLBACK* LPFNCREATEURLCACHECONTAINER)(LPCSTR,LPCSTR,LPCSTR,DWORD,DWORD,DWORD,LPVOID,LPDWORD);
typedef BOOL (CALLBACK* LPFNDELETEURLCACHECONTAINER)(LPCSTR,DWORD);
typedef HANDLE (CALLBACK* LPFNFINDFIRSTURLCACHECONTAINER)(LPDWORD,LPINTERNET_CACHE_CONTAINER_INFO,LPDWORD,DWORD);
typedef BOOL (CALLBACK* LPFNFINDNEXTURLCACHECONTAINER)(HANDLE,LPINTERNET_CACHE_CONTAINER_INFO,LPDWORD);
typedef BOOL (CALLBACK* LPFNFINDCLOSEURLCACHE)(HANDLE);
typedef BOOL (CALLBACK* LPFNGETURLCACHECONFIGINFO)(LPINTERNET_CACHE_CONFIG_INFO,LPDWORD,DWORD);

/////////////////////////////////////////////////////////////////////////
// Global Variables:

HINSTANCE g_hInst;			// current instance
BOOL g_fRunSilent = FALSE;	// True = show no UI
BOOL g_fRemove    = FALSE;	// True = remove the cache containers in INF
//BOOL g_fNoIE4Msg  = FALSE;	// True = do not show UI saying IE4 WININET is required
BOOL g_fNoIE4	  = FALSE;	// IE4 WININET is not available

TCHAR  gszIniValTrue[]			= INI_TRUE ;
TCHAR  gszIniValFalse[]			= INI_FALSE ;
TCHAR  gszIniValOn[]			= INI_ON ;
TCHAR  gszIniValOff[]			= INI_OFF ;

TCHAR  gszIniValYes[]			= INI_YES ;
TCHAR  gszIniValNo[]			= INI_NO ;

LPFNCREATEURLCACHECONTAINER		lpfnCreateUrlCacheContainer		= NULL;
LPFNDELETEURLCACHECONTAINER		lpfnDeleteUrlCacheContainer		= NULL;
LPFNFINDFIRSTURLCACHECONTAINER	lpfnFindFirstUrlCacheContainer	= NULL;
LPFNFINDNEXTURLCACHECONTAINER	lpfnFindNextUrlCacheContainer	= NULL;
LPFNFINDCLOSEURLCACHE			lpfnFindCloseUrlCache			= NULL;
LPFNGETURLCACHECONFIGINFO		lpfnGetUrlCacheConfigInfo		= NULL;

/////////////////////////////////////////////////////////////////////////
// Foward declarations of functions included in this code module:

INT_PTR CALLBACK DlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CenterWindow (HWND, HWND);
int OnInitDialog(HWND hDlg);

BOOL LoadWininet(void);
BOOL WininetLoaded(void);
BOOL CacheContainer(DWORD *dwTotal, DWORD *dwInstalled, DWORD dwAction, HWND hListBox);

HRESULT	ExpandEntry(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[]);

HRESULT ExpandVar(
        LPSTR& pchSrc,          // passed by ref!
        LPSTR& pchOut,          // passed by ref!
        DWORD& cbLen,           // passed by ref!
        DWORD cbBuffer,         // size of out buffer
        const char * szVars[],  // array of variable names eg. %EXE_ROOT%
        const char * szValues[]);// corresponding values to expand of vars

LPSTR GetINFDir(LPSTR lpBuffer, int nBuffSize);
LPSTR GetINFDrive(LPSTR lpBuffer, int nBuffSize);
WORD GetProfileBooleanWord(LPCTSTR szIniSection, LPCTSTR szKeyName, LPCTSTR szIniFile);
DWORD CreateAdditionalEntries(LPCSTR lpszUniqueVendorName, LPCSTR lpszVolumeTitle, LPCSTR lpszVolumeLabel, LPCSTR lpszPrefixMap);
DWORD GetPrefixMapEntry(LPCSTR lpszUniqueVendorName, LPSTR lpszPrefixMap, DWORD cbPrefixMap);
BOOL UrlCacheContainerExists(LPCSTR lpszUniqueVendorName, LPCSTR lpszCachePrefix, LPCSTR lpszPrefixMap);

// WININET CreateUrlCacheContainer WRAPPER
// Wraps up the hacks in one spot - see f() header for details
BOOL _CreateUrlCacheContainer(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
     IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
     IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,         // New - part of Wrapper.
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,
     IN DWORD dwOptions
     );


/************************************************************************\
 *    FUNCTION: WinMain
\************************************************************************/

int APIENTRY WinMain(HINSTANCE g_hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow)
{
	LPSTR   lpszCmd = NULL;
	DWORD	dwTotal = 0;
	DWORD	dwInstalled = 0;

	g_hInst = g_hInstance;

	// Parse lpCmdLine looking for options we understand
    TCHAR szTokens[] = _T("-/ ");
    LPTSTR lpszToken = _tcstok(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (_tcsicmp(lpszToken, _T("Silent"))==0)
            g_fRunSilent = TRUE;
        else if (_tcsicmp(lpszToken, _T("Remove"))==0)
			g_fRemove = TRUE;
		else if (_tcsicmp(lpszToken, _T("Uninstall"))==0)
			g_fRemove = TRUE;
//		else if (_tcsicmp(lpszToken, _T("NoIE4Msg"))==0)
//			g_fNoIE4Msg = TRUE;

        lpszToken = _tcstok(NULL, szTokens);
    }

	
	// Check for IE4 or higher WININET.DLL version
	// and dynamically load it and init global function pointers
	// to WININET f() used in this application
	// This will avoid Undefined Dynalink errors when run on a
	// system without IE4
	if (!LoadWininet())
	{
		g_fNoIE4 = TRUE;

		// Put up message about requiring IE4 WININET

		/* Since we workaround not having IE4 - no need for message
		 
		if (!g_fNoIE4Msg)
		{
			char szString[128];		// Keep string 70% larger for localization
			char szCaption[128];	// Keep string 70% larger for localization

			LoadString (g_hInst, ID_APPNAME, szCaption, sizeof(szCaption));
			LoadString (g_hInst, IDM_NEEDIE4WININET, szString, sizeof(szString));
			MessageBox(NULL, szString, szCaption, MB_OK);
		}
		*/

		// Can't call WININET
		// Need to make registry entries to install cache containers
		//
		if (!CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_FILL_LB, NULL))
		{
            if (g_fRunSilent)
            {
                // Create cache entries in silent mode.
                CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_MAKE_REG_ENTRIES, NULL);

            }
            else
            {
                // Otherwise run app.
                DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
            }
            return(FALSE);
		}

		return 0;	// Quit and go home
	}


	if (!g_fRunSilent)
	{
		// Only want to put up UI if any of the containers are NOT installed
		// (this includes those containers that are installed but the
		//  PrefixMap entry is incorrect - i.e. wrong drive)

		if (!CacheContainer(&dwTotal, &dwInstalled, CACHE_ACTION_FILL_LB, NULL))
		{
			DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
			return(FALSE);
		}
		else
		{
			// All the CacheContainers are already installed or there is no INF
			// so check if we want to uninstall
			// OnInitDialog checks the g_fRemove flags and POST's a msg
			// to dialog to initiate the Uninstall steps
			if (g_fRemove)
				DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_MAINAPP), NULL, DlgProc);
		}
	}
	else
	{
		DWORD	dwAction = CACHE_ACTION_INSTALL;	// default action is INSTALL

		// We're running silent and deep - all quiet on board
		// we don't need no stinkin window

		if (g_fRemove)
			dwAction = CACHE_ACTION_REMOVE;

		if (!CacheContainer(&dwTotal, &dwInstalled, dwAction, NULL))
		{
			// BUGBUG: Since we're running silent what
			// should we do on failure?
		}

		return 0;
	}
	
	return 0;
}

/************************************************************************\
 *    FUNCTION: DlgProc
\************************************************************************/

INT_PTR CALLBACK DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	int wmId, wmEvent;

	switch (message)
	{

		case WM_INITDIALOG:
			return OnInitDialog(hDlg);

		case WM_COMMAND:
			wmId    = LOWORD(wParam); // Remember, these are...
			wmEvent = HIWORD(wParam); // ...different for Win32!
		
			switch (wmId)
			{
				case IDM_INSTALL:
				{
					DWORD	dwError = 0;
					DWORD	dwTotal = 0;
					DWORD	dwInstalled = 0;
					DWORD	dwAction = 0;

					if (g_fNoIE4)
						dwAction = CACHE_ACTION_MAKE_REG_ENTRIES;
					else
						dwAction = CACHE_ACTION_INSTALL;

					if (!CacheContainer(&dwTotal, &dwInstalled, dwAction, NULL))
					{
						dwError = GetLastError();
					}

					if (dwInstalled > 0)
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Successfully installed a cache container
						// though not necessarily all of them.
						LoadString (g_hInst, IDM_SUCCESS, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwInstalled, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);

						// We're done close this app
						PostMessage (hDlg, WM_CLOSE, 0, 0);
					}
					else
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Unable to install any of the cache containers successfully
						LoadString (g_hInst, IDM_FAILED, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);
					}
					break;
				}

				case IDM_UNINSTALL:
				{
					DWORD	dwError = 0;
					DWORD	dwTotal = 0;
					DWORD	dwRemoved = 0;

					if (g_fNoIE4)
					{
						char szString[128];	// Keep string 70% larger for localization
						char szBuffer[256];

						// Uninstall of cache containers requires IE4
						LoadString (g_hInst, IDM_ERR_IE4REQFORUNINSTALL, szString, sizeof(szString));
						wsprintf(szBuffer, szString, dwRemoved, dwTotal);
						LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
						MessageBox(hDlg, szBuffer, szString, MB_OK);
					}
					else
					{

						if (!CacheContainer(&dwTotal, &dwRemoved, CACHE_ACTION_REMOVE, NULL))
						{
							dwError = GetLastError();
						}

						if (dwRemoved > 0)
						{
							char szString[128];	// Keep string 70% larger for localization
							char szBuffer[256];

							// Successfully UnInstalled a cache container
							// though not necessarily all of them.
							LoadString (g_hInst, IDM_SUCCESS_REMOVE, szString, sizeof(szString));
							wsprintf(szBuffer, szString, dwRemoved, dwTotal);
							LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
							MessageBox(hDlg, szBuffer, szString, MB_OK);
						}
						else
						{
							char szString[128];	// Keep string 70% larger for localization
							char szBuffer[256];

							// Unable to install any of the cache containers successfully
							LoadString (g_hInst, IDM_FAILED_REMOVE, szString, sizeof(szString));
							wsprintf(szBuffer, szString, dwTotal);
							LoadString (g_hInst, ID_APPNAME, szString, sizeof(szString));
							MessageBox(hDlg, szBuffer, szString, MB_OK);
						}
					}

					if (g_fRemove)
					{
						// We're done close this app
						PostMessage (hDlg, WM_CLOSE, 0, 0);
					}

					break;
				}

				case IDCANCEL:
					EndDialog(hDlg, TRUE);
					break;

				default:
					return (FALSE);
			}
			break;

		default:
			return (FALSE);
	}
	return (TRUE);
}


/************************************************************************\
 *    FUNCTION: CenterWindow
\************************************************************************/
// This is a 'utility' function I find usefull. It will center one
// window over another. It also makes sure that the placement is within
// the 'working area', meaning that it is both within the display limits
// of the screen, -and- not obscured by the tray or other frameing
// elements of the desktop.
BOOL CenterWindow (HWND hwndChild, HWND hwndParent)
{
	RECT    rChild, rParent, rWorkArea = {0,0,0,0};
	int     wChild, hChild, wParent, hParent;
	int     wScreen, hScreen, xScreen, yScreen, xNew, yNew;
	BOOL bResult;

	// Get the Height and Width of the child window
	GetWindowRect (hwndChild, &rChild);
	wChild = rChild.right - rChild.left;
	hChild = rChild.bottom - rChild.top;

	// Get the Height and Width of the parent window
	GetWindowRect (hwndParent, &rParent);
	wParent = rParent.right - rParent.left;
	hParent = rParent.bottom - rParent.top;

	// Get the limits of the 'workarea'
#if !defined(SPI_GETWORKAREA)
#define SPI_GETWORKAREA 48
#endif
	bResult = SystemParametersInfo(
    	SPI_GETWORKAREA,	// system parameter to query or set
    	sizeof(RECT),	// depends on action to be taken
    	&rWorkArea,	// depends on action to be taken
    	0);	

	wScreen = rWorkArea.right - rWorkArea.left;
	hScreen = rWorkArea.bottom - rWorkArea.top;
	xScreen = rWorkArea.left;
	yScreen = rWorkArea.top;

	// On Windows NT, the above metrics aren't valid (yet), so they all return
	// '0'. Lets deal with that situation properly:
	if (wScreen==0 && hScreen==0) {
		wScreen = GetSystemMetrics(SM_CXSCREEN);
		hScreen = GetSystemMetrics(SM_CYSCREEN);
		xScreen = 0; // These values should already be '0', but just in case
		yScreen = 0;
	}

	// Calculate new X position, then adjust for screen
	xNew = rParent.left + ((wParent - wChild) /2);
	if (xNew < xScreen) {
		xNew = xScreen;
	} else if ((xNew+wChild) > wScreen) {
		xNew = (xScreen + wScreen) - wChild;
	}

	// Calculate new Y position, then adjust for screen
	yNew = rParent.top  + ((hParent - hChild) /2);
	if (yNew < yScreen) {
		yNew = yScreen;
	} else if ((yNew+hChild) > hScreen) {
		yNew = (yScreen + hScreen) - hChild;
	}

	// Set it, and return
	return SetWindowPos (hwndChild, NULL, xNew, yNew, 0, 0, SWP_NOSIZE | SWP_NOZORDER);
}

int OnInitDialog(HWND hDlg)
{
	HWND	hListBox;
	DWORD	dwRemoved = 0;
	DWORD	dwTotal = 0;

	CenterWindow (hDlg, GetDesktopWindow ());

	hListBox = GetDlgItem(hDlg, IDC_LIST);

	// Populate list box with Cache Container list
	CacheContainer(&dwTotal, &dwRemoved, CACHE_ACTION_FILL_LB, hListBox);

	// #57353 - after adding don't show UI if already installed
	// we forgot to account for /uninstall on cmd line
	if (g_fRemove)
		PostMessage(hDlg, WM_COMMAND, IDM_UNINSTALL, 0L);

	return FALSE;
}

/************************************************************************\
*   FUNCTION: LoadWininet()
*
*	If IE4 or greater version of WININET then load it up and establish
*	function pointers to use in rest of application.
*
*	returns BOOL
*		TRUE  - Sufficient version of WININET.DLL is available
*		FALSE - WININET.DLL is not new enough for our purposes
*
\************************************************************************/
BOOL LoadWininet()
{
	HINSTANCE	hDll;

	hDll = LoadLibrary("WININET.DLL");

	if (hDll != NULL)
	{
		lpfnCreateUrlCacheContainer = (LPFNCREATEURLCACHECONTAINER)GetProcAddress(hDll, "CreateUrlCacheContainerA");
		lpfnDeleteUrlCacheContainer = (LPFNDELETEURLCACHECONTAINER)GetProcAddress(hDll, "DeleteUrlCacheContainerA");
		lpfnFindFirstUrlCacheContainer = (LPFNFINDFIRSTURLCACHECONTAINER)GetProcAddress(hDll, "FindFirstUrlCacheContainerA");
		lpfnFindNextUrlCacheContainer = (LPFNFINDNEXTURLCACHECONTAINER)GetProcAddress(hDll, "FindNextUrlCacheContainerA");
		lpfnFindCloseUrlCache = (LPFNFINDCLOSEURLCACHE)GetProcAddress(hDll, "FindCloseUrlCache");
		lpfnGetUrlCacheConfigInfo = (LPFNGETURLCACHECONFIGINFO)GetProcAddress(hDll, "GetUrlCacheConfigInfoA");

		if ( (!lpfnCreateUrlCacheContainer) ||
			 (!lpfnDeleteUrlCacheContainer) ||
			 (!lpfnFindFirstUrlCacheContainer) ||
			 (!lpfnFindNextUrlCacheContainer) ||
			 (!lpfnFindCloseUrlCache) ||
			 (!lpfnGetUrlCacheConfigInfo) )
		{
			
			lpfnCreateUrlCacheContainer = NULL;
			lpfnDeleteUrlCacheContainer = NULL;
			lpfnFindFirstUrlCacheContainer = NULL;
			lpfnFindNextUrlCacheContainer = NULL;
			lpfnFindCloseUrlCache = NULL;
			lpfnGetUrlCacheConfigInfo = NULL;

			FreeLibrary(hDll);

			return FALSE;
		}
	}
	else
		return FALSE;

	return TRUE;
}

/************************************************************************\
*   FUNCTION: WininetLoaded()
*
*	returns BOOL
*		TRUE  - Sufficient version of WININET.DLL is available
*		FALSE - WININET.DLL is not new enough for our purposes
*
\************************************************************************/
BOOL WininetLoaded()
{
	if (lpfnCreateUrlCacheContainer)
		return TRUE;

	return FALSE;
}

/************************************************************************\
*   FUNCTION: UrlCacheContainerExists()
*
*
*	returns BOOL
*		TRUE  - This cache container is already installed and PrefixMap
*				location is correct
*		FALSE - Cache container is not installed or it's PrefixMap
*				location is different
*
\************************************************************************/

BOOL UrlCacheContainerExists(LPCSTR lpszUniqueVendorName, LPCSTR lpszCachePrefix, LPCSTR lpszPrefixMap)
{
	BYTE	bBuf[4096];
	LPINTERNET_CACHE_CONTAINER_INFO lpCCI = (LPINTERNET_CACHE_CONTAINER_INFO) bBuf;
	DWORD	cbCEI = sizeof(bBuf);
	DWORD	dwModified = 0;
	HANDLE	hEnum = NULL;
	BOOL	bFound = FALSE;

	BOOL	bReturn = FALSE;

	if (!WininetLoaded())
		return FALSE;

	// Look for our cache container, then determine if it already exists
	// also need to make sure PrefixMap entry is correct
	// for situation when CD is placed into a different drive
	// after it's already been installed
	hEnum = lpfnFindFirstUrlCacheContainer(&dwModified, lpCCI, &cbCEI, 0);

	if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
		bFound = TRUE;
	else
	{
		while (hEnum && lpfnFindNextUrlCacheContainer(hEnum, lpCCI, &cbCEI))
		{
			if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
			{
				bFound = TRUE;
				break;
			}
		}
	}

	if (bFound)
	{
		// Now check if URL CachePrefix pattern is the same
		if (0 == lstrcmpi(lpszCachePrefix, lpCCI->lpszCachePrefix))
		{
			char	lpBuffer[256];
			DWORD	cbBuffer = sizeof(lpBuffer);

			// Now check if PrefixMap entry is OK
			GetPrefixMapEntry(lpszUniqueVendorName, lpBuffer, cbBuffer);
			
			if (0 == lstrcmpi(lpBuffer, lpszPrefixMap))
				bReturn = TRUE;
			else
				bReturn = FALSE;

			// If both CachePrefix and PrefixMap match
			// then we consider this entry to already exist
			// and is correctly installed.
		}
	}

	if (hEnum)
		lpfnFindCloseUrlCache(hEnum);

	return bReturn;
}

/************************************************************************\
*   FUNCTION: _CreateUrlCacheContainer()
*
*	Wrapper around WININET CreateUrlCacheContainer()
*
*	Parameters:
*
*	REMOVED
*   lpszUserLocalCachePath
*					Don't need to pass it in since can figure it out
*					using GetUrlCacheConfigInfo()
*
*   ADDED
*	lpszPrefixMap	Param added to wrapper, is missing from WININET f()
*					Specifies the location root path of the data
*					provided by the cache container.
*
*	Workaround #1 - Pre-poplulate registry with PrefixMap
*	-----------------------------------------------------
*	In order to work properly must pre-populate registry
*	with the PrefixMap entry. Otherwise WININET CreateUrlCacheContainer()
*	will not install the cache container.
*
*	STEP #1:
*	========
*	Must setup registry entry in
*	HKCU\Software\Microsoft\Windows\CurrentVersion\
*		Internet Settings\Cache\Extensible Cache
*
*	For PrefixMap
*	Key = <Unique Vendor Name>
*		PrefixMap		= <string>
*
*
*	Other Entries include:
*		CacheLimit		= <DWORD>
*		CacheOptions	= <DWORD>
*		CachePath		= <string>
*		CachePrefix		= <string>
*	These should be put there by the call to CreateUrlCacheContainer()
*
*	STEP #2
*	=======
*	Call CreateUrlCacheContainer()
*
*	Locates all the 'workarounds' to one function.
\************************************************************************/
BOOL _CreateUrlCacheContainer(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
	 IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
	 IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,         // New - part of WRAPPER
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,			// Not used by WININET currently
     IN DWORD dwOptions
     )
{
	// Enough size to get our info first time without having to realloc
    BYTE bBuf[4096];
    LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) bBuf;
    DWORD cbCEI = sizeof(bBuf);

	DWORD dwError = 0;
	char szCachePath[MAX_PATH];

    DWORD	dwResult = ERROR_SUCCESS;

	if (!WininetLoaded())
		return FALSE;
    
    
    // Figure out local user cache location directory
	if (!lpfnGetUrlCacheConfigInfo(lpCCI, &cbCEI, CACHE_CONFIG_CONTENT_PATHS_FC))
	{
		// Look for ERROR_INSUFFICIENT_BUFFER and allocate enough
		if (ERROR_INSUFFICIENT_BUFFER == GetLastError())
		{
			// BUGBUG: TODO: Handle insufficient buffer case
			// Try again using required size returned in cbCEI
			//lpCCI = new INTERNET_CACHE_CONFIG_INFO[cbCEI];
		}
		else
			dwError = GetLastError();
	}
	else
	{
		if (lpCCI->dwNumCachePaths > 0)
			lstrcpy(szCachePath, lpCCI->CachePaths[0].CachePath);
	}

	// Add Cache Container Unique Vendor Name to CachePath
	// All container content will be stored in this location
	if(lstrlen(szCachePath) + lstrlen(lpszUniqueVendorName) >= sizeof(szCachePath) / sizeof(szCachePath[0]))
	{
		return FALSE;
	}

	lstrcat(szCachePath, lpszUniqueVendorName);

	// Manually put PrefixMap into Registry
	// HKCU\Software\Microsoft\Windows\CurrentVersion\
	//		Internet Settings\Cache\Extensible Cache
	CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

	// BUGBUG: Currently CreateUrlCacheContainer() fails if the entry
	// already exists. The returned GetLastError() is ERROR_INVALID_PARAM
	// Need to workaround this for now by enumerating the existing
	// cache containers and if found remove it and then re-add it.

	if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
				szCachePath, KBCacheLimit, dwContainerType,
				dwOptions, NULL, 0))
	{
		BYTE	bBuf[4096];
		LPINTERNET_CACHE_CONTAINER_INFO lpCCI = (LPINTERNET_CACHE_CONTAINER_INFO) bBuf;
		DWORD	cbCEI = sizeof(bBuf);
		DWORD	dwModified = 0;
		HANDLE	hEnum = NULL;
		int		nCount = 0;

		// Assume we failed because cache container already exists
		// Look for our cache container, delete it, and re-create it
		hEnum = lpfnFindFirstUrlCacheContainer(&dwModified, lpCCI, &cbCEI, 0);

		if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
		{
			// BUGBUG: Need to specify any options?
			if (!lpfnDeleteUrlCacheContainer(lpszUniqueVendorName, 0))
			{
				dwResult = GetLastError();
			}
			else
			{
				CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

				if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
							szCachePath, KBCacheLimit, dwContainerType,
							dwOptions, NULL, 0))
				{
					dwResult = GetLastError();
				}
			}
		}
		else
		{
			while (hEnum && lpfnFindNextUrlCacheContainer(hEnum, lpCCI, &cbCEI))
			{
				if (0 == lstrcmpi(lpszUniqueVendorName, lpCCI->lpszName))
				{
					if (!lpfnDeleteUrlCacheContainer(lpszUniqueVendorName, 0))
					{
						dwResult = GetLastError();
					}
					else
					{
						CreateAdditionalEntries(lpszUniqueVendorName, lpszVolumeTitle, lpszVolumeLabel, lpszPrefixMap);

						if (!lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
									szCachePath, KBCacheLimit, dwContainerType,
									dwOptions, NULL, 0))
						{
							dwResult = GetLastError();
						}

						break;
					}
				}

				nCount++;
			}
		}

		if (hEnum)
			lpfnFindCloseUrlCache(hEnum);

	}

	if (dwResult != ERROR_SUCCESS)
		return (FALSE);
	else
		return (TRUE);

//	return lpfnCreateUrlCacheContainer(lpszUniqueVendorName, lpszCachePrefix,
//				szCachePath, KBCacheLimit, dwContainerType,
//				dwOptions, NULL, 0);
}

/************************************************************************\
*   FUNCTION: CreateAdditionalEntries()
*
*	Add the PrefixMap registry entry to the correct location in the
*	registry. A requirement to workaround this param missing from
*	the CreateUrlCacheContainer() WININET API.
*
\************************************************************************/

DWORD CreateAdditionalEntries(LPCSTR lpszUniqueVendorName, LPCSTR lpszVolumeTitle, 
                              LPCSTR lpszVolumeLabel, LPCSTR lpszPrefixMap)
{
    const static char *szKeyPrefixMap   = "PrefixMap";
    const static char *szKeyVolumeLabel	= "VolumeLabel";
    const static char *szKeyVolumeTitle	= "VolumeTitle";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";
    
	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	DWORD	dwResult = ERROR_SUCCESS;
    CHAR szCurDir[MAX_PATH];
    CHAR szVolumeLabel[MAX_PATH];

	// Manually put PrefixMap into Registry
	//
	// BUGBUG: cache containers are per user if user profiles are enabled
	// so on NT they are always per user, on Win95 however 
	// Need to use HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE below
	// depending on what's enabled.
	//
	// Hack on top of a Hack for Win95 ONLY
	// Since this entire function is to workaround the lack of a param
	// for PrefixMap in CreateUrlCacheContainer() another hack shouldn't
	// matter since it's only temporary
	// On Win95 need to check this entry
	// HKEY_LOCAL_MACHINE\Network\Logon
	//		UserProfiles=DWORD:00000001
	// which says if UserProfiles are turned on
	// If they are turned on we use HKEY_CURRENT_USER
	// otherwise use HKEY_LOCAL_MACHINE
	
	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist

			// Let's try to create it
			dwResult = RegCreateKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
				NULL, &hKeyVendor, &dwDisposition);

        }    
    
    }

    if (dwResult == ERROR_SUCCESS)
    {
        RegSetValueEx(hKeyVendor, szKeyPrefixMap, 0, REG_SZ,
            (CONST UCHAR *) lpszPrefixMap, lstrlen(lpszPrefixMap)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeLabel, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeLabel, lstrlen(lpszVolumeLabel)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeTitle, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeTitle, lstrlen(lpszVolumeTitle)+1);
    }        
    
    
        
	return dwResult;
}

/************************************************************************\
*   FUNCTION: GetPrefixMapEntry()
*
*	Get the PrefixMap registry entry from the correct location in the
*	registry.
*
*	Returns: PrefixMap entry in lpszPrefixMap
*			 or NULL if no enty is found.
*
\************************************************************************/

DWORD GetPrefixMapEntry(LPCSTR lpszUniqueVendorName, LPSTR lpszPrefixMap, DWORD cbPrefixMap)
{
    const static char *szKeyPrefixMap = "PrefixMap";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";

	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	unsigned long	ulVal = 0;
	DWORD	dwResult = ERROR_SUCCESS;

	// Manually put PrefixMap into Registry
	//
	// BUGBUG: cache containers are per user if user profiles are enabled
	// so on NT they are always per user, on Win95 however 
	// Need to use HKEY_CURRENT_USER or HKEY_LOCAL_MACHINE below
	// depending on what's enabled.
	//
	// Hack on top of a Hack for Win95 ONLY
	// Since this entire function is to workaround the lack of a param
	// for PrefixMap in CreateUrlCacheContainer() another hack shouldn't
	// matter since it's only temporary
	// On Win95 need to check this entry
	// HKEY_LOCAL_MACHINE\Network\Logon
	//		UserProfiles=DWORD:00000001
	// which says if UserProfiles are turned on
	// If they are turned on we use HKEY_CURRENT_USER
	// otherwise use HKEY_LOCAL_MACHINE
	
	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

	if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist
			lpszPrefixMap[0] = '\0';
		}
		else	// key did exist so lets return it in lpszPrefixMap
		{
			// Vendor name must be unique so is it ok to assume uniqueness?
			if ( (dwResult = RegQueryValueEx(hKeyVendor, szKeyPrefixMap, 0, &ulVal,
				(LPBYTE) lpszPrefixMap, &cbPrefixMap ))
				 == ERROR_SUCCESS )
			{
			}
			else
				lpszPrefixMap[0] = '\0';
		}
	}
	else
		lpszPrefixMap[0] = '\0';

	return dwResult;
}

/************************************************************************\
*   FUNCTION: WriteCacheContainerEntry()
*
* Manually write all the registry entries that WININET CreateUrlCacheContainer
* would normally write.
*
* This f() is used when IE4 WININET is not yet installed.
*
\************************************************************************/

DWORD WriteCacheContainerEntry(
     IN LPCSTR lpszUniqueVendorName,
     IN LPCSTR lpszCachePrefix,
     IN LPCSTR lpszPrefixMap,			// New - part of WRAPPER
     IN LPCSTR lpszVolumeTitle,	        // New - part of WRAPPER
     IN LPCSTR lpszVolumeLabel,	        // New - part of WRAPPER
     IN DWORD KBCacheLimit,
     IN DWORD dwContainerType,			// Not used by WININET currently
     IN DWORD dwOptions
	 )

{
    const static char *szCachePrefix    = "CachePrefix";
    const static char *szKeyPrefixMap   = "PrefixMap";
    const static char *szKeyVolumeLabel	= "VolumeLabel";
    const static char *szKeyVolumeTitle	= "VolumeTitle";
    const static char *szCacheLimit     = "CacheLimit";
    const static char *szCacheOptions   = "CacheOptions";
    const static char *szCachePath      = "CachePath";
	const static char *szExtCacheRoot = "Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Cache\\Extensible Cache";
    
	HKEY hKeyRoot	  = HKEY_CURRENT_USER;	// default to current user
	HKEY hKeyCacheExt = 0;
	HKEY hKeyVendor   = 0;
	DWORD dwDisposition = 0;
	DWORD	dwResult = ERROR_SUCCESS;
	CHAR lpszCachePath[MAX_PATH];

	OSVERSIONINFO	osvInfo;

	memset(&osvInfo, 0, sizeof(osvInfo));
	osvInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (GetVersionEx(&osvInfo))
	{
		if (VER_PLATFORM_WIN32_WINDOWS == osvInfo.dwPlatformId)
		{
			// We're running on Win95 so default to HKLM
			hKeyRoot = HKEY_LOCAL_MACHINE;
		}
		else
			hKeyRoot = HKEY_CURRENT_USER;	// else assume NT and default to HKCU

		DWORD dwType = REG_DWORD;
		DWORD dwSize = sizeof(DWORD);
		DWORD dwUserProfiles = 0;

		HKEY hKeyProfiles = 0;

		BYTE bBuf[4096];
		LPINTERNET_CACHE_CONFIG_INFO lpCCI = (LPINTERNET_CACHE_CONFIG_INFO) bBuf;
		DWORD cbCEI = sizeof(bBuf);

		if (!lpfnGetUrlCacheConfigInfo)
		{
			HINSTANCE	hDll;

			hDll = LoadLibrary("WININET.DLL");

			if (hDll != NULL)
			{
				lpfnGetUrlCacheConfigInfo = (LPFNGETURLCACHECONFIGINFO)GetProcAddress(hDll, "GetUrlCacheConfigInfoA");

				if (!lpfnGetUrlCacheConfigInfo)
				{
					FreeLibrary(hDll);
					dwResult = -1;		// Indicate failure
				}
			}
		}

		if (lpfnGetUrlCacheConfigInfo)
		{
			// Figure out local user cache location directory
			// Note: Need to use IE3 backward compatible flag
			// IE3:   CACHE_CONFIG_DISK_CACHE_PATHS_FC
			// IE4:   CACHE_CONFIG_CONTENT_PATHS_FC
			if (lpfnGetUrlCacheConfigInfo(lpCCI, &cbCEI, CACHE_CONFIG_DISK_CACHE_PATHS_FC))
			{
				// Now need to parse the returned CachePath to remove trailing 'cache1\'
				// "c:\windows\Temporary Internet Files\cache1\"
				// look for backslash starting from end of string
				int i = lstrlen(lpCCI->CachePaths[0].CachePath);

				while( (lpCCI->CachePaths[0].CachePath[i] != '\\') && (i >= 0) )
					   i--;

				if (lpCCI->CachePaths[0].CachePath[i] == '\\')
					lpCCI->CachePaths[0].CachePath[i+1] = '\0';		// Leave '\' intact for later strcat

				if (lpCCI->dwNumCachePaths > 0)
					lstrcpy(lpszCachePath, lpCCI->CachePaths[0].CachePath);

				// Add Cache Container Unique Vendor Name to CachePath
				// All container content will be stored in this location
				if(lstrlen(lpszCachePath) + lstrlen(lpszUniqueVendorName) >= sizeof(lpszCachePath) / sizeof(lpszCachePath[0]))
				{
					return FALSE;
				}

				lstrcat(lpszCachePath, lpszUniqueVendorName);
			}
		}
		else
		{
			// No IE3 or IE4 WININET present
			// so synthesize CachePath from GetWinDir() + "Temporary Internet Files"

			if ( GetWindowsDirectory(lpszCachePath, MAX_PATH) > 0)
			{
				if ('\\' == lpszCachePath[lstrlen(lpszCachePath)-1])
					lstrcat(lpszCachePath, _T("Temporary Internet Files"));
				else
				{
					lstrcat(lpszCachePath, _T("\\"));
					lstrcat(lpszCachePath, _T("Temporary Internet Files"));
				}
			}

		}

		// But now have to see if User Profiles are enabled
		if ((dwResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE, "Network\\Logon",
								NULL, KEY_ALL_ACCESS, &hKeyProfiles)) == ERROR_SUCCESS)
		{
			if ((dwResult = RegQueryValueEx(hKeyProfiles, "UserProfiles",
								NULL, &dwType, (unsigned char *)&dwUserProfiles,
								&dwSize)) == ERROR_SUCCESS)
			{
				if ( (dwResult != ERROR_MORE_DATA) &&
					 (1L == dwUserProfiles) )
							hKeyRoot = HKEY_CURRENT_USER;
				else
					hKeyRoot = HKEY_LOCAL_MACHINE;
			}
		}
	}


	if ( (dwResult = RegCreateKeyEx(hKeyRoot, szExtCacheRoot,
			0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS,
			NULL, &hKeyCacheExt, &dwDisposition)) == ERROR_SUCCESS)
	{
	
		if ( (dwResult = RegOpenKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, KEY_ALL_ACCESS, &hKeyVendor)) != ERROR_SUCCESS)
		{
			// Key didn't exist

			// Let's try to create it
			dwResult = RegCreateKeyEx(hKeyCacheExt, lpszUniqueVendorName,
				0, NULL, REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
				NULL, &hKeyVendor, &dwDisposition);

        }    
    
    }

    if (dwResult == ERROR_SUCCESS)
    {
        RegSetValueEx(hKeyVendor, szKeyPrefixMap, 0, REG_SZ,
            (CONST UCHAR *) lpszPrefixMap, lstrlen(lpszPrefixMap)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeLabel, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeLabel, lstrlen(lpszVolumeLabel)+1);
            
        RegSetValueEx(hKeyVendor, szKeyVolumeTitle, 0, REG_SZ,
            (CONST UCHAR *) lpszVolumeTitle, lstrlen(lpszVolumeTitle)+1);

        RegSetValueEx(hKeyVendor, szCachePrefix, 0, REG_SZ,
            (CONST UCHAR *) lpszCachePrefix, lstrlen(lpszCachePrefix)+1);

        RegSetValueEx(hKeyVendor, szCachePath, 0, REG_SZ,
            (CONST UCHAR *) lpszCachePath, lstrlen(lpszCachePath)+1);

        RegSetValueEx(hKeyVendor, szCacheLimit, 0, REG_DWORD,
            (unsigned char *)&KBCacheLimit, sizeof(DWORD));

        RegSetValueEx(hKeyVendor, szCacheOptions, 0, REG_DWORD,
            (unsigned char *)&dwOptions, sizeof(DWORD));
	
	}        
    
    
	if (dwResult != ERROR_SUCCESS)
		return (FALSE);
	else
		return (TRUE);
}

/************************************************************************\
*    FUNCTION: CacheContainer()
*
*	 Parameters:
*		dwAction - flag indicating what to do
*					CACHE_ACTION_INSTALL
*					CACHE_ACTION_REMOVE
*					CACHE_ACTION_FILL_LB
*
*		hListBox - HWND to ListBox to fill in with Container names
*
*
*		Note:
*				if dwAction == CACHE_ACTION_FILL_LB then if hListBox  
*				is NULL then return TRUE if ALL Containers installed
*				correctly or FALSE if not
*  
*		Additionally create a CDCACHE.INF at the root of the CD-ROM.
*		Typical contents:
*
*			[Add.CacheContainer]
*			<Unique Vendor Name>=<INF Section Name>
*			Encarta 97=EncartaCD
*
*			[INF Section Name]
*			VolumeLabel=<string>
*			VolumeTitle=<string>
*			CachePrefix=<string>
*			CacheRoot=<relative path on CD-ROM of data>
*			KBCacheLimit=<numerical amount in KB>
*			AutoDelete=Yes|No (default)
*			IncludeSubDirs=Yes|No (default)
*			NoDesktopInit=Yes|No (default)
*
*			[EncartaCD]
*			VolumeLabel=MSENCART97
*			VolumeTitle=Microsoft Encarta CD 97
*			CachePrefix=http://www.microsoft.com/encarta
*			CacheRoot=%EXE_ROOT%\data\http
*			KBCacheLimit=500
*			AutoDelete=Yes
*			IncludeSubDirs=Yes
*
*	NOTE: %EXE_ROOT% is a replaceable param that gets set to the
*		path this EXE was ran from, such as E: or E:\BIN
*
*
*	Calls _CreateUrlCacheContainer()
\************************************************************************/
BOOL CacheContainer(DWORD *dwTotal, DWORD *dwInstalled, DWORD dwAction, HWND hListBox)
{
    BOOL	bRet = FALSE;
    BOOL    bVolumeLabel = FALSE;
    DWORD	dwRes = 0;
	HRESULT hr = 0;
	
	int nSectionSize = 4096;	// Limit each INF section to 4K
	char szSections[4096];
	char *lpSections = (char *)szSections;

    const static char *szAddCacheContainerSection = "Add.CacheContainer";
    const static char *szKey_Name			= "Name";
    const static char *szKey_VolumeTitle	= "VolumeTitle";
    const static char *szKey_Prefix			= "CachePrefix";
    const static char *szKey_Root			= "CacheRoot";
    const static char *szKey_CacheLimit		= "KBCacheLimit";
    const static char *szKey_AutoDelete		= "AutoDelete";
    const static char *szKey_IncludeSubDirs = "IncludeSubDirs";
    const static char *szKey_NoDesktopInit	= "NoDesktopInit";
	char szDefault[12] = "*Unknown*"; // note: buffer needs to hold larger strings
	DWORD len;

	char szInf[STRING_BUFFER_SIZE];
	char szInfPath[MAX_PATH];
	char szContainerName[STRING_BUFFER_SIZE];
	char szCachePrefix[STRING_BUFFER_SIZE];
	char szCacheRoot[MAX_PATH];
	char szPrefixMap[MAX_PATH];
    char szVolumeLabel[MAX_PATH];
    char szMapDrive[4];
    char szVolumeTitle[MAX_PATH];
	char szAutoDelete[STRING_BUFFER_SIZE];
	char szIncludeSubDirs[STRING_BUFFER_SIZE];
	char szNoDesktopInit[STRING_BUFFER_SIZE];

	int			nDefault = 0;
	int			nCacheLimit = 0;
	BOOL		bResult;
	HANDLE		hFile;

#define SIZE_CMD_LINE   2048

    char szBuf[SIZE_CMD_LINE];  // enough for commandline

    // BEGIN NOTE: add vars and values in matching order
    // add a var by adding a new define VAR_NEW_VAR = NUM_VARS++
    const char *szVars[] =
	{
#define VAR_EXE_ROOT     0       // Replace with drive+path (ex. "D:" or "D:\PATH") of this EXE
        "%EXE_ROOT%",

#define VAR_EXE_DRIVE    1       // Replace with drive (ex. "D:") of this EXE
        "%EXE_DRIVE%",

#define NUM_VARS        2
        ""
    };

	int nValBuffSize = MAX_PATH;
    char lpValBuffer[MAX_PATH];
	int nDriveBuffSize = MAX_PATH;
    char lpDriveBuffer[MAX_PATH];
    const char *szValues[NUM_VARS + 1];
    szValues[VAR_EXE_ROOT] = GetINFDir(lpValBuffer, nValBuffSize);
	szValues[VAR_EXE_DRIVE] = GetINFDrive(lpDriveBuffer, nDriveBuffSize);
    szValues[NUM_VARS] = NULL;
    // END NOTE: add vars and values in matching order

	CWaitCursor wait;

	// Look for INF
	//
	LoadString (g_hInst, ID_INFNAME, szInf, sizeof(szInf));
	lstrcpy(szInfPath, GetINFDir(szInfPath, sizeof(szInfPath)) );
	strcat (szInfPath, "\\");
	strcat (szInfPath, szInf);
	strcat (szInfPath, ".INF");
	hFile = CreateFile(szInfPath, GENERIC_READ, FILE_SHARE_READ, NULL,
					   OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


	if (INVALID_HANDLE_VALUE != hFile)
	{
		CloseHandle(hFile);
		hFile = NULL;

		// Is there a [Add.CacheContainer] section

		// BUGBUG: GetPrivateProfileSection() fails on Win95
		// Workaround for GetPrivateProfileSection() failure on Win95
		szDefault[0] = '\0';
		len = GetPrivateProfileString(szAddCacheContainerSection, NULL, szDefault,
									lpSections, nSectionSize, szInfPath);


		if (!len)
		{
			// no CD-ROM Cache Container sections in INF
			// BUGBUG: Display a message if in NON Silent mode?

			// This is case where AUTORUN.INF has no [Add.Container] section

		}
		else
		{
			// lpBuffer now has list of key strings (as in key=value)
			// final pair terminated with extra NULL
			//
			// Loop through each cache container entry
			while (*lpSections)
			{
				WORD  dResult   = 0;
                
                // Init flags for this container to map-able.
                DWORD dwOptions = INTERNET_CACHE_CONTAINER_MAP_ENABLED;	

				GetPrivateProfileString(szAddCacheContainerSection, lpSections, szDefault,
								szContainerName, STRING_BUFFER_SIZE, szInfPath);

				if (szContainerName)
				{
					(*dwTotal)++;	// Keep track of how many cache containers in INF

					// Build PrefixMap
					//
					// BUGBUG: Default to root?
					lstrcpy(szDefault, "%EXE_ROOT%");
					// Get the PrefixMap entry
					dwRes = GetPrivateProfileString(szContainerName, szKey_Root, szDefault,
											szCacheRoot, MAX_PATH, szInfPath);

					// Replace any %parameters%
					// S_OK indicates that something was expanded
					if (S_OK == (hr = ExpandEntry(szCacheRoot, szBuf, SIZE_CMD_LINE, szVars, szValues)))
						lstrcpyn(szPrefixMap, szBuf, sizeof(szPrefixMap));
					else
						lstrcpy(szPrefixMap, szCacheRoot);


                    memcpy(szMapDrive, szPrefixMap, 2);
                    memcpy(szMapDrive + 2, "\\", sizeof("\\"));
                    if (GetVolumeInformation(szMapDrive, szVolumeLabel, MAX_PATH, 
                             NULL, NULL, NULL, NULL, 0))
                    {
                        bVolumeLabel = TRUE;
                    }
                    else
                    {
                        *szVolumeLabel = '\0';
                        bVolumeLabel = FALSE;
                    }

					lstrcpy(szDefault, "");
					GetPrivateProfileString(szContainerName, szKey_Prefix, szDefault,
											szCachePrefix, STRING_BUFFER_SIZE, szInfPath);

                    lstrcpy(szDefault, "");
					GetPrivateProfileString(szContainerName, szKey_VolumeTitle, szDefault,
											szVolumeTitle, STRING_BUFFER_SIZE, szInfPath);
 
					// Now trim off trailing backslash '\' from szCachePrefix
					// workaround for #43375
					int i = lstrlen(szCachePrefix);

					if (i > 0)
						if ('\\' == szCachePrefix[i - 1])
							szCachePrefix[i - 1] = '\0';

					// BUGBUG: Should create custom Profile f() to
					// read/return DWORD value rather than int
					nDefault = 500;	// 500K Cache Limit
					nCacheLimit = GetPrivateProfileInt(szContainerName, szKey_CacheLimit,
													   nDefault, szInfPath);

					dResult = GetProfileBooleanWord(szContainerName, szKey_AutoDelete, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is No/False for AutoDelete
						case FALSE:
							break;
						case TRUE:
							dwOptions |= INTERNET_CACHE_CONTAINER_AUTODELETE;
							break;
					}

					dResult = GetProfileBooleanWord(szContainerName, szKey_IncludeSubDirs, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is Yes/True for IncludeSubDirs
						case FALSE:
							dwOptions |= INTERNET_CACHE_CONTAINER_NOSUBDIRS;	// Don't include subdirs in cacheview
							break;
						case TRUE:
							break;
					}

					dResult = GetProfileBooleanWord(szContainerName, szKey_NoDesktopInit, szInfPath);
					switch (dResult)
					{
						case -1:	// The key did not exist in INF
							break;	// default is No/False for NoDesktopInit
						case FALSE:
							break;
						case TRUE:
							dwOptions |= INTERNET_CACHE_CONTAINER_NODESKTOPINIT;
							break;
					}


					switch (dwAction)
					{
					case CACHE_ACTION_INSTALL:
						// Call CreateUrlCacheContainer WRAPPER
                        if (bVolumeLabel)
                        {
                            bRet = _CreateUrlCacheContainer(lpSections, szCachePrefix, szPrefixMap, 
                                                            szVolumeTitle, szVolumeLabel, nCacheLimit, 0, dwOptions);
                        }
                        else
                        {
                            bRet = FALSE;
                        }

						break;
					case CACHE_ACTION_REMOVE:
						if (!WininetLoaded())
							return FALSE;

						bRet = lpfnDeleteUrlCacheContainer(lpSections, dwOptions);
						break;
					case CACHE_ACTION_FILL_LB:
						// Fill listbox hListBox

						if (hListBox)
						{
							SendMessage(hListBox, LB_ADDSTRING, 0, (LPARAM)lpSections);
						}
						else
						{
							// hListBox is NULL
							//
							//	if dwAction == CACHE_ACTION_FILL_LB then if hListBox  
							//	is NULL then return TRUE if ALL Containers installed
							//	correctly or FALSE if not
							//

							if (UrlCacheContainerExists(lpSections, szCachePrefix, szPrefixMap))
								bRet = TRUE;
							else
								return FALSE;	// One container is not installed so bail out
						}

						break;
					case CACHE_ACTION_MAKE_REG_ENTRIES:
                        if (bVolumeLabel)
                        {
						    bRet = WriteCacheContainerEntry(lpSections, szCachePrefix, szPrefixMap, szVolumeTitle, 
                                                            szVolumeLabel, nCacheLimit, 0, dwOptions);
                        }
                        else
                            bRet = FALSE;


						break;
					}

					if (bRet)
						(*dwInstalled)++;	// Keep track of successful installs
				}
				//else empty section entry, ignore and move to next
				
				// Get Next Section name
				while ( (*(lpSections++) != '\0')  );

			}
		}
	}
	else
	{
		// Couldn't find INF file
		// BUGBUG: need to do anything else here?
	}

	return bRet;
}

/************************************************************************\
*    FUNCTION: ExpandEntry()
*
* Borrowed from urlmon\download\hooks.cxx
\************************************************************************/
HRESULT	ExpandEntry(
    LPSTR szSrc,
    LPSTR szBuf,
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
	//Assert(szSrc);

    HRESULT hr = S_FALSE;

    LPSTR pchSrc = szSrc;     // start parsing at begining of cmdline

    LPSTR pchOut = szBuf;       // set at begin of out buffer
    DWORD cbLen = 0;

    while (*pchSrc) {

        // look for match of any of our env vars
        if (*pchSrc == '%') {

            HRESULT hr1 = ExpandVar(pchSrc, pchOut, cbLen, // all passed by ref!
                cbBuffer, szVars, szValues);  

            if (FAILED(hr1)) {
                hr = hr1;
                goto Exit;
            }


            if (hr1 == S_OK) {    // expand var expanded this
                hr = hr1;
                continue;
            }
        }
            
        // copy till the next % or nul
        if ((cbLen + 1) < cbBuffer) {

            *pchOut++ = *pchSrc++;
            cbLen++;

        } else {

            // out of buffer space
            *pchOut = '\0'; // term
            hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
            goto Exit;

        }


    }

    *pchOut = '\0'; // term


Exit:

    return hr;

}

/************************************************************************\
*    FUNCTION: ExpandVar()
*
* Borrowed from urlmon\download\hooks.cxx
\************************************************************************/
HRESULT ExpandVar(
    LPSTR& pchSrc,          // passed by ref!
    LPSTR& pchOut,          // passed by ref!
    DWORD& cbLen,           // passed by ref!
    DWORD cbBuffer,
    const char * szVars[],
    const char * szValues[])
{
    HRESULT hr = S_FALSE;
    int cbvar = 0;

    //Assert (*pchSrc == '%');

    for (int i=0; szVars[i] && (cbvar = lstrlen(szVars[i])) ; i++) { // for each variable

        int cbneed = 0;

        if ( (szValues[i] == NULL) || !(cbneed = lstrlen(szValues[i])))
            continue;

        cbneed++;   // add for nul

        if (0 == strncmp(szVars[i], pchSrc, cbvar)) {

            // found something we can expand

                if ((cbLen + cbneed) >= cbBuffer) {
                    // out of buffer space
                    *pchOut = '\0'; // term
                    hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
                    goto Exit;
                }

                lstrcpy(pchOut, szValues[i]);
                cbLen += (cbneed -1); //don't count the nul

                pchSrc += cbvar;        // skip past the var in pchSrc
                pchOut += (cbneed -1);  // skip past dir in pchOut

                hr = S_OK;
                goto Exit;

        }
    }

Exit:

    return hr;
    
}

// Return drive+path without trailing backslash
LPSTR GetINFDir(LPSTR lpBuffer, int nBuffSize)
{
	// Figure out what directory we've been started in
	GetModuleFileName(g_hInst, lpBuffer, nBuffSize);

	// Now trim off trailing backslash '\' if any
	int i = lstrlen(lpBuffer);

	if (i > 0)
		if ('\\' == lpBuffer[i - 1])
			lpBuffer[i - 1] = '\0';

	// Get rid of executable name
	i = lstrlen(lpBuffer);

	while( (lpBuffer[i] != '\\') && (i >= 0) )
		   i--;

	if (lpBuffer[i] == '\\')
		lpBuffer[i] = '\0';


	return lpBuffer;
}


// Return drive without trailing backslash
LPSTR GetINFDrive(LPSTR lpBuffer, int nBuffSize)
{
	// Figure out what directory we've been started in
	GetModuleFileName(g_hInst, lpBuffer, nBuffSize);

	if (!lpBuffer)
		return NULL;

	LPSTR lpSaveBuffer = lpBuffer;

	// Now trim off everything after first colon ':'
	if (':' == lpBuffer[1])
		lpBuffer[2] = '\0';
	else
	{
		// assumption that lpBuffer of form "D:\path" failed
		// so actually parse it
		// #48022 robgil - add check for end of lpBuffer string
		while (*lpBuffer != '\0' && *lpBuffer != ':')
			lpBuffer++;

		if (':' == *lpBuffer)
			*(lpBuffer + 1) = '\0';
		else
		{
			// #48022
			// Need to return \\server\share
			// for Drive when a UNC path
			lpBuffer = lpSaveBuffer;

			if ('\\' == lpBuffer[0] && '\\' == lpBuffer[1])
			{
				lpBuffer += 2;	// move past leading '\\'

				while (*lpBuffer != '\0' && *lpBuffer != '\\')
					lpBuffer++;

				if ('\\' == *lpBuffer)
				{
					lpBuffer++;

					while (*lpBuffer != '\0' && *lpBuffer != '\\')
						lpBuffer++;

					if ('\\' == *lpBuffer)
						*lpBuffer = '\0';
				}
			}

		}

	}

	return lpSaveBuffer;
}


//------------------------------------------------------------------------
//  BOOL GetProfileBooleanWord
//
//  Description:
//     Retrieves the value associated with szKeyName and
//     evaluates to a TRUE or FALSE.  If a value is not
//     associated with the key, -1 is returned.
//
//  Parameters:
//     LPSTR szKeyName
//        pointer to key name
//
//  Return Value:
//     WORD
//        -1, if a setting for the given key does not exist
//        TRUE, if value evaluates to a "positive" or "true"
//        FALSE, otherwise
//
//------------------------------------------------------------------------

WORD GetProfileBooleanWord
(
	LPCTSTR			szIniSection,
	LPCTSTR         szKeyName,
    LPCTSTR			szIniFile
)
{
	TCHAR	szTemp[10];

	GetPrivateProfileString( szIniSection,
							 szKeyName, _T(""), szTemp, sizeof( szTemp ),
                             szIniFile ) ;

	if (0 == lstrlen( szTemp ))
		return ( (WORD) -1 ) ;

	if ((0 == lstrcmpi( szTemp, gszIniValTrue )) ||
	   (0 == lstrcmpi( szTemp, gszIniValYes )) ||
	   (0 == lstrcmpi( szTemp, gszIniValOn )))
		return ( TRUE ) ;

	// Try and convert something numeric
	if (0 != _ttoi(szTemp))		// atoi (via tchar.h)
		return ( TRUE );

	return ( FALSE ) ;

} // end of GetProfileBooleanWord()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wrapmb.h ===
#ifndef _WRAPMB_
#define _WRAPMB_

/*++

Notes:  I made some changes to this library to build both a UNICODE and ANSI version

        RonaldM

--*/

#include "iadmw.h"

//--------------------------------------------------------
// startup & closeing utilities

BOOL     FInitMetabaseWrapper( OLECHAR* pocMachineName );
BOOL     FCloseMetabaseWrapper();

//
// As above, privately maintaining the interface
//
BOOL     FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab );
BOOL     FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab);


//--------------------------------------------------------
class CWrapMetaBase
    {
    public:
    WORD m_count;
    // construct - destruct
    CWrapMetaBase();
    ~CWrapMetaBase();

    // second stage initialization
    BOOL FInit( PVOID pMBCom = NULL);

    // open, close and save the object and such
    BOOL Open( LPCTSTR pszPath, DWORD dwFlags = METADATA_PERMISSION_READ );
    BOOL Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath,
               DWORD dwFlags = METADATA_PERMISSION_READ );

    BOOL Close( void );
    BOOL Save( void );

    // enumerate the objects
    BOOL EnumObjects( LPCTSTR pszPath, LPTSTR Name, DWORD cbNameBuf, DWORD Index );

    // Add and delete objects
    BOOL AddObject( LPCTSTR pszPath );
    BOOL DeleteObject( LPCTSTR pszPath );

    // rename an object
    BOOL RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName );

    // access the metahandle
    METADATA_HANDLE QueryHandle();

    // setting values
    BOOL SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPCTSTR dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD cbData, DWORD dwFlags = METADATA_INHERIT );

    // getting values
    BOOL GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD* dwValue, DWORD dwFlags = METADATA_INHERIT );
    BOOL GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD cchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetMultiSZString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, LPTSTR pszValue, DWORD cchValue,
                            DWORD dwFlags = METADATA_INHERIT );
    BOOL GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            PVOID pData, DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );
    PVOID GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                            DWORD* pcbData, DWORD dwFlags = METADATA_INHERIT );

    // deleting values
    BOOL DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType );

    // free memory returned by GetData
    void FreeWrapData( PVOID pData );

    protected:
    // pointer to the real metabase object as defined in mb.hxx
    // by casting it PVOID, those files including this will not have to include mb.hxx, which
    // is the whole point of wrapping it like this.
    // PVOID   m_pvMB;

    // pointer to the dcom interface it should use
    IMSAdminBase *       m_pMetabase;

    // the open metabase handle
    METADATA_HANDLE     m_hMeta;

    // size of the local buffer
    #define BUFFER_SIZE     2000

    // local buffer - allocated once, used many times
    PVOID   m_pBuffer;
    DWORD   m_cbBuffer;


    // path conversion utilities
    WCHAR * PrepPath( LPCTSTR psz );
    void UnprepPath();

    WCHAR * m_pPathBuffer;
    DWORD   m_cchPathBuffer;
    };

#endif //_WRAPMB_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\wrapmb.cpp ===
/*++

Module Name:

    wrapmb.cpp

Abstract:

    wrapper classes for the metabase class. Yes, I am wrapping a wrapper. Why?
        because including mb.hxx totally screws up the headers in my stdafx based
        MFC files. This way they can just include wrapmb.h and not have to worry
        about including all the other stuff. Also, I can set INITGUID here. That
        way I can use precompiled headers in the main project to Greatly increase
        compile times. If that isn't reason enough, then I can also manage the pointer
        to the interface object itself here.

Author:

   Boyd Multerer boydm

--*/
#include "stdafx.h"
#include <objbase.h>
#include <initguid.h>
#include <iadmw.h>

#include "iiscnfgp.h"
#include "wrapmb.h"

#ifdef _NO_TRACING_
DECLARE_DEBUG_PRINTS_OBJECT();
#endif

#define     MB_TIMEOUT          5000


// a macro to automatically cast the pointer to the mb object
//#define _pmb    ((MB*)m_pvMB)


// globals
IMSAdminBase*                g_pMBCom = NULL;



//----------------------------------------------------------------
BOOL    FInitMetabaseWrapperEx( OLECHAR* pocMachineName, IMSAdminBase ** ppiab )
    {
    IClassFactory *  pcsfFactory = NULL;
    COSERVERINFO     csiMachineName;
    COSERVERINFO *   pcsiParam = NULL;

    HRESULT          hresError;

    if(!ppiab)
    {
        return FALSE;
    }

    //fill the structure for CoGetClassObject
    ZeroMemory( &csiMachineName, sizeof(csiMachineName) );
    // csiMachineName.pAuthInfo = NULL;
    // csiMachineName.dwFlags = 0;
    // csiMachineName.pServerInfoExt = NULL;
    csiMachineName.pwszName = pocMachineName;
    pcsiParam = &csiMachineName;

    hresError = CoGetClassObject(
        GETAdminBaseCLSID(TRUE),
        CLSCTX_SERVER,
        pcsiParam,
        IID_IClassFactory,
        (void**) &pcsfFactory
        );

    if (FAILED(hresError))
    {
        return FALSE;
    }

    // create the instance of the interface
    hresError = pcsfFactory->CreateInstance(NULL, IID_IMSAdminBase, (void **)ppiab);
    if (FAILED(hresError))
    {
        *ppiab = NULL;
        return FALSE;
    }

    // release the factory
    pcsfFactory->Release();

    // success
    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapperEx(IMSAdminBase ** ppiab)
    {
    if ( ppiab && *ppiab)
        {
        (*ppiab)->Release();
        *ppiab = NULL;
        }

    return TRUE;
    }

//----------------------------------------------------------------
BOOL    FInitMetabaseWrapper( OLECHAR * pocMachineName )
    {
    //release previous interface if needed
    if( g_pMBCom != NULL )
        {
        g_pMBCom->Release();
        g_pMBCom = NULL;
        }

    return FInitMetabaseWrapperEx(pocMachineName, &g_pMBCom);
    }

//----------------------------------------------------------------
BOOL    FCloseMetabaseWrapper()
    {
    return FCloseMetabaseWrapperEx(&g_pMBCom);
    }


//=================================================================== The wrapper class

//----------------------------------------------------------------
CWrapMetaBase::CWrapMetaBase():
    m_pMetabase( NULL ),
    m_hMeta( NULL ),
    m_count(0),
    m_pBuffer( NULL ),
    m_cbBuffer(0),
    m_pPathBuffer( NULL ),
    m_cchPathBuffer( 0 )
    {
    // attempt to allocate the general buffer
    m_pBuffer = GlobalAlloc( GPTR, BUFFER_SIZE );
    if ( m_pBuffer )
        m_cbBuffer = BUFFER_SIZE;
    }

//----------------------------------------------------------------
CWrapMetaBase::~CWrapMetaBase()
    {
    // make sure the metabase handle is closed
    Close();

    // free the buffer
    if ( m_pBuffer )
        GlobalFree( m_pBuffer );
    m_pBuffer = NULL;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::FInit( PVOID pMBCom )
    {
    BOOL            fAnswer = FALSE;

    // NULL was passed in, use the global reference - most cases will do this
    if ( pMBCom )
    {
        m_pMetabase = (IMSAdminBase *)pMBCom;
    }
    else
    {
        m_pMetabase = g_pMBCom;
    }

    // if the interface is not there, fail
    if ( !m_pMetabase )
    {
        return FALSE;
    }

    // return success
    return TRUE;
    }


//==========================================================================================
// open, close and save the object and such

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( LPCTSTR pszPath, DWORD dwFlags )
    {
    return Open( METADATA_MASTER_ROOT_HANDLE, pszPath, dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Open( METADATA_HANDLE hOpenRoot, LPCTSTR pszPath, DWORD dwFlags )
    {
    m_count++;
    HRESULT hRes;

    // if a metabase handle is already open, close it
    if ( m_hMeta )
        Close();

    hRes = m_pMetabase->OpenKey( hOpenRoot, pszPath, dwFlags, MB_TIMEOUT, &m_hMeta );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Close( void )
    {
    if ( m_hMeta )
        {
        m_count--;
        m_pMetabase->CloseKey( m_hMeta );
        }
    m_hMeta = NULL;
    return TRUE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::Save( void )
        {
        HRESULT hRes = m_pMetabase->SaveData();

        if ( SUCCEEDED( hRes ))
            return TRUE;
        SetLastError( HRESULTTOWIN32( hRes ));
        return FALSE;
        }

// enumerate the objects
//----------------------------------------------------------------
// fortunately, we know that there is a max length to the name of any individual
// key in the metabase of 256 characters
BOOL CWrapMetaBase::EnumObjects(
    LPCTSTR pszPath,
    LPTSTR pName,
    DWORD cbNameBuf,
    DWORD Index
    )
    {
    // enumerate into the wide character buffer
    HRESULT hRes = m_pMetabase->EnumKeys( m_hMeta, pszPath, pName, Index );

    // Check for success
    if ( SUCCEEDED( hRes ))
        {
        return TRUE;
        }

    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// Add and delete objects
//----------------------------------------------------------------
BOOL CWrapMetaBase::AddObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->AddKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteObject( LPCTSTR pszPath )
    {
    HRESULT hRes = m_pMetabase->DeleteKey( m_hMeta, pszPath );

    if ( SUCCEEDED( hRes ))
        return TRUE;
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }


//==========================================================================================
// access the metahandle
//----------------------------------------------------------------
METADATA_HANDLE CWrapMetaBase::QueryHandle()
        {
        return m_hMeta;
        }


//==========================================================================================
// setting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::SetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                                DWORD dwValue, DWORD dwFlags )
    {
    return SetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            (PVOID) &dwValue,
            sizeof( DWORD ),
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPCTSTR pszValue, DWORD dwFlags )
    {
    int len = wcslen( pszValue )+1;
    DWORD cbWide = len * sizeof(WCHAR);

    // set the string into place
    BOOL fAnswer = SetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            (PVOID)pszValue,
            cbWide,            // string length ignored for inprocess clients
            dwFlags );

    // return the answer
    return fAnswer;
    }

//==========================================================================================
// getting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::GetDword( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                             DWORD* pdwValue, DWORD dwFlags )
    {
    DWORD cb = sizeof(DWORD);
    return GetData( pszPath,
            dwPropID,
            dwUserType,
            DWORD_METADATA,
            pdwValue,
            &cb,
            dwFlags );
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetString( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType,
                              LPTSTR pszValue, DWORD cchValue, DWORD dwFlags )
    {
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if ( GetData( pszPath,
            dwPropID,
            dwUserType,
            STRING_METADATA,
            pszValue,
            &cchValue,
            dwFlags ) )
        {
        fAnswer = TRUE;
        }

    // return the answer
    return fAnswer;
    }

BOOL CWrapMetaBase::GetMultiSZString( 
       LPCTSTR pszPath, 
       DWORD dwPropID, 
       DWORD dwUserType, 
       LPTSTR pszValue, 
       DWORD cchValue, 
       DWORD dwFlags)
{
    BOOL    fAnswer = FALSE;

    // get the data and put it right into the buffer - this is the wide version
    if (GetData( pszPath,
            dwPropID,
            dwUserType,
            MULTISZ_METADATA,
            pszValue,
            &cchValue,
            dwFlags ) )
   {
       fAnswer = TRUE;
   }

   // return the answer
   return fAnswer;
}

//==========================================================================================
// deleting values
//----------------------------------------------------------------
BOOL CWrapMetaBase::DeleteData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwDataType )
    {
    // go right ahead and delete it
    HRESULT hRes = m_pMetabase->DeleteData( m_hMeta, pszPath, dwPropID, dwDataType );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return(FALSE);
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::RenameObject( LPCTSTR pszPathOld, LPCTSTR pszNewName )
    {
    // rename the key
    HRESULT hRes = m_pMetabase->RenameKey( m_hMeta, pszPathOld, pszNewName );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // clean up after a failure
    SetLastError( HRESULTTOWIN32( hRes ));
    return FALSE;
    }

//=====================================================================================

//----------------------------------------------------------------
BOOL CWrapMetaBase::SetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD cbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;

    // prepare the set data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = cbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // set the data
    hRes = m_pMetabase->SetData( m_hMeta, pszPath, &mdRecord );

    // test for success
    if ( SUCCEEDED( hRes ))
        return TRUE;

    // there was an error, clean up
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
BOOL CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        PVOID pData, DWORD* pcbData, DWORD dwFlags )
    {
    METADATA_RECORD mdRecord;
    HRESULT         hRes;
    DWORD           dwRequiredLen;

    // prepare the get data record
    mdRecord.dwMDIdentifier  = dwPropID;
    mdRecord.dwMDAttributes  = dwFlags;
    mdRecord.dwMDUserType    = dwUserType;
    mdRecord.dwMDDataType    = dwDataType;
    mdRecord.dwMDDataLen     = *pcbData;
    mdRecord.pbMDData        = (PBYTE)pData;

    // get the data
    hRes = m_pMetabase->GetData( m_hMeta, pszPath, &mdRecord, &dwRequiredLen );

    // test for success
    if ( SUCCEEDED( hRes ))
        {
        *pcbData = mdRecord.dwMDDataLen;
        return TRUE;
        }

    // there was a failure - clean up
    *pcbData = dwRequiredLen;
    SetLastError( HRESULTTOWIN32( hRes ) );
    return FALSE;
    }

//----------------------------------------------------------------
// another form of GetData that automatically allocates the buffer. It should then be
// freed using GlobalFree(p);
PVOID CWrapMetaBase::GetData( LPCTSTR pszPath, DWORD dwPropID, DWORD dwUserType, DWORD dwDataType,
                                        DWORD* pcbData, DWORD dwFlags )
    {
    PVOID           pData = m_pBuffer;
    DWORD           cbData = m_cbBuffer;
    DWORD           err = 0;
    BOOL            f;

    // first - attempt to get the data in the buffer that has already been allocated;
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if the get data function worked, we can pretty much leave
    if ( f )
        {
        // set the data size
        *pcbData = cbData;
        // return the allocated buffer
        return pData;
        }

    // check the error - it could be some sort of memory error
    err = GetLastError();

    // it is ok that the GetData failed, but the reason had better be ERROR_INSUFFICIENT_BUFFER
    // otherwise, it is something we can't handle
    if ( err != ERROR_INSUFFICIENT_BUFFER )
        return NULL;

    // allocate the buffer
    pData = GlobalAlloc( GPTR, cbData );
    if ( !pData )
        return NULL;

    // first, get the size of the data that we are looking for
    f = GetData( pszPath, dwPropID, dwUserType, dwDataType, pData, &cbData, dwFlags );

    // if that getting failed, we need to cleanup
    if ( !f )
        {
        GlobalFree( pData );
        pData = NULL;
        }

    // set the data size
    *pcbData = cbData;

    // return the allocated buffer
    return pData;
    }

//----------------------------------------------------------------
// free memory returned by GetData
void CWrapMetaBase::FreeWrapData( PVOID pData )
{
    // if it is trying to free the local buffer, do nothing
    if ( pData == m_pBuffer )
    {
        return;
    }

    // ah - but it was not the local buffer - we should dispose of it
    if ( pData )
    {
        GlobalFree( pData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\place.inc ===
#
#  Places all of the internet binaries into the inetsrv tree.
#  Also establishes some standard conventions used across the project.
#

#
# Override IISBASEDIR if you're one of those weirdos that didn't
# enlist the IIS project into the correct directory.
#

!IFNDEF IISBASEDIR
IISBASEDIR=$(PROJECT_ROOT)\iis
!ENDIF

!IF "$(OACR)" == "Yes"
SUBSTITUTE_386_CC=$(PROJECT_ROOT)\iis\oacr\bin\cl.exe
!ENDIF

#
# We'll use our own COFFBASE.TXT and PLACEFIL.TXT, thank you very much.
#

!IFNDEF COFFBASE_TXT_FILE
COFFBASE_TXT_FILE=$(IISBASEDIR)\coffbase.txt
!ENDIF

!IFNDEF BINPLACE_PLACEFILE
BINPLACE_PLACEFILE=$(IISBASEDIR)\placefil.txt
!ENDIF

# This used to have the -y option.  Now, inetsrv binaries are binplaced
# to retail, so the symbols should be binplaced to symbols\retail.
# The -y switch causes the symbols to be binplaced to the wrong directory.

BINPLACE_FLAGS=$(BINPLACE_FLAGS)

# enable building legoizable binaries
!ifndef IIS_NO_BBT
NTBBT=1
!endif

# define CAP related options
CAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
CAP_LIBS=$(SDK_LIB_PATH)\cap.lib
CAP_FLAGS= -Zd -Gh

!IFDEF CAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(CAP_FLAGS)
LINK_OPTIONS=$(CAP_LINK_OPTIONS)
!ENDIF

# define ICE-CAP related options
ICAP_LINK_OPTIONS=-debugtype:coff -debug:mapped,partial
ICAP_LIBS=$(SDK_LIB_PATH)\icap.lib $(SDK_LIB_PATH)\penter.lib
ICAP_FLAGS= -Zi -Gh

!IFDEF ICAP_PROFILE
USER_C_FLAGS=$(USER_C_FLAGS) $(ICAP_FLAGS)
LINK_OPTIONS=$(ICAP_LINK_OPTIONS)
!ENDIF

!ifndef IIS_NO_PDB
USE_PDB=1
!endif

!if $(386)
!ifndef IIS_NO_SYM
USE_MAPSYM=1
!endif
!endif



#  !ifdef _NT386TREE
#  !if ("$(COMPUTERNAME)" == "X86CHK")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "X86FRE")
#  _NT386TREE=$(_NT386TREE)\InetSrv
#  !else
#  _NT386TREE=$(_NT386TREE)\iis
#  !endif
#  !endif


#  !ifdef _NTMIPSTREE
#  _NTMIPSTREE=$(_NTMIPSTREE)\iis
#  !endif


#  !ifdef _NTALPHATREE
#  !if ("$(COMPUTERNAME)" == "ALPHACHK")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !elseif ("$(COMPUTERNAME)" == "ALPHAFRE")
#  _NTALPHATREE=$(_NTALPHATREE)\InetSrv
#  !else
#  _NTALPHATREE=$(_NTALPHATREE)\iis
#  !endif
#  !endif


#  !ifdef _NTPPCTREE
#  _NTPPCTREE=$(_NTPPCTREE)\iis
#  !endif

#
# Enable warning level 3, treat warnings as errors
#

!ifndef MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3 /WX
!endif

#
# Don't allow anyone to disable warnings as errors.
#
# If any of the {platform}_WARNING_LEVEL macros are defined without
# the /WX switch, append /WX to the macro and whine about it.
#
!if 0

!ifdef 386_WARNING_LEVEL
! if ("$(386_WARNING_LEVEL:/WX=x)" == "$(386_WARNING_LEVEL)") && ("$(386_WARNING_LEVEL:-WX=x)" == "$(386_WARNING_LEVEL)")
!  message 386_WARNING_LEVEL defined without /WX
386_WARNING_LEVEL=$(386_WARNING_LEVEL) /WX
! endif
!endif

!ifdef MIPS_WARNING_LEVEL
! if ("$(MIPS_WARNING_LEVEL:/WX=x)" == "$(MIPS_WARNING_LEVEL)") && ("$(MIPS_WARNING_LEVEL:-WX=x)" == "$(MIPS_WARNING_LEVEL)")
!  message MIPS_WARNING_LEVEL defined without /WX
MIPS_WARNING_LEVEL=$(MIPS_WARNING_LEVEL) /WX
! endif
!endif

!ifdef ALPHA_WARNING_LEVEL
! if ("$(ALPHA_WARNING_LEVEL:/WX=x)" == "$(ALPHA_WARNING_LEVEL)") && ("$(ALPHA_WARNING_LEVEL:-WX=x)" == "$(ALPHA_WARNING_LEVEL)")
!  message ALPHA_WARNING_LEVEL defined without /WX
ALPHA_WARNING_LEVEL=$(ALPHA_WARNING_LEVEL) /WX
! endif
!endif

!ifdef PPC_WARNING_LEVEL
! if ("$(PPC_WARNING_LEVEL:/WX=x)" == "$(PPC_WARNING_LEVEL)") && ("$(PPC_WARNING_LEVEL:-WX=x)" == "$(PPC_WARNING_LEVEL)")
!  message PPC_WARNING_LEVEL defined without /WX
PPC_WARNING_LEVEL=$(PPC_WARNING_LEVEL) /WX
! endif
!endif

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cenumns.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:  cenumns.cxx
//
//  Contents:  Windows NT 4.0 Enumerator Code
//
//             CIISNamespaceEnum::Create
//             CIISNamespaceEnum::CIISNamespaceEnum
//             CIISNamespaceEnum::~CIISNamespaceEnum
//             CIISNamespaceEnum::Next
//             CIISNamespaceEnum::GetServerObject
//             CIISNamespaceEnum::EnumServerObjects
//
//  History:    21-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#include "charset.hxx"

#pragma hdrstop

#define ENUM_BUFFER_SIZE (1024 * 16)
#define DEFAULT_ADMIN_SERVER_KEY  \
            L"SOFTWARE\\Microsoft\\ADs\\Providers\\IIS\\"

#define DEFAULT_ADMIN_SERVER_VALUE_KEY      L"DefaultAdminServer"


//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
HRESULT
CIISNamespaceEnum::Create(
    CIISNamespaceEnum FAR* FAR* ppenumvariant,
    VARIANT var,
    CCredentials& Credentials
    )
{
    HRESULT hr = S_OK;
    CIISNamespaceEnum FAR* penumvariant = NULL;

    penumvariant = new CIISNamespaceEnum();

    if (penumvariant == NULL){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ObjectTypeList::CreateObjectTypeList(
            var,
            &penumvariant->_pObjList
            );
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    RRETURN(hr);

error:
    if (penumvariant) {
        delete penumvariant;
    }
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::CIISNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
CIISNamespaceEnum::CIISNamespaceEnum()
{
    _pObjList       = NULL;
    _fRegistryRead  = FALSE;
    bDone = false;

    //_lpServerList         = NULL;
    //_iCurrentServer      = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::~CIISNamespaceEnum
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
CIISNamespaceEnum::~CIISNamespaceEnum()
{

    if ( _pObjList )
        delete _pObjList;

//     FreeServerList();
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Next
//
//  Synopsis:   Returns cElements number of requested ADs objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{

    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumServerObjects(
            cElements,
            pvar,
            &cElementFetched
            );

    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceEnum::Reset
//
//  Synopsis:   Resets the enumerator so that a new server list will
//              be generated on the next call to Next.
//
//  Arguments:  None.
//
//  Returns:    HRESULT -- S_OK if there was a previous server list
//                      -- S_FALSE if there was not a previous server list
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceEnum::Reset(
    )
{
    bDone = true;
    return (S_OK);
}

// Generate the server list and set flags
HRESULT
CIISNamespaceEnum::GenerateServerList()
{
    RRETURN(E_NOTIMPL);
//     DWORD Error;
// 
//     ADsAssert(_lpServerList==NULL);
// 
//     Error = INetDiscoverServers(
//                 INET_ALL_SERVICES_ID,
//                 SVC_DEFAULT_WAIT_TIME,
//                 &_lpServerList);
// 
//     if (Error != ERROR_SUCCESS) {
//         return HRESULT_FROM_WIN32(Error);
//     }
// 
//     // Set the current server to the first
//     _iCurrentServer = 0;
// 
// 
//     return S_OK;
// 
}

// Free the server list and set flags
HRESULT
CIISNamespaceEnum::FreeServerList(
    )
{
    RRETURN(E_NOTIMPL);
//     if ( _lpServerList ) {
//         // _lpServerList is set to NULL
//         INetFreeDiscoverServersList(&_lpServerList); // void return
//     }
//     ADsAssert(_lpServerList==NULL);
//     return S_OK;
}

HRESULT
CIISNamespaceEnum::EnumServerObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    // perform this check once per call
//     if (!_lpServerList) {   // generate server list
//         GenerateServerList();
//     }

    // we're only going to return a single element - localhost
    cElements = 1;

    while (i < cElements) {

        hr = GetServerObject(&pDispatch);
        BAIL_ON_FAILURE(hr);

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    // we've received the entire block or we have
    // reached the end of the list

    RRETURN(hr);

error:
    // there was an error retrieving the current object
    RRETURN(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISNamespaceEnum::GetServerObject(
    IDispatch ** ppDispatch
    )
{
//     HKEY             hKey = NULL;
// #if 0
//     WCHAR            szServerName[MAX_PATH];
// #endif
    WCHAR           *lpwszServerName;
    HRESULT          hr;
    char             szServerName[10] = "localhost";
    UINT             err;

    if (true == bDone)
    {
        RRETURN(S_FALSE);
    }

//     // while there are still more servers
//     if (_iCurrentServer < (_lpServerList->NumServers)) {
//         // get the next server name
//         lpszServerName = _lpServerList->Servers[_iCurrentServer]->ServerName;
// 
//         // convert the server name to unicode
// #if 0
//         AnsiToUnicodeString(
//             lpszServerName,
//             szServerName,
//             strlen(lpszServerName));
// #else
        err = AllocUnicode(szServerName, &lpwszServerName);
        if (err) {
            RRETURN( HRESULT_FROM_WIN32(err) );
        }

// #endif
// 
//         // increment the current server index
//         ++_iCurrentServer;
// 
//     } else {
//         RRETURN(S_FALSE);
//     }
// 

    *ppDispatch = NULL;

    //
    // Now create and send back the current object
    //

    hr = CIISTree::CreateServerObject(
                L"IIS:",
                lpwszServerName,
                COMPUTER_CLASS_W,
                _Credentials,
                ADS_OBJECT_BOUND,
                IID_IDispatch,
                (void **)ppDispatch
                );
    BAIL_ON_FAILURE(hr);

    bDone = true;

error:

    RRETURN_ENUM_STATUS(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//		multiple IDispatch-callable interfaces.
//
//  Classes:	CAggregatorDispMgr
//
//  Functions:	None external.
//
//  History:    ??-???-??   KrishnaG   created
//		07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "iis.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include ".\cdispmgr.hxx"
#include "iprops.hxx"

#endif	// ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-	End Non-ADSI compile stuff

//
// Error recovery.
//

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:	Simplified from Win4AssertEx, to make this dispatch manager
//  		not depend on other files.
//
//----------------------------------------------------------------------------
static void
AggregatorAssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
	szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
	    DebugBreak();
    }
}
# define AggregatorDispMgrAssert(x)  (void)((x) || (AggregatorAssertEx(__FILE__, __LINE__, #x),0))
#else
# define AggregatorAssertEx(f,l,m)
# define AggregatorDispMgrAssert(x)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
	*pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
	DispId < 0 || DispId >= 0x10000)
    {
	//
	// Might happen if some object has very large dispid's.
	// But we can't handle it if it does.
	//
	*pResult = DISPID_UNKNOWN;
    }
    else
	*pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
	if (rgdispid[i] == DISPID_UNKNOWN)
	    continue;

	//
	// This is either a stack of DispMgrs >127 high, or
	// a programming error.  More likely the latter.
	//
	AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

	rgdispid[i] =
	    (rgdispid[i] & 0x00ffffff) |
	    (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
	//
	// It should never be less than zero, and the only place
	// this is called from guarantees it is not zero.
	//
	AggregatorDispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

	rgdispid[i] =
	    (rgdispid[i] & 0x00ffffff) |
	    (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CAggregatorDispMgr::CAggregatorDispMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
}

CAggregatorDispMgr::~CAggregatorDispMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

}

void
CAggregatorDispMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}


STDMETHODIMP
CAggregatorDispMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CAggregatorDispMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

//
// MAJOR NOTE This works only for single names; if multiple names are
// passed we die big time. This is help us get going using VB's _NewEnum
//

STDMETHODIMP
CAggregatorDispMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR *rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID *rgdispid
    )
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
	    hr = S_OK;
	    for (DWORD dw = 0; dw < cNames; dw++) {
	        if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
		        (PDWORD)(rgdispid + dw)))) {
		            hr = DISP_E_UNKNOWNNAME;
		            rgdispid[dw] = DISPID_UNKNOWN;
	        }
	    }
	    if (SUCCEEDED(hr)) {
	        MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
	    }
    }

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
	unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CAggregatorDispMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CAggregatorDispMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CAggregatorDispMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CAggregatorDispMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr = S_OK;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

error:

    return hr;
}

STDMETHODIMP
CAggregatorDispMgr::TypeInfoInvoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
	unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT *pvarResult,
	EXCEPINFO *pexcepinfo,
    unsigned int *puArgErr
    )
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

    	//
	    // One of the special DISPIDs.
	    //
	    // If we have an interface pointer for it, use that.
	    // If we don't, and we have a base IDispatch pointer,
	    //   pass it to the base pointer's Invoke() method.
	    // If we don't, and we don't have a base IDispatch pointer,
	    //   return failure.
	    //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
	    break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

	    if (!pInterfacePtr) {

	        BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);

	    }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else {

        //                           	
	    // A regular DISPID of ours.
	    //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

	    if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
	        pInterfacePtr = getInterfacePtr(typeinfoid);
	        pTypeInfo = getTypeInfo(typeinfoid);
	        if (!pTypeInfo)
		        //
		    // Shouldn't happen.
		    //
		    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
	    }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = AggregatorDynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

error:
    return hr;
}


HRESULT
AggregatorDynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        //
        // NOTE: only handles one argument.
        //

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

error:
    return(hr);

}


HRESULT
CAggregatorDispMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }

    pTypeInfoEntry = FindTypeInfo(pTypeInfo);
    if (!pTypeInfoEntry) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CAggregatorDispMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }

    pTypeInfoEntry = FindTypeInfo(pTypeInfo);
    if (!pTypeInfoEntry) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CAggregatorDispMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    AggregatorDispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


ITypeInfo *
AggregatorFindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
AggregatorLoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr = S_OK;
    ITypeLib *  pTL;

    AggregatorDispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (FAILED(hr))
    {
        return hr;
    }

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CAggregatorDispMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    hr = AggregatorLoadTypeInfo(libid, iid, &pTypeInfo);
    BAIL_ON_FAILURE(hr);

    hr = AddTypeInfo(pTypeInfo, pIntf);
    BAIL_ON_FAILURE(hr);

    if (SpecialId == -4) {
	    hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
	    hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

error:
    if (pTypeInfo)
	    pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CAggregatorDispMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cenumsch.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumsch.cxx
//
//  Contents:  IIS Schema Enumeration Code
//
//             CIISSchemaEnum::CIISSchemaEnum
//             CIISSchemaEnum::~CIISSchemaEnum
//             CIISSchemaEnum::EnumObjects
//             CIISSchemaEnum::EnumObjects
//             CIISSchemaEnum::Create
//             CIISSchemaEnum::Next
//
//  History:   01-02-98         sophiac
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISSchemaEnum::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//----------------------------------------------------------------------------
HRESULT
CIISSchemaEnum::Create(
    CIISSchemaEnum FAR* FAR* ppenumvariant,
    IIsSchema * pSchema,
    BSTR bstrADsPath,
    BSTR bstrName
    )
{
    HRESULT hr = S_OK;
    CIISSchemaEnum FAR* penumvariant = NULL;
    VARIANT vFilter;

    *ppenumvariant = NULL;
    VariantInit(&vFilter);

    penumvariant = new CIISSchemaEnum();
    if (!penumvariant)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    penumvariant->_pSchema = pSchema;

    hr = ADsAllocString( bstrADsPath, &penumvariant->_bstrADsPath);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( bstrName, &penumvariant->_bstrName);
    BAIL_ON_FAILURE(hr);

    hr = ObjectTypeList::CreateObjectTypeList(
            vFilter,
            &penumvariant->_pObjList );
    BAIL_ON_FAILURE(hr);

    *ppenumvariant = penumvariant;

    VariantClear(&vFilter);
    RRETURN(hr);

error:

    delete penumvariant;
    VariantClear(&vFilter);

    RRETURN(hr);
}

CIISSchemaEnum::CIISSchemaEnum()
    : _bstrADsPath( NULL ),
      _bstrName( NULL ),
      _pObjList( NULL ),
      _pSchema( NULL ),
      _dwCurrentEntry( 0 )
{
}

CIISSchemaEnum::~CIISSchemaEnum()
{
   ADsFreeString( _bstrName );
   ADsFreeString( _bstrADsPath );

   if ( _pObjList != NULL )
   {
       delete _pObjList;
       _pObjList = NULL;
   }
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISSchemaEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISSchemaEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumObjects( cElements,
                      pvar,
                      &cElementFetched );

    if ( pcElementFetched )
        *pcElementFetched = cElementFetched;

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::EnumObjects(
    DWORD ObjectType,
    ULONG cElements,
    VARIANT FAR * pvar,
    ULONG FAR * pcElementFetched
    )
{
    switch (ObjectType)
    {
        case IIS_CLASS_ID:
            RRETURN (EnumClasses(cElements, pvar, pcElementFetched));

        case IIS_SYNTAX_ID:
            RRETURN(EnumSyntaxObjects(cElements, pvar, pcElementFetched));

        case IIS_PROPERTY_ID:
            RRETURN(EnumProperties(cElements, pvar, pcElementFetched));

        default:
            RRETURN(S_FALSE);
    }
}

HRESULT
CIISSchemaEnum::EnumObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    DWORD           i;
    ULONG           cRequested = 0;
    ULONG           cFetchedByPath = 0;
    ULONG           cTotalFetched = 0;
    VARIANT FAR*    pPathvar = pvar;
    HRESULT         hr;
    DWORD           ObjectType;

    for (i = 0; i < cElements; i++)
        VariantInit(&pvar[i]);

    cRequested = cElements;

    while (  SUCCEEDED( _pObjList->GetCurrentObject(&ObjectType))
          && ((hr = EnumObjects( ObjectType,
                                 cRequested,
                                 pPathvar,
                                 &cFetchedByPath)) == S_FALSE )
          )
    {
        pPathvar += cFetchedByPath;
        cRequested -= cFetchedByPath;
        cTotalFetched += cFetchedByPath;

        cFetchedByPath = 0;

        if ( FAILED(_pObjList->Next()) )
        {
            if ( pcElementFetched )
                *pcElementFetched = cTotalFetched;
            RRETURN(S_FALSE);
        }

        _dwCurrentEntry = 0;
    }

    if ( pcElementFetched )
        *pcElementFetched = cTotalFetched + cFetchedByPath;

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::EnumClasses(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetClassObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetClassObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= _pSchema->GetClassEntries() )
        goto error;

    hr = CIISClass::CreateClass(
                        _bstrADsPath,
                        _pSchema->GetClassName(_dwCurrentEntry),
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}

HRESULT
CIISSchemaEnum::EnumSyntaxObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetSyntaxObject(&pDispatch);
        if ( hr == S_FALSE ) 
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetSyntaxObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current object
    //
    if ( _dwCurrentEntry >= g_cIISSyntax )
        goto error;

    hr = CIISSyntax::CreateSyntax(
                        _bstrADsPath,
                        &g_aIISSyntax[_dwCurrentEntry],
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}


HRESULT
CIISSchemaEnum::EnumProperties(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    DWORD i = 0;
    IDispatch *pDispatch = NULL;

    while ( i < cElements )
    {
        hr = GetPropertyObject(&pDispatch);
        if ( hr == S_FALSE )
            break;

        VariantInit( &pvar[i] );
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }

    RRETURN(hr);
}

HRESULT
CIISSchemaEnum::GetPropertyObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;

    //
    // Now send back the current ovbject
    //
    if ( _dwCurrentEntry >= _pSchema->GetPropEntries() )
        goto error;

    hr = CIISProperty::CreateProperty(
                        _bstrADsPath,
                        _pSchema->GetPropName(_dwCurrentEntry),
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)ppDispatch
                        );
    BAIL_ON_FAILURE(hr);

    _dwCurrentEntry++;

    RRETURN(S_OK);

error:

    *ppDispatch = NULL;
    RRETURN(S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cenumt.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumt.cxx
//
//  Contents:  IIS Object Enumeration Code
//
//              CIISTreeEnum::CIISTreeEnum()
//              CIISTreeEnum::CIISTreeEnum
//              CIISTreeEnum::EnumObjects
//              CIISTreeEnum::EnumObjects
//
//  History:    25-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//
//----------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISTreeEnum::Create(
    CIISTreeEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;

    HRESULT hr = NOERROR;
    CIISTreeEnum FAR* penumvariant = NULL;

    LPWSTR pszIISPathName = NULL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    *ppenumvariant = NULL;

    penumvariant = new CIISTreeEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    //
    // Store ServerName
    //

    penumvariant->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!(penumvariant->_pszServerName)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


	hr = InitServerInfo(Credentials,
	                    penumvariant->_pszServerName, 
                        &(penumvariant->_pAdminBase),
                        &(penumvariant->_pSchema));
	BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

	memset(pszIISPathName, 0, sizeof(pszIISPathName));

    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!(penumvariant->_pszMetaBasePath)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (FAILED(hr)) {
        if (penumvariant) {
            delete penumvariant;
            *ppenumvariant = NULL;
        }
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

CIISTreeEnum::CIISTreeEnum():
                    _ADsPath(NULL),
                    _pszServerName(NULL),
					_pSchema(NULL),
					_pAdminBase(NULL),
                    _pszMetaBasePath(NULL)
{
    _dwObjectCurrentEntry = 0;
}


CIISTreeEnum::~CIISTreeEnum()
{
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

    //
    // Release everything
    //

}


HRESULT
CIISTreeEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenericObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISTreeEnum::GetGenericObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR NameBuf[MAX_PATH];
    WCHAR DataBuf[MAX_PATH];
    DWORD dwStatus = 0;
    DWORD dwReqdBufferLen;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;

    *ppDispatch = NULL;

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr = _pAdminBase->EnumKeys(
                hObjHandle,
                L"",
                (LPWSTR)NameBuf,
                _dwObjectCurrentEntry
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find out Class Name
    //

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = ALL_METADATA;
    mdrData.dwMDAttributes = METADATA_INHERIT;
    mdrData.dwMDDataLen = MAX_PATH;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->GetData(
                hObjHandle,
                (LPWSTR)NameBuf,
                &mdrData,
                &dwReqdBufferLen
                );


    if (FAILED(hr)) {
        if (hr == MD_ERROR_DATA_NOT_FOUND) {

            LPWSTR pszIISPath;
            pszIISPath = _wcsupr((LPWSTR)_pszMetaBasePath);

            if (wcsstr(_pszMetaBasePath, L"W3SVC") != NULL) {
                memcpy((LPWSTR)DataBuf, WEBDIR_CLASS_W,
                       SIZEOF_WEBDIR_CLASS_W);
            }
            else if (wcsstr(_pszMetaBasePath, L"MSFTPSVC") != NULL) {
                memcpy((LPWSTR)DataBuf, FTPVDIR_CLASS_W,
                       SIZEOF_FTPVDIR_CLASS_W);
            }
            else {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }
        else {
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        hr = _pSchema->ValidateClassName((LPWSTR)DataBuf);
        if (hr == E_ADS_SCHEMA_VIOLATION) {
            memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                   SIZEOF_DEFAULT_CLASS_W);
        }
    }

    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    (LPWSTR)NameBuf,
                    (LPWSTR)DataBuf,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)ppDispatch
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    //
    // GetTree returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr  = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISTreeEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:  
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISTreeEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cenumobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:      cenumobj.cxx
//
//  Contents:  IIS Object Enumeration Code
//
//              CIISGenObjectEnum::CIISGenObjectEnum()
//              CIISGenObjectEnum::CIISGenObjectEnum
//              CIISGenObjectEnum::Create
//              CIISGenObjectEnum::GetGenObjects
//              CIISGenObjectEnum::EnumGenericObjects
//              CIISGenObjectEnum::Next
//
//  History:    28-Feb-97   SophiaC     Created.
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Create
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:   
//
//----------------------------------------------------------------------------
/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISGenObjectEnum::Create(
    CIISGenObjectEnum FAR* FAR* ppenumvariant,
    BSTR ADsPath,
    VARIANT var,
    CCredentials& Credentials
    )
{

    HRESULT hr = NOERROR;
    CIISGenObjectEnum FAR* penumvariant = NULL;

    LPWSTR pszIISPathName = NULL;
    DWORD dwStatus = 0;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(ADsPath);

    *ppenumvariant = NULL;

    penumvariant = new CIISGenObjectEnum();
    if (!penumvariant) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = ADsAllocString( ADsPath, &penumvariant->_ADsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);


    penumvariant->_Credentials = Credentials;

    *ppenumvariant = penumvariant;

    //
    // Store ServerName
    //

    penumvariant->_pszServerName = AllocADsStr(pObjectInfo->TreeName);
    

    if (!(penumvariant->_pszServerName)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = InitServerInfo(Credentials,
                        penumvariant->_pszServerName,
                        &(penumvariant->_pAdminBase),
                        &(penumvariant->_pSchema));
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memset(pszIISPathName, 0, sizeof(pszIISPathName));

    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    penumvariant->_pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!(penumvariant->_pszMetaBasePath)) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (FAILED(hr)) {
        if (penumvariant) {
            delete penumvariant;
            *ppenumvariant = NULL;
        }
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

CIISGenObjectEnum::CIISGenObjectEnum():
                    _ADsPath(NULL),
                    _pszServerName(NULL),
                    _pSchema(NULL),
                    _pAdminBase(NULL),
                    _pszMetaBasePath(NULL)
{
    _dwObjectCurrentEntry = 0;
}


CIISGenObjectEnum::~CIISGenObjectEnum()
{
    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

    //
    // Release everything
    //

}


HRESULT
CIISGenObjectEnum::EnumGenericObjects(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    HRESULT hr = S_OK;
    IDispatch *pDispatch = NULL;
    DWORD i = 0;

    while (i < cElements ) {

        hr = GetGenObject(&pDispatch);
        if (FAILED(hr)) {
            continue;
        }

        if (hr == S_FALSE) {
            break;
        }

        VariantInit(&pvar[i]);
        pvar[i].vt = VT_DISPATCH;
        pvar[i].pdispVal = pDispatch;
        (*pcElementFetched)++;
        i++;
    }
    return(hr);
}


/* #pragma INTRINSA suppress=all */
HRESULT
CIISGenObjectEnum::GetGenObject(
    IDispatch ** ppDispatch
    )
{
    HRESULT hr = S_OK;
    WCHAR NameBuf[MAX_PATH];
    WCHAR DataBuf[MAX_PATH];
    DWORD dwStatus = 0;
    DWORD dwReqdBufferLen;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    IADs * pADs = NULL;

    *ppDispatch = NULL;

    if (!_pAdminBase)
    {
        hr = InitServerInfo(_Credentials, _pszServerName, &_pAdminBase, &_pSchema);
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);
    
    hr = _pAdminBase->EnumKeys(
                hObjHandle,
                L"",
                (LPWSTR)NameBuf,
                _dwObjectCurrentEntry
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find out Class Name
    //

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = ALL_METADATA;
    mdrData.dwMDAttributes = METADATA_INHERIT;
    mdrData.dwMDDataLen = MAX_PATH;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->GetData(
                hObjHandle,
                (LPWSTR)NameBuf,
                &mdrData,
                &dwReqdBufferLen
                );

    if (FAILED(hr)) {
        if (hr == MD_ERROR_DATA_NOT_FOUND) {

            LPWSTR pszIISPath;
            pszIISPath = _wcsupr((LPWSTR)_pszMetaBasePath);

            if (wcsstr(pszIISPath, L"W3SVC") != NULL) {
                memcpy((LPWSTR)DataBuf, WEBDIR_CLASS_W,
                       SIZEOF_WEBDIR_CLASS_W);
            }
            else if (wcsstr(pszIISPath, L"MSFTPSVC") != NULL) {
                memcpy((LPWSTR)DataBuf, FTPVDIR_CLASS_W,
                       SIZEOF_FTPVDIR_CLASS_W);
            }
            else {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }
        else {
            BAIL_ON_FAILURE(hr);
        }
    }
    else {
        hr = _pSchema->ValidateClassName((LPWSTR)DataBuf);
        if (hr == E_ADS_SCHEMA_VIOLATION) {
            memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W,
                   SIZEOF_DEFAULT_CLASS_W);
        }
    }

    //
    // Bump up the object count. The instantiation of this object
    // may fail; if we come into this function again, we do not want
    // to pick up the same object.
    //

    _dwObjectCurrentEntry++;

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    (LPWSTR)NameBuf,
                    (LPWSTR)DataBuf, 
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IDispatch,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                IID_IDispatch,
                (void**)ppDispatch
                );

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }


    if (pADs) {
        pADs->Release();
    }

    //
    // GetGenObject returns only S_FALSE
    //

    if (FAILED(hr)) {
        hr  = S_FALSE;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISGenObjectEnum::Next
//
//  Synopsis:   Returns cElements number of requested NetOle objects in the
//              array supplied in pvar.
//
//  Arguments:  [cElements] -- The number of elements requested by client
//              [pvar] -- ptr to array of VARIANTs to for return objects
//              [pcElementFetched] -- if non-NULL, then number of elements
//                                 -- actually returned is placed here
//
//  Returns:    HRESULT -- S_OK if number of elements requested are returned
//                      -- S_FALSE if number of elements is < requested
//
//  Modifies:
//
//  History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISGenObjectEnum::Next(
    ULONG cElements,
    VARIANT FAR* pvar,
    ULONG FAR* pcElementFetched
    )
{
    ULONG cElementFetched = 0;
    HRESULT hr = S_OK;

    hr = EnumGenericObjects(
            cElements,
            pvar,
            &cElementFetched
            );


    if (pcElementFetched) {
        *pcElementFetched = cElementFetched;
    }
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cextmgr.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cextmgr.cxx
//
//  Contents:  IIS ExtMgr Object
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//  Class CADsExtMgr

CADsExtMgr::CADsExtMgr():
    _pClassEntry(NULL),
    _pDispMgr(NULL)
{

}

HRESULT
CADsExtMgr::CreateExtMgr(
    IUnknown FAR * pUnkOuter,
    CAggregatorDispMgr * pDispMgr,
    CCredentials& Credentials,
    LPTSTR pszClassName,
    CADsExtMgr ** ppExtMgr
    )
{
    PCLASS_ENTRY pClassEntry =  NULL;
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    hr = AllocateExtMgrObject(
                &pExtMgr
                );
    BAIL_ON_FAILURE(hr);


    //
    // Now store the DispatchMgr of the Aggregator
    //

    pExtMgr->_pDispMgr = pDispMgr;

    hr = ADSIGetExtensionList(
            pszClassName,
            &(pExtMgr->_pClassEntry)
            );

    if (pExtMgr->_pClassEntry) {

        hr = ADSILoadExtensions2(
                    pUnkOuter,
                    Credentials,
                    pExtMgr->_pClassEntry
                    );
    }

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:
    *ppExtMgr = NULL;
    delete pExtMgr;
    RRETURN(hr);
}


CADsExtMgr::~CADsExtMgr( )
{
    //
    // Free the ClassEntry
    //

    if (_pClassEntry) {

        FreeClassEntry(_pClassEntry);
    }

    //
    // And do nothing with the DispMgr - we just keep a pointer
    //

}

STDMETHODIMP
CADsExtMgr::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    PCLASS_ENTRY  pClassEntry = _pClassEntry;
    IUnknown * pUnknown = NULL;
    PINTERFACE_ENTRY pIID = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    HRESULT hr = S_OK;

    if (!pClassEntry) {

        RRETURN(E_NOINTERFACE);
    }

    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pUnknown = pExtensionEntry->pUnknown;
        pIID = pExtensionEntry->pIID;

        while (pIID) {

            if (IsEqualIID(pIID->iid, iid)) {


                if (!pUnknown) {

                    RRETURN(E_NOINTERFACE);
                }

                hr = pUnknown->QueryInterface(
                            iid,
                            ppv
                            );
                RRETURN(hr);
            }

            pIID = pIID->pNext;

        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    RRETURN(hr = E_NOINTERFACE);
}


HRESULT
CADsExtMgr::AllocateExtMgrObject(
    CADsExtMgr ** ppExtMgr
    )
{
    CADsExtMgr FAR * pExtMgr = NULL;
    HRESULT hr = S_OK;

    pExtMgr = new CADsExtMgr();
    if (pExtMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    *ppExtMgr = pExtMgr;

    RRETURN(hr);

error:

    if (pExtMgr) {
        delete pExtMgr;
    }

    RRETURN(hr);

}


HRESULT
ADSILoadExtensionManager(
    LPWSTR pszClassName,
    IUnknown * pUnkOuter,
    CCredentials& Credentials,
    CAggregatorDispMgr * pDispMgr,
    CADsExtMgr ** ppExtMgr
    )
{

    HRESULT hr = S_OK;

    hr = CADsExtMgr::CreateExtMgr(
            pUnkOuter,
            pDispMgr,
            Credentials,
            pszClassName,
            ppExtMgr
            );

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::GetTypeInfoCount(
    unsigned int FAR* pctinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetTypeInfo(
    unsigned int itinfo,
    LCID lcid,
    ITypeInfo FAR* FAR* pptinfo
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CADsExtMgr::GetIDsOfNames(
    REFIID iid,
    LPWSTR FAR* rgszNames,
    unsigned int cNames,
    LCID lcid,
    DISPID FAR* rgdispid
    )
{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch FAR * pPrivDisp = NULL;


    hr = _pDispMgr->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid
            );

    if (FAILED(hr)) {

        if (!_pClassEntry) {
            RRETURN(DISP_E_UNKNOWNNAME);
        }

        pExtension = _pClassEntry->pExtensionHead;

        while (pExtension) {

            if (pExtension->fDisp) {
                
                //
                // fDisp = TRUE indicates 
                //  1)  extension supports pADsExt AND 
                //  2)  either 
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL     
                //      OR
                //      b) we don't know if a) is true or not yet
                // 

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateGetIDsOfNames(
                          iid,
                          rgszNames,
                          cNames,
                          lcid,
                          rgdispid
                          );

                if (SUCCEEDED(hr)) {

                    // 
                    // check & prefix extension id to dispid(s) returned 
                    // by extension
                    //  

                    hr = CheckAndPrefixExtIDArray(
                                pExtension->dwExtensionID,
                                cNames,
                                rgdispid
                                );
                                    
                    if (SUCCEEDED(hr) )
                    {
                        RRETURN(hr);
                    }

                    //
                    // if cannot prefix extension id because NOT ALL 
                    // dispids returned by PrivateGetIDsOfNames() are
                    // valid, this extension does not support this property
                    // or method -> try next extension
                    //
                }

                else if (hr == E_NOTIMPL) {
    
                    //
                    // extension object does not support the optional
                    // IADsExtension::PrivateGetIDsOfNames()/PrivateInvoke()
                    // -> remember this in cache & try next extension object
                    //

                    pExtension->fDisp = FALSE;
                }

                else {

                    // 
                    // extens'n object supports PrivateGetIDsOfNames()/Invoke()
                    // but does not know about this property or method 
                    // -> try next extension object
                    //
                }

            } // end "if (pExtension->pADs && pExtension->fDisp)"

            pExtension = pExtension->pNext;

        } // end while

    }

    
    // 
    // Unify the final error code retuned to ADSI client to DISP_E_UNKNOWNNAME 
    //

    if ( FAILED(hr) && hr!=E_OUTOFMEMORY) {

        hr = DISP_E_UNKNOWNNAME;
    }

    RRETURN(hr);
}


STDMETHODIMP
CADsExtMgr::Invoke(
    DISPID dispidMember,
    REFIID iid,
    LCID lcid,
    unsigned short wFlags,
    DISPPARAMS FAR* pdispparams,
    VARIANT FAR* pvarResult,
    EXCEPINFO FAR* pexcepinfo,
    unsigned int FAR* puArgErr
    )
{
    DWORD dwExtensionId = 0;
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtension = NULL;
    IPrivateDispatch * pPrivDisp = NULL;
    DISPID rgExtDispid = DISPID_UNKNOWN;

    //
    // This could be a special dispatch id - pass it to
    // the aggregator
    //

    if (dispidMember <= 0) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    //
    // It is not a special dispatch id, so compute the extension
    // id and pass it to the appropriate dispatch manager
    //

    dwExtensionId = EXTRACT_EXTENSION_ID(dispidMember);

    if (!dwExtensionId) {

        hr = _pDispMgr->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        RRETURN(hr);

    }

    if (!_pClassEntry) {

        RRETURN(DISP_E_MEMBERNOTFOUND);
    }


    pExtension = _pClassEntry->pExtensionHead;

    rgExtDispid = REMOVE_EXTENSION_ID(dispidMember);

    while (pExtension) {

        if (dwExtensionId == pExtension->dwExtensionID) {

            if (pExtension->fDisp) {

                //
                // fDisp = TRUE indicates 
                //  1)  extension supports pADsExt AND 
                //  2)  either 
                //      a) PrivateGetIDsOfNames() does Not return E_NOTIMPL 
                //      OR
                //      b) we don't know if a) is true or not yet (client bug)
                //

                ASSERT(pExtension->pADsExt);

                hr = (pExtension->pADsExt)->PrivateInvoke(
                        rgExtDispid, 
                        iid,
                        lcid,
                        wFlags,
                        pdispparams,
                        pvarResult,
                        pexcepinfo,
                        puArgErr
                        );
                RRETURN(hr);

            } else {

                //
                // A dwExtensionId match indicates THIS extens'n has returned 
                // a valid dispid to clients thru' pADs->PrivateGetIDsOfNames. 
                // Thus, fDisp should be TURE.
                //
                // But since dispid goes thru' clients before passed back to
                // PrivateInovke(), don't ASSERT in case of clients errors.
                //

                RRETURN(DISP_E_MEMBERNOTFOUND);
            }
        }

        pExtension = pExtension->pNext;

    } // end while

    RRETURN(DISP_E_MEMBERNOTFOUND);
}


HRESULT
CADsExtMgr::CheckAndPrefixExtIDArray(
    IN      DWORD dwExtensionID,
    IN      unsigned int cDispids, 
    IN OUT  DISPID * rgDispids
    )
{
    
    HRESULT hrEach = S_OK;
    HRESULT hrAll = S_OK;


    ASSERT_VALID_EXTENSION_ID(dwExtensionID);


    for (unsigned int i = 0; i<cDispids; i++) 
    {
        hrEach = CheckAndPrefixExtID(
                    dwExtensionID,
                    rgDispids[i],
                    rgDispids+i
                    );

        if (FAILED(hrEach)) 
        {
            hrAll = E_FAIL;
            
            // 
            // The entire operation is considered as failure as a whole.
            // But continue to get other dispid s.t. debugger or user knows 
            // which dispid in the array is causing problem -> DISPID_UNKOWN
            //
        }
    }
    
    RRETURN(hrAll);

}


HRESULT
CADsExtMgr::CheckAndPrefixExtID(
    IN      DWORD   dwExtensionID,
    IN      DISPID  dispid,
    IN OUT  DISPID  * pNewDispid
    )
{
    ASSERT(pNewDispid);
    
    if  ( (dispid>= ADS_EXT_MINEXTDISPID) &&
          (dispid<= ADS_EXT_MAXEXTDISPID) ) 
    {
        *pNewDispid = PREFIX_EXTENSION_ID(dwExtensionID, dispid) ;

        RRETURN(S_OK);
    }    
    else
    {
        *pNewDispid = DISPID_UNKNOWN;

        RRETURN(E_FAIL);
    }
   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cenumvar.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cenumvar.cxx
//
//  Contents:  Windows NT 4.0 Enumerator Code
//
//             CIISEnumVariant::Create
//             CIISEnumVariant::CIISEnumVariant
//             CIISEnumVariant::~CIISEnumVariant
//             CIISEnumVariant::QueryInterface
//             CIISEnumVariant::AddRef
//             CIISEnumVariant::Release
//             CIISEnumVariant::Next
//             CIISEnumVariant::Skip
//             CIISEnumVariant::Clone
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::CIISEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CIISEnumVariant::CIISEnumVariant()
{
    //
    // Set the reference count on the enumerator.
    //
    m_cRef = 1;

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::~CIISEnumVariant
//
//  Synopsis:
//
//
//  Arguments:
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
CIISEnumVariant::~CIISEnumVariant()
{
    //
    // Bump down the reference count on the Collection object
    //
}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::QueryInterface
//
//  Synopsis:
//
//  Arguments:  [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::QueryInterface(REFIID iid, void FAR* FAR* ppv)
{
    *ppv = NULL;

    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT) {

        *ppv = this;

    }
    else {

        return ResultFromScode(E_NOINTERFACE);
    }

    AddRef();
    return NOERROR;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::AddRef
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CIISEnumVariant::AddRef(void)
{

    return ++m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Release
//
//  Synopsis:
//
//
//  Arguments:  [void]
//
//  Returns:
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG)
CIISEnumVariant::Release(void)
{


    if(--m_cRef == 0){

        delete this;
        return 0;
    }

    return m_cRef;
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Skip
//
//  Synopsis:
//
//  Arguments:  [cElements]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Skip(ULONG cElements)
{

    RRETURN(E_NOTIMPL);

}

//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Reset
//
//  Synopsis:
//
//  Arguments:  []
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Reset()
{

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Function:   CIISEnumVariant::Clone
//
//  Synopsis:
//
//  Arguments:  [pCollection]
//              [ppEnumVariant]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//
//----------------------------------------------------------------------------
STDMETHODIMP
CIISEnumVariant::Clone(IEnumVARIANT FAR* FAR* ppenum)
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cgenobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cgenobj.cxx
//
//  Contents:  Microsoft ADs IIS Provider Generic Object
//
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISGenObject

DEFINE_IDispatch_ExtMgr_Implementation(CIISGenObject)
DEFINE_IADs_Implementation(CIISGenObject)


CIISGenObject::CIISGenObject():
                _pExtMgr(NULL),
                _pPropertyCache(NULL),
                _pszServerName(NULL),
                _pszMetaBasePath(NULL),
                _pAdminBase(NULL),
                _pSchema(NULL),
                _pDispMgr(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISGenObject);
}

HRESULT
CIISGenObject::CreateGenericObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISGenObject FAR * pGenObject = NULL;
    CADsExtMgr FAR * pExtensionMgr = NULL;
    HRESULT hr = S_OK;
    LPWSTR pszClassName = ClassName;

    hr = AllocateGenObject(ClassName, Credentials, &pGenObject);
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_IISGenObject,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr =  pGenObject->CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    hr = pGenObject->_pPropertyCache->InitializePropertyCache( 
            pGenObject->_pszServerName 
            );
    BAIL_ON_FAILURE(hr);

    //
    // To maintain compatibility with IIS4 we want to fail when
    // creating a new object if the metabase path already exists.
    //
    if( ADS_OBJECT_UNBOUND == pGenObject->_dwObjectState )
    {
        hr = ::MetaBaseDetectKey( pGenObject->_pAdminBase,
                                  pGenObject->_pszMetaBasePath
                                  );
        if( SUCCEEDED(hr) )
        {
            hr = HRESULT_FROM_WIN32( ERROR_ALREADY_EXISTS );
        }
        else if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) )
        {
            hr = S_OK;
        }
        
        BAIL_ON_FAILURE(hr);
    }

    if ( !_wcsicmp(ClassName, L"IIsFtpServer") ||
         !_wcsicmp(ClassName, L"IIsWebServer") ||
         !_wcsicmp(ClassName, L"IIsNntpServer") ||
         !_wcsicmp(ClassName, L"IIsSmtpServer") ||
         !_wcsicmp(ClassName, L"IIsPop3Server") ||
		 !_wcsicmp(ClassName, L"IIsImapServer")
		 ) 
	{
         pszClassName = L"IIsServer";
    }
    else if ( !_wcsicmp(ClassName, L"IIsWebDirectory") ||
         !_wcsicmp(ClassName, L"IIsWebVirtualDir")) 
	{
         pszClassName = L"IIsApp";
    }

    hr = ADSILoadExtensionManager(
                    pszClassName,
                    (IADs *)pGenObject,
                    Credentials,
                    pGenObject->_pDispMgr,
                    &pExtensionMgr
                    );
    BAIL_ON_FAILURE(hr);

    pGenObject->_pExtMgr = pExtensionMgr;

    hr = pGenObject->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pGenObject->Release();

    RRETURN(hr);

error:

    delete pGenObject;
    RRETURN(hr);
}

CIISGenObject::~CIISGenObject( )
{
    if (_pExtMgr)
    {
        delete _pExtMgr;
    }

    VariantClear(&_vFilter);

    if (_pDispMgr)
    {
        delete _pDispMgr;
    }

    if (_pPropertyCache)
    {
        delete _pPropertyCache;
    }

    if (_pszServerName) {

        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath){

        FreeADsStr(_pszMetaBasePath);
    }

}




STDMETHODIMP
CIISGenObject::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{

    if (ppv == NULL) {
        RRETURN(E_POINTER);
    }

    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISBaseObject))
    {
        *ppv = (IISBaseObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (_pExtMgr)
    {
        RRETURN(_pExtMgr->QueryInterface(iid,ppv));
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CIISGenObject::SetInfo()
{
    HRESULT hr = S_OK;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        // Check to see if we're creating an IIsApplicationPool
        // If so, use the IISApplicationAdmin interface

        if ( !_wcsicmp(_ADsClass, L"IIsApplicationPool")) 
	    {
            memset(pcsiParam, 0, sizeof(COSERVERINFO));

            //
            // special case to handle "localhost" to work-around ole32 bug
            //

            if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
                pcsiParam->pwszName =  NULL;
            }
            else {
                pcsiParam->pwszName = _pszServerName;
            }

            hr = CoGetClassObject(
                        CLSID_WamAdmin,
                        CLSCTX_SERVER,
                        pcsiParam,
                        IID_IClassFactory,
                        (void**) &pcsfFactory
                        );

            BAIL_ON_FAILURE(hr);
    
            hr = pcsfFactory->CreateInstance(
                        NULL,
                        IID_IIISApplicationAdmin,
                       (void **) &pAppAdmin
                        );
            BAIL_ON_FAILURE(hr);

            hr = pAppAdmin->CreateApplicationPool( _Name );

            // Don't BAIL_ON_FAILURE here!  Check the HR below first...
        }

        // Otherwise do the creation the old fashioned way

        else {
            hr = IISCreateObject();
        }

        //
        // Since methods that we aggregate like IIsApp::AppCreate may
        // persist our path in the metabase we don't want to fail just
        // because the path exists. This is done to maintain backward
        // compatibility with IIS4.
        //
        if( ERROR_ALREADY_EXISTS != HRESULT_CODE(hr) )
        {
            BAIL_ON_FAILURE(hr);
        }

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    RRETURN(hr);
}


HRESULT
CIISGenObject::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwMDNumDataEntries = 0;


    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                (LPWSTR) _pszMetaBasePath,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);


    hr = _pPropertyCache->IISMarshallProperties(
                            &pMetaDataArray,
                            &dwMDNumDataEntries
                            );
    BAIL_ON_FAILURE(hr);

    hr = MetaBaseSetAllData(
                _pAdminBase,
                hObjHandle,
                L"",
                (PMETADATA_RECORD)pMetaDataArray,
                dwMDNumDataEntries
                );
    BAIL_ON_FAILURE(hr);


error:

    if (pMetaDataArray) {
        FreeMetaDataRecordArray(pMetaDataArray, dwMDNumDataEntries);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }


    RRETURN(hr);
}


HRESULT
CIISGenObject::IISCreateObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    WCHAR DataBuf[MAX_PATH];
    WCHAR * PathBuf = (WCHAR *)AllocADsMem((DWORD) wcslen(_pszMetaBasePath)*sizeof(WCHAR) + 2);
	WCHAR * pChild = NULL;

	if (PathBuf == NULL)
	{
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
	}
    wcscpy(PathBuf, _pszMetaBasePath);
    WCHAR * q = NULL, * p = NULL;
	do
	{
        hr = MetaBaseDetectKey(_pAdminBase, PathBuf);
		// if failed, try parent path
		if (FAILED(hr))
		{
			p = _tcsrchr(PathBuf, _T('/'));
			if (p != NULL)
			{
                if (q != NULL)
                    *q = _T('/');
				*p = 0;
				pChild = p + 1;
			}
			else
			{
    			BAIL_ON_FAILURE(hr);
			}
		}
		else
        {
		    break;
        }
        q = p;
	} while (true);

	hr = OpenAdminBaseKey(
			_Credentials,
            _pszServerName,
            PathBuf,
            METADATA_PERMISSION_WRITE,
            &_pAdminBase,
            &hObjHandle
            );
    BAIL_ON_FAILURE(hr);
    if (pChild != NULL)
    {
        hr = MetaBaseCreateObject(
                _pAdminBase,
                hObjHandle,
                pChild
                );
    }
    if( ERROR_ALREADY_EXISTS != HRESULT_CODE(hr) )
    {
        BAIL_ON_FAILURE(hr);
    }

    //
    // Set KeyType
    //

    if (wcslen(_ADsClass) >= MAX_PATH)
    {
        BAIL_ON_FAILURE(E_ADS_BAD_PARAMETER);
    }
    wcscpy((LPWSTR)DataBuf, _ADsClass);

    mdrData.dwMDIdentifier = MD_KEY_TYPE;
    mdrData.dwMDDataType = STRING_METADATA;
    mdrData.dwMDUserType = IIS_MD_UT_SERVER;
    mdrData.dwMDAttributes = METADATA_NO_ATTRIBUTES;
    mdrData.dwMDDataLen = (DWORD)(wcslen(DataBuf)+1)*2;
    mdrData.pbMDData = (PBYTE)DataBuf;

    hr = _pAdminBase->SetData(
                hObjHandle,
                pChild,
                &mdrData);
    BAIL_ON_FAILURE(hr);

error:
    if (_pAdminBase && hObjHandle) 
	{
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }
	if (PathBuf != NULL)
	{
		FreeADsMem(PathBuf);
	}

    RRETURN(hr);
}

HRESULT
CIISGenObject::GetInfo()
{
    _pPropertyCache->flushpropcache();

    RRETURN(GetInfo(TRUE));
}

HRESULT
CIISGenObject::GetInfo(
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwMDAttributes =  METADATA_INHERIT;
    DWORD dwMDUserType = ALL_METADATA;
    DWORD dwMDDataType = ALL_METADATA;
    DWORD dwMDNumDataEntries;
    DWORD dwMDDataSetNumber;
    LPBYTE pBuffer = NULL;


    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);


    hr = MetaBaseGetAllData(
                _pAdminBase,
                hObjHandle,
                L"",
                dwMDAttributes,
                dwMDUserType,
                dwMDDataType,
                &dwMDNumDataEntries,
                &dwMDDataSetNumber,
                (LPBYTE *)&pBuffer
                );
    BAIL_ON_FAILURE(hr);


    hr = _pPropertyCache->IISUnMarshallProperties(
                            pBuffer,
                            pBuffer,
                            dwMDNumDataEntries,
                            fExplicit
                            );
    BAIL_ON_FAILURE(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CIISGenObject::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISGenObject::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISGenObject::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                    _ADsPath,
                    ClassName,
                    RelativeName,
                    _Credentials,
                    ppObject,
                    FALSE
                    );
    RRETURN(hr);

}

STDMETHODIMP
CIISGenObject::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CIISGenObjectEnum::Create(
                (CIISGenObjectEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}

inline
HRESULT
ValidateRelativePath(
    IN LPCWSTR wszRelativePath
    )
/*++

Routine Description:

    Determine if a relative path is valid. This is really just to check
    assumptions that are made about the relative path. 
    
    It doesn't do much now, but might be expanded and moved to a common
    location if necessary.

Arguments:

    IN wszRelativePath  : a relative ads path

Return Value:

    E_ADS_BAD_PATHNAME if the path is not valid

--*/
{
    HRESULT hr = E_ADS_BAD_PATHNAME;

    if( wszRelativePath && *wszRelativePath != L'/' )
    {
        hr = S_OK;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT   hr = S_OK;
    IADs *    pADs  = NULL;
 
    BOOL      bRelativeNameExtended = FALSE;
    LPWSTR    pwszParentClass = NULL;
    LPWSTR    pwszParentADsPath = NULL;
    LPWSTR    pwszRelativeName = NULL;
    DWORD     i = 0;

    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //
    hr = _pSchema->ValidateClassName(ClassName);
    BAIL_ON_FAILURE(hr);

    //
    // Handle case where RelativeName may be an extended path,
    // such as foo/bar/baz.
    //
    hr = ValidateRelativePath( RelativeName );
    BAIL_ON_FAILURE(hr);

    bRelativeNameExtended = ( wcschr( RelativeName, L'/' ) != NULL );
    if( bRelativeNameExtended )
    {
        pwszRelativeName = wcsrchr( RelativeName, L'/' ) + 1;

        hr = ResolveExtendedChildPath( RelativeName, 
                                       &pwszParentADsPath,
                                       &pwszParentClass );

        BAIL_ON_FAILURE(hr);
    }
    else
    {
        pwszParentClass = _ADsClass;
        pwszParentADsPath = _ADsPath;
        pwszRelativeName = RelativeName;
    }

    //
    // validate name --> can't have ',' in the name
    //

    while (RelativeName[i] != L'\0' && RelativeName[i] != L',')
       i++;

    if (RelativeName[i] != L'\0' || i >= METADATA_MAX_NAME_LEN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    } 
  
    hr = _pSchema->ValidateContainedClassName(pwszParentClass, ClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    pwszParentADsPath,
                    pwszRelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    hr = pADs->QueryInterface(
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pADs) {
        pADs->Release();
    }
    
    if( bRelativeNameExtended )
    {
        ADsFreeString( pwszParentClass );
        ADsFreeString( pwszParentADsPath );
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISGenObject::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IIISApplicationAdmin * pAppAdmin = NULL;

    //
    // Get Server and Path name
    //

    hr = CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    // Check to see if we're deleting an IIsApplicationPool
    // If so, use the IISApplicationAdmin interface

    if ( !_wcsicmp(bstrClassName, L"IIsApplicationPool")) 
	{
        memset(pcsiParam, 0, sizeof(COSERVERINFO));

        //
        // special case to handle "localhost" to work-around ole32 bug
        //

        if (_pszServerName == NULL || _wcsicmp(_pszServerName,L"localhost") == 0) {
            pcsiParam->pwszName =  NULL;
        }
        else {
            pcsiParam->pwszName = _pszServerName;
        }

        hr = CoGetClassObject(
                    CLSID_WamAdmin,
                    CLSCTX_SERVER,
                    pcsiParam,
                    IID_IClassFactory,
                    (void**) &pcsfFactory
                    );

        BAIL_ON_FAILURE(hr);
    
        hr = pcsfFactory->CreateInstance(
                    NULL,
                    IID_IIISApplicationAdmin,
                   (void **) &pAppAdmin
                    );
        BAIL_ON_FAILURE(hr);

        hr = pAppAdmin->DeleteApplicationPool( bstrRelativeName );

        BAIL_ON_FAILURE(hr);
        
    }

    // Otherwise do the delete the old fashioned way

    else {
        hr = OpenAdminBaseKey(
                    _Credentials,
                    _pszServerName,
                    _pszMetaBasePath,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Pass in full path
        //

        hr = MetaBaseDeleteObject(
                    _pAdminBase,
                    hObjHandle,
                    (LPWSTR)bstrRelativeName
                    );
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }
 
    if (pAppAdmin) {
        pAppAdmin->Release();
    } 

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    LPWSTR pszIISPathName = NULL;
    IADs  *pADs = NULL;
    BSTR bstrClassName = NULL;
    LPWSTR pszPath = NULL;
    IWamAdmin2 *pWamAdmin = NULL;
    LPWSTR pszIISNewName = NULL;
    bool bIsW3 = false;

    bIsW3 = CheckIsW3(_ADsPath);

    if (bIsW3)
    {
        hr = InitWamAdmin(_pszServerName, &pWamAdmin);
        BAIL_ON_FAILURE(hr);
    }

    //
    // open common path node
    //

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                pszIISPathName,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Do Copy operation
    //

    hr = MetaBaseCopyObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)SourceName,
                hObjHandle,
                (LPWSTR)NewName
                );
    BAIL_ON_FAILURE(hr);

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    if (pszIISPathName) {
        DWORD dwLen;
        dwLen = (DWORD)(wcslen(pszIISPathName) + wcslen(NewName)) + 2;

        pszIISNewName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISNewName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISNewName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISNewName, L"/");
            wcscat(pszIISNewName, (LPWSTR)NewName);
        }
    }

    if (bIsW3 && pWamAdmin)
    {
        hr = pWamAdmin->AppRecover((LPWSTR) pszIISNewName, TRUE);
        BAIL_ON_FAILURE(hr);
    }

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    NewName,
                    bstrClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    pszPath = ((CIISGenObject*)pADs)->ReturnMetaDataPath();

    hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase) {
        if (hObjHandle) {
            CloseAdminBaseKey(_pAdminBase, hObjHandle);
        }
    }

    if (pWamAdmin) {
        UninitWamAdmin(pWamAdmin);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszIISNewName) {
        FreeADsMem(pszIISNewName);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}

bool
CIISGenObject::CheckIsW3(LPCWSTR pszPath)
{
    // we should only return true if the second part of the path = 'W3SVC'
    // IIS://localhost/W3SVC/1/blah

    WCHAR* token = NULL;
    WCHAR* pszWorker  = NULL;

    pszWorker = new WCHAR[(DWORD)wcslen(pszPath) + 1];
    if (!pszWorker)
    {
        return false;
        
    }

    wcscpy(pszWorker, pszPath);

    // get the first token
    token = wcstok((WCHAR*)pszWorker, L"/");

    // get the second token
    token = wcstok(NULL, L"/");
    token = wcstok(NULL, L"/");
    if (token && !_wcsicmp(token, L"w3svc"))
    {
        if (pszWorker)
        {
            delete [] pszWorker;
        }
        return true;
    }

    if (pszWorker)
    {
        delete [] pszWorker;
    }
    return false;
}

STDMETHODIMP
CIISGenObject::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IUnknown *pUnk = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    LPWSTR pszIISPathName = NULL;
    IADs  *pADs = NULL;
    BSTR bstrClassName = NULL;
    LPWSTR pszPath = NULL;
    IWamAdmin2 *pWamAdmin = NULL;
    LPWSTR pszIISOldName = NULL;
    LPWSTR pszIISNewName = NULL;
    bool bIsW3 = false;

    bIsW3 = CheckIsW3(_ADsPath);

    if (bIsW3)
    {
        hr = InitWamAdmin(_pszServerName, &pWamAdmin);
        BAIL_ON_FAILURE(hr);
    }

    //
    // open common path node
    //

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    if (pszIISPathName) {

        DWORD dwLen;
        dwLen = (DWORD)(wcslen(pszIISPathName) + wcslen(SourceName)) + 2;

        pszIISOldName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISOldName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISOldName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISOldName, L"/");
            wcscat(pszIISOldName, (LPWSTR)SourceName);
        }
    }

    if (bIsW3 && pWamAdmin)
    {
        hr = pWamAdmin->AppDeleteRecoverable((LPWSTR) pszIISOldName, TRUE);
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                pszIISPathName,
                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Do Move operation
    //

    hr = MetaBaseMoveObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)SourceName,
                hObjHandle,
                (LPWSTR)NewName
                );
    BAIL_ON_FAILURE(hr);

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    if (pszIISPathName) {
        DWORD dwLen;
        dwLen = (DWORD)(wcslen(pszIISPathName) + wcslen(NewName)) + 2;

        pszIISNewName = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pszIISNewName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        wcscpy(pszIISNewName, pszIISPathName);
        if (NewName) {
            wcscat(pszIISNewName, L"/");
            wcscat(pszIISNewName, (LPWSTR)NewName);
        }
    }

    if (bIsW3 && pWamAdmin)
    {
        hr = pWamAdmin->AppRecover((LPWSTR) pszIISNewName, TRUE);
        BAIL_ON_FAILURE(hr);
    }

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);

    hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    NewName,
                    bstrClassName,
                    _Credentials,
                    ADS_OBJECT_BOUND,
                    IID_IADs,
                    (void **)&pADs
                    );
    BAIL_ON_FAILURE(hr);

    pszPath = ((CIISGenObject*)pADs)->ReturnMetaDataPath();

    hr = pADs->QueryInterface(
                        IID_IDispatch,
                        (void **)ppObject
                        );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase) {
        if (hObjHandle) {
            CloseAdminBaseKey(_pAdminBase, hObjHandle);
        }
    }

    if (pWamAdmin) {
        UninitWamAdmin(pWamAdmin);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszIISOldName) {
        FreeADsMem(pszIISOldName);
    }

    if (pszIISNewName) {
        FreeADsMem(pszIISNewName);
    }

    if (pADs){
        pADs->Release();
    }

    RRETURN(hr);
}


HRESULT
CIISGenObject::AllocateGenObject(
    LPWSTR pszClassName,
    CCredentials& Credentials,
    CIISGenObject ** ppGenObject
    )
{
    CIISGenObject FAR * pGenObject = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pGenObject = new CIISGenObject();
    if (pGenObject == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pGenObject,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISBaseObject,
                           (IISBaseObject *)pGenObject,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pGenObject,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);

    pDispMgr->RegisterPropertyCache((IPropertyCache*)pPropertyCache);

    pGenObject->_Credentials = Credentials;
    pGenObject->_pPropertyCache = pPropertyCache;
    pGenObject->_pDispMgr = pDispMgr;
    *ppGenObject = pGenObject;

    RRETURN(hr);

error:
    if (pDispMgr)
    {
        delete pDispMgr;
    }

    if (pGenObject)
    {
        delete pGenObject;
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISGenObject::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    if (NULL == bstrClassName)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup ADSI IIS syntax Id
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    // check if property is RAW BINARY type;
    // if RAW BINARY type, get corresponding NTACL flag property
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }


    //
    // retrieve data object from cache; if one exists
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    //
    // always return an array for multisz type
    //

    if (dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
        hr = IISTypeToVarTypeCopy(
                _pSchema,
                bstrName,
                pIISSrcObjects,
                pvProp,
                TRUE
                );
    }

    else if (dwNumValues == 1 && dwSyntax != IIS_SYNTAX_ID_MULTISZ &&
        dwSyntax != IIS_SYNTAX_ID_MIMEMAP ) {

        hr  = IISTypeToVarTypeCopy(
                   _pSchema,
                   bstrName,
                   pIISSrcObjects,
                   pvProp,
                   FALSE
                   );
    }else {

        hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    FALSE
                    );

    }

    BAIL_ON_FAILURE(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax ID
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // Issue: How do we handle multi-valued support
    //

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &vProp);
    BAIL_ON_FAILURE(hr);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    }
    else {

        dwNumValues = 1;
        pvProp = &vVar;
    }


    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISDestObjects,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }
    

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIISGenObject::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    METADATA_HANDLE hObjHandle = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax Id
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pIISDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;

        //
        // Now begin the rest of the processing
        //
  
        VariantInit(&vVar);
        hr = VariantCopyInd(&vVar, &vProp);
        BAIL_ON_FAILURE(hr);

        if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
            hr  = ConvertArrayToVariantArray(
                        vVar,
                        &pVarArray,
                        &dwNumValues
                        );

            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
        else {
            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

		VariantClear(&vVar);

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToIISTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        dwNumValues,
                        &pIISDestObjects,
                        TRUE
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        if (dwFlags != CACHE_PROPERTY_CLEARED) {

            hr = _pSchema->LookupBitMask(bstrName, &dwMask);
            BAIL_ON_FAILURE(hr);

            // 
            // get its corresponding DWORD flag value
            // 

            VariantInit(&vGetProp);
            hr = Get(wchName, &vGetProp);
            BAIL_ON_FAILURE(hr);

            dwFlagValue = V_I4(&vGetProp);
 
            if (pIISDestObjects->IISValue.value_1.dwDWORD) {
                dwFlagValue |= dwMask;
            }
            else {
                dwFlagValue &= ~dwMask;
            }

            pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
            pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        }

        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

    if (dwFlags == CACHE_PROPERTY_CLEARED) {
        DWORD dwMetaId;

        hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
        BAIL_ON_FAILURE(hr);

        hr = InitServerInfo(_Credentials, _pszServerName, &_pAdminBase, &_pSchema);
        BAIL_ON_FAILURE(hr);

        hr = OpenAdminBaseKey(
                    _Credentials,
                    _pszServerName,
                    _pszMetaBasePath,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
    }

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISGenObject::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];
    BSTR bstrClassName = NULL;

    //
    // check if property is a supported property
    //

    hr = get_CoreADsClass(&bstrClassName);
    BAIL_ON_FAILURE(hr);
    if (NULL == bstrClassName)
    {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }
    hr = _pSchema->ValidateProperty(bstrClassName, bstrName);
    BAIL_ON_FAILURE(hr);

    //
    // lookup its syntax Id
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    // check if property is RAW BINARY type;
    // if RAW BINARY type, get corresponding NTACL flag property
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    TRUE
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

HRESULT
CIISGenObject::CacheMetaDataPath()
{
    HRESULT hr = E_FAIL;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(_ADsPath);
    LPWSTR pszIISPathName =  NULL;


    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    _pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = InitServerInfo(_Credentials, _pszServerName, &_pAdminBase, &_pSchema);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(_ADsPath);

    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';

    hr = BuildIISPathFromADsPath(
                pObjectInfo,
                pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    _pszMetaBasePath = AllocADsStr(pszIISPathName);

    if (!_pszMetaBasePath) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

error:

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

}

STDMETHODIMP
CIISGenObject::GetDataPaths(
    THIS_ BSTR bstrName,
    THIS_ LONG lnAttribute,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    DWORD dwAttribute;
    DWORD dwTemp;
    METADATA_HANDLE hObjHandle = NULL;
    LPBYTE pBuffer = NULL;

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
    BAIL_ON_FAILURE(hr);

    hr = _pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwTemp);
    BAIL_ON_FAILURE(hr);

    switch (lnAttribute) {
    case IIS_ANY_PROPERTY:
       break;

    case IIS_INHERITABLE_ONLY:
       if ((METADATA_INHERIT & dwAttribute) != METADATA_INHERIT) {
          RRETURN(hr = MD_ERROR_DATA_NOT_FOUND); 
       }
       break;

    default :
       RRETURN(hr = E_ADS_BAD_PARAMETER);
    }  

    //
    // Get Server and Path name
    //

    hr = CacheMetaDataPath();
    BAIL_ON_FAILURE(hr);

    hr = OpenAdminBaseKey(
                _Credentials,
                _pszServerName,
                _pszMetaBasePath,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr =  MetaBaseGetDataPaths(_pAdminBase,
                               hObjHandle,
                               dwMetaId,
                               (LPBYTE *)&pBuffer
                               ); 
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromPathArray( (LPWSTR)_ADsPath, (LPWSTR)pBuffer, pvProp);
    BAIL_ON_FAILURE(hr);

error:

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISGenObject::GetPropertyAttribObj(
    THIS_ BSTR bstrName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    DWORD i = 0;
    PROPERTYINFO *pPropertyInfo = NULL;
    IISPropertyAttribute * pPropAttrib = NULL;
    WCHAR wchName[MAX_PATH];

    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;
    VARIANT vVar;

    VariantInit(&vVar);
    *ppObject = NULL;

    //
    // if passed in bstrName is a meta id, then convert it to property name
    //

    if (wcslen(bstrName) >= MAX_PATH) bstrName[MAX_PATH - 1] = L'\0';
    wcscpy((LPWSTR)wchName, bstrName);
    
    while (wchName[i] != L'\0' && wchName[i] >= L'0' && 
           wchName[i] <= L'9') {
       i++;
    }
 
    if (i == wcslen((LPWSTR)wchName)) {
        dwMetaId = _wtoi((LPWSTR)wchName);
        hr = _pSchema->ConvertID_To_PropName(dwMetaId, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }
    else {

        //
        // check if property is a supported property
        //

        hr = _pSchema->LookupMetaID(bstrName, &dwMetaId);
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
            _Credentials,
            _pszServerName,
            _pszMetaBasePath,
            METADATA_PERMISSION_READ,
            &_pAdminBase,
            &hObjHandle
            );
    BAIL_ON_FAILURE(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                   dwMetaId,
                   METADATA_INHERIT | METADATA_ISINHERITED,
                   ALL_METADATA,
                   ALL_METADATA,
                   dwBufferSize,
                   pBuffer);

    hr = _pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);
    mdrMDData.pbMDData = pBuffer;
    mdrMDData.dwMDDataLen = dwBufferSize; 

    hr = _pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );
    BAIL_ON_FAILURE(hr);

    //
    // get default value
    //

    pPropertyInfo = _pSchema->GetPropertyInfo(wchName);
    ASSERT(pPropertyInfo != NULL);

    if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        vVar.vt = VT_I4;
        vVar.lVal = pPropertyInfo->dwDefault;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
             pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        vVar.vt = VT_BOOL;
        vVar.boolVal = pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
        LPWSTR pszStr = pPropertyInfo->szDefault;

        hr = MakeVariantFromStringArray(NULL,
                                        pszStr,
                                        &vVar);
        BAIL_ON_FAILURE(hr);
    }
    else {
        vVar.vt = VT_BSTR;
        hr = ADsAllocString( pPropertyInfo->szDefault, &(vVar.bstrVal));
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyAttribute::CreatePropertyAttribute(
                           IID_IISPropertyAttribute,
                           (VOID**)&pPropAttrib
                           );
    BAIL_ON_FAILURE(hr);

    hr = ((CPropertyAttribute*)pPropAttrib)->InitFromRawData(
                           (LPWSTR) wchName,
                           dwMetaId,
                           mdrMDData.dwMDUserType,   // usertype
                           mdrMDData.dwMDAttributes,  // attributes
                           &vVar
                           );
    BAIL_ON_FAILURE(hr);

    *ppObject = (IDispatch*)pPropAttrib;

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    if (hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

HRESULT
CIISGenObject::ResolveExtendedChildPath(
    IN   BSTR RelativeChildPath,
    OUT  BSTR *pParentPath,
    OUT  BSTR *pParentClass
)
/*++

Routine Description:

    Helper method called from CIISGenObject::Create() finds the
    metabase key that is most proximate to RelativeChildPath and
    returns the ADS class for this key along with adjusted path
    for the parent.

Arguments:

    IN  RelativeChildPath : An extended subpath, such as foo/bar
    OUT pParentPath       : Allocated with ADsAllocString
    OUT pParentClass      : Allocated with ADsAllocString

Return Value:

    S_OK
    S_FALSE               : No path found in the metabase

--*/
{
    ADsAssert( RelativeChildPath );
    ADsAssert( pParentPath );
    ADsAssert( pParentClass );

    *pParentPath = NULL;
    *pParentClass = NULL;

    HRESULT hr = S_OK;
    DWORD   cbBuffSize;
    LPWSTR  pwszPathBuffer = NULL;
    DWORD   dwLen;
    BOOL    bFound;
    WCHAR   *pch = NULL;
    WCHAR   wszParentClassBuffer[MAX_PATH];    

    //
    // Build buffer to hold the metabase and ads paths
    //
    cbBuffSize = (DWORD)((wcslen(_ADsPath) + wcslen(RelativeChildPath) + 2)
                 * sizeof(WCHAR));
    
    pwszPathBuffer = (LPWSTR)AllocADsMem( cbBuffSize );
    if( !pwszPathBuffer )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    
    ZeroMemory( pwszPathBuffer, cbBuffSize );
    
    //
    // Build the metabase path for the child
    //
    
    if (wcslen(_pszMetaBasePath) > wcslen(_ADsPath))
    {
        BAIL_ON_FAILURE(E_ADS_BAD_PARAMETER);
    }

    wcscpy( pwszPathBuffer, _pszMetaBasePath );
    
    dwLen = (DWORD)wcslen( pwszPathBuffer );
    ADsAssert( dwLen );

    if( pwszPathBuffer[dwLen - 1] != L'/' )
    {
        pwszPathBuffer[dwLen] = L'/';
    }
    wcscat( pwszPathBuffer, RelativeChildPath );

    //
    // Look for the closest path in the metabase to our child
    //
    bFound = FALSE;
    
    pch = wcsrchr( pwszPathBuffer, L'/' );
    if (pch != NULL)
      *pch = 0;
    
    while( !bFound && 0 != wcscmp( pwszPathBuffer, _pszMetaBasePath ) )
    {
        hr = MetaBaseDetectKey( _pAdminBase, pwszPathBuffer );
        if( SUCCEEDED(hr) )
        {
            bFound = TRUE;
        }
        else if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) )
        {
            // Continue up the path buffer
            pch = wcsrchr( pwszPathBuffer, L'/' );
            if (pch != NULL)
               *pch = 0;

            hr = S_FALSE;
        }
        else
        {
            BAIL_ON_FAILURE( hr );
        }
    }

    //
    // Get pParentClass
    //
    if( bFound )
    {
        // Get the key type from the node
        hr = MetaBaseGetADsClass( _pAdminBase, 
                                  pwszPathBuffer, 
                                  _pSchema, 
                                  wszParentClassBuffer,
                                  MAX_PATH
                                  );
        BAIL_ON_FAILURE( hr );
    }
    else
    {
        // Use our own key type
        if (wcslen(_ADsClass) >= MAX_PATH)
        {
            BAIL_ON_FAILURE(E_ADS_BAD_PARAMETER);
        }
        wcscpy( wszParentClassBuffer, _ADsClass );
    }

    hr = ADsAllocString( wszParentClassBuffer, pParentClass );
    BAIL_ON_FAILURE( hr );

    //
    // Get pParentPath
    //
    wcscpy( pwszPathBuffer, _ADsPath );
    wcscat( pwszPathBuffer, L"/" );
    wcscat( pwszPathBuffer, RelativeChildPath );
    pch = wcsrchr( pwszPathBuffer, L'/' );
    if (pch != NULL)
      *pch = 0;

    hr = ADsAllocString( pwszPathBuffer, pParentPath );
    BAIL_ON_FAILURE( hr );
    
error:

    if( pwszPathBuffer )
    {
        FreeADsMem( pwszPathBuffer );
    }

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\charset.cxx ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    charset.cxx

Abstract:

    Contains some functions to do Unicode <-> Ansi/MBCS convertsions.

Author:

    Danilo Almeida  (t-danal)  06-17-96

Revision History:

--*/


//
// INCLUDES
//

#include "iis.hxx"

/*
 *  AnsiBytesFromUnicode
 *
 *  Description:
 *      Given a Unicode string, returns number of bytes needed for Ansi version
 *
 *  In:
 *      pwszUnicode - pointer to Unicode string
 */

int
AnsiBytesFromUnicode(
    LPCWSTR pwszUnicode
    )
{
    return WideCharToMultiByte(CP_ACP,
                               0,
                               pwszUnicode,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
}


/*
 *  AllocAnsi
 *
 *  Description:
 *      Given a Unicode string, allocate a new Ansi translation of that string
 *
 *  In:
 *      pwszUnicode - pointer to original Unicode string
 *      ppszAnsi    - pointer to cell to hold new MCBS string addr
 *
 *  Out:
 *      ppszAnsi    - contains new MBCS string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeAnsi.
 */

UINT
AllocAnsi(
    LPCWSTR pwszUnicode,
    LPSTR* ppszAnsi
    )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbUnicode;
    INT      cbAnsi;

    if (pwszUnicode == NULL)
    {
        *ppszAnsi = NULL;
        return 0;
    }

    cbAnsi = AnsiBytesFromUnicode(pwszUnicode);
    err = MyAllocMem(cbAnsi, &pbAlloc);
    if (err)
        return err;

    cbUnicode = (DWORD)wcslen(pwszUnicode)+1;

    *ppszAnsi = (LPSTR)pbAlloc;

    err = (UINT) !WideCharToMultiByte(CP_ACP,
                                      0,
                                      pwszUnicode,
                                      cbUnicode,
                                      *ppszAnsi,
                                      cbAnsi,
                                      NULL,
                                      NULL);
    if (err)
    {
        *ppszAnsi = NULL;
        MyFreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}


/*
 *  FreeAnsi
 *
 *  Description:
 *      Deallocates an Ansi string allocated by AllocAnsi
 *
 *  In:
 *      pszAnsi - pointer to the Ansi string
 *
 *  Out:
 *      pszAnsi - invalid pointer - string has been freed
 */

VOID
FreeAnsi(LPSTR pszAnsi)
{
    if (pszAnsi != NULL)
        MyFreeMem((LPBYTE)pszAnsi);
}

/*
 *  AllocUnicode
 *
 *  Description:
 *      Given an Ansi string, allocates an Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      ppwszUnicode    - pointer to new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - points to new Unicode string
 *
 *  Returns:
 *      Error code or 0 if successful.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

UINT
AllocUnicode(
    LPCSTR   pszAnsi,
    LPWSTR * ppwszUnicode )
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cbAnsi;

    if (pszAnsi == NULL)
    {
        *ppwszUnicode = NULL;
        return 0;
    }

    // Allocate space for Unicode string (may be a little extra if MBCS)

    cbAnsi = (DWORD)strlen(pszAnsi)+1;
    err = MyAllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
        return err;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    err = (UINT) !MultiByteToWideChar(CP_ACP,
                                      MB_PRECOMPOSED,
                                      pszAnsi,
                                      cbAnsi,
                                      *ppwszUnicode,
                                      cbAnsi);
    if (err)
    {
        *ppwszUnicode = NULL;
        MyFreeMem(pbAlloc);
        return ( (UINT)GetLastError() );
    }

    return 0;
}

/*
 *  AllocUnicode2
 *
 *  Description:
 *      Given a MBCS string, allocates a new Unicode version of that string
 *
 *  In:
 *      pszAnsi         - pointer to original MBCS string
 *      cbAnsi          - number of bytes to convert
 *      ppwszUnicode    - pointer to where to return new Unicode string address
 *
 *  Out:
 *      ppwszUnicode    - contains new Unicode string
 *
 *  Returns:
 *      Returns number of characters written.
 *
 *  Notes:
 *      The client must free the allocated string with FreeUnicode.
 */

int
AllocUnicode2(
    LPCSTR   pszAnsi,
    int      cbAnsi,
    LPWSTR * ppwszUnicode)
{
    UINT     err;
    BYTE *   pbAlloc;
    INT      cwch;

    *ppwszUnicode = NULL;
    SetLastError(ERROR_SUCCESS);

    if (cbAnsi == 0)
        return 0;

    err = MyAllocMem(sizeof(WCHAR) * cbAnsi, &pbAlloc);
    if (err)
    {
        SetLastError(err);
        return 0;
    }

    *ppwszUnicode = (LPWSTR)pbAlloc;

    cwch = MultiByteToWideChar(CP_ACP,
                               MB_PRECOMPOSED,
                               pszAnsi,
                               cbAnsi,
                               *ppwszUnicode,
                               cbAnsi);

    if (cwch == 0)
    {
        *ppwszUnicode = NULL;
        MyFreeMem(pbAlloc);
    }

    return cwch;
}

/*
 *  FreeUnicode
 *
 *  Description:
 *      Deallocates a Unicode string allocatedd by AllocUnicode/AllocUnicode2
 *
 *  In:
 *      pwszUnicode - pointer to the Unicode string
 *
 *  Out:
 *      pwszUnicode - invalid pointer - string has been freed
 */

VOID
FreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        MyFreeMem((LPBYTE)pwszUnicode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cipseccf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cipseccf.cxx
//
//  Contents:  Windows NT 4.0 IP Security Object Class Factory Code
//
//             CIISIPSecurityCF::CreateInstance
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISIPSecurityCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    21-04-97   sophiac     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISIPSecurityCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CIPSecurity::CreateIPSecurity(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------

#define DEFINE_CONTAINED_IADs_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_Name(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                              \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_ADsPath(retval));                            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(_pADs->get_Class(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Parent(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(_pADs->get_Schema(retval));                             \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(_pADs->get_GUID(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(_pADs->Get(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(_pADs->Put(bstrName, vProp));                             \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(_pADs->GetEx(bstrName, pvProp));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(_pADs->PutEx(lnControlCode, bstrName, vProp));            \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetInfo(THIS_)                                                   \
{                                                                     \
    RRETURN(_pADs->GetInfo());                                        \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::SetInfo(THIS_ )                                                  \
{                                                                     \
    RRETURN(_pADs->SetInfo());                                        \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(_pADs->GetInfoEx(vProperties, lnReserved));               \
}


#define DEFINE_CONTAINED_IDSObject_Implementation(cls)                \
STDMETHODIMP                                                          \
cls::SetObjectAttributes(                                             \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes,                                            \
    DWORD *pdwNumAttributesModified                                   \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->SetObjectAttributes(                             \
                        pAttributeEntries,                            \
                        dwNumAttributes,                              \
                        pdwNumAttributesModified                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectAttributes(                                             \
    PADS_ATTR_NAME pAttributeNames,                                   \
    DWORD dwNumberAttributes,                                         \
    PADS_ATTR_DEF *ppAttributeEntries,                                \
    DWORD * pdwNumAttributesReturned                                  \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectAttributes(                             \
                        pAttributeNames,                              \
                        dwNumberAttributes,                           \
                        ppAttributeEntries,                           \
                        pdwNumAttributesReturned                      \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::CreateDSObject(                                                  \
    LPWSTR pszRDNName,                                                \
    PADS_ATTR_DEF pAttributeEntries,                                  \
    DWORD dwNumAttributes                                             \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->CreateDSObject(                                  \
                        pszRDNName,                                   \
                        pAttributeEntries,                            \
                        dwNumAttributes                               \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::DeleteDSObject(                                                  \
    LPWSTR pszRDNName                                                 \
    )                                                                 \
                                                                      \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->DeleteDSObject(                                  \
                        pszRDNName                                    \
                        );                                            \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObjectInformation(                                            \
    THIS_ PADS_OBJECT_INFO  *  ppObjInfo                              \
    )                                                                 \
{                                                                     \
    HRESULT hr = S_OK;                                                \
                                                                      \
    hr = _pDSObject->GetObjectInformation(                            \
                            ppObjInfo                                 \
                            );                                        \
    RRETURN(hr);                                                      \
}

#define DEFINE_CONTAINED_IADsContainer_Implementation(cls)          \
STDMETHODIMP                                                          \
cls::get_Filter(THIS_ VARIANT FAR* pVar )                             \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Filter( pVar );                    \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Filter(THIS_ VARIANT Var )                                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Filter( Var );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Hints(THIS_ VARIANT FAR* pVar )                              \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Hints( pVar );                     \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::put_Hints(THIS_ VARIANT Var )                                    \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->put_Hints( Var );                      \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Count(THIS_ long FAR* retval)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get_Count( retval );                   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get__NewEnum(THIS_ IUnknown * FAR * retval )                     \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->get__NewEnum( retval );                \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetObject(THIS_ BSTR ClassName, BSTR RelativeName,               \
               IDispatch * FAR * ppObject )                           \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->GetObject( ClassName, RelativeName, ppObject ); \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Create(THIS_ BSTR ClassName, BSTR RelativeName,                  \
            IDispatch * FAR * ppObject )                               \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr =_pADsContainer->Create( ClassName, RelativeName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Delete(THIS_ BSTR ClassName, BSTR SourceName )                   \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                         \
        hr = _pADsContainer->Delete( ClassName, SourceName );       \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::CopyHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->CopyHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::MoveHere(THIS_ BSTR SourceName, BSTR NewName,                    \
              IDispatch * FAR * ppObject )                            \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pADsContainer ) {                                           \
        hr = _pADsContainer->MoveHere( SourceName, NewName, ppObject );  \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     

#define DEFINE_CONTAINED_IIsBaseObject_Implementation(cls)            \
STDMETHODIMP                                                          \
cls::GetDataPaths(THIS_ BSTR bstrName, LONG lnAttribute,              \
                  VARIANT FAR* pvProp)                                \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetDataPaths( bstrName, lnAttribute, pvProp);   \
    }                                                                 \
    RRETURN(hr);                                                      \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetPropertyAttribObj(THIS_ BSTR bstrName,                        \
                          IDispatch * FAR *ppObject)                  \
{                                                                     \
    HRESULT hr = E_NOTIMPL;                                           \
    if ( _pIIsBaseObject) {                                           \
        hr = _pIIsBaseObject->GetPropertyAttribObj(bstrName, ppObject); \
    }                                                                 \
    RRETURN(hr);                                                      \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cipsec.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cipsec.cxx
//
//  Contents:  IPSecurity object
//
//  History:   21-4-97     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

#define _RDNS_STANDALONE

#define ILIST_DENY      0
#define ILIST_GRANT     1

#define ITYPE_DNS       0
#define ITYPE_IP        1

#define SENTINEL_ADDR   "0.0.0.0, 255.255.255.255"
#define DEFAULT_MASK    "255.255.255.255"

LPBYTE
GetIp(
    LPSTR               pArg
    );

BOOL
FreeIp(
    LPBYTE              pIp
    );

//  Class CIPSecurity

DEFINE_Simple_IDispatch_Implementation(CIPSecurity)

CIPSecurity::CIPSecurity():
        _pDispMgr(NULL)
{
    ENLIST_TRACKING(CIPSecurity);
}

HRESULT
CIPSecurity::CreateIPSecurity(
    REFIID riid,
    void **ppvObj
    )
{
    CIPSecurity FAR * pIPSecurity = NULL;
    HRESULT hr = S_OK;

    hr = AllocateIPSecurityObject(&pIPSecurity);
    BAIL_ON_FAILURE(hr);

    hr = pIPSecurity->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pIPSecurity->Release();

    RRETURN(hr);

error:
    delete pIPSecurity;

    RRETURN(hr);

}


CIPSecurity::~CIPSecurity( )
{
    delete _pDispMgr;

    _AddrChk.UnbindCheckList();
}

STDMETHODIMP
CIPSecurity::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISIPSecurity))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISIPSecurity FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CIPSecurity::InitFromBinaryBlob(
    LPBYTE pByte,
    DWORD dwLength
    )
{

    DWORD dwDenyEntries, dwGrantEntries;
    LPBYTE pBuffer = NULL;

    if (pByte && dwLength) {
        pBuffer = (LPBYTE) AllocADsMem(dwLength);

        if (!pBuffer) {
            return(E_OUTOFMEMORY);
        }

        memcpy(pBuffer, pByte, dwLength);
    }

    //
    // Length of 0 is the default value for empty blob
    //

    if ((pByte == NULL) || (dwLength == 0)) {
        _AddrChk.BindCheckList(NULL, 0);
    } else {
        _AddrChk.BindCheckList(pBuffer, dwLength);
    }

    dwDenyEntries = _AddrChk.GetNbAddr(FALSE) +
                    _AddrChk.GetNbName(FALSE);

    dwGrantEntries = _AddrChk.GetNbAddr(TRUE) +
                     _AddrChk.GetNbName(TRUE);

    if (dwGrantEntries > dwDenyEntries) {
        _bGrantByDefault = FALSE;

        // 
        // check if entry is a sentinel address
        // 

        if (dwGrantEntries == 1 && _AddrChk.GetNbAddr(TRUE) == 1) {
            DWORD dwFlags;
            LPBYTE pM;
            LPBYTE pA;
            CHAR achE[80];

            if (_AddrChk.GetAddr(TRUE, 0, &dwFlags, &pM, &pA) == TRUE) {

	            wsprintfA( (LPSTR)achE, "%d.%d.%d.%d, %d.%d.%d.%d",
    	            pA[3], pA[2], pA[1], pA[0],
        	        pM[3], pM[2], pM[1], pM[0] );
			}

            if (strcmp(achE, SENTINEL_ADDR) == 0) {
                _AddrChk.DeleteAllAddr(TRUE);
            }
        }
    }
    else {
        _bGrantByDefault = TRUE;
    }

    return S_OK;
}

HRESULT
CIPSecurity::CopyIPSecurity(
    LPBYTE *ppByte,
    PDWORD pdwLength
    )
{
    //
    // Remove the other list if default by grant
    //

    _AddrChk.DeleteAllAddr(_bGrantByDefault);
    _AddrChk.DeleteAllName(_bGrantByDefault);

    //
    // List is empty.  If deny by default is on, create
    // a dummy sentinel entry to grant access to single
    // address 0.0.0.0, otherwise we're ok.
    //

    if (!_bGrantByDefault && 
        !_AddrChk.GetNbAddr(TRUE) &&
        !_AddrChk.GetNbName(TRUE)) {

        BYTE bMask[4] = { 0xff, 0xff, 0xff, 0xff };
        BYTE bIp[4] = { 0, 0, 0, 0 };

        _AddrChk.AddAddr(
            ILIST_GRANT,
            AF_INET,
            bMask,
            bIp
            ); 
    }

    *ppByte = _AddrChk.QueryCheckListPtr();
    *pdwLength = _AddrChk.QueryCheckListSize();

    return S_OK;
}


HRESULT
CIPSecurity::AllocateIPSecurityObject(
    CIPSecurity ** ppIPSecurity
    )
{
    CIPSecurity FAR * pIPSecurity = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pIPSecurity = new CIPSecurity();
    if (pIPSecurity == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {

        if (pIPSecurity)
        {
            delete pIPSecurity;
        }

        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISIPSecurity,
                (IISIPSecurity *)pIPSecurity,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pIPSecurity->_pDispMgr = pDispMgr;
    *ppIPSecurity = pIPSecurity;

    RRETURN(hr);

error:

    if (pDispMgr)
    {
        delete pDispMgr;
    }

    RRETURN(hr);

}

STDMETHODIMP
CIPSecurity::get_IPDeny(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbAddr(FALSE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;

        VariantInit(&v);

        v.vt = VT_BSTR;
        GetEntry(ITYPE_IP, ILIST_DENY, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::put_IPDeny(THIS_ VARIANT pVarIPDeny)
{
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;
    HRESULT hr = S_OK;

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &pVarIPDeny);
    BAIL_ON_FAILURE(hr);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarIPDeny;
    }

    _AddrChk.DeleteAllAddr(FALSE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_IP, ILIST_DENY, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::get_IPGrant(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbAddr(TRUE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_IP, ILIST_GRANT, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_IPGrant(THIS_ VARIANT pVarIPGrant)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &pVarIPGrant);
    BAIL_ON_FAILURE(hr);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarIPGrant;
    }

    _AddrChk.DeleteAllAddr(TRUE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_IP, ILIST_GRANT, pszAnsiName) ) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::get_DomainDeny(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbName(FALSE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_DNS, ILIST_DENY, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_DomainDeny(THIS_ VARIANT pVarDomainDeny)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &pVarDomainDeny);
    BAIL_ON_FAILURE(hr);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarDomainDeny;
    }

    _AddrChk.DeleteAllName(FALSE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {
            if (!AddToList(ITYPE_DNS, ILIST_DENY, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }
            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIPSecurity::get_DomainGrant(THIS_ VARIANT FAR * retval)
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwNumEntries = _AddrChk.GetNbName(TRUE);

    VariantInit(retval);

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;
    aBound.cElements = dwNumEntries;   // number of entries

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumEntries; i++ )
    {
        VARIANT v;
        LPBYTE pByte = NULL;

        VariantInit(&v);
        v.vt = VT_BSTR;

        GetEntry(ITYPE_DNS, ILIST_GRANT, &pByte, i);

        hr = ADsAllocString((LPWSTR)pByte, &(v.bstrVal));

        if (pByte) {
            FreeADsMem(pByte);
        }

        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(retval) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(retval) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

STDMETHODIMP
CIPSecurity::put_DomainGrant(THIS_ VARIANT pVarDomainGrant)
{
    HRESULT hr = S_OK;
    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    VARIANT vVar;
    DWORD dwNumValues;
    DWORD dwStatus;
    DWORD i;
    LPSTR pszAnsiName = NULL;

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &pVarDomainGrant);
    BAIL_ON_FAILURE(hr);

    if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    } 
    else {

        dwNumValues = 1;
        pvProp = &pVarDomainGrant;
    }

    _AddrChk.DeleteAllName(TRUE);

    for (i = 0; i < dwNumValues; i++ ) {
        dwStatus = AllocAnsi(
                        (LPWSTR)pvProp->bstrVal,
                        &pszAnsiName
                        );

        if (dwStatus) {
            BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(dwStatus));
        }

        if (pszAnsiName) {

            if (!AddToList(ITYPE_DNS, ILIST_GRANT, pszAnsiName)) {
                hr = RETURNCODETOHRESULT(ERROR_INVALID_PARAMETER);
            }

            FreeAnsi(pszAnsiName);
            pszAnsiName = NULL;
            BAIL_ON_FAILURE(hr);
        }

        pvProp++;
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}



STDMETHODIMP
CIPSecurity::get_GrantByDefault(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bGrantByDefault ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIPSecurity::put_GrantByDefault(THIS_ VARIANT_BOOL bGrantByDefault)
{
    _bGrantByDefault = bGrantByDefault ? TRUE : FALSE;
    RRETURN(S_OK);
}

/* INTRINSA suppress=null_pointers */
BOOL
CIPSecurity::AddToList(
    int                 iType,
    int                 iList,
    LPSTR               pArg
    )
{
    BOOL        fSt;
    LPBYTE      pMask = NULL;
    LPBYTE      pAddr = NULL;
    char*       pComma= NULL;
    DWORD       dwFlags = 0;

    switch ( iType )
    {
        case ITYPE_IP:
            pComma = strstr(pArg, ",");

            if (NULL == pComma) {
                pMask = GetIp(DEFAULT_MASK);
            }
            else {
                pMask = GetIp(pComma+1);
            }

            if (pComma) {
                *pComma = 0;
            }

            pAddr = GetIp(pArg);

            if (pMask && pAddr) 
            {
                fSt = _AddrChk.AddAddr( iList, AF_INET, pMask, pAddr );
            }
            else
            {
                fSt = FALSE;
            }

            FreeIp( pMask );
            FreeIp( pAddr );
            return fSt;

        case ITYPE_DNS:
            if ( !strncmp( pArg, "*.", 2 ) )
            {
                pArg += 2;
            }
            else
            {
                dwFlags |= DNSLIST_FLAG_NOSUBDOMAIN;
            }
            return _AddrChk.AddName( iList, pArg, dwFlags );
            break;
    }

    return FALSE;
}


BOOL
CIPSecurity::GetEntry(
    int                 iType,
    int                 iList,
    LPBYTE            * ppbyte,
    int                 dwEntry
    )
{
    DWORD   dwF;
    DWORD   dwStatus;
    BOOL    fSt = FALSE;
    LPWSTR  pszStr = NULL;

    *ppbyte = NULL;

    switch ( iType )
    {
        case ITYPE_IP:
            LPBYTE pM;
            LPBYTE pA;
            CHAR achE[80];

            fSt = _AddrChk.GetAddr( iList, dwEntry, &dwF, &pM, &pA );

            if (fSt) {
                wsprintfA( (LPSTR)achE, "%d.%d.%d.%d, %d.%d.%d.%d",
                    pA[0], pA[1], pA[2], pA[3],
                    pM[0], pM[1], pM[2], pM[3] );

                dwStatus = AllocUnicode(
                                (LPSTR)achE,
                                &pszStr
                                );
                if (dwStatus == ERROR_SUCCESS) {
                    *ppbyte = (LPBYTE) pszStr;
                }
                else {
                    fSt = FALSE;
                }
            }
            break;

        case ITYPE_DNS:
            LPSTR pN;
            DWORD dwLen;
            UINT  err;

            // Use break to exit on error condition

            fSt = _AddrChk.GetName( iList, dwEntry, &pN, &dwF );
            if( !fSt )
            {
                break;
            }

            dwLen = (DWORD)strlen(pN) + 1;

            // pszStr is the working copy of our memory
            // *ppbyte is the data to be returned
            
            if ( dwF & DNSLIST_FLAG_NOSUBDOMAIN )
            {
                pszStr = (LPWSTR) AllocADsMem(dwLen*sizeof(WCHAR));
                if( !pszStr )
                {
                    fSt = FALSE;
                    break;
                }
                *ppbyte = (LPBYTE)pszStr;
            }
            else 
            {
                // In this case we have a subdomain restriction, so
                // we want to pre-pend "*." to the string.
                pszStr = (LPWSTR) AllocADsMem((dwLen+2)*sizeof(WCHAR));
                if( !pszStr )
                {
                    fSt = FALSE;
                    break;
                }
                
                // Save the address to return
                *ppbyte = (LPBYTE)pszStr;

                wcscpy((LPWSTR)pszStr, L"*.");
                pszStr += wcslen(pszStr);

            }

            err = (UINT) !MultiByteToWideChar(CP_ACP,
                              MB_PRECOMPOSED,
                              pN,
                              dwLen,
                              pszStr,
                              dwLen);
            if (err)
            {
                FreeADsMem( *ppbyte );
                *ppbyte = NULL;
                fSt = FALSE;
                break;
            }

            // Final break
            break;
    }

    return fSt;
}


LPBYTE
GetIp(
    LPSTR               pArg
    )
{
    if (pArg)
    {
        LPBYTE p;
        p = (LPBYTE)LocalAlloc( LMEM_FIXED, 4 );
        if ( p )
        {
            int p0, p1, p2, p3;
            if ( sscanf( pArg, "%d.%d.%d.%d", &p0, &p1, &p2, &p3 ) == 4 )
            {
                //
                // network byte order
                //
                 
                p[3] = (BYTE)(p3 & 0xFF);
                p[2] = (BYTE)(p2 & 0xFF);
                p[1] = (BYTE)(p1 & 0xFF);
                p[0] = (BYTE)(p0 & 0xFF);
                return p;
            }
            LocalFree( p );
            return NULL;
        }
    }

    return NULL;
}


BOOL
FreeIp(
    LPBYTE              pIp
    )
{
    if ( pIp )
    {
        LocalFree( pIp );
    }

    return TRUE;
}

typedef
VOID
(* PFN_SCHED_CALLBACK)(
    VOID * pContext
    );

dllexp
DWORD
ScheduleWorkItem(
    PFN_SCHED_CALLBACK pfnCallback,
    PVOID              pContext,
    DWORD              msecTimeInterval,
    BOOL               fPeriodic = FALSE
    )
{
    return 0;
}

dllexp
BOOL
RemoveWorkItem(
    DWORD  pdwCookie
    )
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cmimecf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmimecf.cxx
//
//  Contents:  MimeType Object Class Factory Code
//
//  History:   04-01-97     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISMimeTypeCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISMimeTypeCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CMimeType::CreateMimeType(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cnamcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cnamcf.cxx
//
//  Contents:  Windows NT 4.0 Namespace Object Class Factory Code
//
//             CIISNamespaceCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISNamespaceCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISNamespaceCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;
    CCredentials Credentials;

    if (pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISNamespace::CreateNamespace(
                L"ADs:",
                L"IIS:",
                Credentials,
                ADS_OBJECT_BOUND,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cnamesp.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cnamesp.cxx
//
//  Contents:  Namespace Object
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


DEFINE_IDispatch_Implementation(CIISNamespace)
DEFINE_IADs_Implementation(CIISNamespace)

//  Class CIISNamespace

CIISNamespace::CIISNamespace()
{
    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISNamespace);
}

HRESULT
CIISNamespace::CreateNamespace(
    BSTR Parent,
    BSTR NamespaceName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISNamespace FAR * pNamespace = NULL;
    HRESULT hr = S_OK;

    hr = AllocateNamespaceObject(
                Credentials,
                &pNamespace
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->InitializeCoreObject(
                Parent,
                NamespaceName,
                L"Namespace",
                L"",
                CLSID_IISNamespace,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pNamespace->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pNamespace->Release();

    RRETURN(hr);

error:

    delete pNamespace;
    RRETURN(hr);
}


CIISNamespace::~CIISNamespace( )
{
    VariantClear(&_vFilter);
    delete _pDispMgr;
}

STDMETHODIMP
CIISNamespace::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *)this;
    }else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *)this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsOpenDSObject))
    {
        *ppv = (IADsOpenDSObject FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


STDMETHODIMP
CIISNamespace::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CIISNamespace::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                TRUE
                );
    RRETURN(hr);

}

STDMETHODIMP
CIISNamespace::get__NewEnum(THIS_ IUnknown * FAR* retval)
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    //
    // Create new enumerator for items currently
    // in collection and QI for IUnknown
    //

    hr = CIISNamespaceEnum::Create(
                (CIISNamespaceEnum **)&penum,
                _vFilter,
                _Credentials
                );
    if (FAILED(hr)){

        goto error;
    }
    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );

    if (FAILED(hr)){
       goto error;
    }

    if (penum) {
        penum->Release();
    }

    return NOERROR;

error:

    if (penum) {
        delete penum;
    }

    return hr;
}

STDMETHODIMP
CIISNamespace::Create(THIS_ BSTR ClassName, BSTR RelativeName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::Delete(THIS_ BSTR SourceName, BSTR Type)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::CopyHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISNamespace::MoveHere(THIS_ BSTR SourceName, BSTR NewName, IDispatch * FAR* ppObject)
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISNamespace::AllocateNamespaceObject(
    CCredentials& Credentials,
    CIISNamespace ** ppNamespace
    )
{
    CIISNamespace FAR * pNamespace = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pNamespace = new CIISNamespace();
    if (pNamespace == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsOpenDSObject,
                           (IADsOpenDSObject *)pNamespace,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pNamespace,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    pNamespace->_Credentials = Credentials;
    pNamespace->_pDispMgr = pDispMgr;
    *ppNamespace = pNamespace;

    RRETURN(hr);

error:
    if (pDispMgr)
    {
        delete  pDispMgr;
    }

    if (pNamespace)
    {
        delete pNamespace;
    }

    RRETURN(hr);
}




STDMETHODIMP
CIISNamespace::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{

    //
    // retrieve dataobject from cache; if one exists
    //



    //
    //
    //
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISNamespace::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISNamespace::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISNamespace::OpenDSObject(
    BSTR lpszDNName,
    BSTR lpszUserName,
    BSTR lpszPassword,
    LONG lnReserved,
    IDispatch FAR * * ppADsObj
    )
{
    HRESULT hr = S_OK;
    IUnknown * pObject = NULL;
    CCredentials Credentials;

    hr = Credentials.SetUserName(lpszUserName);
    BAIL_ON_FAILURE(hr);

    hr = Credentials.SetPassword(lpszPassword);
    BAIL_ON_FAILURE(hr);

    hr = ::GetObject(
                lpszDNName,
                Credentials,
                (LPVOID *)&pObject
                );
    BAIL_ON_FAILURE(hr);



    hr = pObject->QueryInterface(
                        IID_IDispatch,
                        (void **)ppADsObj
                        );
    BAIL_ON_FAILURE(hr);


error:

    if (pObject) {
        pObject->Release();
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cmime.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmime.cxx
//
//  Contents:  MimeType object
//
//  History:   04-1-97     krishnag    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

//  Class CMimeType

DEFINE_Simple_IDispatch_Implementation(CMimeType)

CMimeType::CMimeType():
        _pDispMgr(NULL),
        _lpMimeType(NULL),
        _lpExtension(NULL)
{
    ENLIST_TRACKING(CMimeType);
}

HRESULT
CMimeType::CreateMimeType(
    REFIID riid,
    void **ppvObj
    )
{
    CMimeType FAR * pMimeType = NULL;
    HRESULT hr = S_OK;

    hr = AllocateMimeTypeObject(&pMimeType);
    BAIL_ON_FAILURE(hr);

    hr = pMimeType->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pMimeType->Release();

    RRETURN(hr);

error:
    delete pMimeType;

    RRETURN(hr);

}


CMimeType::~CMimeType( )
{
    if (_lpMimeType) {
        FreeADsStr(_lpMimeType);
    }

    if (_lpExtension) {
        FreeADsStr(_lpExtension);
    }

    delete _pDispMgr;
}

STDMETHODIMP
CMimeType::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISMimeType))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISMimeType FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CMimeType::InitFromIISString(
    LPWSTR pszStr
    )
{
    LPWSTR pszToken = NULL;
    DWORD dwLen = 0;

    if (!pszStr) {
        return S_FALSE;
    }

    //
    // get length of pszStr; do not count ',' ; + 1 for null pointer and -1
    // for ','  so dwLen is = wcslen
    //

    dwLen = (DWORD)wcslen(pszStr);

    //
    // first token is extension
    //

    pszToken = wcstok(pszStr, L",");
    if (pszToken) {
        _lpExtension = AllocADsStr(pszToken);

        //
        // second token is mimetype
        //

        if (wcslen(pszStr) + 1 < dwLen) {
            pszToken = pszStr + wcslen(pszStr) + 1;
           _lpMimeType = AllocADsStr(pszToken);
        }
    }


    return S_OK;
}

HRESULT
CMimeType::CopyMimeType(
    LPWSTR *ppszMimeType
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszMimeType = NULL;
    DWORD dwLen = 0;

    if (!ppszMimeType) {
        return S_FALSE;
    }

    if (_lpExtension) {
        dwLen = (DWORD)wcslen(_lpExtension);
    }

    if (_lpMimeType) {
        dwLen += (DWORD)wcslen(_lpMimeType);
    }

    //
    // dwLen +2 to include comma and null terminator
    //

    pszMimeType = (LPWSTR)AllocADsMem((dwLen+2) * sizeof(WCHAR));

    if (!pszMimeType) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    //
    // empty contents
    //

    wcscpy(pszMimeType, L"");

    if (_lpExtension) {
        wcscpy(pszMimeType, _lpExtension);
    }

    wcscat(pszMimeType, L",");

    if (_lpMimeType) {
        wcscat(pszMimeType, _lpMimeType);
    }

    pszMimeType[wcslen(pszMimeType)] = L'\0';

    *ppszMimeType = pszMimeType;

error:

    RRETURN(hr);
}



HRESULT
CMimeType::AllocateMimeTypeObject(
    CMimeType ** ppMimeType
    )
{
    CMimeType FAR * pMimeType = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pMimeType = new CMimeType();
    if (pMimeType == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    if (FAILED(hr))
    {
        delete pMimeType;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISMimeType,
                (IISMimeType *)pMimeType,
                DISPID_REGULAR
                );
    if (FAILED(hr))
    {
        delete pMimeType;
    }
    BAIL_ON_FAILURE(hr);

    pMimeType->_pDispMgr = pDispMgr;
    *ppMimeType = pMimeType;

    RRETURN(hr);

error:

    delete  pDispMgr;

    RRETURN(hr);

}

STDMETHODIMP
CMimeType::get_MimeType(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpMimeType, retval);
    RRETURN(hr);
}

STDMETHODIMP
CMimeType::put_MimeType(THIS_ BSTR bstrMimeType)
{
    if (!bstrMimeType) {
        RRETURN(E_FAIL);
    }
    if (_lpMimeType) {
        FreeADsStr(_lpMimeType);
    }
    _lpMimeType = AllocADsStr(bstrMimeType);
    if (!_lpMimeType) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}

STDMETHODIMP
CMimeType::get_Extension(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString(_lpExtension, retval);
    RRETURN(hr);
}

STDMETHODIMP
CMimeType::put_Extension(THIS_ BSTR bstrExtension)
{
    if (!bstrExtension) {
        RRETURN(E_FAIL);
    }
    if (_lpExtension) {
        FreeADsStr(_lpExtension);
    }
    _lpExtension = AllocADsStr(bstrExtension);
    if (!_lpExtension) {
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\common.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  common.cxx
//
//  Contents:  Microsoft ADs IIS Common routines 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

extern SERVER_CACHE * g_pServerCache;
extern WIN32_CRITSEC * g_pGlobalLock;

#pragma hdrstop

FILTERS Filters[] = {
                    {L"user", IIS_USER_ID},
                    {L"group", IIS_GROUP_ID},
                    {L"queue", IIS_PRINTER_ID},
                    {L"domain", IIS_DOMAIN_ID},
                    {L"computer", IIS_COMPUTER_ID},
                    {L"service", IIS_SERVICE_ID},
                    {L"fileservice", IIS_FILESERVICE_ID},
                    {L"fileshare", IIS_FILESHARE_ID},
                    {L"class", IIS_CLASS_ID},
                    {L"functionalset", IIS_FUNCTIONALSET_ID},
                    {L"syntax", IIS_SYNTAX_ID},
                    {L"property", IIS_PROPERTY_ID},
                    {L"tree", IIS_TREE_ID},
                    {L"Organizational Unit", IIS_OU_ID},
                    {L"Organization", IIS_O_ID},
                    {L"Locality", IIS_LOCALITY_ID}
                  };

#define MAX_FILTERS  (sizeof(Filters)/sizeof(FILTERS))

#define DEFAULT_TIMEOUT_VALUE                    30000

PFILTERS  gpFilters = Filters;
DWORD gdwMaxFilters = MAX_FILTERS;
extern WCHAR * szProviderName;


//+------------------------------------------------------------------------
//
//  Class:      Common
//
//  Purpose:    Contains Winnt routines and properties that are common to
//              all Winnt objects. Winnt objects get the routines and
//              properties through C++ inheritance.
//
//-------------------------------------------------------------------------


HRESULT
BuildADsPath(
    BSTR Parent,
    BSTR Name,
    BSTR *pADsPath
    )
{
    LPWSTR lpADsPath = NULL;
    WCHAR ProviderName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwLen = 0;

    //
    // We will assert if bad parameters are passed to us.
    // This is because this should never be the case. This
    // is an internal call
    //

    ADsAssert(Parent && Name);
    ADsAssert(pADsPath);


    //
    // Special case the Namespace object; if
    // the parent is L"ADs:", then Name = ADsPath
    //

    if (!_wcsicmp(Parent, L"ADs:")) {
        RRETURN(ADsAllocString( Name, pADsPath));
    }

    //
    // Allocate the right side buffer
    // 2 for // + a buffer of MAX_PATH
    //
    dwLen = (DWORD)(wcslen(Parent) + wcslen(Name)) + 2 + MAX_PATH;

    lpADsPath = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));
    if (!lpADsPath) {
        RRETURN(E_OUTOFMEMORY);
    }



    //
    // The rest of the cases we expect valid data,
    // Path, Parent and Name are read-only, the end-user
    // cannot modify this data
    //

    //
    // For the first object, the domain object we do not add
    // the first backslash; so we examine that the parent is
    // L"WinNT:" and skip the slash otherwise we start with
    // the slash
    //

    wsprintf(ProviderName, L"%s:", szProviderName);

    wcscpy(lpADsPath, Parent);

    if (_wcsicmp(lpADsPath, ProviderName)) {
        wcscat(lpADsPath, L"/");
    }else {
        wcscat(lpADsPath, L"//");
    }
    wcscat(lpADsPath, Name);

    hr = ADsAllocString( lpADsPath, pADsPath);


    if (lpADsPath) {
        FreeADsMem(lpADsPath);
    }

    RRETURN(hr);
}

HRESULT
BuildSchemaPath(
    BSTR bstrADsPath,
    BSTR bstrClass,
    BSTR *pSchemaPath
    )
{
    WCHAR ADsSchema[MAX_PATH];
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrADsPath);
    HRESULT hr = S_OK;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    wcscpy(ADsSchema, L"");
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    if (bstrClass && *bstrClass) {
        hr = ADsObject(&Lexer, pObjectInfo);
        BAIL_ON_FAILURE(hr);

        if (pObjectInfo->TreeName) {

            wsprintf(ADsSchema,L"%s://",pObjectInfo->ProviderName);
            wcscat(ADsSchema, pObjectInfo->TreeName);
            wcscat(ADsSchema,L"/schema/");
            wcscat(ADsSchema, bstrClass);

        }
    }

    hr = ADsAllocString( ADsSchema, pSchemaPath);

error:

    if (pObjectInfo) {

        FreeObjectInfo( pObjectInfo );
    }
    RRETURN(hr);
}



HRESULT
BuildADsGuid(
    REFCLSID clsid,
    BSTR *pADsClass
    )
{
    WCHAR ADsClass[MAX_PATH];

    StringFromGUID2(clsid, ADsClass, 256);

    RRETURN(ADsAllocString( ADsClass, pADsClass));
}


HRESULT
ValidateOutParameter(
    BSTR * retval
    )
{
    if (!retval) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    RRETURN(S_OK);
}


HRESULT
OpenAdminBaseKey(
    IN CCredentials& Credentials,
    IN LPWSTR pszServerName,
    IN LPWSTR pszPathName,
    IN DWORD dwAccessType,
    IN OUT IMSAdminBase **ppAdminBase,
    OUT METADATA_HANDLE *phHandle
    )
{
    HRESULT hr;
    IMSAdminBase *pAdminBase = *ppAdminBase;
    METADATA_HANDLE RootHandle = NULL;
    DWORD dwThreadId;

    hr = pAdminBase->OpenKey(
                METADATA_MASTER_ROOT_HANDLE,
                pszPathName,
                dwAccessType,
                DEFAULT_TIMEOUT_VALUE,
                &RootHandle
                );

    if (FAILED(hr)) {
        if ((HRESULT_CODE(hr) == RPC_S_SERVER_UNAVAILABLE) ||
            ((HRESULT_CODE(hr) >= RPC_S_NO_CALL_ACTIVE) &&
             (HRESULT_CODE(hr) <= RPC_S_CALL_FAILED_DNE)) || 
            hr == RPC_E_DISCONNECTED) {

            SERVER_CACHE_ITEM * item = NULL;

            IMSAdminBase * pOldAdminBase = pAdminBase;

            //
            // RPC error, try to recover connection
            //

            hr = InitAdminBase(Credentials, pszServerName, &pAdminBase);
            BAIL_ON_FAILURE(hr);

            *ppAdminBase = pAdminBase; 

            hr = pAdminBase->OpenKey(
                        METADATA_MASTER_ROOT_HANDLE,
                        pszPathName,
                        dwAccessType,
                        DEFAULT_TIMEOUT_VALUE,
                        &RootHandle
                        );

            //
            // update cache item
            //

            dwThreadId = GetCurrentThreadId();
            item = g_pServerCache->Find(pszServerName, dwThreadId);

            ASSERT(item != NULL);

            if (item != NULL)
            {
                UninitAdminBase(pOldAdminBase);
                item->UpdateAdminBase(pAdminBase, dwThreadId);
            }
        }
    }

error :

    if (FAILED(hr)) {

        if (pAdminBase && RootHandle) {
            pAdminBase->CloseKey(RootHandle);
        }
    }
    else {
        *phHandle = RootHandle;
    }

    RRETURN(hr);
}


VOID
CloseAdminBaseKey(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hHandle
    )
{
    HRESULT hr;

    if (pAdminBase) {
        hr = pAdminBase->CloseKey(hHandle);
    }

    return;
}


HRESULT
MetaBaseGetAllData(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD dwMDAttributes,
    IN DWORD dwMDUserType,
    IN DWORD dwMDDataType,
    OUT PDWORD pdwMDNumDataEntries,
    OUT PDWORD pdwMDDataSetNumber,
    OUT LPBYTE * ppBuffer
    )
{

    LPBYTE pBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    DWORD dwReqdBufferSize = 0;

    hr = pAdminBase->GetAllData(
                        hObjHandle,
                        pszIISPathName,
                        dwMDAttributes,
                        dwMDUserType,
                        dwMDDataType,
                        pdwMDNumDataEntries,
                        pdwMDDataSetNumber,
                        dwBufferSize,
                        (LPBYTE)"",
                        &dwReqdBufferSize
                        );


    pBuffer = (LPBYTE) AllocADsMem(dwReqdBufferSize);

    if (!pBuffer) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwBufferSize = dwReqdBufferSize;

    hr = pAdminBase->GetAllData(
                        hObjHandle,
                        pszIISPathName,
                        dwMDAttributes,
                        dwMDUserType,
                        dwMDDataType,
                        pdwMDNumDataEntries,
                        pdwMDDataSetNumber,
                        dwBufferSize,
                        pBuffer,
                        &dwReqdBufferSize
                        );
    BAIL_ON_FAILURE(hr);


    *ppBuffer = pBuffer;


    RRETURN(hr);

error:


    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}



HRESULT
MetaBaseSetAllData(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN PMETADATA_RECORD pMetaDataArray,
    IN DWORD dwNumEntries
    )
{
    HRESULT hr = S_OK;
    PMETADATA_RECORD pTemp = NULL;
    METADATA_RECORD mdrMDData;
    DWORD i;

    //
    // Set each METADATA record one at a time
    //

    for (i = 0; i < dwNumEntries; i++) {

        pTemp = pMetaDataArray + i;

        mdrMDData.dwMDIdentifier = pTemp->dwMDIdentifier;
        mdrMDData.dwMDAttributes = pTemp->dwMDAttributes;
        mdrMDData.dwMDUserType = pTemp->dwMDUserType;
        mdrMDData.dwMDDataType = pTemp->dwMDDataType;
        mdrMDData.dwMDDataLen = pTemp->dwMDDataLen;
        mdrMDData.dwMDDataTag = pTemp->dwMDDataTag;
        mdrMDData.pbMDData = pTemp->pbMDData;

        hr = pAdminBase->SetData(
                hObjHandle,
                pszIISPathName,
                &mdrMDData
                );

        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}

HRESULT
MetaBaseDeleteObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName
    )
{
    HRESULT hr = S_OK;


    hr = pAdminBase->DeleteKey(
             hObjHandle,
             pszIISPathName
             );

    RRETURN(hr);
}


HRESULT
MetaBaseCreateObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName
    )
{
    HRESULT hr = S_OK;


    hr = pAdminBase->AddKey(
             hObjHandle,
             pszIISPathName
             );

    RRETURN(hr);
}

HRESULT
MetaBaseCopyObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hSrcObjHandle,
    IN LPWSTR pszIISSrcPathName,
    IN METADATA_HANDLE hDestObjHandle,
    IN LPWSTR pszIISDestPathName
    )
{
    HRESULT hr = S_OK;

    hr = pAdminBase->CopyKey(
             hSrcObjHandle,
             pszIISSrcPathName,
             hDestObjHandle,
             pszIISDestPathName,
             TRUE,
             TRUE
             );

    RRETURN(hr);
}

HRESULT
MetaBaseMoveObject(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hSrcObjHandle,
    IN LPWSTR pszIISSrcPathName,
    IN METADATA_HANDLE hDestObjHandle,
    IN LPWSTR pszIISDestPathName
    )
{
    HRESULT hr = S_OK;

    hr = pAdminBase->CopyKey(
             hSrcObjHandle,
             pszIISSrcPathName,
             hDestObjHandle,
             pszIISDestPathName,
             FALSE,
             FALSE
             );

    RRETURN(hr);
}

HRESULT
MetaBaseGetAdminACL(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    OUT LPBYTE *ppBuffer
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ADMIN_ACL,    // admin acl
                       METADATA_INHERIT,
                       IIS_MD_UT_FILE,
                       BINARY_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);

    if (!pBuffer) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    MD_SET_DATA_RECORD(&mdrMDData,
                       MD_ADMIN_ACL,    // admin acl
                       METADATA_INHERIT,
                       IIS_MD_UT_FILE,
                       BINARY_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}

HRESULT
MetaBaseDetectKey(
    IN IMSAdminBase *pAdminBase,
    IN LPCWSTR pszIISPathName
    )
{
    HRESULT   hr = S_OK;
    FILETIME  ft;

    hr = pAdminBase->GetLastChangeTime( METADATA_MASTER_ROOT_HANDLE,
                                        pszIISPathName,
                                        &ft,
                                        FALSE 
                                        );
    RRETURN(hr);
}

HRESULT
MetaBaseGetADsClass(
    IN  IMSAdminBase  *pAdminBase,
    IN  LPWSTR        pszIISPathName,
    IN  IIsSchema     *pSchema,
    OUT LPWSTR        pszDataBuffer,
    IN  DWORD         dwBufferLen
    )
/*++

Routine Description:

    Get the ADsClass from the metabase path.

Arguments:

    IN  pAdminBase      : the metabase
    IN  pszIISPathName  : the full metabase path (may be upcased)
    IN  pSchema         : schema against which to validate
    OUT pszDataBuffer   : the class name
    IN  dwBufferLen     : number of characters allocated for class name

Return Value:

--*/
{
    // CODEWORK - There are at least two other places that do essentially
    // the same thing. It should be possible to replace that code with a
    // call to this routine

    HRESULT         hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;
    DWORD           dwReqdBufferLen = 0;

    hr = pAdminBase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                              pszIISPathName,
                              METADATA_PERMISSION_READ,
                              DEFAULT_TIMEOUT_VALUE,
                              &hObjHandle
                              );
    BAIL_ON_FAILURE(hr);
    
    //
    // Find out Class Name
    //
    mdrData.dwMDIdentifier  = MD_KEY_TYPE;
    mdrData.dwMDDataType    = STRING_METADATA;
    mdrData.dwMDUserType    = ALL_METADATA;
    mdrData.dwMDAttributes  = METADATA_INHERIT;
    mdrData.dwMDDataLen     = dwBufferLen * sizeof(WCHAR);
    mdrData.pbMDData        = (PBYTE)pszDataBuffer;

    hr = pAdminBase->GetData(
                hObjHandle,
                L"",
                &mdrData,
                &dwReqdBufferLen
                );

    if (FAILED(hr)) 
    {
        if (hr == MD_ERROR_DATA_NOT_FOUND) 
        {
            //
            // If the key does not have a KeyType we will do our best
            // to guess. This is pretty bogus, but there is existing code
            // that depends on this behavior.
            //
            _wcsupr(pszIISPathName);
            if (wcsstr(pszIISPathName, L"W3SVC") != NULL)
            {
                wcscpy( pszDataBuffer, WEBDIR_CLASS_W );
            }
            else if (wcsstr(pszIISPathName, L"MSFTPSVC") != NULL)
            {
                wcscpy( pszDataBuffer, FTPVDIR_CLASS_W );
            }
            else 
            {
                wcscpy( pszDataBuffer, DEFAULT_SCHEMA_CLASS_W );
            }
            hr = S_FALSE;
        }
        else 
        {
            BAIL_ON_FAILURE(hr);
        }
    }
    else
    {
        hr = pSchema->ValidateClassName( pszDataBuffer );
        if (hr == E_ADS_UNKNOWN_OBJECT) 
        {
            wcscpy( pszDataBuffer, DEFAULT_SCHEMA_CLASS_W );
        }
    }

error:
    //
    // Close the handle now
    //
    if (hObjHandle) 
    {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
        hObjHandle = NULL;
    }

    RRETURN(hr);
}

static HRESULT 
GetSchema(
    CCredentials& Credentials,
    LPWSTR machineNameW, 
    IIsSchema **out
    ) 
/*++

Routine Description:

    Creates and initializes a new IIsSchema object.

Arguments:

Return Value:

Notes:
    
    This routine should only be used internally. If it is necessary
    to get a reference to the schema for the current machine, use
    InitServerInfo().

--*/
{
    IIsSchema *schema=NULL;
    HRESULT hr = S_OK;
    schema = new IIsSchema();

    if (schema) {
        hr = schema->InitSchema(machineNameW, Credentials);
        if (FAILED(hr)) {
                delete schema;
                schema = 0;
                *out = 0;
                return hr;
        }
    }
    else {
        return E_OUTOFMEMORY;
    }
    *out = schema;
    return hr;
}



HRESULT
FreeMetaDataRecordArray(
    PMETADATA_RECORD pMetaDataArray,
    DWORD dwNumEntries
    )
{

    DWORD i;
    DWORD dwIISType; 
    PMETADATA_RECORD pMetaData;

    for (i = 0; i < dwNumEntries; i++ ) {
       pMetaData = pMetaDataArray + i;
       dwIISType = pMetaData->dwMDDataType;
    
       switch(dwIISType) {
       case DWORD_METADATA:
           break;

       case STRING_METADATA:
       case EXPANDSZ_METADATA:
           FreeADsStr((LPWSTR)pMetaData->pbMDData);
           break;

       case MULTISZ_METADATA:
       case BINARY_METADATA:
           FreeADsMem(pMetaData->pbMDData);
           break;

       default:
           break;
       }
    }

    FreeADsMem(pMetaDataArray);

    RRETURN(S_OK);
}

HRESULT
InitAdminBase(
    IN CCredentials& Credentials,
    IN LPWSTR pszServerName,
    OUT IMSAdminBase **ppAdminBase
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    
    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr))
    {
        return hr;
    }
    
    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr))
    {
        return hr;
    }

    CComAuthInfo localAuthInfo(pszServerName,
                               pszUserName,
                               pszPassword);

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    pcsiParam = localAuthInfo.CreateServerInfoStruct();

    hr = CoGetClassObject(
                CLSID_MSAdminBase,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = localAuthInfo.ApplyProxyBlanket(pcsfFactory);

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IMSAdminBase,
                (void **) &pAdminBaseT
                );
    BAIL_ON_FAILURE(hr);

    hr = localAuthInfo.ApplyProxyBlanket(pAdminBaseT);

    BAIL_ON_FAILURE(hr);

	hr = pAdminBaseT->UnmarshalInterface((IMSAdminBaseW **)&pAdminBase);
    pAdminBaseT->Release();
    pAdminBaseT = NULL;
	BAIL_ON_FAILURE(hr);

    hr = localAuthInfo.ApplyProxyBlanket(pAdminBase);

    BAIL_ON_FAILURE(hr);

    *ppAdminBase = pAdminBase;

    localAuthInfo.FreeServerInfoStruct(pcsiParam);

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

VOID
UninitAdminBase(
    IN IMSAdminBase * pAdminBase
    )
{
    if (pAdminBase != NULL) {
        pAdminBase->Release();
    }
}

HRESULT
InitServerInfo(
    IN CCredentials& Credentials,
    IN LPWSTR pszServerName,
    OUT IMSAdminBase ** ppObject,
    OUT IIsSchema **ppSchema
    )
{
    HRESULT hr = S_OK;
    IMSAdminBase * pAdminBase = NULL;
    IIsSchema * pSchema = NULL;
    SERVER_CACHE_ITEM * item;
    BOOL Success;
    DWORD dwThreadId;

    ASSERT(g_pServerCache != NULL);

    //
    // We'll return the localhost machine config to the users if 
    // pszServerName == NULL, e.g. IIS:
    //

    if (pszServerName == NULL) {
        pszServerName = L"Localhost";
    }

    dwThreadId = GetCurrentThreadId();

    if ((item = g_pServerCache->Find(pszServerName, dwThreadId)) == NULL) {

        //
        // get pAdminBase and pSchema
        //

        hr = InitAdminBase(Credentials, pszServerName, &pAdminBase);
        BAIL_ON_FAILURE(hr);

        hr = GetSchema(Credentials, pszServerName, &pSchema);

        if( ERROR_PATH_NOT_FOUND == HRESULT_CODE(hr) ||
            MD_ERROR_DATA_NOT_FOUND == hr
            )
        {
            // Return custom error.
            hr = MD_ERROR_IISAO_INVALID_SCHEMA;
        }
        BAIL_ON_FAILURE(hr);

        item = new SERVER_CACHE_ITEM(pszServerName,
                                     pAdminBase,
                                     pSchema,
                                     dwThreadId,
                                     Success);

        if (item == NULL || !Success) {
            if (item != NULL) {
                delete pSchema;
                UninitAdminBase(pAdminBase);
                delete item;
            }
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }

        if (g_pServerCache->Insert(item) == FALSE) {
            delete pSchema;
            UninitAdminBase(pAdminBase);
            delete item;
            RRETURN(E_OUTOFMEMORY); // OUT_OF_MEMORY;
        }
    }

    *ppSchema = item->pSchema;
    *ppObject = item->pAdminBase;

error :

    RRETURN(hr);

}

HRESULT
MetaBaseGetDataPaths(
    IN IMSAdminBase *pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN DWORD dwMDMetaID,
    OUT LPBYTE * ppBuffer
    )
{

    LPBYTE pBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    DWORD dwReqdBufferSize = 0;

    hr = pAdminBase->GetDataPaths(
                        hObjHandle,
                        (LPWSTR)L"",
                        dwMDMetaID,
                        ALL_METADATA,
                        dwBufferSize,
                        (LPWSTR)L"",
                        &dwReqdBufferSize
                        );


    pBuffer = (LPBYTE) AllocADsMem(dwReqdBufferSize*sizeof(WCHAR));

    if (!pBuffer) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwBufferSize = dwReqdBufferSize;

    hr = pAdminBase->GetDataPaths(
                        hObjHandle,
                        (LPWSTR)L"",
                        dwMDMetaID,
                        ALL_METADATA,
                        dwBufferSize,
                        (LPWSTR)pBuffer,
                        &dwReqdBufferSize
                        );
    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}


HRESULT
MakeVariantFromStringArray(
    LPWSTR pszStr,
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;
    WCHAR wchPath[MAX_PATH];


    if  (pszList != NULL)
    {
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;

        if (*pszStrList == L'\0') {
            nCount = 1;
            pszStrList++;
        }

        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszStrList = pszList;
        for (i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (pszStr) {
                wcscpy((LPWSTR)wchPath, pszStr);
                wcscat((LPWSTR)wchPath, pszStrList);
                hr = ADsAllocString((LPWSTR)wchPath, &(V_BSTR(&v)));
            }
            else {
                hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));
            }

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    return S_OK;

error:

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
MakeVariantFromPathArray(
    LPWSTR pszStr,
    LPWSTR pszList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    LPWSTR pszStrList;

    LPWSTR pszConcatBuffer = NULL;
    DWORD  cbConcatBuffer = 0;
    DWORD  cbRequiredConcatBuffer = 0;
    DWORD  nStrLen = 0;
    DWORD  nPathStrLen = 0;

    if  (pszList != NULL)
    {
        //
        // Count strings in pszList
        //
        long nCount = 0;
        long i = 0;
        pszStrList = pszList;
        while (*pszStrList != L'\0') {
            while (*pszStrList != L'\0') {
                pszStrList++;
            }
            nCount++;
            pszStrList++;
        }

        //
        // Allocate output array
        //
        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        //
        // Prepare to copy our values from pszList to aList
        //
        if( pszStr )
        {
            nStrLen = (DWORD)wcslen( pszStr );
        }

        pszStrList = pszList;
        while ( *pszStrList != L'\0' )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            if (pszStr) 
            {
                //
                // Reallocate our string buffer. Since the strings are 
                // generally increasing in size, we'll allocate more space 
                // than we need so we don't have to reallocate every time.
                //
                nPathStrLen = (DWORD)wcslen(pszStrList);
                cbRequiredConcatBuffer = ( nStrLen + nPathStrLen + 1 )
                                         * sizeof(WCHAR);
                if( cbRequiredConcatBuffer > cbConcatBuffer )
                {
                    pszConcatBuffer = (LPWSTR)ReallocADsMem( 
                                           pszConcatBuffer,
                                           cbConcatBuffer,
                                           2 * cbRequiredConcatBuffer 
                                           );
                    if( pszConcatBuffer == NULL )
                    {
                        hr = E_OUTOFMEMORY;
                        BAIL_ON_FAILURE(hr);
                    }
                    if( cbConcatBuffer == 0 )
                    {
                        // This is our first time through.
                        wcscpy(pszConcatBuffer, pszStr);
                    }
                    cbConcatBuffer = 2 * cbRequiredConcatBuffer;
                }

                //
                // Copy the returned value into the buffer.
                //
                wcscpy(pszConcatBuffer + nStrLen, pszStrList);
               
                if (pszConcatBuffer[nStrLen + nPathStrLen - 1] == L'/') 
                {
                    pszConcatBuffer[nStrLen + nPathStrLen - 1] = L'\0';
                }

                hr = ADsAllocString(pszConcatBuffer, &(V_BSTR(&v)));
            }
            else {
                hr = ADsAllocString( pszStrList, &(V_BSTR(&v)));
            }

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszStrList += wcslen(pszStrList) + 1;
            i++;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    if( pszConcatBuffer )
    {
        FreeADsMem( pszConcatBuffer );
    }

    return S_OK;

error:

    if( pszConcatBuffer )
    {
        FreeADsMem( pszConcatBuffer );
    }

    if ( aList )
        SafeArrayDestroy( aList );

    return hr;
}

HRESULT
InitWamAdmin(
    IN LPWSTR pszServerName,
    OUT IWamAdmin2 **ppWamAdmin
    )
{
    HRESULT hr = S_OK;

    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IWamAdmin2 * pWamAdmin = NULL;

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    //
    // special case to handle "localhost" to work-around ole32 bug
    //

    if (pszServerName == NULL || _wcsicmp(pszServerName,L"localhost") == 0) {
        pcsiParam->pwszName =  NULL;
    }
    else {
        pcsiParam->pwszName =  pszServerName;
    }

    csiName.pAuthInfo = NULL;
    pcsiParam = &csiName;

    hr = CoGetClassObject(
                CLSID_WamAdmin,
                CLSCTX_SERVER,
                pcsiParam,
                IID_IClassFactory,
                (void**) &pcsfFactory
                );

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
                NULL,
                IID_IWamAdmin2,
                (void **) &pWamAdmin
                );
    BAIL_ON_FAILURE(hr);

    *ppWamAdmin = pWamAdmin;

error:

    if (pcsfFactory) {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}


VOID
UninitWamAdmin(
    IN IWamAdmin2 *pWamAdmin
    )
{
    if (pWamAdmin != NULL) {
        pWamAdmin->Release();
    }
}


HRESULT
ConvertDispatchToVariantArray(
    VARIANT varDispatch,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    VARIANT vVar;
    WCHAR* wComma = NULL;
    WCHAR* wHolder = NULL;
    DWORD  dwNumVariants = 0;
    VARIANT * pVarArray = NULL;

    VariantInit(&vVar);

    hr = VariantCopyInd(&vVar, &varDispatch);
    BAIL_ON_FAILURE(hr);
    
    // Output here is VT_BSTR, of format: "str_1,str_2,str_3, ... str_n\0"
    hr = VariantChangeType( &vVar, &vVar, 0, VT_BSTR );    
    BAIL_ON_FAILURE(hr);
    
    // count the number of comma separated entries
    wHolder = wComma = vVar.bstrVal;
    while (wComma) {
        wComma = wcsstr(wHolder, L",");
        dwNumVariants++;
        if (wComma) {
            wComma++;
            wHolder = wComma;
        }
    }
    
    if (!dwNumVariants)
    {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    pVarArray = (PVARIANT)AllocADsMem(
                                sizeof(VARIANT)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    DWORD i = 0;

    wHolder = wComma = vVar.bstrVal;
    while (wHolder) {

        wComma = wcsstr(wHolder, L",");
        if (wComma) {
            *wComma = 0;  // change the comma to null char
            wComma++;
        }
        
        if (*wHolder) {
            // use wHolder here
            VariantInit(pVarArray + i);
            V_VT(pVarArray + i) = VT_BSTR;
            hr = ADsAllocString(wHolder, &(V_BSTR(pVarArray + i)));
            BAIL_ON_FAILURE(hr);

            i++;
        }
        else {
            dwNumVariants--;
        }

        wHolder = wComma;
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    VariantClear(&vVar);

    RRETURN(hr);
    
}

HRESULT
ConvertArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    if(!(V_ISARRAY(&varSafeArray)))
       RRETURN(E_FAIL);

    //
    // This handles by-ref and regular SafeArrays.
    //

    if (V_VT(&varSafeArray) & VT_BYREF)
        pArray = *(V_ARRAYREF(&varSafeArray));
    else
        pArray = V_ARRAY(&varSafeArray);


    //
    // Check that there is only one dimension in this array
    //
    if (pArray && pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (!pArray ||  
        ( pArray->rgsabound[0].cElements == 0) ) {

        dwNumVariants = 1;

        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit(pVarArray);
        pVarArray->vt = VT_BSTR;
        pVarArray->bstrVal = NULL;
       
    } 
    else {  

        //
        // We know that this is a valid single dimension array
        //

        hr = SafeArrayGetLBound(pArray,
                                1,
                                (long FAR *)&dwSLBound
                                );
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayGetUBound(pArray,
                                1,
                                (long FAR *)&dwSUBound
                                );
        BAIL_ON_FAILURE(hr);

        dwNumVariants = dwSUBound - dwSLBound + 1;
        pVarArray = (PVARIANT)AllocADsMem(
                                    sizeof(VARIANT)*dwNumVariants
                                    );
        if (!pVarArray) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        for (i = dwSLBound; i <= dwSUBound; i++) {
    
            VariantInit(pVarArray + i);
            hr = SafeArrayGetElement(pArray,
                                    (long FAR *)&i,
                                    (pVarArray + i)
                                    );
            CONTINUE_ON_FAILURE(hr);
        }
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}


//
// Property helper functions
//
//

#define VALIDATE_PTR(pPtr) \
    if (!pPtr) { \
        hr = E_ADS_BAD_PARAMETER;\
    }\
    BAIL_ON_FAILURE(hr);


HRESULT
put_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR   pSrcStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackStringinVariant(
            pSrcStringProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_BSTR_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    BSTR *ppDestStringProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( ppDestStringProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackStringfromVariant(
            varOutputData,
            ppDestStringProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_LONG_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    LONG   lSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackLONGinVariant(
            lSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_LONG_Property(
    IADs * pADsObject,
    BSTR  bstrPropertyName,
    PLONG plDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( plDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackLONGfromVariant(
            varOutputData,
            plDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);

}

HRESULT
put_DATE_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    DATE   daSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackDATEinVariant(
            daSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}


HRESULT
put_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    VARIANT_BOOL   fSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANT_BOOLinVariant(
            fSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_BOOL_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT_BOOL pfDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pfDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANT_BOOLfromVariant(
            varOutputData,
            pfDestProperty
            );
    BAIL_ON_FAILURE(hr);


error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
put_VARIANT_Property(
    IADs * pADsObject,
    BSTR   bstrPropertyName,
    VARIANT   vSrcProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varInputData;

    hr = PackVARIANTinVariant(
            vSrcProperty,
            &varInputData
            );
    BAIL_ON_FAILURE(hr);


    hr = pADsObject->Put(
            bstrPropertyName,
            varInputData
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varInputData );
    RRETURN(hr);
}

HRESULT
get_VARIANT_Property(
    IADs * pADsObject,
    BSTR bstrPropertyName,
    PVARIANT pvDestProperty
    )
{
    HRESULT hr = S_OK;
    VARIANT varOutputData;

    VALIDATE_PTR( pvDestProperty );

    VariantInit( &varOutputData );

    hr = pADsObject->Get(
            bstrPropertyName,
            &varOutputData
            );
    BAIL_ON_FAILURE(hr);

    hr = UnpackVARIANTfromVariant(
            varOutputData,
            pvDestProperty
            );
    BAIL_ON_FAILURE(hr);

error:

    VariantClear( &varOutputData );
    RRETURN(hr);
}

HRESULT
MetaBaseGetStringData(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD  dwMetaId,
    OUT LPBYTE *ppBuffer
    )
{
    HRESULT hr = S_OK;
    DWORD dwBufferSize = 0;
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = NULL;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       ALL_METADATA,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    pBuffer = (LPBYTE) AllocADsMem(dwBufferSize);

    if (!pBuffer) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       ALL_METADATA,
                       STRING_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    BAIL_ON_FAILURE(hr);

    *ppBuffer = pBuffer;

    RRETURN(hr);

error:

    if (pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}

HRESULT
MetaBaseGetDwordData(
    IN IMSAdminBase * pAdminBase,
    IN METADATA_HANDLE hObjHandle,
    IN LPWSTR pszIISPathName,
    IN DWORD  dwMetaId,
    OUT PDWORD pdwData
    )
{

    HRESULT hr = S_OK;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    LPBYTE pBuffer = (LPBYTE)pdwData;

    MD_SET_DATA_RECORD(&mdrMDData,
                       dwMetaId, 
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       DWORD_METADATA,
                       dwBufferSize,
                       pBuffer);

    hr = pAdminBase->GetData(
             hObjHandle,
             pszIISPathName,
             &mdrMDData,
             &dwBufferSize
             );

    RRETURN(hr);
}


HRESULT
MakeStringFromVariantArray(
    VARIANT *pvVariant,
    LPBYTE* ppBuffer 
    )
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwLen = 0;
    VARIANT *pVar;
    LPBYTE pBuffer = NULL;
    DWORD dwNumVars = 0;
    VARIANT * pVarArray = NULL;

    pVar = pvVariant;

    if (pVar->vt == VT_EMPTY) {
        RRETURN(S_OK);
    }

    hr  = ConvertArrayToVariantArray(
                *pVar,
                &pVarArray,
                &dwNumVars
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumVars == 0) {
        RRETURN(S_OK);
    }

    //
    // find out total length 
    //
         
    pVar = pVarArray;
    for (i = 0; i < dwNumVars; i++ ) {
         //
         // add 1 for comma
         //

         if (pVar->vt == VT_BSTR || pVar->vt == VT_EMPTY) {
             if (pVar->bstrVal && *(pVar->bstrVal)) {

                 //
                 // validate parameter; check for ','
                 //

                 if (wcschr(pVar->bstrVal, L',')) { 
                     hr = E_ADS_BAD_PARAMETER; 
                     BAIL_ON_FAILURE(hr);
                 }
                 dwLen += ((DWORD)wcslen(pVar->bstrVal) + 1);
             }
         }
         else {
             hr = E_ADS_CANT_CONVERT_DATATYPE;
             BAIL_ON_FAILURE(hr);
         }
         pVar++;
    }

    //
    // if there are non-empty entries found in the array, copy them to buffer
    //

    if (dwLen != 0) {
        pBuffer = (LPBYTE) AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppBuffer = pBuffer;

        pVar = pVarArray;

        for (i = 0; i < dwNumVars; i++, pVar++ ) {
             
             if (pVar->bstrVal && *(pVar->bstrVal)) {
    
                 memcpy(pBuffer, pVar->bstrVal, 
                        wcslen(pVar->bstrVal)*sizeof(WCHAR));
                 pBuffer = pBuffer + wcslen(pVar->bstrVal)*sizeof(WCHAR);
    
                 if (i != dwNumVars -1) {
                    memcpy(pBuffer, L",", sizeof(WCHAR));
                    pBuffer = pBuffer + sizeof(WCHAR);
                 }
             }
        }

        if (*ppBuffer == pBuffer - dwLen*sizeof(WCHAR)) {
            pBuffer -= sizeof(WCHAR);
            *pBuffer = L'\0';
        }
        else {
            *pBuffer = L'\0';
        }
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumVars; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    if (FAILED(hr) && pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}


HRESULT
CheckVariantDataType(
    PVARIANT pVar,
    VARTYPE vt
    )
{
    HRESULT hr;

    hr = VariantChangeType(pVar,
                           pVar,
                           0,
                           vt);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    RRETURN(hr);
}

HRESULT
MakeMultiStringFromVariantArray(
    VARIANT *pvVariant,
    LPBYTE* ppBuffer 
    )
{
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwLen = 0;
    VARIANT *pVar;
    LPBYTE pBuffer = NULL;
    DWORD dwNumVars = 0;
    VARIANT * pVarArray = NULL;

    pVar = pvVariant;

    if (pVar->vt == VT_EMPTY) {
        RRETURN(S_OK);
    }

    hr  = ConvertArrayToVariantArray(
                *pVar,
                &pVarArray,
                &dwNumVars
                );
    BAIL_ON_FAILURE(hr);

    if (dwNumVars == 0) {
        RRETURN(S_OK);
    }

    //
    // find out total length 
    //
         
    pVar = pVarArray;
    for (i = 0; i < dwNumVars; i++ ) {
         if (pVar->vt == VT_BSTR) {
             if (pVar->bstrVal && *(pVar->bstrVal)) {
                 dwLen += ((DWORD)wcslen(pVar->bstrVal) + 1);
             }
             else {

                 //
                 // add 1 for \0
                 //

                 dwLen++;
             }
         }
         else {
             hr = E_ADS_CANT_CONVERT_DATATYPE;
             BAIL_ON_FAILURE(hr);
         }
         pVar++;
    }

    //
    // +1 for extra \0
    //

    dwLen++;

    //
    // copy entries to buffer
    //

    if (dwLen != 0) {
        pBuffer = (LPBYTE) AllocADsMem(dwLen*sizeof(WCHAR));

        if (!pBuffer) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *ppBuffer = pBuffer;

        pVar = pVarArray;

        for (i = 0; i < dwNumVars; i++, pVar++ ) {
             
             if (pVar->bstrVal && *(pVar->bstrVal)) {
    
                 memcpy(pBuffer, pVar->bstrVal, 
                        wcslen(pVar->bstrVal)*sizeof(WCHAR));
                 pBuffer = pBuffer + wcslen(pVar->bstrVal)*sizeof(WCHAR);
             }
             memcpy(pBuffer, L"\0", sizeof(WCHAR));
             pBuffer = pBuffer + sizeof(WCHAR);
        }

        *pBuffer = L'\0';
    }

error:

    if (pVarArray) {

        for (i = 0; i < dwNumVars; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    if (FAILED(hr) && pBuffer) {

        FreeADsMem(pBuffer);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cprov.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cprov.cxx
//
//  Contents:  Provider Object Code
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISProvider

CIISProvider::CIISProvider()
{

}

HRESULT
CIISProvider::Create(CIISProvider FAR * FAR * ppProvider)
{
    CIISProvider FAR * pProvider = NULL;
    HRESULT hr = S_OK;

    //Create the Provider Object

    pProvider = new CIISProvider();
    if (pProvider == NULL) {
        RRETURN(ResultFromScode(E_OUTOFMEMORY));
    }

    if (FAILED(hr)) {
        delete pProvider;
        RRETURN(hr);
    }


    *ppProvider = pProvider;
    RRETURN(hr);
}

CIISProvider::~CIISProvider( )
{
    ENLIST_TRACKING(CIISProvider);
}

STDMETHODIMP
CIISProvider::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = this;
    }
    else if (IsEqualIID(iid, IID_IParseDisplayName))
    {
        *ppv = (IParseDisplayName FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CIISProvider::ParseDisplayName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;

    *ppmk = NULL;

    if (pchEaten != NULL){
        *pchEaten = 0;
    }

    hr = ResolvePathName(
                pbc,
                szDisplayName,
                pchEaten,
                ppmk
                );

    RRETURN(hr);
}

HRESULT
CIISProvider::ResolvePathName(
    IBindCtx* pbc,
    WCHAR* szDisplayName,
    ULONG* pchEaten,
    IMoniker** ppmk
    )
{
    HRESULT hr;
    LPUNKNOWN pUnknown = NULL;
    CCredentials Credentials;

    *pchEaten = 0;
    hr = GetObject(
            szDisplayName,
            Credentials,
            (LPVOID *)&pUnknown
            );
    BAIL_IF_ERROR(hr);

    hr = CreatePointerMoniker(pUnknown, ppmk);
    BAIL_IF_ERROR(hr);

    *pchEaten += (ULONG)wcslen(szDisplayName);

cleanup:

    if (pUnknown) {
        pUnknown->Release();
    }

    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cprops.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       cprops.cxx
//
//  Contents:   Property Cache functionality for IIS
//
//  Functions:
//                CPropertyCache::addproperty
//                CPropertyCache::updateproperty
//                CPropertyCache::findproperty
//                CPropertyCache::getproperty
//                CPropertyCache::putproperty
//                CProperyCache::CPropertyCache
//                CPropertyCache::~CPropertyCache
//                CPropertyCache::createpropertycache
//
//  History:      17-June-1997   sophiac Created.
//                cloned off NT property cache code
//
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma  hdrstop

#if DBG
DECLARE_INFOLEVEL(IISMarshall);
DECLARE_DEBUG(IISMarshall);
#define IISMarshallDebugOut(x) IISMarshallInlineDebugOut x
#endif



//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::addproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vt]                --
//              [vaData]            --
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
addproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject
    )
{
    HRESULT hr = S_OK;
    PPROPERTY pNewProperty = NULL;

    //
    //  extend the property cache by adding a new property entry
    //

    PPROPERTY pOrigProperties = _pProperties;

    _pProperties = (PPROPERTY)ReallocADsMem(
                                _pProperties,
                                _cb,
                                _cb + sizeof(PROPERTY)
                                );
    if (!_pProperties) {
        _pProperties = pOrigProperties;
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }


    pNewProperty = (PPROPERTY)((LPBYTE)_pProperties + _cb);

    wcscpy(pNewProperty->szPropertyName, szPropertyName);

    //
    // Update the index
    //

    _dwMaxProperties++;
    _cb += sizeof(PROPERTY);

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::updateproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --
//              [vaData]    --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::updateproperty(
    LPWSTR szPropertyName,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject,
    BOOL fExplicit
    )
{
    HRESULT hr;
    DWORD dwIndex;
    DWORD dwMetaId;
    PIISOBJECT pIISTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (!fExplicit) {
        if ((PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_MODIFIED) ||
            (PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED))    {
            hr = S_OK;
            goto error;
        }
    }

    //
    //   Factor in cases where object state is necessary to
    //   decide on update.
    //

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        IISTypeFreeIISObjects(
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_IISOBJECT(pThisProperty) = NULL;
    }

    PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;
    PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;
    _pSchema->ConvertPropName_To_ID(szPropertyName, &dwMetaId);

    PROPERTY_METAID(pThisProperty) = dwMetaId;

    hr = IISTypeCopyConstruct(
            pIISObject,
            dwNumValues,
            &pIISTempObject
            );
    BAIL_ON_FAILURE(hr);

    PROPERTY_IISOBJECT(pThisProperty) = pIISTempObject;

    PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_INITIALIZED;

error:

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::findproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName] --
//              [pdwIndex]       --
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::findproperty(
    LPWSTR szPropertyName,
    PDWORD pdwIndex
    )

{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    for (i = 0; i < _dwMaxProperties; i++) {

        pThisProperty = _pProperties + i;

        ASSERT(pThisProperty);

        if (!_wcsicmp(pThisProperty->szPropertyName, szPropertyName)) {
            *pdwIndex = i;
            RRETURN(S_OK);
        }
    }
    *pdwIndex = 0;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::getproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Property to retrieve from the cache
//              [pvaData]           --  Data returned in a variant
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::
getproperty(
    LPWSTR szPropertyName,
    PDWORD  pdwSyntaxId,
    PDWORD  pdwNumValues,
    PIISOBJECT * ppIISObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    PPROPERTY pThisProperty = NULL;
    DWORD dwInfoLevel = 0;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {

        //
        // Now call the GetInfo function
        //

        if (!_bPropsLoaded) {
            hr = _pCoreADsObject->GetInfo(FALSE);
            if (FAILED(hr) && hr != E_ADS_OBJECT_UNBOUND) {
                BAIL_ON_FAILURE(hr);
            }

            hr = findproperty(
                        szPropertyName,
                        &dwIndex
                        );
        }
    }
    if (hr == E_ADS_PROPERTY_NOT_FOUND) {
        LPBYTE propvalue;
        DWORD dwSyntax;
        DWORD dwNumValues;

        hr = _pSchema->GetDefaultProperty(szPropertyName, &dwNumValues,
                                          &dwSyntax, &propvalue);
        BAIL_ON_FAILURE(hr);
        hr = unmarshallproperty(
                    szPropertyName,
                    propvalue,
                    dwNumValues,
                    dwSyntax,
                    0
                    );
        BAIL_ON_FAILURE(hr);
        hr = findproperty (szPropertyName,
                           &dwIndex
                           );

    }
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        *pdwSyntaxId = (DWORD)PROPERTY_SYNTAX(pThisProperty);
        *pdwNumValues = (DWORD)PROPERTY_NUMVALUES(pThisProperty);

        hr = IISTypeCopyConstruct(PROPERTY_IISOBJECT(pThisProperty),
                                 PROPERTY_NUMVALUES(pThisProperty),
                                 ppIISObject );
        BAIL_ON_FAILURE(hr);
    }else {

        *ppIISObject = NULL;
        *pdwNumValues = 0;
        *pdwSyntaxId = 0;
        hr = E_ADS_PROPERTY_NOT_SET;
    }

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache::putproperty
//
//  Synopsis:
//
//
//
//  Arguments:  [szPropertyName]    --  Clsid index
//              [vaData]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::putproperty(
    LPWSTR szPropertyName,
    DWORD  dwFlags,
    DWORD  dwSyntaxId,
    DWORD  dwNumValues,
    PIISOBJECT pIISObject
    )
{
    HRESULT hr;
    DWORD dwIndex = 0L;
    DWORD dwMetaId = 0;
    PIISOBJECT pIISTempObject = NULL;
    PPROPERTY pThisProperty = NULL;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    hr = findproperty(
            szPropertyName,
            &dwIndex
            );
    BAIL_ON_FAILURE(hr);

    pThisProperty = _pProperties + dwIndex;

    if (PROPERTY_IISOBJECT(pThisProperty)) {

        IISTypeFreeIISObjects(
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty)
                );
        PROPERTY_IISOBJECT(pThisProperty) = NULL;
    }

    _pSchema->ConvertPropName_To_ID(szPropertyName, &dwMetaId);

    switch (dwFlags) {

    case CACHE_PROPERTY_MODIFIED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = dwNumValues;

        PROPERTY_METAID(pThisProperty) = dwMetaId;

        hr = IISTypeCopyConstruct(
                pIISObject,
                dwNumValues,
                &pIISTempObject
                );
        BAIL_ON_FAILURE(hr);

        PROPERTY_IISOBJECT(pThisProperty) = pIISTempObject;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_MODIFIED;
        break;

    case CACHE_PROPERTY_CLEARED:

        PROPERTY_SYNTAX(pThisProperty) = dwSyntaxId;

        PROPERTY_NUMVALUES(pThisProperty) = 0;

        PROPERTY_IISOBJECT(pThisProperty) = NULL;

        PROPERTY_FLAGS(pThisProperty) = CACHE_PROPERTY_CLEARED;

        break;

    }

error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::CPropertyCache():
    _pCoreADsObject(NULL),
    _pSchema(NULL),
    _bPropsLoaded(FALSE),
    _dwMaxProperties(0),
    _dwCurrentIndex(0),
    _pProperties(NULL),
    _cb(0),
    _pDispProperties(NULL),
    _dwDispMaxProperties(0),
    _cbDisp(0),
    _bstrServerName(NULL)
{

}

//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
CPropertyCache::
~CPropertyCache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PDISPPROPERTY pThisDispProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (PROPERTY_IISOBJECT(pThisProperty)) {

                IISTypeFreeIISObjects(
                        PROPERTY_IISOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_IISOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }


    //
    // Free Dynamic Dispid Table
    //

    if (_pDispProperties) {

        FreeADsMem(_pDispProperties);
    }

    if( _bstrServerName )
    {
        ADsFreeString( _bstrServerName );
    }
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
HRESULT
CPropertyCache::createpropertycache(
    CCoreADsObject FAR * pCoreADsObject,
    CPropertyCache FAR *FAR * ppPropertyCache
    )
{
    CPropertyCache FAR * pPropertyCache = NULL;
    BSTR serverName=NULL;
    HRESULT hr;

    hr = pCoreADsObject->get_CoreName(&serverName);
    BAIL_ON_FAILURE(hr);

    pPropertyCache = new CPropertyCache();

    if (!pPropertyCache) {
        RRETURN(E_OUTOFMEMORY);
    }

    pPropertyCache->_pCoreADsObject = pCoreADsObject;
    
    *ppPropertyCache = pPropertyCache;
    RRETURN(S_OK);

error :

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------

HRESULT
CPropertyCache::
unmarshallproperty(
    LPWSTR szPropertyName,
    LPBYTE lpValue,
    DWORD  dwNumValues,
    DWORD  dwSyntaxId,
    BOOL fExplicit
    )
{
    DWORD dwIndex = 0;
    HRESULT hr = S_OK;
    PIISOBJECT pIISObject = NULL;

    hr = UnMarshallIISToIISSynId(
                dwSyntaxId,
                dwNumValues,
                lpValue,
                &pIISObject
                );
    BAIL_ON_FAILURE(hr);

    //
    // Find this property in the cache
    //

    hr = findproperty(
                szPropertyName,
                &dwIndex
                );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pIISObject
                    );

        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = updateproperty(
                    szPropertyName,
                    dwSyntaxId,
                    dwNumValues,
                    pIISObject,
                    fExplicit
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISObject) {
        IISTypeFreeIISObjects(
                pIISObject,
                dwNumValues
                );

    }

    RRETURN(hr);
}

HRESULT
CPropertyCache::
IISUnMarshallProperties(
    LPBYTE pBase,
    LPBYTE pBuffer,
    DWORD  dwMDNumDataEntries,
    BOOL fExplicit
    )
{
    HRESULT hr = S_OK;
    PMETADATA_GETALL_RECORD pmdgarData = NULL, pTemp = NULL;
    DWORD i = 0;
    WCHAR szPropertyName[MAX_PATH];
    DWORD dwSyntaxID;
    DWORD dwNumValues;
   
    ZeroMemory(szPropertyName, MAX_PATH);
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    _bPropsLoaded = TRUE;
    pmdgarData = (PMETADATA_GETALL_RECORD)pBuffer;

    for (i = 0; i < dwMDNumDataEntries; i++) {

        //
        // unmarshall this property into the
        // property cache
        //

        pTemp = pmdgarData + i;

        hr = _pSchema->ConvertID_To_PropName(pTemp->dwMDIdentifier, 
                                             szPropertyName);

        CONTINUE_ON_FAILURE(hr);

        hr = _pSchema->LookupSyntaxID(szPropertyName, &dwSyntaxID);

        CONTINUE_ON_FAILURE(hr);

        //
        // find out number of strings within the multi-sz string
        //

        if (pTemp->dwMDDataType == MULTISZ_METADATA) {
            LPWSTR pszStr = (LPWSTR) (pBase + pTemp->dwMDDataOffset);

            if (*pszStr == 0) {
                dwNumValues = 1;
            }
            else {
                dwNumValues = 0;
            }

            while (*pszStr != L'\0') {
                while (*pszStr != L'\0') {
                    pszStr++;
                }
                dwNumValues++;
                pszStr++;
            }
        }
        else if (pTemp->dwMDDataType == BINARY_METADATA) {

            //
            // if DataType == BINARY, pass the length to dwNumValues
            //

            dwNumValues = pTemp->dwMDDataLen;
        }
        else {
            dwNumValues = 1;
        }

        hr = unmarshallproperty(
                    szPropertyName,
                    pBase + pTemp->dwMDDataOffset,
                    dwNumValues,
                    dwSyntaxID,
                    fExplicit
                    );

        CONTINUE_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CPropertyCache::
IISMarshallProperties(
    PMETADATA_RECORD *  ppMetaDataRecords,
    PDWORD pdwMDNumDataEntries
    )
{

    HRESULT hr = S_OK;
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwCount = 0;

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    pMetaDataArray = (PMETADATA_RECORD) AllocADsMem(
                          _dwMaxProperties * sizeof(METADATA_RECORD));
    if (!pMetaDataArray ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppMetaDataRecords = pMetaDataArray;

    for (i = 0; i < _dwMaxProperties ; i++) {

        pThisProperty = _pProperties + i;

        //
        // Bypass any property that has not been
        // modified
        //

        if (PROPERTY_FLAGS(pThisProperty) == 0 ||
            PROPERTY_FLAGS(pThisProperty) == CACHE_PROPERTY_CLEARED) {
            continue;
        }

        hr = MarshallIISSynIdToIIS(
                _pSchema,
                PROPERTY_SYNTAX(pThisProperty),
                PROPERTY_METAID(pThisProperty),
                PROPERTY_IISOBJECT(pThisProperty),
                PROPERTY_NUMVALUES(pThisProperty),
                pMetaDataArray
                );
        CONTINUE_ON_FAILURE(hr);

        pMetaDataArray++;
        dwCount++;
    }

    *pdwMDNumDataEntries = dwCount;

error:

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Function:   ~CPropertyCache
//
//  Synopsis:
//
//
//
//  Arguments:
//
//
//-------------------------------------------------------------------------
void
CPropertyCache::
flushpropcache()
{
    DWORD i = 0;
    PPROPERTY pThisProperty = NULL;

    if (_pProperties) {

        for (i = 0; i < _dwMaxProperties; i++) {

            pThisProperty = _pProperties + i;

            if (PROPERTY_IISOBJECT(pThisProperty)) {

                IISTypeFreeIISObjects(
                        PROPERTY_IISOBJECT(pThisProperty),
                        PROPERTY_NUMVALUES(pThisProperty)
                        );
                PROPERTY_IISOBJECT(pThisProperty) = NULL;
            }
        }

        FreeADsMem(_pProperties);
    }

    //
    // Reset the property cache
    //

    _pProperties = NULL;
    _dwMaxProperties = 0;
    _cb = 0;
}


BOOL
CPropertyCache::
index_valid(
   )
{
    //
    // need to check separately since a negative DWORD is equal to +ve large #
    //
    if (_dwMaxProperties==0)
        return(FALSE);
   
    if (_dwCurrentIndex > _dwMaxProperties - 1)
        return(FALSE);
    else
        return(TRUE);
}


BOOL
CPropertyCache::
index_valid(
   DWORD dwIndex
   )
{
    //
    // need to check separately since a negative DWORD is equal to +ve large #
    //
    if (_dwMaxProperties==0)
        return(FALSE);

    if (dwIndex > _dwMaxProperties - 1)
        return(FALSE);
    else
        return(TRUE);
}


void
CPropertyCache::
reset_propindex(
    )
{
  _dwCurrentIndex = 0;

}


HRESULT
CPropertyCache::
skip_propindex(
    DWORD dwElements
    )
{
    DWORD newIndex = _dwCurrentIndex + dwElements;

    if (!index_valid())
        RRETURN(E_ADS_BAD_PARAMETER);

    if (newIndex > _dwMaxProperties) {
        RRETURN(E_ADS_BAD_PARAMETER);
    }
    
    _dwCurrentIndex = newIndex;

    RRETURN(S_OK);

}


HRESULT
CPropertyCache::
get_PropertyCount(
    PDWORD pdwMaxProperties
    )
{
    *pdwMaxProperties = _dwMaxProperties;

    RRETURN(S_OK);
}

DWORD
CPropertyCache::
get_CurrentIndex(
    )
{
    return(_dwCurrentIndex);
}


LPWSTR
CPropertyCache::
get_CurrentPropName(
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!_dwMaxProperties)      // if !_dwMaxProperties, pThisProperty=NULL, AV
        return NULL;            // in PROPERTY_NAME(pThisProperty) 

    if (!index_valid())
        return(PROPERTY_NAME(pThisProperty));

    pThisProperty = _pProperties + _dwCurrentIndex;

    return(PROPERTY_NAME(pThisProperty));
}

LPWSTR
CPropertyCache::
get_PropName(
    DWORD dwIndex
    )

{
    PPROPERTY pThisProperty = NULL;

    if (!index_valid(dwIndex))
       return(NULL);

    pThisProperty = _pProperties + dwIndex;

    return(PROPERTY_NAME(pThisProperty));
}


HRESULT
CPropertyCache::
deleteproperty(
    DWORD dwIndex
    )
{
   HRESULT hr = S_OK;
   PPROPERTY pNewProperties = NULL;
   PPROPERTY pThisProperty = _pProperties + dwIndex;

   if (!index_valid(dwIndex)) {
      hr = E_FAIL;
      BAIL_ON_FAILURE(hr);
   }

   if (_dwMaxProperties == 1) {
      //
      // Deleting everything
      //
      if (PROPERTY_IISOBJECT(pThisProperty)) {
          IISTypeFreeIISObjects(
                  PROPERTY_IISOBJECT(pThisProperty),
                  PROPERTY_NUMVALUES(pThisProperty)
                  );
          PROPERTY_IISOBJECT(pThisProperty) = NULL;
      }

      FreeADsMem(_pProperties);
      _pProperties = NULL;
      _dwMaxProperties = 0;
      _cb = 0;
      RRETURN(hr);
   }

   pNewProperties = (PPROPERTY)AllocADsMem(
                               _cb - sizeof(PROPERTY)
                               );
   if (!pNewProperties) {
       hr = E_OUTOFMEMORY;
       BAIL_ON_FAILURE(hr);
   }

   //
   // Copying the memory before the deleted item
   //
   if (dwIndex != 0) {
      memcpy( pNewProperties,
              _pProperties,
              dwIndex * sizeof(PROPERTY));
   }

   //
   // Copying the memory following the deleted item
   //
   if (dwIndex != (_dwMaxProperties-1)) {
      memcpy( pNewProperties + dwIndex,
              _pProperties + dwIndex + 1,
              (_dwMaxProperties - dwIndex - 1) * sizeof(PROPERTY));
   }

   if (PROPERTY_IISOBJECT(pThisProperty)) {
       IISTypeFreeIISObjects(
               PROPERTY_IISOBJECT(pThisProperty),
               PROPERTY_NUMVALUES(pThisProperty)
               );
       PROPERTY_IISOBJECT(pThisProperty) = NULL;
   }
   FreeADsMem(_pProperties);
   _pProperties = pNewProperties;
   _dwMaxProperties--;
   _cb -= sizeof(PROPERTY);
error:

   RRETURN(hr);
}


////////////////////////////////////////////////////////////////////////
//
//  IPropertyCache
//

HRESULT
CPropertyCache::
locateproperty(
    LPWSTR  szPropertyName,
    PDWORD  pdwDispid
    )
{
    HRESULT hr;

    hr = DispatchLocateProperty(
            szPropertyName,
            pdwDispid
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
putproperty(
    DWORD   dwDispid,
    VARIANT varValue
    )
{
    HRESULT hr;

    hr = DispatchPutProperty(
            dwDispid, 
            varValue 
            );

    RRETURN(hr);
}

HRESULT
CPropertyCache::
getproperty(
    DWORD   dwDispid,
    VARIANT * pvarValue
    )
{
    HRESULT hr;

    hr = DispatchGetProperty(
            dwDispid, 
            pvarValue 
            );

    RRETURN(hr);
}
 

////////////////////////////////////////////////////////////////////////
//
// Dynamic Dispid Table
//

HRESULT
CPropertyCache::
DispatchFindProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid 
    )
{
    DWORD i = 0;
    PDISPPROPERTY pDispProp = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!pdwDispid || !szPropertyName)  
        RRETURN(E_ADS_BAD_PARAMETER);

    for (i=0; i<_dwDispMaxProperties; i++) {
        
        pDispProp = _pDispProperties + i;
    
        if (!_wcsicmp(DISPATCH_NAME(pDispProp), szPropertyName)) {
            *pdwDispid=i;
            RRETURN(S_OK);
        }
    }

    *pdwDispid = (DWORD)-1;
    RRETURN(E_ADS_PROPERTY_NOT_FOUND);
}

HRESULT
CPropertyCache::
DispatchAddProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid    /* optional */
    )
{

    HRESULT hr = E_FAIL;
    DWORD dwDispid = (DWORD)-1;
    PDISPPROPERTY pNewDispProps = NULL;

    //
    // use ADs Error codes since this funct'n does not go directly into
    // the dispatch interface
    //
    if (!szPropertyName)  
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = DispatchFindProperty(
            szPropertyName,
            &dwDispid
            );
    
    if (hr==E_ADS_PROPERTY_NOT_FOUND) {
        
        // 
        // increase the size of Dynamic Dispid Table by 1 property
        //
        pNewDispProps = (PDISPPROPERTY) ReallocADsMem(
                                            _pDispProperties,
                                            _cbDisp,
                                            _cbDisp + sizeof(DISPPROPERTY)
                                            );
        if (!pNewDispProps)
            BAIL_ON_FAILURE(hr=E_OUTOFMEMORY);

        //
        // must succeeded at this pt. okay to change table & indexes 
        //
        _pDispProperties = pNewDispProps;
        wcscpy((_pDispProperties+_dwDispMaxProperties)->szPropertyName, 
               szPropertyName);
        dwDispid = _dwDispMaxProperties++;
        _cbDisp += sizeof(DISPPROPERTY);

        hr = S_OK;
    }

    // 
    // return valid, or invalid (-1) in case of failure, dispid of
    // szProperty iff asked for
    //
    if (pdwDispid)            
        *pdwDispid = dwDispid;
        
error:
    
    RRETURN(hr);
} 
        
HRESULT
CPropertyCache::
DispatchLocateProperty(
    LPWSTR szPropertyName,
    PDWORD pdwDispid 
    )
{
    HRESULT hr;
    BSTR bstrClassName = NULL;

    //
    // - pdwDispid not optional here
    // - Use DISP_E_ERROR codes since this function directly called by
    //   the dispatch manager 
    //
    if (!pdwDispid || !szPropertyName)  
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // return dispid of property if already in table; 
    // 
    hr = DispatchFindProperty(
            szPropertyName,
            pdwDispid
            );
   
    if (hr==E_ADS_PROPERTY_NOT_FOUND) {
                 
        //
        // check if property in schema
        //      - this is necessary; otherwise, property not in schema will 
        //        be allowed to be added to cache and will not be given the 
        //        chance to be handled by 3rd party extension.
        //      - note that property not in schema but added to the cache
        //        thru' IADsProperty list will not be handled by 3rd
        //        party extension either. 
        //
        hr = _pCoreADsObject->get_CoreADsClass(&bstrClassName);
        BAIL_ON_FAILURE(hr);
        hr = _pSchema->ValidateProperty(bstrClassName, szPropertyName);
        BAIL_ON_FAILURE(hr);

        //
        // Add property that is in the schema but not in the cache to
        // the dynamic dispid table. That is, property which is in the 
        // schema will always be handled by the cache/server thur ADSI but 
        // will NOT be handled by 3rd party extension.
        //
        if (SUCCEEDED(hr)) {
    
            hr = DispatchAddProperty(
                        szPropertyName,
                        pdwDispid
                        );
            BAIL_ON_FAILURE(hr);

        }

        //
        // Property Not in the schema will nto be added to the dynamic
        // dispid table and could be handled by 3rd party extension.
        //
        else {

            hr = DISP_E_MEMBERNOTFOUND;
            BAIL_ON_FAILURE(hr); 

        }
    }

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    RRETURN(hr);

error:

    if (bstrClassName) {
        ADsFreeString(bstrClassName);
    }

    *pdwDispid = (DWORD)DISPID_UNKNOWN;

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CPropertyCache::
DispatchGetProperty(
    DWORD dwDispid,
    VARIANT * pvarVal
    )
{
    HRESULT hr;
    LPWSTR szPropName = NULL;
    DWORD dwSyntaxId = (DWORD)-1;
    DWORD dwSyntax;
    DWORD dwNumValues = (DWORD)0;
    PIISOBJECT pIISObjs = NULL;
    WCHAR wchName[MAX_PATH];
      
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager 
    //
    if (!pvarVal) 
        RRETURN(DISP_E_PARAMNOTOPTIONAL);

    if (!DISPATCH_INDEX_VALID(dwDispid)) 
        RRETURN(DISP_E_MEMBERNOTFOUND);

    szPropName = DISPATCH_PROPERTY_NAME(dwDispid); 

    //
    // lookup ADSI IIS syntax Id
    //

    hr = _pSchema->LookupSyntaxID(szPropName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    // 
    // return value in cache for szPropName; retrieve value from server 
    // if not already in cache; fail if none on sever
    //
    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) 
    {
    hr = getproperty(
            wchName, 
            &dwSyntaxId, 
            &dwNumValues,
            &pIISObjs
            );
    }
    else
    {
    hr = getproperty(
            szPropName, 
            &dwSyntaxId, 
            &dwNumValues,
            &pIISObjs
            );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISObjs->IISType = dwSyntax;

    //
    // translate IIS objects into variants 
    //
    //
    // always return an array for multisz type
    //

    if (dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
        hr = IISTypeToVarTypeCopy(
                _pSchema,
                szPropName,
                pIISObjs,
                pvarVal,
                TRUE
                );
    }

    else if (dwNumValues == 1 && dwSyntax != IIS_SYNTAX_ID_MULTISZ &&
        dwSyntax != IIS_SYNTAX_ID_MIMEMAP ) {
        
        hr = IISTypeToVarTypeCopy(
                _pSchema,
                szPropName,
                pIISObjs,
                pvarVal,
                FALSE
                );

    } else {
        
        hr = IISTypeToVarTypeCopyConstruct(
                _pSchema,
                szPropName,
                pIISObjs,
                dwNumValues,
                pvarVal,
                FALSE
                );
    }         
    BAIL_ON_FAILURE(hr);

error:
 
    if (pIISObjs) {
        
        IISTypeFreeIISObjects(
            pIISObjs,
            dwNumValues
            );
    }

    if (FAILED(hr)) {

        V_VT(pvarVal) = VT_ERROR;
    }    

    RRETURN(hr);
}

HRESULT
CPropertyCache::
DispatchPutProperty(
    DWORD dwDispid,
    VARIANT& varVal
    )
{
    HRESULT hr;
    DWORD dwSyntaxId = (DWORD)-1;
    DWORD dwIndex = (DWORD)-1;
    LPIISOBJECT pIISObjs = NULL;
    DWORD dwNumValues = (DWORD)0;

    VARIANT * pVarArray = NULL;     // to be freed
    VARIANT * pvProp = NULL;            // do not free
    VARIANT vVar;
    WCHAR wchName[MAX_PATH];
    LPWSTR szPropName = NULL;
    
    hr = LoadSchema();
    BAIL_ON_FAILURE(hr);

    //
    // Use DISP_E_ERROR codes since this function directly called by
    // the dispatch manager 
    //
    if (!DISPATCH_INDEX_VALID(dwDispid)) 
        RRETURN(DISP_E_MEMBERNOTFOUND);

    // 
    // retreive property name from Dynamic Dispatch Table
    //
    szPropName = DISPATCH_PROPERTY_NAME(dwDispid); 

    //
    // lookup its syntax ID
    //

    hr = _pSchema->LookupSyntaxID(szPropName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // Issue: How do we handle multi-valued support
    //

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &varVal);
    BAIL_ON_FAILURE(hr);

    if (V_VT(&vVar) == VT_DISPATCH)
    {
        hr = ConvertDispatchToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );

        if (S_OK == hr) {
            pvProp = pVarArray;
        }
        else {
            // something went wrong converting to a variant array
            // don't bail - just stuff it in as is
            dwNumValues = 1;
            pvProp = &vVar;
            hr = S_OK;
        }
    }
    else if ((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar)) {
        hr  = ConvertArrayToVariantArray(
                    vVar,
                    &pVarArray,
                    &dwNumValues
                    );
        BAIL_ON_FAILURE(hr);
        pvProp = pVarArray;
    }
    else {

        dwNumValues = 1;
        pvProp = &vVar;
    }

    //
    // Variant Array to IIS Objects
    //
    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISObjs,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        DWORD dwMask;
        DWORD dwFlagValue;
        DWORD Temp;
        LPIISOBJECT pIISObject = NULL;

        hr = _pSchema->LookupBitMask(szPropName, &dwMask);
        BAIL_ON_FAILURE(hr);

        //
        // get its corresponding DWORD flag value
        //

        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        hr = getproperty(wchName, 
                         &Temp,
                         &Temp,
                         &pIISObject);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = pIISObject->IISValue.value_1.dwDWORD;

        if (pIISObjs->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISObjs->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISObjs->IISType = IIS_SYNTAX_ID_DWORD;
        szPropName = wchName;

        if (pIISObject) {
            IISTypeFreeIISObjects(
                pIISObject,
                1
                );
        }
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(szPropName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        szPropName = wchName;
    }

    //
    // add the property to cache if not already in since DispatchAddProperty
    // does not addproperty
    //
    hr = findproperty(
                szPropName,
                &dwIndex
                );

    if (FAILED(hr)) {
        hr = addproperty(
                    szPropName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ?
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISObjs
                    );
        BAIL_ON_FAILURE(hr);
    }
    
    //
    // update property value in cache
    //

    hr = putproperty(
                szPropName, 
                CACHE_PROPERTY_MODIFIED,
                dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ?
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                dwNumValues,
                pIISObjs
                );
    BAIL_ON_FAILURE(hr);


error:
 
    if (pIISObjs) {
        IISTypeFreeIISObjects(
            pIISObjs,
            dwNumValues
            );
    }

    if (pVarArray) {

        DWORD i = 0;
        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    VariantClear(&vVar);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\core.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  core.cxx
//
//  Contents:
//
//  History:   11-1-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

HRESULT
CCoreADsObject::InitializeCoreObject(
        BSTR Parent,
        BSTR Name,
        BSTR ClassName,
        BSTR Schema,
        REFCLSID rclsid,
        DWORD dwObjectState
        )
{
    HRESULT hr = S_OK;
    ADsAssert(Parent);
    ADsAssert(Name);
    ADsAssert(ClassName);

    hr = BuildADsPath(
            Parent,
            Name,
            &_ADsPath
            );
    BAIL_ON_FAILURE(hr);

    hr = BuildADsGuid(
            rclsid,
            &_ADsGuid
            );
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( Parent, &_Parent);
    BAIL_ON_FAILURE(hr);


    hr = ADsAllocString( Name, &_Name);
    BAIL_ON_FAILURE(hr);

    hr = ADsAllocString( ClassName, &_ADsClass);
    BAIL_ON_FAILURE(hr);

    hr = BuildSchemaPath(
            _ADsPath,
            ClassName,
            &_Schema
            );
    BAIL_ON_FAILURE(hr);

    _dwObjectState = dwObjectState;

error:
    RRETURN(hr);

}

CCoreADsObject::CCoreADsObject():
                        _Name(NULL),
                        _ADsPath(NULL),
                        _Parent(NULL),
                        _ADsClass(NULL),
                        _Schema(NULL),
                        _ADsGuid(NULL),
                        _dwObjectState(0)
{
}

CCoreADsObject::~CCoreADsObject()
{
    if (_Name) {
        ADsFreeString(_Name);
    }

    if (_ADsPath) {
        ADsFreeString(_ADsPath);
    }

    if (_Parent) {
        ADsFreeString(_Parent);
    }

    if (_ADsClass) {
        ADsFreeString(_ADsClass);
    }

    if (_Schema) {
        ADsFreeString(_Schema);
    }

    if (_ADsGuid) {
        ADsFreeString(_ADsGuid);
    }

}

HRESULT
CCoreADsObject::get_CoreName(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Name, retval));
}


HRESULT
CCoreADsObject::get_CoreADsPath(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsPath, retval));

}

HRESULT
CCoreADsObject::get_CoreADsClass(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsClass, retval));
}

HRESULT
CCoreADsObject::get_CoreParent(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_Parent, retval));
}

HRESULT
CCoreADsObject::get_CoreSchema(BSTR * retval)
{

    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    if ( _Schema == NULL || *_Schema == 0 )
        RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

    RRETURN(ADsAllocString(_Schema, retval));
}

HRESULT
CCoreADsObject::get_CoreGUID(BSTR * retval)
{
    HRESULT hr;

    if (FAILED(hr = ValidateOutParameter(retval))){
        RRETURN(hr);
    }

    RRETURN(ADsAllocString(_ADsGuid, retval));
}

STDMETHODIMP
CCoreADsObject::GetInfo(
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cpobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cpobj.cxx
//
//  Contents:  Property Attribute object
//
//  History:   21-1-98     SophiaC    Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop


//  Class CPropertyAttribute

DEFINE_Simple_IDispatch_Implementation(CPropertyAttribute)

CPropertyAttribute::CPropertyAttribute():
        _pDispMgr(NULL)
{
    VariantInit(&_vDefault);
    ENLIST_TRACKING(CPropertyAttribute);
}

HRESULT
CPropertyAttribute::CreatePropertyAttribute(
    REFIID riid,
    void **ppvObj
    )
{
    CPropertyAttribute FAR * pPropertyAttribute = NULL;
    HRESULT hr = S_OK;

    hr = AllocatePropertyAttributeObject(&pPropertyAttribute);
    BAIL_ON_FAILURE(hr);

    hr = pPropertyAttribute->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pPropertyAttribute->Release();

    RRETURN(hr);

error:
    delete pPropertyAttribute;

    RRETURN(hr);

}


CPropertyAttribute::~CPropertyAttribute( )
{
    VariantClear(&_vDefault);
    delete _pDispMgr;
}

STDMETHODIMP
CPropertyAttribute::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISPropertyAttribute))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IISPropertyAttribute FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}


HRESULT
CPropertyAttribute::InitFromRawData(
    LPWSTR pszName,
    DWORD dwMetaId,
    DWORD dwUserType,
    DWORD dwAttribute,
    VARIANT *pvVal
    )
{
    HRESULT hr = S_OK;

    wcscpy((LPWSTR)_wcName, pszName);
    _lMetaId = (long) dwMetaId;
    _lUserType = (long) dwUserType;
    _lAllAttributes = (long) dwAttribute;
    _bInherit = dwAttribute & METADATA_INHERIT;
    _bPartialPath = dwAttribute & METADATA_PARTIAL_PATH;
    _bSecure = dwAttribute & METADATA_SECURE;
    _bReference = dwAttribute & METADATA_REFERENCE;
    _bVolatile = dwAttribute & METADATA_VOLATILE;
    _bIsinherit = dwAttribute & METADATA_ISINHERITED;
    _bInsertPath = dwAttribute & METADATA_INSERT_PATH;
    
    hr = VariantCopy(&_vDefault, pvVal);
    
    return hr;
}

HRESULT
CPropertyAttribute::AllocatePropertyAttributeObject(
    CPropertyAttribute ** ppPropertyAttribute
    )
{
    CPropertyAttribute FAR * pPropertyAttribute = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pPropertyAttribute = new CPropertyAttribute();
    if (pPropertyAttribute == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISOle,
                IID_IISPropertyAttribute,
                (IISPropertyAttribute *)pPropertyAttribute,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    pPropertyAttribute->_pDispMgr = pDispMgr;
    *ppPropertyAttribute = pPropertyAttribute;

    RRETURN(hr);

error:

    if (pDispMgr)
    {
        delete pDispMgr;
    }

    if (pPropertyAttribute)
    {
        delete pPropertyAttribute;
    }

    RRETURN(hr);
}


STDMETHODIMP
CPropertyAttribute::get_PropName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString((LPWSTR)_wcName, retval);
    RRETURN(hr);
}

STDMETHODIMP
CPropertyAttribute::get_MetaId(THIS_ LONG FAR * retval)
{
    *retval = _lMetaId;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_MetaId(THIS_ LONG lMetaId)
{
   RRETURN(E_ADS_PROPERTY_NOT_SET);
}

STDMETHODIMP
CPropertyAttribute::get_UserType(THIS_ LONG FAR * retval)
{
    *retval = _lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_UserType(THIS_ LONG lUserType)
{
    _lUserType = lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_AllAttributes(THIS_ LONG FAR * retval)
{
    *retval = _lAllAttributes;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Inherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bInherit ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Inherit(THIS_ VARIANT_BOOL bInherit)
{
    _bInherit = bInherit ? TRUE : FALSE;
    _lAllAttributes |= (_bInherit ? METADATA_INHERIT : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_PartialPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bPartialPath ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_PartialPath(THIS_ VARIANT_BOOL bPartialPath)
{
    _bPartialPath = bPartialPath ? TRUE : FALSE;
    _lAllAttributes |= (_bPartialPath ?  METADATA_PARTIAL_PATH : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Reference(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bReference ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Reference(THIS_ VARIANT_BOOL bReference)
{
    _bReference = bReference ? TRUE : FALSE;
    _lAllAttributes |= (_bReference ? METADATA_REFERENCE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Secure(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bSecure ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Secure(THIS_ VARIANT_BOOL bSecure)
{
    _bSecure = bSecure ? TRUE : FALSE;
    _lAllAttributes |= (_bSecure ? METADATA_SECURE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Volatile(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bVolatile ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Volatile(THIS_ VARIANT_BOOL bVolatile)
{
    _bVolatile = bVolatile ? TRUE : FALSE;
    _lAllAttributes |= (_bVolatile ? METADATA_VOLATILE : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Isinherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bIsinherit ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_Isinherit(THIS_ VARIANT_BOOL bIsinherit)
{
    _bIsinherit = bIsinherit ? TRUE : FALSE;
    _lAllAttributes |= (_bIsinherit ? METADATA_ISINHERITED : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_InsertPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _bInsertPath ? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::put_InsertPath(THIS_ VARIANT_BOOL bInsertPath)
{
    _bInsertPath = bInsertPath ? TRUE : FALSE;
    _lAllAttributes |= (_bInsertPath ? METADATA_INSERT_PATH : 0);
    RRETURN(S_OK);
}

STDMETHODIMP
CPropertyAttribute::get_Default(THIS_ VARIANT FAR * retval)
{
    VariantInit(retval);
    RRETURN(VariantCopy(retval, &_vDefault));
}

STDMETHODIMP
CPropertyAttribute::put_Default(THIS_ VARIANT vVarDefault)
{
    VariantClear(&_vDefault);
    RRETURN(VariantCopy(&_vDefault, &vVarDefault));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cpobjcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  cpobjcf.cxx
//
//  Contents:  Windows NT 4.0 Property Attribute Object Class Factory Code
//
//             CIISPropertyAttributeCF::CreateInstance
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISPropertyAttributeCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    21-04-97   sophiac     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISPropertyAttributeCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = E_FAIL;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CPropertyAttribute::CreatePropertyAttribute(
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cprovcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  cprovcf.cxx
//
//  Contents:  IIS Provider Object Class Factory Code
//
//             CIISProviderCF::CreateInstance
//
//  History:   01-30-95     krishnag    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   CIISProviderCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    01-30-95   krishnag     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISProviderCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr;
    CIISProvider *     pProvider;

    if (pUnkOuter)
        RRETURN(E_FAIL);


    hr = CIISProvider::Create(&pProvider);

    if (FAILED(hr)) {
        RRETURN (hr);
    }

    if (pProvider)
    {
        hr = pProvider->QueryInterface(iid, ppv);
        pProvider->Release();
    }
    else
    {
        *ppv = NULL;
        RRETURN(E_OUTOFMEMORY);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cschobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  cschobj.cxx
//
//  Contents:  Microsoft ADs IIS Provider Schema Object
//
//
//  History:   01-30-98     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISSchema

DEFINE_IDispatch_Implementation(CIISSchema)
DEFINE_IADs_Implementation(CIISSchema)


CIISSchema::CIISSchema() :
      _pSchema(NULL),
      _pDispMgr(NULL),
      _pszServerName(NULL),
      _pAdminBase(NULL)
{

    ENLIST_TRACKING(CIISSchema);
}

HRESULT
CIISSchema::CreateSchema(
    LPWSTR pszServerName,
    BSTR Parent,
    BSTR CommonName,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISSchema FAR * pSchema = NULL;
    HRESULT hr = S_OK;
    CCredentials localCred;

    hr = AllocateSchemaObject(&pSchema);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(localCred,
                        pszServerName, 
                        &pSchema->_pAdminBase, 
                        &pSchema->_pSchema);
    BAIL_ON_FAILURE(hr);

    pSchema->_pszServerName = AllocADsStr(pszServerName);

    if (!pSchema->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSchema->InitializeCoreObject(
                Parent,
                CommonName,
                SCHEMA_CLASS_NAME,
                L"",
                CLSID_IISSchema,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pSchema->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pSchema->Release();

    RRETURN(hr);

error:

    delete pSchema;
    RRETURN(hr);
}

CIISSchema::~CIISSchema( )
{
    delete _pDispMgr;

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

}

STDMETHODIMP
CIISSchema::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISSchemaObject))
    {
        *ppv = (IISSchemaObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

STDMETHODIMP
CIISSchema::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

/* IADsContainer methods */

STDMETHODIMP
CIISSchema::get_Count(long FAR* retval)
{
    HRESULT hr;
    DWORD dwEntries;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    hr = _pSchema->GetTotalEntries(&dwEntries);

    if ( SUCCEEDED(hr))
        *retval = dwEntries + g_cIISSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CIISSchema::get_Filter(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetObject(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    LPWSTR pszBuffer = NULL;
    HRESULT hr = S_OK;
    DWORD dwLen;
    CCredentials Credentials;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwLen = (DWORD)(wcslen(_ADsPath) + wcslen(RelativeName) + wcslen(ClassName)) + 4;

    pszBuffer = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

    if (!pszBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszBuffer, _ADsPath);
    wcscat(pszBuffer, L"/");
    wcscat(pszBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(pszBuffer,L",");
        wcscat(pszBuffer, ClassName);
    }

    hr = ::GetObject(
                pszBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;

    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    *retval = NULL;

    hr = CIISSchemaEnum::Create(
                (CIISSchemaEnum **)&penum,
                _pSchema,
                _ADsPath,
                _Name
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISSchema::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{

    HRESULT hr = S_OK;
    DWORD i = 1;

    //
    // We can only create "Class","Property" here, "Syntax" is read-only
    //

    //
    // check if property/class already exists
    //

    if (_pSchema->ValidateClassName(RelativeName) == ERROR_SUCCESS ||
        _pSchema->ValidatePropertyName(RelativeName) == ERROR_SUCCESS ) {
        hr = E_ADS_OBJECT_EXISTS;
        BAIL_ON_FAILURE(hr);
    }

    //
    // validate name -->
    //                  must start w/ a-z, A-Z, or underscore
    //                  must only contain a-z, A-Z, 0-9, or underscore
    //

    // check first character
    if (                                                    // if first char is
        (RelativeName[0] < 65 || RelativeName[0] > 90)  &&  // not uppercase letter and
        (RelativeName[0] < 97 || RelativeName[0] > 122) &&  // not lowercase letter and
         RelativeName[0] != 95                              // not underscore
       )                                                    // then bail
    {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }
     
    while (                                                       // while characters are
            (RelativeName[i] >= 65 && RelativeName[i] <= 90)  ||  // uppercase letters or
            (RelativeName[i] >= 97 && RelativeName[i] <= 122) ||  // lowercase letters or
            (RelativeName[i] >= 48 && RelativeName[i] <= 57)  ||  // digits or
             RelativeName[i] == 95                                // underscores
          )                                                       // then things are okay
            i++;

    if (RelativeName[i] != L'\0' || i >= METADATA_MAX_NAME_LEN) {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    } 

    if (  ( _wcsicmp( ClassName, CLASS_CLASS_NAME ) == 0 ) )
    {

        //
        // Now, create the class
        //
        hr = CIISClass::CreateClass(
                         _ADsPath,
                         RelativeName,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else if (  ( _wcsicmp( ClassName, PROPERTY_CLASS_NAME ) == 0 ) )
    {

        hr = CIISProperty::CreateProperty(
                         _ADsPath,
                         RelativeName,
                         ADS_OBJECT_UNBOUND,
                         IID_IUnknown,
                         (void **) ppObject );
    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
    }

error:

    RRETURN(hr);

}

STDMETHODIMP
CIISSchema::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    HRESULT hr;
    BOOL bClass;
    METADATA_HANDLE hObjHandle = NULL;

    if (  ( _wcsicmp( bstrClassName, CLASS_CLASS_NAME ) == 0 ) )
    {
        hr = _pSchema->ValidateClassName(bstrRelativeName);
        BAIL_ON_FAILURE(hr);
        bClass = TRUE;

        //
        // remove entry from metabase
        //

        CCredentials localCred;

        hr = OpenAdminBaseKey(
                    localCred,
                    _pszServerName,
                    SCHEMA_CLASS_METABASE_PATH,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = MetaBaseDeleteObject(
                    _pAdminBase,
                    hObjHandle,
                    (LPWSTR)bstrRelativeName
                    );
        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
    }
    else if (  ( _wcsicmp( bstrClassName, PROPERTY_CLASS_NAME ) == 0 ) )
    {
        DWORD dwMetaId;

        hr = _pSchema->ValidatePropertyName(bstrRelativeName);
        BAIL_ON_FAILURE(hr);
        bClass = FALSE;

        //
        // Lookup metaid
        //

        hr = _pSchema->LookupMetaID(bstrRelativeName, &dwMetaId);
        BAIL_ON_FAILURE(hr);

        //
        // remove entry from metabase
        //

        CCredentials localCred;

        hr = OpenAdminBaseKey(
                    localCred,
                    _pszServerName,
                    SCHEMA_PROP_METABASE_PATH,
                    METADATA_PERMISSION_WRITE,
                    &_pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Names",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);

        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Types",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
       
        hr = _pAdminBase->DeleteData(
                              hObjHandle,
                              (LPWSTR)L"Defaults",
                              dwMetaId,
                              ALL_METADATA
                              );

        if (hr == MD_ERROR_DATA_NOT_FOUND) {
            hr = S_OK;
        }
        BAIL_ON_FAILURE(hr);
    }
    else
    {
        hr = E_ADS_BAD_PARAMETER;
        BAIL_ON_FAILURE(hr);
    }

    //
    // remove entry from schema cache
    //

    hr = _pSchema->RemoveEntry(bClass, bstrRelativeName);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISSchema::AllocateSchemaObject(
    CIISSchema ** ppSchema
    )
{
    CIISSchema FAR * pSchema = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSchema = new CIISSchema();
    if (pSchema == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
        if (pSchema)
        {
            delete pSchema;
        }
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pSchema,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISSchemaObject,
                           (IISSchemaObject *)pSchema,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    pSchema->_pDispMgr = pDispMgr;
    *ppSchema = pSchema;

    RRETURN(hr);

error:
    delete pDispMgr;
    delete pSchema;

    RRETURN(hr);

}


STDMETHODIMP
CIISSchema::GetInfo(
    THIS_ DWORD dwApiLevel,
    BOOL fExplicit
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISSchema::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}



STDMETHODIMP
CIISSchema::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    RRETURN(E_NOTIMPL);
}


STDMETHODIMP
CIISSchema::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSchema::GetSchemaPropertyAttributes(
    THIS_ BSTR bstrName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;
    PROPERTYINFO *pPropertyInfo = NULL;
    DWORD i = 0;
    IISPropertyAttribute * pPropAttrib = NULL;
    WCHAR wchName[MAX_PATH];
    VARIANT vVar;

    VariantInit(&vVar);
    *ppObject = NULL;

    //
    // if passed in bstrName is a meta id, then convert it to property name
    //
    if (wcslen(bstrName) >= MAX_PATH) bstrName[MAX_PATH - 1] = L'\0';
    wcscpy((LPWSTR)wchName, bstrName);

    while (wchName[i] != L'\0' && wchName[i] >= L'0' &&
           wchName[i] <= L'9') {
       i++;
    }

    if (i == wcslen((LPWSTR)wchName)) {
        dwMetaId = _wtoi((LPWSTR)wchName);
        hr = _pSchema->ConvertID_To_PropName(dwMetaId, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }
    else {

        //
        // check if property is a supported property
        //

        hr = _pSchema->LookupMetaID(wchName, &dwMetaId);
        BAIL_ON_FAILURE(hr);
    }

    //
    // get property attribute value
    //

    pPropertyInfo = _pSchema->GetPropertyInfo(wchName);
    ASSERT(pPropertyInfo != NULL);

    if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
        vVar.vt = VT_I4;
        vVar.lVal = pPropertyInfo->dwDefault;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        vVar.vt = VT_BOOL;
        vVar.boolVal = pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
    }
    else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
        pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
        LPWSTR pszStr = pPropertyInfo->szDefault;

        hr = MakeVariantFromStringArray(NULL,
                                        pszStr,
                                        &vVar);
        BAIL_ON_FAILURE(hr);
    }
    else {
        vVar.vt = VT_BSTR;
        hr = ADsAllocString( pPropertyInfo->szDefault, &(vVar.bstrVal));
        BAIL_ON_FAILURE(hr);
    }

    hr = CPropertyAttribute::CreatePropertyAttribute(
                           IID_IISPropertyAttribute,
                           (VOID**)&pPropAttrib
                           );
    BAIL_ON_FAILURE(hr);

    hr = ((CPropertyAttribute*)pPropAttrib)->InitFromRawData(
                           (LPWSTR) wchName,
                           dwMetaId,
                           pPropertyInfo->dwUserGroup,
                           pPropertyInfo->dwMetaFlags,
                           &vVar
                           );
    BAIL_ON_FAILURE(hr);

    *ppObject = (IDispatch*)pPropAttrib;

error:

    VariantClear(&vVar);
    RRETURN(hr);
}

STDMETHODIMP
CIISSchema::PutSchemaPropertyAttributes(
    THIS_ IDispatch * pObject
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\cschema.cxx ===
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996
//
//  File:  cschema.cxx
//
//  Contents:  Windows NT 4.0
//
//
//  History:   01-09-98     sophiac    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

#define PROP_RW     0x0000001

SCHEMAOBJPROPS g_pClassObjProps[] = {
          {L"PrimaryInterface", IIS_SYNTAX_ID_STRING, CLASS_PRIMARY_INTERFACE},
          {L"CLSID", IIS_SYNTAX_ID_STRING, CLASS_CLSID},
          {L"OID", IIS_SYNTAX_ID_STRING, CLASS_OID},
          {L"Abstract",  IIS_SYNTAX_ID_BOOL, CLASS_ABSTRACT},
          {L"Auxiliary",  IIS_SYNTAX_ID_BOOL, CLASS_AUXILIARY},
          {L"MandatoryProperties", IIS_SYNTAX_ID_STRING, CLASS_MAND_PROPERTIES},
          {L"OptionalProperties", IIS_SYNTAX_ID_STRING, CLASS_OPT_PROPERTIES},
          {L"NamingProperties", IIS_SYNTAX_ID_STRING, CLASS_NAMING_PROPERTIES},
          {L"DerivedFrom", IIS_SYNTAX_ID_STRING, CLASS_DERIVEDFROM},
          {L"AuxDerivedFrom", IIS_SYNTAX_ID_STRING, CLASS_AUX_DERIVEDFROM},
          {L"PossibleSuperiors", IIS_SYNTAX_ID_STRING, CLASS_POSS_SUPERIORS},
          {L"Containment", IIS_SYNTAX_ID_STRING, CLASS_CONTAINMENT},
          {L"Container",  IIS_SYNTAX_ID_BOOL, CLASS_CONTAINER},
          {L"HelpFileName", IIS_SYNTAX_ID_STRING, CLASS_HELPFILENAME},
          {L"HelpFileContext", IIS_SYNTAX_ID_DWORD, CLASS_HELPFILECONTEXT}
        };

SCHEMAOBJPROPS g_pPropertyObjProps[] = {
          {L"OID", IIS_SYNTAX_ID_STRING, PROP_OID},
          {L"Syntax", IIS_SYNTAX_ID_STRING, PROP_SYNTAX},
          {L"MaxRange", IIS_SYNTAX_ID_DWORD, PROP_MAXRANGE},
          {L"MinRange", IIS_SYNTAX_ID_DWORD, PROP_MINRANGE},
          {L"MultiValued", IIS_SYNTAX_ID_BOOL, PROP_MULTIVALUED},
          {L"PropName", IIS_SYNTAX_ID_STRING, PROP_PROPNAME},
          {L"MetaId", IIS_SYNTAX_ID_DWORD, PROP_METAID},
          {L"UserType", IIS_SYNTAX_ID_DWORD, PROP_USERTYPE},
          {L"AllAttributes", IIS_SYNTAX_ID_DWORD, PROP_ALLATTRIBUTES},
          {L"Inherit", IIS_SYNTAX_ID_BOOL, PROP_INHERIT},
          {L"PartialPath", IIS_SYNTAX_ID_BOOL, PROP_PARTIALPATH},
          {L"Secure", IIS_SYNTAX_ID_BOOL, PROP_SECURE},
          {L"Reference", IIS_SYNTAX_ID_BOOL, PROP_REFERENCE},
          {L"Volatile", IIS_SYNTAX_ID_BOOL, PROP_VOLATILE},
          {L"Isinherit", IIS_SYNTAX_ID_BOOL, PROP_ISINHERIT},
          {L"InsertPath", IIS_SYNTAX_ID_BOOL, PROP_INSERTPATH},
          {L"Default", IIS_SYNTAX_ID_STRING_DWORD, PROP_DEFAULT}
        };

DWORD g_cPropertyObjProps (sizeof(g_pPropertyObjProps)/sizeof(SCHEMAOBJPROPS));
DWORD g_cClassObjProps (sizeof(g_pClassObjProps)/sizeof(SCHEMAOBJPROPS));

/******************************************************************/
/*  Class CIISClass
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISClass)
DEFINE_IADs_Implementation(CIISClass)

CIISClass::CIISClass()
    : _pDispMgr( NULL ),
      _bstrCLSID( NULL ),
      _bstrOID( NULL ),
      _bstrPrimaryInterface( NULL ),
      _fAbstract( FALSE ),
      _fContainer( FALSE ),
      _bstrHelpFileName( NULL ),
      _lHelpFileContext( 0 ),
	  _bExistClass(FALSE),
	  _pSchema(NULL),
      _pszServerName(NULL),
      _pszClassName(NULL),
      _pAdminBase(NULL)
{
    VariantInit( &_vMandatoryProperties );
    VariantInit( &_vOptionalProperties );
    VariantInit( &_vPossSuperiors );
    VariantInit( &_vContainment );

    ENLIST_TRACKING(CIISClass);
}

CIISClass::~CIISClass()
{

    if ( _bstrCLSID ) {
        ADsFreeString( _bstrCLSID );
    }

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrPrimaryInterface ) {
        ADsFreeString( _bstrPrimaryInterface );
    }

    if ( _bstrHelpFileName ) {
        ADsFreeString( _bstrHelpFileName );
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszClassName) {
        FreeADsStr(_pszClassName);
    }

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vPossSuperiors );
    VariantClear( &_vContainment );

    delete _pDispMgr;
}

HRESULT
CIISClass::CreateClass(
    BSTR   bstrParent,
    BSTR   bstrRelative,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISClass FAR *pClass = NULL;
    HRESULT hr = S_OK;
    CCredentials localCred;
    BSTR bstrTmp = NULL;
    CLASSINFO *pClassInfo;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(bstrParent);

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateClassObject( &pClass );
    BAIL_ON_FAILURE(hr);

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(localCred,
                        pObjectInfo->TreeName,
                        &pClass->_pAdminBase,
                        &pClass->_pSchema);
    BAIL_ON_FAILURE(hr);

    pClass->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!pClass->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pClass->_pszClassName = AllocADsStr(bstrRelative);

    if (!pClass->_pszClassName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pClassInfo = pClass->_pSchema->GetClassInfo(bstrRelative);

    //
    //  an existing class
    //

    if (pClassInfo) {
  
        pClass->_bExistClass = TRUE;
        pClass->_lHelpFileContext = pClassInfo->lHelpFileContext;
        pClass->_fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
        pClass->_fAbstract = (VARIANT_BOOL)pClassInfo->fAbstract;


        if (pClassInfo->pPrimaryInterfaceGUID) {
            hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pPrimaryInterfaceGUID),
                              &bstrTmp );
            BAIL_ON_FAILURE(hr);

            hr = ADsAllocString( bstrTmp,
                                 &pClass->_bstrPrimaryInterface);
            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }

        if (pClassInfo->pCLSID) {
            hr = StringFromCLSID( (REFCLSID) *(pClassInfo->pCLSID),
                                  &bstrTmp );
            BAIL_ON_FAILURE(hr);
    
            hr = ADsAllocString( bstrTmp,
                                 &pClass->_bstrCLSID );
            BAIL_ON_FAILURE(hr);

            CoTaskMemFree(bstrTmp);
            bstrTmp = NULL;
        }

        hr = ADsAllocString( pClassInfo->bstrOID, &pClass->_bstrOID);
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                        &(pClass->_vMandatoryProperties));
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                        &(pClass->_vOptionalProperties));
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrPossSuperiors,
                                        &(pClass->_vPossSuperiors));
        BAIL_ON_FAILURE(hr);

        hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                        &(pClass->_vContainment));
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString(pClassInfo->bstrHelpFileName,
                            &pClass->_bstrHelpFileName);
        BAIL_ON_FAILURE(hr);
    }


    hr = pClass->InitializeCoreObject(
         bstrParent,
         bstrRelative,
         CLASS_CLASS_NAME,
         NO_SCHEMA,
         CLSID_IISClass,
         dwObjectState );

    BAIL_ON_FAILURE(hr);

    hr = pClass->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pClass->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    if ( bstrTmp != NULL )
        CoTaskMemFree(bstrTmp);

    *ppvObj = NULL;
    delete pClass;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}


STDMETHODIMP
CIISClass::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsClass FAR * ) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsClass))
    {
        *ppv = (IADsClass FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISClass::SetInfo(THIS)
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = IISCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}


/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
CIISClass::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    PMETADATA_RECORD pMetaDataArray = NULL;
    DWORD dwMDNumDataEntries = 0;
    CLASSINFO ClassInfo;
    LPBYTE pBuffer = NULL;
    CCredentials localCred;

    memset(&ClassInfo, 0, sizeof(CLASSINFO));

    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = OpenAdminBaseKey(
                localCred,
                _pszServerName,
                SCHEMA_CLASS_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    hr = MakeStringFromVariantArray(&_vMandatoryProperties, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateProperties((LPWSTR)pBuffer, TRUE);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrMandatoryProperties = (BSTR)pBuffer;

    pBuffer = NULL;
    hr = MakeStringFromVariantArray(&_vOptionalProperties, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateProperties((LPWSTR)pBuffer, FALSE);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrOptionalProperties = (BSTR)pBuffer;

    pBuffer = NULL;
    hr = MakeStringFromVariantArray(&_vContainment, (LPBYTE*)&pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = ValidateClassNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    hr = CheckDuplicateNames((LPWSTR)pBuffer);
    BAIL_ON_FAILURE(hr);
    ClassInfo.bstrContainment = (BSTR)pBuffer;

    pBuffer = NULL;
    ClassInfo.fContainer = _fContainer;

    //
    // validate data
    //
  
    if ((ClassInfo.fContainer && !ClassInfo.bstrContainment) ||
        (!ClassInfo.fContainer && ClassInfo.bstrContainment) ) {
        hr = E_ADS_SCHEMA_VIOLATION;
        BAIL_ON_FAILURE(hr);
    }

    // Things are okay, so reset the _v members just incase things have changed
    hr = MakeVariantFromStringList( ClassInfo.bstrMandatoryProperties,
                                    &(_vMandatoryProperties));
    BAIL_ON_FAILURE(hr);
    
    hr = MakeVariantFromStringList( ClassInfo.bstrOptionalProperties,
                                    &(_vOptionalProperties));
    BAIL_ON_FAILURE(hr);

    hr = MakeVariantFromStringList( ClassInfo.bstrContainment,
                                    &(_vContainment));
    BAIL_ON_FAILURE(hr);

    hr = IISMarshallClassProperties(
                            &ClassInfo,
                            &pMetaDataArray,
                            &dwMDNumDataEntries
                            );
    BAIL_ON_FAILURE(hr);

    hr = MetaBaseSetAllData(
                _pAdminBase,
                hObjHandle,
                _pszClassName,
                (PMETADATA_RECORD)pMetaDataArray,
                dwMDNumDataEntries
                );
    BAIL_ON_FAILURE(hr);

    // 
    // update schema cache
    // 

    _pSchema->SetClassInfo(_pszClassName, &ClassInfo);
    BAIL_ON_FAILURE(hr);

    _bExistClass = TRUE;

error:

    //
    // if failed to create properties for new class, delete class node
    //

    if (FAILED(hr) && !_bExistClass && hObjHandle) {

        MetaBaseDeleteObject(
                _pAdminBase,
                hObjHandle,
                (LPWSTR)_pszClassName
                );
    }

    if (ClassInfo.bstrOptionalProperties) {
        FreeADsMem(ClassInfo.bstrOptionalProperties);
    }

    if (ClassInfo.bstrMandatoryProperties) {
        FreeADsMem(ClassInfo.bstrMandatoryProperties);
    }

    if (ClassInfo.bstrContainment) {
        FreeADsMem(ClassInfo.bstrContainment);
    }

    if (pBuffer) {
        FreeADsMem(pBuffer);
    }

    if (pMetaDataArray) {
        FreeADsMem(pMetaDataArray);
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

HRESULT
CIISClass::IISCreateObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    CCredentials localCred;

    //
    // Add CreateObject functionality : sophiac
    //

    hr = OpenAdminBaseKey(
                localCred,
                _pszServerName,
                SCHEMA_CLASS_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // Pass in full path
    //

    hr = MetaBaseCreateObject(
                _pAdminBase,
                hObjHandle,
                _pszClassName
                );
    BAIL_ON_FAILURE(hr);

error:

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    PCLASSINFO pClassInfo = NULL;

    //
    // free up memory first
    //

    VariantClear( &_vMandatoryProperties );
    VariantClear( &_vOptionalProperties );
    VariantClear( &_vContainment );

    //
    // get classinfo from schema cache 
    //

    pClassInfo = _pSchema->GetClassInfo(_pszClassName);

    if (pClassInfo) {
  
        _fContainer = (VARIANT_BOOL)pClassInfo->fContainer;
        hr = MakeVariantFromStringList( pClassInfo->bstrMandatoryProperties,
                                        &_vMandatoryProperties);
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrOptionalProperties,
                                        &_vOptionalProperties);
        BAIL_ON_FAILURE(hr);


        hr = MakeVariantFromStringList( pClassInfo->bstrContainment,
                                        &_vContainment);
        BAIL_ON_FAILURE(hr);

    }

error:

    RRETURN(hr);
}

/* IADsClass methods */

STDMETHODIMP
CIISClass::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwID;

    //
    // check if property is a supported property
    //

    hr = ValidateClassObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case CLASS_OPT_PROPERTIES:
        hr = get_OptionalProperties(pvProp);
        break;
    case CLASS_CONTAINMENT: 
        hr = get_Containment(pvProp);
        break;
    case CLASS_CONTAINER:
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
        break;
    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


HRESULT
CIISClass::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwID;

    VARIANT vVar;

    //
    // check if property is a supported property and 
    // loop up its syntax id
    //

    hr = ValidateClassObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    VariantInit(&vVar);
    hr = VariantCopyInd(&vVar, &vProp);
    BAIL_ON_FAILURE(hr);

    //
    // update both classinfo and member variables
    //

    switch(dwID) {
    case CLASS_OPT_PROPERTIES:
        if (vVar.vt != VT_EMPTY &&
            !((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar))) {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
        hr = VariantCopy(&_vOptionalProperties, &vVar);
        BAIL_ON_FAILURE(hr);
        break;

    case CLASS_CONTAINMENT: 
        if (vVar.vt != VT_EMPTY &&
            !((V_VT(&vVar) & VT_VARIANT) && V_ISARRAY(&vVar))) {
            hr = E_ADS_CANT_CONVERT_DATATYPE;
            BAIL_ON_FAILURE(hr);
        }
        hr = VariantCopy(&_vContainment, &vVar);
        BAIL_ON_FAILURE(hr);
        break;

    case CLASS_CONTAINER:
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        _fContainer = (vProp.boolVal == VARIANT_TRUE) ? true : false;
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    VariantClear(&vVar);

    RRETURN(hr);
}


STDMETHODIMP
CIISClass::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    //
    // Get and GetEx are the same for class schema object
    //

    hr = Get(bstrName, pvProp);
    RRETURN(hr);
}


STDMETHODIMP
CIISClass::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISClass::ValidateProperties(
    LPWSTR pszList,
    BOOL bMandatory
    )
{
    WCHAR *pszNewList;
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszList;
    HRESULT hr;

    if (pszList == NULL) RRETURN(S_OK);

    // need to allocate +2 = 1 for null, 1 for extra comma
    pszNewList = new WCHAR[wcslen(pszList)+2];

    if (pszNewList == NULL) RRETURN(E_OUTOFMEMORY);

    wcscpy(pszNewList, L"");

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            hr = _pSchema->ValidatePropertyName(szName);
            if (hr == E_ADS_PROPERTY_NOT_SUPPORTED) {
            
                hr = PropertyInMetabase(szName, bMandatory);
            }
            else {

                // form the new list
                wcscat(pszNewList, szName);
                wcscat(pszNewList, L",");
            }

            BAIL_ON_FAILURE(hr);  // if it's a legit bad name
        }
    }

    // get rid of the last comma
    pszNewList[wcslen(pszNewList) - 1] = 0;

    wcscpy(pszList, pszNewList);

    delete [] pszNewList;
    RRETURN(S_OK);

error: 

    //
    // return E_ADS_SCHEMA_VIOLATION if property not found in global list
    //

    delete [] pszNewList;
    RRETURN(E_ADS_SCHEMA_VIOLATION);
}

HRESULT
CIISClass::PropertyInMetabase( 
    LPWSTR szPropName,
    BOOL bMandatory 
    )
{
    // Oops - somethings wrong.  What do we do?  Depends...
    //
    // Check to see if the bad property name exists in the associated list
    // in the metabase.
    //
    // If so (case 1), then we are trying to SetInfo after having deleted a property from
    // the schema - so just silently remove the name from metabase & the cached class.
    //
    // If not (case 2), we are trying to SetInfo w/ a bogus property name, 
    // so throw an exception.

    HRESULT hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    CLASSINFO *pClassInfo;
    LPWSTR ObjectList;
    WCHAR szTestProp[MAX_PATH];

    pClassInfo = _pSchema->GetClassInfo(_pszClassName);

    if (pClassInfo == NULL) {
        RRETURN(hr);
    }

    if (bMandatory == TRUE) {
        ObjectList = pClassInfo->bstrMandatoryProperties;
    }
    else {
        ObjectList = pClassInfo->bstrOptionalProperties;
    }

    while ((ObjectList = grabProp(szTestProp, ObjectList)) != NULL) {
        if (wcscmp(szTestProp, szPropName) == 0) {
        
            hr = S_OK;  // clear the error - we'll fix it (case 1)
        }
    }

    RRETURN(hr);
}

HRESULT
CIISClass::ValidateClassNames(
    LPWSTR pszList
    )
{
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszList;
    HRESULT hr;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            hr = _pSchema->ValidateClassName(szName);
            if (FAILED(hr)) {
                if (_wcsicmp(szName, _pszClassName)) {
                    BAIL_ON_FAILURE(hr);
                }
            }
        }

    }

    RRETURN(S_OK);

error: 

    //
    // return E_ADS_SCHEMA_VIOLATION if classname not found in global list
    //

    RRETURN(E_ADS_SCHEMA_VIOLATION);
}

STDMETHODIMP
CIISClass::get_PrimaryInterface( THIS_ BSTR FAR *pbstrGUID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_CLSID( THIS_ BSTR FAR *pbstrCLSID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_CLSID( THIS_ BSTR bstrCLSID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Abstract( THIS_ VARIANT_BOOL FAR *pfAbstract )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_Abstract( THIS_ VARIANT_BOOL fAbstract )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Auxiliary( THIS_ VARIANT_BOOL FAR *pfAuxiliary)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_Auxiliary( THIS_ VARIANT_BOOL fAuxiliary )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_NamingProperties( THIS_ VARIANT FAR *retval )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_NamingProperties( THIS_ VARIANT vNamingProperties )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_MandatoryProperties( THIS_ VARIANT FAR *retval )
{
    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    RRETURN(VariantCopy(retval, &_vMandatoryProperties));
}

STDMETHODIMP
CIISClass::put_MandatoryProperties( THIS_ VARIANT vMandatoryProperties )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_OptionalProperties( THIS_ VARIANT FAR *retval )
{
    if ( !retval )
        RRETURN(E_ADS_BAD_PARAMETER);

    VariantInit( retval );

    RRETURN(VariantCopy(retval, &_vOptionalProperties));
}

STDMETHODIMP
CIISClass::put_OptionalProperties( THIS_ VARIANT vOptionalProperties )
{
    HRESULT hr = put_VARIANT_Property( this, TEXT("OptionalProperties"),
                                       vOptionalProperties );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_DerivedFrom( THIS_ VARIANT FAR *pvDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_DerivedFrom( THIS_ VARIANT vDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_AuxDerivedFrom( THIS_ VARIANT FAR *pvAuxDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_AuxDerivedFrom( THIS_ VARIANT vAuxDerivedFrom )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_PossibleSuperiors( THIS_ VARIANT FAR *pvPossSuperiors )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_PossibleSuperiors( THIS_ VARIANT vPossSuperiors )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_Containment( THIS_ VARIANT FAR *pvContainment )
{
    if ( !pvContainment )
        RRETURN(E_ADS_BAD_PARAMETER);
    VariantInit( pvContainment );
    RRETURN( VariantCopy( pvContainment, &_vContainment ));
}

STDMETHODIMP
CIISClass::put_Containment( THIS_ VARIANT vContainment )
{
    HRESULT hr = put_VARIANT_Property( this, TEXT("Containment"),
                                       vContainment );

    if ( hr == E_ADS_CANT_CONVERT_DATATYPE )
    {
        hr = E_NOTIMPL;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_Container( THIS_ VARIANT_BOOL FAR *pfContainer )
{
    if ( !pfContainer )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pfContainer = _fContainer? VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISClass::put_Container( THIS_ VARIANT_BOOL fContainer )
{
    HRESULT hr = put_VARIANT_BOOL_Property( this, TEXT("Container"),
                                       fContainer );
    RRETURN(hr);
}

STDMETHODIMP
CIISClass::get_HelpFileName( THIS_ BSTR FAR *pbstrHelpFileName )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_HelpFileName( THIS_ BSTR bstrHelpFile )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::get_HelpFileContext( THIS_ long FAR *plHelpContext )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::put_HelpFileContext( THIS_ long lHelpContext )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISClass::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISClass::AllocateClassObject(CIISClass FAR * FAR * ppClass)
{

    CIISClass FAR  *pClass = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pClass = new CIISClass();
    if ( pClass == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsClass,
                            (IADsClass *) pClass,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pClass->_pDispMgr = pDispMgr;
    *ppClass = pClass;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pClass;

    RRETURN(hr);

}

/******************************************************************/
/*  Class CIISProperty
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISProperty)
DEFINE_IADs_Implementation(CIISProperty)

CIISProperty::CIISProperty()
    : _pDispMgr( NULL ),
      _bstrOID( NULL ),
      _bstrSyntax( NULL ),
      _lMaxRange( 0 ),
      _lMinRange( 0 ),
      _fMultiValued( FALSE ),
      _lMetaId( 0 ),
      _lUserType(IIS_MD_UT_SERVER ),
      _lAllAttributes( 0),
      _dwSyntaxId( IIS_SYNTAX_ID_DWORD ),
      _dwFlags( PROP_RW ),
      _dwMask( 0 ),
      _dwPropID( 0 ),
	  _bExistProp(FALSE),
	  _pSchema(NULL),
      _pszServerName(NULL),
      _pszPropName(NULL),
      _pAdminBase(NULL)
{

    VariantInit(&_vDefault);

    ADsAllocString(L"Integer", &_bstrSyntax);
    
    ENLIST_TRACKING(CIISProperty);
}

CIISProperty::~CIISProperty()
{
    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszPropName) {
        FreeADsStr(_pszPropName);
    }

    VariantClear( &_vDefault );
    delete _pDispMgr;
}

/* #pragma INTRINSA suppress=all */
HRESULT
CIISProperty::CreateProperty(
    BSTR   bstrParent,
    BSTR   bstrRelative,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISProperty FAR * pProperty = NULL;
    HRESULT hr = S_OK;
    CCredentials localCred;
    PROPERTYINFO *pPropertyInfo;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = NULL;
    CLexer Lexer(bstrParent);

    hr = AllocatePropertyObject( &pProperty );
    BAIL_ON_FAILURE(hr);

    pObjectInfo = &ObjectInfo;
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = InitServerInfo(localCred,
                        pObjectInfo->TreeName,
                        &pProperty->_pAdminBase,
                        &pProperty->_pSchema);
    BAIL_ON_FAILURE(hr);

    pProperty->_pszServerName = AllocADsStr(pObjectInfo->TreeName);

    if (!pProperty->_pszServerName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pProperty->_pszPropName = AllocADsStr(bstrRelative);

    if (!pProperty->_pszPropName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    pPropertyInfo = pProperty->_pSchema->GetPropertyInfo(bstrRelative);

    if (pPropertyInfo) {

        LPWSTR pszSyntax;

        pProperty->_bExistProp = TRUE;
        hr = ADsAllocString( pPropertyInfo->bstrOID, &pProperty->_bstrOID);
        BAIL_ON_FAILURE(hr);

        pProperty->_lMaxRange = pPropertyInfo->lMaxRange;
        pProperty->_lMinRange = pPropertyInfo->lMinRange;
        pProperty->_fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

        pProperty->_lMetaId = pPropertyInfo->dwMetaID;
        pProperty->_lUserType = pPropertyInfo->dwUserGroup;
        pProperty->_lAllAttributes = pPropertyInfo->dwMetaFlags;
        pProperty->_dwSyntaxId = pPropertyInfo->dwSyntaxId;
        pProperty->_dwFlags = pPropertyInfo->dwFlags;
        pProperty->_dwMask = pPropertyInfo->dwMask;
        pProperty->_dwPropID = pPropertyInfo->dwPropID;

        pszSyntax = SyntaxIdToString(pProperty->_dwSyntaxId);
        hr = ADsAllocString(pszSyntax, &(pProperty->_bstrSyntax));
        BAIL_ON_FAILURE(hr);

        if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            (pProperty->_vDefault).vt = VT_I4;
            (pProperty->_vDefault).lVal = pPropertyInfo->dwDefault;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            (pProperty->_vDefault).vt = VT_BOOL;
            (pProperty->_vDefault).boolVal = 
                  pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            LPWSTR pszStr = pPropertyInfo->szDefault;

            hr = MakeVariantFromStringArray(NULL,
                                            pszStr,
                                            &(pProperty->_vDefault));
            BAIL_ON_FAILURE(hr);
        }
        else {
            (pProperty->_vDefault).vt = VT_BSTR;
            hr = ADsAllocString( pPropertyInfo->szDefault, 
                                 &(pProperty->_vDefault.bstrVal));
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = pProperty->InitializeCoreObject(
             bstrParent,
             bstrRelative,
             PROPERTY_CLASS_NAME,
             NO_SCHEMA,
             CLSID_IISProperty,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    hr = pProperty->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pProperty->Release();

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);

error:

    *ppvObj = NULL;

    delete pProperty;

    FreeObjectInfo(pObjectInfo);

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IISSchemaObject))
    {
        *ppv = (IISSchemaObject FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsProperty))
    {
        *ppv = (IADsProperty FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISProperty::SetInfo(THIS)
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        //
        // fill in all unset fields
        //

        // User set an explicit the MetaID for a new object
        // we need to validate it.
        if( _lMetaId != 0 &&
            !IsMetaIdAvailable( _lMetaId ) 
            )
        {
            return E_ADS_SCHEMA_VIOLATION;
        }

        if (!_bstrSyntax) {
            LPWSTR pszSyntax;
            pszSyntax = SyntaxIdToString(_dwSyntaxId);
            hr = ADsAllocString(pszSyntax, &_bstrSyntax);
            BAIL_ON_FAILURE(hr);
        }

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }

    hr = IISSetObject();
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

HRESULT
CIISProperty::IISSetObject()
{
    HRESULT hr = S_OK;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdr;
    PropValue pv;
    CCredentials localCred;
    PROPERTYINFO PropertyInfo;

    memset(&PropertyInfo, 0, sizeof(PROPERTYINFO));

    //
    // Add SetObject functionality : sophiac
    //

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    //
    // validate data
    //

    switch(_dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        if (_vDefault.vt != VT_EMPTY) {
            hr = CheckVariantDataType(&_vDefault, VT_I4);
            if (FAILED(hr)) {
                hr = E_ADS_SCHEMA_VIOLATION;
            }
            BAIL_ON_FAILURE(hr);
        }
        if (_lMaxRange < _lMinRange) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        if ((_vDefault.vt != VT_EMPTY && _vDefault.vt != VT_BOOL) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_STRING:
    case IIS_SYNTAX_ID_EXPANDSZ:
        if ((_vDefault.vt != VT_EMPTY && _vDefault.vt != VT_BSTR) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_MIMEMAP: 
    case IIS_SYNTAX_ID_MULTISZ:
        if ((_vDefault.vt != VT_EMPTY &&
             _vDefault.vt != VT_VARIANT &&
             !((V_VT(&_vDefault) & VT_VARIANT) && V_ISARRAY(&_vDefault))) ||
            _lMaxRange != 0 || _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_IPSECLIST:     
        if (_vDefault.vt != VT_EMPTY || _lMaxRange != 0 ||  _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    case IIS_SYNTAX_ID_BINARY:         
    case IIS_SYNTAX_ID_NTACL:
        if (_vDefault.vt != VT_EMPTY || _lMaxRange != 0 ||  _lMinRange != 0 ) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }
        break;

    default:
        break;

    }

    //
    // set property Default values
    //

    PropertyInfo.lMaxRange = _lMaxRange;
    PropertyInfo.lMinRange = _lMinRange;
    PropertyInfo.fMultiValued = _fMultiValued;
    PropertyInfo.dwFlags = _dwFlags;
    PropertyInfo.dwSyntaxId = _dwSyntaxId;
    PropertyInfo.dwMask = _dwMask;   
    PropertyInfo.dwMetaFlags = _lAllAttributes;
    PropertyInfo.dwUserGroup = _lUserType;

    hr = ConvertDefaultValue(&_vDefault, &PropertyInfo);
    BAIL_ON_FAILURE(hr);

    hr = SetMetaID();
    BAIL_ON_FAILURE(hr);

    PropertyInfo.dwMetaID = _lMetaId;
    PropertyInfo.dwPropID = _dwPropID; 

    hr = OpenAdminBaseKey(
                localCred,
                _pszServerName,
                SCHEMA_PROP_METABASE_PATH,
                METADATA_PERMISSION_WRITE,
                &_pAdminBase,
                &hObjHandle
                );
    BAIL_ON_FAILURE(hr);

    //
    // set property name under Properties/Names
    //

    MD_SET_DATA_RECORD(&mdr,
                       (DWORD)_lMetaId,
                       METADATA_NO_ATTRIBUTES,
                       IIS_MD_UT_SERVER,
                       STRING_METADATA,
                       ((DWORD)wcslen((LPWSTR)_pszPropName)+1)*2,
                       (unsigned char *)_pszPropName);

    hr = _pAdminBase->SetData(hObjHandle, L"Names", &mdr);
    BAIL_ON_FAILURE(hr);

    //
    // set property attributes/types under Properties/Types
    //

    InitPropValue(&pv, &PropertyInfo);
    mdr.dwMDDataType = BINARY_METADATA;
    mdr.dwMDDataLen = sizeof(PropValue);
    mdr.pbMDData = (unsigned char *)&pv;
    hr = _pAdminBase->SetData(hObjHandle, L"Types", &mdr);
    BAIL_ON_FAILURE(hr);

    DataForSyntaxID(&PropertyInfo, &mdr);
    hr = _pAdminBase->SetData(hObjHandle, L"Defaults", &mdr);
    BAIL_ON_FAILURE(hr);

    //
    //  update schema cache
    //

    hr = _pSchema->SetPropertyInfo(_pszPropName, &PropertyInfo);
    BAIL_ON_FAILURE(hr);

    _bExistProp = TRUE;

error:

    if (PropertyInfo.szDefault) {
        if (PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_STRING ||
            PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_EXPANDSZ) {
            FreeADsStr(PropertyInfo.szDefault );
        }
        else if (PropertyInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem(PropertyInfo.szDefault );
        }
    }

    //
    // if validation failed and new prop, delete class node
    //

    if (FAILED(hr) && !_bExistProp && hObjHandle) {

        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Names",
                         _lMetaId,
                         ALL_METADATA
                         );
        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Types",
                         _lMetaId,
                         ALL_METADATA
                         );
        _pAdminBase->DeleteData(
                         hObjHandle,
                         (LPWSTR)L"Defaults",
                         _lMetaId,
                         ALL_METADATA
                         );
    }

    if (_pAdminBase && hObjHandle) {
        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::GetInfo(THIS)
{
    HRESULT hr = S_OK;
    PROPERTYINFO *pPropertyInfo = NULL;

    //
    // free up memory first
    //

    VariantClear( &_vDefault );

    if ( _bstrOID ) {
        ADsFreeString( _bstrOID );
    }

    if ( _bstrSyntax ) {
        ADsFreeString( _bstrSyntax );
    }

    pPropertyInfo = _pSchema->GetPropertyInfo(_pszPropName);

    if (pPropertyInfo) {

        hr = ADsAllocString( pPropertyInfo->bstrOID, &_bstrOID);
        BAIL_ON_FAILURE(hr);

        hr = ADsAllocString( pPropertyInfo->bstrSyntax, &_bstrSyntax);
        BAIL_ON_FAILURE(hr);

        _lMaxRange = pPropertyInfo->lMaxRange;
        _lMinRange = pPropertyInfo->lMinRange;
        _fMultiValued  = (VARIANT_BOOL)pPropertyInfo->fMultiValued;

        _lMetaId = pPropertyInfo->dwMetaID;
        _lUserType = pPropertyInfo->dwUserGroup;
        _lAllAttributes = pPropertyInfo->dwMetaFlags;
        _dwSyntaxId = pPropertyInfo->dwSyntaxId;
        _dwFlags = pPropertyInfo->dwFlags;
        _dwMask = pPropertyInfo->dwMask;
        _dwPropID = pPropertyInfo->dwPropID;

        if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            _vDefault.vt = VT_I4;
            _vDefault.lVal = pPropertyInfo->dwDefault;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            _vDefault.vt = VT_BOOL;
            _vDefault.boolVal =
                  pPropertyInfo->dwDefault ? VARIANT_TRUE : VARIANT_FALSE;
        }
        else if (pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropertyInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            LPWSTR pszStr = pPropertyInfo->szDefault;

            hr = MakeVariantFromStringArray(NULL,
                                            pszStr,
                                            &_vDefault);
            BAIL_ON_FAILURE(hr);
        }
        else {
            _vDefault.vt = VT_BSTR;
            hr = ADsAllocString( pPropertyInfo->szDefault, &(_vDefault.bstrVal));
            BAIL_ON_FAILURE(hr);
        }
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwID;

    //
    // check if property is a supported property
    //

    hr = ValidatePropertyObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case PROP_SYNTAX:
        pvProp->vt = VT_BSTR;
        hr = ADsAllocString( _bstrSyntax, &pvProp->bstrVal);
        break;

    case PROP_MAXRANGE:
        pvProp->vt = VT_I4;
        pvProp->lVal = _lMaxRange;
        break;

    case PROP_MINRANGE:
        pvProp->vt = VT_I4;
        pvProp->lVal = _lMinRange;
        break;

    case PROP_MULTIVALUED:
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _fMultiValued? VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_PROPNAME:                      
        pvProp->vt = VT_BSTR;
        hr = ADsAllocString( _pszPropName, &pvProp->bstrVal);
        break;

    case PROP_METAID:                           
        if (_lMetaId == 0) {
            hr = E_ADS_PROPERTY_NOT_SET;
        }
        else {
            pvProp->vt = VT_I4;
            pvProp->lVal = _lMetaId;
        }
        break;

    case PROP_USERTYPE:                         
        pvProp->vt = VT_I4;
        pvProp->lVal = _lUserType;
        break;

    case PROP_ALLATTRIBUTES:                    
        pvProp->vt = VT_I4;
        pvProp->lVal = _lAllAttributes;
        break;

    case PROP_INHERIT:                          
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_INHERIT ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_SECURE:                           
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_SECURE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_REFERENCE:                        
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_REFERENCE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_VOLATILE:                         
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_VOLATILE ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_INSERTPATH:                      
        pvProp->vt = VT_BOOL;
        pvProp->boolVal = _lAllAttributes & METADATA_INSERT_PATH ?
                                     VARIANT_TRUE : VARIANT_FALSE;
        break;

    case PROP_DEFAULT:                          
        hr = VariantCopy(pvProp, &_vDefault);
        BAIL_ON_FAILURE(hr);
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


HRESULT
CIISProperty::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwID;             
    VARIANT vVar;


    //
    // check if property is a supported property
    //

    hr = ValidatePropertyObjProps(bstrName, &dwSyntaxId, &dwID);
    BAIL_ON_FAILURE(hr);

    switch(dwID) {
    case PROP_SYNTAX:
        if (_bExistProp) {
            hr = E_ADS_SCHEMA_VIOLATION;
            BAIL_ON_FAILURE(hr);
        }

        hr = ValidateSyntaxName(vProp.bstrVal, &dwSyntaxId);
        BAIL_ON_FAILURE(hr);
        hr = ADsReAllocString( &_bstrSyntax,
                               vProp.bstrVal ? vProp.bstrVal: TEXT("") );
        BAIL_ON_FAILURE(hr);
        _dwSyntaxId = dwSyntaxId;
        if (_dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
            _dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            _fMultiValued = VARIANT_TRUE;
        }

        break;

    case PROP_MAXRANGE:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lMaxRange = vProp.lVal;
        break;

    case PROP_MINRANGE:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lMinRange = vProp.lVal;
        break;

    case PROP_USERTYPE:                         
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        _lUserType = vProp.lVal;
        break;

    case PROP_INHERIT:
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_INHERIT;
        }
        else {
            _lAllAttributes &= ~METADATA_INHERIT;
        }
        break;

    case PROP_PARTIALPATH:                      
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_PARTIAL_PATH;
        }
        else {
            _lAllAttributes &= ~METADATA_PARTIAL_PATH;
        }
        break;

    case PROP_SECURE:                           
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_SECURE;
        }
        else {
            _lAllAttributes &= ~METADATA_SECURE;
        }
        break;

    case PROP_REFERENCE:                        
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_REFERENCE;
        }
        else {
            _lAllAttributes &= ~METADATA_REFERENCE;
        }
        break;

    case PROP_VOLATILE:                         
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_VOLATILE;
        }
        else {
            _lAllAttributes &= ~METADATA_VOLATILE;
        }
        break;

    case PROP_ISINHERIT:                        
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_ISINHERITED;
        }
        else {
            _lAllAttributes &= ~METADATA_ISINHERITED;
        }
        break;

    case PROP_INSERTPATH:                      
        hr = CheckVariantDataType(&vProp, VT_BOOL);
        BAIL_ON_FAILURE(hr);
        if (vProp.boolVal == VARIANT_TRUE) {
            _lAllAttributes |= METADATA_INSERT_PATH;
        }
        else {
            _lAllAttributes &= ~METADATA_INSERT_PATH;
        }
        break;

    case PROP_DEFAULT:                          
        VariantInit(&vVar);
        hr = VariantCopyInd(&vVar, &vProp);
        BAIL_ON_FAILURE(hr);

        VariantClear( &_vDefault );
        _vDefault = vVar;
        break;

    case PROP_METAID:
        hr = CheckVariantDataType(&vProp, VT_I4);
        BAIL_ON_FAILURE(hr);
        hr = put_MetaId( vProp.lVal );
        break;

    default:
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
    }

error:

    RRETURN(hr);
}


STDMETHODIMP
CIISProperty::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;

    //
    // Get and GetEx are the same for property schema object
    //

    hr = Get(bstrName, pvProp);
    RRETURN(hr);
}


STDMETHODIMP
CIISProperty::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISProperty::ConvertDefaultValue(
    PVARIANT pVar,
    PROPERTYINFO *pPropInfo
    )
{
    HRESULT hr = S_OK;
    LPBYTE *pBuffer;

    if (pVar->vt != VT_EMPTY) {
        if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_DWORD ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_NTACL ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BINARY ) {
            pPropInfo->dwDefault = (DWORD)pVar->lVal;
        }
        else if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
            pPropInfo->dwDefault = pVar->boolVal ? 1 : 0;
        }
        else if (pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_MULTISZ ||
            pPropInfo->dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ) {
            hr = MakeMultiStringFromVariantArray(pVar, 
                                                 (LPBYTE*)&pBuffer);
            BAIL_ON_FAILURE(hr);
    
            pPropInfo->szDefault = (LPWSTR) pBuffer;
        }
        else {
            if (pVar->vt == VT_BSTR && pVar->bstrVal && *(pVar->bstrVal)) {
                pPropInfo->szDefault = AllocADsStr(pVar->bstrVal);
    
                if (!pPropInfo->szDefault) {
                    hr = E_OUTOFMEMORY;
                    BAIL_ON_FAILURE(hr);
                }
            }
        }
    }

error:

    RRETURN(hr);
}

HRESULT
CIISProperty::ValidateSyntaxName(
    LPWSTR pszName,
    PDWORD pdwSyntax
    )
{
    HRESULT hr = S_OK;
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cIISSyntax; i++ )
    {
         if ( _wcsicmp( g_aIISSyntax[i].bstrName, pszName ) == 0 ) {
             *pdwSyntax = g_aIISSyntax[i].dwIISSyntaxId;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);
}


/* IADsProperty methods */


STDMETHODIMP
CIISProperty::get_OID( THIS_ BSTR FAR *pbstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_OID( THIS_ BSTR bstrOID )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_Syntax( THIS_ BSTR FAR *pbstrSyntax )
{
    if ( !pbstrSyntax )
        RRETURN(E_ADS_BAD_PARAMETER);

    RRETURN( ADsAllocString( _bstrSyntax, pbstrSyntax ));

}

STDMETHODIMP
CIISProperty::put_Syntax( THIS_ BSTR bstrSyntax )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    HRESULT hr;
    DWORD dwSyntaxId;

    if (_bExistProp) {
        RRETURN(E_ADS_SCHEMA_VIOLATION);
    }

    hr = ValidateSyntaxName(bstrSyntax, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    hr = ADsReAllocString( &_bstrSyntax, bstrSyntax);
    BAIL_ON_FAILURE(hr);
    _dwSyntaxId = dwSyntaxId;

    if (_dwSyntaxId == IIS_SYNTAX_ID_MIMEMAP ||
        _dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
        _fMultiValued = VARIANT_TRUE;
    }

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::get_MaxRange( THIS_ long FAR *plMaxRange )
{
    if ( !plMaxRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMaxRange = _lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MaxRange( THIS_ long lMaxRange )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lMaxRange = lMaxRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_MinRange( THIS_ long FAR *plMinRange )
{
    if ( !plMinRange )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plMinRange = _lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MinRange( THIS_ long lMinRange )
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lMinRange = lMinRange;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_MultiValued( THIS_ VARIANT_BOOL FAR *pfMultiValued )
{
    if ( !pfMultiValued )
        RRETURN(E_ADS_BAD_PARAMETER);

    *pfMultiValued = _fMultiValued;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_MultiValued( THIS_ VARIANT_BOOL fMultiValued )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::Qualifiers(THIS_ IADsCollection FAR* FAR* ppQualifiers)
{
    RRETURN(E_NOTIMPL);
}

HRESULT
CIISProperty::AllocatePropertyObject(CIISProperty FAR * FAR * ppProperty)
{
    CIISProperty FAR *pProperty = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pProperty = new CIISProperty();
    if ( pProperty == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADs,
                            (IADs *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsProperty,
                            (IADsProperty *) pProperty,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_IISOle,
                           IID_IISPropertyAttribute,
                           (IISPropertyAttribute *)pProperty,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    pProperty->_pDispMgr = pDispMgr;
    *ppProperty = pProperty;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pProperty;

    RRETURN(hr);

}

STDMETHODIMP
CIISProperty::get_PropName(THIS_ BSTR FAR * retval)
{
    HRESULT hr = S_OK;

    hr = ADsAllocString((LPWSTR)_pszPropName, retval);
    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::get_MetaId(THIS_ LONG FAR * retval)
{
    HRESULT hr = S_OK;

    if (_lMetaId == 0) {
        hr = E_ADS_PROPERTY_NOT_SET;
    }
    else {
        *retval = _lMetaId;
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISProperty::put_MetaId(THIS_ LONG lMetaId)
{
    if (GetObjectState() != ADS_OBJECT_UNBOUND) 
    {
        // Only valid for unsaved objects
        RRETURN( E_ADS_OBJECT_EXISTS );
    }
    if( lMetaId < 0 )
    {
        // Never a valid metabase id
        RRETURN( E_ADS_BAD_PARAMETER );
    }
    if( !IsMetaIdAvailable( (DWORD)lMetaId ) )
    {
        // This id is already in use
        RRETURN( E_ADS_SCHEMA_VIOLATION );
    }

     _lMetaId = (DWORD)lMetaId;
     RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_UserType(THIS_ LONG FAR * retval)
{
    *retval = _lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_UserType(THIS_ LONG lUserType)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    _lUserType = (DWORD)lUserType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_AllAttributes(THIS_ LONG FAR * retval)
{
    *retval = _lAllAttributes;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Inherit(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_INHERIT ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Inherit(THIS_ VARIANT_BOOL bInherit)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bInherit == VARIANT_TRUE) { 
        _lAllAttributes |= METADATA_INHERIT;
    }
    else {
        _lAllAttributes &= ~METADATA_INHERIT;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_PartialPath(THIS_ VARIANT_BOOL FAR * retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_PartialPath(THIS_ VARIANT_BOOL bPartialPath)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_Reference(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_REFERENCE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Reference(THIS_ VARIANT_BOOL bReference)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bReference == VARIANT_TRUE) { 
        _lAllAttributes |= METADATA_REFERENCE;
    }
    else {
        _lAllAttributes &= ~METADATA_REFERENCE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Secure(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_SECURE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Secure(THIS_ VARIANT_BOOL bSecure)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bSecure == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_SECURE;
    }
    else {
        _lAllAttributes &= ~METADATA_SECURE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Volatile(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_VOLATILE ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_Volatile(THIS_ VARIANT_BOOL bVolatile)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bVolatile == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_VOLATILE;
    }
    else {
        _lAllAttributes &= ~METADATA_VOLATILE;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Isinherit(THIS_ VARIANT_BOOL FAR * retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::put_Isinherit(THIS_ VARIANT_BOOL bIsinherit)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISProperty::get_InsertPath(THIS_ VARIANT_BOOL FAR * retval)
{
    *retval = _lAllAttributes & METADATA_INSERT_PATH ? 
                                     VARIANT_TRUE : VARIANT_FALSE;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::put_InsertPath(THIS_ VARIANT_BOOL bInsertPath)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    if (bInsertPath == VARIANT_TRUE) {
        _lAllAttributes |= METADATA_INSERT_PATH;
    }
    else {
        _lAllAttributes &= ~METADATA_INSERT_PATH;
    }
    RRETURN(S_OK);
}

STDMETHODIMP
CIISProperty::get_Default(THIS_ VARIANT FAR * retval)
{
    VariantInit(retval);      
    RRETURN(VariantCopy(retval, &_vDefault));
}

STDMETHODIMP
CIISProperty::put_Default(THIS_ VARIANT vVarDefault)
{
	HRESULT hr_check = _pSchema->ValidatePropertyName(_pszPropName);

	if (SUCCEEDED(hr_check)) {
		RRETURN(E_FAIL);
	}

    VariantClear(&_vDefault);
    RRETURN(VariantCopy(&_vDefault, &vVarDefault));
}

HRESULT
CIISProperty::SetMetaID()
{
    HRESULT hr = S_OK;
    DWORD dwMetaId;

    //
    // get metaid 
    //

    if (_lMetaId == 0) {
        hr = _pSchema->LookupMetaID(_pszPropName, &dwMetaId);

        //
        // generate a meta id for this property
        //

        if (FAILED(hr)) {

            hr = GenerateNewMetaID(_pszServerName, _pAdminBase, &dwMetaId);
            BAIL_ON_FAILURE(hr);

            //
            // since we don't support bit mask property for ext. schema,
            // propid == metaid
            //

            _dwPropID = dwMetaId;
        }
        else {
            hr = _pSchema->LookupPropID(_pszPropName, &_dwPropID);
            ASSERT(hr);
        }

        //
        // assign new metaid to property
        //

        _lMetaId = (LONG)dwMetaId;
    
    }

error:

    RRETURN(hr);

}

BOOL
CIISProperty::IsMetaIdAvailable(
    DWORD MetaId
    )
/*++
Routine Description:

    Determine if the ID is valid to set on a new property.
    
    The determinination is based on whether the id is not 
    currently in use.

    NOTE - We will not respect ranges of IDs reserved for
    the base object. Unless that value is already defined
    (per vanvan)

Arguments:

    MetaId - The ID to validate

Return Value:

    TRUE if the specified id is valid to set, FALSE otherwise
--*/
{
    BOOL                fRet = FALSE;
    HRESULT             hr = NOERROR;
    CCredentials localCred;
    METADATA_HANDLE     hObjHandle = NULL;

    // Is the property specified by MetaId defined in the schema

    hr = OpenAdminBaseKey(
                localCred,
                _pszServerName,
                SCHEMA_PROP_METABASE_PATH,
                METADATA_PERMISSION_READ,
                &_pAdminBase,
                &hObjHandle
                );

    if( SUCCEEDED(hr) )
    {
        METADATA_RECORD mdr;
        WCHAR           wcsPropertyName[MAX_PATH + 1];
        DWORD           cb;

        MD_SET_DATA_RECORD( &mdr,
                            MetaId,
                            METADATA_NO_ATTRIBUTES,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            sizeof(wcsPropertyName),
                            (unsigned char *)wcsPropertyName
                            );

        hr = _pAdminBase->GetData( hObjHandle, L"Names", &mdr, &cb );

        if( MD_ERROR_DATA_NOT_FOUND == hr )
        {
            fRet = TRUE;
        }

        CloseAdminBaseKey(_pAdminBase, hObjHandle);
    }

    return fRet;
}

/******************************************************************/
/*  Class CIISSyntax
/******************************************************************/

DEFINE_IDispatch_Implementation(CIISSyntax)
DEFINE_IADs_Implementation(CIISSyntax)
DEFINE_IADs_PutGetUnImplementation(CIISSyntax)

CIISSyntax::CIISSyntax() : _pSchema(NULL),
                           _pDispMgr(NULL)
{
    ENLIST_TRACKING(CIISSyntax);
}

CIISSyntax::~CIISSyntax()
{
    delete _pDispMgr;
}

HRESULT
CIISSyntax::CreateSyntax(
    BSTR   bstrParent,
    SYNTAXINFO *pSyntaxInfo,
    DWORD  dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISSyntax FAR *pSyntax = NULL;
    HRESULT hr = S_OK;

    hr = AllocateSyntaxObject( &pSyntax );
    BAIL_ON_FAILURE(hr);

    hr = pSyntax->InitializeCoreObject(
             bstrParent,
             pSyntaxInfo->bstrName,
             SYNTAX_CLASS_NAME,
             NO_SCHEMA,
             CLSID_IISSyntax,
             dwObjectState );
    BAIL_ON_FAILURE(hr);

    pSyntax->_lOleAutoDataType = pSyntaxInfo->lOleAutoDataType;

    hr = pSyntax->QueryInterface( riid, ppvObj );
    BAIL_ON_FAILURE(hr);

    pSyntax->Release();

    RRETURN(hr);

error:

    delete pSyntax;
    RRETURN(hr);
}

STDMETHODIMP
CIISSyntax::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsSyntax))
    {
        *ppv = (IADsSyntax FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return NOERROR;
}

/* IADs methods */

STDMETHODIMP
CIISSyntax::SetInfo(THIS)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISSyntax::GetInfo(THIS)
{
    RRETURN(S_OK);
}

HRESULT
CIISSyntax::AllocateSyntaxObject(CIISSyntax FAR * FAR * ppSyntax)
{
    CIISSyntax FAR *pSyntax = NULL;
    CAggregatorDispMgr FAR *pDispMgr = NULL;
    HRESULT hr = S_OK;

    pSyntax = new CIISSyntax();
    if ( pSyntax == NULL )
        hr = E_OUTOFMEMORY;
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if ( pDispMgr == NULL )
    {
        hr = E_OUTOFMEMORY;
        if (pSyntax)
        {
            delete pSyntax;
        }
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                            LIBID_ADs,
                            IID_IADsSyntax,
                            (IADsSyntax *) pSyntax,
                            DISPID_REGULAR );
    BAIL_ON_FAILURE(hr);

    pSyntax->_pDispMgr = pDispMgr;
    *ppSyntax = pSyntax;

    RRETURN(hr);

error:

    delete pDispMgr;
    delete pSyntax;

    RRETURN(hr);

}

STDMETHODIMP
CIISSyntax::get_OleAutoDataType( THIS_ long FAR *plOleAutoDataType )
{
    if ( !plOleAutoDataType )
        RRETURN(E_ADS_BAD_PARAMETER);

    *plOleAutoDataType = _lOleAutoDataType;
    RRETURN(S_OK);
}

STDMETHODIMP
CIISSyntax::put_OleAutoDataType( THIS_ long lOleAutoDataType )
{
    RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);
}


/******************************************************************/
/*  Misc Helpers
/******************************************************************/

HRESULT
MakeVariantFromStringList(
    BSTR bstrList,
    VARIANT *pvVariant
)
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    BSTR pszTempList = NULL;

    if ( bstrList != NULL )
    {
        // If bstrList is not null, then there we consider there
        // to be one element
        long nCount = 1;

        long i = 0;
        TCHAR c;
        BSTR pszSrc;

        hr = ADsAllocString( bstrList, &pszTempList );
        BAIL_ON_FAILURE(hr);

        c = pszTempList[i];
        while ( c )
        {
            if ( c == TEXT(','))
            {
                pszTempList[i] = 0;
                nCount++;
            }

            i++;
            c = pszTempList[i];
        }

        aBound.lLbound = 0;
        aBound.cElements = nCount;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pszSrc = pszTempList;

        for ( i = 0; i < nCount; i++ )
        {
            VARIANT v;

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            hr = ADsAllocString( pszSrc, &(V_BSTR(&v)));
            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList,
                                      &i,
                                      &v );
            VariantClear(&v);
            BAIL_ON_FAILURE(hr);

            pszSrc += _tcslen( pszSrc ) + 1;
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;

        ADsFreeString( pszTempList );
        pszTempList = NULL;

    }
    else
    {
        aBound.lLbound = 0;
        aBound.cElements = 0;

        aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

        if ( aList == NULL )
        {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        VariantInit( pvVariant );
        V_VT(pvVariant) = VT_ARRAY | VT_VARIANT;
        V_ARRAY(pvVariant) = aList;
    }

    RRETURN(S_OK);

error:

    if ( pszTempList )
        ADsFreeString( pszTempList );

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}



HRESULT
ValidateClassObjProps(
    LPWSTR pszName,
    PDWORD pdwSyntax,
    PDWORD pdwID
    )
{
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cClassObjProps; i++ )
    {
         if ( _wcsicmp( g_pClassObjProps[i].szObjectName, pszName) == 0 ) {
             *pdwSyntax = g_pClassObjProps[i].dwSyntaxId;
             *pdwID = g_pClassObjProps[i].dwID;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);

}

HRESULT
ValidatePropertyObjProps(
    LPWSTR pszName,
    PDWORD pdwSyntax,
    PDWORD pdwID
    )
{
    DWORD i;

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cPropertyObjProps; i++ )
    {
         if ( _wcsicmp( g_pPropertyObjProps[i].szObjectName, pszName) == 0 ) {
             *pdwSyntax = g_pPropertyObjProps[i].dwSyntaxId;
             *pdwID = g_pPropertyObjProps[i].dwID;
             RRETURN(S_OK);
         }
    }

    RRETURN(E_ADS_BAD_PARAMETER);

}


HRESULT
IISMarshallClassProperties(
    CLASSINFO *pClassInfo,
    PMETADATA_RECORD *  ppMetaDataRecords,
    PDWORD pdwMDNumDataEntries
    )
{

    HRESULT hr = S_OK;
    PMETADATA_RECORD pMetaDataArray = NULL;
    static BOOL bTemp = FALSE; 

    //
    // set to 4 because we're supporting 4 properties only
    //
    *pdwMDNumDataEntries = 4;

    pMetaDataArray = (PMETADATA_RECORD) AllocADsMem(
                          *pdwMDNumDataEntries * sizeof(METADATA_RECORD));
    if (!pMetaDataArray ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *ppMetaDataRecords = pMetaDataArray;

    //
    // setting Containment and Container property for classes
    //
    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINER;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = DWORD_METADATA;
    pMetaDataArray->dwMDDataLen = sizeof(DWORD);
    if (pClassInfo) {
        pMetaDataArray->pbMDData = (unsigned char*)&(pClassInfo->fContainer);
    }
    else {
        pMetaDataArray->pbMDData = (BYTE*)&bTemp;
    }
    pMetaDataArray++;

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_CONTAINMENT;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrContainment) {
        pMetaDataArray->dwMDDataLen = ((DWORD)wcslen((LPWSTR)pClassInfo->bstrContainment)+ 1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrContainment;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }

    pMetaDataArray++;


    //
    // setting Optional and Mandatory Properties
    //

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_MAND_PROPERTIES;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrMandatoryProperties) {
        pMetaDataArray->dwMDDataLen = ((DWORD)wcslen((LPWSTR)pClassInfo->bstrMandatoryProperties)+1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrMandatoryProperties;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }

    pMetaDataArray++;

    pMetaDataArray->dwMDIdentifier = MD_SCHEMA_CLASS_OPT_PROPERTIES;
    pMetaDataArray->dwMDAttributes = METADATA_NO_ATTRIBUTES;
    pMetaDataArray->dwMDUserType = IIS_MD_UT_SERVER;
    pMetaDataArray->dwMDDataType = STRING_METADATA;
    if (pClassInfo && pClassInfo->bstrOptionalProperties) {
        pMetaDataArray->dwMDDataLen = ((DWORD)wcslen((LPWSTR)pClassInfo->bstrOptionalProperties)+1)*2;
        pMetaDataArray->pbMDData = (unsigned char *)pClassInfo->bstrOptionalProperties;
    }
    else {
        pMetaDataArray->dwMDDataLen = 0;
        pMetaDataArray->pbMDData = NULL;
    }


error:

    RRETURN(hr);
}



HRESULT
GenerateNewMetaID(
    LPWSTR pszServerName,
    IMSAdminBase *pAdminBase,
    PDWORD pdwMetaID
    )
{

    HRESULT hr = S_OK;
    DWORD dwMetaId = 0;
    METADATA_HANDLE hObjHandle = NULL;
    DWORD dwBufferSize = sizeof(DWORD);
    METADATA_RECORD mdrMDData;
    CCredentials localCred;
    LPBYTE pBuffer = (LPBYTE)&dwMetaId;

    hr = OpenAdminBaseKey(
            localCred,
            pszServerName,
            IIS_MD_ADSI_SCHEMA_PATH_W,
            METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
            &pAdminBase,
            &hObjHandle
            );
    BAIL_ON_FAILURE(hr);

    MD_SET_DATA_RECORD(&mdrMDData,
                   MD_SCHEMA_METAID,
                   METADATA_NO_ATTRIBUTES,
                   IIS_MD_UT_SERVER,
                   DWORD_METADATA,
                   dwBufferSize,
                   pBuffer);

    hr = pAdminBase->GetData(
            hObjHandle,
            L"",
            &mdrMDData,
            &dwBufferSize
            );
    BAIL_ON_FAILURE(hr);

    *pdwMetaID = dwMetaId;

    //
    // increment metaid by 1 for next property
    //

    dwMetaId++;

    hr = pAdminBase->SetData(
             hObjHandle,
             L"",
             &mdrMDData
             );
    BAIL_ON_FAILURE(hr);
    
error:

    if (hObjHandle) {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
    }

    RRETURN(hr);
}
   

HRESULT
CheckDuplicateNames(
    LPWSTR pszNames
    ) 
{
    WCHAR szName[MAX_PATH];
    WCHAR szName2[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)pszNames;
    LPWSTR CheckList = (LPWSTR)pszNames;
    DWORD dwCount = 0;

    if (ObjectList == NULL ||
        (ObjectList != NULL && *ObjectList == NULL)) {
        RRETURN(S_OK);
    }

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            CheckList = pszNames;
            while ((CheckList = grabProp(szName2, CheckList)) != NULL) {
                if (*szName2 != L'\0') {
                    if (!_wcsicmp(szName, szName2)) {
                        dwCount++; 
                    }
                }
            }
            if (dwCount > 1) {
                RRETURN(E_ADS_BAD_PARAMETER);
            }
            dwCount = 0;
        }
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\ctree.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  ctree.cxx
//
//  Contents:  Microsoft ADs IIS Provider Tree Object
//
//  History:   25-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

//  Class CIISTree

DEFINE_IDispatch_Implementation(CIISTree)
DEFINE_IADs_Implementation(CIISTree)


CIISTree::CIISTree():
				_pAdminBase(NULL),
				_pSchema(NULL),
                _pPropertyCache(NULL)
{

    VariantInit(&_vFilter);

    ENLIST_TRACKING(CIISTree);
}

/* #pragma INTRINSA suppress=all */
HRESULT
CIISTree::CreateServerObject(
    BSTR bstrADsPath,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszADsParent = NULL;
    WCHAR szCommonName[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];

    pszADsParent = AllocADsStr(bstrADsPath);

    if (!pszADsParent) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszADsParent = L'\0';

    //
    // Determine the parent and rdn name
    //

    hr = BuildADsParentPath(
                bstrADsPath,
                pszADsParent,
                szCommonName
                );

    //
    // call the helper function
    //

    hr = CIISTree::CreateServerObject(
                 pszADsParent,
                 szCommonName,
                 L"user",
                 Credentials,
                 dwObjectState,
                 riid,
                 ppvObj
                );

error:

    if (pszADsParent) {
        FreeADsStr(pszADsParent);
    }

    RRETURN(hr);
}


HRESULT
CIISTree::CreateServerObject(
    BSTR Parent,
    BSTR CommonName,
    BSTR ClassName,
    CCredentials& Credentials,
    DWORD dwObjectState,
    REFIID riid,
    void **ppvObj
    )
{
    CIISTree FAR * pTree = NULL;
    HRESULT hr = S_OK;

    hr = AllocateTree(Credentials, &pTree);
    BAIL_ON_FAILURE(hr);

    hr = pTree->InitializeCoreObject(
                Parent,
                CommonName,
                ClassName,
                L"",
                CLSID_IISTree,
                dwObjectState
                );
    BAIL_ON_FAILURE(hr);

    hr = pTree->_pPropertyCache->InitializePropertyCache( CommonName );
    BAIL_ON_FAILURE(hr);

    hr = pTree->QueryInterface(riid, ppvObj);
    BAIL_ON_FAILURE(hr);

    pTree->Release();

    RRETURN(hr);

error:

    delete pTree;
    RRETURN(hr);
}

CIISTree::~CIISTree( )
{
    VariantClear(&_vFilter);

    delete _pDispMgr;

    delete _pPropertyCache;
}

STDMETHODIMP
CIISTree::QueryInterface(REFIID iid, LPVOID FAR* ppv)
{
    if (IsEqualIID(iid, IID_IUnknown))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADsContainer))
    {
        *ppv = (IADsContainer FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IADs))
    {
        *ppv = (IADs FAR *) this;
    }
    else if (IsEqualIID(iid, IID_IDispatch))
    {
        *ppv = (IADs FAR *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
    return NOERROR;
}

HRESULT
CIISTree::SetInfo()
{
    HRESULT hr = S_OK;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {

        hr = IISCreateObject();
        BAIL_ON_FAILURE(hr);

        //
        // If the create succeded, set the object type to bound
        //

        SetObjectState(ADS_OBJECT_BOUND);

    }else {

        hr = IISSetObject();
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
CIISTree::IISSetObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszIISPathName = NULL;
    HRESULT hr = S_OK;


    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Add Set functionality: sophiac
    //


error:


    if (pszIISPathName) {

        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

HRESULT
CIISTree::IISCreateObject()
{
    DWORD dwStatus = 0L;
    LPWSTR pszIISParentName = NULL;
    HRESULT hr = S_OK;


    hr = BuildIISPathFromADsPath(
                _Parent,
                &pszIISParentName
                );
    BAIL_ON_FAILURE(hr);

    // 
    //  Add Create functionality: sophiac
    // 

error:


    if (pszIISParentName) {

        FreeADsStr(pszIISParentName);
    }

    RRETURN(hr);
}

HRESULT
CIISTree::GetInfo()
{
    RRETURN(GetInfo(TRUE));
}

HRESULT
CIISTree::GetInfo(
    BOOL fExplicit
    )
{
    DWORD dwStatus = 0L;
    HANDLE hObject = NULL;
    LPWSTR pszIISPathName = NULL;
    HRESULT hr;

    if (GetObjectState() == ADS_OBJECT_UNBOUND) {
        hr = E_ADS_OBJECT_UNBOUND;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    // Add get functionality : sophiac
    //

error:


    if (pszIISPathName) {

        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

/* IADsContainer methods */

STDMETHODIMP
CIISTree::get_Count(long FAR* retval)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::get_Filter(THIS_ VARIANT FAR* pVar)
{
    VariantInit(pVar);
    RRETURN(VariantCopy(pVar, &_vFilter));
}

STDMETHODIMP
CIISTree::put_Filter(THIS_ VARIANT Var)
{
    RRETURN(VariantCopy(&_vFilter, &Var));
}

STDMETHODIMP
CIISTree::put_Hints(THIS_ VARIANT Var)
{
    RRETURN( E_NOTIMPL);
}


STDMETHODIMP
CIISTree::get_Hints(THIS_ VARIANT FAR* pVar)
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::GetObject(
    BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;

    hr = ::RelativeGetObject(
                _ADsPath,
                ClassName,
                RelativeName,
                _Credentials,
                ppObject,
                FALSE
                );

    RRETURN(hr);

}

STDMETHODIMP
CIISTree::get__NewEnum(
    THIS_ IUnknown * FAR* retval
    )
{
    HRESULT hr;
    IUnknown FAR* punkEnum=NULL;
    IEnumVARIANT * penum = NULL;


    *retval = NULL;

    hr = CIISTreeEnum::Create(
                (CIISTreeEnum **)&penum,
                _ADsPath,
                _vFilter,
                _Credentials
                );
    BAIL_ON_FAILURE(hr);

    hr = penum->QueryInterface(
                IID_IUnknown,
                (VOID FAR* FAR*)retval
                );
    BAIL_ON_FAILURE(hr);

    if (penum) {
        penum->Release();
    }

    RRETURN(NOERROR);

error:

    if (penum) {
        delete penum;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::Create(
    THIS_ BSTR ClassName,
    BSTR RelativeName,
    IDispatch * FAR* ppObject
    )
{
    HRESULT hr = S_OK;
    IADs * pADs  = NULL;
    DWORD dwSyntaxId = 0;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    //
    // Validate if this class really exists in the schema
    // and validate that this object can be created in this
    // container
    //

    CLexer Lexer(_ADsPath);

    BAIL_ON_FAILURE(hr);
    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);
    hr = InitServerInfo(_Credentials, pObjectInfo->TreeName, &_pAdminBase, &_pSchema);
    BAIL_ON_FAILURE(hr);
	hr = _pSchema->ValidateClassName(ClassName);
    BAIL_ON_FAILURE(hr);
	hr = CIISGenObject::CreateGenericObject(
                    _ADsPath,
                    RelativeName,
                    ClassName,
                    _Credentials,
                    ADS_OBJECT_UNBOUND,
                    IID_IDispatch,
                    (void **)ppObject
                    );
    BAIL_ON_FAILURE(hr);
    RRETURN(hr);
	
error:
    RRETURN(hr);
}

STDMETHODIMP
CIISTree::Delete(
    THIS_ BSTR bstrClassName,
    BSTR bstrRelativeName
    )
{
    LPWSTR pszIISPathName = NULL;
    HRESULT hr = S_OK;

    hr = BuildIISPathFromADsPath(
                _ADsPath,
                &pszIISPathName
                );
    BAIL_ON_FAILURE(hr);

    //
    //
    // Add delete functionality : sophiac
    //

error:

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    RRETURN(hr);
}

STDMETHODIMP
CIISTree::CopyHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}

STDMETHODIMP
CIISTree::MoveHere(
    THIS_ BSTR SourceName,
    BSTR NewName,
    IDispatch * FAR* ppObject
    )
{
    RRETURN(E_NOTIMPL);
}


HRESULT
CIISTree::AllocateTree(
    CCredentials& Credentials,
    CIISTree ** ppTree
    )
{
    CIISTree FAR * pTree = NULL;
    CAggregatorDispMgr FAR * pDispMgr = NULL;
    CPropertyCache FAR * pPropertyCache = NULL;
    HRESULT hr = S_OK;

    pTree = new CIISTree();
    if (pTree == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregatorDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADs,
                           (IADs *)pTree,
                           DISPID_REGULAR
                           );
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                           LIBID_ADs,
                           IID_IADsContainer,
                           (IADsContainer *)pTree,
                           DISPID_NEWENUM
                           );
    BAIL_ON_FAILURE(hr);

    hr = CPropertyCache::createpropertycache(
                        (CCoreADsObject FAR *)pTree,
                        &pPropertyCache
                        );
    BAIL_ON_FAILURE(hr);



    pTree->_Credentials = Credentials;
    pTree->_pPropertyCache = pPropertyCache;
    pTree->_pDispMgr = pDispMgr;
    *ppTree = pTree;

    RRETURN(hr);

error:
    if (pDispMgr)
    {
        delete  pDispMgr;
    }

    if (pTree)
    {
        delete pTree;
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISTree::Get(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    if (dwNumValues == 1) {

        hr  = IISTypeToVarTypeCopy(
                   _pSchema,
                   bstrName,
                   pIISSrcObjects,
                   pvProp,
                   FALSE
                   );
    }else {

        hr = IISTypeToVarTypeCopyConstruct(
                    _pSchema,
                    bstrName,
                    pIISSrcObjects,
                    dwNumValues,
                    pvProp,
                    FALSE
                    );

    }
    BAIL_ON_FAILURE(hr);

error:
    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}

/* INTRINSA suppress=null_pointers, uninitialized */
STDMETHODIMP
CIISTree::GetEx(
    THIS_ BSTR bstrName,
    VARIANT FAR* pvProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;
    DWORD dwSyntax;
    DWORD dwNumValues = 0;
    LPIISOBJECT pIISSrcObjects = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // check if property is a supported property
    //

    hr = _pSchema->LookupSyntaxID(bstrName, &dwSyntax);
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY) {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
    }

    //
    // retrieve data object from cache; if one exists
    //

    if (dwSyntax == IIS_SYNTAX_ID_BOOL_BITMASK || dwSyntax == IIS_SYNTAX_ID_BINARY)
    {
    hr = _pPropertyCache->getproperty(
                wchName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    else
    {
    hr = _pPropertyCache->getproperty(
                bstrName,
                &dwSyntaxId,
                &dwNumValues,
                &pIISSrcObjects
                );
    }
    BAIL_ON_FAILURE(hr);

    //
    // reset it to its syntax id if BITMASK type
    //

    pIISSrcObjects->IISType = dwSyntax;

    //
    // translate the IIS objects to variants
    //

    hr = IISTypeToVarTypeCopyConstruct(
                _pSchema,
                bstrName,
                pIISSrcObjects,
                dwNumValues,
                pvProp,
                TRUE
                );
    BAIL_ON_FAILURE(hr);

error:
    if (pIISSrcObjects) {

        IISTypeFreeIISObjects(
            pIISSrcObjects,
            dwNumValues
            );
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::Put(
    THIS_ BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    WCHAR wchName[MAX_PATH];

    //
    // Issue: How do we handle multi-valued support
    //

    if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {
        if(V_ISBYREF(&vProp)) {

            hr  = ConvertByRefSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
        else {

            hr  = ConvertSafeArrayToVariantArray(
                        vProp,
                        &pVarArray,
                        &dwNumValues
                        );
            BAIL_ON_FAILURE(hr);
            pvProp = pVarArray;
        }
    }
    else {

        dwNumValues = 1;
        pvProp = &vProp;
    }

    //
    // Check if this is a legal property and it syntax ID
    //

    hr = _pSchema->LookupSyntaxID( bstrName, &dwSyntaxId);
    BAIL_ON_FAILURE(hr);

    //
    // check if the variant maps to the syntax of this property
    //

    hr = VarTypeToIISTypeCopyConstruct(
                    dwSyntaxId,
                    pvProp,
                    dwNumValues,
                    &pIISDestObjects,
                    FALSE
                    );
    BAIL_ON_FAILURE(hr);

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //
    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) 
    {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    CACHE_PROPERTY_MODIFIED,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }

    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISTree::PutEx(
    THIS_ long lnControlCode,
    BSTR bstrName,
    VARIANT vProp
    )
{
    HRESULT hr = S_OK;
    DWORD dwSyntaxId  = 0;
    DWORD dwIndex = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    DWORD dwNumValues = 0;
    DWORD dwFlags = 0;

    VARIANT * pVarArray = NULL;
    VARIANT * pvProp = NULL;
    WCHAR wchName[MAX_PATH];

    switch (lnControlCode) {
    case ADS_PROPERTY_CLEAR:
        dwFlags = CACHE_PROPERTY_CLEARED;

        pIISDestObjects = NULL;
        dwNumValues = 0;

        break;

    case ADS_PROPERTY_UPDATE:
        dwFlags = CACHE_PROPERTY_MODIFIED;

        //
        // Now begin the rest of the processing
        //

        if ((V_VT(&vProp) &  VT_VARIANT) &&  V_ISARRAY(&vProp)) {
            if (V_ISBYREF(&vProp)) {
                hr  = ConvertByRefSafeArrayToVariantArray(
                            vProp,
                            &pVarArray,
                            &dwNumValues
                            );
                BAIL_ON_FAILURE(hr);
            }
            else {
                hr  = ConvertSafeArrayToVariantArray(
                            vProp,
                            &pVarArray,
                            &dwNumValues
                            );
                BAIL_ON_FAILURE(hr);
            }
            pvProp = pVarArray;

        }else {

            hr = E_FAIL;
            BAIL_ON_FAILURE(hr);
        }

        //
        // check if the variant maps to the syntax of this property
        //

        hr = VarTypeToIISTypeCopyConstruct(
                        dwSyntaxId,
                        pvProp,
                        dwNumValues,
                        &pIISDestObjects,
                        TRUE
                        );
        BAIL_ON_FAILURE(hr);

        break;

    default:
       RRETURN(hr = E_ADS_BAD_PARAMETER);

    }

    //
    // check if property is BITMASK type;
    // if BITMASK type, get corresponding DWORD flag property
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK) {
        VARIANT vGetProp;
        DWORD dwMask;
        DWORD dwFlagValue;

        hr = _pSchema->LookupBitMask(bstrName, &dwMask);
        BAIL_ON_FAILURE(hr);

        // 
        // get its corresponding DWORD flag value
        // 

        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);

        VariantInit(&vGetProp);
        hr = Get(wchName, &vGetProp);
        BAIL_ON_FAILURE(hr);

        dwFlagValue = V_I4(&vGetProp);
 
        if (pIISDestObjects->IISValue.value_1.dwDWORD) {
            dwFlagValue |= dwMask;
        }
        else {
            dwFlagValue &= ~dwMask;
        }

        pIISDestObjects->IISValue.value_1.dwDWORD = dwFlagValue;
        pIISDestObjects->IISType = IIS_SYNTAX_ID_DWORD;
        bstrName = wchName;
    }

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY) 
    {
        hr = _pSchema->LookupFlagPropName(bstrName, (LPWSTR)wchName);
        BAIL_ON_FAILURE(hr);
        bstrName = wchName;
    }

    //
    // Find this property in the cache
    //

    hr = _pPropertyCache->findproperty(
                        bstrName,
                        &dwIndex
                        );

    //
    // If this property does not exist in the
    // cache, add this property into the cache.
    //

    if (FAILED(hr)) {
        hr = _pPropertyCache->addproperty(
                    bstrName,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
        //
        // If the operation fails for some reason
        // move on to the next property
        //
        BAIL_ON_FAILURE(hr);

    }

    //
    // Now update the property in the cache
    //

    hr = _pPropertyCache->putproperty(
                    bstrName,
                    dwFlags,
                    dwSyntaxId == IIS_SYNTAX_ID_BOOL_BITMASK ? 
                                      IIS_SYNTAX_ID_DWORD : dwSyntaxId,
                    dwNumValues,
                    pIISDestObjects
                    );
    BAIL_ON_FAILURE(hr);

error:

    if (pIISDestObjects) {
        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumValues
                );

    }


    if (pVarArray) {

        DWORD i = 0;

        for (i = 0; i < dwNumValues; i++) {
            VariantClear(pVarArray + i);
        }
        FreeADsMem(pVarArray);
    }

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\fsmacro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:  fsmacro.h
//
//  Contents:  Macros for adsi put/get methods
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#define PUT_PROPERTY_LONG(this, Property) \
                RRETURN(put_LONG_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        l##Property \
                                        ))

#define GET_PROPERTY_LONG(this, Property) \
                RRETURN(get_LONG_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_BSTR(this, Property) \
                RRETURN(put_BSTR_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        bstr##Property \
                                        ))

#define GET_PROPERTY_BSTR(this, Property) \
                RRETURN(get_BSTR_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(put_VARIANT_BOOL_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        f##Property\
                                        ))

#define GET_PROPERTY_VARIANT_BOOL(this, Property) \
                RRETURN(get_VARIANT_BOOL_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_DATE(this, Property) \
                RRETURN(put_DATE_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        da##Property \
                                        ))

#define GET_PROPERTY_DATE(this, Property) \
                RRETURN(get_DATE_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))


#define PUT_PROPERTY_VARIANT(this, Property) \
                RRETURN(put_VARIANT_Property( \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        v##Property \
                                        ))

#define GET_PROPERTY_VARIANT(this, Property) \
                RRETURN(get_VARIANT_Property(  \
                                        (IADs *)this, \
                                        TEXT(#Property), \
                                        retval \
                                        ))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\extension.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       extension.cxx
//
//  Contents:   3rd party extension mgmt functions 
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop


LPCWSTR lpszTopLevel = L"SOFTWARE\\Microsoft\\ADs\\Providers\\IIS";
LPCWSTR lpszExtensions = L"Extensions";

PCLASS_ENTRY gpClassHead = NULL;

PCLASS_ENTRY
BuildClassesList()
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;
    HKEY hExtensionRootKey = NULL;

    HKEY hClassKey = NULL;

    DWORD dwIndex = 0;
    WCHAR lpszClassName[MAX_PATH];
    DWORD dwchClassName = 0;
    PCLASS_ENTRY pClassHead = NULL;
    PCLASS_ENTRY pClassEntry = NULL;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     lpszTopLevel,
                     0,
                     KEY_READ,
                     &hTopLevelKey
                     ) != ERROR_SUCCESS)
    {
        goto CleanupAndExit;
    }

    if (RegOpenKeyEx(hTopLevelKey,
                     lpszExtensions,
                     0,
                     KEY_READ,
                     &hExtensionRootKey
                     ) != ERROR_SUCCESS)

    {
        goto CleanupAndExit;
    }

    memset(lpszClassName, 0, sizeof(lpszClassName));
    dwchClassName = (int) (sizeof(lpszClassName) / sizeof(WCHAR));

    while(RegEnumKeyEx(hExtensionRootKey,
                     dwIndex,
                     lpszClassName,
                     &dwchClassName,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hExtensionRootKey,
                         lpszClassName,
                         0,
                         KEY_READ,
                         &hClassKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        pClassEntry  = BuildClassEntry(
                                lpszClassName,
                                hClassKey
                                );

        if (pClassEntry) {

            pClassEntry->pNext = pClassHead;
            pClassHead = pClassEntry;
        }

        if (hClassKey) {
            CloseHandle(hClassKey);
        }

        memset(lpszClassName, 0, sizeof(lpszClassName));
        dwchClassName = (int) (sizeof(lpszClassName) / sizeof(WCHAR));
        dwIndex++;
    }

CleanupAndExit:

    if (hExtensionRootKey) {
        RegCloseKey(hExtensionRootKey);
    }

    if (hTopLevelKey) {
        RegCloseKey(hTopLevelKey);
    }

    return(pClassHead);
}

VOID
FreeClassesList(
    PCLASS_ENTRY pClassHead
    )
{
    PCLASS_ENTRY pDelete;

    while (pClassHead) {

        pDelete = pClassHead;
        pClassHead = pClassHead->pNext;

        FreeClassEntry(pDelete);
    }

    return;
}

PCLASS_ENTRY
BuildClassEntry(
    LPWSTR lpszClassName,
    HKEY hClassKey
    )
{
    HKEY hTopLevelKey = NULL;
    HKEY hExtensionKey = NULL;

    DWORD dwIndex = 0;
    DWORD dwchExtensionCLSID = 0;
    WCHAR lpszExtensionCLSID[MAX_PATH];
    PCLASS_ENTRY pClassEntry = NULL;
    PEXTENSION_ENTRY pExtensionHead = NULL;
    PEXTENSION_ENTRY pExtensionEntry = NULL;

    pClassEntry =  (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (!pClassEntry) {

        goto CleanupAndExit;
    }

    wcscpy(pClassEntry->szClassName, lpszClassName);

    memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
    dwchExtensionCLSID = (int) (sizeof(lpszExtensionCLSID) / sizeof(WCHAR));

    while(RegEnumKeyEx(hClassKey,
                     dwIndex,
                     lpszExtensionCLSID,
                     &dwchExtensionCLSID,
                     NULL,
                     NULL,
                     NULL,
                     NULL
                     ) == ERROR_SUCCESS)
    {
        //
        // Read namespace
        //

        if (RegOpenKeyEx(hClassKey,
                         lpszExtensionCLSID,
                         0,
                         KEY_READ,
                         &hExtensionKey
                         ) != ERROR_SUCCESS){
            goto CleanupAndExit;
        }

        //
        // Read the Interfaces that this Extension supports
        //

        pExtensionEntry = BuildExtensionEntry(
                                lpszExtensionCLSID,
                                hExtensionKey
                                );

        if (pExtensionEntry) {

            wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);

            pExtensionEntry->pNext = pExtensionHead;
            pExtensionHead = pExtensionEntry;
        }


        if (hExtensionKey) {

            CloseHandle(hExtensionKey);
        }

        memset(lpszExtensionCLSID, 0, sizeof(lpszExtensionCLSID));
        dwchExtensionCLSID = (int) (sizeof(lpszExtensionCLSID) / sizeof(WCHAR));
        dwIndex++;

    }

    pClassEntry->pExtensionHead = pExtensionHead;




CleanupAndExit:

    return(pClassEntry);
}


PEXTENSION_ENTRY
BuildExtensionEntry(
    LPWSTR lpszExtensionCLSID,
    HKEY hExtensionKey
    )
{
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pInterfaceHead = NULL;
    WCHAR lpszInterfaces[MAX_PATH];
    DWORD dwchInterfaces = 0;
    LPWSTR psz = NULL;
    WCHAR Interface[MAX_PATH];
    HRESULT hr = S_OK;


    pExtensionEntry =  (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (!pExtensionEntry) {

        goto CleanupAndExit;
    }

    memset(lpszInterfaces, 0, sizeof(lpszInterfaces));
    dwchInterfaces = sizeof(lpszInterfaces);

    RegQueryValueEx(
            hExtensionKey,
            L"Interfaces",
            NULL,
            NULL,
            (LPBYTE) lpszInterfaces,
            &dwchInterfaces
            );

    psz = lpszInterfaces;

    while (psz && *psz) {

       lstrcpy(Interface, psz);

       // skip (length) + 1
       // lstrlen returns length sans '\0'


       pInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

       if (pInterfaceEntry) {

           wcscpy(pInterfaceEntry->szInterfaceIID, Interface);

           hr = IIDFromString(Interface, &(pInterfaceEntry->iid));

           pInterfaceEntry->pNext = pInterfaceHead;
           pInterfaceHead = pInterfaceEntry;

       }

       psz = psz + lstrlen(psz) + 1;

    }

    wcscpy(pExtensionEntry->szExtensionCLSID, lpszExtensionCLSID);
    hr = CLSIDFromString(lpszExtensionCLSID, &(pExtensionEntry->ExtCLSID));

    pExtensionEntry->pIID = pInterfaceHead;

CleanupAndExit:

    return(pExtensionEntry);
}


void
FreeInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    if (pInterfaceEntry) {

        FreeADsMem(pInterfaceEntry);
    }
}


void
FreeExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PINTERFACE_ENTRY pInterfaceEntry = NULL;
    PINTERFACE_ENTRY pTemp = NULL;

    if (pExtensionEntry) {

        pInterfaceEntry = pExtensionEntry->pIID;

        while (pInterfaceEntry) {

            pTemp = pInterfaceEntry->pNext;

            if (pInterfaceEntry) {

                FreeInterfaceEntry(pInterfaceEntry);
            }

            pInterfaceEntry = pTemp;

        }

        //
        // Now unload the Extension Object
        //

        if (pExtensionEntry->pUnknown) {

            //
            // Call non-delegating Release to release ref. count on innner
            // object to inner object -> inner object self destroyed.
            // 
            (pExtensionEntry->pUnknown)->Release();

        }


        FreeADsMem(pExtensionEntry);
    }

    return;
}

void
FreeClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{

    PEXTENSION_ENTRY pExtensionEntry = NULL;
    PEXTENSION_ENTRY pTemp = NULL;

    if (pClassEntry) {

        pExtensionEntry = pClassEntry->pExtensionHead;

        while (pExtensionEntry) {

            pTemp = pExtensionEntry->pNext;

            if (pExtensionEntry) {

                FreeExtensionEntry(pExtensionEntry);
            }

            pExtensionEntry = pTemp;

        }

        FreeADsMem(pClassEntry);
    }

    return;
}


PINTERFACE_ENTRY
MakeCopyofInterfaceEntry(
    PINTERFACE_ENTRY pInterfaceEntry
    )
{
    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    pNewInterfaceEntry = (PINTERFACE_ENTRY)AllocADsMem(sizeof(INTERFACE_ENTRY));

    if (pNewInterfaceEntry) {

        wcscpy(pNewInterfaceEntry->szInterfaceIID, pInterfaceEntry->szInterfaceIID);
        memcpy(&(pNewInterfaceEntry->iid), &(pInterfaceEntry->iid), sizeof(GUID));
    }

    return(pNewInterfaceEntry);
}



PEXTENSION_ENTRY
MakeCopyofExtensionEntry(
    PEXTENSION_ENTRY pExtensionEntry
    )
{
    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PINTERFACE_ENTRY pInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceEntry = NULL;

    PINTERFACE_ENTRY pNewInterfaceHead = NULL;


    pInterfaceEntry = pExtensionEntry->pIID;

    while (pInterfaceEntry) {

        pNewInterfaceEntry = MakeCopyofInterfaceEntry(pInterfaceEntry);

        if (pNewInterfaceEntry) {

            pNewInterfaceEntry->pNext = pNewInterfaceHead;
            pNewInterfaceHead = pNewInterfaceEntry;
        }

        pInterfaceEntry = pInterfaceEntry->pNext;

    }

    pNewExtensionEntry = (PEXTENSION_ENTRY)AllocADsMem(sizeof(EXTENSION_ENTRY));

    if (pNewExtensionEntry) {

        wcscpy(
            pNewExtensionEntry->szExtensionCLSID, 
            pExtensionEntry->szExtensionCLSID
            );

        memcpy(
            &(pNewExtensionEntry->ExtCLSID), 
            &(pExtensionEntry->ExtCLSID), 
            sizeof(GUID)
            );

        pNewExtensionEntry->pIID = pNewInterfaceHead;


        //
        // Initialize fields we won't know the values of until an instacne of 
        // the extension is created and aggregated (loaded).
        //

        pNewExtensionEntry->pUnknown=NULL;
        pNewExtensionEntry->pPrivDisp=NULL;
        pNewExtensionEntry->pADsExt=NULL;
        pNewExtensionEntry->fDisp=FALSE;    
        pNewExtensionEntry->dwExtensionID = (DWORD) -1; //invalid dwExtensionID 

        //
        // let class entry handle pNext
        //
    }

    return(pNewExtensionEntry);
}


PCLASS_ENTRY
MakeCopyofClassEntry(
    PCLASS_ENTRY pClassEntry
    )
{
    PCLASS_ENTRY pNewClassEntry = NULL;

    PEXTENSION_ENTRY pExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionEntry = NULL;

    PEXTENSION_ENTRY pNewExtensionHead = NULL;


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        pNewExtensionEntry = MakeCopyofExtensionEntry(pExtensionEntry);

        if (pNewExtensionEntry) {

            pNewExtensionEntry->pNext = pNewExtensionHead;
            pNewExtensionHead = pNewExtensionEntry;
        }

        pExtensionEntry = pExtensionEntry->pNext;

    }

    pNewClassEntry = (PCLASS_ENTRY)AllocADsMem(sizeof(CLASS_ENTRY));

    if (pNewClassEntry) {

        wcscpy(pNewClassEntry->szClassName, pClassEntry->szClassName);

        pNewClassEntry->pExtensionHead = pNewExtensionHead;

    }

    return(pNewClassEntry);
}


CRITICAL_SECTION g_ExtCritSect;

#define ENTER_EXTENSION_CRITSECT()  EnterCriticalSection(&g_ExtCritSect)
#define LEAVE_EXTENSION_CRITSECT()  LeaveCriticalSection(&g_ExtCritSect)

HRESULT
ADSIGetExtensionList(
    LPWSTR pszClassName,
    PCLASS_ENTRY * ppClassEntry
    )
{

    PCLASS_ENTRY pTempClassEntry = NULL;
    PCLASS_ENTRY pClassEntry = NULL;
    ENTER_EXTENSION_CRITSECT();

    pTempClassEntry = gpClassHead;

    while (pTempClassEntry) {


        if (!_wcsicmp(pTempClassEntry->szClassName, pszClassName)) {

            //
            // Make a copy of this entire extension and
            // hand it over to the calling entity.
            //

            pClassEntry = MakeCopyofClassEntry(pTempClassEntry);

            *ppClassEntry = pClassEntry;

            LEAVE_EXTENSION_CRITSECT();

            RRETURN(S_OK);

        }

        pTempClassEntry = pTempClassEntry->pNext;

   }


   *ppClassEntry = NULL;

   LEAVE_EXTENSION_CRITSECT();

   RRETURN(S_OK);

}


//
// Instantiate extension objects listed in <pClassEntry> as aggregatees of
// aggregator <pUnkOuter>. Initialize extensions with <Credentials>. 
//
// Max Load 127 extensions. Return S_FALSE if more extension in <pClassEntry>
// EXTTODO:   define S_??? in future for > unloaded extension -> passed to
//            ADSI clients.
//

HRESULT
ADSILoadExtensions2(
    IUnknown FAR * pUnkOuter,
    CCredentials& Credentials,
    PCLASS_ENTRY pClassEntry
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtEntry = NULL;
    DWORD dwExtensionID = MIN_EXTENSION_ID;  
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;
    VARIANT varUserName;
    VARIANT varPassword;
    VARIANT varAuthFlags;
    PVARIANT pvarUserName = &varUserName;
    PVARIANT pvarPassword = &varPassword;
    PVARIANT pvarAuthFlags = &varAuthFlags;
    BOOL    fReturnError = FALSE;


    ASSERT(pUnkOuter);


    if (pClassEntry)
    {
        pExtEntry=pClassEntry->pExtensionHead;
    }

    if (!pClassEntry || !pExtEntry) {
        RRETURN(S_OK);
    }


    VariantInit(pvarUserName);
    VariantInit(pvarPassword);
    VariantInit(pvarAuthFlags);


    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();



    while (pExtEntry) {

        //
        // Max # of extension have been loaded, cannot load more
        //

        if (dwExtensionID>MAX_EXTENSION_ID) {
            
            //
            // EXTTODO: S_FALSE for now. See hdr doc for future plan.
            //
            hr = S_FALSE;   
            break;
        }

        // 
        // create extension object (aggregatee) and ask for Non-delegating
        // IUnknown. Ref count on extension object = 1.
        //

        hr = CoCreateInstance(
                    pExtEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IUnknown,      
                    (void **)&(pExtEntry->pUnknown)
                    );

        //
        // if fail, go to next extesion entry s.t. bad individual extension 
        // cannot block other extensions from loading (no clean up needed)
        //
        // EXTTODO: no warning to user about failure
        //

        if (SUCCEEDED(hr)) {

            pExtEntry->dwExtensionID = dwExtensionID;


            hr = (pExtEntry->pUnknown)->QueryInterface(
                        IID_IADsExtension,
                        (void **) &(pExtEntry->pADsExt)
                        );

            if  (FAILED(hr)) {
            
                //
                // extension does not support the optioanl IADsExtension -> OK.
                // (no clean up needed)
                //

                pExtEntry->pADsExt=NULL;

                pExtEntry->fDisp = FALSE;

            } else {
                
                //
                // Cache the interface ptr but call Release() immediately to 
                // avoid aggregator having a ref count on itself 
                // since IADsExtension inherits from delegating IUnknown.
                // 
                // Note: codes still works if inherit from NonDelegatingIUknown
                //   

                (pExtEntry->pADsExt)->Release() ;

                //       
                // For efficiency, set this flag to FALSE on FIRST encounter of 
                // pADsExt->PrivateGetIDsOfNames()/Invoke() returning E_NOTIMPL.
                // Set as TRUE now s.t. at least first encounter will happen.
                //

                pExtEntry->fDisp = TRUE;


                //
                // Pass its own credentials to extension. Ignore error if any. 
                //

                hr = ADsAllocString(
                        pszUserName,
                        &(pvarUserName->bstrVal)
                        );
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);        
                }
                V_VT(pvarUserName) = VT_BSTR;

                hr = ADsAllocString(
                        pszPassword,
                        &(pvarPassword->bstrVal)
                        );  
                if (FAILED(hr)) {
                    fReturnError = TRUE;
                    BAIL_ON_FAILURE(hr);        
                }
                V_VT(pvarPassword) = VT_BSTR;
            
                V_I4(pvarAuthFlags) = dwAuthFlags;
                V_VT(pvarAuthFlags) = VT_I4;

                hr = (pExtEntry->pADsExt)->Operate(
                        ADS_EXT_INITCREDENTIALS,
                        varUserName, 
                        varPassword,
                        varAuthFlags
                        );
            } 

        } // end if CoCreateInstance() succeeded  


        pExtEntry = pExtEntry->pNext;


        //
        // ++ extension ID even if creat'n of extension fails just to be safe 
        // - chuck's stuff :)
        //

        dwExtensionID++;                
    
    }   // end while 



error:

    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    VariantClear(pvarUserName);
    VariantClear(pvarPassword);
    VariantClear(pvarAuthFlags); 

    if (fReturnError) {
        RRETURN(hr);        // fetal error, 
    }
    else {
        RRETURN(S_OK);      // "okay" error if any, optional support 
    }
    
}

HRESULT
ADSILoadExtensions(
    IUnknown FAR * pUnkOuter,
    CCredentials& Credentials,
    PCLASS_ENTRY pClassEntry,
    LPTSTR pszClassName
    )

{
    HRESULT hr = S_OK;
    PEXTENSION_ENTRY pExtensionEntry = NULL;
    DWORD dwExtensionID = 1;
    IPrivateDispatch * pPrivDisp = NULL;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;
    DWORD dwAuthFlags = 0;

    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr)) {
        RRETURN(S_OK);
    }

    dwAuthFlags = Credentials.GetAuthFlags();


    pExtensionEntry = pClassEntry->pExtensionHead;

    while (pExtensionEntry) {

        hr = CoCreateInstance(
                    pExtensionEntry->ExtCLSID,
                    pUnkOuter,
                    CLSCTX_INPROC_SERVER,
                    IID_IPrivateUnknown,
                    (void **)&(pExtensionEntry->pUnknown)
                    );


        if (SUCCEEDED(hr)) {


            hr = (pExtensionEntry->pUnknown)->ADSIInitializeObject(
                                                    pszUserName,
                                                    pszPassword,
                                                    dwAuthFlags
                                                    );

            pExtensionEntry->dwExtensionID = dwExtensionID;

            hr = (pExtensionEntry->pUnknown)->QueryInterface(
                                    IID_IPrivateDispatch,
                                    (void **)&pPrivDisp
                                    );
            if (SUCCEEDED(hr)) {

                hr = pPrivDisp->ADSIInitializeDispatchManager(dwExtensionID);

                if (FAILED(hr)) {

                    //
                    // Remember NOT to do a Release here for IPrivateDispatch
                    //

                    pExtensionEntry->fDisp = FALSE;

                    (pExtensionEntry->pUnknown)->Release();


                }else {
                    pExtensionEntry->fDisp = TRUE;
                    pExtensionEntry->pPrivDisp = pPrivDisp;

                    //
                    // Now release  both pointers because we don't want to
                    // have a cyclic reference count
                    //

                    (pExtensionEntry->pPrivDisp)->Release();
                    (pExtensionEntry->pUnknown)->Release();
                }

            }else {
                pExtensionEntry->fDisp = FALSE;

                (pExtensionEntry->pUnknown)->Release();

            }

        }

        pExtensionEntry = pExtensionEntry->pNext;

        dwExtensionID++;

    }


    if (pszUserName) {
        FreeADsStr(pszUserName);
    }

    if (pszPassword) {
        FreeADsStr(pszPassword);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\globals.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997
//
//  File:  globals.cxx
//
//  Contents:
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

#include "globdata.cxx"


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\globdata.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  globdata.cxx
//
//  Contents:  Microsoft ADs IIS Provider schema/property tables
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include "nntpmeta.h"
#include "smtpinet.h"
#include "pop3s.h"
#include "imaps.h"
#include "w3svc.h"

// Include iwamreg.h for EAppMode values
#include <iwamreg.h>

WCHAR *szProviderName = L"IIS";

#define MAX_LONG    (0x7FFFFFFF)
#define MIN_LONG    (0x80000000)
#define MAX_BOOLEAN 1
#define MAX_STRLEN  (256)

#define PROP_RW     0x0000001
#define PROP_RO     0x0000002

// -------------------------------------------------------------
// DANGER! DANGER! DANGER!
//
// If you modify the property list for a class make sure there
// is a comma (,) between each name. Generally this means there
// should be a comma at the end of each line.
//
//--------------------------------------------------------------

CLASSINFO g_aIISClasses[] =
{
        //
        // IIS Classes
        //
        {
                TEXT("IIsObject"),      // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsComputer"),    // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxBandwidthBlocked,MimeMap"),
                NULL,
                TEXT("IIsObject,IIsWebService,IIsFtpService,IIsMimeMap,IIsNntpService,IIsSmtpService,IIsPop3Service,IIsImapService"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,MimeMap,AnonymousUserName,AnonymousUserPass,UseDigestSSP,")
                TEXT("ServerListenBacklog,ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AllowKeepAlive,ServerSize,DisableSocketPooling,AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("CacheISAPI,CGITimeOut,DirectoryLevelsToScan,ContentIndexed,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings,InProcessIsapiApps,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPUResetInterval,")
                TEXT("SslUseDsMapper,")
                TEXT("WAMUserName,WAMUserPass,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName")
                TEXT(",AppPoolId,AllowTransientRegistration,AppAutoStart,BackwardCompatEnabled")
                ,NULL,
                TEXT("IIsObject,IIsWebInfo,IIsWebServer,IIsFilters,IIsApplicationPools"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpService"),  // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,DisableSocketPooling,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("DirectoryLevelsToScan,Realm,")
                TEXT("LogType,LogFilePeriod,LogFileLocaltimeRollover,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("FtpDirBrowseShowLongDate,AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpInfo,IIsFtpServer"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("ContentIndexed,KeyType,ServerState,ServerComment,MaxBandwidth,")
                TEXT("ServerAutoStart,ServerSize,DisableSocketPooling,ServerListenBacklog,ServerListenTimeout,ServerBindings,SecureBindings,MaxConnections,ConnectionTimeout,")
                TEXT("AllowKeepAlive,CGITimeout,MaxEndpointConnections,UseDigestSSP,")
                TEXT("CacheISAPI,MimeMap,AnonymousUserName,AnonymousUserPass,FrontPageWeb,")
                TEXT("AnonymousPasswordSync,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,EnableDirBrowsing,DefaultDoc,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,")
                TEXT("EnableDocFooter,DefaultDocFooter,HttpRedirect,LogonMethod,")
                TEXT("NTAuthenticationProviders,AuthBasic,AuthAnonymous,")
                TEXT("AuthNTLM,AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,CertCheckMode,RevocationFreshnessTime,RevocationURLRetrievalTimeout,")
                TEXT("CertNoRevocCheck,CertCacheRetrievalOnly,CertCheckRevocationFreshnessTime,CertNoUsageCheck,")
                TEXT("AccessSSLMapCert,AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,AspSessionTimeout,")
                TEXT("AspQueueTimeout,AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("AppRoot,AppFriendlyName,AppIsolated,AppPackageID,AppPackageName,AppOopRecoverLimit,")
                TEXT("AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("ClusterEnabled,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("PasswordExpirePrenotifyDays,PasswordCacheTTL,")
                TEXT("PasswordChangeFlags,MaxBandwidthBlocked,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("DirBrowseFlags,AuthFlags,AuthMD5,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("EnableDefaultDoc,DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("CPUResetInterval,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("SSLCertHash,SSLStoreName,")
                TEXT("ProcessNTCRIfLoggedOn,AllowPathInfoForScriptMappings,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsObject,IIsCertMapper,IIsFilters,IIsWebVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpServer"),   // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,MaxConnections,ServerState,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerListenBacklog,DisableSocketPooling,LogAnonymous,LogNonAnonymous,")
                TEXT("ServerComment,ServerBindings,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ExitMessage,GreetingMessage,BannerMessage,MaxClientsMessage,AnonymousOnly,MSDOSDirOutput,")
                TEXT("ServerSize,AnonymousPasswordSync,AllowAnonymous,DefaultLogonDomain,AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("Realm,ClusterEnabled,FtpDirBrowseShowLongDate,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileLocaltimeRollover,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessFlags,AccessRead,AccessWrite"),
                NULL,
                TEXT("IIsObject,IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsWebFile"),     // Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,UNCAuthenticationPassThrough,UseDigestSSP,")
                TEXT("CGITimeOut,DefaultLogonDomain,LogonMethod,Realm,MimeMap,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("DontLog,HttpExpires,HttpPics,HttpCustomHeaders,HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("AuthFlags,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AuthMD5,AuthPersistence,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole"),
                NULL,                           // Inherits from
                NULL,   // Can Contain
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebDirectory"),// Class Name
                NULL,                   // GUID *objectClassID
                NULL,                   // PrimaryInterfaceGUID
                TEXT(""),               // bstrOID
                FALSE,                  // fAbstract
                NULL,                   // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,AspKeepSessionIDSecure,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebVirtualDir,IIsWebFile,IIsObject"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,AnonymousUserName,AnonymousUserPass,AnonymousPasswordSync,UseDigestSSP,")
                TEXT("AppRoot,AppFriendlyName,AppOopRecoverLimit,AppIsolated,AppPackageName,AppPackageID,")
                TEXT("CacheISAPI,AppAllowDebugging,AppAllowClientDebug,")
                TEXT("AuthBasic,AuthAnonymous,AuthNTLM,")
                TEXT("DefaultLogonDomain,LogonMethod,")
                TEXT("CGITimeOut,Realm,EnableDefaultDoc,")
                TEXT("DirBrowseShowDate,DirBrowseShowTime,DirBrowseShowSize,DirBrowseShowExtension,DirBrowseShowLongDate,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessRead,AccessWrite,AccessExecute,AccessScript,AccessSource,IPSecurity,DontLog,HttpExpires,HttpPics,HttpCustomHeaders,")
                TEXT("AccessNoRemoteRead,AccessNoRemoteWrite,AccessNoRemoteExecute,AccessNoRemoteScript,")
                TEXT("DoStaticCompression,DoDynamicCompression,")
                TEXT("HttpErrors,EnableDocFooter,DefaultDocFooter,HttpRedirect,")
                TEXT("EnableDirBrowsing,DefaultDoc,ContentIndexed,")
                TEXT("CacheControlMaxAge,CacheControlNoCache,CacheControlCustom,CreateProcessAsUser,")
                TEXT("PoolIdcTimeout,PutReadSize,RedirectHeaders,UploadReadAheadSize,")
                TEXT("FrontPageWeb,Path,UNCUserName,UNCPassword,")
                TEXT("UNCAuthenticationPassThrough,AppWamClsid,")
                TEXT("AuthPersistence,AuthPersistSingleRequest,AuthPersistSingleRequestIfProxy,AuthPersistSingleRequestAlwaysIfProxy,AccessFlags,AccessSSLFlags,ScriptMaps,")
                TEXT("SSIExecDisable,EnableReverseDns,CreateCGIWithNewConsole,")
                TEXT("AspBufferingOn,AspLogErrorRequests,AspScriptErrorSentToBrowser,AspScriptErrorMessage,AspAllowOutOfProcComponents,")
                TEXT("AspScriptFileCacheSize,AspDiskTemplateCacheDirectory,AspMaxDiskTemplateCacheFiles,AspScriptEngineCacheMax,AspScriptTimeout,AspSessionTimeout,")
                TEXT("AspEnableParentPaths,AspAllowSessionState,AspScriptLanguage,AspKeepSessionIDSecure,")
                TEXT("AspExceptionCatchEnable,AspCodepage,AspLCID,MimeMap,")
                TEXT("AspQueueTimeout,")
                TEXT("AspEnableAspHtmlFallback,AspEnableChunkedEncoding,")
                TEXT("AspEnableTypelibCache,AspErrorsToNTLog,AspProcessorThreadMax,")
                TEXT("AspTrackThreadingModel,AspRequestQueueMax,AspEnableApplicationRestart,")
                TEXT("AspQueueConnectionTestTime,AspSessionMax,")
                TEXT("PeriodicRestartRequests,PeriodicRestartTime,PeriodicRestartSchedule,ShutdownTimeLimit,")
                TEXT("DirBrowseFlags,AuthMD5,AuthFlags,")
                TEXT("AppPoolId,AllowTransientRegistration,AppAutoStart"),
                NULL,
                TEXT("IIsWebDirectory,IIsWebFile,IIsWebVirtualDir,IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFtpVirtualDir"), // Class Name
                NULL,                     // GUID *objectClassID
                NULL,                     // PrimaryInterfaceGUID
                TEXT(""),                 // bstrOID
                FALSE,                    // fAbstract
                NULL,                     // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,AccessFlags,AccessRead,AccessWrite,DontLog,IPSecurity,FtpDirBrowseShowLongDate"),
                NULL,
                TEXT("IIsFtpVirtualDir"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsFilter"),       // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterPath,FilterDescription,FilterFlags,FilterState,FilterEnabled,")
                TEXT("NotifySecurePort,NotifyNonSecurePort,NotifyReadRawData,NotifyPreProcHeaders,")
                TEXT("NotifyAuthentication,NotifyAuthComplete,NotifyUrlMap,NotifyAccessDenied,NotifySendResponse,")
                TEXT("NotifySendRawData,NotifyLog,NotifyEndOfRequest,NotifyEndOfNetSession,")
                TEXT("NotifyOrderHigh,NotifyOrderMedium,NotifyOrderLow"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsFilters"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,FilterLoadOrder"),
                NULL,
                TEXT("IIsObject,IIsFilter,IIsCompressionSchemes"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionScheme"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcCompressionDll,HcFileExtensions,HcScriptFileExtensions,")
                TEXT("HcMimeType,HcPriority,HcDynamicCompressionLevel,")
                TEXT("HcOnDemandCompLevel,HcCreateFlags"),
                NULL,
                NULL,
                FALSE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCompressionSchemes"), // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,HcCompressionDirectory,HcCacheControlHeader,")
                TEXT("HcExpiresHeader,HcDoDynamicCompression,HcDoStaticCompression,")
                TEXT("HcDoOnDemandCompression,HcDoDiskSpaceLimiting,")
                TEXT("HcNoCompressionForHttp10,HcNoCompressionForProxies,")
                TEXT("HcNoCompressionForRange,HcSendCacheHeaders,HcMaxDiskSpaceUsage,")
                TEXT("HcIoBufferSize,HcCompressionBufferSize,HcMaxQueueLength,")
                TEXT("HcFilesDeletedPerDiskFree,HcMinFileSizeForComp"),
                NULL,
                TEXT("IIsObject,IIsCompressionScheme"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsCertMapper"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsMimeMap"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,MimeMap"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModules"),   // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType"),
                NULL,
                TEXT("IIsObject,IIsLogModule,IIsCustomLogModule"),
                TRUE,                    // Is this a container?
                TEXT(""),
                0
        },
        {
                TEXT("IIsLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleId,LogModuleUiId"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsCustomLogModule"),    // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogCustomPropertyName,LogCustomPropertyHeader,")
                TEXT("LogCustomPropertyID,LogCustomPropertyMask,")
                TEXT("LogCustomPropertyDataType,LogCustomPropertyServicesString"),
                NULL,
                NULL,
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsWebInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,ServerConfigFlags,CustomErrorDescriptions,AdminServer,")
                TEXT("ServerConfigSSL40,ServerConfigSSL128,ServerConfigSSLAllowEncrypt,ServerConfigAutoPWSync,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },
        {
                TEXT("IIsFtpInfo"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                FALSE,
                TEXT(""),
                0
        },


                //------------------------------------------------------------
                //
                //      -- BEGIN EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------

                //
                //      Objects that are handled by the adsiis dll:
                //

        {
                TEXT("IIsNntpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")

                TEXT("ArticleTimeLimit,HistoryExpiration,HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("NewsCrawlerTime,ShutdownLatency,GroupvarListFile,")

                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("FeedReportPeriod,MaxSearchResults,")
                TEXT("NntpServiceVersion,")

                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("AllowAnonymous,DirectoryLevelsToScan,")
                TEXT("NTAuthenticationProviders"),
                NULL,
                TEXT("IIsObject,IIsNntpInfo,IIsNntpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                TEXT("GroupHelpFile,GroupListFile,ArticleTableFile,HistoryTableFile,ModeratorFile,")
                TEXT("XoverTableFile,ListFile,PrettyNamesFile"),   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,AnonymousUserName,AnonymousUserPass,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AnonymousPasswordSync,AdminACL,AdminACLBin,IPSecurity,DontLog,ContentIndexed,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")

                TEXT("ArticleTimeLimit,HistoryExpiration,HonorClientMsgIds,SmtpServer,AdminEmail,AdminName,")
                TEXT("AllowClientPosts,AllowFeedPosts,AllowControlMsgs,")
                TEXT("DefaultModeratorDomain,NntpCommandLogMask,DisableNewNews,")
                TEXT("NewsCrawlerTime,ShutdownLatency,GroupvarListFile,")

                TEXT("ClientPostHardLimit,ClientPostSoftLimit,FeedPostHardLimit,FeedPostSoftLimit,")
                TEXT("NntpUucpName,NntpOrganization,NewsPickupDirectory,NewsFailedPickupDirectory,")
                TEXT("NntpServiceVersion,NewsDropDirectory,NntpClearTextProvider,")
                TEXT("FeedReportPeriod,MaxSearchResults,")

                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessWrite,AccessExecute,AccessFlags,")
                TEXT("SSLCertHash,")
                TEXT("NTAuthenticationProviders"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir,IIsNntpFeeds,IIsNntpExpiration,")                                                                                            // Real objects
                TEXT("IIsNntpRebuild,IIsNntpSessions,IIsNntpGroups"),       // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,ContentIndexed,DontLog,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,AccessSSLFlags,")
                TEXT("AccessAllowPosting,AccessRestrictGroupVisibility,AccessFlags,")
                TEXT("VrDriverClsid,VrDriverProgid,FsPropertyPath,VrUseAccount,VrDoExpire,ExMdbGuid,VrOwnModerator"),
                NULL,
                TEXT("IIsObject,IIsNntpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsNntpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpService"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,")
                TEXT("SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpAdvQueueDll,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("SmtpCommandLogMask,SmtpFlushMailFile,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout,")
                TEXT("DisableSocketPooling,SmtpUseTcpDns,SmtpDomainValidationFlags,SmtpSSLRequireTrustedCA,")
                TEXT("SmtpSSLCertHostnameValidation,MaxMailObjects,ShouldPickupMail,MaxDirChangeIOSize,")
                TEXT("NameResolutionType,MaxSmtpErrors,ShouldPipelineIn,ShouldPipelineOut,")
                TEXT("ConnectResponse,UpdatedFQDN,UpdatedDefaultDomain,EtrnSubdomains,")
                TEXT("SmtpMaxRemoteQThreads,SmtpDisableRelay,SmtpHeloNoDomain,")
                TEXT("SmtpMailNoHelo,SmtpAqueueWait,AddNoHeaders,SmtpEventlogLevel,")
                TEXT("AllowAnonymous,AnonymousOnly,AnonymousPasswordSync,AnonymousUserName,")
                TEXT("AnonymousUserPass,Realm,DefaultLogonDomain"),
                NULL,
                TEXT("IIsObject,IIsSmtpInfo,IIsSmtpServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,ClusterEnabled,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("SmtpServiceVersion,")
                TEXT("EnableReverseDnsLookup,ShouldDeliver,AlwaysUseSsl,LimitRemoteConnections,")
                TEXT("SmartHostType,DoMasquerade,RemoteSmtpPort,RemoteSmtpSecurePort,HopCount,")
                TEXT("MaxOutConnections,MaxOutConnectionsPerDomain,RemoteTimeout,MaxMessageSize,MaxSessionSize,MaxRecipients,")
                TEXT("LocalRetryInterval,RemoteRetryInterval,LocalRetryAttempts,RemoteRetryAttempts,EtrnDays,")
                TEXT("MaxBatchedMessages,SmartHost,FullyQualifiedDomainName,DefaultDomain,")
                TEXT("DropDirectory,BadMailDirectory,PickupDirectory,QueueDirectory,")
                TEXT("MasqueradeDomain,SendNdrTo,SendBadTo,")
                TEXT("RoutingDll,RoutingSources,DomainRouting,")
                TEXT("RouteAction,RouteUserName,RoutePassword,")
                TEXT("SaslLogonDomain,SmtpClearTextProvider,NTAuthenticationProviders,")
                TEXT("SmtpRemoteProgressiveRetry,SmtpLocalDelayExpireMinutes,SmtpLocalNDRExpireMinutes,")
                TEXT("SmtpRemoteDelayExpireMinutes,SmtpRemoteNDRExpireMinutes,")
                TEXT("SmtpRemoteRetryThreshold,SmtpDSNOptions,SmtpDSNLanguageID,")
                TEXT("SmtpInboundCommandSupportOptions,SmtpOutboundCommandSupportOptions,")
                TEXT("RelayIpList,RelayForAuth,")
                TEXT("SmtpConnectTimeout,SmtpMailFromTimeout,SmtpRcptToTimeout,")
                TEXT("SmtpDataTimeout,SmtpBdatTimeout,SmtpAuthTimeout,SmtpSaslTimeout,")
                TEXT("SmtpTurnTimeout,SmtpRsetTimeout,")
                TEXT("SmtpHeloTimeout,")
                TEXT("DisableSocketPooling,SmtpUseTcpDns,SmtpDomainValidationFlags,SmtpSSLRequireTrustedCA,")
                TEXT("SmtpSSLCertHostnameValidation,MaxMailObjects,ShouldPickupMail,MaxDirChangeIOSize,")
                TEXT("NameResolutionType,MaxSmtpErrors,ShouldPipelineIn,ShouldPipelineOut,")
                TEXT("ConnectResponse,UpdatedFQDN,UpdatedDefaultDomain,EtrnSubdomains,")
                TEXT("SmtpMaxRemoteQThreads,SmtpDisableRelay,SmtpHeloNoDomain,")
                TEXT("SmtpMailNoHelo,SmtpAqueueWait,AddNoHeaders,SmtpEventlogLevel,")
                TEXT("AllowAnonymous,AnonymousOnly,AnonymousPasswordSync,AnonymousUserName,")
                TEXT("AnonymousUserPass,Realm,DefaultLogonDomain")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir,IIsSmtpRoutingSource,IIsSmtpDomain,")     // Real objects
                TEXT("IIsSmtpSessions"),   // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpVirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags"),
                NULL,
                TEXT("IIsObject,IIsSmtpVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpDomain"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,RouteAction,RouteActionString,RouteUserName,RoutePassword,")
                          TEXT("RelayIpList,RelayForAuth,AuthTurnList,CSideEtrnDomains"),        //
                NULL,
                TEXT("IIsSmtpDomain"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("SmtpRoutingTableType,SmtpDsDataDirectory,SmtpDsDefaultMailRoot,")
                TEXT("SmtpDsBindType,SmtpDsSchemaType,SmtpDsHost,SmtpDsNamingContext,")
                TEXT("SmtpDsAccount,SmtpDsPassword,SmtpDsUseCat,SmtpDsPort,SmtpDsDomain,SmtpDsFlags"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsSmtpInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Service"),                                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,"),
                NULL,
                TEXT("IIsObject,IIsPop3Info,IIsPop3Server"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Server"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("Pop3ServiceVersion,")
                TEXT("Pop3ExpireMail,Pop3ExpireDelay,Pop3ExpireStart,Pop3MailExpirationTime,")
                TEXT("Pop3ClearTextProvider,Pop3DefaultDomain,")
                TEXT("Pop3RoutingDll,Pop3RoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir,IIsPop3RoutingSource,")       // Real objects
                TEXT("IIsPop3Sessions"),    // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3VirtualDir"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("Pop3ExpireMail,Pop3MailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsPop3VirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3RoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("Pop3RoutingTableType,Pop3DsDataDirectory,Pop3DsDefaultMailRoot,")
                TEXT("Pop3DsBindType,Pop3DsSchemaType,Pop3DsHost,Pop3DsNamingContext,")
                TEXT("Pop3DsAccount,Pop3DsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsPop3Info"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapService"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("ServerListenBacklog,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogFilePeriod,LogPluginClsid,LogModuleList,LogFileDirectory,LogFileTruncateSize,")
                TEXT("LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources"),
                NULL,
                TEXT("IIsObject,IIsImapInfo,IIsImapServer"),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapServer"),                                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                                                   // bstrMandatoryProperties

                TEXT("KeyType,MaxBandwidth,MaxConnections,")
                TEXT("ServerComment,ConnectionTimeout,ServerListenTimeout,MaxEndpointConnections,ServerAutoStart,")
                TEXT("ServerBindings,SecureBindings,")
                TEXT("AdminACL,AdminACLBin,IPSecurity,DontLog,")
                TEXT("AuthAnonymous,AuthBasic,AuthNTLM,AuthFlags,")
                TEXT("DefaultLogonDomain,NTAuthenticationProviders,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("LogType,LogPluginClsid,LogFileDirectory,LogFilePeriod,LogFileTruncateSize,LogExtFileDate,")
                TEXT("LogExtFileTime,LogExtFileClientIp,LogExtFileUserName,LogExtFileSiteName,LogExtFileComputerName,LogExtFileServerIp,LogExtFileMethod,")
                TEXT("LogExtFileUriStem,LogExtFileUriQuery,LogExtFileHttpStatus,LogExtFileWin32Status,LogExtFileBytesSent,LogExtFileBytesRecv,")
                TEXT("LogExtFileTimeTaken,LogExtFileServerPort,LogExtFileUserAgent,LogExtFileCookie,LogExtFileReferer,LogExtFileProtocolVersion,LogExtFileFlags,LogExtFileHost,LogOdbcDataSource,")
                TEXT("LogOdbcTableName,LogOdbcUserName,LogOdbcPassword,")
                TEXT("ServerListenBacklog,Win32Error,ServerState,")
                TEXT("ImapServiceVersion,")
                TEXT("ImapExpireMail,ImapExpireDelay,ImapExpireStart,ImapMailExpirationTime,")
                TEXT("ImapClearTextProvider,ImapDefaultDomain,")
                TEXT("ImapRoutingDll,ImapRoutingSources,")
                TEXT("SSLCertHash"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir,IIsImapRoutingSource,")       // Real objects
                TEXT("IIsImapSessions"),        // Class extensions
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapVirtualDir"),// Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,Path,UNCUserName,UNCPassword,Win32Error,DontLog,")
                TEXT("AccessRead,AccessWrite,")
                TEXT("AccessSSL,AccessSSL128,AccessSSLNegotiateCert,AccessSSLRequireCert,AccessSSLMapCert,")
                TEXT("AccessFlags,AccessSSLFlags,")
                TEXT("ImapExpireMail,ImapMailExpirationTime"),
                NULL,
                TEXT("IIsObject,IIsImapVirtualDir"),   // Can Contain
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapRoutingSource"),           // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("ImapRoutingTableType,ImapDsDataDirectory,ImapDsDefaultMailRoot,")
                TEXT("ImapDsBindType,ImapDsSchemaType,ImapDsHost,ImapDsNamingContext,")
                TEXT("ImapDsAccount,ImapDsPassword"),
                NULL,
                NULL,           // Can Contain
                TRUE,
                TEXT(""),           //
                0
        },

        {               // Taken from as IIsFtpInfo
                TEXT("IIsImapInfo"),     // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("KeyType,LogModuleList"),
                NULL,
                TEXT("IIsObject"),
                TRUE,
                TEXT(""),
                0
        },

        //
        //      Place holders for extension classes:
        //

        {
                TEXT("IIsNntpRebuild"),                 // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeeds"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")        //
                TEXT("FeedPeerTempDirectory"),
                NULL,
                TEXT("IIsNntpFeed"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpFeed"),                   // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,")
                TEXT("FeedServerName,FeedType,FeedNewsgroups,FeedSecurityType,")
                TEXT("FeedAuthenticationType,FeedAccountName,FeedPassword,FeedStartTimeHigh,")
                TEXT("FeedStartTimeLow,FeedInterval,FeedAllowControlMsgs,FeedCreateAutomatically,")
                TEXT("FeedDisabled,FeedDistribution,FeedConcurrentSessions,FeedMaxConnectionAttempts,")
                TEXT("FeedUucpName,FeedTempDirectory,FeedNextPullHigh,FeedNextPullLow,FeedPeerTempDirectory,")
                TEXT("FeedPeerGapSize,FeedOutgoingPort,FeedFeedpairId,FeedHandshake,FeedAdminError,FeedErrParmMask"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpiration"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                TEXT("IIsNntpExpire"),
                TRUE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpExpire"),              // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType,ExpireSpace,ExpireTime,ExpireNewsgroups,ExpirePolicyName"),
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsNntpGroups"),                  // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsSmtpSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsPop3Sessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsImapSessions"),                // Class Name
                NULL,                                   // GUID *objectClassID
                NULL,                                   // PrimaryInterfaceGUID
                TEXT(""),                               // bstrOID
                FALSE,                                  // fAbstract
                NULL,                                   // bstrMandatoryProperties
                TEXT("KeyType"),        //
                NULL,
                NULL,
                FALSE,                          //
                TEXT(""),
                0
        },

        {
                TEXT("IIsApplicationPools"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("PeriodicRestartTime,PeriodicRestartRequests,PeriodicRestartSchedule,MaxProcesses,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,UlAppPoolQueueLength,KeyType"),
                NULL,
                TEXT("IIsApplicationPool,IIsStreamFilter"),
                TRUE,   // is a containter?
                TEXT(""),
                0
        },

        {
                TEXT("IIsApplicationPool"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("PeriodicRestartTime,PeriodicRestartRequests,MaxProcesses,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,UlAppPoolQueueLength,KeyType"),
                NULL,
                TEXT(""),
                TRUE,
                TEXT(""),
                0
        },

        {
                TEXT("IIsStreamFilter"),      // Class Name
                NULL,                    // GUID *objectClassID
                NULL,                    // PrimaryInterfaceGUID
                TEXT(""),                // bstrOID
                FALSE,                   // fAbstract
                NULL,                    // bstrMandatoryProperties
                TEXT("PeriodicRestartTime,PeriodicRestartConnections,PingingEnabled,IdleTimeout,RapidFailProtection,SMPAffinitized,SMPProcessorAffinityMask,StartupTimeLimit,ShutdownTimeLimit,PingInterval,PingResponseTime,DisallowOverlappingRotation,DisallowRotationOnConfigChange,OrphanWorkerProcess,KeyType"),
                NULL,
                TEXT(""),
                FALSE,
                TEXT(""),
                0
        },


                //------------------------------------------------------------
                //
                //      -- END EXTENSION CLASSES -- magnush
                //
                //------------------------------------------------------------
};

SYNTAXINFO g_aIISSyntax[] =
{ {  TEXT("Boolean"),  IIS_SYNTAX_ID_BOOL,     VT_BOOL },
  {  TEXT("Integer"),  IIS_SYNTAX_ID_DWORD,    VT_I4 },
  {  TEXT("String"),   IIS_SYNTAX_ID_STRING,   VT_BSTR },
  {  TEXT("ExpandSz"), IIS_SYNTAX_ID_EXPANDSZ, VT_BSTR },
  {  TEXT("List"),     IIS_SYNTAX_ID_MULTISZ,  VT_VARIANT }, // VT_BSTR|VT_ARR

  {  TEXT("IPSec"),    IIS_SYNTAX_ID_IPSECLIST,VT_VARIANT }, // IP Sec object
  {  TEXT("NTAcl"),    IIS_SYNTAX_ID_NTACL,    VT_VARIANT }, // NT ACL object
  {  TEXT("Binary"),    IIS_SYNTAX_ID_BINARY,    VT_VARIANT }, // NT ACL object but in Raw Binary Form
  {  TEXT("MimeMapList"), IIS_SYNTAX_ID_MIMEMAP, VT_VARIANT } // VT_ARRAY of Mime Map object
};

DWORD g_cIISClasses = (sizeof(g_aIISClasses)/sizeof(g_aIISClasses[0]));
DWORD g_cIISSyntax = (sizeof(g_aIISSyntax)/sizeof(g_aIISSyntax[0]));



PROPERTYINFO g_aIISProperties[] =
{

// Global Properties
      { TEXT("BackwardCompatEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_GLOBAL_STANDARD_APP_MODE_ENABLED, MD_GLOBAL_STANDARD_APP_MODE_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

//
// Computer properties
//
      { TEXT("KeyType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_KEY_TYPE, MD_KEY_TYPE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER,0, TEXT("")},

      { TEXT("MaxBandwidth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH, MD_MAX_BANDWIDTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("MimeMap"),
        TEXT(""), TEXT("MimeMapList"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MIMEMAP, MD_MIME_MAP, MD_MIME_MAP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

//
// Service properties
//

      { TEXT("AnonymousUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_USER_NAME, MD_ANONYMOUS_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ANONYMOUS_PWD, MD_ANONYMOUS_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AnonymousPasswordSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_USE_SUBAUTH, MD_ANONYMOUS_USE_SUBAUTH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AllowAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_ANONYMOUS, MD_ALLOW_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("WAMUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_USER_NAME, MD_WAM_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("WAMUserPass"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_WAM_PWD, MD_WAM_PWD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOGON_DOMAIN, MD_DEFAULT_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AdminACL"),
        TEXT(""), TEXT("NTAcl"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_NTACL, MD_ADMIN_ACL, MD_ADMIN_ACL, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminACLBin"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BINARY, MD_ADMIN_ACL, MD_VPROP_ADMIN_ACL_RAW_BINARY, 0, METADATA_INHERIT | METADATA_SECURE | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("IPSecurity"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_IP_SEC, MD_IP_SEC, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DontLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DONT_LOG, MD_DONT_LOG, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("Realm"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REALM, MD_REALM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ServerListenTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_TIMEOUT, MD_SERVER_LISTEN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 120, TEXT("")},

      { TEXT("MaxEndpointConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_ENDPOINT_CONNECTIONS, MD_MAX_ENDPOINT_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("DisableSocketPooling"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_SOCKET_POOLING, MD_DISABLE_SOCKET_POOLING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartRequests"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_TIME, MD_APPPOOL_PERIODIC_RESTART_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartSchedule"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_APPPOOL_PERIODIC_RESTART_SCHEDULE, MD_APPPOOL_PERIODIC_RESTART_SCHEDULE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShutdownTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SHUTDOWN_TIMELIMIT, MD_APPPOOL_SHUTDOWN_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},
//
//
//  IW3Service Properties
//
//

      { TEXT("AdminServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_INSTANCE, MD_ADMIN_INSTANCE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("1")},

      { TEXT("EnableDirBrowsing"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_ENABLED, MD_DIRBROW_ENABLED, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DirBrowseShowDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_DATE, MD_DIRBROW_SHOW_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_TIME, MD_DIRBROW_SHOW_TIME, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowSize"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_SIZE, MD_DIRBROW_SHOW_SIZE, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowExtension"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_SHOW_EXTENSION, MD_DIRBROW_SHOW_EXTENSION, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LONG_DATE, MD_DIRBROW_LONG_DATE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableDefaultDoc"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_DIRECTORY_BROWSING, MD_VPROP_DIRBROW_LOADDEFAULT, MD_DIRBROW_LOADDEFAULT, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("DefaultDoc"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_LOAD_FILE, MD_DEFAULT_LOAD_FILE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("default.htm")},

      { TEXT("HttpExpires"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_EXPIRES, MD_HTTP_EXPIRES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("D, 0x15180")},

      { TEXT("HttpPics"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_PICS, MD_HTTP_PICS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpCustomHeaders"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HTTP_CUSTOM, MD_HTTP_CUSTOM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("CustomErrorDescriptions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR_DESC, MD_CUSTOM_ERROR_DESC, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HttpErrors"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_CUSTOM_ERROR, MD_CUSTOM_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("EnableDocFooter"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FOOTER_ENABLED, MD_FOOTER_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DefaultDocFooter"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FOOTER_DOCUMENT, MD_FOOTER_DOCUMENT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HttpRedirect"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HTTP_REDIRECT, MD_HTTP_REDIRECT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogonMethod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGON_METHOD, MD_LOGON_METHOD, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_LOGON_INTERACTIVE, TEXT("")},

      { TEXT("NTAuthenticationProviders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NTAUTHENTICATION_PROVIDERS, MD_NTAUTHENTICATION_PROVIDERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthBasic"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_BASIC, MD_AUTH_BASIC, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_ANONYMOUS, MD_AUTH_ANONYMOUS, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AuthNTLM"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_NT, MD_AUTH_NT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthMD5"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION, MD_VPROP_AUTH_MD5, MD_AUTH_MD5, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_EXECUTE, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSource"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ_SOURCE, MD_ACCESS_SOURCE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL, MD_ACCESS_SSL, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_SSL128, MD_ACCESS_SSL128, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLNegotiateCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_NEGO_CERT, MD_ACCESS_NEGO_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLRequireCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_REQUIRE_CERT, MD_ACCESS_REQUIRE_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessSSLMapCert"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SSL_ACCESS_PERM, MD_VPROP_ACCESS_MAP_CERT, MD_ACCESS_MAP_CERT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CertCheckMode"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CERT_CHECK_MODE, MD_CERT_CHECK_MODE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CertNoRevocCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_REVOC_CHECK, MD_CERT_NO_REVOC_CHECK, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("CertCacheRetrievalOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CACHE_RETRIEVAL_ONLY, MD_CERT_CACHE_RETRIEVAL_ONLY, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertCheckRevocationFreshnessTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_CHECK_REVOCATION_FRESHNESS_TIME, MD_CERT_CHECK_REVOCATION_FRESHNESS_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("CertNoUsageCheck"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_CERT_CHECK_MODE, MD_VPROP_CERT_NO_USAGE_CHECK, MD_CERT_NO_USAGE_CHECK , METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("AccessRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_READ, MD_ACCESS_READ, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("AccessWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_WRITE, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_SCRIPT, MD_ACCESS_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteExecute"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_EXECUTE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteRead"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_READ, MD_ACCESS_NO_REMOTE_READ, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteWrite"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_WRITE, MD_ACCESS_NO_REMOTE_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessNoRemoteScript"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_ACCESS_NO_REMOTE_SCRIPT, MD_ACCESS_NO_REMOTE_SCRIPT, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("FilterLoadOrder"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_CONFIGURATION_INFO, MD_SERVER_CONFIGURATION_INFO, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL40"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_40, MD_SERVER_CONFIG_SSL_40, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSL128"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_SSL_128, MD_SERVER_CONFIG_SSL_128, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigSSLAllowEncrypt"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_ALLOW_ENCRYPT, MD_SERVER_CONFIG_ALLOW_ENCRYPT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerConfigAutoPWSync"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_SERVER_CONFIGURATION_INFO, MD_VPROP_SERVER_CONFIG_AUTO_PW_SYNC, MD_SERVER_CONFIG_AUTO_PW_SYNC, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

//
// IIsFtpService
//

      { TEXT("LogAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_ANONYMOUS, MD_LOG_ANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogNonAnonymous"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOG_NONANONYMOUS, MD_LOG_NONANONYMOUS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


//
// IIsVirtualServer
//

      { TEXT("ServerState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_STATE, MD_SERVER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, MD_SERVER_STATE_STOPPED, TEXT("")},

      { TEXT("ServerComment"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_COMMENT, MD_SERVER_COMMENT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ServerAutoStart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SERVER_AUTOSTART, MD_SERVER_AUTOSTART, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ServerSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_SIZE, MD_SERVER_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_SERVER_SIZE_MEDIUM, TEXT("")},

      { TEXT("ServerListenBacklog"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SERVER_LISTEN_BACKLOG, MD_SERVER_LISTEN_BACKLOG, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 40, TEXT("")},

      { TEXT("ServerBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SERVER_BINDINGS, MD_SERVER_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SecureBindings"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SECURE_BINDINGS, MD_SECURE_BINDINGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("MaxConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_CONNECTIONS, MD_MAX_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ConnectionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CONNECTION_TIMEOUT, MD_CONNECTION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 900, TEXT("")},

//
// IIsWebServer
//

      { TEXT("AllowKeepAlive"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_KEEPALIVES, MD_ALLOW_KEEPALIVES, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("CGITimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SCRIPT_TIMEOUT, MD_SCRIPT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 300, TEXT("")},

      { TEXT("CacheISAPI"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CACHE_EXTENSIONS, MD_CACHE_EXTENSIONS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, (DWORD)-1, TEXT("")},

      { TEXT("FrontPageWeb"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FRONTPAGE_WEB, MD_FRONTPAGE_WEB, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RevocationFreshnessTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_FRESHNESS_TIME, MD_REVOCATION_FRESHNESS_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 86400, TEXT("")},

      { TEXT("RevocationURLRetrievalTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, MD_REVOCATION_URL_RETRIEVAL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

//
// IIsFtpServer
//


      { TEXT("ExitMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXIT_MESSAGE, MD_EXIT_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GreetingMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_GREETING_MESSAGE, MD_GREETING_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("BannerMessage"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_BANNER_MESSAGE, MD_BANNER_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("MaxClientsMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAX_CLIENTS_MESSAGE, MD_MAX_CLIENTS_MESSAGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AnonymousOnly"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ANONYMOUS_ONLY, MD_ANONYMOUS_ONLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MSDOSDirOutput"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_MSDOS_DIR_OUTPUT, MD_MSDOS_DIR_OUTPUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

//
// IIsW3File
//




// IIsW3Directory


      { TEXT("AppRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_ROOT, MD_APP_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppFriendlyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_FRIENDLY_NAME, MD_APP_FRIENDLY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppOopRecoverLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APP_OOP_RECOVER_LIMIT, MD_APP_OOP_RECOVER_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_WAM, APP_OOP_RECOVER_LIMIT_DEFAULT, TEXT("")},

      { TEXT("AppIsolated"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_APP_ISOLATED, MD_APP_ISOLATED, 0, METADATA_INHERIT, IIS_MD_UT_WAM, eAppRunOutProcInDefaultPool, TEXT("")},

      { TEXT("AppPackageName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_NAME, MD_APP_PACKAGE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AppPackageID"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_APP_PACKAGE_ID, MD_APP_PACKAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("ContentIndexed"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_IS_CONTENT_INDEXED, MD_IS_CONTENT_INDEXED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UseDigestSSP"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_USE_DIGEST_SSP, MD_USE_DIGEST_SSP, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsW3VirtualDir
//

      { TEXT("Path"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PATH, MD_VR_PATH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_USERNAME, MD_VR_USERNAME, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UNCPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_PASSWORD, MD_VR_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_FILE, 0, TEXT("")},


//
// IIsFtpVirtualDir
//

      { TEXT("FtpDirBrowseShowLongDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOW_4_DIGIT_YEAR, MD_SHOW_4_DIGIT_YEAR, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

//
// IIsFilter
//

      { TEXT("FilterPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_IMAGE_PATH, MD_FILTER_IMAGE_PATH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterState"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_STATE, MD_FILTER_STATE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterDescription"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_DESCRIPTION, MD_FILTER_DESCRIPTION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FilterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_FILTER_ENABLED, MD_FILTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FilterFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FILTER_FLAGS, MD_FILTER_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SECURE_PORT, MD_NOTIFY_SECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyNonSecurePort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_NONSECURE_PORT, MD_NOTIFY_NONSECURE_PORT, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyReadRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_READ_RAW_DATA, MD_NOTIFY_READ_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyPreProcHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_PREPROC_HEADERS, MD_NOTIFY_PREPROC_HEADERS, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthentication"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTHENTICATION, MD_NOTIFY_AUTHENTICATION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAuthComplete"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_AUTH_COMPLETE, MD_NOTIFY_AUTH_COMPLETE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyUrlMap"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_URL_MAP, MD_NOTIFY_URL_MAP, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyAccessDenied"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ACCESS_DENIED, MD_NOTIFY_ACCESS_DENIED, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendResponse"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RESPONSE, MD_NOTIFY_SEND_RESPONSE, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifySendRawData"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_SEND_RAW_DATA, MD_NOTIFY_SEND_RAW_DATA, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_LOG, MD_NOTIFY_LOG, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_REQUEST, MD_NOTIFY_END_OF_REQUEST, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyEndOfNetSession"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_END_OF_NET_SESSION, MD_NOTIFY_END_OF_NET_SESSION, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderHigh"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_HIGH, MD_NOTIFY_ORDER_HIGH, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderMedium"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_MEDIUM, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NotifyOrderLow"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_FILTER_FLAGS, MD_VPROP_NOTIFY_ORDER_LOW, MD_NOTIFY_ORDER_MEDIUM, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},


//
//
//
//

      { TEXT("AspBufferingOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_BUFFERINGON, MD_ASP_BUFFERINGON, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspLogErrorRequests"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_LOGERRORREQUESTS, MD_ASP_LOGERRORREQUESTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorSentToBrowser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_SCRIPTERRORSSENTTOBROWSER, MD_ASP_SCRIPTERRORSSENTTOBROWSER, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptErrorMessage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTERRORMESSAGE, MD_ASP_SCRIPTERRORMESSAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("An error occurred on the server when processing the URL. Please contact the system administrator.")},

      { TEXT("AspMaxDiskTemplateCacheFiles"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_MAXDISKTEMPLATECACHEFILES, MD_ASP_MAXDISKTEMPLATECACHEFILES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspScriptFileCacheSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTFILECACHESIZE, MD_ASP_SCRIPTFILECACHESIZE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0xffffffff, TEXT("")},

      { TEXT("AspDiskTemplateCacheDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_ASP_DISKTEMPLATECACHEDIRECTORY, MD_ASP_DISKTEMPLATECACHEDIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("%Windir%\\System32\\inetsrv\\ASP Compiled Templates")},

      { TEXT("AspScriptEngineCacheMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTENGINECACHEMAX, MD_ASP_SCRIPTENGINECACHEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 120, TEXT("")},

      { TEXT("AspScriptTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SCRIPTTIMEOUT, MD_ASP_SCRIPTTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 90, TEXT("")},

      { TEXT("AspSessionTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONTIMEOUT, MD_ASP_SESSIONTIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 10, TEXT("")},

      { TEXT("AspEnableParentPaths"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEPARENTPATHS, MD_ASP_ENABLEPARENTPATHS, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspAllowSessionState"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWSESSIONSTATE, MD_ASP_ALLOWSESSIONSTATE, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspScriptLanguage"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ASP_SCRIPTLANGUAGE, MD_ASP_SCRIPTLANGUAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("Vbscript")},

      { TEXT("AspQueueTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUETIMEOUT, MD_ASP_QUEUETIMEOUT, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0xffffffff, TEXT("")},

      { TEXT("AspAllowOutOfProcComponents"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, MD_ASP_ALLOWOUTOFPROCCOMPONENTS, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspExceptionCatchEnable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_EXCEPTIONCATCHENABLE, MD_ASP_EXCEPTIONCATCHENABLE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspCodepage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_CODEPAGE, MD_ASP_CODEPAGE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspLCID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_LCID, MD_ASP_LCID, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowDebugging"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLESERVERDEBUG, MD_ASP_ENABLESERVERDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AppAllowClientDebug"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECLIENTDEBUG, MD_ASP_ENABLECLIENTDEBUG, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("AspKeepSessionIDSecure"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_KEEPSESSIONIDSECURE, MD_ASP_KEEPSESSIONIDSECURE, 0, METADATA_INHERIT, ASP_MD_UT_APP, 0, TEXT("")},

      { TEXT("PasswordExpirePrenotifyDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, MD_ADV_NOTIFY_PWD_EXP_IN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PasswordCacheTTL"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ADV_CACHE_TTL, MD_ADV_CACHE_TTL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 600, TEXT("")},

      { TEXT("PasswordChangeFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTH_CHANGE_FLAGS, MD_AUTH_CHANGE_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ProcessNTCRIfLoggedOn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_PROCESS_NTCR_IF_LOGGED_ON, MD_PROCESS_NTCR_IF_LOGGED_ON, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("AllowPathInfoForScriptMappings"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, MD_ALLOW_PATH_INFO_FOR_SCRIPT_MAPPINGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("UNCAuthenticationPassThrough"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_PASSTHROUGH, MD_VR_PASSTHROUGH, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AppWamClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APP_WAM_CLSID, MD_APP_WAM_CLSID, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DirBrowseFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_DIRECTORY_BROWSING, MD_DIRECTORY_BROWSING, 0, METADATA_INHERIT, IIS_MD_UT_FILE,
        MD_DIRBROW_SHOW_DATE
        |MD_DIRBROW_SHOW_TIME
        |MD_DIRBROW_SHOW_SIZE
        |MD_DIRBROW_SHOW_EXTENSION
        |MD_DIRBROW_LOADDEFAULT
        , TEXT("")},

      { TEXT("AuthFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION, MD_AUTHORIZATION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_ANONYMOUS, TEXT("")},

      { TEXT("AuthPersistence"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_AUTHORIZATION_PERSISTENCE, MD_AUTHORIZATION_PERSISTENCE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_AUTH_SINGLEREQUESTIFPROXY, TEXT("")},

      { TEXT("AuthPersistSingleRequest"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUEST, MD_AUTH_SINGLEREQUEST, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTIFPROXY, MD_AUTH_SINGLEREQUESTIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AuthPersistSingleRequestAlwaysIfProxy"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_AUTHORIZATION_PERSISTENCE, MD_VPROP_AUTH_SINGLEREQUESTALWAYSIFPROXY, MD_AUTH_SINGLEREQUESTALWAYSIFPROXY, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("AccessFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ACCESS_PERM, MD_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, MD_ACCESS_READ, TEXT("")},

      { TEXT("AccessSSLFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SSL_ACCESS_PERM, MD_SSL_ACCESS_PERM, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("ScriptMaps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SCRIPT_MAPS, MD_SCRIPT_MAPS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("\0")},

      { TEXT("InProcessIsapiApps"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_IN_PROCESS_ISAPI_APPS, MD_IN_PROCESS_ISAPI_APPS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("SSIExecDisable"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSI_EXEC_DISABLED, MD_SSI_EXEC_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("EnableReverseDns"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_REVERSE_DNS, MD_DO_REVERSE_DNS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateCGIWithNewConsole"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROC_NEW_CONSOLE, MD_CREATE_PROC_NEW_CONSOLE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("LogModuleId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_MOD_ID, MD_LOG_PLUGIN_MOD_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleUiId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_UI_ID, MD_LOG_PLUGIN_UI_ID, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOG_TYPE, MD_LOG_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogFilePeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_PERIOD, MD_LOGFILE_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("LogPluginClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGIN_ORDER, MD_LOG_PLUGIN_ORDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogModuleList"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOG_PLUGINS_AVAILABLE, MD_LOG_PLUGINS_AVAILABLE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("NCSA Common Log File Format, Microsoft IIS Log File Format, W3C Extended Log File Format")},

      { TEXT("LogFileDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_LOGFILE_DIRECTORY, MD_LOGFILE_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\System32\\LogExtFiles")},

      { TEXT("LogFileTruncateSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGFILE_TRUNCATE_SIZE, MD_LOGFILE_TRUNCATE_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2000000, TEXT("")},

      { TEXT("LogFileLocaltimeRollover"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LOGFILE_LOCALTIME_ROLLOVER, MD_LOGFILE_LOCALTIME_ROLLOVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileDate"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_DATE, MD_EXTLOG_DATE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTime"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME, MD_EXTLOG_TIME, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileClientIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_CLIENT_IP, MD_EXTLOG_CLIENT_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUserName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USERNAME, MD_EXTLOG_USERNAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileSiteName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SITE_NAME, MD_EXTLOG_SITE_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileComputerName"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COMPUTER_NAME, MD_EXTLOG_COMPUTER_NAME, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerIp"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_IP, MD_EXTLOG_SERVER_IP, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileMethod"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_METHOD, MD_EXTLOG_METHOD, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriStem"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_STEM, MD_EXTLOG_URI_STEM, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileUriQuery"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_URI_QUERY, MD_EXTLOG_URI_QUERY, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileHttpStatus"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HTTP_STATUS, MD_EXTLOG_HTTP_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("LogExtFileWin32Status"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_WIN32_STATUS, MD_EXTLOG_WIN32_STATUS, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesSent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_SENT, MD_EXTLOG_BYTES_SENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileBytesRecv"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_BYTES_RECV, MD_EXTLOG_BYTES_RECV, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileTimeTaken"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_TIME_TAKEN, MD_EXTLOG_TIME_TAKEN, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileServerPort"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_SERVER_PORT, MD_EXTLOG_SERVER_PORT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileUserAgent"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_USER_AGENT, MD_EXTLOG_USER_AGENT, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileCookie"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_COOKIE, MD_EXTLOG_COOKIE, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileReferer"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_REFERER, MD_EXTLOG_REFERER, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileProtocolVersion"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_PROTOCOL_VERSION , MD_EXTLOG_PROTOCOL_VERSION, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogExtFileFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGEXT_FIELD_MASK, MD_LOGEXT_FIELD_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, MD_DEFAULT_EXTLOG_FIELDS, TEXT("")},

      { TEXT("LogExtFileHost"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_LOGEXT_FIELD_MASK, MD_VPROP_EXTLOG_HOST, MD_EXTLOG_HOST, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogOdbcDataSource"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_DATA_SOURCES, MD_LOGSQL_DATA_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("HTTPLOG")},

      { TEXT("LogOdbcTableName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_TABLE_NAME, MD_LOGSQL_TABLE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetLog")},

      { TEXT("LogOdbcUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_USER_NAME, MD_LOGSQL_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("InternetAdmin")},

      { TEXT("LogOdbcPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGSQL_PASSWORD, MD_LOGSQL_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CacheControlMaxAge"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CC_MAX_AGE, MD_CC_MAX_AGE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlNoCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CC_NO_CACHE, MD_CC_NO_CACHE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CacheControlCustom"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_CC_OTHER, MD_CC_OTHER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("CreateProcessAsUser"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CREATE_PROCESS_AS_USER, MD_CREATE_PROCESS_AS_USER, 0, METADATA_INHERIT, IIS_MD_UT_FILE, DWORD(-1), TEXT("")},

      { TEXT("DirectoryLevelsToScan"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LEVELS_TO_SCAN, MD_LEVELS_TO_SCAN, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 2, TEXT("")},

      { TEXT("MaxBandwidthBlocked"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_BANDWIDTH_BLOCKED, MD_MAX_BANDWIDTH_BLOCKED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0xffffffff, TEXT("")},

      { TEXT("PoolIdcTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POOL_IDC_TIMEOUT, MD_POOL_IDC_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("PutReadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_PUT_READ_SIZE, MD_PUT_READ_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 8192, TEXT("")},

      { TEXT("RedirectHeaders"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_REDIRECT_HEADERS, MD_REDIRECT_HEADERS, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("UploadReadAheadSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_UPLOAD_READAHEAD_SIZE, MD_UPLOAD_READAHEAD_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 49152, TEXT("")},

      { TEXT("CPUResetInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CPU_RESET_INTERVAL, MD_CPU_RESET_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 24, TEXT("")},

      { TEXT("LogCustomPropertyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_NAME, MD_LOGCUSTOM_PROPERTY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LOGCUSTOM_PROPERTY_HEADER, MD_LOGCUSTOM_PROPERTY_HEADER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_ID, MD_LOGCUSTOM_PROPERTY_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_MASK, MD_LOGCUSTOM_PROPERTY_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyDataType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOGCUSTOM_PROPERTY_DATATYPE, MD_LOGCUSTOM_PROPERTY_DATATYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("LogCustomPropertyServicesString"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_LOGCUSTOM_SERVICES_STRING, MD_LOGCUSTOM_SERVICES_STRING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("W3Svc\0MSFTPSvc\0SmtpSvc\0NNTPSvc\0\0")},

      { TEXT("HcCompressionDirectory"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DIRECTORY, MD_HC_COMPRESSION_DIRECTORY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("%Windir%\\IIS Temporary Compressed Files")},

      { TEXT("HcCacheControlHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_CACHE_CONTROL_HEADER, MD_HC_CACHE_CONTROL_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("max-age=86400")},

      { TEXT("HcExpiresHeader"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HC_EXPIRES_HEADER, MD_HC_EXPIRES_HEADER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoDynamicCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DYNAMIC_COMPRESSION, MD_HC_DO_DYNAMIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcDoStaticCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_STATIC_COMPRESSION, MD_HC_DO_STATIC_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("DoDynamicCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION, MD_HC_DO_NAMESPACE_DYNAMIC_COMPRESSION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("DoStaticCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_NAMESPACE_STATIC_COMPRESSION, MD_HC_DO_NAMESPACE_STATIC_COMPRESSION, 0, METADATA_INHERIT, IIS_MD_UT_FILE, 0, TEXT("")},

      { TEXT("HcDoOnDemandCompression"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_ON_DEMAND_COMPRESSION, MD_HC_DO_ON_DEMAND_COMPRESSION, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcDoDiskSpaceLimiting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_DO_DISK_SPACE_LIMITING, MD_HC_DO_DISK_SPACE_LIMITING, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForHttp10"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_HTTP_10, MD_HC_NO_COMPRESSION_FOR_HTTP_10, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcNoCompressionForProxies"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_PROXIES, MD_HC_NO_COMPRESSION_FOR_PROXIES, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcNoCompressionForRange"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_NO_COMPRESSION_FOR_RANGE, MD_HC_NO_COMPRESSION_FOR_RANGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcSendCacheHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HC_SEND_CACHE_HEADERS, MD_HC_SEND_CACHE_HEADERS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("HcMaxDiskSpaceUsage"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_DISK_SPACE_USAGE, MD_HC_MAX_DISK_SPACE_USAGE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000000, TEXT("")},

      { TEXT("HcIoBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_IO_BUFFER_SIZE, MD_HC_IO_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcCompressionBufferSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_COMPRESSION_BUFFER_SIZE, MD_HC_COMPRESSION_BUFFER_SIZE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 8192, TEXT("")},

      { TEXT("HcMaxQueueLength"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MAX_QUEUE_LENGTH, MD_HC_MAX_QUEUE_LENGTH, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1000, TEXT("")},

      { TEXT("HcFilesDeletedPerDiskFree"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_FILES_DELETED_PER_DISK_FREE, MD_HC_FILES_DELETED_PER_DISK_FREE, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcMinFileSizeForComp"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_MIN_FILE_SIZE_FOR_COMP, MD_HC_MIN_FILE_SIZE_FOR_COMP, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 256, TEXT("")},

      { TEXT("HcCompressionDll"),
        TEXT(""), TEXT("ExpandSz"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_EXPANDSZ, MD_HC_COMPRESSION_DLL, MD_HC_COMPRESSION_DLL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_FILE_EXTENSIONS, MD_HC_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcScriptFileExtensions"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_HC_SCRIPT_FILE_EXTENSIONS, MD_HC_SCRIPT_FILE_EXTENSIONS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("\0")},

      { TEXT("HcPriority"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_PRIORITY, MD_HC_PRIORITY, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("HcDynamicCompressionLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_DYNAMIC_COMPRESSION_LEVEL, MD_HC_DYNAMIC_COMPRESSION_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HcOnDemandCompLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_ON_DEMAND_COMP_LEVEL, MD_HC_ON_DEMAND_COMP_LEVEL, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("HcCreateFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HC_CREATE_FLAGS, MD_HC_CREATE_FLAGS, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AspEnableAspHtmlFallback"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEASPHTMLFALLBACK, MD_ASP_ENABLEASPHTMLFALLBACK, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspEnableChunkedEncoding"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLECHUNKEDENCODING, MD_ASP_ENABLECHUNKEDENCODING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspEnableTypelibCache"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLETYPELIBCACHE, MD_ASP_ENABLETYPELIBCACHE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, (DWORD)-1, TEXT("")},

      { TEXT("AspErrorsToNTLog"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ERRORSTONTLOG, MD_ASP_ERRORSTONTLOG, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspProcessorThreadMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_PROCESSORTHREADMAX, MD_ASP_PROCESSORTHREADMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 10, TEXT("")},

      { TEXT("AspTrackThreadingModel"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_TRACKTHREADINGMODEL, MD_ASP_TRACKTHREADINGMODEL, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("AspRequestQueueMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_REQEUSTQUEUEMAX, MD_ASP_REQEUSTQUEUEMAX, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 500, TEXT("")},

      { TEXT("AspEnableApplicationRestart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ASP_ENABLEAPPLICATIONRESTART, MD_ASP_ENABLEAPPLICATIONRESTART, 0, METADATA_NO_ATTRIBUTES, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("AspQueueConnectionTestTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_QUEUECONNECTIONTESTTIME, MD_ASP_QUEUECONNECTIONTESTTIME, 0, METADATA_INHERIT, ASP_MD_UT_APP, 3, TEXT("")},

      { TEXT("AspSessionMax"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ASP_SESSIONMAX, MD_ASP_SESSIONMAX, 0, METADATA_INHERIT, ASP_MD_UT_APP, (DWORD)-1, TEXT("")},

      { TEXT("SslUseDsMapper"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SSL_USE_DS_MAPPER, MD_SSL_USE_DS_MAPPER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClusterEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_CLUSTER_ENABLED, MD_CLUSTER_ENABLED, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLCertHash"),
        TEXT(""), TEXT("Binary"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_BINARY, MD_SSL_CERT_HASH, MD_SSL_CERT_HASH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SSLStoreName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_STRING, MD_SSL_CERT_STORE_NAME, MD_SSL_CERT_STORE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

//--------------------------------------------------------------------
//
//      -- BEGIN EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

                // I think this one should be added to the standard IIS properties:

      { TEXT("Win32Error"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_WIN32_ERROR, MD_WIN32_ERROR, 0, METADATA_VOLATILE, IIS_MD_UT_SERVER, 0, TEXT("")},



        //
        //      NNTP service:
        //

      { TEXT("ArticleTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ARTICLE_TIME_LIMIT, MD_ARTICLE_TIME_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("HistoryExpiration"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HISTORY_EXPIRATION, MD_HISTORY_EXPIRATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("HonorClientMsgIds"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_HONOR_CLIENT_MSGIDS, MD_HONOR_CLIENT_MSGIDS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("SmtpServer"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_SERVER, MD_SMTP_SERVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminEmail"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_EMAIL, MD_ADMIN_EMAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AdminName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ADMIN_NAME, MD_ADMIN_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AllowClientPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CLIENT_POSTS, MD_ALLOW_CLIENT_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowFeedPosts"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_FEED_POSTS, MD_ALLOW_FEED_POSTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("AllowControlMsgs"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALLOW_CONTROL_MSGS, MD_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, TRUE, TEXT("")},

      { TEXT("DefaultModeratorDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_MODERATOR, MD_DEFAULT_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_COMMAND_LOG_MASK, MD_NNTP_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("DisableNewNews"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_NEWNEWS, MD_DISABLE_NEWNEWS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsCrawlerTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NEWS_CRAWLER_TIME, MD_NEWS_CRAWLER_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ShutdownLatency"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SHUTDOWN_LATENCY, MD_SHUTDOWN_LATENCY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

        //
        //      NNTP Virtual Server:
        //

      { TEXT("GroupHelpFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_HELP_FILE, MD_GROUP_HELP_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUP_LIST_FILE, MD_GROUP_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ArticleTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ARTICLE_TABLE_FILE, MD_ARTICLE_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("HistoryTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_HISTORY_TABLE_FILE, MD_HISTORY_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ModeratorFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MODERATOR_FILE, MD_MODERATOR_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("XoverTableFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_XOVER_TABLE_FILE, MD_XOVER_TABLE_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ClientPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_HARD_LIMIT, MD_CLIENT_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("ClientPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_CLIENT_POST_SOFT_LIMIT, MD_CLIENT_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostHardLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_HARD_LIMIT, MD_FEED_POST_HARD_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("FeedPostSoftLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_POST_SOFT_LIMIT, MD_FEED_POST_SOFT_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},

      { TEXT("NntpUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_UUCP_NAME, MD_NNTP_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpOrganization"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_ORGANIZATION, MD_NNTP_ORGANIZATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_LIST_FILE, MD_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PICKUP_DIRECTORY, MD_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsFailedPickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FAILED_PICKUP_DIRECTORY, MD_FAILED_PICKUP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_NNTP_SERVICE_VERSION, MD_NNTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NewsDropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DROP_DIRECTORY, MD_DROP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PrettyNamesFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_PRETTYNAMES_FILE, MD_PRETTYNAMES_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("NntpClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_NNTP_CLEARTEXT_AUTH_PROVIDER, MD_NNTP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedReportPeriod"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_REPORT_PERIOD, MD_FEED_REPORT_PERIOD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSearchResults"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SEARCH_RESULTS, MD_MAX_SEARCH_RESULTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("GroupvarListFile"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_GROUPVAR_LIST_FILE, MD_GROUPVAR_LIST_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    //
    // IIsNntpFeed
    //

      { TEXT("FeedServerName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_SERVER_NAME, MD_FEED_SERVER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_TYPE, MD_FEED_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_NEWSGROUPS, MD_FEED_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedSecurityType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_SECURITY_TYPE, MD_FEED_SECURITY_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAuthenticationType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_AUTHENTICATION_TYPE, MD_FEED_AUTHENTICATION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAccountName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_ACCOUNT_NAME, MD_FEED_ACCOUNT_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PASSWORD, MD_FEED_PASSWORD, 0, METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedStartTimeHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_HIGH, MD_FEED_START_TIME_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedStartTimeLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_START_TIME_LOW, MD_FEED_START_TIME_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_INTERVAL, MD_FEED_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAllowControlMsgs"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ALLOW_CONTROL_MSGS, MD_FEED_ALLOW_CONTROL_MSGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedCreateAutomatically"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CREATE_AUTOMATICALLY, MD_FEED_CREATE_AUTOMATICALLY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDisabled"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_DISABLED, MD_FEED_DISABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedDistribution"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_FEED_DISTRIBUTION, MD_FEED_DISTRIBUTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedConcurrentSessions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_CONCURRENT_SESSIONS, MD_FEED_CONCURRENT_SESSIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedMaxConnectionAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_MAX_CONNECTION_ATTEMPTS, MD_FEED_MAX_CONNECTION_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedUucpName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_UUCP_NAME, MD_FEED_UUCP_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_TEMP_DIRECTORY, MD_FEED_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedNextPullHigh"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_HIGH, MD_FEED_NEXT_PULL_HIGH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedNextPullLow"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_NEXT_PULL_LOW, MD_FEED_NEXT_PULL_LOW, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedPeerTempDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FEED_PEER_TEMP_DIRECTORY, MD_FEED_PEER_TEMP_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FeedPeerGapSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_PEER_GAP_SIZE, MD_FEED_PEER_GAP_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedOutgoingPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_OUTGOING_PORT, MD_FEED_OUTGOING_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedFeedpairId"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_FEEDPAIR_ID, MD_FEED_FEEDPAIR_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedHandshake"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_HANDSHAKE, MD_FEED_HANDSHAKE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedAdminError"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ADMIN_ERROR, MD_FEED_ADMIN_ERROR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("FeedErrParmMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FEED_ERR_PARM_MASK, MD_FEED_ERR_PARM_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

    //
    // IIsNntpExpire
    //

      { TEXT("ExpireSpace"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_SPACE, MD_EXPIRE_SPACE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_EXPIRE_TIME, MD_EXPIRE_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("ExpireNewsgroups"),
        TEXT(""), TEXT("List"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_EXPIRE_NEWSGROUPS, MD_EXPIRE_NEWSGROUPS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExpirePolicyName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EXPIRE_POLICY_NAME, MD_EXPIRE_POLICY_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

     //
     // IIsNntpVirtualDir
     //
      { TEXT("VrDriverClsid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_DRIVER_CLSID, MD_VR_DRIVER_CLSID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrDriverProgid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_VR_DRIVER_PROGID, MD_VR_DRIVER_PROGID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FsPropertyPath"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FS_PROPERTY_PATH, MD_FS_PROPERTY_PATH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrUseAccount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_VR_USE_ACCOUNT, MD_VR_USE_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},

      { TEXT("VrDoExpire"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_DO_EXPIRE, MD_VR_DO_EXPIRE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ExMdbGuid"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_EX_MDB_GUID, MD_EX_MDB_GUID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("VrOwnModerator"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_VR_OWN_MODERATOR, MD_VR_OWN_MODERATOR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AccessAllowPosting"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_NNTP_ALLOW_POSTING, MD_ACCESS_WRITE, METADATA_INHERIT, IIS_MD_UT_FILE, TRUE, TEXT("")},

      { TEXT("AccessRestrictGroupVisibility"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL_BITMASK, MD_ACCESS_PERM, MD_VPROP_NNTP_RESTRICT_GROUP_VISIBILITY, MD_ACCESS_EXECUTE, METADATA_INHERIT, IIS_MD_UT_FILE, FALSE, TEXT("")},

    //
    // IIsSmtpService
    //
      { TEXT("SmtpServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 1, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SERVICE_VERSION, MD_SMTP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},


      { TEXT("EnableReverseDnsLookup"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_REVERSE_NAME_LOOKUP, MD_REVERSE_NAME_LOOKUP, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ShouldDeliver"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_DELIVER, MD_SHOULD_DELIVER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},

      { TEXT("AlwaysUseSsl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SSL, MD_ALWAYS_USE_SSL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("AlwaysUseSasl"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ALWAYS_USE_SASL, MD_ALWAYS_USE_SASL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("LimitRemoteConnections"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_LIMIT_REMOTE_CONNECTIONS, MD_LIMIT_REMOTE_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DoMasquerade"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DO_MASQUERADE, MD_DO_MASQUERADE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmartHostType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMARTHOST_TYPE, MD_SMARTHOST_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteSmtpPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SMTP_PORT, MD_REMOTE_SMTP_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 25, TEXT("")},

      { TEXT("RemoteSmtpSecurePort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_SECURE_PORT, MD_REMOTE_SECURE_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 465, TEXT("")},

      { TEXT("HopCount"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_HOP_COUNT, MD_HOP_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10, TEXT("")},

      { TEXT("MaxOutConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUTBOUND_CONNECTION, MD_MAX_OUTBOUND_CONNECTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxOutConnectionsPerDomain"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_OUT_CONN_PER_DOMAIN, MD_MAX_OUT_CONN_PER_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RemoteTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_TIMEOUT, MD_REMOTE_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxMessageSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE, MD_MAX_MSG_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x2000000, TEXT("")},

      { TEXT("MaxSessionSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MSG_SIZE_B4_CLOSE, MD_MAX_MSG_SIZE_B4_CLOSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0x10000000, TEXT("")},

      { TEXT("MaxRecipients"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_RECIPIENTS, MD_MAX_RECIPIENTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 100, TEXT("")},

      { TEXT("LocalRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_MINUTES, MD_LOCAL_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("RemoteRetryInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_MINUTES, MD_REMOTE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("LocalRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_LOCAL_RETRY_ATTEMPTS, MD_LOCAL_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("RemoteRetryAttempts"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_REMOTE_RETRY_ATTEMPTS, MD_REMOTE_RETRY_ATTEMPTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 48, TEXT("")},

      { TEXT("EtrnDays"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ETRN_DAYS, MD_ETRN_DAYS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxBatchedMessages"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_BATCH_MSG_LIMIT, MD_BATCH_MSG_LIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MaxSmtpLogonErrors"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SMTP_AUTHLOGON_ERRORS, MD_MAX_SMTP_AUTHLOGON_ERRORS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 4, TEXT("")},

      { TEXT("SmartHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMARTHOST_NAME, MD_SMARTHOST_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("FullyQualifiedDomainName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FQDN_VALUE, MD_FQDN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_DEFAULT_DOMAIN_VALUE, MD_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("DropDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_DROP_DIR, MD_MAIL_DROP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("BadMailDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_BAD_MAIL_DIR, MD_BAD_MAIL_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PickupDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_PICKUP_DIR, MD_MAIL_PICKUP_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("QueueDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MAIL_QUEUE_DIR, MD_MAIL_QUEUE_DIR, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTING_DLL, MD_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("MasqueradeDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_MASQUERADE_NAME, MD_MASQUERADE_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendNdrTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_NDR_TO, MD_SEND_NDR_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SaslLogonDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SASL_LOGON_DOMAIN, MD_SASL_LOGON_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("ServerSsAuthMapping"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SERVER_SS_AUTH_MAPPING, MD_SERVER_SS_AUTH_MAPPING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, MD_SMTP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SendBadTo"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SEND_BAD_TO, MD_SEND_BAD_TO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_ROUTING_SOURCES, MD_ROUTING_SOURCES, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      { TEXT("DomainRouting"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_DOMAIN_ROUTING, MD_DOMAIN_ROUTING, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

      //SMTP Retry related data
      { TEXT("SmtpRemoteProgressiveRetry"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, MD_SMTP_REMOTE_PROGRESSIVE_RETRY_MINUTES, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpLocalDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, MD_SMTP_EXPIRE_LOCAL_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpLocalNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, MD_SMTP_EXPIRE_LOCAL_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteDelayExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, MD_SMTP_EXPIRE_REMOTE_DELAY_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},

      { TEXT("SmtpRemoteNDRExpireMinutes"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, MD_SMTP_EXPIRE_REMOTE_NDR_MIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 2880, TEXT("")},

      { TEXT("SmtpRemoteRetryThreshold"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_REMOTE_RETRY_THRESHOLD, MD_SMTP_REMOTE_RETRY_THRESHOLD, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 3, TEXT("")},

      { TEXT("SmtpDSNOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_OPTIONS, MD_SMTP_DSN_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDSNLanguageID"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DSN_LANGUAGE_ID, MD_SMTP_DSN_LANGUAGE_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpInboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, MD_INBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpOutboundCommandSupportOptions"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, MD_OUTBOUND_COMMAND_SUPPORT_OPTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, SMTP_DEFAULT_CMD_SUPPORT, TEXT("")},

      { TEXT("SmtpAdvQueueDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_AQUEUE_DLL, MD_AQUEUE_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      // props below added by awetmore- 11/09/2000
      { TEXT("DisableSocketPooling"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_DISABLE_SOCKET_POOLING, MD_DISABLE_SOCKET_POOLING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpUseTcpDns"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_USE_TCP_DNS, MD_SMTP_USE_TCP_DNS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpDomainValidationFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_DOMAIN_VALIDATION_FLAGS, MD_DOMAIN_VALIDATION_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpSSLRequireTrustedCA"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, MD_SMTP_SSL_REQUIRE_TRUSTED_CA, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpSSLCertHostnameValidation"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, MD_SMTP_SSL_CERT_HOSTNAME_VALIDATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxMailObjects"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_MAIL_OBJECTS, MD_MAX_MAIL_OBJECTS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPickupMail"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PICKUP_MAIL, MD_SHOULD_PICKUP_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxDirChangeIOSize"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_DIR_CHANGE_IO_SIZE, MD_MAX_DIR_CHANGE_IO_SIZE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("NameResolutionType"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_NAME_RESOLUTION_TYPE, MD_NAME_RESOLUTION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("MaxSmtpErrors"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_MAX_SMTP_ERRORS, MD_MAX_SMTP_ERRORS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPipelineIn"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PIPELINE_IN, MD_SHOULD_PIPELINE_IN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ShouldPipelineOut"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SHOULD_PIPELINE_OUT, MD_SHOULD_PIPELINE_OUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("ConnectResponse"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_CONNECT_RESPONSE, MD_CONNECT_RESPONSE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("UpdatedFQDN"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_UPDATED_FQDN, MD_UPDATED_FQDN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("UpdatedDefaultDomain"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_UPDATED_DEFAULT_DOMAIN, MD_UPDATED_DEFAULT_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("EtrnSubdomains"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ETRN_SUBDOMAINS, MD_ETRN_SUBDOMAINS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpMaxRemoteQThreads"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_MAX_REMOTEQ_THREADS, MD_SMTP_MAX_REMOTEQ_THREADS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpDisableRelay"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_DISABLE_RELAY, MD_SMTP_DISABLE_RELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpHeloNoDomain"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_HELO_NODOMAIN, MD_SMTP_HELO_NODOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpMailNoHelo"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_SMTP_MAIL_NO_HELO, MD_SMTP_MAIL_NO_HELO, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpAqueueWait"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_AQUEUE_WAIT, MD_SMTP_AQUEUE_WAIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("AddNoHeaders"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_ADD_NOHEADERS, MD_ADD_NOHEADERS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

      { TEXT("SmtpEventlogLevel"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EVENTLOG_LEVEL, MD_SMTP_EVENTLOG_LEVEL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD) -1, TEXT("")},

    // IIsSmtpDomain
    //
      { TEXT("RouteAction"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_ROUTE_ACTION, MD_ROUTE_ACTION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteActionString"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_ACTION_TYPE, MD_ROUTE_ACTION_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RouteUserName"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_USER_NAME, MD_ROUTE_USER_NAME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RoutePassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_ROUTE_PASSWORD, MD_ROUTE_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpCommandLogMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_COMMAND_LOG_MASK, MD_COMMAND_LOG_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpFlushMailFile"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_FLUSH_MAIL_FILE, MD_FLUSH_MAIL_FILE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayIpList"),
        TEXT(""), TEXT("IPSec"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_IPSECLIST, MD_SMTP_IP_RELAY_ADDRESSES, MD_SMTP_IP_RELAY_ADDRESSES, 0, METADATA_INHERIT | METADATA_REFERENCE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("RelayForAuth"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RELAY_FOR_AUTH_USERS, MD_SMTP_RELAY_FOR_AUTH_USERS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("AuthTurnList"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RW, 0, IIS_SYNTAX_ID_MULTISZ, MD_SMTP_AUTHORIZED_TURN_LIST, MD_SMTP_AUTHORIZED_TURN_LIST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("CSideEtrnDomains"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_CSIDE_ETRN_DOMAIN, MD_SMTP_CSIDE_ETRN_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      // ---

      { TEXT("SmtpConnectTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_CONNECT_TIMEOUT, MD_SMTP_CONNECT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpMailFromTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_MAILFROM_TIMEOUT, MD_SMTP_MAILFROM_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRcptToTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RCPTTO_TIMEOUT, MD_SMTP_RCPTTO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATA_TIMEOUT, MD_SMTP_DATA_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDAT_TIMEOUT, MD_SMTP_BDAT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpAuthTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_AUTH_TIMEOUT, MD_SMTP_AUTH_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpSaslTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_SASL_TIMEOUT, MD_SMTP_SASL_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEtrnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_ETRN_TIMEOUT, MD_SMTP_ETRN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpTurnTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TURN_TIMEOUT, MD_SMTP_TURN_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpRsetTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_RSET_TIMEOUT, MD_SMTP_RSET_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpQuitTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_QUIT_TIMEOUT, MD_SMTP_QUIT_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

      { TEXT("SmtpHeloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_HELO_TIMEOUT, MD_SMTP_HELO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

#if 0
      { TEXT("SmtpEhloTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_EHLO_TIMEOUT, MD_SMTP_EHLO_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDataTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DATATERMINATION_TIMEOUT, MD_SMTP_DATATERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpBdatTermTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_BDATTERMINATION_TIMEOUT, MD_SMTP_BDATTERMINATION_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpTlsTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_TLS_TIMEOUT, MD_SMTP_TLS_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif

    // IIsPop3Service
    //
      { TEXT("Pop3ServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_SERVICE_VERSION, MD_POP3_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_INSTANCE_MAIL, MD_POP3_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_DELAY, MD_POP3_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("Pop3ExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_START, MD_POP3_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3ClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_CLEARTEXT_AUTH_PROVIDER, MD_POP3_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DEFAULT_DOMAIN_VALUE, MD_POP3_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_ROUTING_DLL, MD_POP3_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3RoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_POP3_ROUTING_SOURCE, MD_POP3_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},


    // IIsImapService
    //
      { TEXT("ImapServiceVersion"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RO, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_SERVICE_VERSION, MD_IMAP_SERVICE_VERSION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireMail"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_INSTANCE_MAIL, MD_IMAP_EXPIRE_INSTANCE_MAIL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapExpireDelay"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_DELAY, MD_IMAP_EXPIRE_DELAY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (24*60), TEXT("")},

      { TEXT("ImapExpireStart"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_START, MD_IMAP_EXPIRE_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapClearTextProvider"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, MD_IMAP_CLEARTEXT_AUTH_PROVIDER, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDefaultDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DEFAULT_DOMAIN_VALUE, MD_IMAP_DEFAULT_DOMAIN_VALUE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingDll"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_ROUTING_DLL, MD_IMAP_ROUTING_DLL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapRoutingSources"),
        TEXT(""), TEXT("List"), 0, 0, TRUE,
        PROP_RO, 0, IIS_SYNTAX_ID_MULTISZ, MD_IMAP_ROUTING_SOURCE, MD_IMAP_ROUTING_SOURCE, 0, METADATA_INHERIT, IIS_MD_UT_WAM, 0, TEXT("")},

    // IIsPop3VirtualDir
    //
      { TEXT("Pop3MailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_POP3_EXPIRE_MSG_HOURS, MD_POP3_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsImapVirtualDir
    //
      { TEXT("ImapMailExpirationTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_IMAP_EXPIRE_MSG_HOURS, MD_IMAP_EXPIRE_MSG_HOURS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsSmtpRoutingSource
    //
      { TEXT("SmtpRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_TYPE, MD_SMTP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("SmtpDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DATA_DIRECTORY, MD_SMTP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DEFAULT_MAIL_ROOT, MD_SMTP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_BIND_TYPE, MD_SMTP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_SCHEMA_TYPE, MD_SMTP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_HOST, MD_SMTP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_NAMING_CONTEXT, MD_SMTP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsDomain"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_DOMAIN, MD_SMTP_DS_DOMAIN, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_ACCOUNT, MD_SMTP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_SMTP_DS_PASSWORD, MD_SMTP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsUseCat"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_USE_CAT, MD_SMTP_DS_USE_CAT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsFlags"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_FLAGS, MD_SMTP_DS_FLAGS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("SmtpDsPort"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_SMTP_DS_PORT, MD_SMTP_DS_PORT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

    // IIsPop3RoutingSource
    //
      { TEXT("Pop3RoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_TYPE, MD_POP3_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("Pop3DsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DATA_DIRECTORY, MD_POP3_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_DEFAULT_MAIL_ROOT, MD_POP3_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_BIND_TYPE, MD_POP3_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_SCHEMA_TYPE, MD_POP3_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_HOST, MD_POP3_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_NAMING_CONTEXT, MD_POP3_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_ACCOUNT, MD_POP3_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("Pop3DsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_POP3_DS_PASSWORD, MD_POP3_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},


    // IIsImapRoutingSource
    //
      { TEXT("ImapRoutingTableType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_TYPE, MD_IMAP_DS_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("LDAP")},

      { TEXT("ImapDsDataDirectory"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DATA_DIRECTORY, MD_IMAP_DS_DATA_DIRECTORY, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsDefaultMailRoot"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_DEFAULT_MAIL_ROOT, MD_IMAP_DS_DEFAULT_MAIL_ROOT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsBindType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_BIND_TYPE, MD_IMAP_DS_BIND_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsSchemaType"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_SCHEMA_TYPE, MD_IMAP_DS_SCHEMA_TYPE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsHost"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_HOST, MD_IMAP_DS_HOST, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsNamingContext"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_NAMING_CONTEXT, MD_IMAP_DS_NAMING_CONTEXT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsAccount"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_ACCOUNT, MD_IMAP_DS_ACCOUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("ImapDsPassword"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_IMAP_DS_PASSWORD, MD_IMAP_DS_PASSWORD, 0, METADATA_INHERIT | METADATA_SECURE, IIS_MD_UT_SERVER, 0, TEXT("")},

      { TEXT("PeriodicRestartTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_TIME, MD_APPPOOL_PERIODIC_RESTART_TIME, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("PeriodicRestartRequests"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, MD_APPPOOL_PERIODIC_RESTART_REQUEST_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10000, TEXT("")},
      { TEXT("MaxProcesses"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_MAX_PROCESS_COUNT, MD_APPPOOL_MAX_PROCESS_COUNT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 1, TEXT("")},
      { TEXT("PingingEnabled"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_PINGING_ENABLED, MD_APPPOOL_PINGING_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("IdleTimeout"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_IDLE_TIMEOUT, MD_APPPOOL_IDLE_TIMEOUT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10, TEXT("")},
      { TEXT("RapidFailProtection"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED, MD_APPPOOL_RAPID_FAIL_PROTECTION_ENABLED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("SMPAffinitized"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_SMP_AFFINITIZED, MD_APPPOOL_SMP_AFFINITIZED, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("SMPProcessorAffinityMask"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK, MD_APPPOOL_SMP_AFFINITIZED_PROCESSOR_MASK, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("OrphanWorkerProcess"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING, MD_APPPOOL_ORPHAN_PROCESSES_FOR_DEBUGGING, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("StartupTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_STARTUP_TIMELIMIT, MD_APPPOOL_STARTUP_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 30, TEXT("")},
      { TEXT("ShutdownTimeLimit"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_SHUTDOWN_TIMELIMIT, MD_APPPOOL_SHUTDOWN_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("PingInterval"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PING_INTERVAL, MD_APPPOOL_PING_INTERVAL, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 300, TEXT("")},
      { TEXT("PingResponseTime"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PING_RESPONSE_TIMELIMIT, MD_APPPOOL_PING_RESPONSE_TIMELIMIT, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 60, TEXT("")},
      { TEXT("DisallowOverlappingRotation"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION, MD_APPPOOL_DISALLOW_OVERLAPPING_ROTATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("UlAppPoolQueueLength"),
        TEXT(""), TEXT("Integer"), -1, 4000000, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH, MD_APPPOOL_UL_APPPOOL_QUEUE_LENGTH, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 3000, TEXT("")},
      { TEXT("DisallowRotationOnConfigChange"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE, MD_APPPOOL_DISALLOW_ROTATION_ON_CONFIG_CHANGE, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("AppPoolId"),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_APPPOOL_APPPOOL_ID, MD_APPPOOL_APPPOOL_ID, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 0, TEXT("")},
      { TEXT("AllowTransientRegistration"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_ALLOW_TRANSIENT_REGISTRATION, MD_APPPOOL_ALLOW_TRANSIENT_REGISTRATION, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)0, TEXT("")},
      { TEXT("AppAutoStart"),
        TEXT(""), TEXT("Boolean"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_BOOL, MD_APPPOOL_AUTO_START, MD_APPPOOL_AUTO_START, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, (DWORD)-1, TEXT("")},
      { TEXT("PeriodicRestartConnections"),
        TEXT(""), TEXT("Integer"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_DWORD, MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS, MD_APPPOOL_PERIODIC_RESTART_CONNECTIONS, 0, METADATA_INHERIT, IIS_MD_UT_SERVER, 10000, TEXT("")},

//--------------------------------------------------------------------
//
//      -- END EXTENSION PROPERTIES -- magnush
//
//--------------------------------------------------------------------

#if 0
        // THis is the blank property template
      { TEXT(""),
        TEXT(""), TEXT("String"), 0, 0, FALSE,
        PROP_RW, 0, IIS_SYNTAX_ID_STRING, MD_FILTER_LOAD_ORDER, MD_FILTER_LOAD_ORDER, 0, METADATA_NO_ATTRIBUTES, IIS_MD_UT_SERVER, 0, TEXT("")},
#endif
};


DWORD g_cIISProperties = sizeof(g_aIISProperties)/sizeof(PROPERTYINFO);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\getobj.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  getobj.cxx
//
//  Contents:  ADSI GetObject functionality
//
//  History:   25-Feb-97   SophiaC    Created.
//             25-Jun-97   MagnusH    Added private extension mechanism
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


extern LPWSTR szProviderName;

//+---------------------------------------------------------------------------
//  Function:   RelativeGetObject
//
//  Synopsis:   Gets object relative to given Active Directory path.
//
//  Arguments:  [BSTR ADsPath]
//              [BSTR ClassName]
//              [BSTR RelativeName]
//              [IUnknown** ppObject]
//              [BOOL bNamespaceRelative]
//
//  Returns:    HRESULT
//
//  Modifies:   *ppObject
//
//----------------------------------------------------------------------------
HRESULT
RelativeGetObject(
    BSTR ADsPath,
    BSTR ClassName,
    BSTR RelativeName,
    CCredentials& Credentials,
    IDispatch * FAR* ppObject,
    BOOL bNamespaceRelative
    )
{
    HRESULT hr = S_OK;
    LPWSTR pszBuffer = NULL;
    DWORD dwLen;

    *ppObject = NULL;

    if (!RelativeName || !*RelativeName) {
        RRETURN(E_ADS_UNKNOWN_OBJECT);
    }

    dwLen = (DWORD)(wcslen(ADsPath) + wcslen(RelativeName) + wcslen(ClassName)) + 4;

    pszBuffer = (LPWSTR)AllocADsMem(dwLen*sizeof(WCHAR));

    if (!pszBuffer) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    wcscpy(pszBuffer, ADsPath);

    if (bNamespaceRelative)
        wcscat(pszBuffer, L"//");
    else
        wcscat(pszBuffer, L"/");
    wcscat(pszBuffer, RelativeName);

    if (ClassName && *ClassName) {
        wcscat(pszBuffer,L",");
        wcscat(pszBuffer, ClassName);
    }

    hr = ::GetObject(
                pszBuffer,
                Credentials,
                (LPVOID *)ppObject
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pszBuffer) {
        FreeADsMem(pszBuffer);
    }

    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//  Function:  GetObject
//
//  Synopsis:  Called by ResolvePathName to return an object
//
//  Arguments:  [LPWSTR szBuffer]
//              [LPVOID *ppObject]
//
//  Returns:    HRESULT
//
//  Modifies:    -
//
//----------------------------------------------------------------------------
HRESULT
GetObject(
    LPWSTR szBuffer,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;
    DWORD dwStatus = NO_ERROR;

    WCHAR szCommonName[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    LPWSTR pszParent = NULL;

    IMSAdminBase * pAdminBase = NULL;
    METADATA_HANDLE hObjHandle = NULL;
    METADATA_RECORD mdrData;

    LPWSTR pszIISPathName = NULL;

    WCHAR DataBuf[MAX_PATH];
    DWORD dwReqdBufferLen;

    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);

    IIsSchema *pSchema = NULL;

    IADs * pADs = NULL;

    //
    // Parse the pathname
    //

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    //
    // Validate that this ADs pathname is to be processed by
    // us - as in the provider name is @IIS!
    //

    hr = InitServerInfo(Credentials, pObjectInfo->TreeName, &pAdminBase, &pSchema);
    BAIL_ON_FAILURE(hr);

    hr = ValidateProvider(pObjectInfo);
    BAIL_ON_FAILURE(hr);

    hr = ValidateObjectType(pObjectInfo);

    switch (pObjectInfo->ObjectType) {

    case TOKEN_NAMESPACE:
        //
        // This means that this is a namespace object;
        // instantiate the namespace object
        //

        hr = GetNamespaceObject(
                pObjectInfo,
                Credentials,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_SCHEMA:

        hr = GetSchemaObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_CLASS:

        hr = GetClassObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);

        break;

    case TOKEN_PROPERTY:

        hr = GetPropertyObject(
                pObjectInfo,
                pSchema,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    case TOKEN_SYNTAX:

        hr = GetSyntaxObject(
                pObjectInfo,
                ppObject
                );
        BAIL_ON_FAILURE(hr);
        break;

    default:

        pszIISPathName = AllocADsStr(szBuffer);

        if (!pszIISPathName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *pszIISPathName = L'\0';
        hr = BuildIISPathFromADsPath(
                        pObjectInfo,
                        pszIISPathName
                        );
        BAIL_ON_FAILURE(hr);

        hr = OpenAdminBaseKey(
                    Credentials,
                    pObjectInfo->TreeName,
                    (LPWSTR)pszIISPathName,
                    METADATA_PERMISSION_READ,
                    &pAdminBase,
                    &hObjHandle
                    );
        BAIL_ON_FAILURE(hr);

        //
        // Find out Class Name
        //

        mdrData.dwMDIdentifier = MD_KEY_TYPE;
        mdrData.dwMDDataType = STRING_METADATA;
        mdrData.dwMDUserType = ALL_METADATA;
        mdrData.dwMDAttributes = METADATA_INHERIT;
        mdrData.dwMDDataLen = MAX_PATH;
        mdrData.pbMDData = (PBYTE)DataBuf;

        hr = pAdminBase->GetData(
                    hObjHandle,
                    L"",
                    &mdrData,
                    &dwReqdBufferLen
                    );

        if (FAILED(hr)) {
            if (hr == MD_ERROR_DATA_NOT_FOUND) {

                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W, 
                       SIZEOF_DEFAULT_CLASS_W);

                if (pObjectInfo->ClassName[0] != L'\0' &&
                    _wcsicmp((LPWSTR)pObjectInfo->ClassName, DataBuf)) {
                    hr = E_ADS_BAD_PARAMETER;
                    BAIL_ON_FAILURE(hr);
                }
            }
            else {
                BAIL_ON_FAILURE(hr);
            }
        }
        else {

            if (pObjectInfo->ClassName[0] != L'\0' &&
                _wcsicmp((LPWSTR)pObjectInfo->ClassName, DataBuf)) {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }

            hr = pSchema->ValidateClassName((LPWSTR)DataBuf);
            if (hr == E_ADS_SCHEMA_VIOLATION) {
                memcpy((LPWSTR)DataBuf, DEFAULT_SCHEMA_CLASS_W, 
                       SIZEOF_DEFAULT_CLASS_W);
            }
        }

        //
        // Close the handle now
        //

        if (hObjHandle) {
            CloseAdminBaseKey(pAdminBase, hObjHandle);
            hObjHandle = NULL;
        }

        pszParent = AllocADsStr(szBuffer);

        if (!pszParent) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        *pszParent = L'\0';

        hr = BuildADsParentPath(
                    szBuffer,
                    pszParent,
                    szCommonName
                    );
        BAIL_ON_FAILURE(hr);

        hr = CIISGenObject::CreateGenericObject(
                        pszParent,
                        szCommonName,
                        (LPWSTR)DataBuf,
                        Credentials,
                        ADS_OBJECT_BOUND,
                        IID_IDispatch,
                        (void **)&pADs
                        );
        BAIL_ON_FAILURE(hr);

        hr = pADs->QueryInterface(
                    IID_IDispatch,
                    ppObject
                    );
        BAIL_ON_FAILURE(hr);

    }

error:

    if (pAdminBase && hObjHandle) {
        CloseAdminBaseKey(pAdminBase, hObjHandle);
    }

    if (pADs) {
        pADs->Release();
    }

    if (pszIISPathName) {
        FreeADsStr(pszIISPathName);
    }

    if (pszParent) {
        FreeADsStr(pszParent);
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);
}

HRESULT
BuildIISPathFromADsPath(
    LPWSTR szADsPathName,
    LPWSTR * pszIISPathName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szADsPathName);
    DWORD i = 0;
    HRESULT hr;
    LPWSTR szIISPathName = NULL;

    *pszIISPathName = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    szIISPathName = AllocADsStr(szADsPathName);
    if (!szIISPathName) {

        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *szIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(pObjectInfo, szIISPathName);
    BAIL_ON_FAILURE(hr);

    *pszIISPathName = szIISPathName;

error:

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

}


HRESULT
BuildIISPathFromADsPath(
    POBJECTINFO pObjectInfo,
    LPWSTR pszIISPathName
    )
{

    DWORD dwNumComponents = 0;
    DWORD i = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    //
    // wcscat "LM" to IIS Metabase path
    //

    wcscat(pszIISPathName, L"/LM/");

    if (dwNumComponents) {

        for (i = 0; i < dwNumComponents; i++) {

            wcscat(pszIISPathName, pObjectInfo->ComponentArray[i].szComponent);
            if( i < dwNumComponents -1 ) {
                wcscat(pszIISPathName,L"/");
            }
        }
    }

    RRETURN(S_OK);

}


HRESULT
BuildADsParentPath(
    LPWSTR szBuffer,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer Lexer(szBuffer);
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    HRESULT hr;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));
    hr = ADsObject(&Lexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    dwNumComponents = pObjectInfo->NumComponents;


    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        hr = S_OK;

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @IIS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName
        //

        if (wcslen(pObjectInfo->TreeName)>=MAX_PATH)
        {
            hr = E_ADS_BAD_PARAMETER;
            BAIL_ON_FAILURE(hr);
        }
        wcscpy(szCommonName, pObjectInfo->TreeName);

        hr = S_OK;

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->TreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");


            pszComponent =  pObjectInfo->ComponentArray[i].szComponent;
            pszValue = pObjectInfo->ComponentArray[i].szValue;


            if (pszComponent && pszValue) {

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );
                wcscat(szParent,L"=");
                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szValue
                    );
            }else if (pszComponent){

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
        }

        //
        // And the common name is the last component
        //

        pszComponent =  pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent;
        pszValue = pObjectInfo->ComponentArray[dwNumComponents - 1].szValue;


        if (pszComponent && pszValue) {

            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue);

        }else if (pszComponent){

            if (wcslen(pszComponent)>=MAX_PATH)
            {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            wcscpy(szCommonName, pszComponent);

        }else {
            //
            // Error - we should never hit this case!!
            //

        }

    }

error:

    FreeObjectInfo( &ObjectInfo );
    RRETURN(hr);

}

HRESULT
BuildADsParentPath(
    POBJECTINFO pObjectInfo,
    LPWSTR szParent,
    LPWSTR szCommonName
    )
{
    DWORD i = 0;
    DWORD dwNumComponents = 0;
    LPWSTR pszComponent = NULL, pszValue = NULL;

    dwNumComponents = pObjectInfo->NumComponents;

    if (!dwNumComponents && !pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and
        // no tree name specified. This is the
        // namespace object - its parent is the
        // @ADs! object
        //

        wsprintf(szParent,L"ADs:");

        RRETURN(S_OK);

    } else if (!dwNumComponents && pObjectInfo->TreeName) {
        //
        // There are no CNs in this pathname and a tree
        // name has been specified. This is the root
        // object - its parent is the  @IIS! object

        wsprintf(szParent, L"%s:", pObjectInfo->ProviderName);

        //
        // And the common name is the TreeName. Remember the
        // "//" will be added on  when we reconstruct the full
        // pathname
        //

        if (wcslen(pObjectInfo->TreeName)>=MAX_PATH)
        {
            RRETURN(E_ADS_BAD_PARAMETER);
        }
        wcscpy(szCommonName, pObjectInfo->TreeName);

        RRETURN(S_OK);

    }else {
        //
        // There are one or more CNs, a tree name has been
        // specified. In the worst case the parent is the
        // root object. In the best case a long CN.
        //

        wsprintf(
            szParent, L"%s://%s",
            pObjectInfo->ProviderName,
            pObjectInfo->TreeName
            );

        for (i = 0; i < dwNumComponents - 1; i++) {

            wcscat(szParent, L"/");


            pszComponent =  pObjectInfo->ComponentArray[i].szComponent;
            pszValue = pObjectInfo->ComponentArray[i].szValue;


            if (pszComponent && pszValue) {

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );
                wcscat(szParent,L"=");
                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szValue
                    );
            }else if (pszComponent){

                wcscat(
                    szParent,
                    pObjectInfo->ComponentArray[i].szComponent
                    );

            }else {
                //
                // Error - we should never hit this case!!
                //

            }
        }

        //
        // And the common name is the last component
        //

        pszComponent =  pObjectInfo->ComponentArray[dwNumComponents - 1].szComponent;
        pszValue = pObjectInfo->ComponentArray[dwNumComponents - 1].szValue;


        if (pszComponent && pszValue) {

            wsprintf(szCommonName, L"%s=%s",pszComponent, pszValue);

        }else if (pszComponent){

            if (wcslen(pszComponent)>=MAX_PATH)
            {
                RRETURN(E_ADS_BAD_PARAMETER);
            }
            wcscpy(szCommonName, pszComponent);

        }else {
            //
            // Error - we should never hit this case!!
            //
        }
    }

    RRETURN(S_OK);
}



VOID
FreeObjectInfo(
    POBJECTINFO pObjectInfo
    )
{
    if ( !pObjectInfo )
        return;

    FreeADsStr( pObjectInfo->ProviderName );
    FreeADsStr( pObjectInfo->TreeName );

    for ( DWORD i = 0; i < pObjectInfo->NumComponents; i++ ) {
        
        if (pObjectInfo->ComponentArray[i].szComponent) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szComponent );
        }
        if (pObjectInfo->ComponentArray[i].szValue) {
            FreeADsStr( pObjectInfo->ComponentArray[i].szValue );
        }
    }

    if (pObjectInfo->ComponentArray) {
        FreeADsMem(pObjectInfo->ComponentArray);
    }

    // We don't need to free pObjectInfo since the object is always a static
    // variable on the stack.
}


//+---------------------------------------------------------------------------
// Function:    GetNamespaceObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
//----------------------------------------------------------------------------
HRESULT
GetNamespaceObject(
    POBJECTINFO pObjectInfo,
    CCredentials& Credentials,
    LPVOID * ppObject
    )
{
    HRESULT hr;

    hr = ValidateNamespaceObject(
                pObjectInfo
                );
    BAIL_ON_FAILURE(hr);

    hr = CIISNamespace::CreateNamespace(
                L"ADs:",
                L"IIS:",
                Credentials,
                ADS_OBJECT_BOUND,
                IID_IUnknown,
                ppObject
                );


error:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:    GetSchemaObject
//
// Synopsis:    called by GetObject
//
// Arguments:   [POBJECTINFO pObjectInfo]
//              [LPVOID * ppObject]
//
// Returns:     HRESULT
//
// Modifies:      -
//
//----------------------------------------------------------------------------
HRESULT
GetSchemaObject(
    POBJECTINFO pObjectInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwObjectType = 0;

    hr = ValidateSchemaObject(
                pObjectInfo,
                &dwObjectType
                );
    BAIL_ON_FAILURE(hr);

    //
    // Note: The "error:" tag is at the end of the switch statement,
    //       so we can simply break out.
    //

    switch (dwObjectType) {
    case IIS_SCHEMA_ID:
        hr = GetIntSchemaObject(
                pObjectInfo,
                ppObject
                );
        break;

    case IIS_CLASSPROP_ID:
        hr = GetClassObject(
                pObjectInfo,
                pSchemaCache,
                ppObject
                );
        if (FAILED(hr)) {

            hr = GetPropertyObject(
                        pObjectInfo,
                        pSchemaCache,
                        ppObject
                        );
            if (FAILED(hr)) {

                hr = GetSyntaxObject(
                            pObjectInfo,
                            ppObject
                            );
            }
            if (FAILED(hr)) {
                hr = E_ADS_UNKNOWN_OBJECT;
            }
        }
        break;

    default:
        hr = E_ADS_UNKNOWN_OBJECT;
        break;
    }

error:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetSchemaObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetIntSchemaObject(
    POBJECTINFO pObjInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;

    if (pObjInfo->NumComponents != 1)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 )
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISSchema::CreateSchema( pObjInfo->TreeName,
                                   ADsParent,
                                   pObjInfo->ComponentArray[0].szComponent,
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetClassObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetClassObject(
    POBJECTINFO pObjInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if ( dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, CLASS_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Validate the given class name
    //
    hr = pSchemaCache->ValidateClassName(
                pObjInfo->ComponentArray[dwNumComponents-1].szComponent);
    BAIL_ON_FAILURE(hr);
    
    //
    // Class name found, create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISClass::CreateClass( ADsParent,
                                 pObjInfo->ComponentArray[dwNumComponents-1].szComponent,
                                 ADS_OBJECT_BOUND,
                                 IID_IUnknown,
                                 (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetSyntaxObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetSyntaxObject(
    POBJECTINFO pObjInfo,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD i;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if (dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SYNTAX_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Look for the given syntax name
    //

    for ( i = 0; i < g_cIISSyntax; i++ )
    {
         if ( _wcsicmp( g_aIISSyntax[i].bstrName,
                        pObjInfo->ComponentArray[dwNumComponents-1].szComponent ) == 0 )
             break;
    }

    if ( i == g_cIISSyntax )
    {
        // Syntax name not found, return error

        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Syntax name found, create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);

    hr = CIISSyntax::CreateSyntax( ADsParent,
                                   &(g_aIISSyntax[i]),
                                   ADS_OBJECT_BOUND,
                                   IID_IUnknown,
                                   (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:   GetPropertyObject
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
GetPropertyObject(
    POBJECTINFO pObjInfo,
    IIsSchema *pSchemaCache,
    LPVOID * ppObject
    )
{
    LPUNKNOWN pUnknown = NULL;
    WCHAR ADsParent[MAX_PATH+MAX_PROVIDER_TOKEN_LENGTH];
    WCHAR ADsName[MAX_PATH];
    HRESULT hr = S_OK;
    DWORD dwNumComponents = pObjInfo->NumComponents;

    if (dwNumComponents != 2 && dwNumComponents != 3)
       RRETURN(E_ADS_BAD_PATHNAME);

    if ( (dwNumComponents == 2 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, SCHEMA_NAME ) != 0 ) || 
         (dwNumComponents == 3 && 
         _wcsicmp( pObjInfo->ComponentArray[0].szComponent, PROPERTY_CLASS_NAME ) != 0 )) 
    {
        hr = E_ADS_BAD_PATHNAME;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Validate the given property name
    //
    hr = pSchemaCache->ValidatePropertyName(
                pObjInfo->ComponentArray[dwNumComponents-1].szComponent);
    BAIL_ON_FAILURE(hr);
    
    //
    // Property name is found, so create and return the object
    //

    hr = BuildADsParentPath(pObjInfo, ADsParent, ADsName);
    BAIL_ON_FAILURE(hr);


    hr = CIISProperty::CreateProperty(
                             ADsParent,
                             pObjInfo->ComponentArray[dwNumComponents-1].szComponent,
                             ADS_OBJECT_BOUND,
                             IID_IUnknown,
                             (void **)&pUnknown );
    BAIL_ON_FAILURE(hr);

    *ppObject = pUnknown;

    RRETURN(hr);

error:
    if (pUnknown)
        pUnknown->Release();

    *ppObject = NULL;
    RRETURN(hr);
}


HRESULT
ValidateNamespaceObject(
    POBJECTINFO pObjectInfo
    )
{
    if (!_wcsicmp(pObjectInfo->ProviderName, szProviderName)) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateProvider(
    POBJECTINFO pObjectInfo
    )
{

    //
    // The provider name is case-sensitive.  This is a restriction that OLE
    // has put on us.
    //
    if (!(wcscmp(pObjectInfo->ProviderName, szProviderName))) {
        RRETURN(S_OK);
    }
    RRETURN(E_FAIL);
}


HRESULT
ValidateObjectType(
    POBJECTINFO pObjectInfo
    )
{

    if (pObjectInfo->ProviderName && !pObjectInfo->TreeName
            && !pObjectInfo->NumComponents) {
        pObjectInfo->ObjectType = TOKEN_NAMESPACE;
    }else if (pObjectInfo->ProviderName && pObjectInfo->TreeName
                && pObjectInfo->NumComponents) {

        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"schema")) {
            pObjectInfo->ObjectType = TOKEN_SCHEMA;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"class")) {
            pObjectInfo->ObjectType = TOKEN_CLASS;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"property")) {
            pObjectInfo->ObjectType = TOKEN_PROPERTY;
        }
        else if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent,L"syntax")) {
            pObjectInfo->ObjectType = TOKEN_SYNTAX;
        }

    }

    RRETURN(S_OK);
}


HRESULT
ValidateSchemaObject(
    POBJECTINFO pObjectInfo,
    PDWORD pdwObjectType
    )
{
    DWORD dwNumComponents = 0;

    dwNumComponents = pObjectInfo->NumComponents;

    switch (dwNumComponents) {

    case 1:
        if (!_wcsicmp(pObjectInfo->ComponentArray[0].szComponent, L"schema")) {
            *pdwObjectType = IIS_SCHEMA_ID;
            RRETURN(S_OK);
        }
        break;

    case 2:

        *pdwObjectType = IIS_CLASSPROP_ID;
        RRETURN(S_OK);


    default:
        break;


    }

    RRETURN(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iis2.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  iis2.h
//
//  Contents:  Macros for ADSI IIS methods
//
//  History:   25-Feb-97   SophiaC    Created.
//
//----------------------------------------------------------------------------
#define IIS_CLSID_IISNamespace             d6bfa35e-89f2-11d0-8527-00c04fd8d503
#define IIS_LIBIID_IISOle                  49d704a0-89f7-11d0-8527-00c04fd8d503
#define IIS_CLSID_IISProvider              d88966de-89f2-11d0-8527-00c04fd8d503
#define IIS_CLSID_MimeType                 9036B028-A780-11d0-9B3D-0080C710EF95
#define IIS_IID_IISMimeType                9036B027-A780-11d0-9B3D-0080C710EF95

#define IIS_CLSID_IPSecurity               F3287520-BBA3-11d0-9BDC-00A0C922E703
#define IIS_IID_IISIPSecurity              F3287521-BBA3-11d0-9BDC-00A0C922E703

#define IIS_CLSID_PropertyAttribute        FD2280A8-51A4-11D2-A601-3078302C2030
#define IIS_IID_IISPropertyAttribute       50E21930-A247-11D1-B79C-00A0C922E703

#define IIS_IID_IISBaseObject              4B42E390-0E96-11d1-9C3F-00A0C922E703
#define IIS_IID_IISSchemaObject            B6865A9C-3F64-11D2-A600-00A0C922E703


#define PROPERTY_RO(name,type, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] type * retval);

#define PROPERTY_LONG_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] long ln##name);

#define PROPERTY_LONG_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] long * retval);

#define PROPERTY_BSTR_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] BSTR bstr##name);

#define PROPERTY_BSTR_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] BSTR * retval);

#define PROPERTY_VARIANT_BOOL_RW(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT_BOOL f##name);

#define PROPERTY_VARIANT_BOOL_RO(name, prid)          \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT_BOOL * retval);

#define PROPERTY_VARIANT_RW(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] VARIANT v##name);

#define PROPERTY_VARIANT_RO(name, prid)               \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] VARIANT * retval); \

#define PROPERTY_DATE_RW(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] DATE da##name);

#define PROPERTY_DATE_RO(name, prid)                  \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] DATE * retval);

#define PROPERTY_DISPATCH_RW(name, prid)              \
        [propget, id(prid)]                           \
        HRESULT name([out, retval] IDispatch ** retval);    \
                                                      \
        [propput, id(prid)]                           \
        HRESULT name([in] IDispatch * p##name);


#define DECLARE_IISMimeType_METHODS \
    STDMETHOD(get_MimeType)(THIS_ BSTR FAR* retval);  \
    STDMETHOD(put_MimeType)(THIS_ BSTR bstrMimeType); \
    STDMETHOD(get_Extension)(THIS_ BSTR FAR* retval); \
    STDMETHOD(put_Extension)(THIS_ BSTR bstrExtension);

#define DECLARE_IISIPSecurity_METHODS \
    STDMETHOD(get_IPDeny)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_IPDeny)(THIS_ VARIANT pVarIPDeny); \
    STDMETHOD(get_IPGrant)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_IPGrant)(THIS_ VARIANT pVarIPGrant); \
    STDMETHOD(get_DomainDeny)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_DomainDeny)(THIS_ VARIANT pVarDomainDeny); \
    STDMETHOD(get_DomainGrant)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_DomainGrant)(THIS_ VARIANT pVarDomainGrant); \
    STDMETHOD(get_GrantByDefault)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_GrantByDefault)(THIS_ VARIANT_BOOL bGrantByDefault);


#define DECLARE_IISBaseObject_METHODS \
    STDMETHOD(GetDataPaths) (         \
         THIS_ \
         BSTR bstrName, \
         LONG lnAttribute,      \
         VARIANT FAR* pvPaths); \
    STDMETHOD(GetPropertyAttribObj) ( \
         THIS_ \
         BSTR bstrName, \
         IDispatch **ppObject);

#define DECLARE_IISSchemaObject_METHODS \
    STDMETHOD(GetSchemaPropertyAttributes) (         \
         THIS_ \
         BSTR bstrName, \
         IDispatch **ppObject); \
    STDMETHOD(PutSchemaPropertyAttributes) (         \
         THIS_ \
         IDispatch *pObject);

#define DECLARE_IISPropertyAttribute_METHODS \
    STDMETHOD(get_PropName)(THIS_ BSTR FAR* retval);  \
    STDMETHOD(get_MetaId)(THIS_ LONG FAR* retval); \
    STDMETHOD(put_MetaId)(THIS_ LONG lMetaId); \
    STDMETHOD(get_UserType)(THIS_ LONG FAR* retval); \
    STDMETHOD(put_UserType)(THIS_ LONG lUserType); \
    STDMETHOD(get_AllAttributes)(THIS_ LONG FAR* retval); \
    STDMETHOD(get_Inherit)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Inherit)(THIS_ VARIANT_BOOL bInherit); \
    STDMETHOD(get_PartialPath)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_PartialPath)(THIS_ VARIANT_BOOL bPartialPath); \
    STDMETHOD(get_Secure)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Secure)(THIS_ VARIANT_BOOL bSecure); \
    STDMETHOD(get_Reference)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Reference)(THIS_ VARIANT_BOOL bReference); \
    STDMETHOD(get_Volatile)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Volatile)(THIS_ VARIANT_BOOL bVolatile); \
    STDMETHOD(get_Isinherit)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_Isinherit)(THIS_ VARIANT_BOOL bIsinherit); \
    STDMETHOD(get_InsertPath)(THIS_ VARIANT_BOOL FAR* retval); \
    STDMETHOD(put_InsertPath)(THIS_ VARIANT_BOOL bInsertPath);  \
    STDMETHOD(get_Default)(THIS_ VARIANT FAR* retval); \
    STDMETHOD(put_Default)(THIS_ VARIANT VarDefaults);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\guid.c ===
/*++

   Copyright (c) 1997-1999 Microsoft Corporation

   Module  Name :

       adsiis_guid.c

   Abstract:

        Contains IIDs, CLSIDs, and LIBIDs used by ADSIIS

   Environment:

      Win32 User Mode

--*/

#define INITGUID


#include <ole2.h>
#include "iwamreg.h"
#include "iadmw.h"


//--------------------------------------------------------------------------
//
//  IIS CLSIDs
//
//--------------------------------------------------------------------------

DEFINE_GUID(CLSID_IISGenObject,0x8B645280L,0x7BA4,0x11CF,0xB0,0x3D,0x00,0xAA,0x00,0x6E,0x09,0x75);

DEFINE_GUID(CLSID_IISTree,0x47E94340L,0x994F,0x11CF,0xA5,0xF2,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISSchema,0x65E252B0L,0xB4C8,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISClass,0x946260E0L,0xB505,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISProperty,0x93F8FBF0L,0xB67B,0x11CF,0xA2,0xB5,0x00,0xAA,0x00,0x6E,0x05,0xD3);

DEFINE_GUID(CLSID_IISSyntax,0x953DBC50L,0xEBDB,0x11CF,0x8A,0xBC,0x00,0xC0,0x4F,0xD8,0xD5,0x03);



DEFINE_GUID(LIBID_IISOle,0x49D704A0L,0x89F7,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(CLSID_IISNamespace,0xD6BFA35EL,0x89F2,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(CLSID_IISProvider,0xD88966DEL,0x89F2,0x11D0,0x85,0x27,0x00,0xC0,0x4F,0xD8,0xD5,0x03);

DEFINE_GUID(IID_IISMimeType, 0x9036b027, 0xa780, 0x11d0, 0x9b, 0x3d, 0x0, 0x80, 0xc7, 0x10, 0xef, 0x95);

DEFINE_GUID(CLSID_IISMimeType, 0x9036b028, 0xa780, 0x11d0, 0x9b, 0x3d, 0x0, 0x80, 0xc7, 0x10, 0xef, 0x95);

DEFINE_GUID(CLSID_IPSecurity, 0xf3287520, 0xbba3, 0x11d0, 0x9b, 0xdc, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );

DEFINE_GUID(IID_IISIPSecurity, 0xf3287521, 0xbba3, 0x11d0, 0x9b, 0xdc, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );

DEFINE_GUID(IID_IISBaseObject, 0x4b42e390, 0xe96, 0x11d1, 0x9c, 0x3f, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(IID_IISSchemaObject, 0xb6865a9c, 0x3f64, 0x11d2, 0xa6, 0x00, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3);

DEFINE_GUID(CLSID_IISPropertyAttribute, 0xFD2280A8, 0x51A4, 0x11d2, 0xa6, 0x01, 0x30, 0x78, 0x30, 0x2c, 0x20, 0x30);

DEFINE_GUID(IID_IISPropertyAttribute, 0x50e21930, 0xa247, 0x11d1, 0xb7, 0x9c, 0x0, 0xa0, 0xc9, 0x22, 0xe7, 0x3 );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\guid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997
//
//  File:       guid.h
//
//  Contents:   extern references for IIS guids
//
//  History:   
//
//----------------------------------------------------------------------------

#ifndef __GUID_H__
#define __GUID_H__

#ifdef __cplusplus
extern "C" {
#endif

//-------------------------------------------
//
// IISOle CLSIDs
//
//-------------------------------------------


//
// IISOle objects
//


extern const CLSID CLSID_IISGenObject;


extern const CLSID CLSID_IISTree;

extern const CLSID CLSID_IISSchema;

extern const CLSID CLSID_IISClass;

extern const CLSID CLSID_IISProperty;

extern const CLSID CLSID_IISSyntax;


extern const  CLSID LIBID_IISOle;

extern const  CLSID CLSID_IISNamespace;

extern const  CLSID CLSID_IISProvider;

extern const  CLSID CLSID_IISMimeType;

extern const  CLSID CLSID_IISPropertyAttribute;



#ifdef __cplusplus
}
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iis2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iis2var.cxx
//
//  Contents:   IIS Object to Variant Copy Routines
//
//  Functions:
//
//  History:    05-Mar-97   SophiaC   Created.
//
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
//  IISType objects copy code
//

void
VarTypeFreeVarObjects(
    PVARIANT pVarObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    for (i = 0; i < dwNumValues; i++ ) {
         VariantClear(pVarObject + i);
    }

    FreeADsMem(pVarObject);

    return;
}


HRESULT
IISTypeToVarTypeCopyIISSynIdDWORD(
								  IIsSchema *pSchema,
								  PIISOBJECT lpIISSrcObject,
								  PVARIANT lpVarDestObject
								 )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_I4;
    lpVarDestObject->lVal = lpIISSrcObject->IISValue.value_1.dwDWORD;

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdSTRING(
								   IIsSchema *pSchema,
								   PIISOBJECT lpIISSrcObject,
								   PVARIANT lpVarDestObject
								  )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr = ADsAllocString(
            lpIISSrcObject->IISValue.value_2.String,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdEXPANDSZ(
									 IIsSchema *pSchema,
									 PIISOBJECT lpIISSrcObject,
									 PVARIANT lpVarDestObject	
									)

{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
            lpIISSrcObject->IISValue.value_3.ExpandSz,
            &(lpVarDestObject->bstrVal)
            );

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdMULTISZ(
									IIsSchema *pSchema,
									PIISOBJECT lpIISSrcObject,
									PVARIANT lpVarDestObject
								   )
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BSTR;

    hr =  ADsAllocString(
               lpIISSrcObject->IISValue.value_4.MultiSz,
               &(lpVarDestObject->bstrVal)
               );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBOOL(
								 IIsSchema *pSchema,
								 PIISOBJECT lpIISSrcObject,
								 PVARIANT lpVarDestObject
								)
{
    HRESULT hr = S_OK;

    lpVarDestObject->vt = VT_BOOL;
    lpVarDestObject->boolVal = lpIISSrcObject->IISValue.value_1.dwDWORD ?
                               VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBOOLBITMASK(
										IIsSchema *pSchema,
										LPWSTR pszPropertyName,
										PIISOBJECT lpIISSrcObject,
										PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD dwFlag = 0;

    pSchema->LookupBitMask(pszPropertyName, &dwFlag);

    lpVarDestObject->vt = VT_BOOL;
    lpVarDestObject->boolVal = 
           (lpIISSrcObject->IISValue.value_1.dwDWORD) & dwFlag ?
                               VARIANT_TRUE : VARIANT_FALSE;

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyIISSynIdMIMEMAP(
									IIsSchema *pSchema,
									PIISOBJECT lpIISSrcObject,
									PVARIANT lpVarDestObject
								   )
{
    HRESULT hr = S_OK;

    IISMimeType * pMimeType = NULL;
 
    hr = CMimeType::CreateMimeType(
                IID_IISMimeType,
                (VOID**) &pMimeType
                );

    BAIL_ON_FAILURE(hr);

    hr = ((CMimeType*)pMimeType)->InitFromIISString( 
             lpIISSrcObject->IISValue.value_4.MultiSz);
    lpVarDestObject->vt = VT_DISPATCH;
    lpVarDestObject->pdispVal = pMimeType;

error:

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdBinary(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;
    long i = 0;

    aBound.lLbound = 0;
    aBound.cElements = lpIISSrcObject->IISValue.value_5.Length;;

    if (bReturnBinaryAsVT_VARIANT)
    {
       aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );
    }
    else
    {
       aList = SafeArrayCreate( VT_UI1, 1, &aBound );
    }
    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    if (!bReturnBinaryAsVT_VARIANT)
    {
        memcpy( pArray, lpIISSrcObject->IISValue.value_5.Binary, aBound.cElements );
    }
    else
    {
        for (i = 0; (DWORD)i < aBound.cElements; i++ )
        {
            VARIANT v;
            WCHAR wVal[20];

            VariantInit(&v);
            V_VT(&v) = VT_BSTR;

            _itow(lpIISSrcObject->IISValue.value_5.Binary[i], wVal, 16);

            hr = ADsAllocString( wVal, &(V_BSTR(&v)));

            BAIL_ON_FAILURE(hr);

            hr = SafeArrayPutElement( aList, &i, &v );

            VariantClear(&v);
            BAIL_ON_FAILURE(hr);
        }
    }

    SafeArrayUnaccessData( aList );

    if (bReturnBinaryAsVT_VARIANT)
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_VARIANT;
    }
    else
    {
       V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    }
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdNTACL(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
 
    lpVarDestObject->vt = VT_DISPATCH;

    hr = ConvertSecDescriptorToVariant(
                (PSECURITY_DESCRIPTOR)lpIISSrcObject->IISValue.value_5.Binary,
                lpVarDestObject
                );

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopyIISSynIdIPSECLIST(
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;

    IISIPSecurity * pIPSec = NULL;
 
    hr = CIPSecurity::CreateIPSecurity(
                IID_IISIPSecurity,
                (VOID**) &pIPSec
                );

    BAIL_ON_FAILURE(hr);

    hr = ((CIPSecurity*)pIPSec)->InitFromBinaryBlob( 
             lpIISSrcObject->IISValue.value_5.Binary,
             lpIISSrcObject->IISValue.value_5.Length);
    lpVarDestObject->vt = VT_DISPATCH;
    lpVarDestObject->pdispVal = pIPSec;

error:

    RRETURN(hr);
}

HRESULT
IISTypeToVarTypeCopy(
    IIsSchema *pSchema,
    LPWSTR pszPropertyName,
    PIISOBJECT lpIISSrcObject,
    PVARIANT lpVarDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    switch (lpIISSrcObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeToVarTypeCopyIISSynIdDWORD(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeToVarTypeCopyIISSynIdSTRING(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeToVarTypeCopyIISSynIdEXPANDSZ(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeToVarTypeCopyIISSynIdMULTISZ(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
        hr = IISTypeToVarTypeCopyIISSynIdBOOL(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeToVarTypeCopyIISSynIdBOOLBITMASK(
				pSchema,
                pszPropertyName,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeToVarTypeCopyIISSynIdMIMEMAP(
				pSchema,
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_NTACL:
        hr = IISTypeToVarTypeCopyIISSynIdNTACL(
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
        hr = IISTypeToVarTypeCopyIISSynIdBinary(
                lpIISSrcObject,
                lpVarDestObject,
                bReturnBinaryAsVT_VARIANT
                );
        break;

    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeToVarTypeCopyIISSynIdIPSECLIST(
                lpIISSrcObject,
                lpVarDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}


HRESULT
IISTypeToVarTypeCopyConstruct(
    IIsSchema *pSchema,
    LPWSTR pszPropertyName,
    LPIISOBJECT pIISSrcObjects,
    DWORD dwNumObjects,
    PVARIANT pVarDestObjects,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    long i = 0;
    HRESULT hr = S_OK;
    DWORD dwSyntaxId;

    dwSyntaxId = pIISSrcObjects->IISType;
    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST  ||
        dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        hr = IISTypeToVarTypeCopy( pSchema,
                                   pszPropertyName,
                                   pIISSrcObjects,
                                   pVarDestObjects,
                                   bReturnBinaryAsVT_VARIANT);
        RRETURN(hr);

    }

    VariantInit(pVarDestObjects);

    //  
    //  Check to see if IISType is a Multi-sz w/ only 1 empty string element
    //

    if (dwNumObjects == 1 && 
        (pIISSrcObjects->IISType == IIS_SYNTAX_ID_MULTISZ || 
         pIISSrcObjects->IISType == IIS_SYNTAX_ID_MIMEMAP )) {
         
        if (*pIISSrcObjects->IISValue.value_4.MultiSz == L'\0') {
            dwNumObjects = 0;
        }
    }

    // The following are for handling are multi-value properties
    //

    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;

    aBound.lLbound = 0;

    aBound.cElements = dwNumObjects;

    aList = SafeArrayCreate( VT_VARIANT, 1, &aBound );

    if ( aList == NULL )
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for ( i = 0; i < (long) dwNumObjects; i++ )
    {
        VARIANT v;

        VariantInit(&v);
        hr = IISTypeToVarTypeCopy( pSchema,
                                   pszPropertyName,
                                   pIISSrcObjects + i,
                                   &v,
                                   bReturnBinaryAsVT_VARIANT);
        BAIL_ON_FAILURE(hr);

        hr = SafeArrayPutElement( aList, &i, &v );
        VariantClear(&v);
        BAIL_ON_FAILURE(hr);
    }

    V_VT(pVarDestObjects) = VT_ARRAY | VT_VARIANT;
    V_ARRAY(pVarDestObjects) = aList;

    RRETURN(S_OK);

error:

    if ( aList )
        SafeArrayDestroy( aList );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iiscopy.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       IIScopy.cxx
//
//  Contents:   IIS Object Copy Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects copy code
//

HRESULT
IISTypeCopyIISSynIdDWORD(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                                lpIISSrcObject->IISValue.value_1.dwDWORD;
    RRETURN(hr);
}

HRESULT
IISTypeCopyIISSynIdSTRING(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_2.String =
                    (LPWSTR)AllocADsStr(
                            lpIISSrcObject->IISValue.value_2.String
                            );

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdEXPANDSZ(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )

{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_3.ExpandSz =
                    (LPWSTR)AllocADsStr(
                            lpIISSrcObject->IISValue.value_3.ExpandSz
                            );
    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdMULTISZ(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_4.MultiSz =
                     (LPWSTR)AllocADsStr(
                                lpIISSrcObject->IISValue.value_4.MultiSz
                                );

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdBINARY(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    DWORD Length = 0;
    LPBYTE pBuffer = NULL;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;
     
    Length = lpIISSrcObject->IISValue.value_5.Length;
    lpIISDestObject->IISValue.value_5.Length = Length;

    if (Length) {
        pBuffer = (LPBYTE)AllocADsMem(Length);
        if (!pBuffer) {
            RRETURN(S_FALSE);
        }
        memcpy(pBuffer, lpIISSrcObject->IISValue.value_5.Binary, Length);
    }

    lpIISDestObject->IISValue.value_5.Binary = pBuffer;

    RRETURN(hr);
}


HRESULT
IISTypeCopyIISSynIdMIMEMAP(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    lpIISDestObject->IISType = lpIISSrcObject->IISType;

    lpIISDestObject->IISValue.value_6.MimeMap =
                     (LPWSTR)AllocADsStr(
                                lpIISSrcObject->IISValue.value_4.MultiSz
                                );

    RRETURN(hr);
}

HRESULT
IISTypeCopy(
    PIISOBJECT lpIISSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpIISSrcObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeCopyIISSynIdDWORD(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeCopyIISSynIdSTRING(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeCopyIISSynIdEXPANDSZ(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeCopyIISSynIdMULTISZ(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeCopyIISSynIdBINARY(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeCopyIISSynIdMIMEMAP(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeCopyIISSynIdDWORD(
                lpIISSrcObject,
                lpIISDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
IISTypeCopyConstruct(
    LPIISOBJECT pIISSrcObjects,
    DWORD dwNumObjects,
    LPIISOBJECT * ppIISDestObjects
    )
{

    DWORD i = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    HRESULT hr = S_OK;
    DWORD dwNumObj;


    if (pIISSrcObjects->IISType == IIS_SYNTAX_ID_BINARY    ||
        pIISSrcObjects->IISType == IIS_SYNTAX_ID_IPSECLIST ||
        pIISSrcObjects->IISType == IIS_SYNTAX_ID_NTACL) {
        dwNumObj = 1;
    }
    else {
        dwNumObj = dwNumObjects;
    }

    pIISDestObjects = (LPIISOBJECT)AllocADsMem(
                                    dwNumObj * sizeof(IISOBJECT)
                                    );

    if (!pIISDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObj; i++ ) {
         hr = IISTypeCopy(pIISSrcObjects + i, pIISDestObjects + i);
     }

     *ppIISDestObjects = pIISDestObjects;

     RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iisfree.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       IISfree.cxx
//
//  Contents:   IIS Object Free Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects free code
//


HRESULT
IISTypeFreeIISSynIdDWORD(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdSTRING(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_2.String);

    RRETURN(hr);
}


HRESULT
IISTypeFreeIISSynIdEXPANDSZ(
    PIISOBJECT lpIISDestObject
    )

{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_3.ExpandSz);
    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdMULTISZ(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_4.MultiSz);

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdBINARY(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    if (lpIISDestObject->IISValue.value_5.Binary) {
        FreeADsMem(lpIISDestObject->IISValue.value_5.Binary);
    }

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdBOOL(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    RRETURN(hr);
}

HRESULT
IISTypeFreeIISSynIdMIMEMAP(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;

    FreeADsStr(lpIISDestObject->IISValue.value_6.MimeMap);

    RRETURN(hr);
}

HRESULT
IISTypeClear(
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    switch (lpIISDestObject->IISType) {
    case IIS_SYNTAX_ID_DWORD:
        hr = IISTypeFreeIISSynIdDWORD(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = IISTypeFreeIISSynIdSTRING(
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = IISTypeFreeIISSynIdEXPANDSZ(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = IISTypeFreeIISSynIdMULTISZ(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_IPSECLIST:
        hr = IISTypeFreeIISSynIdBINARY(
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = IISTypeFreeIISSynIdMIMEMAP(
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = IISTypeFreeIISSynIdBOOL(
                lpIISDestObject
                );
        break;


    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



void
IISTypeFreeIISObjects(
    PIISOBJECT pIISObject,
    DWORD dwNumValues
    )
{
    DWORD i = 0;

    if (pIISObject->IISType == IIS_SYNTAX_ID_BINARY ||
        pIISObject->IISType == IIS_SYNTAX_ID_IPSECLIST ||
        pIISObject->IISType == IIS_SYNTAX_ID_NTACL) {
        IISTypeClear(pIISObject);
    }
    else {
        for (i = 0; i < dwNumValues; i++ ) {
             IISTypeClear(pIISObject + i);
        }
    }

    FreeADsMem(pIISObject);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iismrshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iismrshl.cxx
//
//  Contents:   IIS marshalling code
//
//  Functions:
//
//  History:    27-Feb-97  Sophiac Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

#define MAX_PATH_MULTISZ_STRING         256
#define MAX_PATH_MIMEMAP_STRING         100

PMETADATA_RECORD
CopyIISSynIdDWORD_To_IISDWORD(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = DWORD_METADATA;
    pMetaDataRec->dwMDDataLen = sizeof(DWORD);
    pMetaDataRec->pbMDData = (LPBYTE)&(lpIISObject->IISValue.value_1.dwDWORD);

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdSTRING_To_IISSTRING(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = STRING_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    if (lpIISObject) {
        pszData = AllocADsStr((LPWSTR)lpIISObject->IISValue.value_2.String);

        if (!pszData) {
            return(pMetaDataRec);
        }

        pMetaDataRec->dwMDDataLen = ((DWORD)wcslen(pszData) + 1)*2;
    }

    pMetaDataRec->pbMDData = (LPBYTE)pszData;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdEXPANDSZ_To_IISEXPANDSZ(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = EXPANDSZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    if (lpIISObject) {
        pszData = AllocADsStr((LPWSTR)lpIISObject->IISValue.value_3.ExpandSz);

        if (!pszData) {
            return(pMetaDataRec);
        }
        pMetaDataRec->dwMDDataLen = ((DWORD)wcslen(pszData) + 1)*2;
    }

    pMetaDataRec->pbMDData = (LPBYTE)pszData;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdMULTISZ_To_IISMULTISZ(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    DWORD i;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszStr = NULL;
    LPWSTR pszData = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = MULTISZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    //
    // Calculate buffer length to allocate
    //

    for (i = 0; i < dwNumValues; i++) {
        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        pMetaDataRec->dwMDDataLen += ((DWORD)wcslen(pszData) + 1)*2;
    }

    //
    // +2 for the extra null terminator
    //

    pszStr = (LPWSTR) AllocADsMem(pMetaDataRec->dwMDDataLen + 2);

    if (pszStr == NULL) {
        return(pMetaDataRec);
    }

    //
    // empty contents
    //

    wcscpy(pszStr, L"");

    pMetaDataRec->pbMDData = (LPBYTE)pszStr;

    for (i = 0; i < dwNumValues; i++) {

        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        wcscat(pszStr, pszData);
        pszStr += wcslen(pszData);
        *pszStr = L'\0';
        pszStr++;

    }

    *pszStr = L'\0';
    pMetaDataRec->dwMDDataLen += 2;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdBINARY_To_IISBINARY(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPBYTE pBuffer = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = BINARY_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    pBuffer = (LPBYTE) AllocADsMem(
                    lpIISObject->IISValue.value_5.Length);

    if (!pBuffer) {
        return(pMetaDataRec);
    }

    memcpy(pBuffer,
           lpIISObject->IISValue.value_5.Binary,
           lpIISObject->IISValue.value_5.Length);

    pMetaDataRec->pbMDData = (LPBYTE)pBuffer;
    pMetaDataRec->dwMDDataLen = lpIISObject->IISValue.value_5.Length;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdMIMEMAP_To_IISMIMEMAP(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    DWORD i;
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;
    LPWSTR pszData = NULL;
    LPWSTR pszStr = NULL;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = MULTISZ_METADATA;
    pMetaDataRec->dwMDDataLen = 0;

    //
    // Calculate buffer length to allocate
    //

    for (i = 0; i < dwNumValues; i++) {
        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        pMetaDataRec->dwMDDataLen += ((DWORD)wcslen(pszData) + 1)*2;
    }

    //
    // +2 for the extra null terminator
    //

    pszStr = (LPWSTR) AllocADsMem(pMetaDataRec->dwMDDataLen + 2);

    if (pszStr == NULL) {
        return(pMetaDataRec);
    }

    //
    // empty contents
    //

    wcscpy(pszStr, L"");

    pMetaDataRec->pbMDData = (LPBYTE)pszStr;

    for (i = 0; i < dwNumValues; i++) {

        pszData = (LPWSTR)lpIISObject[i].IISValue.value_4.MultiSz;
        wcscat(pszStr, pszData);
        pszStr += wcslen(pszData);
        *pszStr = L'\0';
        pszStr++;

    }

    *pszStr = L'\0';
    pMetaDataRec->dwMDDataLen += 2;

    return(pMetaDataRec);
}

PMETADATA_RECORD
CopyIISSynIdBOOL_To_IISBOOL(
	IIsSchema *pSchema,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwAttribute = ALL_METADATA;
    DWORD dwUserType = ALL_METADATA;

    pSchema->LookupMDFlags(dwMetaId, &dwAttribute, &dwUserType);

    pMetaDataRec->dwMDIdentifier = dwMetaId;
    pMetaDataRec->dwMDAttributes = dwAttribute;
    pMetaDataRec->dwMDUserType = dwUserType;
    pMetaDataRec->dwMDDataType = DWORD_METADATA;
    pMetaDataRec->dwMDDataLen = sizeof(DWORD);
    pMetaDataRec->pbMDData = (LPBYTE)&(lpIISObject->IISValue.value_1.dwDWORD);

    return(pMetaDataRec);

}


PMETADATA_RECORD
CopyIISSynIdToIIS(
	IIsSchema *pSchema,
    DWORD dwSyntaxId,
    DWORD dwMetaId,
    PMETADATA_RECORD pMetaDataRec,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    switch (dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        pMetaDataRec = CopyIISSynIdDWORD_To_IISDWORD(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_STRING:
        pMetaDataRec = CopyIISSynIdSTRING_To_IISSTRING(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        pMetaDataRec = CopyIISSynIdEXPANDSZ_To_IISEXPANDSZ(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        pMetaDataRec = CopyIISSynIdMULTISZ_To_IISMULTISZ(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        pMetaDataRec = CopyIISSynIdBINARY_To_IISBINARY(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        pMetaDataRec = CopyIISSynIdMIMEMAP_To_IISMIMEMAP(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pMetaDataRec = CopyIISSynIdBOOL_To_IISBOOL(
						 pSchema,
                         dwMetaId,
                         pMetaDataRec,
                         lpIISObject
                         );
        break;

    default:
        break;

    }

    return(pMetaDataRec);
}


HRESULT
MarshallIISSynIdToIIS(
	IIsSchema *pSchema,
    DWORD dwSyntaxId,
    DWORD dwMDIdentifier,
    PIISOBJECT pIISObject,
    DWORD dwNumValues,
    PMETADATA_RECORD pMetaDataRecord
    )
{
    CopyIISSynIdToIIS(
			pSchema,
             dwSyntaxId,
             dwMDIdentifier,
             pMetaDataRecord,
             pIISObject,
             dwNumValues
             );

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iistypes.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iistypes.h
//
//  Contents:   IIS syntax type structure
//
//  Functions:
//
//----------------------------------------------------------------------------

#ifndef __IISTYPES_HXX
#define __IISTYPES_HXX

typedef struct
{
    DWORD dwDWORD;

} IIS_SYNTAX_DWORD, * LPIIS_SYNTAX_DWORD;

typedef struct
{
    LPWSTR String;

} IIS_SYNTAX_STRING, * LPIIS_SYNTAX_STRING;

typedef struct
{
    LPWSTR ExpandSz;

} IIS_SYNTAX_EXPANDSZ, * LPIIS_SYNTAX_EXPANDSZ;

typedef struct
{
    LPWSTR MultiSz;

} IIS_SYNTAX_MULTISZ, * LPIIS_SYNTAX_MULTISZ;

typedef struct
{
    DWORD Length;
    LPBYTE Binary;

} IIS_SYNTAX_BINARY, * LPIIS_SYNTAX_BINARY;

typedef struct
{
    LPWSTR MimeMap;

} IIS_SYNTAX_MIMEMAP, * LPIIS_SYNTAX_MIMEMAP;

typedef struct _iistype{
    DWORD IISType;
    union {
        IIS_SYNTAX_DWORD value_1;
        IIS_SYNTAX_STRING value_2;
        IIS_SYNTAX_EXPANDSZ value_3;
        IIS_SYNTAX_MULTISZ value_4;
        IIS_SYNTAX_BINARY value_5;
        IIS_SYNTAX_MIMEMAP value_6;
    }IISValue;
} IISOBJECT, *PIISOBJECT, *LPIISOBJECT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iisres.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iisres.h
//
//  Contents:   IIS provider ID
//
//  Functions:
//
//----------------------------------------------------------------------------
#define IIS_PROVIDER_ID    1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iissynid.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iissynid.h
//
//  Contents:   IIS syntax id
//
//  Functions:
//
//----------------------------------------------------------------------------

#define     IIS_SYNTAX_ID_DWORD         1
#define     IIS_SYNTAX_ID_STRING        2
#define     IIS_SYNTAX_ID_EXPANDSZ      3
#define     IIS_SYNTAX_ID_MULTISZ       4
#define     IIS_SYNTAX_ID_BINARY        5
#define	    IIS_SYNTAX_ID_BOOL          6
#define	    IIS_SYNTAX_ID_BOOL_BITMASK  7
#define	    IIS_SYNTAX_ID_MIMEMAP       8
#define		IIS_SYNTAX_ID_IPSECLIST		9
#define		IIS_SYNTAX_ID_NTACL  		10
#define		IIS_SYNTAX_ID_HTTPERRORS	11
#define		IIS_SYNTAX_ID_HTTPHEADERS	12

//
// special type used for propertyobjprops[]
//
#define		IIS_SYNTAX_ID_STRING_DWORD  13
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\macro.h ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  cmacro.h
//
//  Contents:  Macros for adsi IIS provider
//
//  History:   21-04-97     sophiac    Created.
//
//----------------------------------------------------------------------------
#define BAIL_ON_NULL(p)       \
        if (!(p)) {           \
                goto error;   \
        }

#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                hr = NO_ERROR; \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        HRESULT hr = (_pDispMgr->GetIDsOfNames(iid,                   \
                                       rgszNames,                     \
                                       cNames,                        \
                                       lcid,                          \
                                       rgdispid                       \
                                       ));                            \
                                                                      \
                                                                      \
        RRETURN(hr);                                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
		RRETURN (_pDispMgr->Invoke(dispidMember,                     \
                                    iid,                              \
                                    lcid,                             \
                                    wFlags,                           \
                                    pdispparams,                      \
                                    pvarResult,                       \
                                    pexcepinfo,                       \
                                    puArgErr                          \
                                    ));                               \
}
 

#define DEFINE_Simple_IDispatch_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}



#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetInfoEx(THIS_ VARIANT vProperties, long lnReserved)            \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}


#define CHECK_AND_SET_EXTENDED_ERROR(dwStatus, hr)                    \
    if (dwStatus) {                                                   \
        hr = CheckAndSetExtendedError(dwStatus);                      \
        BAIL_ON_FAILURE(hr);                                          \
    }



#define DEFINE_IADs_PutGetUnImplementation(cls)                       \
STDMETHODIMP                                                          \
cls::Get(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Put(THIS_ BSTR bstrName, VARIANT vProp)                          \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetEx(THIS_ BSTR bstrName, VARIANT FAR* pvProp)                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::PutEx(THIS_ long lnControlCode, BSTR bstrName, VARIANT vProp)    \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}


#define DEFINE_IDispatch_ExtMgr_Implementation(cls)                   \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfoCount(pctinfo));                 \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pExtMgr->GetTypeInfo(itinfo,                         \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pExtMgr->GetIDsOfNames(iid,                          \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pExtMgr->Invoke(dispidMember,                       \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\imaps.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    IMAPS.h

    This file contains constants & type definitions shared between the
    IMAP Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.
        Ahalim      Added K2 support (6/17/97).

*/


#ifndef _IMAPS_H_
#define _IMAPS_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


///////////////////////////////////////////////////////////////////////////////////////
// 
//  IMAP Metabase Properties
//

//  
// Metabase path: /LM/ImapSvc
//
#define IIS_MD_IMAP_SERVICE_BASE            (IMAP_MD_ID_BEGIN_RESERVED + 500)
#define MD_IMAP_SERVICE_VERSION             (IIS_MD_IMAP_SERVICE_BASE + 0)
#define MD_IMAP_UPDATED_DEFAULT_DOMAIN      (IIS_MD_IMAP_SERVICE_BASE + 1)
/*
Standard properties used here:
MD_CONNECTION_TIMEOUT
MD_MAX_CONNECTION
MD_SERVER_COMMENT
MD_SERVER_AUTOSTART
MD_SERVER_SIZE
MD_SERVER_LISTEN_BACKLOG
MD_SERVER_BINDINGS
MD_SECURE_PORT
MD_LOGON_METHOD
MD_AUTHORIZATION
MD_LOG_TYPE
MD_LOGFILE_DIRECTORY
MD_LOGFILE_PERIOD
MD_LOGFILE_TRUNCATE_SIZE
MD_NTAUTHENTICATION_PROVIDERS
*/


//
// Metabase path: /LM/ImapSvc/<inst#>/Root/<vroot>
//
#define IIS_MD_IMAP_BASE                    (IMAP_MD_ID_BEGIN_RESERVED)
#define MD_IMAP_EXPIRE_MAIL                 (IIS_MD_IMAP_BASE + 0)
#define MD_IMAP_EXPIRE_MSG_HOURS            (IIS_MD_IMAP_BASE + 1)
/*
Standard properties used here:
MD_VR_PATH
MD_VR_USERNAME
MD_VR_PASSWORD
*/

//  
// Metabase path: /LM/ImapSvc/<inst#>
//
#define IIS_MD_IMAP_PARAMS_BASE             (IMAP_MD_ID_BEGIN_RESERVED + 200)
#define MD_IMAP_CMD_LOG_FLAGS               (IIS_MD_IMAP_PARAMS_BASE + 0)
#define MD_IMAP_NO_TRANSMITFILES            (IIS_MD_IMAP_PARAMS_BASE + 1)
#define MD_IMAP_STATIC_BUFFER_SIZE          (IIS_MD_IMAP_PARAMS_BASE + 2)
#define MD_IMAP_FILE_IO_BUFFER_SIZE         (IIS_MD_IMAP_PARAMS_BASE + 3)
#define MD_IMAP_MAX_OUTSTANDING_IO          (IIS_MD_IMAP_PARAMS_BASE + 4)
#define MD_IMAP_SHARING_RETRY_ATTEMPTS      (IIS_MD_IMAP_PARAMS_BASE + 5)
#define MD_IMAP_SHARING_RETRY_SLEEP         (IIS_MD_IMAP_PARAMS_BASE + 6)
#define MD_IMAP_MSGS_PER_MAILBAG            (IIS_MD_IMAP_PARAMS_BASE + 7)
#define MD_IMAP_BUFFERED_WRITES             (IIS_MD_IMAP_PARAMS_BASE + 9)
#define MD_IMAP_SEND_BUFFER_SIZE            (IIS_MD_IMAP_PARAMS_BASE + 10)
#define MD_IMAP_RECV_BUFFER_SIZE            (IIS_MD_IMAP_PARAMS_BASE + 11)
#define MD_IMAP_MAX_NUM_CONNECTIONS         (IIS_MD_IMAP_PARAMS_BASE + 12)
#define MD_IMAP_MAX_MAILBAG_INSTANCES       (IIS_MD_IMAP_PARAMS_BASE + 13)
#define MD_IMAP_ROUTING_SOURCE              (IIS_MD_IMAP_PARAMS_BASE + 14)
#define MD_IMAP_INFO_MAX_ERRORS             (IIS_MD_IMAP_PARAMS_BASE + 15)
#define MD_IMAP_DEFAULT_DOMAIN_VALUE        (IIS_MD_IMAP_PARAMS_BASE + 16)
#define MD_IMAP_ROUTING_DLL                 (IIS_MD_IMAP_PARAMS_BASE + 17)      
#define MD_IMAP_EXPIRE_DELAY                (IIS_MD_IMAP_PARAMS_BASE + 18)
#define MD_IMAP_EXPIRE_START                (IIS_MD_IMAP_PARAMS_BASE + 19)
#define MD_IMAP_EXPIRE_DIRS_MAX             (IIS_MD_IMAP_PARAMS_BASE + 20)
#define MD_IMAP_EXPIRE_INSTANCE_MAIL        (IIS_MD_IMAP_PARAMS_BASE + 21)
#define MD_IMAP_QUERY_IDQ_PATH              (IIS_MD_IMAP_PARAMS_BASE + 22)
#define MD_IMAP_CLEARTEXT_AUTH_PROVIDER     (IIS_MD_IMAP_PARAMS_BASE + 23)
#define MD_IMAP_DS_TYPE                     (IIS_MD_IMAP_PARAMS_BASE + 24)
#define MD_IMAP_DS_DATA_DIRECTORY           (IIS_MD_IMAP_PARAMS_BASE + 25)
#define MD_IMAP_DS_DEFAULT_MAIL_ROOT        (IIS_MD_IMAP_PARAMS_BASE + 26)
#define MD_IMAP_DS_BIND_TYPE                (IIS_MD_IMAP_PARAMS_BASE + 27)
#define MD_IMAP_DS_SCHEMA_TYPE              (IIS_MD_IMAP_PARAMS_BASE + 28)
#define MD_IMAP_DS_HOST                     (IIS_MD_IMAP_PARAMS_BASE + 29)
#define MD_IMAP_DS_NAMING_CONTEXT           (IIS_MD_IMAP_PARAMS_BASE + 30)
#define MD_IMAP_DS_ACCOUNT                  (IIS_MD_IMAP_PARAMS_BASE + 31)
#define MD_IMAP_DS_PASSWORD                 (IIS_MD_IMAP_PARAMS_BASE + 32)
#define MD_IMAP_DS_MAX_RESOLVE_BUFFERS      (IIS_MD_IMAP_PARAMS_BASE + 33)
#define MD_IMAP_DS_MAX_VIRTUAL_SERVERS      (IIS_MD_IMAP_PARAMS_BASE + 34)
#define MD_IMAP_DS_MAX_HANDLE_CACHE_ENTRIES (IIS_MD_IMAP_PARAMS_BASE + 35)
#define MD_IMAP_DS_SORT_THRESHOLD           (IIS_MD_IMAP_PARAMS_BASE + 36)

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _IMAPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\object.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  object.cxx
//
//  Contents:  ADSI object type code
//
//  History:
//----------------------------------------------------------------------------

#include "iis.hxx"
#pragma hdrstop

ObjectTypeList::ObjectTypeList()
{
    _pObjList = NULL;
    _dwCurrentIndex = 0;
    _dwMaxElements = 0;
    _dwUBound  = 0;
    _dwLBound = 0;

}


HRESULT
ObjectTypeList::CreateObjectTypeList(
    VARIANT vFilter,
    ObjectTypeList ** ppObjectTypeList
    )
{
    ObjectTypeList * pObjectTypeList = NULL;
    HRESULT hr = S_OK;

    pObjectTypeList = new ObjectTypeList;

    if (!pObjectTypeList) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = BuildObjectArray(
            vFilter,
            &pObjectTypeList->_pObjList,
            &pObjectTypeList->_dwMaxElements
            );

    if (FAILED(hr)) {

        hr = BuildDefaultObjectArray(
                gpFilters,
                gdwMaxFilters,
                &pObjectTypeList->_pObjList,
                &pObjectTypeList->_dwMaxElements
                );

        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayGetUBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwUBound
                );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetLBound(
                pObjectTypeList->_pObjList,
                1,
                (long FAR *)&pObjectTypeList->_dwLBound
                );
    BAIL_ON_FAILURE(hr);

    pObjectTypeList->_dwCurrentIndex = pObjectTypeList->_dwLBound;

    *ppObjectTypeList = pObjectTypeList;

    RRETURN(S_OK);


error:
    if (pObjectTypeList) {
        delete pObjectTypeList;
    }
    RRETURN(hr);

}


ObjectTypeList::~ObjectTypeList()
{
    HRESULT hr = S_OK;
    if (_pObjList) {
        hr = SafeArrayDestroy(_pObjList);
    }
}


HRESULT
ObjectTypeList::GetCurrentObject(
    PDWORD pdwObject
    )
{
    HRESULT hr = S_OK;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    hr = SafeArrayGetElement(
                    _pObjList,
                    (long FAR *)&_dwCurrentIndex,
                    (void *)pdwObject
                    );
    RRETURN(hr);
}

HRESULT
ObjectTypeList::Next()
{
    HRESULT hr = S_OK;

    _dwCurrentIndex++;

    if (_dwCurrentIndex > _dwUBound) {
        return(E_FAIL);
    }

    return(hr);
}



HRESULT
ObjectTypeList::Reset()
{
    HRESULT hr = S_OK;

    return(hr);

}


HRESULT
IsValidFilter(
    LPWSTR ObjectName,
    DWORD *pdwFilterId,
    PFILTERS pFilters,
    DWORD dwMaxFilters
    )
{

    DWORD i = 0;

    for (i = 0; i < dwMaxFilters; i++) {

        if (!_wcsicmp(ObjectName, (pFilters + i)->szObjectName)) {
            *pdwFilterId = (pFilters + i)->dwFilterId;
            RRETURN(S_OK);
        }

    }
    *pdwFilterId = 0;
    RRETURN(E_FAIL);
}



HRESULT
BuildDefaultObjectArray(
    PFILTERS  pFilters,
    DWORD dwMaxFilters,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    DWORD i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    SAFEARRAY * pFilter = NULL;

    sabNewArray.cElements = dwMaxFilters;
    sabNewArray.lLbound =  0;

    pFilter =   SafeArrayCreate(
                        VT_I4,
                        1,
                        &sabNewArray
                        );
    if (!pFilter){
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwMaxFilters; i++) {

        hr = SafeArrayPutElement(
                pFilter,
                (long *)&i,
                (void *)&((pFilters + i)->dwFilterId)
            );
        BAIL_ON_FAILURE(hr);
    }

    *ppFilter = pFilter;
    *pdwNumElements = dwMaxFilters;

    RRETURN(S_OK);

error:
    if (pFilter) {
        SafeArrayDestroy(pFilter);
    }

    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}



HRESULT
BuildObjectArray(
    VARIANT var,
    SAFEARRAY ** ppFilter,
    DWORD * pdwNumElements
    )
{
    LONG uDestCount = 0;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    VARIANT v;
    LONG i;
    HRESULT hr = S_OK;
    SAFEARRAYBOUND sabNewArray;
    DWORD dwFilterId;
    SAFEARRAY * pFilter = NULL;

    if(!((V_VT(&var) &  VT_VARIANT) &&  V_ISARRAY(&var))) {
        RRETURN(E_FAIL);
    }

    //
    // Check that there is only one dimension in this array
    //

    if ((V_ARRAY(&var))->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    //
    // Check that there is atleast one element in this array
    //

    if ((V_ARRAY(&var))->rgsabound[0].cElements == 0){
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(&var),
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    sabNewArray.cElements = dwSUBound - dwSLBound + 1;
    sabNewArray.lLbound = dwSLBound;

    pFilter = SafeArrayCreate(
                    VT_I4,
                    1,
                    &sabNewArray
                    );


    if (!pFilter) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {
        VariantInit(&v);
        hr = SafeArrayGetElement(V_ARRAY(&var),
                                (long FAR *)&i,
                                &v
                                );
        if (FAILED(hr)) {
            continue;
        }


        hr = IsValidFilter(
                V_BSTR(&v),
                &dwFilterId,
                gpFilters,
                gdwMaxFilters
                );

        if (FAILED(hr)) {

            VariantClear(&v);
            continue;
        }

        VariantClear(&v);

        hr = SafeArrayPutElement(
                pFilter,
                (long*)&uDestCount,
                (void *)&dwFilterId
                );

        if(FAILED(hr)){
            continue;
        }

        uDestCount++;

    }

    //
    // There was nothing of value that could be retrieved from the
    // filter.
    //

    if (!uDestCount ) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }


    *pdwNumElements  = uDestCount;
    *ppFilter = pFilter;

    RRETURN(S_OK);

error:

    if (pFilter) {

        SafeArrayDestroy(pFilter);
    }
    *ppFilter = NULL;
    *pdwNumElements = 0;
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\iisurshl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       iisurshl.cxx
//
//  Contents:   IIS unmarshalling code
//
//  Functions:
//
//  History:      01-Mar-97   SophiaC   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"



HRESULT
IISTypeInit(
    PIISOBJECT pIISType
    )
{
    memset(pIISType, 0, sizeof(IISOBJECT));

    RRETURN(S_OK);
}


LPBYTE
CopyIISDWORD_To_IISSynIdDWORD(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    lpIISObject->IISType = IIS_SYNTAX_ID_DWORD;

    lpIISObject->IISValue.value_1.dwDWORD = *(DWORD UNALIGNED *)lpByte;


    return(lpByte);
}

LPBYTE
CopyIISSTRING_To_IISSynIdSTRING(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;

    lpIISObject->IISType = IIS_SYNTAX_ID_STRING;

    lpIISObject->IISValue.value_2.String =
            (LPWSTR)AllocADsStr((LPWSTR)lpByte);

    return(lpByte);
}


LPBYTE
CopyIISEXPANDSZ_To_IISSynIdEXPANDSZ(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject
    )
{
    DWORD dwStatus = 0;

    lpIISObject->IISType = IIS_SYNTAX_ID_EXPANDSZ;

    lpIISObject->IISValue.value_3.ExpandSz =
            (LPWSTR)AllocADsStr((LPWSTR)lpByte);

    return(lpByte);
}

LPBYTE
CopyIISMULTISZ_To_IISSynIdMULTISZ(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszCurrPosition = NULL;
    DWORD i;

    //
    // scan multi-sz string and store each string in an IISObject object
    //

    pszCurrPosition = (LPWSTR) lpByte;

    for (i = 0; i < dwNumValues; i++) {

        //
        // copy each string to IISObject structure
        //

        lpIISObject[i].IISType = IIS_SYNTAX_ID_MULTISZ;

        lpIISObject[i].IISValue.value_4.MultiSz =
                    (LPWSTR)AllocADsStr((LPWSTR)pszCurrPosition);

        while (*pszCurrPosition != L'\0') {
            pszCurrPosition++;
        }

        pszCurrPosition++;
    }

    return(lpByte);
}

LPBYTE
CopyIISBINARY_To_IISSynIdBINARY(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwSyntaxId,
    DWORD dwNumValues
    )
{
    LPBYTE pBuffer = NULL;

    lpIISObject->IISType = dwSyntaxId;

    pBuffer = (LPBYTE) AllocADsMem(dwNumValues);
    if (!pBuffer) {
        return(lpByte);
    }

    memcpy(pBuffer, lpByte, dwNumValues);

    lpIISObject->IISValue.value_5.Binary = pBuffer;
    lpIISObject->IISValue.value_5.Length = dwNumValues;

    return(lpByte);
}

LPBYTE
CopyIISMIMEMAP_To_IISSynIdMIMEMAP(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwNumValues
    )
{
    DWORD dwStatus = 0;
    LPWSTR pszUnicode = NULL;
    LPWSTR pszCurrPosition = NULL;
    DWORD i;

    //
    // scan multi-sz string and store each string in an IISObject object
    //

    pszCurrPosition = (LPWSTR) lpByte;

    for (i = 0; i < dwNumValues; i++) {

        //
        // copy each string to IISObject structure
        //

        lpIISObject[i].IISType = IIS_SYNTAX_ID_MIMEMAP;

        lpIISObject[i].IISValue.value_6.MimeMap =
                    (LPWSTR)AllocADsStr((LPWSTR)pszCurrPosition);

        while (*pszCurrPosition != L'\0') {
            pszCurrPosition++;
        }

        pszCurrPosition++;
    }

    return(lpByte);
}

LPBYTE
CopyIISBOOL_To_IISSynIdBOOL(
    LPBYTE lpByte,
    PIISOBJECT lpIISObject,
    DWORD dwSyntaxId
    )
{
    lpIISObject->IISType = dwSyntaxId;

    lpIISObject->IISValue.value_1.dwDWORD = *(PDWORD)lpByte;

    return(lpByte);
}


LPBYTE
CopyIISToIISSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE pTemp,
    PIISOBJECT lpIISObject
    )
{               
    switch (dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
        pTemp = CopyIISDWORD_To_IISSynIdDWORD(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_STRING:
        pTemp = CopyIISSTRING_To_IISSynIdSTRING(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_EXPANDSZ:
        pTemp = CopyIISEXPANDSZ_To_IISSynIdEXPANDSZ(
                         pTemp,
                         lpIISObject
                         );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        pTemp = CopyIISMULTISZ_To_IISSynIdMULTISZ(
                         pTemp,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        pTemp = CopyIISBINARY_To_IISSynIdBINARY(
                         pTemp,
                         lpIISObject,
                         dwSyntaxId,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        pTemp = CopyIISMIMEMAP_To_IISSynIdMIMEMAP(
                         pTemp,
                         lpIISObject,
                         dwNumValues
                         );
        break;

    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pTemp = CopyIISBOOL_To_IISSynIdBOOL(
                         pTemp,
                         lpIISObject,
                         dwSyntaxId
                         );
        break;

    default:
        break;

    }

    return(pTemp);
}


HRESULT
UnMarshallIISToIISSynId(
    DWORD dwSyntaxId,
    DWORD dwNumValues,
    LPBYTE lpByte,
    PIISOBJECT * ppIISObject
    )
{
    DWORD  i = 0;
    PIISOBJECT pIISObject = NULL;

    //
    // For binary type, dwNumValues is the number of bytes
    //

    if (dwSyntaxId == IIS_SYNTAX_ID_BINARY ||
        dwSyntaxId == IIS_SYNTAX_ID_IPSECLIST  ||
        dwSyntaxId == IIS_SYNTAX_ID_NTACL) {
        pIISObject = (PIISOBJECT)AllocADsMem(
                            sizeof(IISOBJECT)
                            );
    }
    else {
        pIISObject = (PIISOBJECT)AllocADsMem(
                            dwNumValues * sizeof(IISOBJECT)
                            );
    }

    if (!pIISObject) {
        RRETURN(E_FAIL);
    }

    lpByte = CopyIISToIISSynId(
                       dwSyntaxId,
                       dwNumValues,
                       lpByte,
                       pIISObject
                       );

    *ppIISObject = pIISObject;

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\libmain.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       libmain.cxx
//
//  Contents:   LibMain for adsiis.dll
//
//  Functions:  LibMain, DllGetClassObject
//
//  History:    25-Oct-94   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"

#pragma hdrstop

HINSTANCE g_hInst = NULL;
WCHAR * szIISPrefix = L"@IIS!";

#ifdef ADSI_BUILD_WIN95
STDAPI
DllRegisterServerWin95(VOID);
STDAPI
DllUnregisterServerWin95(VOID);
#endif //ADSI_BUILD_WIN95

//
//  Global Data
//

WIN32_CRITSEC * g_pGlobalLock = NULL;
SERVER_CACHE * g_pServerCache = NULL;

extern CRITICAL_SECTION  g_ExtCritSect;

extern PCLASS_ENTRY gpClassHead;

DECLARE_DEBUG_PRINTS_OBJECT()
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#endif

//---------------------------------------------------------------------------
// ADs debug print, mem leak and object tracking-related stuff
//---------------------------------------------------------------------------

DECLARE_INFOLEVEL(ADs)

//+---------------------------------------------------------------------------
//
//  Function:   ShutDown
//
//  Synopsis:   Function to handle printing out heap debugging display
//
//----------------------------------------------------------------------------
inline VOID ShutDown()
{
#if DBG==1
#ifndef MSVC
     DUMP_TRACKING_INFO_DELETE();
     DeleteCriticalSection(&g_csOT);
     DeleteCriticalSection(&g_csMem);
#endif  // ifndef MSVC
     DeleteCriticalSection(&g_csDP);
#endif
}

extern "C" DWORD heapInfoLevel;
extern "C" DWORD OtInfoLevel;
extern "C" DWORD ADsInfoLevel;

//+---------------------------------------------------------------------------
//
//  Function:   GetINIHeapInfoLevel
//
//  Synopsis:   Gets various infolevel values from win.ini
//
//----------------------------------------------------------------------------
inline VOID GetINIHeapInfoLevel()
{
#if DBG==1
    const INT MAXINFOLEN=11;
    WCHAR  awcs[MAXINFOLEN];

#ifndef MSVC
    if (GetProfileString(L"IIS",L"heapInfoLevel", L"00000003", awcs,MAXINFOLEN))
        heapInfoLevel = wcstoul(awcs, NULL, 16);

    if (GetProfileString(L"IIS",L"Ot", L"00000003", awcs, MAXINFOLEN))
        OtInfoLevel = wcstoul(awcs, NULL, 16);

#endif  // MSVC

    if (GetProfileString(L"IIS",L"ADsInfoLevel", L"00000003", awcs,MAXINFOLEN))
        ADsInfoLevel = wcstoul(awcs, NULL, 16);
#endif
}

//  Globals


ULONG  g_ulObjCount = 0;  // Number of objects alive in oleds.dll


//+------------------------------------------------------------------------
//
//  Macro that calculates the number of elements in a statically-defined
//  array.
//
//  Note - I swiped this from ADsary.cxx - A type-safe array class. Remember
//  to swipe the whole thing as required.
//-------------------------------------------------------------------------
#define MY_ARRAY_SIZE(_a)  (sizeof(_a) / sizeof(_a[0]))

CIISProviderCF               g_cfProvider;
CIISNamespaceCF              g_cfNamespace;
CIISMimeTypeCF               g_cfMimeType;
CIISPropertyAttributeCF      g_cfPropertyAttribute;


//+------------------------------------------------------------------------
//
//  oleds class factories
//
//-------------------------------------------------------------------------

struct CLSCACHE
{
    const CLSID *   pclsid;
    IClassFactory * pCF;
};



CLSCACHE g_aclscache[] =
{
    &CLSID_IISProvider,                        &g_cfProvider,
    &CLSID_IISNamespace,                       &g_cfNamespace,
    &CLSID_IISMimeType,                        &g_cfMimeType,
    &CLSID_IISPropertyAttribute,               &g_cfPropertyAttribute
};


//+---------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard DLL entrypoint for locating class factories
//
//----------------------------------------------------------------

STDAPI
DllGetClassObject(REFCLSID clsid, REFIID iid, LPVOID FAR* ppv)
{
    HRESULT         hr;
    size_t          i;

    for (i = 0; i < MY_ARRAY_SIZE(g_aclscache); i++)
    {
        if (IsEqualCLSID(clsid, *g_aclscache[i].pclsid))
        {
            hr = g_aclscache[i].pCF->QueryInterface(iid, ppv);
            RRETURN(hr);
        }
    }

    *ppv = NULL;

    //
    // Add Debugging Code to indicate that the oleds.DllGetClassObject has been called with an unknown CLSID.
    //

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard DLL entrypoint to determine if DLL can be unloaded
//
//---------------------------------------------------------------

STDAPI
DllCanUnloadNow(void)
{
    HRESULT hr;

    hr = S_FALSE;

    return hr;
}

//+---------------------------------------------------------------
//
//  Function:   LibMain
//
//  Synopsis:   Standard DLL initialization entrypoint
//
//---------------------------------------------------------------

EXTERN_C BOOL __cdecl
LibMain(HINSTANCE hInst, ULONG ulReason, LPVOID pvReserved)
{
    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInst);
        g_pGlobalLock = new WIN32_CRITSEC();
        g_pServerCache = new SERVER_CACHE();

        g_hInst = hInst;


#if DBG==1
#ifndef MSVC
        INITIALIZE_CRITICAL_SECTION(&g_csOT);
        INITIALIZE_CRITICAL_SECTION(&g_csMem);
#endif
        INITIALIZE_CRITICAL_SECTION(&g_csDP);
#endif

#ifdef _NO_TRACING_
        CREATE_DEBUG_PRINT_OBJECT("adsiis");
        SET_DEBUG_FLAGS(DEBUG_ERROR);
#endif

        InitializeCriticalSection(&g_ExtCritSect);

        gpClassHead = BuildClassesList();
        break;


    case DLL_PROCESS_DETACH:
        
        //
        // free global list of class entries for 3rd party ext
        //

        FreeClassesList(gpClassHead);

        DeleteCriticalSection(&g_ExtCritSect);

#ifdef _NO_TRACING_
        DELETE_DEBUG_PRINT_OBJECT();
#endif

        ShutDown();

        delete(g_pGlobalLock);
        delete(g_pServerCache);
        break;

    default:
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   entry point for NT - post .546
//
//----------------------------------------------------------------------------
BOOL
DllMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    return LibMain((HINSTANCE)hDll, dwReason, lpReserved);
}


//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsidIndex
//
//  Synopsis:   Returns the index of the given CLSID in the cache, or
//              -1 if the CLSID is not present in the cache
//
//  Arguments:  [clsid]
//
//  Returns:    int
//
//-------------------------------------------------------------------------

int
GetCachedClsidIndex(REFCLSID clsid)
{
    int             i;
    CLSCACHE *      pclscache;

    for (i = 0, pclscache = g_aclscache;
         i < MY_ARRAY_SIZE(g_aclscache);
         i ++, pclscache++)
    {
        if (IsEqualCLSID(*pclscache->pclsid, clsid))
            return i;
    }

    return -1;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClassFactory
//
//  Synopsis:   Returns the cached class factory with the given index.
//              The pointer returned has been AddRef'd.
//
//  Arguments:  [iclsid]
//
//  Returns:    IClassFactory *
//
//-------------------------------------------------------------------------

IClassFactory *
GetCachedClassFactory(int iclsid)
{
    IClassFactory * pCF;

    pCF = g_aclscache[iclsid].pCF;
    pCF->AddRef();

    return pCF;
}




//+------------------------------------------------------------------------
//
//  Function:   GetCachedClsid
//
//  Synopsis:   Returns the CLSID corresponding to the given index.
//              Normally, code should call GetCachedClassFactory to get
//              the class factory directly.
//
//  Arguments:  [iclsid]    --  Clsid index
//              [pclsid]    --  Matching clsid returned in *pclsid
//
//-------------------------------------------------------------------------

void
GetCachedClsid(int iclsid, CLSID * pclsid)
{
    // Assert(iclsid >= 0);
    // Assert(iclsid < ARRAY_SIZE(g_aclscache));

    *pclsid = *g_aclscache[iclsid].pclsid;
}


//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI DllRegisterServer(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];

#ifdef ADSI_BUILD_WIN95
    if ( IISGetPlatformType() == PtWindows95 ) {
        return(DllRegisterServerWin95());
    }
#endif //ADSI_BUILD_WIN95

    hModule=GetModuleHandle(TEXT("ADSIIS.DLL"));

    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileName(hModule, pszName, MAX_PATH+1)==0) {
            return E_UNEXPECTED;
            }

    DWORD dwNameSize = ((DWORD)wcslen(pszName) + 1) * sizeof(WCHAR);

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                       TEXT("Software\\Microsoft\\ADs\\Providers\\IIS"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISNamespace"),
                      sizeof(TEXT("IISNamespace")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IISNamespace\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Namespace Object"),
                      sizeof(TEXT("IIS Namespace Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISNamespace"),
                      sizeof(TEXT("IISNamespace")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("IIS\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{d88966de-89f2-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{d88966de-89f2-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Provider Object"),
                      sizeof(TEXT("IIS Provider Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS"),
                      sizeof(TEXT("IIS")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("Mimemap\\CLSID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{9036b028-a780-11d0-9b3d-0080c710ef95}"),
                      sizeof(TEXT("{9036b028-a780-11d0-9b3d-0080c710ef95}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(HKEY_CLASSES_ROOT,
                       TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyCLSID, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IIS Mimemap Object"),
                      sizeof(TEXT("IIS Mimemap Object")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("InprocServer32"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT("ThreadingModel"), NULL, REG_SZ,
                      (BYTE*) TEXT("Both"),
                      sizeof(TEXT("Both")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("ProgID"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("IISMimemap"),
                      sizeof(TEXT("IISMimemap")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("TypeLib"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}"),
                      sizeof(TEXT("{49d704a0-89f7-11d0-8527-00c04fd8d503}")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyEx(hKeyCLSID,
                       TEXT("Version"),
                       NULL, TEXT(""), REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueEx(hKeyTemp, TEXT(""), NULL, REG_SZ,
                      (BYTE*) TEXT("0.0"),
                      sizeof(TEXT("0.0")))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "PropertyAttribute\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{FD2280A8-51A4-11D2-A601-3078302C2030}",
                      sizeof("{FD2280A8-51A4-11D2-A601-3078302C2030}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS PropertyAttribute Object",
                      sizeof("IIS PropertyAttribute Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) pszName,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISPropertyAttribute",
                      sizeof("IISPropertyAttribute"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);


    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServer
//
//  Synopsis:   Register registry keys for adsiis
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI DllUnregisterServer(void) {

#ifdef ADSI_BUILD_WIN95
    if ( IISGetPlatformType() == PtWindows95 ) {
        return(DllUnregisterServerWin95());
    }
#endif //ADSI_BUILD_WIN95

    HRESULT hr = S_OK;
    hr = UnRegisterTypeLib(LIBID_IISOle,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\ADs\\Providers\\IIS"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISNamespace\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IISNamespace"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IIS\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("IIS"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Mimemap\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("Mimemap"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("PropertyAttribute\\CLSID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("PropertyAttribute"));

    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\InprocServer32"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\ProgID"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\TypeLib"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}\\Version"));
    RegDeleteKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\{FD2280A8-51A4-11D2-A601-3078302C2030}"));

    return hr;
}

#ifdef ADSI_BUILD_WIN95

//+------------------------------------------------------------------------
//
//  Function:   DllRegisterServerWin95
//
//  Synopsis:   Register registry keys for adsiis on win95
//
//  Arguments:  None
//
//-------------------------------------------------------------------------

STDAPI
DllRegisterServerWin95(
    )
{
    HKEY hKeyCLSID, hKeyTemp;
    DWORD dwDisposition;
    HMODULE hModule;
    HRESULT hr;
    ITypeLib   *pITypeLib;
    WCHAR pszName[MAX_PATH +1];
    CHAR pszNameA[MAX_PATH +1];

    hModule=GetModuleHandleA("ADSIIS.DLL");
    if (!hModule) {
            return E_UNEXPECTED;
            }

    if (GetModuleFileNameA(hModule, pszNameA, MAX_PATH+1)==0) {
            return E_UNEXPECTED;
            }

    swprintf(pszName, OLESTR("%S"), pszNameA);

    DWORD dwNameSize = (DWORD)strlen(pszNameA + 1) * sizeof(CHAR);

    hr=LoadTypeLibEx(pszName, REGKIND_REGISTER, &pITypeLib);
    if (FAILED(hr)) {
        return E_UNEXPECTED;
    }

    pITypeLib->Release();

    if (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                       "Software\\Microsoft\\ADs\\Providers\\IIS",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISNamespace",
                      sizeof("IISNamespace"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "IISNamespace\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{d6bfa35e-89f2-11d0-8527-00c04fd8d503}",
                      sizeof("{d6bfa35e-89f2-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    //
    // register CLSID
    //

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Namespace Object",
                      sizeof("IIS Namespace Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) pszNameA,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISNamespace",
                      sizeof("IISNamespace"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "IIS\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{d88966de-89f2-11d0-8527-00c04fd8d503}",
                      sizeof("{d88966de-89f2-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Provider Object",
                      sizeof("IIS Provider Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) pszNameA,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IIS",
                      sizeof("IIS"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "Mimemap\\CLSID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{9036b028-a780-11d0-9b3d-0080c710ef95}",
                      sizeof("{9036b028-a780-11d0-9b3d-0080c710ef95}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(HKEY_CLASSES_ROOT,
                       "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyCLSID, &dwDisposition)!=ERROR_SUCCESS) {
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyCLSID, "", NULL, REG_SZ,
                      (BYTE*) "IIS Mimemap Object",
                      sizeof("IIS Mimemap Object"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegCreateKeyExA(hKeyCLSID,
                       "InprocServer32",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) pszNameA,
                      dwNameSize)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "ThreadingModel", NULL, REG_SZ,
                      (BYTE*) "Both",
                      sizeof("Both"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "ProgID",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "IISMimemap",
                      sizeof("IISMimemap"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "TypeLib",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "{49d704a0-89f7-11d0-8527-00c04fd8d503}",
                      sizeof("{49d704a0-89f7-11d0-8527-00c04fd8d503}"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);

    if (RegCreateKeyExA(hKeyCLSID,
                       "Version",
                       NULL, "", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL,
                       &hKeyTemp, &dwDisposition)!=ERROR_SUCCESS) {
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    if (RegSetValueExA(hKeyTemp, "", NULL, REG_SZ,
                      (BYTE*) "0.0",
                      sizeof("0.0"))!=ERROR_SUCCESS) {
                RegCloseKey(hKeyTemp);
                RegCloseKey(hKeyCLSID);
                return E_UNEXPECTED;
                }

    RegCloseKey(hKeyTemp);
    RegCloseKey(hKeyCLSID);

    return NOERROR;
}

//+------------------------------------------------------------------------
//
//  Function:   DllUnregisterServerWin95
//
//  Synopsis:   Register registry keys for adsiis on win95
//
//  Arguments:  None
//
//+------------------------------------------------------------------------
/* #pragma INTRINSA suppress=all */
STDAPI
DllUnregisterServerWin95(void) {

    HRESULT hr = S_OK;

    hr = UnRegisterTypeLib(LIBID_IISOle,
                      1,
                      0,
                      0,
                      SYS_WIN32);

    RegDeleteKeyA(HKEY_LOCAL_MACHINE, "Software\\Microsoft\\ADs\\Providers\\IIS");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IISNamespace\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IISNamespace");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d6bfa35e-89f2-11d0-8527-00c04fd8d503}");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IIS\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "IIS");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{d88966de-89f2-11d0-8527-00c04fd8d503}");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "Mimemap\\CLSID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "Mimemap");

    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\InprocServer32");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\ProgID");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\TypeLib");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}\\Version");
    RegDeleteKeyA(HKEY_CLASSES_ROOT, "CLSID\\{9036b028-a780-11d0-9b3d-0080c710ef95}");


    return hr;
}

#endif // ADSI_BUILD_WIN95
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\pop3s.h ===
/**********************************************************************/
/**                       Microsoft Windows NT                       **/
/**                Copyright(c) Microsoft Corp., 1993                **/
/**********************************************************************/

/*
    POP3S.h

    This file contains constants & type definitions shared between the
    POP3 Service, Installer, and Administration UI.


    FILE HISTORY:
        KeithMo     10-Mar-1993 Created.

*/
#ifndef _POP3S_H_
#define _POP3S_H_

#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus
#if !defined(MIDL_PASS)
#include <winsock.h>
#endif


///////////////////////////////////////////////////////////////////////////////////////
// 
//	POP3 Metabase Properties
//

#define IIS_MD_POP3_SERVICE_BASE			(POP3_MD_ID_BEGIN_RESERVED + 500)
//	
// Metabase path: /LM/Pop3Svc
//
#define MD_POP3_SERVICE_VERSION				(IIS_MD_POP3_SERVICE_BASE + 0)
#define MD_POP3_UPDATED_DEFAULT_DOMAIN		(IIS_MD_POP3_SERVICE_BASE + 2)

/*
Standard properties used here:
MD_CONNECTION_TIMEOUT
MD_MAX_CONNECTION
MD_SERVER_COMMENT
MD_SERVER_AUTOSTART
MD_SERVER_SIZE
MD_SERVER_LISTEN_BACKLOG
MD_SERVER_BINDINGS
MD_SECURE_PORT
MD_LOGON_METHOD
MD_AUTHORIZATION
MD_LOG_TYPE
MD_LOGFILE_DIRECTORY
MD_LOGFILE_PERIOD
MD_LOGFILE_TRUNCATE_SIZE
MD_NTAUTHENTICATION_PROVIDERS
*/


#define IIS_MD_POP3_BASE					(POP3_MD_ID_BEGIN_RESERVED)
//
// Metabase path: /LM/Pop3Svc/<inst#>/Root/<vroot>
//
#define MD_POP3_EXPIRE_MAIL					(IIS_MD_POP3_BASE + 0)
#define MD_POP3_EXPIRE_MSG_HOURS			(IIS_MD_POP3_BASE + 1)
/*
Standard properties used here:
MD_VR_PATH
MD_VR_USERNAME
MD_VR_PASSWORD
*/


//	
// Metabase path: /LM/Pop3Svc/<inst#>/Parameters
//
#define IIS_MD_POP3_PARAMS_BASE             (POP3_MD_ID_BEGIN_RESERVED + 200)
#define MD_POP3_CMD_LOG_FLAGS               (IIS_MD_POP3_PARAMS_BASE + 0)
#define MD_POP3_NO_TRANSMITFILES            (IIS_MD_POP3_PARAMS_BASE + 1)
#define MD_POP3_STATIC_BUFFER_SIZE          (IIS_MD_POP3_PARAMS_BASE + 2)
#define MD_POP3_FILE_IO_BUFFER_SIZE         (IIS_MD_POP3_PARAMS_BASE + 3)
#define MD_POP3_MAX_OUTSTANDING_IO          (IIS_MD_POP3_PARAMS_BASE + 4)
#define MD_POP3_SHARING_RETRY_ATTEMPTS      (IIS_MD_POP3_PARAMS_BASE + 5)
#define MD_POP3_SHARING_RETRY_SLEEP         (IIS_MD_POP3_PARAMS_BASE + 6)
#define MD_POP3_MSGS_PER_MAILBAG            (IIS_MD_POP3_PARAMS_BASE + 7)
#define MD_POP3_BUFFERED_WRITES             (IIS_MD_POP3_PARAMS_BASE + 9)
#define MD_POP3_SEND_BUFFER_SIZE            (IIS_MD_POP3_PARAMS_BASE + 10)
#define MD_POP3_RECV_BUFFER_SIZE            (IIS_MD_POP3_PARAMS_BASE + 11)
#define MD_POP3_MAX_NUM_CONNECTIONS         (IIS_MD_POP3_PARAMS_BASE + 12)
#define MD_POP3_MAX_MAILBAG_INSTANCES       (IIS_MD_POP3_PARAMS_BASE + 13)
#define MD_POP3_ROUTING_SOURCE              (IIS_MD_POP3_PARAMS_BASE + 14)
#define MD_POP3_INFO_MAX_ERRORS             (IIS_MD_POP3_PARAMS_BASE + 15)
#define MD_POP3_DEFAULT_DOMAIN_VALUE        (IIS_MD_POP3_PARAMS_BASE + 16)
#define MD_POP3_ROUTING_DLL                 (IIS_MD_POP3_PARAMS_BASE + 17)
#define MD_POP3_EXPIRE_DELAY                (IIS_MD_POP3_PARAMS_BASE + 18)
#define MD_POP3_EXPIRE_START                (IIS_MD_POP3_PARAMS_BASE + 19)
#define MD_POP3_EXPIRE_DIRS_MAX             (IIS_MD_POP3_PARAMS_BASE + 20)
#define MD_POP3_EXPIRE_INSTANCE_MAIL        (IIS_MD_POP3_PARAMS_BASE + 21)
#define MD_POP3_CLEARTEXT_AUTH_PROVIDER     (IIS_MD_POP3_PARAMS_BASE + 22)
#define MD_POP3_DS_TYPE                     (IIS_MD_POP3_PARAMS_BASE + 23)
#define MD_POP3_DS_DATA_DIRECTORY           (IIS_MD_POP3_PARAMS_BASE + 24)
#define MD_POP3_DS_DEFAULT_MAIL_ROOT        (IIS_MD_POP3_PARAMS_BASE + 25)
#define MD_POP3_DS_BIND_TYPE                (IIS_MD_POP3_PARAMS_BASE + 26)
#define MD_POP3_DS_SCHEMA_TYPE              (IIS_MD_POP3_PARAMS_BASE + 27)
#define MD_POP3_DS_HOST                     (IIS_MD_POP3_PARAMS_BASE + 28)
#define MD_POP3_DS_NAMING_CONTEXT           (IIS_MD_POP3_PARAMS_BASE + 29)
#define MD_POP3_DS_ACCOUNT                  (IIS_MD_POP3_PARAMS_BASE + 30)
#define MD_POP3_DS_PASSWORD                 (IIS_MD_POP3_PARAMS_BASE + 31)
#define MD_POP3_DS_MAX_RESOLVE_BUFFERS      (IIS_MD_POP3_PARAMS_BASE + 32)
#define MD_POP3_DS_MAX_VIRTUAL_SERVERS      (IIS_MD_POP3_PARAMS_BASE + 33)
#define MD_POP3_DS_MAX_HANDLE_CACHE_ENTRIES (IIS_MD_POP3_PARAMS_BASE + 34)
#define MD_POP3_DS_SORT_THRESHOLD           (IIS_MD_POP3_PARAMS_BASE + 35)

#ifdef __cplusplus
}
#endif  // _cplusplus

#endif  // _POP3S_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\parse.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:  parse.cxx
//
//  Contents:  IIS Pathname Parser
//
//    The Pathname Parser is a key component in ADs providers. It checks for
//    syntactic validity of an ADs pathname that has been passed to this
//    provider. If the syntax is valid, then an OBJECTINFO structure is
//    constructed. This OBJECTINFO structure contains a componentized version
//    of the ADs pathname for this object.
//
//    Note all that is being done is a syntax check. Rather than special-case
//    every single new nuance to pathnames, all path checking must conform to
//    the grammar rules laid out by the parser.
//
//
//
//  History:
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop

KWDLIST KeywordList[MAX_KEYWORDS] =
{
    { TOKEN_SCHEMA, SCHEMA_CLASS_NAME},
    { TOKEN_CLASS, CLASS_CLASS_NAME },
    { TOKEN_PROPERTY, PROPERTY_CLASS_NAME },
    { TOKEN_SYNTAX, SYNTAX_CLASS_NAME },
};


// Object -> PathName, Type, eos
// Object -> PathName, eos

//+---------------------------------------------------------------------------
//  Function:   ADsObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <ADsObject> -> <ProviderName> <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//----------------------------------------------------------------------------
HRESULT
ADsObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = ProviderName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

    pObjectInfo->ObjectType = TOKEN_IISOBJECT;
    pObjectInfo->ComponentArray = NULL;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    switch (dwToken) {

    case TOKEN_END:
        RRETURN(S_OK);

    case TOKEN_COMMA:
        hr = Type(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);
        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
        if (dwToken == TOKEN_END) {
            RRETURN(S_OK);
        }else {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    default:
        hr = pTokenizer->PushBackToken();


        hr = IISObject(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        switch (dwToken) {
        case TOKEN_END:
            RRETURN(S_OK);

        case TOKEN_COMMA:
            hr = Type(pTokenizer, pObjectInfo);
            BAIL_IF_ERROR(hr);
            hr = pTokenizer->GetNextToken(szToken, &dwToken);
            BAIL_IF_ERROR(hr);
            if (dwToken == TOKEN_END) {
                RRETURN(S_OK);
            }else {
                RRETURN(E_ADS_BAD_PATHNAME);
            }

        default:
            RRETURN(E_FAIL);

        }
    }

cleanup:
    RRETURN(hr);

}


//+---------------------------------------------------------------------------
//  Function:   IISObject
//
//  Synopsis:   parses an ADs pathname passed to this provider. This function
//              parses the following grammar rules
//
//              <IISObject> -> "\\""identifier""\" <IISObject>
//
//
//  Arguments:  [CLexer * pTokenizer] - a lexical analyzer object
//              [POBJECTINFO pObjectInfo] - a pointer to an OBJECTINFO structure
//
//  Returns:    [HRESULT] 0 if successful, error HRESULT if not
//
//  Modifies:   pTokenizer (consumes the input buffer)
//
//----------------------------------------------------------------------------

HRESULT
IISObject(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) &&  (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if ((dwToken != TOKEN_FSLASH) && (dwToken != TOKEN_BSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }


    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);
    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddTreeName(pObjectInfo, szToken);
    BAIL_IF_ERROR(hr);

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    //
    // If we get an TOKEN_END, then we have a tree name only \\<tree_name>
    //

    if (dwToken == TOKEN_END || dwToken == TOKEN_COMMA) {
        hr = pTokenizer->PushBackToken();
        RRETURN(S_OK);
    }

    if ((dwToken != TOKEN_BSLASH) && (dwToken != TOKEN_FSLASH)) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = PathName(pTokenizer, pObjectInfo);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

HRESULT
ProviderName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_ATSIGN) {

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);

        if (dwToken != TOKEN_IDENTIFIER) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_EXCLAMATION) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else if (dwToken == TOKEN_IDENTIFIER) {

        hr = AddProviderName(pObjectInfo, szToken);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);


        if (dwToken != TOKEN_COLON) {
            RRETURN(E_ADS_BAD_PATHNAME);
        }

    }else {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    //
    // You can now disable the processing for "@" and "!" treat them
    // as ordinary characters.
    //

    pTokenizer->SetAtDisabler(TRUE);


    RRETURN(S_OK);

cleanup:

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
PathName(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    HRESULT hr;
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;

    do
    {
        hr = Component(pTokenizer, pObjectInfo);
        BAIL_IF_ERROR(hr);

        hr = pTokenizer->GetNextToken(szToken, &dwToken);
        BAIL_IF_ERROR(hr);
    }
    while( (dwToken == TOKEN_BSLASH) || (dwToken == TOKEN_FSLASH) );

    hr = pTokenizer->PushBackToken();
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:  Component -> <identifier>
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
Component(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szComponent[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szComponent, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken != TOKEN_IDENTIFIER) {
        RRETURN(E_ADS_BAD_PATHNAME);
    }

    hr = AddComponent(pObjectInfo, szComponent, NULL);
    BAIL_IF_ERROR(hr);

cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
CLexer::CLexer(LPWSTR szBuffer):
                _ptr(NULL),
                _Buffer(NULL),
                _dwLastTokenLength(0),
                _dwLastToken(0),
                _dwEndofString(0),
                _bAtDisabled(FALSE)
{
    if (!szBuffer || !*szBuffer) {
        return;
    }
    _Buffer = AllocADsStr(szBuffer);
    _ptr = _Buffer;
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    08-12-96   t-danal     Created.
//
//----------------------------------------------------------------------------
CLexer::~CLexer()
{
    FreeADsStr(_Buffer);
}

/*++
    This routine assumes that szToken is a buffer of at least MAX_TOKEN_LENGTH
--*/
HRESULT
CLexer::GetNextToken(LPWSTR szToken, LPDWORD pdwToken)
{
    WCHAR c;
    DWORD state = 0;
    LPWSTR pch = szToken;

    memset(szToken, 0, sizeof(WCHAR) * MAX_TOKEN_LENGTH);
    _dwLastTokenLength = 0;
    while (1) {
        c = NextChar();
        switch (state) {
        case  0:
            if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
            }
            *pch++ = c;

            if (c == L'\\') {
                *pdwToken = TOKEN_BSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'/') {
                *pdwToken = TOKEN_FSLASH;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L',') {
                *pdwToken = TOKEN_COMMA;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'='){
                *pdwToken = TOKEN_EQUAL;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }
            else if (c == L':'){
                *pdwToken = TOKEN_COLON;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'\0'){
                *pdwToken = TOKEN_END;
                _dwLastToken = *pdwToken;
                RRETURN(S_OK);
            }else if (c == L'@') {

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_ATSIGN;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);

                }else {
                    state = 1;
                }

            }else if (c == L'!'){

                if (!_bAtDisabled) {

                    *pdwToken = TOKEN_EXCLAMATION;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {
                    state = 1;
                }

            }else {

                state = 1;
            }
            break;


        case 1:
            if (c == L'\\' || c == L'\0' || c == L',' ||
                    c == L'=' ||
                    c == L':' || c == L'/') {
                PushbackChar();

                *pdwToken = TOKEN_IDENTIFIER;
                _dwLastToken = *pdwToken;
                RRETURN (S_OK);

            }else if (c == L'@' || c == L'!') {

                if (!_bAtDisabled) {

                    PushbackChar();

                    *pdwToken = TOKEN_IDENTIFIER;
                    _dwLastToken = *pdwToken;
                    RRETURN(S_OK);


                }else {

                    if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                        RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                    }
                    *pch++ = c;
                    state = 1;
                    break;

                }

            }else {
                if (_dwLastTokenLength++ >= MAX_TOKEN_LENGTH) {
                    RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
                }
                *pch++ = c;
                state = 1;
                break;
            }

        default:
            RRETURN(RETURNCODETOHRESULT(ERROR_INVALID_NAME));
        }
    }
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
WCHAR
CLexer::NextChar()
{
    if (_ptr == NULL || *_ptr == L'\0') {
        _dwEndofString = TRUE;
        return(L'\0');
    }
    return(*_ptr++);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
HRESULT
CLexer::PushBackToken()
{
    if (_dwLastToken == TOKEN_END) {
        RRETURN(S_OK);
    }
    _ptr -= _dwLastTokenLength;

    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
void
CLexer::PushbackChar()
{
    if (_dwEndofString) {
        return;
    }
    _ptr--;

}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
//----------------------------------------------------------------------------
BOOL
CLexer::IsKeyword(LPWSTR szToken, LPDWORD pdwToken)
{
    DWORD i = 0;

    for (i = 0; i < MAX_KEYWORDS; i++) {
        if (!_wcsicmp(szToken, KeywordList[i].Keyword)) {
            *pdwToken = KeywordList[i].dwTokenId;
            return(TRUE);
        }
    }
    *pdwToken = 0;
    return(FALSE);
}

//+---------------------------------------------------------------------------
//Function:
//
//Synopsis:
//
//Arguments:
//
//Returns:
//
//Modifies:
//
//History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
AddComponent(POBJECTINFO pObjectInfo, LPWSTR szComponent, LPWSTR szValue)
{
    if (!szComponent || !*szComponent) {
        RRETURN(E_FAIL);
    }

    if (pObjectInfo->ComponentArray == NULL) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) AllocADsMem(sizeof(COMPONENT)*MAXCOMPONENTS);
        pObjectInfo->MaxComponents = MAXCOMPONENTS;
    }
    else if (pObjectInfo->NumComponents == pObjectInfo->MaxComponents) {
        pObjectInfo->ComponentArray =
               (PCOMPONENT) ReallocADsMem(
                                  pObjectInfo->ComponentArray,
                                  sizeof(COMPONENT)*pObjectInfo->MaxComponents,
                                  sizeof(COMPONENT)*(
                                    pObjectInfo->MaxComponents+MAXCOMPONENTS)
                                  );
        pObjectInfo->MaxComponents += MAXCOMPONENTS;
    }

    pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szComponent =
                        AllocADsStr(szComponent);

    if (szValue && *szValue) {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue =
                        AllocADsStr(szValue);
    }
    else {
        pObjectInfo->ComponentArray[pObjectInfo->NumComponents].szValue = NULL;
    }

    pObjectInfo->NumComponents++;

    RRETURN(S_OK);
}

HRESULT
AddProviderName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->ProviderName = AllocADsStr(szToken);

    RRETURN(S_OK);
}


HRESULT
AddTreeName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    pObjectInfo->TreeName = AllocADsStr(szToken);

    RRETURN(S_OK);
}

HRESULT
AddClassName(POBJECTINFO pObjectInfo, LPWSTR szToken)
{
    if (!szToken || !*szToken) {
        RRETURN(E_FAIL);
    }

    wcscpy(pObjectInfo->ClassName, szToken);

    RRETURN(S_OK);
}

//+---------------------------------------------------------------------------
// Function:
//
// Synopsis:
//
// Arguments:
//
// Returns:
//
// Modifies:
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------
HRESULT
SetType(POBJECTINFO pObjectInfo, DWORD dwToken)
{
    pObjectInfo->ObjectType = dwToken;
    RRETURN(S_OK);
}


//+---------------------------------------------------------------------------
// Function:    Type
//
// Synopsis:    Parses Type-> "user" | "group" etc
//
// Arguments:   [CLexer * pTokenizer]
//              [POBJECTINFo pObjectInfo]
//
// Returns:     HRESULT
//
// Modifies:    -
//
// History:    11-3-95   krishnag     Created.
//
//----------------------------------------------------------------------------


HRESULT
Type(CLexer * pTokenizer, POBJECTINFO pObjectInfo)
{
    WCHAR szToken[MAX_TOKEN_LENGTH];
    DWORD dwToken;
    HRESULT hr;

    hr = pTokenizer->GetNextToken(szToken, &dwToken);
    BAIL_IF_ERROR(hr);

    if (dwToken == TOKEN_IDENTIFIER ) {
        if (pTokenizer->IsKeyword(szToken, &dwToken)) {
            hr = SetType(pObjectInfo, dwToken);
            RRETURN(hr);
        }
        hr = AddClassName(pObjectInfo, szToken);
        RRETURN(hr);
    }

    RRETURN(E_FAIL);

cleanup:
    RRETURN(hr);
}


void
CLexer::SetAtDisabler(
    BOOL bFlag
    )
{
    _bAtDisabled = bFlag;
}

BOOL
CLexer::GetAtDisabler()
{
    return(_bAtDisabled);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\schemini.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  schemini.cxx
//
//  Contents:  Loading Schema/Property from metabase code
//
//  History:   28-Apr-97     Markand    Created.
//  History:   18-Aug-98     sophiac    Extensible schema
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#define INITGUID
#pragma hdrstop
#include "mddef.h"
#include <tchar.h>

#define DEFAULT_TIMEOUT_VALUE                    30000

StrMap::StrMap() {
	count = 0;
	mapSize = 64;
	map = (StrMapEntry *)malloc(sizeof(StrMapEntry) * mapSize);
}

StrMap::~StrMap() {
	free(map);
}

DWORD StrMap::GetEntries() {
	return count;
}

LPWSTR StrMap::GetEntryName(DWORD dwIndex) {
	return map[dwIndex].m_str;
}


BOOL StrMap::CheckSpace() {
	if (count < mapSize)
		return TRUE;
	mapSize += 32;
    StrMapEntry* map_old = map;
	if ((map = (StrMapEntry *)realloc(map, sizeof(StrMapEntry)*mapSize)) == NULL)
	{
        if (map_old)
        {
            free(map_old);
        }
		return FALSE;
	}
	return TRUE;
}

BOOL StrMap::Add(LPWSTR str, void *data) {
	if (!CheckSpace())
		return FALSE;
	map[count].m_str = str;
	map[count].m_data = data;
	count++;
	return TRUE;
}

BOOL StrMap::ClearEntry(DWORD dwIndex) {

	count--;

	void* prop = map[dwIndex].m_data;
	
	// replace object to be deleted by last object in list and decrement count

	map[dwIndex].m_str  = map[count].m_str;
	map[dwIndex].m_data = map[count].m_data; 
	map[count].m_str  = NULL;
	map[count].m_data = NULL;

	if (prop)
		delete prop;

	return TRUE;
}

void *StrMap::Find(LPWSTR str) {
	for (int i=0; i < count; i++) {
		if (!_wcsicmp(str, map[i].m_str))
			return map[i].m_data;
	}
	return NULL;
}

void *StrMap::operator[] (LPWSTR str) {
	return Find(str);
}	


DWORDMap::DWORDMap() {
	count = 0;
	mapSize = 64;
	map = (DWORDMapEntry *)malloc(sizeof(DWORDMapEntry) * mapSize);
}

DWORDMap::~DWORDMap() {
	free(map);
}

BOOL DWORDMap::CheckSpace() {
	if (count < mapSize)
		return TRUE;
	mapSize += 32;

    DWORDMapEntry* map_old = map;
	if ((map = (DWORDMapEntry *)realloc(map, sizeof(DWORDMapEntry)*mapSize)) == NULL)
	{
        if (map_old)
        {
            free(map_old);
        }
		return FALSE;
    }
	return TRUE;
}

BOOL DWORDMap::Add(DWORD val, void *data) {
	if (!CheckSpace())
		return FALSE;
	map[count].m_val = val;
	map[count].m_data = data;
	count++;
	return TRUE;
}

BOOL DWORDMap::ClearEntry(DWORD id) {
	//  !! don't delete the m_data here
	//  !! it will be or already has been deleted
	//  !! by StrMap::ClearEntry

	int ri = 0;

	for (int i=0; i < count; i++) {
		if (id == map[i].m_val)
			ri = i;		
	}

	count--;

	map[ri].m_val  = map[count].m_val;
	map[ri].m_data = map[count].m_data;
	map[count].m_val  = NULL;
	map[count].m_data = NULL;

	return TRUE;
}

void *DWORDMap::Find(DWORD val) {
	for (int i=0; i < count; i++) {
		if (val == map[i].m_val)
			return map[i].m_data;
	}
	return NULL;
}

void *DWORDMap::operator[] (DWORD val) {
	return Find(val);
}	

IIsSchemaClass::IIsSchemaClass(LPWSTR _name) {
    memset(&classInfo, 0, sizeof(CLASSINFO));
	name = new WCHAR[wcslen(_name)+1];
	wcscpy(name, _name);
}

IIsSchemaClass::~IIsSchemaClass() {
	delete[] name;

	if (classInfo.bstrContainment)
		FreeADsMem(classInfo.bstrContainment);
	if (classInfo.bstrOptionalProperties)
		FreeADsMem(classInfo.bstrOptionalProperties);
	if (classInfo.bstrMandatoryProperties)
		FreeADsMem(classInfo.bstrMandatoryProperties);
}

HRESULT
IISSchemaProperty::SetpropInfo(PROPERTYINFO *ppropInfo) {

    HRESULT hr = S_OK;
    LPWSTR pszStr;
 
    if (propInfo.bstrOID) {
        ADsFreeString( propInfo.bstrOID );
    }
    if (propInfo.bstrSyntax) {
        ADsFreeString( propInfo.bstrSyntax );
    }
    if (propInfo.szDefault) {
        if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_STRING ||
            propInfo.dwSyntaxId == IIS_SYNTAX_ID_EXPANDSZ) {
            FreeADsStr( propInfo.szDefault );
        }
        else if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem( propInfo.szDefault );
        }
    }

    memset(&propInfo, 0, sizeof(PROPERTYINFO));
    memcpy(&propInfo, ppropInfo, sizeof(PROPERTYINFO));

    hr = ADsAllocString(ppropInfo->bstrSyntax, &propInfo.bstrSyntax);
    BAIL_ON_FAILURE(hr);
    hr = ADsAllocString(ppropInfo->bstrOID, &propInfo.bstrOID);
    BAIL_ON_FAILURE(hr);

    switch(ppropInfo->dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
         propInfo.dwDefault = ppropInfo->dwDefault;
         break;

    case IIS_SYNTAX_ID_STRING:
    case IIS_SYNTAX_ID_EXPANDSZ:
         if (ppropInfo->szDefault) {
             propInfo.szDefault = AllocADsStr((LPWSTR)(ppropInfo->szDefault));
             if (!propInfo.szDefault) {
                 hr = E_OUTOFMEMORY;
                 BAIL_ON_FAILURE(hr);
             }
         }
         break;

    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        pszStr = ppropInfo->szDefault;

        //
        // calculate length
        //

        if (pszStr) {
           DWORD dwLen = 0;

           //
           // if first char is a null char
           //

           if (*pszStr == L'\0') {
               dwLen = 1;
               pszStr++;
           }

           while (*pszStr != L'\0') {
               while (*pszStr != L'\0') {
                   pszStr++;
                   dwLen++;
               }
               pszStr++;
               dwLen++;
           }
           propInfo.szDefault = (LPWSTR)AllocADsMem((dwLen +1) * sizeof(WCHAR));
           if (!propInfo.szDefault) {
               hr = E_OUTOFMEMORY;
               BAIL_ON_FAILURE(hr);
           }
           memcpy(propInfo.szDefault, (LPWSTR)ppropInfo->szDefault, 
              (dwLen+1)*sizeof(WCHAR));
        }

        break;

    default:
        break;

    }

error:

    RRETURN(hr); 
}

IISSchemaProperty::IISSchemaProperty(DWORD id, LPWSTR _name, int nameLen) {
    memset(&propInfo, 0, sizeof(PROPERTYINFO));
	name = new WCHAR[nameLen];
	wcscpy(name, _name);
	propID = id;
}

IISSchemaProperty::~IISSchemaProperty() {
	delete[] name;
    if (propInfo.szDefault) {
        if (propInfo.dwSyntaxId == IIS_SYNTAX_ID_MULTISZ) {
            FreeADsMem(propInfo.szDefault);
        }
        else {
            FreeADsStr(propInfo.szDefault);
        }
    }
}

HRESULT IIsSchemaClass::findContainedClassName(LPWSTR pszContainName) {
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)classInfo.bstrContainment;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszContainName)) {
			   return S_OK;
            }
        }

    }

	return E_ADS_SCHEMA_VIOLATION;
}

HRESULT IIsSchemaClass::SetclassInfo(PCLASSINFO pClassInfo) {
    HRESULT hr = S_OK;
    LPBYTE pBuffer = NULL;
    DWORD dwSize;

	if (classInfo.bstrContainment)
		FreeADsMem(classInfo.bstrContainment);
	if (classInfo.bstrOptionalProperties)
		FreeADsMem(classInfo.bstrOptionalProperties);
	if (classInfo.bstrMandatoryProperties)
		FreeADsMem(classInfo.bstrMandatoryProperties);

    memset(&classInfo, 0, sizeof(CLASSINFO));

    if (pClassInfo) {
        if (pClassInfo->bstrContainment) {
            dwSize = ((DWORD)wcslen(pClassInfo->bstrContainment)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrContainment, dwSize);
            classInfo.bstrContainment = (BSTR)pBuffer;
        }

        if (pClassInfo->bstrMandatoryProperties) {
            dwSize = ((DWORD)wcslen(pClassInfo->bstrMandatoryProperties)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrMandatoryProperties, dwSize);
            classInfo.bstrMandatoryProperties = (BSTR)pBuffer;
        }

        if (pClassInfo->bstrOptionalProperties) {
            dwSize = ((DWORD)wcslen(pClassInfo->bstrOptionalProperties)+1)*sizeof(WCHAR);
            pBuffer = (LPBYTE)AllocADsMem(dwSize);
            if (!pBuffer) {
                hr = E_OUTOFMEMORY;
                BAIL_ON_FAILURE(hr);
            }

            memcpy(pBuffer, pClassInfo->bstrOptionalProperties, dwSize);
            classInfo.bstrOptionalProperties = (BSTR)pBuffer;
        }
        classInfo.fContainer = pClassInfo->fContainer;
    }

error:

    RRETURN(hr); 
}

HRESULT IIsSchemaClass::findProp(LPWSTR pszPropName) {
    WCHAR szName[MAX_PATH];
    LPWSTR ObjectList = (LPWSTR)classInfo.bstrOptionalProperties;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszPropName)) {
			   return S_OK;
            }
        }

    }

    ObjectList = (LPWSTR)classInfo.bstrMandatoryProperties;

    while ((ObjectList = grabProp(szName, ObjectList)) != NULL) {
        if (*szName != L'\0') {
            if (!_wcsicmp(szName, pszPropName)) {
			   return S_OK;
            }
        }
	}

	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

BOOL IISSchemaProperty::InitFromMetaData(METADATA_GETALL_RECORD *mdga, BYTE *data) {
    PropValue pv;

    WCHAR* pszSyntax = NULL;

	if (mdga->dwMDDataType == BINARY_METADATA  && 
        mdga->dwMDDataLen >= sizeof(PropValue) - sizeof(LPWSTR)) 
    {
		memcpy(&pv, (data+mdga->dwMDDataOffset), sizeof(PropValue));

        propInfo.dwMetaID = pv.dwMetaID;
        propInfo.dwPropID = pv.dwPropID;
        propInfo.dwSyntaxId = pv.dwSynID;
        propInfo.lMaxRange = (long)pv.dwMaxRange;
        propInfo.lMinRange = (long)pv.dwMinRange;
        propInfo.dwFlags = pv.dwFlags;
        propInfo.dwMask = pv.dwMask;
        propInfo.dwMetaFlags = pv.dwMetaFlags;
        propInfo.dwUserGroup = pv.dwUserGroup;
        propInfo.fMultiValued = pv.fMultiValued;

        pszSyntax = SyntaxIdToString(pv.dwSynID);
        HRESULT hr = ADsAllocString(pszSyntax, &(propInfo.bstrSyntax));
        if FAILED(hr)
        {
            return FALSE;
        }

		return TRUE;
	}
	return FALSE;
}

BOOL IISSchemaProperty::InitPropertyDefaults(METADATA_GETALL_RECORD *mdga, BYTE *data) {

    WCHAR *ptr;
    BYTE  *bptr;

    propInfo.dwDefault = 0;
    propInfo.szDefault = NULL;

    if (!(mdga && data)){
        return TRUE;
    }

    switch(mdga->dwMDDataType) {
    case DWORD_METADATA:
         propInfo.dwDefault = *(DWORD *)(data+mdga->dwMDDataOffset);
         break;
    case STRING_METADATA:
    case EXPANDSZ_METADATA:
         propInfo.szDefault = AllocADsStr((LPWSTR)(data+mdga->dwMDDataOffset));
         break;
    case MULTISZ_METADATA:   
        ptr = (LPWSTR)(data+mdga->dwMDDataOffset);
        propInfo.szDefault = (LPWSTR) AllocADsMem(mdga->dwMDDataLen);
        memcpy(propInfo.szDefault, (LPWSTR)ptr, mdga->dwMDDataLen);
        break;

    case BINARY_METADATA:
        if (mdga->dwMDDataLen > 0)
        {
            bptr = (BYTE*)(data+mdga->dwMDDataOffset);
            propInfo.szDefault = (LPWSTR) AllocADsMem(mdga->dwMDDataLen);
            memcpy(propInfo.szDefault, bptr, mdga->dwMDDataLen);
            propInfo.dwBinDataLen = mdga->dwMDDataLen;
        }
        else
        {
            propInfo.dwBinDataLen = 0;
        }
        break;
    }
	return TRUE;
}

WCHAR *grabProp(WCHAR *out, WCHAR *in) {
	if (!in || *in == L'\0') {
		*out = L'\0';
		return NULL;
	}
	while (*in != L',' && *in != L'\0') {
		*out++ = *in++;
	}
	*out = L'\0';
	if (*in == L',')
		return ++in;
	return in;
}

WCHAR *SyntaxIdToString(DWORD syntaxID) {
	switch(syntaxID) {
	case IIS_SYNTAX_ID_BOOL:
	case IIS_SYNTAX_ID_BOOL_BITMASK:
		return L"Boolean";
	case IIS_SYNTAX_ID_DWORD:
		return L"Integer";
	case IIS_SYNTAX_ID_STRING:
		return L"String";
	case IIS_SYNTAX_ID_EXPANDSZ:
		return L"ExpandSz";
	case IIS_SYNTAX_ID_MIMEMAP:
		return L"MimeMapList";
	case IIS_SYNTAX_ID_MULTISZ:
		return L"List";
	case IIS_SYNTAX_ID_IPSECLIST:
		return L"IPSec";
	case IIS_SYNTAX_ID_NTACL:
		return L"NTAcl";
	case IIS_SYNTAX_ID_BINARY:
		return L"Binary";
	default:
		return L"(ERROR -- UNDEFINED SYNTAX ID)";
	}
}

BOOL DataForSyntaxID(PROPERTYINFO *pp, METADATA_RECORD *mdr) {
    static DWORD value=0;
    WCHAR *ptr;

    switch(pp->dwSyntaxId) {
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
    case IIS_SYNTAX_ID_DWORD:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&(pp->dwDefault);
        break;
    case IIS_SYNTAX_ID_STRING:
        mdr->dwMDDataType = STRING_METADATA;
        if (pp->szDefault) {
            mdr->dwMDDataLen = ((DWORD)wcslen(pp->szDefault)+1)*2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        mdr->dwMDDataType = EXPANDSZ_METADATA;
        if (pp->szDefault) {
            mdr->dwMDDataLen = ((DWORD)wcslen(pp->szDefault)+1)*2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        //
        // Note, ALL multisz types must have an extra \0 in the table.
        //
        mdr->dwMDDataType = MULTISZ_METADATA;
        if (pp->szDefault) {
            ptr = pp->szDefault;
            if (*ptr == L'\0') {
                ptr++;
            }
            while (*ptr!=0) {
                ptr += wcslen(ptr)+1;
            } 
            mdr->dwMDDataLen = (DWORD)DIFF((char *)ptr - (char *)pp->szDefault)+2;
        }
        else {
            mdr->dwMDDataLen = 0;
        }
        mdr->pbMDData = (unsigned char *)pp->szDefault;
        break;
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_BINARY:
        mdr->dwMDDataType = BINARY_METADATA;
        mdr->dwMDDataLen = 0;
        mdr->pbMDData = NULL;
        break;
    default:
        mdr->dwMDDataType = DWORD_METADATA;
        mdr->dwMDDataLen = sizeof(DWORD);
        mdr->pbMDData = (unsigned char *)&value;
        return FALSE;
    }
    return TRUE;
}

DWORD SyntaxToMetaID(DWORD syntaxID) {
	switch(syntaxID) {
	case IIS_SYNTAX_ID_BOOL:
	case IIS_SYNTAX_ID_BOOL_BITMASK:
	case IIS_SYNTAX_ID_DWORD:
		return DWORD_METADATA;

	case IIS_SYNTAX_ID_STRING:
		return STRING_METADATA;

	case IIS_SYNTAX_ID_EXPANDSZ:
		return EXPANDSZ_METADATA;

	case IIS_SYNTAX_ID_MIMEMAP:
	case IIS_SYNTAX_ID_MULTISZ:
	case IIS_SYNTAX_ID_HTTPERRORS:
	case IIS_SYNTAX_ID_HTTPHEADERS:
		return MULTISZ_METADATA;

	case IIS_SYNTAX_ID_IPSECLIST:
	case IIS_SYNTAX_ID_NTACL:
	case IIS_SYNTAX_ID_BINARY:
		return  BINARY_METADATA;

	default:
//		printf("ERROR, Unknown Syntax Type %x", syntaxID);
		return 0;
	}
	return 0;
}

MetaHandle::MetaHandle(IMSAdminBasePtr _pmb) : pmb(_pmb) {
	if (pmb)
		pmb->AddRef();
	h = 0;
}
MetaHandle::~MetaHandle() {
	if (pmb) {
		if (h)
			pmb->CloseKey(h);
		pmb->Release();
	}
}

HRESULT IIsSchema::IdToPropNameW(DWORD id, LPWSTR buf) {
	IISSchemaProperty *prop = (IISSchemaProperty *)idToProp[id];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
    wcscpy(buf, prop->getName());
	return S_OK;
}

HRESULT IIsSchema::PropNameWToId(LPWSTR propNameW, DWORD *id) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*id = prop->getPropID();
	return S_OK;
}

HRESULT IIsSchema::LookupFlagPropName(LPWSTR propNameW, LPWSTR FlagPropName) {
    DWORD id;
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	id = prop->getMetaID();
    return (ConvertID_To_PropName(id, FlagPropName));
}

HRESULT IIsSchema::LookupMetaID(LPWSTR propNameW, PDWORD pdwMetaId) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*pdwMetaId = prop->getMetaID();
	return S_OK;
}


HRESULT IIsSchema::LookupPropID(LPWSTR propNameW, PDWORD pdwPropId) {
	IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	*pdwPropId = prop->getPropID();
	return S_OK;
}

HRESULT IIsSchema::PropNameWToIISSchemaProp(LPWSTR propNameW, IISSchemaProperty **prop) {
	*prop = NULL;
	*prop = (IISSchemaProperty *)nameToProp[propNameW];
	if (!*prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	return S_OK;
}

HRESULT IIsSchema::ValidatePropertyName( LPWSTR szPropName) {
	DWORD propID;
	HRESULT hr;

	hr = PropNameWToId(szPropName, &propID);
	RRETURN(hr);
}

HRESULT IIsSchema::ValidateProperty(LPWSTR szClassName, LPWSTR szPropName) {
	HRESULT hr;
	IIsSchemaClass *sc;

	sc = (IIsSchemaClass*)nameToClass[szClassName];
	if (!sc)
		return E_ADS_PROPERTY_NOT_SUPPORTED;
	hr = sc->findProp(szPropName);

	RRETURN(hr);
}

HRESULT IIsSchema::ValidateContainedClassName(LPWSTR szClassName, LPWSTR szContainName) {
	HRESULT hr;
	IIsSchemaClass *sc;

	sc = (IIsSchemaClass *)nameToClass[szClassName];
	if (!sc)
		RRETURN(E_ADS_UNKNOWN_OBJECT);
	hr = sc->findContainedClassName(szContainName);
	RRETURN(hr);
}

HRESULT 
IIsSchema::GetDefaultProperty(
    LPWSTR szPropName, 
    PDWORD pdwNumValues, 
    PDWORD pdwSyntax, 
    LPBYTE *pBuffer
    ) 
/*++

Routine Description:

Arguments:

    LPBYTE *pBuffer     - pBuffer is not allocated, it just holds the
                          address of the default value in the PROPINFO
                          structure

Return Value:

Notes:

    Called by CPropertyCache::getproperty

    Currently binary values are not supported correctly, we
    may not ever support them.

--*/
{
	HRESULT hr = S_OK;

    IISSchemaProperty *prop = (IISSchemaProperty *)nameToProp[szPropName];

	if (!prop)
		return E_ADS_PROPERTY_NOT_SUPPORTED;

    *pdwSyntax = prop->getSyntaxID();

    switch(*pdwSyntax) {
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
    case IIS_SYNTAX_ID_DWORD:
        *pBuffer = (LPBYTE)prop->getdwDefaultAddr();
        *pdwNumValues = 1;
        break;
    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
    case IIS_SYNTAX_ID_NTACL:
        //
        // We don't currently support setting or getting default values,
        // so pBuffer should always be NULL. To support default values
        // on binaries, we need to transmit the length in the PROPINFO
        // structure.
        //
        *pBuffer = (LPBYTE)prop->getszDefault();
        *pdwNumValues = (DWORD)prop->getdwBinDataLen();
        break;
    case IIS_SYNTAX_ID_MULTISZ:
    {
        *pBuffer = (LPBYTE)prop->getszDefault();
        LPWSTR pszStr = (LPWSTR)*pBuffer;

        if (*pszStr == 0) {
            *pdwNumValues = 1;
        }
        else {
            *pdwNumValues = 0;
        }

        while (*pszStr != L'\0') {
            while (*pszStr != L'\0') {
                pszStr++;
            }
            (*pdwNumValues)++;
            pszStr++;
        }
        break;
    }   
	default:
        *pBuffer = (LPBYTE)prop->getszDefault();
        *pdwNumValues = 1;
        break;
    }

	RRETURN(hr);
}

HRESULT IIsSchema::PropNameWToSyntaxId(LPWSTR propNameW, DWORD *syntaxID) {
	IISSchemaProperty *prop;
	HRESULT hr;
	
	hr = PropNameWToIISSchemaProp(propNameW, &prop);
	BAIL_ON_FAILURE(hr);
	*syntaxID = prop->getSyntaxID();
	return S_OK;
error:
	return E_ADS_PROPERTY_NOT_SUPPORTED;
}

HRESULT IIsSchema::ValidateClassName(LPWSTR classNameW) {
	if (nameToClass[classNameW])
		RRETURN(ERROR_SUCCESS);
	else
        RRETURN(E_ADS_SCHEMA_VIOLATION);
}


HRESULT IIsSchema::ConvertID_To_PropName(
    DWORD dwIdentifier,
    LPWSTR pszPropertyName
    )
{
	HRESULT hr = S_OK;

	hr = IdToPropNameW(dwIdentifier, pszPropertyName);
    RRETURN(hr);
}

HRESULT IIsSchema::ConvertPropName_To_ID(
    LPWSTR pszPropertyName,
    PDWORD pdwIdentifier
    )
{
    HRESULT hr = S_OK;

    if (!pszPropertyName) {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
    }
	hr = PropNameWToId(pszPropertyName, pdwIdentifier);
error:

    RRETURN(hr);
}


HRESULT IIsSchema::LookupSyntaxID(
    LPWSTR pszPropertyName,
    PDWORD pdwSyntaxId
    )
{
    HRESULT hr = S_OK;

    if (!pszPropertyName) {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
    }
	hr = PropNameWToSyntaxId(pszPropertyName, pdwSyntaxId);
error:

    RRETURN(hr);
}


HRESULT IIsSchema::LookupMDFlags(
    DWORD dwPropID,
    PDWORD pdwAttribute,
    PDWORD pdwUserType
    )
{
    HRESULT hr = S_OK;
	IISSchemaProperty *prop=(IISSchemaProperty *)idToProp[dwPropID];
	if (prop) {
		*pdwAttribute = prop->getMetaFlags();
		*pdwUserType = prop->getUserGroup();
	} else {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
	}
	return S_OK;
error:
    RRETURN(hr);
}

HRESULT
IIsSchema::LookupBitMask(
    LPWSTR pszPropertyName,
    PDWORD pdwMaskBits
    )
{
    HRESULT hr = S_OK;
	IISSchemaProperty *prop=NULL;
	
	hr = PropNameWToIISSchemaProp(pszPropertyName, &prop);
	BAIL_ON_FAILURE(hr);

	if (prop) {
		*pdwMaskBits = prop->getMask();
	} else {
        hr = E_ADS_PROPERTY_NOT_SUPPORTED;
        BAIL_ON_FAILURE(hr);
	}
	return S_OK;
error:
    RRETURN(hr);
}

HRESULT IIsSchema::LoadAllData(IMSAdminBasePtr &pmb, 
					   MetaHandle &root, 
					   WCHAR *subdir, 
					   BYTE **buf, 
					   DWORD *size,
					   DWORD *count) {
	DWORD dataSet;
	DWORD neededSize;
	HRESULT hr;
	//
	// Try to get the property names.
	//
	hr = pmb->GetAllData(root,
					subdir,
					METADATA_NO_ATTRIBUTES,
					ALL_METADATA,
					ALL_METADATA,
					count,
					&dataSet,
					*size,
					*buf,
					&neededSize);
	if (!SUCCEEDED(hr)) {
		DWORD code = ERROR_INSUFFICIENT_BUFFER;
		if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
//			printf("Names buf of %d not big enough.  Need %d bytes\n", 
//					getAllBufSize,
//					neededSize);
			delete *buf;
			*buf = 0;
			*size = neededSize;
			*buf = new BYTE[neededSize];
			hr = pmb->GetAllData(root,
							subdir,
							METADATA_NO_ATTRIBUTES,
							ALL_METADATA,
							ALL_METADATA,
							count,
							&dataSet,
	 						*size,
							*buf,
							&neededSize);

		}
	}
	return hr;
}

// BUGBUG: Get rid of this constant ASAP!
// Sergeia: fix for bug 189797, buffer was too small
const DWORD getAllBufSize = 4096*2;
 
HRESULT IIsSchema::InitSchema(WCHAR *baseName, CCredentials& Credentials)
{
    DWORD bufSize = getAllBufSize;
    BYTE *buf = new BYTE[bufSize];
    HRESULT hr;
    COSERVERINFO csiName;
    COSERVERINFO *pcsiParam = &csiName;
    IClassFactory * pcsfFactory = NULL;
    IMSAdminBase * pAdminBase = NULL;
    IMSAdminBase * pAdminBaseT = NULL;
    DWORD count=0, dataSet=0, neededSize=0;
    METADATA_GETALL_RECORD *pmd;
    DWORD propBufSize = 128;
    DWORD i;
    MetaHandle root(NULL);
    LPWSTR pContainment = NULL;
    LPWSTR pOptProp = NULL;
    LPWSTR pMandProp = NULL;
    DWORD  dwData = 0;
    CLASSINFO classInfo;
    BOOL bMayBeIIS4 = FALSE;
    LPWSTR pszUserName = NULL;
    LPWSTR pszPassword = NULL;

    hr = Credentials.GetUserName(&pszUserName);
    if (FAILED(hr))
    {
	    if (buf)
        {
		    delete [] buf;
        }

        return hr;
    }
    
    hr = Credentials.GetPassword(&pszPassword);
    if (FAILED(hr))
    {
	    if (buf)
        {
		    delete [] buf;
        }

        return hr;
    }

    CComAuthInfo localAuthInfo(baseName,
                               pszUserName,
                               pszPassword);

    memset(pcsiParam, 0, sizeof(COSERVERINFO));

    pcsiParam = localAuthInfo.CreateServerInfoStruct();

    hr = CoGetClassObject(
            CLSID_MSAdminBase,
            CLSCTX_SERVER,
            pcsiParam,
            IID_IClassFactory,
            (void**) &pcsfFactory
            );

    BAIL_ON_FAILURE(hr);

    hr = localAuthInfo.ApplyProxyBlanket(pcsfFactory);

    BAIL_ON_FAILURE(hr);

    hr = pcsfFactory->CreateInstance(
            NULL,
            IID_IMSAdminBase,
            (void **) &pAdminBase
            );
    BAIL_ON_FAILURE(hr);

    hr = localAuthInfo.ApplyProxyBlanket(pAdminBase);

    BAIL_ON_FAILURE(hr);

    METADATA_HANDLE MDataHandle;
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            L"/Schema/Properties/Defaults", // Present Only in IIS5
            METADATA_PERMISSION_READ,
            20,
            &MDataHandle);

    if (HRESULTTOWIN32(hr) == ERROR_PATH_NOT_FOUND)
    {
        bMayBeIIS4 = TRUE;
    }
    if (HRESULTTOWIN32(hr) == ERROR_SUCCESS)
    {
	    pAdminBase->CloseKey(MDataHandle);
    }

    root.setpointer(pAdminBase);
    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
            L"/Schema/Properties",
            METADATA_PERMISSION_READ,
            DEFAULT_TIMEOUT_VALUE,
            root);

    BAIL_ON_FAILURE(hr);

    hr = LoadAllData(pAdminBase, root, L"Names", &buf, &bufSize, &count);

    BAIL_ON_FAILURE(hr);

    // Now, here we've gotten the list of properties/names.
    // Create IIsSchemaProperty objects for each.  We then
    // Add the object to the two maps.  Later, we will load
    // all of the "Properties/Values" properties, look up (by
    // id) the object, and initialize the property value.

    pmd = (METADATA_GETALL_RECORD *)buf;
    for ( i=0;i < count; i++, pmd++) 
    {

	    if (pmd->dwMDDataType != STRING_METADATA) 
	    {
		    continue;
	    }
	    LPWSTR name = (WCHAR *)(buf + pmd->dwMDDataOffset);
	    IISSchemaProperty *pProp = new IISSchemaProperty(
                                        pmd->dwMDIdentifier,
                                        name,
                                        pmd->dwMDDataLen);
	    idToProp.Add(pmd->dwMDIdentifier, pProp);
	    nameToProp.Add(pProp->getName(), pProp);
    }

    if (!bMayBeIIS4)
    {
    
        hr = LoadAllData(pAdminBase, root, L"Types", &buf, &bufSize, &count);

	    BAIL_ON_FAILURE(hr);

	    // Now, here we've gotten the list of properties/values.
	    // We then need to look up the properties by id (since that's
	    // what we have) and initialize the property type information.

	    for (i=0;i < count; i++) 
	    {
		    pmd = ((METADATA_GETALL_RECORD*)buf) + i;


		    IISSchemaProperty *pProp = (IISSchemaProperty *)(idToProp[pmd->dwMDIdentifier]);
		    if (pProp == NULL) 
		    {
			    continue;
		    }
		    pProp->InitFromMetaData(pmd, buf);
	    }
    } 
    
    else 
    { // IIS4 Code
	
	    // since the binary data stored in metabase changed, read from the resources
	    for (i=0;i < g_cIISProperties; i++) 
	    {
		    PROPERTYINFO * pPrpInfo = &g_aIISProperties[i];

		    IISSchemaProperty *pProp = (IISSchemaProperty *)(idToProp[pPrpInfo->dwPropID]);
		    if (pProp == NULL) {
			    continue;
		    }
		
		    memcpy(pProp->GetpropInfo(),pPrpInfo,sizeof(PROPERTYINFO));
	    }
    }

    if (!bMayBeIIS4)
    { // in IIS4 the defaults has been already loaded

	    hr = LoadAllData(pAdminBase, root, L"Defaults", &buf, &bufSize, &count);
	    BAIL_ON_FAILURE(hr);

	    // Now, here we've gotten the list of properties/defaults.
	    // We then need to look up the properties by id (since that's
	    // what we have) and initialize the property type information.

	    for (i=0;i < count; i++) 
	    {
		    pmd = ((METADATA_GETALL_RECORD*)buf) + i;


		    IISSchemaProperty *pProp = (IISSchemaProperty *)(idToProp[pmd->dwMDIdentifier]);
		    if (pProp == NULL) 
		    {
			    continue;
		    }
      
		    pProp->InitPropertyDefaults(pmd, buf);
	    }
    }

    root.close();
    // Next, we need to initialize the class map.
    WCHAR className[METADATA_MAX_NAME_LEN];

    hr = pAdminBase->OpenKey(METADATA_MASTER_ROOT_HANDLE,
						     L"/Schema/Classes",
						     METADATA_PERMISSION_READ,
						     DEFAULT_TIMEOUT_VALUE,
						     root);
    BAIL_ON_FAILURE(hr);

    for (i=0; TRUE ; i++) 
    {
        hr = pAdminBase->EnumKeys(root, L"", (LPWSTR)className, i);
        if (!SUCCEEDED(hr)) 
        {
            hr = ERROR_SUCCESS;
            break;
        }

	    IIsSchemaClass *psc = new IIsSchemaClass(className);

        if (bMayBeIIS4)
        {
            DWORD i; // the scope saves us and this variable name
            for (i=0;i<g_cIISClasses;i++)
            {
                if (!_wcsicmp(className, g_aIISClasses[i].bstrName)) 
                {
                    if (g_aIISClasses[i].bstrContainment)
                    {
                        pContainment = (LPWSTR)AllocADsMem((lstrlenW(g_aIISClasses[i].bstrContainment)+1)*sizeof(WCHAR));
                        lstrcpyW(pContainment,g_aIISClasses[i].bstrContainment);
                    } 
                    else 
                    {
                        pContainment=NULL; 
                    }
                    
                    if (g_aIISClasses[i].bstrOptionalProperties)
                    {
                        pOptProp = (LPWSTR)AllocADsMem((lstrlenW(g_aIISClasses[i].bstrOptionalProperties)+1)*sizeof(WCHAR));
                        lstrcpyW(pOptProp,g_aIISClasses[i].bstrOptionalProperties);
                    } 
                    else 
                    {
                        pOptProp = NULL;
                    }
                    
                    if (g_aIISClasses[i].bstrMandatoryProperties)
                    {
                        pMandProp = (LPWSTR)AllocADsMem((lstrlenW(g_aIISClasses[i].bstrMandatoryProperties)+1)*sizeof(WCHAR));
                        lstrcpyW(pMandProp,g_aIISClasses[i].bstrMandatoryProperties);
                    } 
                    else 
                    {
                        pMandProp = NULL;
                    }
                    dwData = g_aIISClasses[i].fContainer?TRUE:FALSE;
			        break;
                }
            }
    
        } 
        
        else 
        {

		    //
		    // Load the Containment, Mandatory, Optional, and Container properties.
	        //	

            hr = MetaBaseGetStringData(pAdminBase,
                                       root,
                                       className,
                                       MD_SCHEMA_CLASS_CONTAINMENT,
                                       (LPBYTE*)&pContainment
                                       );
     	    BAIL_ON_FAILURE(hr);

            hr = MetaBaseGetStringData(pAdminBase,
                                       root,
                                       className,
                                       MD_SCHEMA_CLASS_OPT_PROPERTIES,
                                       (LPBYTE*)&pOptProp
                                       );
     	    BAIL_ON_FAILURE(hr);

            hr = MetaBaseGetStringData(pAdminBase,
                                       root,
                                       className,
                                       MD_SCHEMA_CLASS_MAND_PROPERTIES,
                                       (LPBYTE*)&pMandProp
                                       );
     	    BAIL_ON_FAILURE(hr);

            hr = MetaBaseGetDwordData(pAdminBase,
                                      root,
                                      className,
                                      MD_SCHEMA_CLASS_CONTAINER,
                                      &dwData
                                      );
            BAIL_ON_FAILURE(hr);
       
        }

        classInfo.bstrContainment = pContainment;
        classInfo.bstrOptionalProperties = pOptProp;
        classInfo.bstrMandatoryProperties = pMandProp;
        classInfo.fContainer = dwData ? TRUE : FALSE;

        psc->SetclassInfo(&classInfo);
	    nameToClass.Add(psc->getName(), psc);

        if (pContainment) 
        {
            FreeADsMem(pContainment);
        }

        if (pOptProp) 
        {
            FreeADsMem(pOptProp);
        }

        if (pMandProp) 
        {
            FreeADsMem(pMandProp);
        }

    }
    
    localAuthInfo.FreeServerInfoStruct(pcsiParam);

error:

    if (pAdminBase) 
    {
        pAdminBase->Release();
    }
	if (buf)
    {
		delete [] buf;
    }
    if (pcsfFactory) 
    {
        pcsfFactory->Release();
    }

    RRETURN(hr);
}

HRESULT IIsSchema::GetTotalEntries(PDWORD pdwEntries) { 
    *pdwEntries = nameToClass.GetEntries() + nameToProp.GetEntries();
    RRETURN(S_OK); 
}			

DWORD IIsSchema::GetClassEntries() { 
    return nameToClass.GetEntries();
}			

DWORD IIsSchema::GetPropEntries() { 
    return nameToProp.GetEntries();
}			

LPWSTR IIsSchema::GetClassName(DWORD dwIndex) { 
    return nameToClass.GetEntryName(dwIndex);
}			

LPWSTR IIsSchema::GetPropName(DWORD dwIndex) { 
    return nameToProp.GetEntryName(dwIndex);
}			

HRESULT IIsSchema::RemoveEntry(BOOL bClass, LPWSTR pszName) { 

	DWORD i;
	DWORD id = 0;
	LPWSTR pszPropName;
	LPWSTR pszClassName;
	IISSchemaProperty *prop;
	if (bClass)
	{
		// clear nameToClass entry using pszName
		for ( i = 0; i < nameToClass.GetEntries(); i++ )
		{
			pszClassName = nameToClass.GetEntryName(i);
			if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
				nameToClass.ClearEntry(i);
			}
		}
	}
	else 
	{
		// clear nameToProp entry using pszName
		for ( i = 0; i < nameToProp.GetEntries(); i++ )
		{
			pszPropName = nameToProp.GetEntryName(i);
			if (pszPropName != NULL && _wcsicmp( pszPropName, pszName) == 0 ) {
				prop = (IISSchemaProperty *)nameToProp[pszPropName];
	
				if (!prop)
					RRETURN(E_ADS_PROPERTY_NOT_SUPPORTED);

				id = prop->getPropID();
				nameToProp.ClearEntry(i);
			}
		}
		// clear idToProp entry using id

		if (id != 0)
		{
			idToProp.ClearEntry(id);					
		}
	}

    RRETURN(S_OK); 
}			

PCLASSINFO IIsSchema::GetClassInfo(LPWSTR pszName) {

    DWORD i;
    LPWSTR pszClassName;
	IIsSchemaClass *sc;

    for ( i = 0; i < nameToClass.GetEntries(); i++ )
    {
         pszClassName = nameToClass.GetEntryName(i);
         if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
             sc = (IIsSchemaClass *)nameToClass[pszClassName];
             return sc != NULL ? sc->GetclassInfo() : NULL;
         }
    }

    return NULL;

}

PPROPERTYINFO IIsSchema::GetPropertyInfo(LPWSTR pszName) {

    DWORD i;
    LPWSTR pszPropName;
	IISSchemaProperty *prop;

    for ( i = 0; i < nameToProp.GetEntries(); i++ )
    {
         pszPropName = nameToProp.GetEntryName(i);
         if (pszPropName != NULL && _wcsicmp( pszPropName, pszName) == 0 ) {
             prop = (IISSchemaProperty *)nameToProp[pszPropName];
             return prop->GetpropInfo();
         }
    }

   return NULL;
}


HRESULT IIsSchema::SetClassInfo(LPWSTR pszName, PCLASSINFO pClassInfo) {
    DWORD i;
    LPWSTR pszClassName;
	IIsSchemaClass *sc;

    for ( i = 0; i < nameToClass.GetEntries(); i++ )
    {
         pszClassName = nameToClass.GetEntryName(i);
         if (pszClassName != NULL && _wcsicmp( pszClassName, pszName) == 0 ) {
             sc = (IIsSchemaClass *)nameToClass[pszClassName];
             return sc != NULL ? sc->SetclassInfo(pClassInfo) : E_FAIL;
         }
    }

    //
    //  add to schema cache if doesn't exist
    //

    sc = new IIsSchemaClass(pszName);
    sc->SetclassInfo(pClassInfo);
    nameToClass.Add(sc->getName(), sc);

	RRETURN(S_OK);
}

HRESULT IIsSchema::SetPropertyInfo(LPWSTR pszName, PPROPERTYINFO pPropInfo) {
    DWORD i;
    LPWSTR pszPropName;
	IISSchemaProperty *prop;

    for ( i = 0; i < nameToProp.GetEntries(); i++ )
    {
         pszPropName = nameToProp.GetEntryName(i);
         if ( _wcsicmp( pszPropName, pszName) == 0 ) {
             prop = (IISSchemaProperty *)nameToProp[pszPropName];
             return prop != NULL ? prop->SetpropInfo(pPropInfo) : E_FAIL;
         }
    }

    //
    //  add to schema cache if doesn't exist
    //

    prop = new IISSchemaProperty(pPropInfo->dwPropID,
                                 pszName, 
                                 (DWORD)wcslen(pszName)+1);
    if (prop != NULL)
       prop->SetpropInfo(pPropInfo);
    else 
       return E_FAIL;
    idToProp.Add(pPropInfo->dwPropID, prop);
    nameToProp.Add(prop->getName(), prop);

	RRETURN(S_OK);
}



IIsSchema::IIsSchema() {}			

void InitPropValue(PropValue *pv, PROPERTYINFO *pi) {
    pv->dwSynID = pi->dwSyntaxId;
    pv->dwMetaID = pi->dwMetaID;
    pv->dwPropID = pi->dwPropID;
    pv->dwMaxRange = (DWORD)pi->lMaxRange;
    pv->dwMinRange = (DWORD)pi->lMinRange;

    switch(pi->dwSyntaxId) {
    case IIS_SYNTAX_ID_DWORD:
    case IIS_SYNTAX_ID_BOOL:
    case IIS_SYNTAX_ID_BOOL_BITMASK:
        pv->dwMetaType = DWORD_METADATA;
        break;
    case IIS_SYNTAX_ID_STRING:
        pv->dwMetaType = STRING_METADATA;
        break;
    case IIS_SYNTAX_ID_EXPANDSZ:
        pv->dwMetaType = EXPANDSZ_METADATA;
        break;
    case IIS_SYNTAX_ID_MIMEMAP:
    case IIS_SYNTAX_ID_MULTISZ:
        pv->dwMetaType = MULTISZ_METADATA;
        break;
    case IIS_SYNTAX_ID_NTACL:
    case IIS_SYNTAX_ID_BINARY:
    case IIS_SYNTAX_ID_IPSECLIST:
        pv->dwMetaType = BINARY_METADATA;
        break;

    }
    pv->dwFlags = pi->dwFlags;
    pv->fMultiValued = pi->fMultiValued;
    pv->dwMask = pi->dwMask;
    pv->dwMetaFlags = pi->dwMetaFlags;
    pv->dwUserGroup = pi->dwUserGroup;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\sources.inc ===
!IF 0

Copyright (c) 1995-96  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:


NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

USE_MSVCRT=1
USE_MFCUNICODE=1
USE_STATIC_ATL=1
ATL_VER=30

DLLDEF=..\iis.def
TARGETTYPE=DYNLINK
DLLENTRY=_DllMainCRTStartup
TARGETPATH=obj

INCLUDES= ..;\
          ..\$(O);\
          $(O);\
          $(IISBASEDIR)\staxinc;\
          $(IISBASEDIR)\inc;\
          $(IISBASEDIR)\inc\$(O);\
          $(IISBASEDIR)\svcs\infocomm\common; \
	  $(IISBASEDIR)\svcs\nntp\core\include; \
	  $(IISBASEDIR)\staxinc\export; \
          ..\..\oleds2.0\include;

MSC_WARNING_LEVEL=/W4 /WX /wd4201 /wd4115 /wd4100

SOURCES=\
        ..\iis.rc \
        ..\cprovcf.cxx \
        ..\cprov.cxx \
        ..\cnamcf.cxx \
        ..\cnamesp.cxx \
        ..\cenumns.cxx \
        ..\ctree.cxx \
        ..\cenumt.cxx \
        ..\cgenobj.cxx \
        ..\cschobj.cxx \
        ..\cschema.cxx \
        ..\cenumsch.cxx \
        ..\cenumvar.cxx \
        ..\cenumobj.cxx \
        ..\cmimecf.cxx   \
        ..\cmime.cxx \
        ..\cipseccf.cxx  \
        ..\cipsec.cxx \
        ..\cpobjcf.cxx  \
        ..\cpobj.cxx \
        ..\cprops.cxx \
        ..\var2sec.cxx \
        ..\sec2var.cxx \
        ..\common.cxx \
        ..\core.cxx \
        ..\object.cxx \
        ..\getobj.cxx \
        ..\parse.cxx \
        ..\libmain.cxx \
        ..\cdispmgr.cxx \
        ..\cextmgr.cxx \
        ..\extension.cxx \
        ..\iismrshl.cxx \
        ..\iisurshl.cxx \
        ..\iiscopy.cxx \
        ..\iisfree.cxx \
        ..\iis2var.cxx \
        ..\var2iis.cxx \
        ..\schemini.cxx \
        ..\charset.cxx \
        ..\sdict.cxx \
        ..\svrcache.cxx \
        ..\guid.c

UMTYPE=console

TARGETLIBS = \
             $(SDK_LIB_PATH)\uuid.lib  \
             $(SDK_LIB_PATH)\imagehlp.lib \
             $(SDK_LIB_PATH)\ole32.lib    \
             $(SDK_LIB_PATH)\advapi32.lib \
             $(SDK_LIB_PATH)\comdlg32.lib \
             $(SDK_LIB_PATH)\kernel32.lib \
             $(SDK_LIB_PATH)\shell32.lib  \
             $(SDK_LIB_PATH)\user32.lib   \
             $(SDK_LIB_PATH)\gdi32.lib    \
             $(SDK_LIB_PATH)\oleaut32.lib \
             $(SDK_LIB_PATH)\ws2_32.lib   \
             $(SDK_LIB_PATH)\activeds.lib \
             $(SDK_LIB_PATH)\adsiid.lib   \
             $(IISBASEDIR)\svcs\iisrtl\$(O)\iisrtl.lib   \
             $(SDK_LIB_PATH)\crypt32.lib  \
             $(IISBASEDIR)\admin\common\$(O)\iisui.lib \
             $(IISBASEDIR)\svcs\infocomm\rdns\$(O)\isrdns.lib  \
             $(IISBASEDIR)\admin\adsi\helper\noole\winnt\$(O)\noole.lib      \
             $(IISBASEDIR)\admin\adsi\helper\nocairo\winnt\$(O)\nocairo.lib    \
             $(IISBASEDIR)\admin\adsi\helper\utils\winnt\$(O)\noutils.lib    

C_DEFINES=$(C_DEFINES) -DDAYTONA -DCAL_ENABLED

PRECOMPILED_INCLUDE=..\iis.hxx
PRECOMPILED_OBJ=iis.obj
PRECOMPILED_PCH=iis.pch
PRECOMPILED_CXX=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\sdict.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  sdict.cxx
//
//  Contents:  simple dictionary 
//
//  History:   28-Feb-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iis.hxx>

SIMPLE_DICT::SIMPLE_DICT()
{
    cDictSize = 0;
    iNextItem = 0;
    cDictSlots = INITIALDICTSLOTS;

    DictSlots = InitialDictSlots;
    memset(DictSlots, 0, sizeof(void *) * cDictSlots);
}

SIMPLE_DICT::~SIMPLE_DICT()
{
    if (DictSlots != InitialDictSlots)
        delete DictSlots;
}

int
SIMPLE_DICT::Insert (
    void *Item
    )
{
    int iDictSlots;
    void * * NewDictSlots;

    for (iDictSlots = 0; iDictSlots < cDictSlots; iDictSlots++)

        if (DictSlots[iDictSlots] == NULL)
            {
            DictSlots[iDictSlots] = Item;
            cDictSize += 1;
            return(iDictSlots);
            }

    // If we fell through to here, it must mean that the dictionary is
    // full; hence we need to allocate more space and copy the old
    // dictionary into it.

    NewDictSlots = (void * *) new char[sizeof(void *)*cDictSlots*2];
    if (!NewDictSlots)
        return(-1);

    memcpy(NewDictSlots, DictSlots, sizeof(void *) * cDictSlots);
    memset(NewDictSlots+iDictSlots, 0,  sizeof(void *) * cDictSlots);

    if (DictSlots != InitialDictSlots)
        delete DictSlots;
    DictSlots = NewDictSlots;

    cDictSlots *= 2;

    DictSlots[iDictSlots] = Item;
    cDictSize += 1;
    return(iDictSlots);
}

void *
SIMPLE_DICT::Find (
    int Key
    )
{
    if (Key >= cDictSlots)
        return(NULL);

    return(DictSlots[Key]);
}

void *
SIMPLE_DICT::DeleteItemByBruteForce(
    void * Item
    )
{

    if (Item == 0)
       {
       return (0);
       }

    for (int i = 0; i < cDictSlots; i++)
        {
        if (DictSlots[i] == Item)
           {
           DictSlots[i] = NULL;
           cDictSize -= 1;
           return (Item);
           }
        }

    return (0);
}

void *
SIMPLE_DICT::Delete (
    int Key
    )
{
    void *Item;

    if (Key >= cDictSlots)
        {
        return(NULL);
        }

    Item = DictSlots[Key];
    ASSERT((DictSlots[Key]));

    cDictSize -= 1;
    DictSlots[Key] = NULL;

    return(Item);
}

void *
SIMPLE_DICT::Next (
    )
{
    for ( ; iNextItem < cDictSlots; iNextItem++)
        {
        if (DictSlots[iNextItem])
            return(DictSlots[iNextItem++]);
        }

    iNextItem = NULL;
    return(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\sec2var.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       sec2var.cxx
//
//  Contents:   
//
//  Functions:  
//
//  History:    25-Apr-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    );


HRESULT
ConvertSecDescriptorToVariant(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    VARIANT * pVarSec
    )
{
    IADsSecurityDescriptor * pSecDes = NULL;
    IDispatch * pDispatch = NULL;
    LPWSTR pszGroup = NULL;
    LPWSTR pszOwner = NULL;

    BOOL fOwnerDefaulted = 0;
    BOOL fGroupDefaulted = 0;
    BOOL fDaclDefaulted = 0;
    BOOL fSaclDefaulted = 0;

    BOOL fSaclPresent = 0;
    BOOL fDaclPresent = 0;

    LPBYTE pOwnerSidAddress = NULL;
    LPBYTE pGroupSidAddress = NULL;
    LPBYTE pDACLAddress = NULL;
    LPBYTE pSACLAddress = NULL;

    DWORD dwRet = 0;

    VARIANT varDACL;
    VARIANT varSACL;

    HRESULT hr = S_OK;

    DWORD dwRevision = 0;
    WORD  wControl = 0;

    VariantInit(pVarSec);
    memset(&varSACL, 0, sizeof(VARIANT));
    memset(&varDACL, 0, sizeof(VARIANT));

    if (!pSecurityDescriptor) {
        RRETURN(E_FAIL);
    }


    dwRet = GetSecurityDescriptorControl(
                        pSecurityDescriptor,
                        &wControl,
                        &dwRevision
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorOwner(
                        pSecurityDescriptor,
                        (PSID *)&pOwnerSidAddress,
                        &fOwnerDefaulted
                        );
    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pOwnerSidAddress,
                &pszOwner
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorGroup(
                        pSecurityDescriptor,
                        (PSID *)&pGroupSidAddress,
                        &fGroupDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = ConvertSidToFriendlyName(
                pGroupSidAddress,
                &pszGroup
                );
    BAIL_ON_FAILURE(hr);


    dwRet = GetSecurityDescriptorDacl(
                        pSecurityDescriptor,
                        &fDaclPresent,
                        (PACL*)&pDACLAddress,
                        &fDaclDefaulted
                        );

    if (pDACLAddress) {
        hr = ConvertACLToVariant(
                (PACL)pDACLAddress,
                &varDACL
                );
        BAIL_ON_FAILURE(hr);
    }

    dwRet = GetSecurityDescriptorSacl(
                        pSecurityDescriptor,
                        &fSaclPresent,
                        (PACL *)&pSACLAddress,
                        &fSaclDefaulted
                        );

    if (!dwRet){
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (pSACLAddress) {
        hr = ConvertACLToVariant(
                (PACL)pSACLAddress,
                &varSACL
                );
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_SecurityDescriptor,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsSecurityDescriptor,
                (void **)&pSecDes
                );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->put_Owner(pszOwner);

    hr = pSecDes->put_Group(pszGroup);

    hr = pSecDes->put_Revision(dwRevision);

    hr = pSecDes->put_Control((DWORD)wControl);

    hr = pSecDes->put_DiscretionaryAcl(V_DISPATCH(&varDACL));

    hr = pSecDes->put_SystemAcl(V_DISPATCH(&varSACL));

    hr = pSecDes->QueryInterface(IID_IDispatch, (void**)&pDispatch);
    BAIL_ON_FAILURE(hr);


    V_VT(pVarSec) = VT_DISPATCH;
    V_DISPATCH(pVarSec) =  pDispatch;

error:

    VariantClear(&varSACL);
    VariantClear(&varDACL);

    if (pszOwner) {
        FreeADsStr(pszOwner);
    }

    if (pszGroup) {
        FreeADsStr(pszGroup);
    }

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}


HRESULT
ConvertSidToFriendlyName(
    PSID pSid,
    LPWSTR * ppszAccountName
    )
{
    HRESULT hr = S_OK;
    SID_NAME_USE eUse;
    WCHAR szAccountName[MAX_PATH];
    WCHAR szDomainName[MAX_PATH];
    DWORD dwLen = 0;
    DWORD dwRet = 0;

    LPWSTR pszAccountName = NULL;

    DWORD dwAcctLen = 0;
    DWORD dwDomainLen = 0;

    dwAcctLen = sizeof(szAccountName);
    dwDomainLen = sizeof(szDomainName);

    dwRet = LookupAccountSid(
                NULL,
                pSid,
                szAccountName,
                &dwAcctLen,
                szDomainName,
                &dwDomainLen,
                (PSID_NAME_USE)&eUse
                );
    if (!dwRet) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }else {

        dwLen = (DWORD)(wcslen(szAccountName) + wcslen(szDomainName)) + 1 + 1;

        pszAccountName = (LPWSTR)AllocADsMem(dwLen * sizeof(WCHAR));
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        if (szDomainName[0] && szAccountName[0]) {
            wsprintf(pszAccountName,L"%s\\%s",szDomainName, szAccountName);
        }else if (szAccountName[0]) {

            if (wcslen(szAccountName)>=MAX_PATH)
            {
                hr = E_ADS_BAD_PARAMETER;
                BAIL_ON_FAILURE(hr);
            }
            wcscpy(pszAccountName, szAccountName);
        }
    }

    if (FAILED(hr)) {

        hr = ConvertSidToString(
                    pSid,
                    szAccountName
                    );
        BAIL_ON_FAILURE(hr);

        pszAccountName = AllocADsStr(szAccountName);
        if (!pszAccountName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    *ppszAccountName = pszAccountName;

error:

    RRETURN(hr);
}


HRESULT
ConvertACLToVariant(
    PACL pACL,
    PVARIANT pvarACL
    )
{
    IADsAccessControlList * pAccessControlList = NULL;
    IDispatch * pDispatch = NULL;

    VARIANT varAce;
    DWORD dwAclSize = 0;
    DWORD dwAclRevision = 0;
    DWORD dwAceCount = 0;

    ACL_SIZE_INFORMATION AclSize;
    ACL_REVISION_INFORMATION AclRevision;
    DWORD dwStatus = 0;

    DWORD i = 0;
    DWORD dwNewAceCount = 0;

    HRESULT hr = S_OK;
    LPBYTE pAceAddress = NULL;


    memset(&AclSize, 0, sizeof(ACL_SIZE_INFORMATION));
    memset(&AclRevision, 0, sizeof(ACL_REVISION_INFORMATION));


    dwStatus = GetAclInformation(
                        pACL,
                        &AclSize,
                        sizeof(ACL_SIZE_INFORMATION),
                        AclSizeInformation
                        );


    dwStatus = GetAclInformation(
                        pACL,
                        &AclRevision,
                        sizeof(ACL_REVISION_INFORMATION),
                        AclRevisionInformation
                        );

    dwAceCount = AclSize.AceCount;
    dwAclRevision = AclRevision.AclRevision;

    VariantInit(pvarACL);

    hr = CoCreateInstance(
                CLSID_AccessControlList,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlList,
                (void **)&pAccessControlList
                );
    BAIL_ON_FAILURE(hr);

    for (i = 0; i < dwAceCount; i++) {

        dwStatus = GetAce(pACL, i, (void **)&pAceAddress);

        hr = ConvertAceToVariant(
                    pAceAddress,
                    (PVARIANT)&varAce
                    );

        hr = pAccessControlList->AddAce(V_DISPATCH(&varAce));
        if (SUCCEEDED(hr)) {
           dwNewAceCount++;
        }

        VariantClear(&varAce);
    }

    pAccessControlList->put_AclRevision(dwAclRevision);

    pAccessControlList->put_AceCount(dwNewAceCount);


    hr = pAccessControlList->QueryInterface(
                        IID_IDispatch,
                        (void **)&pDispatch
                        );
    V_VT(pvarACL) = VT_DISPATCH;
    V_DISPATCH(pvarACL) = pDispatch;

error:

    if (pAccessControlList) {

        pAccessControlList->Release();
    }

    RRETURN(hr);
}


/* INTRINSA suppress=null_pointers, uninitialized */
HRESULT
ConvertAceToVariant(
    PBYTE pAce,
    PVARIANT pvarAce
    )
{
    IADsAccessControlEntry * pAccessControlEntry = NULL;
    IDispatch * pDispatch = NULL;

    DWORD dwAceType = 0;
    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    LPWSTR pszAccountName = NULL;
    PACE_HEADER pAceHeader = NULL;
    LPBYTE pSidAddress = NULL;
    LPBYTE pOffset = NULL;
    DWORD dwFlags = 0;

    GUID ObjectGUID;
    GUID InheritedObjectGUID;
    WCHAR szObjectGUID[MAX_PATH];
    WCHAR szInheritedObjectGUID[MAX_PATH];

    HRESULT hr = S_OK;

    szObjectGUID[0] = L'\0';
    szInheritedObjectGUID[0] = L'\0';


    VariantInit(pvarAce);

    hr = CoCreateInstance(
                CLSID_AccessControlEntry,
                NULL,
                CLSCTX_INPROC_SERVER,
                IID_IADsAccessControlEntry,
                (void **)&pAccessControlEntry
                );
    BAIL_ON_FAILURE(hr);

    pAceHeader = (ACE_HEADER *)pAce;


    dwAceType = pAceHeader->AceType;
    dwAceFlags = pAceHeader->AceFlags;
    dwAccessMask = *(PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
    case ACCESS_DENIED_ACE_TYPE:
    case SYSTEM_AUDIT_ACE_TYPE:
    case SYSTEM_ALARM_ACE_TYPE:
        pSidAddress =  (LPBYTE)pAceHeader + sizeof(ACE_HEADER) + sizeof(ACCESS_MASK);
        break;

    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:
    case ACCESS_DENIED_OBJECT_ACE_TYPE:
    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:
    case SYSTEM_ALARM_OBJECT_ACE_TYPE:
        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));
        dwFlags = (DWORD)(*(PDWORD)pOffset);

        //
        // Now advance by the size of the flags
        //
        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(&ObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(ObjectGUID, szObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            memcpy(&InheritedObjectGUID, pOffset, sizeof(GUID));

            StringFromGUID2(InheritedObjectGUID, szInheritedObjectGUID, MAX_PATH);

            pOffset += sizeof (GUID);

        }

        pSidAddress = pOffset;
        break;

    default:
        break;

    }


    hr = ConvertSidToFriendlyName(
                pSidAddress,
                &pszAccountName
                );

    if (FAILED(hr)){
        pszAccountName = AllocADsStr(L"Unknown Trustee");
    }

    //
    // Now set all the information in the Access Control Entry
    //

    hr = pAccessControlEntry->put_AccessMask(dwAccessMask);
    hr = pAccessControlEntry->put_AceFlags(dwAceFlags);
    hr = pAccessControlEntry->put_AceType(dwAceType);

    //
    // Extended ACE information
    //
    hr = pAccessControlEntry->put_Flags(dwFlags);

    if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Object Type GUID
        //
        hr = pAccessControlEntry->put_ObjectType(szObjectGUID);

    }

    if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

        //
        // Add in the Inherited Object Type GUID
        //

        hr = pAccessControlEntry->put_InheritedObjectType(szInheritedObjectGUID);

    }

    hr = pAccessControlEntry->put_Trustee(pszAccountName);

    hr = pAccessControlEntry->QueryInterface(
                IID_IDispatch,
                (void **)&pDispatch
                );
    BAIL_ON_FAILURE(hr);

    V_DISPATCH(pvarAce) =  pDispatch;
    V_VT(pvarAce) = VT_DISPATCH;

cleanup:

    if (pszAccountName) {

        FreeADsStr(pszAccountName);
    }

    if (pAccessControlEntry) {

        pAccessControlEntry->Release();
    }

    RRETURN(hr);


error:

    if (pDispatch) {

        pDispatch->Release();

    }

    goto cleanup;
}


HRESULT
ConvertSidToString(
    PSID pSid,
    LPWSTR   String
    )

/*++

Routine Description:


    This function generates a printable unicode string representation
    of a SID.

    The resulting string will take one of two forms.  If the
    IdentifierAuthority value is not greater than 2^32, then
    the SID will be in the form:


        S-1-281736-12-72-9-110
              ^    ^^ ^^ ^ ^^^
              |     |  | |  |
              +-----+--+-+--+---- Decimal



    Otherwise it will take the form:


        S-1-0x173495281736-12-72-9-110
            ^^^^^^^^^^^^^^ ^^ ^^ ^ ^^^
             Hexidecimal    |  | |  |
                            +--+-+--+---- Decimal


Arguments:

    pSid - opaque pointer that supplies the SID that is to be
    converted to Unicode.

Return Value:

    If the Sid is successfully converted to a Unicode string, a
    pointer to the Unicode string is returned, else NULL is
    returned.

--*/

{
    WCHAR Buffer[256];
    UCHAR   i;
    ULONG   Tmp;
    HRESULT hr = S_OK;

    SID_IDENTIFIER_AUTHORITY    *pSidIdentifierAuthority;
    PUCHAR                      pSidSubAuthorityCount;


    if (!IsValidSid( pSid )) {
        *String= L'\0';
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_SID);
        RRETURN(hr);
    }

    wsprintf(Buffer, L"S-%u-", (USHORT)(((PISID)pSid)->Revision ));
    wcscpy(String, Buffer);

    pSidIdentifierAuthority = GetSidIdentifierAuthority(pSid);

    if (  (pSidIdentifierAuthority->Value[0] != 0)  ||
          (pSidIdentifierAuthority->Value[1] != 0)     ){
        wsprintf(Buffer, L"0x%02hx%02hx%02hx%02hx%02hx%02hx",
                    (USHORT)pSidIdentifierAuthority->Value[0],
                    (USHORT)pSidIdentifierAuthority->Value[1],
                    (USHORT)pSidIdentifierAuthority->Value[2],
                    (USHORT)pSidIdentifierAuthority->Value[3],
                    (USHORT)pSidIdentifierAuthority->Value[4],
                    (USHORT)pSidIdentifierAuthority->Value[5] );
        wcscat(String, Buffer);

    } else {

        Tmp = (ULONG)pSidIdentifierAuthority->Value[5]          +
              (ULONG)(pSidIdentifierAuthority->Value[4] <<  8)  +
              (ULONG)(pSidIdentifierAuthority->Value[3] << 16)  +
              (ULONG)(pSidIdentifierAuthority->Value[2] << 24);
        wsprintf(Buffer, L"%lu", Tmp);
        wcscat(String, Buffer);
    }

    pSidSubAuthorityCount = GetSidSubAuthorityCount(pSid);

    for (i=0;i< *(pSidSubAuthorityCount);i++ ) {
        wsprintf(Buffer, L"-%lu", *(GetSidSubAuthority(pSid, i)));
        wcscat(String, Buffer);
    }

    RRETURN(S_OK);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\caiheap.h ===
//+---------------------------------------------------------------------------
//  File:       caiheap.h
//
//  Contents:   Heap debugging structures and routines for the heap code
//              in commnot
//
//  History:    28-Oct-92   IsaacHe     Created
//
//----------------------------------------------------------------------------

#ifndef _CAIHEAP_H_
#define _CAIHEAP_H_

//
// We keep a stack backtrace for each allocated block of memory.  DEPTHTRACE
// is the number of frames that we record
//
#define DEPTHTRACE   26                 // depth of stack backtraces

//
// The AllocArena structure has this signature at its front.  We put a
// signature on the structure to allow external processes to snapshot the
// debug information and do some minimal check to see they are looking at the
// right stuff
//
const char HEAPSIG[] = { 'H', 'E', 'P', DEPTHTRACE };

// We keep track of the stack backtraces of allocation calls
// in these structues.

struct HeapAllocRec {
        DWORD   sum;            // checksum of stack backtrace
        void *fTrace[ DEPTHTRACE ];     // stack backtrace
        DWORD   count;          // # of un-freed allocs from this place
        size_t  bytes;          // # of un-freed bytes from this place
        struct AllocArena *paa; // points back to the beginning...
        struct {
                DWORD   count;  // # of allocs from this place
                size_t  bytes;  // # of bytes from this place
        } total;
        union {
                struct HeapAllocRec *next; // next bucket in the hash list
                void *ImageBase;        // base addr of containing module
        } u;
};

struct AllocArena {

        char Signature [ sizeof(HEAPSIG) ];
        char comment[ 32 ];
        CRITICAL_SECTION csExclusive;   // ensures single writer

        struct {
                int KeepStackTrace:1;   // are stack records being kept?
        } flags;

        ULONG cAllocs;                  // # of non zero Alloc calls
        ULONG czAllocs;                 // # of Alloc calls w/zero count
        ULONG cFrees;                   // # of Free calls
        ULONG cReAllocs;                // # of realloc calls
        ULONG cMissed;                  // # of missed stack backtraces
        ULONG cRecords;                 // index of next free AllocRec entry
        ULONG cBytesNow;                // # of bytes currently allocated
        ULONG cBytesTotal;              // # of bytes ever allocated
        ULONG cTotalRecords;            // Total # of AllocRecs
        ULONG cPaths;                   // # of distinct allocation paths

        struct {
                ULONG total[ 32 ];      // total number of allocations
                ULONG now[ 32 ];        // current # of simul allocs
                ULONG simul[ 32 ];      // highest # of simul allocs
        } Histogram;

        struct HeapAllocRec AllocRec[1]; // vector of records starts here..
};

/*
 * Allocators may want to associate one of these structures with every
 * allocation...
 */
struct AHeader {
        struct HeapAllocRec FAR *p;
        size_t size;
};

STDAPI_(struct AllocArena ** )
AllocArenaAddr( void );

STDAPI_( struct AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment );

STDAPI_( struct HeapAllocRec FAR * )
AllocArenaRecordAlloc( struct AllocArena *paa, size_t bytes );

STDAPI_(void)
AllocArenaRecordReAlloc( struct HeapAllocRec FAR *vp,
                        size_t oldbytes, size_t newbytes );

STDAPI_(void)
AllocArenaRecordFree( struct HeapAllocRec FAR *vp, size_t bytes );

STDAPI_(void)
AllocArenaDump( struct AllocArena *paa );

STDAPI_( void )
AllocArenaDumpRecord( struct HeapAllocRec FAR *bp );

#endif  // ifndef _CAIHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\sources.inc ===
!INCLUDE ..\common\sources
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\oleds.inc ===
OLEDSLIB_W95=$(PROJECT_ROOT)\adsi\public\lib\win95

!IF "$(ADSI_NT40_BUILD)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_FOR_NT40 -DUSE_DS_VER
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\svrcache.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997
//
//  File:  svrcache.cxx
//
//  Contents:  Caching code for com interface pointer and schema pointer
//
//  History:   28-Apr-97     SophiaC    Created.
//
//----------------------------------------------------------------------------
#include <iis.hxx>

BOOL SERVER_CACHE::Insert(SERVER_CACHE_ITEM * item)
// returns TRUE if succeed
{
    ASSERT(NULL != item);
    CLock lock;
#ifdef DBG
    SERVER_CACHE_ITEM * item2;
    Cache.Reset();
    while (NULL != (item2 = Cache.Next()))
        {
        if ((0 == _wcsicmp(item->ServerName, item2->ServerName)) &&
            (item->dwThreadId == item2->dwThreadId))
            {
            ASSERT(!"item already exists");
            }
        }
#endif
    item->key = Cache.Insert(item);
    return item->key != -1;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Delete(LPWSTR ServerName, DWORD dwThreadId)
// returns item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            Cache.Delete(item->key);
            if (item->ServerName) {
                delete item->ServerName;
            }
            return item; 
            }
        }
    return NULL;
}

SERVER_CACHE_ITEM * SERVER_CACHE::Find(LPWSTR ServerName, DWORD dwThreadId)
// returns pointer to the item found
{
    SERVER_CACHE_ITEM * item;
    CLock lock;
    Cache.Reset();
    while (NULL != (item = Cache.Next()))
        {
        if ((0 == _wcsicmp(ServerName, item->ServerName)) &&
            (dwThreadId == item->dwThreadId))
            {
            return item;
            }
        }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\var2iis.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1997.
//
//  File:       var2IIS.cxx
//
//  Contents:   IIS Object to Variant Copy Routines
//
//  Functions:
//
//  History:    01-Mar-97   SophiaC   Created.
//
//  Issues:     Check null ptrs for AllocADsMem and AllocADsStr
//
//----------------------------------------------------------------------------
#include "iis.hxx"

//
// IISType objects copy code
//


HRESULT
VarTypeToIISTypeCopyIISSynIdDWORD(
								  PVARIANT lpVarSrcObject,
								  PIISOBJECT lpIISDestObject
								 )
{
    HRESULT hr = S_OK;


    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_UI4);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_DWORD;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                            lpVarSrcObject->lVal;

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdSTRING(
								   PVARIANT lpVarSrcObject,
								   PIISOBJECT lpIISDestObject
								  )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_STRING;

    lpIISDestObject->IISValue.value_2.String =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdEXPANDSZ(
									 PVARIANT lpVarSrcObject,
									 PIISOBJECT lpIISDestObject
									)

{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_EXPANDSZ;

    lpIISDestObject->IISValue.value_3.ExpandSz =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);

}

HRESULT
VarTypeToIISTypeCopyIISSynIdMULTISZ(
									PVARIANT lpVarSrcObject,
									PIISOBJECT lpIISDestObject
								   )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BSTR);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_MULTISZ;

    lpIISDestObject->IISValue.value_4.MultiSz =
                        AllocADsStr(
                            lpVarSrcObject->bstrVal
                        );

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdMIMEMAP(
									PVARIANT lpVarSrcObject,
									PIISOBJECT lpIISDestObject
								   )
{
    HRESULT hr = S_OK;
    LPWSTR pszStr;
    IISMimeType * pMimeType = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_MIMEMAP;
    pMimeType = (IISMimeType *)lpVarSrcObject->pdispVal;

    hr = ((CMimeType*) pMimeType)->CopyMimeType(
                        &pszStr
                        );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_6.MimeMap = pszStr;

error:

    RRETURN(hr);
}




HRESULT
VarTypeToIISTypeCopyIISSynIdBinary(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;

    if (bReturnBinaryAsVT_VARIANT)
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_VARIANT);
    }
    else
    {
        hr = VariantChangeType(lpVarSrcObject,lpVarSrcObject,0,VT_ARRAY | VT_UI1);
    }

    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (bReturnBinaryAsVT_VARIANT)
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_VARIANT)) {
            RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }
    else
    {
        if( lpVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
            RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
        }
    }

    hr = SafeArrayGetLBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(lpVarSrcObject),1,(long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE) AllocADsMem(dwSUBound - dwSLBound + 1);
    if (lpIISDestObject->IISValue.value_5.Binary == NULL)
    {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BINARY;
    lpIISDestObject->IISValue.value_5.Length = dwSUBound - dwSLBound + 1;

    hr = SafeArrayAccessData( V_ARRAY(lpVarSrcObject),(void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);
    memcpy( lpIISDestObject->IISValue.value_5.Binary,pArray,dwSUBound-dwSLBound+1);
    SafeArrayUnaccessData( V_ARRAY(lpVarSrcObject) );

error:
    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdNTACL(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    IADsSecurityDescriptor FAR * pSecDes = NULL;
    PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
    DWORD Length = 0;
    IDispatch FAR * pDispatch = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BINARY;
    pDispatch = V_DISPATCH(lpVarSrcObject);

    hr = pDispatch->QueryInterface(
                    IID_IADsSecurityDescriptor,
                    (void **)&pSecDes
                    );
    BAIL_ON_FAILURE(hr);

    hr = ConvertSecurityDescriptorToSecDes(
                pSecDes,
                &pSecurityDescriptor,
                &Length
                );
    BAIL_ON_FAILURE(hr);

    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE)AllocADsMem(Length);
    if ((lpIISDestObject->IISValue.value_5.Binary) == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    lpIISDestObject->IISValue.value_5.Length = Length;
    memcpy(lpIISDestObject->IISValue.value_5.Binary, pSecurityDescriptor,
           Length);

error:

    if (pSecDes) {
        pSecDes->Release();
    }

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdIPSECLIST(
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject
    )
{
    HRESULT hr = S_OK;
    LPBYTE pBuffer;  
    DWORD Length = 0;
    IISIPSecurity * pIPSec = NULL;

    if(lpVarSrcObject->vt != VT_DISPATCH){
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_IPSECLIST;
    pIPSec = (IISIPSecurity*)lpVarSrcObject->pdispVal;

    hr = ((CIPSecurity*) pIPSec)->CopyIPSecurity(
                        &pBuffer, 
                        &Length
                        );

	if (pBuffer == NULL) {
		RRETURN(E_OUTOFMEMORY);
	}

    lpIISDestObject->IISValue.value_5.Length = Length;
    lpIISDestObject->IISValue.value_5.Binary = (LPBYTE)AllocADsMem(Length);
    memcpy(lpIISDestObject->IISValue.value_5.Binary, pBuffer, Length);

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopyIISSynIdBOOL(
								 PVARIANT lpVarSrcObject,
								 PIISOBJECT lpIISDestObject
								)
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BOOL);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BOOL;

    lpIISDestObject->IISValue.value_1.dwDWORD =
                            (lpVarSrcObject->boolVal) ? 1 : 0;

    RRETURN(hr);
}

HRESULT
VarTypeToIISTypeCopyIISSynIdBOOLBITMASK(
										PVARIANT lpVarSrcObject,
										PIISOBJECT lpIISDestObject
									   )
{
    HRESULT hr = S_OK;

    hr = VariantChangeType(lpVarSrcObject,
                           lpVarSrcObject,
                           0,
                           VT_BOOL);
    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            RRETURN(hr);
        }
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    lpIISDestObject->IISType = IIS_SYNTAX_ID_BOOL_BITMASK;

    lpIISDestObject->IISValue.value_1.dwDWORD =
        (lpVarSrcObject->boolVal) ? 1 : 0;

    RRETURN(hr);
}


HRESULT
VarTypeToIISTypeCopy(
    DWORD dwIISType,
    PVARIANT lpVarSrcObject,
    PIISOBJECT lpIISDestObject,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{
    HRESULT hr = S_OK;
    switch (dwIISType){
    case IIS_SYNTAX_ID_DWORD:
        hr = VarTypeToIISTypeCopyIISSynIdDWORD(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_STRING:
        hr = VarTypeToIISTypeCopyIISSynIdSTRING(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;


    case IIS_SYNTAX_ID_EXPANDSZ:
        hr = VarTypeToIISTypeCopyIISSynIdEXPANDSZ(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MULTISZ:
        hr = VarTypeToIISTypeCopyIISSynIdMULTISZ(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_MIMEMAP:
        hr = VarTypeToIISTypeCopyIISSynIdMIMEMAP(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_NTACL:
        hr = VarTypeToIISTypeCopyIISSynIdNTACL(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BINARY:
        hr = VarTypeToIISTypeCopyIISSynIdBinary(
                lpVarSrcObject,
                lpIISDestObject,
                bReturnBinaryAsVT_VARIANT
                );
        break;

    case IIS_SYNTAX_ID_IPSECLIST:
        hr = VarTypeToIISTypeCopyIISSynIdIPSECLIST(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL:
        hr = VarTypeToIISTypeCopyIISSynIdBOOL(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    case IIS_SYNTAX_ID_BOOL_BITMASK:
        hr = VarTypeToIISTypeCopyIISSynIdBOOLBITMASK(
                lpVarSrcObject,
                lpIISDestObject
                );
        break;

    default:
        hr = E_FAIL;
        break;
    }

    RRETURN(hr);
}



HRESULT
VarTypeToIISTypeCopyConstruct(
    DWORD dwIISType,
    LPVARIANT pVarSrcObjects,
    DWORD dwNumObjects,
    LPIISOBJECT * ppIISDestObjects,
    BOOL bReturnBinaryAsVT_VARIANT
    )
{

    DWORD i = 0;
    LPIISOBJECT pIISDestObjects = NULL;
    HRESULT hr = S_OK;

    pIISDestObjects = (LPIISOBJECT)AllocADsMem(
                                    dwNumObjects * sizeof(IISOBJECT)
                                    );

    if (!pIISDestObjects) {
        RRETURN(E_FAIL);
    }

     for (i = 0; i < dwNumObjects; i++ ) {
         hr = VarTypeToIISTypeCopy(
                    dwIISType,
                    pVarSrcObjects + i,
                    pIISDestObjects + i,
                    bReturnBinaryAsVT_VARIANT
                    );
         BAIL_ON_FAILURE(hr);

     }

     *ppIISDestObjects = pIISDestObjects;

     RRETURN(S_OK);

error:

     if (pIISDestObjects) {

        IISTypeFreeIISObjects(
                pIISDestObjects,
                dwNumObjects
                );
     }

     *ppIISDestObjects = NULL;

     RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\adsiis\var2sec.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       var2sec.cxx
//
//  Contents:
//
//  Functions:
//
//  History:    25-Apr-97   KrishnaG   Created.
//
//----------------------------------------------------------------------------
#include "iis.hxx"
#pragma hdrstop



HRESULT
ConvertSecurityDescriptorToSecDes(
    IADsSecurityDescriptor FAR * pSecDes,
    PSECURITY_DESCRIPTOR * ppSecurityDescriptor,
    PDWORD pdwSDLength
    )
{
    HRESULT hr = S_OK;

    SECURITY_DESCRIPTOR AbsoluteSD;
    PSECURITY_DESCRIPTOR pRelative = NULL;
    BOOL Defaulted = FALSE;
    BOOL DaclPresent = FALSE;
    BOOL SaclPresent = FALSE;

    BOOL fDaclDefaulted = FALSE;
    BOOL fSaclDefaulted = FALSE;
    BOOL fOwnerDefaulted = FALSE;
    BOOL fGroupDefaulted = FALSE;

    PSID pOwnerSid = NULL;
    PSID pGroupSid = NULL;
    PACL pDacl = NULL;
    PACL pSacl = NULL;
    DWORD   dwSDLength = 0;
    DWORD dwRet = 0;
    BOOL dwStatus = 0;
    LONG     lControlFlags = 0;
    SECURITY_DESCRIPTOR_CONTROL dwControlFlags = 0;
    SECURITY_DESCRIPTOR_CONTROL dwControlMask = 
                SE_DACL_AUTO_INHERIT_REQ | SE_DACL_AUTO_INHERITED |
                SE_DACL_PROTECTED | SE_SACL_AUTO_INHERIT_REQ |
                SE_SACL_AUTO_INHERITED | SE_SACL_PROTECTED;

    //
    // Initialize *pSizeSD = 0;
    //

    dwRet = InitializeSecurityDescriptor (
                &AbsoluteSD,
                SECURITY_DESCRIPTOR_REVISION1
                );
    if (!dwRet) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = pSecDes->get_Control(&lControlFlags);
    BAIL_ON_FAILURE(hr);
    
    dwControlFlags = dwControlMask & (SECURITY_DESCRIPTOR_CONTROL)lControlFlags;
        
    dwStatus = SetSecurityDescriptorControl(
                &AbsoluteSD,
                dwControlMask,
                dwControlFlags
                );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = GetOwnerSecurityIdentifier(
                pSecDes,
                &pOwnerSid,
                &fOwnerDefaulted
                );
    BAIL_ON_FAILURE(hr);

    dwStatus = SetSecurityDescriptorOwner(
                    &AbsoluteSD,
                    pOwnerSid,
                    fOwnerDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }


    hr = GetGroupSecurityIdentifier(
                pSecDes,
                &pGroupSid,
                &fGroupDefaulted
                );
    BAIL_ON_FAILURE(hr);


    dwStatus = SetSecurityDescriptorGroup(
                    &AbsoluteSD,
                    pGroupSid,
                    fGroupDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    hr = GetDacl(
            pSecDes,
            &pDacl,
            &fDaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pDacl || fDaclDefaulted) {
        DaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorDacl(
                    &AbsoluteSD,
                    DaclPresent,
                    pDacl,
                    fDaclDefaulted
                    );
    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }



    hr = GetSacl(
            pSecDes,
            &pSacl,
            &fSaclDefaulted
            );
    BAIL_ON_FAILURE(hr);


    if (pSacl || fSaclDefaulted) {
        SaclPresent = TRUE;
    }

    dwStatus = SetSecurityDescriptorSacl(
                    &AbsoluteSD,
                    SaclPresent,
                    pSacl,
                    fSaclDefaulted
                    );

    if (!dwStatus) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    dwSDLength = GetSecurityDescriptorLength(
                        &AbsoluteSD
                        );

    pRelative = AllocADsMem(dwSDLength);
    if (!pRelative) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    if (!MakeSelfRelativeSD (&AbsoluteSD, pRelative, &dwSDLength)) {
        FreeADsMem(pRelative);

        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    *ppSecurityDescriptor = pRelative;
    *pdwSDLength = dwSDLength;

cleanup:

    if (pDacl) {
        FreeADsMem(pDacl);
    }

    if (pSacl) {
        FreeADsMem(pSacl);
    }

    if (pOwnerSid) {
        FreeADsMem(pOwnerSid);
    }

    if (pGroupSid) {
        FreeADsMem(pGroupSid);
    }

    RRETURN(hr);

error:
    if (pRelative) {
        FreeADsMem(pRelative);
    }

    *ppSecurityDescriptor = NULL;
    *pdwSDLength = 0;

    goto cleanup;

}

HRESULT
GetOwnerSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfOwnerDefaulted
    )
{
    BSTR bstrOwner = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Owner(
                    &bstrOwner
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_OwnerDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrOwner && *bstrOwner) {

          hr = ConvertTrusteeToSid(
                    bstrOwner,
                    ppSid,
                    &dwSidSize
                    );
          BAIL_ON_FAILURE(hr);
          *pfOwnerDefaulted = FALSE;
        }else {

            *ppSid = NULL;
            *pfOwnerDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfOwnerDefaulted = TRUE;
    }

error:

    if (bstrOwner) {
        ADsFreeString(bstrOwner);
    }

    RRETURN(hr);
}

HRESULT
GetGroupSecurityIdentifier(
    IADsSecurityDescriptor FAR * pSecDes,
    PSID * ppSid,
    PBOOL pfGroupDefaulted
    )
{
    BSTR bstrGroup = NULL;
    DWORD dwSidSize = 0;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_Group(
                    &bstrGroup
                    );
    BAIL_ON_FAILURE(hr);

    hr = pSecDes->get_GroupDefaulted(
                      &varBool
                      );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {

        if (bstrGroup && *bstrGroup) {

            hr = ConvertTrusteeToSid(
                    bstrGroup,
                    ppSid,
                    &dwSidSize
                    );
            BAIL_ON_FAILURE(hr);
            *pfGroupDefaulted = FALSE;
        }else {
            *ppSid = NULL;
            *pfGroupDefaulted = FALSE;
        }

    }else {
        *ppSid = NULL;
        dwSidSize = 0;
        *pfGroupDefaulted = TRUE;
    }

error:

    if (bstrGroup) {
        ADsFreeString(bstrGroup);
    }

    RRETURN(hr);

}

HRESULT
GetDacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppDacl,
    PBOOL pfDaclDefaulted
    )
{
    IADsAccessControlList FAR * pDiscAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_DaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfDaclDefaulted = FALSE;
    }else {
        *pfDaclDefaulted = TRUE;
    }

    hr = pSecDes->get_DiscretionaryAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppDacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pDiscAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pDiscAcl,
                ppDacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pDiscAcl) {
        pDiscAcl->Release();
    }

    RRETURN(hr);
}


HRESULT
GetSacl(
    IADsSecurityDescriptor FAR * pSecDes,
    PACL * ppSacl,
    PBOOL pfSaclDefaulted
    )
{
    IADsAccessControlList FAR * pSystemAcl = NULL;
    IDispatch FAR * pDispatch = NULL;
    HRESULT hr = S_OK;
    VARIANT_BOOL varBool = VARIANT_FALSE;

    hr = pSecDes->get_SaclDefaulted(
                        &varBool
                        );
    BAIL_ON_FAILURE(hr);

    if (varBool == VARIANT_FALSE) {
        *pfSaclDefaulted = FALSE;
    }else {
        *pfSaclDefaulted = TRUE;
    }

    hr = pSecDes->get_SystemAcl(
                    &pDispatch
                    );
    BAIL_ON_FAILURE(hr);

    if (!pDispatch) {
        *ppSacl = NULL;
        goto error;
    }

    hr = pDispatch->QueryInterface(
                    IID_IADsAccessControlList,
                    (void **)&pSystemAcl
                    );
    BAIL_ON_FAILURE(hr);


    hr = ConvertAccessControlListToAcl(
                pSystemAcl,
                ppSacl
                );
    BAIL_ON_FAILURE(hr);

error:

    if (pDispatch) {
        pDispatch->Release();
    }

    if (pSystemAcl) {
        pSystemAcl->Release();
    }

    RRETURN(hr);
}

HRESULT
ConvertAccessControlListToAcl(
    IADsAccessControlList FAR * pAccessList,
    PACL * ppAcl
    )
{
    IUnknown * pUnknown = NULL;
    IEnumVARIANT * pEnumerator  = NULL;
    HRESULT hr = S_OK;
    DWORD i = 0;
    DWORD cReturned = 0;
    VARIANT varAce;

    DWORD dwAceCount = 0;

    IADsAccessControlEntry FAR * pAccessControlEntry = NULL;
    LPBYTE pTempAce = NULL;
    DWORD dwCount = 0;

    PACL pAcl = NULL;
    DWORD dwAclSize = 0;
    PACE_HEADER * ppAceHdr = NULL;

    DWORD dwRet = 0;
    BOOL  bRet = 0;
    DWORD dwAclRevision = 0;


    hr = pAccessList->get_AceCount((long *)&dwAceCount);
    BAIL_ON_FAILURE(hr);


    hr = pAccessList->get__NewEnum(
                    &pUnknown
                    );
    BAIL_ON_FAILURE(hr);

    hr = pUnknown->QueryInterface(
                        IID_IEnumVARIANT,
                        (void FAR * FAR *)&pEnumerator
                        );
    BAIL_ON_FAILURE(hr);



    ppAceHdr = (PACE_HEADER *)AllocADsMem(sizeof(PACE_HEADER)*dwAceCount);
    if (!ppAceHdr) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwAceCount; i++) {

        VariantInit(&varAce);

        hr = pEnumerator->Next(
                    1,
                    &varAce,
                    &cReturned
                    );

        CONTINUE_ON_FAILURE(hr);


        hr = (V_DISPATCH(&varAce))->QueryInterface(
                    IID_IADsAccessControlEntry,
                    (void **)&pAccessControlEntry
                    );
        CONTINUE_ON_FAILURE(hr);

        hr = ConvertAccessControlEntryToAce(
                    pAccessControlEntry,
                    &(pTempAce)
                    );

        VariantClear(&varAce);
        if (pAccessControlEntry) {
            pAccessControlEntry->Release();
            pAccessControlEntry = NULL;
        }
		if (SUCCEEDED(hr))
		{
			*(ppAceHdr + dwCount) = (PACE_HEADER)pTempAce;
			dwCount++;
		}
    }

    hr = ComputeTotalAclSize(ppAceHdr, dwCount, &dwAclSize);
    BAIL_ON_FAILURE(hr);

    pAcl = (PACL)AllocADsMem(dwAclSize);
    if (!pAcl) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

#if 0
    hr = pAccessList->get_AclRevision((long *)&dwAclRevision);
    BAIL_ON_FAILURE(hr);
#else
    dwAclRevision = ACL_REVISION;
#endif


    bRet  = InitializeAcl(
                    pAcl,
                    dwAclSize,
                    dwAclRevision
                    );

    if (!bRet) {
       dwRet = GetLastError();
       hr = HRESULT_FROM_WIN32(dwRet);
       BAIL_ON_FAILURE(hr);
    }

    for (i = 0; i < dwCount; i++) {

        bRet = AddAce(
            pAcl,
            dwAclRevision,
            i,
            (LPBYTE)*(ppAceHdr + i),
            (*(ppAceHdr + i))->AceSize
            );
        if (!bRet) {
           dwRet = GetLastError();
           hr = HRESULT_FROM_WIN32(dwRet);
           BAIL_ON_FAILURE(hr);
        }
    }

    *ppAcl = pAcl;

error:

    if (ppAceHdr) {
        for (i = 0; i < dwCount; i++) {
            if (*(ppAceHdr + i)) {

                FreeADsMem(*(ppAceHdr + i));
            }
        }

        FreeADsMem(ppAceHdr);
    }

    if (pUnknown) {
        pUnknown->Release();
    }

    if (pEnumerator) {
        pEnumerator->Release();
    }


    RRETURN(hr);
}

HRESULT
ConvertAccessControlEntryToAce(
    IADsAccessControlEntry * pAccessControlEntry,
    LPBYTE * ppAce
    )
{

    DWORD dwAceType = 0;
    HRESULT hr = S_OK;
    BSTR bstrTrustee = NULL;
    PSID pSid = NULL;
    DWORD dwSidSize = 0;

    DWORD dwAceFlags = 0;
    DWORD dwAccessMask = 0;
    DWORD dwAceSize = 0;
    LPBYTE pAce = NULL;
    PACCESS_MASK pAccessMask = NULL;
    PSID pSidAddress = NULL;

    PUSHORT pCompoundAceType = NULL;
    DWORD dwCompoundAceType = 0;

    PACE_HEADER pAceHeader = NULL;

    LPBYTE pOffset = NULL;

    BSTR bstrObjectTypeClsid = NULL;
    BSTR bstrInheritedObjectTypeClsid = NULL;

    GUID ObjectTypeGUID;
    GUID InheritedObjectTypeGUID;
    PULONG pFlags;
    DWORD dwFlags = 0;


    hr = pAccessControlEntry->get_AceType((LONG *)&dwAceType);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_Trustee(&bstrTrustee);
    BAIL_ON_FAILURE(hr);

    hr = ConvertTrusteeToSid(
                bstrTrustee,
                &pSid,
                &dwSidSize
                );
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AceFlags((long *)&dwAceFlags);
    BAIL_ON_FAILURE(hr);

    hr = pAccessControlEntry->get_AccessMask((long *)&dwAccessMask);
    BAIL_ON_FAILURE(hr);

    //
    // we will compensateby adding the entire ACE size
    //

    dwAceSize = dwSidSize - sizeof(ULONG);

    switch (dwAceType) {

    case ACCESS_ALLOWED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_DENIED_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case SYSTEM_AUDIT_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;


        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;


        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    case SYSTEM_ALARM_ACE_TYPE:
        dwAceSize += sizeof(ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pSidAddress = (PSID)((LPBYTE)pAccessMask + sizeof(ACCESS_MASK));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_COMPOUND_ACE_TYPE:
        dwAceSize += sizeof(COMPOUND_ACCESS_ALLOWED_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

         pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        pCompoundAceType = (PUSHORT)(pAccessMask + sizeof(ACCESS_MASK));
        *pCompoundAceType = (USHORT)dwCompoundAceType;

        //
        // Fill in the reserved field here.
        //

        pSidAddress = (PSID)((LPBYTE)pCompoundAceType + sizeof(DWORD));
        memcpy(pSidAddress, pSid, dwSidSize);
        break;


    case ACCESS_ALLOWED_OBJECT_ACE_TYPE:

    case ACCESS_DENIED_OBJECT_ACE_TYPE:

    case SYSTEM_AUDIT_OBJECT_ACE_TYPE:

    case SYSTEM_ALARM_OBJECT_ACE_TYPE:


        hr = pAccessControlEntry->get_AceFlags((LONG *)&dwAceFlags);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_Flags((LONG *)&dwFlags);
        BAIL_ON_FAILURE(hr);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {
            dwAceSize += sizeof(GUID);
        }

        hr = pAccessControlEntry->get_ObjectType(&bstrObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrObjectTypeClsid, &ObjectTypeGUID);
        BAIL_ON_FAILURE(hr);

        hr = pAccessControlEntry->get_InheritedObjectType(&bstrInheritedObjectTypeClsid);
        BAIL_ON_FAILURE(hr);

        hr = CLSIDFromString(bstrInheritedObjectTypeClsid, &InheritedObjectTypeGUID);
        BAIL_ON_FAILURE(hr);



        dwAceSize += sizeof(ACCESS_ALLOWED_OBJECT_ACE);
        pAce = (LPBYTE)AllocADsMem(dwAceSize);
        if (!pAce) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        pAceHeader = (PACE_HEADER)pAce;
        pAceHeader->AceType = (UCHAR)dwAceType;
        pAceHeader->AceFlags = (UCHAR)dwAceFlags;
        pAceHeader->AceSize = (USHORT)dwAceSize;

        pAccessMask = (PACCESS_MASK)((LPBYTE)pAceHeader + sizeof(ACE_HEADER));

        *pAccessMask = (ACCESS_MASK)dwAccessMask;

        //
        // Fill in Flags
        //

        pOffset = (LPBYTE)((LPBYTE)pAceHeader +  sizeof(ACE_HEADER) + sizeof(ACCESS_MASK));

        pFlags = (PULONG)(pOffset);

        *pFlags = dwFlags;

        pOffset += sizeof(ULONG);

        if (dwFlags & ACE_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &ObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);

        }


        if (dwFlags & ACE_INHERITED_OBJECT_TYPE_PRESENT) {

            memcpy(pOffset, &InheritedObjectTypeGUID, sizeof(GUID));

            pOffset += sizeof(GUID);
        }

        pSidAddress = (PSID)((LPBYTE)pOffset);
        memcpy(pSidAddress, pSid, dwSidSize);
        break;

    }

    *ppAce = pAce;

error:

    if (bstrTrustee) {
        ADsFreeString(bstrTrustee);
    }

    if (pSid) {
        FreeADsMem(pSid);
    }

    RRETURN(hr);
}

HRESULT
ComputeTotalAclSize(
    PACE_HEADER * ppAceHdr,
    DWORD dwAceCount,
    PDWORD pdwAclSize
    )
{
    DWORD i = 0;
    PACE_HEADER pAceHdr = NULL;
    DWORD dwAceSize = 0;
    DWORD dwAclSize = 0;

    for (i = 0; i < dwAceCount; i++) {

        pAceHdr = *(ppAceHdr + i);
        dwAceSize = pAceHdr->AceSize;
        dwAclSize += dwAceSize;
    }

    dwAclSize += sizeof(ACL);

    *pdwAclSize = dwAclSize;

    RRETURN(S_OK);

}


HRESULT
ConvertTrusteeToSid(
    BSTR bstrTrustee,
    PSID * ppSid,
    PDWORD pdwSidSize
    )
{
    HRESULT hr = S_OK;
    BYTE Sid[MAX_PATH];
    DWORD dwSidSize = sizeof(Sid);
    DWORD dwRet = 0;
    WCHAR szDomainName[MAX_PATH];
    DWORD dwDomainSize = sizeof(szDomainName)/sizeof(WCHAR);
    SID_NAME_USE eUse;
    LPWSTR pszTrustee = (LPWSTR)bstrTrustee;

    PSID pSid = NULL;

    dwSidSize = sizeof(Sid);

    if ((*pszTrustee == (WCHAR)'\\') || (*pszTrustee == WCHAR('/'))){
        pszTrustee++;
    }

    dwRet = LookupAccountName(
                NULL,
                pszTrustee,
                Sid,
                &dwSidSize,
                szDomainName,
                &dwDomainSize,
                (PSID_NAME_USE)&eUse
                );

    if (!dwRet) {
        BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
    }

    pSid = AllocADsMem(dwSidSize);
    if (!pSid) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    memcpy(pSid, Sid, dwSidSize);

    *pdwSidSize = dwSidSize;

    *ppSid = pSid;

error:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\dswarn.h ===
#include <warning.h>

#pragma warning (disable: 4101 4201 4100 4244 4245 4706 4786 4267 4701 4115 4509 4214 4057 4127 4189 4702)

#pragma warning (disable:  4514 4512 4663)

/**************************************************************************

DESCRIPTION OF WARNINGS THAT ARE DISABLED

4101  unreferenced local variable

*4201  nonstandard extension: nameless struct or union

*4214  non standard extension: bit field types other than int

*4115  named type definition in paranthesis -- does not like THSTATE

*4127  conditional expression is a constant

4100  ureferenced formal parameter

*4189  local variable is initialized but not referenced 

*4057 slightly different base types -- char * and unsigned char *

4244 conversion from into to char --loss of data -- I saw a few of these and disabled in an effort to get the code to compile -- need further investigation.

4245 conversion from long to unsigned long -- signed/unsigned mismatch

*4509 non standard extension used -- uses SEH and has destructor

4706 assignment within a conditional expression

4702  *unreacheable code

*4701  var used before initializing

4786  identifier truncated to 255 chars in debug information

4267  Signal to noise ratio of this warning is pretty poor -- too many 
      '=' conversion from size_t to unsigned long, possible loss of data
      The problem is that size_t in 64 bit is defined as a 64 bit int,
      while ulong is still a 32 bit int. In practice most places this is
      used -- e.g sizeof operator, or string len etc the value will fit 
      in a 32 bit ULONG

4514 unreferenced inline function has been removed

4512 assignment operator could not be generated

4663 C++ language change: to explicitly specialize class template 'identifier' use the following syntax

VALID WARNINGS ENCOUNTERED 

( 4267, 4701, 4702 and 4706 can also be included in
this list if desired )

4306 TypeCast -- conversion from unsigned short to unsigned short *

4305 Typecase -- truncation from unsigned short * to unsigned short

4312 TypeCase -- Conversion from unsigned long to void * __ptr64 of greater size



****************************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\adstype.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:
//
//  Contents:
//
//  Functions:
//
//  History:
//
//----------------------------------------------------------------------------
#ifndef _ADSTYPE_H_INCLUDED_
#define _ADSTYPE_H_INCLUDED_

typedef enum {
   ADSTYPE_INVALID = 0,
   ADSTYPE_DN_STRING,
   ADSTYPE_CASE_EXACT_STRING,
   ADSTYPE_CASE_IGNORE_STRING,
   ADSTYPE_PRINTABLE_STRING,
   ADSTYPE_NUMERIC_STRING,
   ADSTYPE_BOOLEAN,
   ADSTYPE_INTEGER,
   ADSTYPE_OCTET_STRING,
   ADSTYPE_UTC_TIME,
   ADSTYPE_LARGE_INTEGER,
   ADSTYPE_PROV_SPECIFIC,
   ADSTYPE_OBJECT_CLASS,
   ADSTYPE_CASEIGNORE_LIST,
   ADSTYPE_OCTET_LIST,
   ADSTYPE_PATH,
   ADSTYPE_POSTALADDRESS,
   ADSTYPE_TIMESTAMP,
   ADSTYPE_BACKLINK,
   ADSTYPE_TYPEDNAME,
   ADSTYPE_HOLD,
   ADSTYPE_NETADDRESS,
   ADSTYPE_REPLICAPOINTER,
   ADSTYPE_FAXNUMBER,
   ADSTYPE_EMAIL,
   ADSTYPE_NT_SECURITY_DESCRIPTOR,
   ADSTYPE_UNKNOWN,
   ADSTYPE_DN_WITH_BINARY,
   ADSTYPE_DN_WITH_STRING
} ADSTYPEENUM;
typedef ADSTYPEENUM ADSTYPE;

//
// ADSTYPE_UNKNOWN was added to the end to be save and not break anyone.
// If further types are added, this will be in the middle which is not
// the best position but nonethesless functional.
//


typedef unsigned char BYTE, *LPBYTE, *PBYTE;


//
// ADS Case DN String syntax
//

typedef LPWSTR ADS_DN_STRING, * PADS_DN_STRING;

//
// ADS Case Exact String syntax
//

typedef LPWSTR ADS_CASE_EXACT_STRING, * PADS_CASE_EXACT_STRING;

//
// ADS Case Ignore String syntax
//

typedef LPWSTR ADS_CASE_IGNORE_STRING, *PADS_CASE_IGNORE_STRING;

//
// ADS Printable String syntax
//

typedef LPWSTR ADS_PRINTABLE_STRING, *PADS_PRINTABLE_STRING;

//
// ADS Numeric String syntax
//
//

typedef LPWSTR ADS_NUMERIC_STRING, *PADS_NUMERIC_STRING;


//
// ADS Boolean syntax
//

typedef DWORD ADS_BOOLEAN, * LPNDS_BOOLEAN;

//
// Example: ADS Integer syntax
//

typedef DWORD ADS_INTEGER, *PADS_INTEGER;

//
// ADS Octet String syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_OCTET_STRING, *PADS_OCTET_STRING;


//
// ADS NT Security Descriptor syntax
//

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_NT_SECURITY_DESCRIPTOR, *PADS_NT_SECURITY_DESCRIPTOR;


//
// ADS UTC Time Syntax
//

typedef SYSTEMTIME ADS_UTC_TIME, *PADS_UTC_TIME;


typedef LARGE_INTEGER ADS_LARGE_INTEGER, *PADS_LARGE_INTEGER;



//
// ADS ClassName syntax
//

typedef LPWSTR  ADS_OBJECT_CLASS, *PADS_OBJECT_CLASS;

typedef struct
{
    DWORD  dwLength;
    LPBYTE lpValue;

} ADS_PROV_SPECIFIC, *PADS_PROV_SPECIFIC;

//
// Extended Syntaxes for NDS
//
typedef struct _ADS_CASEIGNORE_LIST
{
    struct _ADS_CASEIGNORE_LIST *Next;
    LPWSTR            String;

}
ADS_CASEIGNORE_LIST, *PADS_CASEIGNORE_LIST;


typedef struct _ADS_OCTET_LIST
{
    struct _ADS_OCTET_LIST *Next;
    DWORD  Length;
    BYTE * Data;

} ADS_OCTET_LIST, *PADS_OCTET_LIST;

typedef struct
{
    DWORD  Type;
    LPWSTR VolumeName;
    LPWSTR Path;

} ADS_PATH, *PADS_PATH;

typedef struct
{
    LPWSTR PostalAddress[6]; // Value is limited to 6 lines,
                             // 30 characters each.

} ADS_POSTALADDRESS, *PADS_POSTALADDRESS;

typedef struct
{
    DWORD WholeSeconds; // Zero equals 12:00 midnight, January 1, 1970, UTC
    DWORD EventID;

} ADS_TIMESTAMP, *PADS_TIMESTAMP;

typedef struct
{
    DWORD  RemoteID;
    LPWSTR ObjectName;

} ADS_BACKLINK, *PADS_BACKLINK;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Level;
    DWORD  Interval;

} ADS_TYPEDNAME, *PADS_TYPEDNAME;

typedef struct
{
    LPWSTR ObjectName;
    DWORD  Amount;

} ADS_HOLD, *PADS_HOLD;

typedef struct
{
    DWORD  AddressType; // 0 = IPX,
    DWORD  AddressLength;
    BYTE * Address;

} ADS_NETADDRESS, *PADS_NETADDRESS;

typedef struct
{
    LPWSTR ServerName;
    DWORD  ReplicaType;
    DWORD  ReplicaNumber;
    DWORD  Count;
    PADS_NETADDRESS ReplicaAddressHints;
} ADS_REPLICAPOINTER, *PADS_REPLICAPOINTER;

typedef struct
{
    LPWSTR TelephoneNumber;
    DWORD  NumberOfBits;
    LPBYTE Parameters;
} ADS_FAXNUMBER, *PADS_FAXNUMBER;

typedef struct
{
    LPWSTR Address;
    DWORD  Type;
} ADS_EMAIL, *PADS_EMAIL;

typedef struct
{
    DWORD dwLength;
    LPBYTE lpBinaryValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_BINARY, *PADS_DN_WITH_BINARY;

typedef struct
{
    LPWSTR pszStringValue;
    LPWSTR pszDNString;
} ADS_DN_WITH_STRING, *PADS_DN_WITH_STRING;


typedef struct _adsvalue{
   ADSTYPE dwType;
   union {
      ADS_DN_STRING                     DNString;
      ADS_CASE_EXACT_STRING             CaseExactString;
      ADS_CASE_IGNORE_STRING            CaseIgnoreString;
      ADS_PRINTABLE_STRING              PrintableString;
      ADS_NUMERIC_STRING                NumericString;
      ADS_BOOLEAN                       Boolean;
      ADS_INTEGER                       Integer;
      ADS_OCTET_STRING                  OctetString;
      ADS_UTC_TIME                      UTCTime;
      ADS_LARGE_INTEGER                 LargeInteger;
      ADS_OBJECT_CLASS                  ClassName;
      ADS_PROV_SPECIFIC                 ProviderSpecific;
      PADS_CASEIGNORE_LIST              pCaseIgnoreList;
      PADS_OCTET_LIST                   pOctetList;
      PADS_PATH                         pPath;
      PADS_POSTALADDRESS                pPostalAddress;
      ADS_TIMESTAMP                     Timestamp;
      ADS_BACKLINK                      BackLink;
      PADS_TYPEDNAME                    pTypedName;
      ADS_HOLD                          Hold;
      PADS_NETADDRESS                   pNetAddress;
      PADS_REPLICAPOINTER               pReplicaPointer;
      PADS_FAXNUMBER                    pFaxNumber;
      ADS_EMAIL                         Email;
      ADS_NT_SECURITY_DESCRIPTOR        SecurityDescriptor;
      PADS_DN_WITH_BINARY               pDNWithBinary;
      PADS_DN_WITH_STRING               pDNWithString;
   };
}ADSVALUE, *PADSVALUE, *LPADSVALUE;

typedef struct _ads_attr_info{
    LPWSTR  pszAttrName;
    DWORD   dwControlCode;
    ADSTYPE dwADsType;
    PADSVALUE pADsValues;
    DWORD   dwNumValues;
} ADS_ATTR_INFO, *PADS_ATTR_INFO;

typedef enum {
    ADS_SECURE_AUTHENTICATION = 0x00000001,
    ADS_USE_ENCRYPTION        = 0x00000002,
    ADS_USE_SSL               = 0x00000002,
    ADS_READONLY_SERVER       = 0x00000004,
    ADS_PROMPT_CREDENTIALS    = 0x00000008,
    ADS_NO_AUTHENTICATION     = 0x00000010,
    ADS_FAST_BIND             = 0x00000020,
    ADS_USE_SIGNING           = 0x00000040,
    ADS_USE_SEALING           = 0x00000080,
    ADS_USE_DELEGATION        = 0x00000100,
    ADS_SERVER_BIND           = 0x00000200,
    ADS_AUTH_RESERVED         = 0x80000000
} ADS_AUTHENTICATION_ENUM;

/* ADS attribute modification operations */

const int ADS_ATTR_CLEAR          =  1; /* Clear all values from an attribute */
const int ADS_ATTR_UPDATE         =  2; /* Update values on an attribute */
const int ADS_ATTR_APPEND         =  3; /* Append  values to an attribute  */
const int ADS_ATTR_DELETE         =  4; /* Delete values from an attribute  */


typedef struct _ads_object_info{
    LPWSTR pszRDN;
    LPWSTR pszObjectDN;
    LPWSTR pszParentDN;
    LPWSTR pszSchemaDN;
    LPWSTR pszClassName;
} ADS_OBJECT_INFO, *PADS_OBJECT_INFO;

typedef enum {
    ADS_STATUS_S_OK = 0,
    ADS_STATUS_INVALID_SEARCHPREF,
    ADS_STATUS_INVALID_SEARCHPREFVALUE
} ADS_STATUSENUM;

typedef ADS_STATUSENUM ADS_STATUS, *PADS_STATUS;



typedef enum {
    ADS_DEREF_NEVER           = 0,
    ADS_DEREF_SEARCHING       = 1,
    ADS_DEREF_FINDING         = 2,
    ADS_DEREF_ALWAYS          = 3
} ADS_DEREFENUM;

typedef enum {
    ADS_SCOPE_BASE            = 0,
    ADS_SCOPE_ONELEVEL        = 1,
    ADS_SCOPE_SUBTREE         = 2
} ADS_SCOPEENUM;

// Some more useful enums moved from other places
typedef enum {

    ADSIPROP_ASYNCHRONOUS       =   0x00000000,
    ADSIPROP_DEREF_ALIASES      =   0x00000001,
    ADSIPROP_SIZE_LIMIT         =   0x00000002,
    ADSIPROP_TIME_LIMIT         =   0x00000003,
    ADSIPROP_ATTRIBTYPES_ONLY   =   0x00000004,
    ADSIPROP_SEARCH_SCOPE       =   0x00000005,
    ADSIPROP_TIMEOUT            =   0x00000006,
    ADSIPROP_PAGESIZE           =   0x00000007,
    ADSIPROP_PAGED_TIME_LIMIT   =   0x00000008,
    ADSIPROP_CHASE_REFERRALS    =   0x00000009,
    ADSIPROP_SORT_ON            =   0x0000000a,
    ADSIPROP_CACHE_RESULTS      =   0x0000000b,
    ADSIPROP_ADSIFLAG           =   0x0000000c

} ADS_PREFERENCES_ENUM;


typedef enum {

    ADSI_DIALECT_LDAP     =  0x00000000,
    ADSI_DIALECT_SQL      =  0x00000001

} ADSI_DIALECT_ENUM;

//
// Values for ChaseReferral Option.
typedef enum {

    ADS_CHASE_REFERRALS_NEVER         =  0x00000000,
    ADS_CHASE_REFERRALS_SUBORDINATE   =  0x00000020,
    ADS_CHASE_REFERRALS_EXTERNAL      =  0x00000040,
    ADS_CHASE_REFERRALS_ALWAYS        =
            (ADS_CHASE_REFERRALS_SUBORDINATE | ADS_CHASE_REFERRALS_EXTERNAL)
} ADS_CHASE_REFERRALS_ENUM;

typedef enum {
   ADS_SEARCHPREF_ASYNCHRONOUS,
   ADS_SEARCHPREF_DEREF_ALIASES,
   ADS_SEARCHPREF_SIZE_LIMIT,
   ADS_SEARCHPREF_TIME_LIMIT,
   ADS_SEARCHPREF_ATTRIBTYPES_ONLY,
   ADS_SEARCHPREF_SEARCH_SCOPE,
   ADS_SEARCHPREF_TIMEOUT,
   ADS_SEARCHPREF_PAGESIZE,
   ADS_SEARCHPREF_PAGED_TIME_LIMIT,
   ADS_SEARCHPREF_CHASE_REFERRALS,
   ADS_SEARCHPREF_SORT_ON,
   ADS_SEARCHPREF_CACHE_RESULTS,
   ADS_SEARCHPREF_DIRSYNC,
   ADS_SEARCHPREF_TOMBSTONE,
   ADS_SEARCHPREF_VLV,
   ADS_SEARCHPREF_ATTRIBUTE_QUERY,
   ADS_SEARCHPREF_SECURITY_MASK

} ADS_SEARCHPREF_ENUM;

typedef ADS_SEARCHPREF_ENUM ADS_SEARCHPREF;

typedef struct ads_searchpref_info{
    ADS_SEARCHPREF dwSearchPref;
    ADSVALUE vValue;
    ADS_STATUS dwStatus;
} ADS_SEARCHPREF_INFO, *PADS_SEARCHPREF_INFO, *LPADS_SEARCHPREF_INFO;


const LPWSTR ADS_DIRSYNC_COOKIE=L"fc8cb04d-311d-406c-8cb9-1ae8b843b418";
const LPWSTR ADS_VLV_RESPONSE  =L"fc8cb04d-311d-406c-8cb9-1ae8b843b419";

typedef HANDLE ADS_SEARCH_HANDLE, *PADS_SEARCH_HANDLE;


typedef struct ads_search_column {
   LPWSTR  pszAttrName;
   ADSTYPE dwADsType;
   PADSVALUE pADsValues;
   DWORD   dwNumValues;
   HANDLE hReserved;
} ADS_SEARCH_COLUMN, *PADS_SEARCH_COLUMN;


typedef struct _ads_attr_def {
   LPWSTR pszAttrName;
    ADSTYPE dwADsType;
    DWORD dwMinRange;
    DWORD dwMaxRange;
    BOOL fMultiValued;
}ADS_ATTR_DEF, *PADS_ATTR_DEF;


typedef struct _ads_class_def {
    LPWSTR pszClassName;
    DWORD  dwMandatoryAttrs;
    LPWSTR *ppszMandatoryAttrs;
    DWORD optionalAttrs;
    LPWSTR **ppszOptionalAttrs;
    DWORD dwNamingAttrs;
    LPWSTR **ppszNamingAttrs;
    DWORD dwSuperClasses;
    LPWSTR **ppszSuperClasses;
    BOOL fIsContainer;
}ADS_CLASS_DEF, *PADS_CLASS_DEF;


typedef struct _ads_sortkey {

    LPWSTR  pszAttrType;
    LPWSTR  pszReserved;
    BOOLEAN fReverseorder;

} ADS_SORTKEY, *PADS_SORTKEY;


typedef struct _ads_vlv {

    DWORD dwBeforeCount;
    DWORD dwAfterCount;
    DWORD dwOffset;
    DWORD dwContentCount;
    LPWSTR pszTarget;
    DWORD  dwContextIDLength;
    LPBYTE lpContextID;
} ADS_VLV, *PADS_VLV;

//
// Valid dispids for extension.
//
// - Max 24 bits.
// - 0 reserved for DISPID_VALUE dealt with by aggregator.
// - DISPID_UNKNOWN (-1) also allowed.
// - Others -ve dispids dealt with by aggregator only.
//

const int ADS_EXT_MINEXTDISPID = 1 ;
const int ADS_EXT_MAXEXTDISPID = 16777215 ;


//
// dwCodes for IADsExtension::Operate
//

const int ADS_EXT_INITCREDENTIALS       = 1 ;
const int ADS_EXT_INITIALIZE_COMPLETE   = 2 ;


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\macro.h ===
#define BAIL_IF_ERROR(hr) \
        if (FAILED(hr)) {       \
                goto cleanup;   \
        }\

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define CONTINUE_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                continue;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\

#define QUERY_INTERFACE(hr, ptr, iid, ppObj) \
        hr = ptr->QueryInterface(iid, (void **)ppObj); \
        if (FAILED(hr)) {    \
                goto cleanup;\
        }\


#define RRETURN_ENUM_STATUS(hr) \
        if (hr != S_OK) {       \
            RRETURN(S_FALSE);   \
        }                       \
        RRETURN(S_OK);




#define DEFINE_IDispatch_Implementation_Unimplemented(cls) \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)        \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,        \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,   \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid, \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
    RRETURN(E_NOTIMPL);                                               \
}




#define DEFINE_IDispatch_Implementation(cls)                          \
STDMETHODIMP                                                          \
cls::GetTypeInfoCount(unsigned int FAR* pctinfo)                      \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfoCount(pctinfo));                \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::GetTypeInfo(unsigned int itinfo, LCID lcid,                      \
        ITypeInfo FAR* FAR* pptinfo)                                  \
{                                                                     \
        RRETURN(_pDispMgr->GetTypeInfo(itinfo,                        \
                                       lcid,                          \
                                       pptinfo                        \
                                       ));                            \
}                                                                     \
STDMETHODIMP                                                          \
cls::GetIDsOfNames(REFIID iid, LPWSTR FAR* rgszNames,                 \
        unsigned int cNames, LCID lcid, DISPID FAR* rgdispid)         \
{                                                                     \
        RRETURN(_pDispMgr->GetIDsOfNames(iid,                         \
                                         rgszNames,                   \
                                         cNames,                      \
                                         lcid,                        \
                                         rgdispid                     \
                                         ));                          \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,               \
        unsigned short wFlags, DISPPARAMS FAR* pdispparams,           \
        VARIANT FAR* pvarResult, EXCEPINFO FAR* pexcepinfo,           \
        unsigned int FAR* puArgErr)                                   \
{                                                                     \
        RRETURN (_pDispMgr->Invoke(dispidMember,                      \
                                   iid,                               \
                                   lcid,                              \
                                   wFlags,                            \
                                   pdispparams,                       \
                                   pvarResult,                        \
                                   pexcepinfo,                        \
                                   puArgErr                           \
                                   ));                                \
}

#define DEFINE_IADs_Implementation(cls)                             \
STDMETHODIMP                                                          \
cls::get_Name(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreName(retval));                                    \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_ADsPath(THIS_ BSTR FAR* retval)                            \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsPath(retval));                               \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Class(THIS_ BSTR FAR* retval)                                \
{                                                                     \
                                                                      \
    RRETURN(get_CoreADsClass(retval));                              \
}                                                                     \
                                                                      \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Parent(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreParent(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_Schema(THIS_ BSTR FAR* retval)                               \
{                                                                     \
    RRETURN(get_CoreSchema(retval));                                  \
}                                                                     \
                                                                      \
STDMETHODIMP                                                          \
cls::get_GUID(THIS_ BSTR FAR* retval)                                 \
{                                                                     \
    RRETURN(get_CoreGUID(retval));                                    \
}                                                                     \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\memory.h ===
#ifndef _MEMORY_H_INCLUDED_
#define _MEMORY_H_INCLUDED_

#ifdef __cplusplus
extern "C" {
#endif

LPVOID
AllocADsMem(
    DWORD cb
);

BOOL
FreeADsMem(
   LPVOID pMem
);

LPVOID
ReallocADsMem(
   LPVOID pOldMem,
   DWORD cbOld,
   DWORD cbNew
);

LPWSTR
AllocADsStr(
    LPCWSTR pStr
);

BOOL
FreeADsStr(
   LPWSTR pStr
);


BOOL
ReallocADsStr(
   LPWSTR *ppStr,
   LPWSTR pStr
);

#if DBG

extern LIST_ENTRY ADsMemList ;

extern CRITICAL_SECTION ADsMemCritSect ;

VOID InitADsMem(
    VOID
    ) ;

VOID AssertADsMemLeaks(
    VOID
    ) ;


VOID
DumpMemoryTracker();


#else

#define InitADsMem()
#define AssertADsMemLeaks()

#define DumpMemoryTracker()



#endif

#ifdef __cplusplus
}
#endif


#endif // _MEMORY_H_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\oledsdbg.h ===
//+-------------------------------------------------------------------------
//
// File:      oledsdbg.h
//
// Contains:  Debugging stuff for use by the ADs code
//
// History:
//
//
//--------------------------------------------------------------------------

#ifndef _ADSDBG_H_
#define _ADSDBG_H_
//--------------------------------------------------------------------------
//
// Debugging Stuff
//
//--------------------------------------------------------------------------


#include <formdeb.h>

#if DBG == 1
#define ADsDebugOut(x)  ADsInlineDebugOut x
#define ADsAssert(x)    Win4Assert(x)
#define ADsVerify(x)    ADsAssert(x)

//
// HeapValidate() is only available from NTs kernel32.dll
//

#if defined(DAYTONA)
#define VDATEHEAP()       Win4Assert(HeapValidate(GetProcessHeap(), 0, NULL))
#else
#define VDATEHEAP()
#endif

#else
#define ADsDebugOut(x)
#define ADsAssert(x)
#define ADsVerify(x)    x
#define VDATEHEAP()
#endif


DECLARE_DEBUG(ADs);

#ifdef Assert
#undef Assert
#endif

//
// You should use ADsAssert, not Assert
//
#define Assert(x) ADsAssert(x)

#endif //_ADSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\heapstat.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       Heapstats.hxx
//
//  Contents:   Structure that holds heap statistics.
//
//  Classes:    HEAPSTATS
//
//  History:    26-Oct-93 DavidBak      Created
//
//--------------------------------------------------------------------------

#if !defined(__HEAPSTAT_HXX__)
#define __HEAPSTAT_HXX__

#if (PERFSNAP == 1) || (DBG == 1)

//+-------------------------------------------------------------------------
//
//  Class:      HEAPSTATS
//
//  Purpose:    Data structure containing performance counters from the heap.
//              Used in our version of operator new.
//              See common\src\except\memory.cxx.
//
//--------------------------------------------------------------------------

typedef struct _HeapStats
{
    ULONG	cNew;
    ULONG	cZeroNew;
    ULONG	cDelete;
    ULONG	cZeroDelete;
    ULONG	cRealloc;
    ULONG       cbNewed;
    ULONG       cbDeleted;
} HEAPSTATS;

//
// GetHeapStats is in memory.cxx
//

#ifdef __cplusplus
extern "C" {
#endif

void GetHeapStats(HEAPSTATS * hsStats);

#ifdef __cplusplus
}
#endif


#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\formdeb.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       formdeb.h
//
//  Contents:   Private project-wide Win 4 definitions
//
//  History:    23-Jul-91   KyleP       Created.
//              15-Oct-91   KevinRo     Major changes and comments added
//              18-Oct-91   vich        Consolidated win4p.hxx
//              22-Oct-91   SatoNa      Added SHLSTRICT
//              29-Apr-92   BartoszM    Moved from win4p.h
//               3-Jun-92   BruceFo     Added SMUISTRICT
//              17-Dec-92   AlexT       Moved UN..._PARM out of DEVL==1
//              30-Sep-93   KyleP       DEVL obsolete
//              18-Jun-94   AlexT       Make Assert a better statement
//              08-Aug-94   DonCl       copied from cinc and renamed formdeb.h
//
//----------------------------------------------------------------------------

#ifndef __FORMDEB_H__
#define __FORMDEB_H__
#define __DEBNOT_H__    // keep debnot.h from being included accidentally

#include <stdarg.h>

//----------------------------------------------------------------------------
//  Parameter Macros
//
//  To avoid compiler warnings for unimplemented functions, use
//  UNIMPLEMENTED_PARM(x) for each unreferenced parameter.  This will
//  later be defined to nul to reveal functions that we forgot to implement.
//
//  For functions which will never use a parameter, use
//  UNREFERENCED_PARM(x).
//

#define UNIMPLEMENTED_PARM(x)   (x)

#define UNREFERENCED_PARM(x)    (x)

//----------------------------------------------------------------------------
//
//  New STRICT defines should be added in two places below:
//
//  1)  Add the following within the ifdef ALLSTRICT/endif:
//
//      #ifndef xxSTRICT
//      #  define xxSTRICT
//      #endif
//
//      These entries are in alphabetical order.
//
//  2)  Add the following to the #if clause that defines ANYSTRICT:
//
//      #if ... || defined(xxSTRICT) || ...
//
//      so that ANYSTRICT is defined if any of the STRICT defines are.
//

#if (DBG == 1) || (OFSDBG == 1)

#  ifndef CATSTRICT
#    define CATSTRICT
#  endif

#  ifndef CISTRICT
#    define CISTRICT
#  endif

#  ifndef CMSSTRICT
#    define CMSSTRICT
#  endif

#  ifndef DLOSSTRICT
#    define DLOSSTRICT
#  endif

#  ifndef EVSTRICT
#    define EVSTRICT
#  endif

#  ifndef ICLSTRICT
#    define ICLSTRICT
#  endif

#  ifndef INSSTRICT
#    define INSSTRICT
#  endif

#  ifndef JWSTRICT
#    define JWSTRICT
#  endif

#  ifndef NSSTRICT
#    define NSSTRICT
#  endif

#  ifndef OLSTRICT
#    define OLSTRICT
#  endif

#  ifndef OMSTRICT
#    define OMSTRICT
#  endif

#  ifndef REPLSTRICT
#    define REPLSTRICT
#  endif

#  ifndef SHLSTRICT
#    define SHLSTRICT
#  endif

#  ifndef SLSTRICT
#    define SLSTRICT
#  endif

#  ifndef SMUISTRICT
#    define SMUISTRICT
#  endif

#  ifndef SOMSTRICT
#    define SOMSTRICT
#  endif

#  ifndef VCSTRICT
#    define VCSTRICT
#  endif

#  ifndef VQSTRICT
#    define VQSTRICT
#  endif

#  ifndef WMASTRICT
#    define WMASTRICT
#  endif


#endif // (DBG == 1) || (OFSDBG == 1)

//
//  ANYSTRICT
//

#if defined(CATSTRICT) || \
    defined(CISTRICT)  || \
    defined(CMSSTRICT) || \
    defined(DLOSSTRICT)|| \
    defined(ICLSTRICT) || \
    defined(INSSTRICT) || \
    defined(JWSTRICT)  || \
    defined(NSSTRICT)  || \
    defined(OLSTRICT)  || \
    defined(OMSTRICT)  || \
    defined(REPLSTRICT)|| \
    defined(SHLSTRICT) || \
    defined(SLSTRICT)  || \
    defined(SMUISTRICT)|| \
    defined(SOMSTRICT) || \
    defined(VCSTRICT)  || \
    defined(VQSTRICT)  || \
    defined(WMASTRICT)

#  define ANYSTRICT

#endif

#if (DBG != 1 && OFSDBG != 1) && defined(ANYSTRICT)
#pragma message Asserts are defined in a RETAIL build...
#endif


#if defined(WIN32)
 #include <windef.h>
#endif

#ifndef EXPORTDEF
 #define EXPORTDEF
#endif
#ifndef EXPORTIMP
 #define EXPORTIMP
#endif
#ifndef EXPORTED
 #define EXPORTED  _cdecl
#endif
#ifndef APINOT
#ifdef _X86_
 #define APINOT    _stdcall
#else
 #define APINOT    _cdecl
#endif
#endif

//
// DEBUG -- DEBUG -- DEBUG -- DEBUG -- DEBUG
//

#if (DBG == 1) || (OFSDBG == 1)

//
// Debug print functions.
//

#ifdef __cplusplus
extern "C" {
# define EXTRNC "C"
#else
# define EXTRNC
#endif



// vdprintf should only be called from xxDebugOut()

   EXPORTDEF void          APINOT
   vdprintf(
       unsigned long ulCompMask,
       char const *pszComp,
       char const *ppszfmt,
       va_list  ArgList);

   #define _Win4Assert Win4AssertEx

   EXPORTDEF void          APINOT
   Win4AssertEx(
       char const *pszFile,
       int iLine,
       char const *pszMsg);

   EXPORTDEF int           APINOT
   PopUpError(
       char const *pszMsg,
       int iLine,
       char const *pszFile);

   #define _SetWin4InfoLevel SetWin4InfoLevel

   EXPORTDEF unsigned long APINOT
   SetWin4InfoLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4InfoMask(
       unsigned long ulNewMask);

   #define _SetWin4AssertLevel SetWin4AssertLevel

   EXPORTDEF unsigned long APINOT
   SetWin4AssertLevel(
       unsigned long ulNewLevel);

   EXPORTDEF unsigned long APINOT
   SetWin4ExceptionLevel(
       unsigned long ulNewLevel);

#ifdef __cplusplus
}
#endif // __cplusplus

# define EXSTRICT      // (EXception STRICT) - Enabled if ANYSTRICT is enabled

# define Win4Assert(x)  \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Assert(x)      \
        (void)((x) || (Win4AssertEx(__FILE__, __LINE__, #x),0))

# define Verify(x) Assert(x)


//
// Debug print macros
//

# define DEB_ERROR               0x00000001      // exported error paths
# define DEB_WARN                0x00000002      // exported warnings
# define DEB_TRACE               0x00000004      // exported trace messages

# define DEB_DBGOUT              0x00000010      // Output to debugger
# define DEB_STDOUT              0x00000020      // Output to stdout

# define DEB_IERROR              0x00000100      // internal error paths
# define DEB_IWARN               0x00000200      // internal warnings
# define DEB_ITRACE              0x00000400      // internal trace messages

# define DEB_USER1               0x00010000      // User defined
# define DEB_USER2               0x00020000      // User defined
# define DEB_USER3               0x00040000      // User defined
# define DEB_USER4               0x00080000      // User defined
# define DEB_USER5               0x00100000      // User defined
# define DEB_USER6               0x00200000      // User defined
# define DEB_USER7               0x00400000      // User defined
# define DEB_USER8               0x00800000      // User defined
# define DEB_USER9               0x01000000      // User defined
# define DEB_USER10              0x02000000      // User defined
# define DEB_USER11              0x04000000      // User defined
# define DEB_USER12              0x08000000      // User defined
# define DEB_USER13              0x10000000      // User defined
# define DEB_USER14              0x20000000      // User defined
# define DEB_USER15              0x40000000      // User defined

# define DEB_NOCOMPNAME          0x80000000      // suppress component name

# define DEB_FORCE               0x7fffffff      // force message

# define ASSRT_MESSAGE           0x00000001      // Output a message
# define ASSRT_BREAK             0x00000002      // Int 3 on assertion
# define ASSRT_POPUP             0x00000004      // And popup message

# define EXCEPT_MESSAGE          0x00000001      // Output a message
# define EXCEPT_BREAK            0x00000002      // Int 3 on exception
# define EXCEPT_POPUP            0x00000004      // Popup message
# define EXCEPT_FAULT            0x00000008      // generate int 3 on access violation


//+----------------------------------------------------------------------
//
// DECLARE_DEBUG(comp)
// DECLARE_INFOLEVEL(comp)
//
// This macro defines xxDebugOut where xx is the component prefix
// to be defined. This declares a static variable 'xxInfoLevel', which
// can be used to control the type of xxDebugOut messages printed to
// the terminal. For example, xxInfoLevel may be set at the debug terminal.
// This will enable the user to turn debugging messages on or off, based
// on the type desired. The predefined types are defined below. Component
// specific values should use the upper 24 bits
//
// To Use:
//
// 1)   In your components main include file, include the line
//              DECLARE_DEBUG(comp)
//      where comp is your component prefix
//
// 2)   In one of your components source files, include the line
//              DECLARE_INFOLEVEL(comp)
//      where comp is your component prefix. This will define the
//      global variable that will control output.
//
// It is suggested that any component define bits be combined with
// existing bits. For example, if you had a specific error path that you
// wanted, you might define DEB_<comp>_ERRORxxx as being
//
// (0x100 | DEB_ERROR)
//
// This way, we can turn on DEB_ERROR and get the error, or just 0x100
// and get only your error.
//
// Define values that are specific to your xxInfoLevel variable in your
// own file, like ciquery.hxx.
//
//-----------------------------------------------------------------------

# ifndef DEF_INFOLEVEL
#  define DEF_INFOLEVEL (DEB_ERROR | DEB_WARN)
# endif



//
// Back to the info level stuff.
//

# ifdef __cplusplus
extern "C" {
# endif // __cplusplus

# define DECLARE_INFOLEVEL(comp) \
        extern EXTRNC unsigned long comp##InfoLevel = DEF_INFOLEVEL;\
        extern EXTRNC char *comp##InfoLevelString = #comp;

# ifdef __cplusplus
}
# endif

# ifdef __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }     \
    \
    class comp##CDbgTrace\
    {\
    private:\
        unsigned long _ulFlags;\
        char const * const _pszName;\
    public:\
        comp##CDbgTrace(unsigned long ulFlags, char const * const pszName);\
        ~comp##CDbgTrace();\
    };\
    \
    inline comp##CDbgTrace::comp##CDbgTrace(\
            unsigned long ulFlags,\
            char const * const pszName)\
    : _ulFlags(ulFlags), _pszName(pszName)\
    {\
        comp##InlineDebugOut(_ulFlags, "Entering %s\n", _pszName);\
    }\
    \
    inline comp##CDbgTrace::~comp##CDbgTrace()\
    {\
        comp##InlineDebugOut(_ulFlags, "Exiting %s\n", _pszName);\
    }

# else  // ! __cplusplus

#  define DECLARE_DEBUG(comp) \
    extern EXTRNC unsigned long comp##InfoLevel; \
    extern EXTRNC char *comp##InfoLevelString; \
    _inline void \
    comp##InlineDebugOut(unsigned long fDebugMask, char const *pszfmt, ...) \
    { \
        if (comp##InfoLevel & fDebugMask) \
        { \
            va_list va; \
            va_start (va, pszfmt); \
            vdprintf(fDebugMask, comp##InfoLevelString, pszfmt, va);\
            va_end(va); \
        } \
    }

# endif // ! __cplusplus

#else  // DBG == 0

//
// NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG -- NO DEBUG
//

# define Win4Assert(x)  NULL
# define Assert(x)      NULL
# define Verify(x)     (x)

# define DECLARE_DEBUG(comp)
# define DECLARE_INFOLEVEL(comp)

#endif // DBG == 0

#endif // __DEBNOT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\oledsdbg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1996.
//
//  File:       oledsdbg.cxx
//
//  Contents:
//
//
//  History:
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if DBG==1

#include <stdio.h>
#include <printf.h>


unsigned long Win4InfoLevel = DEF_INFOLEVEL;
unsigned long Win4InfoMask = 0xffffffff;
unsigned long Win4AssertLevel = ASSRT_MESSAGE | ASSRT_BREAK | ASSRT_POPUP;

CRITICAL_SECTION g_csDP; // used by debug print routines

//+------------------------------------------------------------
// Function:    vdprintf
//
// Synopsis:    Prints debug output using a pointer to the
//              variable information. Used primarily by the
//              xxDebugOut macros
//
// Arguments:
//      ulCompMask --   Component level mask used to determine
//                      output ability
//      pszComp    --   String const of component prefix.
//      ppszfmt    --   Pointer to output format and data
//
//-------------------------------------------------------------

void APINOT
vdprintf(
    unsigned long ulCompMask,
    char const   *pszComp,
    char const   *ppszfmt,
    va_list       pargs
    )
{

    if ((ulCompMask & DEB_FORCE) == DEB_FORCE ||
        ((ulCompMask | Win4InfoLevel) & Win4InfoMask))
    {
        EnterCriticalSection(&g_csDP);
        DWORD tid = GetCurrentThreadId();
        if ((Win4InfoLevel & (DEB_DBGOUT | DEB_STDOUT)) != DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4dprintf( "%03d> ", tid );
                w4dprintf("%s: ", pszComp);
            }
            w4vdprintf(ppszfmt, pargs);
        }

        if (Win4InfoLevel & DEB_STDOUT)
        {
            if (! (ulCompMask & DEB_NOCOMPNAME))
            {
                w4printf( "%03d> ", tid );
                w4printf("%s: ", pszComp);
            }
            w4vprintf(ppszfmt, pargs);
        }

        LeaveCriticalSection(&g_csDP);
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   _asdprintf
//
//  Synopsis:   Calls vdprintf to output a formatted message.
//
//  History:    18-Oct-91   vich Created
//
//----------------------------------------------------------------------------
inline void __cdecl
_asdprintf(
    char const *pszfmt, ...)
{
    va_list va;
    va_start(va, pszfmt);

    vdprintf(DEB_FORCE, "Assert", pszfmt, va);

    va_end(va);
}

//+------------------------------------------------------------
// Function:    PopUpError
//
// Synopsis:    Displays a dialog box using provided text,
//              and presents the user with the option to
//              continue or cancel.
//
// Arguments:
//      szMsg --        The string to display in main body of dialog
//      iLine --        Line number of file in error
//      szFile --       Filename of file in error
//
// Returns:
//      IDCANCEL --     User selected the CANCEL button
//      IDOK     --     User selected the OK button
//-------------------------------------------------------------

int APINOT
PopUpError(
    char const *szMsg,
    int iLine,
    char const *szFile
    )
{

    int id;
    static char szAssertCaption[100];

    DWORD tid = GetCurrentThreadId();

    sprintf(szAssertCaption,"File: %s line %u, thread id %d",
        szFile, iLine, tid);

    id = MessageBoxA(
                NULL,
                (char *) szMsg,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                );

    return id;
}


//+---------------------------------------------------------------------------
//
//  Function:   _Win4Assert, private
//
//  Synopsis:   Display assertion information
//
//  Effects:    Called when an assertion is hit.
//
//  History:
//
//----------------------------------------------------------------------------


void APINOT
Win4AssertEx(
    char const * szFile,
    int iLine,
    char const * szMessage
    )
{

    if (Win4AssertLevel & ASSRT_MESSAGE)
    {
        DWORD tid = GetCurrentThreadId();

        _asdprintf("%s File: %s Line: %u, thread id %d\n",
                   szMessage, szFile, iLine, tid);
    }

    if (Win4AssertLevel & ASSRT_POPUP)
    {
        int id = PopUpError(szMessage,iLine,szFile);

        if (id == IDCANCEL)
        {
            DebugBreak();
        }
    }
    else if (Win4AssertLevel & ASSRT_BREAK)
    {
        DebugBreak();
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\oledserr.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    oledserr.h

Abstract:

    Contains the entry point for
        ADsGetLastError
        ADsSetLastError
        ADsFreeAllErrorRecords

Author:


    Ram Viswanathan (ramv) 20-Sep-1996

Environment:

    User Mode - Win32


---*/

#ifndef _OLEDSERR_H_INCLUDED_
#define _OLEDSERR_H_INCLUDED_

#ifdef _cplusplus
extern "C" {
#endif

HRESULT
ADsGetLastError(
    OUT     LPDWORD lpError,
    OUT     LPWSTR  lpErrorBuf,
    IN      DWORD   dwErrorBufLen,
    OUT     LPWSTR  lpNameBuf,
    IN      DWORD   dwNameBufLen
    );

VOID
ADsSetLastError(
    IN  DWORD   dwErr,
    IN  LPCWSTR  pszError,
    IN  LPCWSTR  pszProvider
    );

VOID
ADsFreeAllErrorRecords(
    VOID
    );

//=======================
// Data Structures
//=======================

typedef struct _ERROR_RECORD {
    struct  _ERROR_RECORD   *Prev;
    struct  _ERROR_RECORD   *Next;
    DWORD                   dwThreadId;
    DWORD                   dwErrorCode;
    LPWSTR                  pszErrorText;      // This is an allocated buffer
    LPWSTR                  pszProviderName;   // This is an allocated buffer
} ERROR_RECORD, *LPERROR_RECORD;



//
// Global Data Structures
//

extern
ERROR_RECORD        ADsErrorRecList;    // Initialized to zeros by loader

extern
CRITICAL_SECTION    ADsErrorRecCritSec; // Initialized in libmain.cxx



//=======================
// MACROS
//=======================

#define FIND_END_OF_LIST(record)    while(record->Next != NULL) {   \
                                        record=record->Next;        \
                                    }

#define REMOVE_FROM_LIST(record)    record->Prev->Next = record->Next;      \
                                    if (record->Next != NULL) {             \
                                        record->Next->Prev = record->Prev;  \
                                    }

#define ADD_TO_LIST(record, newRec) FIND_END_OF_LIST(record)    \
                                    record->Next = newRec;      \
                                    newRec->Prev = record;      \
                                    newRec->Next = NULL;


//
// Local Functions
//

LPERROR_RECORD
ADsAllocErrorRecord(
    VOID);

LPERROR_RECORD
ADsFindErrorRecord(
    VOID);

VOID
ADsFreeThreadErrorRecords(
    VOID);

#ifdef _cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\umi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0328 */
/* Compiler settings for umi.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __umi_h__
#define __umi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IUmiPropList_FWD_DEFINED__
#define __IUmiPropList_FWD_DEFINED__
typedef interface IUmiPropList IUmiPropList;
#endif 	/* __IUmiPropList_FWD_DEFINED__ */


#ifndef __IUmiBaseObject_FWD_DEFINED__
#define __IUmiBaseObject_FWD_DEFINED__
typedef interface IUmiBaseObject IUmiBaseObject;
#endif 	/* __IUmiBaseObject_FWD_DEFINED__ */


#ifndef __IUmiObject_FWD_DEFINED__
#define __IUmiObject_FWD_DEFINED__
typedef interface IUmiObject IUmiObject;
#endif 	/* __IUmiObject_FWD_DEFINED__ */


#ifndef __IUmiConnection_FWD_DEFINED__
#define __IUmiConnection_FWD_DEFINED__
typedef interface IUmiConnection IUmiConnection;
#endif 	/* __IUmiConnection_FWD_DEFINED__ */


#ifndef __IUmiContainer_FWD_DEFINED__
#define __IUmiContainer_FWD_DEFINED__
typedef interface IUmiContainer IUmiContainer;
#endif 	/* __IUmiContainer_FWD_DEFINED__ */


#ifndef __IUmiCursor_FWD_DEFINED__
#define __IUmiCursor_FWD_DEFINED__
typedef interface IUmiCursor IUmiCursor;
#endif 	/* __IUmiCursor_FWD_DEFINED__ */


#ifndef __IUmiObjectSink_FWD_DEFINED__
#define __IUmiObjectSink_FWD_DEFINED__
typedef interface IUmiObjectSink IUmiObjectSink;
#endif 	/* __IUmiObjectSink_FWD_DEFINED__ */


#ifndef __IUmiURLKeyList_FWD_DEFINED__
#define __IUmiURLKeyList_FWD_DEFINED__
typedef interface IUmiURLKeyList IUmiURLKeyList;
#endif 	/* __IUmiURLKeyList_FWD_DEFINED__ */


#ifndef __IUmiURL_FWD_DEFINED__
#define __IUmiURL_FWD_DEFINED__
typedef interface IUmiURL IUmiURL;
#endif 	/* __IUmiURL_FWD_DEFINED__ */


#ifndef __IUmiQuery_FWD_DEFINED__
#define __IUmiQuery_FWD_DEFINED__
typedef interface IUmiQuery IUmiQuery;
#endif 	/* __IUmiQuery_FWD_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_FWD_DEFINED__
#define __IUmiCustomInterfaceFactory_FWD_DEFINED__
typedef interface IUmiCustomInterfaceFactory IUmiCustomInterfaceFactory;
#endif 	/* __IUmiCustomInterfaceFactory_FWD_DEFINED__ */


#ifndef __UmiDefURL_FWD_DEFINED__
#define __UmiDefURL_FWD_DEFINED__

#ifdef __cplusplus
typedef class UmiDefURL UmiDefURL;
#else
typedef struct UmiDefURL UmiDefURL;
#endif /* __cplusplus */

#endif 	/* __UmiDefURL_FWD_DEFINED__ */


#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __UMI_V6_LIBRARY_DEFINED__
#define __UMI_V6_LIBRARY_DEFINED__

/* library UMI_V6 */
/* [uuid] */ 












typedef 
enum tag_UMI_TYPE_ENUMERATION
    {	UMI_TYPE_NULL	= 0,
	UMI_TYPE_I1	= 1,
	UMI_TYPE_I2	= 2,
	UMI_TYPE_I4	= 3,
	UMI_TYPE_I8	= 4,
	UMI_TYPE_UI1	= 5,
	UMI_TYPE_UI2	= 6,
	UMI_TYPE_UI4	= 7,
	UMI_TYPE_UI8	= 8,
	UMI_TYPE_R4	= 9,
	UMI_TYPE_R8	= 10,
	UMI_TYPE_FILETIME	= 12,
	UMI_TYPE_SYSTEMTIME	= 13,
	UMI_TYPE_BOOL	= 14,
	UMI_TYPE_IDISPATCH	= 15,
	UMI_TYPE_IUNKNOWN	= 16,
	UMI_TYPE_VARIANT	= 17,
	UMI_TYPE_LPWSTR	= 20,
	UMI_TYPE_OCTETSTRING	= 21,
	UMI_TYPE_UMIARRAY	= 22,
	UMI_TYPE_DISCOVERY	= 23,
	UMI_TYPE_UNDEFINED	= 24,
	UMI_TYPE_DEFAULT	= 25,
	UMI_TYPE_ARRAY_FLAG	= 0x2000
    } 	UMI_TYPE_ENUMERATION;

typedef ULONG UMI_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0001
    {	UMI_GENUS_CLASS	= 1,
	UMI_GENUS_INSTANCE	= 2
    } 	UMI_GENUS_TYPE;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0002
    {	UMI_DONT_COMMIT_SECURITY_DESCRIPTOR	= 0x10
    } 	UMI_COMMIT_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0003
    {	UMI_FLAG_GETPROPS_ALL	= 1,
	UMI_FLAG_GETPROPS_SCHEMA	= 0x2,
	UMI_MASK_GETPROPS_PROP	= 0xff,
	UMI_FLAG_GETPROPS_NAMES	= 0x100,
	UMI_MASK_GETPROPS_EXT	= 0x100
    } 	UMI_GETPROPS_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0004
    {	UMI_FLAG_OWNER_SECURITY_INFORMATION	= 0x1,
	UMI_FLAG_GROUP_SECURITY_INFORMATION	= 0x2,
	UMI_FLAG_DACL_SECURITY_INFORMATION	= 0x4,
	UMI_FLAG_SACL_SECURITY_INFORMATION	= 0x8,
	UMI_SECURITY_MASK	= 0xf,
	UMI_FLAG_PROVIDER_CACHE	= 0x10,
	UMI_FLAG_PROPERTY_ORIGIN	= 0x20
    } 	UMI_GET_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0005
    {	UMI_FLAG_REFRESH_ALL	= 0,
	UMI_FLAG_REFRESH_PARTIAL	= 1
    } 	UMI_REFRESH_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0006
    {	UMI_OPERATION_NONE	= 0,
	UMI_OPERATION_APPEND	= 1,
	UMI_OPERATION_UPDATE	= 2,
	UMI_OPERATION_EMPTY	= 3,
	UMI_OPERATION_INSERT_AT	= 4,
	UMI_OPERATION_REMOVE_AT	= 5,
	UMI_OPERATION_DELETE_AT	= 6,
	UMI_OPERATION_DELETE_FIRST_MATCH	= 7,
	UMI_OPERATION_DELETE_ALL_MATCHES	= 8,
	UMI_OPERATION_RESTORE_DEFAULT	= 9
    } 	UMI_PROP_INSTRUCTION;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0007
    {	UMI_OPERATION_INSTANCE	= 0x1000,
	UMI_OPERATION_CLASS	= 0x2000
    } 	UMI_OPERATION_PATH;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0008
    {	UMIPATH_CREATE_AS_NATIVE	= 0x8000,
	UMIPATH_CREATE_AS_EITHER	= 0x4000,
	UMIPATH_CREATE_ACCEPT_RELATIVE	= 0x4
    } 	tag_UMI_PATH_CREATE_FLAG;

typedef 
enum tag_WMI_PATH_STATUS_FLAG
    {	UMIPATH_INFO_NATIVE_STRING	= 0x1,
	UMIPATH_INFO_RELATIVE_PATH	= 0x2,
	UMIPATH_INFO_INSTANCE_PATH	= 0x4,
	UMIPATH_INFO_CLASS_PATH	= 0x8,
	UMIPATH_INFO_SINGLETON_PATH	= 0x10
    } 	tag_UMI_PATH_STATUS_FLAG;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_umi_0000_0009
    {	UMI_S_NO_ERROR	= 0,
	UMI_E_CONNECTION_FAILURE	= 0x80041001,
	UMI_E_TIMED_OUT	= 0x80041002,
	UMI_E_TYPE_MISMATCH	= 0x80041003,
	UMI_E_NOT_FOUND	= 0x80041004,
	UMI_E_INVALID_FLAGS	= 0x80041005,
	UMI_E_UNSUPPORTED_FLAGS	= 0x80041006,
	UMI_E_SYNCHRONIZATION_REQUIRED	= 0x80041007,
	UMI_E_UNSUPPORTED_OPERATION	= 0x80041008,
	UMI_E_TRANSACTION_FAILURE	= 0x80041009,
	UMI_E_UNBOUND_OBJECT	= 0x8004100a
    } 	UMI_STATUS;

typedef struct tag_UMI_OCTET_STRING
    {
    ULONG uLength;
    byte __RPC_FAR *lpValue;
    } 	UMI_OCTET_STRING;

typedef struct tag_UMI_OCTET_STRING __RPC_FAR *PUMI_OCTET_STRING;

typedef struct tag_UMI_COM_OBJECT
    {
    IID __RPC_FAR *priid;
    LPVOID pInterface;
    } 	UMI_COM_OBJECT;

typedef struct tag_UMI_COM_OBJECT __RPC_FAR *PUMI_COM_OBJECT;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ union __MIDL___MIDL_itf_umi_0000_0010
    {
    CHAR cValue[ 1 ];
    UCHAR ucValue[ 1 ];
    WCHAR wcValue[ 1 ];
    WORD wValue[ 1 ];
    DWORD dwValue[ 1 ];
    LONG lValue[ 1 ];
    ULONG uValue[ 1 ];
    BYTE byteValue[ 1 ];
    BOOL bValue[ 1 ];
    LPWSTR pszStrValue[ 1 ];
    FILETIME fileTimeValue[ 1 ];
    SYSTEMTIME sysTimeValue[ 1 ];
    double dblValue[ 1 ];
    unsigned __int64 uValue64[ 1 ];
    __int64 nValue64[ 1 ];
    UMI_OCTET_STRING octetStr[ 1 ];
    UMI_COM_OBJECT comObject[ 1 ];
    } 	UMI_VALUE;

typedef union __MIDL___MIDL_itf_umi_0000_0010 __RPC_FAR *PUMI_VALUE;

typedef /* [public][public][public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0011
    {
    UMI_TYPE uType;
    ULONG uCount;
    ULONG uOperationType;
    LPWSTR pszPropertyName;
    UMI_VALUE __RPC_FAR *pUmiValue;
    } 	UMI_PROPERTY;

typedef struct __MIDL___MIDL_itf_umi_0000_0011 __RPC_FAR *PUMI_PROPERTY;

typedef /* [public][public][public][public][public][public] */ struct __MIDL___MIDL_itf_umi_0000_0012
    {
    ULONG uCount;
    UMI_PROPERTY __RPC_FAR *pPropArray;
    } 	UMI_PROPERTY_VALUES;

typedef struct __MIDL___MIDL_itf_umi_0000_0012 __RPC_FAR *PUMI_PROPERTY_VALUES;


EXTERN_C const IID LIBID_UMI_V6;

#ifndef __IUmiPropList_INTERFACE_DEFINED__
#define __IUmiPropList_INTERFACE_DEFINED__

/* interface IUmiPropList */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiPropList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7b-d9db-11d3-a11f-00105a1f515a")
    IUmiPropList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAt( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAs( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FreeMemory( 
            ULONG uReserved,
            LPVOID pMem) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Delete( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutProps( 
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutFrom( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiPropListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiPropList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiPropList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiPropList __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiPropList __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        END_INTERFACE
    } IUmiPropListVtbl;

    interface IUmiPropList
    {
        CONST_VTBL struct IUmiPropListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiPropList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiPropList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiPropList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiPropList_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiPropList_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiPropList_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiPropList_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiPropList_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiPropList_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiPropList_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiPropList_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiPropList_Put_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Get_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAt_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [out] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_GetAt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetAs_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uCoercionType,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);


void __RPC_STUB IUmiPropList_GetAs_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_FreeMemory_Proxy( 
    IUmiPropList __RPC_FAR * This,
    ULONG uReserved,
    LPVOID pMem);


void __RPC_STUB IUmiPropList_FreeMemory_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_Delete_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiPropList_Delete_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_GetProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_GetProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutProps_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR __RPC_FAR *pszNames,
    /* [in] */ ULONG uNameCount,
    /* [in] */ ULONG uFlags,
    /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);


void __RPC_STUB IUmiPropList_PutProps_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiPropList_PutFrom_Proxy( 
    IUmiPropList __RPC_FAR * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uBufferLength,
    /* [in] */ LPVOID pExistingMem);


void __RPC_STUB IUmiPropList_PutFrom_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiPropList_INTERFACE_DEFINED__ */


#ifndef __IUmiBaseObject_INTERFACE_DEFINED__
#define __IUmiBaseObject_INTERFACE_DEFINED__

/* interface IUmiBaseObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiBaseObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7c-d9db-11d3-a11f-00105a1f515a")
    IUmiBaseObject : public IUmiPropList
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetLastStatus( 
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetInterfacePropList( 
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiBaseObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiBaseObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiBaseObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiBaseObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiBaseObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        END_INTERFACE
    } IUmiBaseObjectVtbl;

    interface IUmiBaseObject
    {
        CONST_VTBL struct IUmiBaseObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiBaseObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiBaseObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiBaseObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiBaseObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiBaseObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiBaseObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiBaseObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiBaseObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiBaseObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiBaseObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiBaseObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiBaseObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiBaseObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetLastStatus_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);


void __RPC_STUB IUmiBaseObject_GetLastStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiBaseObject_GetInterfacePropList_Proxy( 
    IUmiBaseObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);


void __RPC_STUB IUmiBaseObject_GetInterfacePropList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiBaseObject_INTERFACE_DEFINED__ */


#ifndef __IUmiObject_INTERFACE_DEFINED__
#define __IUmiObject_INTERFACE_DEFINED__

/* interface IUmiObject */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObject;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee23-64a4-11d3-a0da-00105a1f515a")
    IUmiObject : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CopyTo( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Refresh( 
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Commit( 
            /* [in] */ ULONG uFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiObject __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiObject __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        END_INTERFACE
    } IUmiObjectVtbl;

    interface IUmiObject
    {
        CONST_VTBL struct IUmiObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObject_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiObject_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiObject_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiObject_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiObject_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiObject_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiObject_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiObject_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiObject_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiObject_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiObject_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiObject_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiObject_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiObject_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObject_Clone_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_CopyTo_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);


void __RPC_STUB IUmiObject_CopyTo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Refresh_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ ULONG uNameCount,
    /* [in] */ LPWSTR __RPC_FAR *pszNames);


void __RPC_STUB IUmiObject_Refresh_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObject_Commit_Proxy( 
    IUmiObject __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiObject_Commit_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObject_INTERFACE_DEFINED__ */


#ifndef __IUmiConnection_INTERFACE_DEFINED__
#define __IUmiConnection_INTERFACE_DEFINED__

/* interface IUmiConnection */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee20-64a4-11d3-a0da-00105a1f515a")
    IUmiConnection : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiConnection __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiConnection __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiConnection __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiConnection __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        END_INTERFACE
    } IUmiConnectionVtbl;

    interface IUmiConnection
    {
        CONST_VTBL struct IUmiConnectionVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiConnection_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiConnection_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiConnection_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiConnection_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiConnection_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiConnection_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiConnection_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiConnection_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiConnection_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiConnection_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiConnection_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiConnection_Open_Proxy( 
    IUmiConnection __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiConnection_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiConnection_INTERFACE_DEFINED__ */


#ifndef __IUmiContainer_INTERFACE_DEFINED__
#define __IUmiContainer_INTERFACE_DEFINED__

/* interface IUmiContainer */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiContainer;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee21-64a4-11d3-a0da-00105a1f515a")
    IUmiContainer : public IUmiObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Open( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PutObject( 
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteObject( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Create( 
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Move( 
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateEnum( 
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ExecQuery( 
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiContainerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiContainer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiContainer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiContainer __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CopyTo )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pCopy);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Refresh )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uNameCount,
            /* [in] */ LPWSTR __RPC_FAR *pszNames);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Commit )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Open )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out][in] */ void __RPC_FAR *pObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteObject )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [optional][in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Create )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pURL,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Move )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUmiURL __RPC_FAR *pOldURL,
            /* [in] */ IUmiURL __RPC_FAR *pNewURL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateEnum )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ExecQuery )( 
            IUmiContainer __RPC_FAR * This,
            /* [in] */ IUmiQuery __RPC_FAR *pQuery,
            /* [in] */ ULONG uFlags,
            /* [in] */ REFIID TargetIID,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);
        
        END_INTERFACE
    } IUmiContainerVtbl;

    interface IUmiContainer
    {
        CONST_VTBL struct IUmiContainerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiContainer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiContainer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiContainer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiContainer_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiContainer_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiContainer_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiContainer_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiContainer_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiContainer_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiContainer_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiContainer_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiContainer_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiContainer_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiContainer_Clone(This,uFlags,riid,pCopy)	\
    (This)->lpVtbl -> Clone(This,uFlags,riid,pCopy)

#define IUmiContainer_CopyTo(This,uFlags,pURL,riid,pCopy)	\
    (This)->lpVtbl -> CopyTo(This,uFlags,pURL,riid,pCopy)

#define IUmiContainer_Refresh(This,uFlags,uNameCount,pszNames)	\
    (This)->lpVtbl -> Refresh(This,uFlags,uNameCount,pszNames)

#define IUmiContainer_Commit(This,uFlags)	\
    (This)->lpVtbl -> Commit(This,uFlags)


#define IUmiContainer_Open(This,pURL,uFlags,TargetIID,ppvRes)	\
    (This)->lpVtbl -> Open(This,pURL,uFlags,TargetIID,ppvRes)

#define IUmiContainer_PutObject(This,uFlags,TargetIID,pObj)	\
    (This)->lpVtbl -> PutObject(This,uFlags,TargetIID,pObj)

#define IUmiContainer_DeleteObject(This,pURL,uFlags)	\
    (This)->lpVtbl -> DeleteObject(This,pURL,uFlags)

#define IUmiContainer_Create(This,pURL,uFlags,pNewObj)	\
    (This)->lpVtbl -> Create(This,pURL,uFlags,pNewObj)

#define IUmiContainer_Move(This,uFlags,pOldURL,pNewURL)	\
    (This)->lpVtbl -> Move(This,uFlags,pOldURL,pNewURL)

#define IUmiContainer_CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)	\
    (This)->lpVtbl -> CreateEnum(This,pszEnumContext,uFlags,TargetIID,ppvEnum)

#define IUmiContainer_ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)	\
    (This)->lpVtbl -> ExecQuery(This,pQuery,uFlags,TargetIID,ppResult)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiContainer_Open_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvRes);


void __RPC_STUB IUmiContainer_Open_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_PutObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out][in] */ void __RPC_FAR *pObj);


void __RPC_STUB IUmiContainer_PutObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_DeleteObject_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [optional][in] */ ULONG uFlags);


void __RPC_STUB IUmiContainer_DeleteObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Create_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pURL,
    /* [in] */ ULONG uFlags,
    /* [out] */ IUmiObject __RPC_FAR *__RPC_FAR *pNewObj);


void __RPC_STUB IUmiContainer_Create_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_Move_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUmiURL __RPC_FAR *pOldURL,
    /* [in] */ IUmiURL __RPC_FAR *pNewURL);


void __RPC_STUB IUmiContainer_Move_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_CreateEnum_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiURL __RPC_FAR *pszEnumContext,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvEnum);


void __RPC_STUB IUmiContainer_CreateEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiContainer_ExecQuery_Proxy( 
    IUmiContainer __RPC_FAR * This,
    /* [in] */ IUmiQuery __RPC_FAR *pQuery,
    /* [in] */ ULONG uFlags,
    /* [in] */ REFIID TargetIID,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppResult);


void __RPC_STUB IUmiContainer_ExecQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiContainer_INTERFACE_DEFINED__ */


#ifndef __IUmiCursor_INTERFACE_DEFINED__
#define __IUmiCursor_INTERFACE_DEFINED__

/* interface IUmiCursor */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCursor;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee26-64a4-11d3-a0da-00105a1f515a")
    IUmiCursor : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetIID( 
            /* [in] */ REFIID riid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Count( 
            /* [out] */ ULONG __RPC_FAR *puNumObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Previous( 
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCursorVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCursor __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiCursor __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetIID )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ REFIID riid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IUmiCursor __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uNumRequested,
            /* [out] */ ULONG __RPC_FAR *puNumReturned,
            /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Count )( 
            IUmiCursor __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puNumObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Previous )( 
            IUmiCursor __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ LPVOID __RPC_FAR *pObj);
        
        END_INTERFACE
    } IUmiCursorVtbl;

    interface IUmiCursor
    {
        CONST_VTBL struct IUmiCursorVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCursor_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCursor_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCursor_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCursor_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiCursor_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiCursor_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiCursor_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiCursor_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiCursor_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiCursor_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiCursor_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiCursor_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiCursor_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiCursor_SetIID(This,riid)	\
    (This)->lpVtbl -> SetIID(This,riid)

#define IUmiCursor_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IUmiCursor_Next(This,uNumRequested,puNumReturned,pObjects)	\
    (This)->lpVtbl -> Next(This,uNumRequested,puNumReturned,pObjects)

#define IUmiCursor_Count(This,puNumObjects)	\
    (This)->lpVtbl -> Count(This,puNumObjects)

#define IUmiCursor_Previous(This,uFlags,pObj)	\
    (This)->lpVtbl -> Previous(This,uFlags,pObj)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCursor_SetIID_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ REFIID riid);


void __RPC_STUB IUmiCursor_SetIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Reset_Proxy( 
    IUmiCursor __RPC_FAR * This);


void __RPC_STUB IUmiCursor_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Next_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uNumRequested,
    /* [out] */ ULONG __RPC_FAR *puNumReturned,
    /* [length_is][size_is][out] */ LPVOID __RPC_FAR *pObjects);


void __RPC_STUB IUmiCursor_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Count_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puNumObjects);


void __RPC_STUB IUmiCursor_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCursor_Previous_Proxy( 
    IUmiCursor __RPC_FAR * This,
    /* [in] */ ULONG uFlags,
    /* [out] */ LPVOID __RPC_FAR *pObj);


void __RPC_STUB IUmiCursor_Previous_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCursor_INTERFACE_DEFINED__ */


#ifndef __IUmiObjectSink_INTERFACE_DEFINED__
#define __IUmiObjectSink_INTERFACE_DEFINED__

/* interface IUmiObjectSink */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiObjectSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5ed7ee24-64a4-11d3-a0da-00105a1f515a")
    IUmiObjectSink : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetResult( 
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiObjectSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiObjectSink __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiObjectSink __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ LONG lNumObjects,
            /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetResult )( 
            IUmiObjectSink __RPC_FAR * This,
            /* [in] */ HRESULT hResStatus,
            /* [in] */ ULONG uFlags,
            /* [in] */ IUnknown __RPC_FAR *pObject);
        
        END_INTERFACE
    } IUmiObjectSinkVtbl;

    interface IUmiObjectSink
    {
        CONST_VTBL struct IUmiObjectSinkVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiObjectSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiObjectSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiObjectSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiObjectSink_Put(This,lNumObjects,ppObjects)	\
    (This)->lpVtbl -> Put(This,lNumObjects,ppObjects)

#define IUmiObjectSink_SetResult(This,hResStatus,uFlags,pObject)	\
    (This)->lpVtbl -> SetResult(This,hResStatus,uFlags,pObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiObjectSink_Put_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ LONG lNumObjects,
    /* [size_is][in] */ IUmiObject __RPC_FAR *__RPC_FAR *ppObjects);


void __RPC_STUB IUmiObjectSink_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiObjectSink_SetResult_Proxy( 
    IUmiObjectSink __RPC_FAR * This,
    /* [in] */ HRESULT hResStatus,
    /* [in] */ ULONG uFlags,
    /* [in] */ IUnknown __RPC_FAR *pObject);


void __RPC_STUB IUmiObjectSink_SetResult_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiObjectSink_INTERFACE_DEFINED__ */


#ifndef __IUmiURLKeyList_INTERFACE_DEFINED__
#define __IUmiURLKeyList_INTERFACE_DEFINED__

/* interface IUmiURLKeyList */
/* [uuid][object][local] */ 


EXTERN_C const IID IID_IUmiURLKeyList;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("cf779c98-4739-4fd4-a415-da937a599f2f")
    IUmiURLKeyList : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *puKeyCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKey( 
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveKey( 
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllKeys( 
            /* [in] */ ULONG uFlags) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeysInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLKeyListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURLKeyList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puKeyCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [string][in] */ LPCWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uKeyIx,
            /* [in] */ ULONG uFlags,
            /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
            /* [in] */ LPWSTR pszKeyName,
            /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
            /* [in] */ LPWSTR pszValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveKey )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [string][in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllKeys )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeysInfo )( 
            IUmiURLKeyList __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        END_INTERFACE
    } IUmiURLKeyListVtbl;

    interface IUmiURLKeyList
    {
        CONST_VTBL struct IUmiURLKeyListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURLKeyList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURLKeyList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURLKeyList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURLKeyList_GetCount(This,puKeyCount)	\
    (This)->lpVtbl -> GetCount(This,puKeyCount)

#define IUmiURLKeyList_SetKey(This,pszName,pszValue)	\
    (This)->lpVtbl -> SetKey(This,pszName,pszValue)

#define IUmiURLKeyList_GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)	\
    (This)->lpVtbl -> GetKey(This,uKeyIx,uFlags,puKeyNameBufSize,pszKeyName,puValueBufSize,pszValue)

#define IUmiURLKeyList_RemoveKey(This,pszName,uFlags)	\
    (This)->lpVtbl -> RemoveKey(This,pszName,uFlags)

#define IUmiURLKeyList_RemoveAllKeys(This,uFlags)	\
    (This)->lpVtbl -> RemoveAllKeys(This,uFlags)

#define IUmiURLKeyList_GetKeysInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetKeysInfo(This,uRequestedInfo,puResponse)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetCount_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puKeyCount);


void __RPC_STUB IUmiURLKeyList_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_SetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [string][in] */ LPCWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_SetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uKeyIx,
    /* [in] */ ULONG uFlags,
    /* [out][in] */ ULONG __RPC_FAR *puKeyNameBufSize,
    /* [in] */ LPWSTR pszKeyName,
    /* [out][in] */ ULONG __RPC_FAR *puValueBufSize,
    /* [in] */ LPWSTR pszValue);


void __RPC_STUB IUmiURLKeyList_GetKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveKey_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [string][in] */ LPCWSTR pszName,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_RemoveAllKeys_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uFlags);


void __RPC_STUB IUmiURLKeyList_RemoveAllKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURLKeyList_GetKeysInfo_Proxy( 
    IUmiURLKeyList __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURLKeyList_GetKeysInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURLKeyList_INTERFACE_DEFINED__ */


#ifndef __IUmiURL_INTERFACE_DEFINED__
#define __IUmiURL_INTERFACE_DEFINED__

/* interface IUmiURL */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiURL;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7d-d9db-11d3-a11f-00105a1f515a")
    IUmiURL : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPathInfo( 
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLocator( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLocator( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetRootNamespace( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRootNamespace( 
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentCount( 
            /* [out] */ ULONG __RPC_FAR *puCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponent( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetComponentFromText( 
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponent( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetComponentAsText( 
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveComponent( 
            /* [in] */ ULONG uIndex) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RemoveAllComponents( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetLeafName( 
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLeafName( 
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetKeyList( 
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateLeafPart( 
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DeleteLeafPart( 
            /* [in] */ long lFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiURLVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiURL __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [out][in] */ ULONG __RPC_FAR *puBufSize,
            /* [string][in] */ LPWSTR pszDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPathInfo )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uRequestedInfo,
            /* [out] */ ULONGLONG __RPC_FAR *puResponse);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLocator )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRootNamespace )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
            /* [string][out][in] */ LPWSTR pName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentCount )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *puCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszClass);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetComponentFromText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
            /* [out][in] */ LPWSTR pszClass,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetComponentAsText )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex,
            /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
            /* [out][in] */ LPWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveComponent )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ ULONG uIndex);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RemoveAllComponents )( 
            IUmiURL __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLeafName )( 
            IUmiURL __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
            /* [string][out][in] */ LPWSTR pszName);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetKeyList )( 
            IUmiURL __RPC_FAR * This,
            /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags,
            /* [string][in] */ LPCWSTR Name);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DeleteLeafPart )( 
            IUmiURL __RPC_FAR * This,
            /* [in] */ long lFlags);
        
        END_INTERFACE
    } IUmiURLVtbl;

    interface IUmiURL
    {
        CONST_VTBL struct IUmiURLVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiURL_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiURL_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiURL_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiURL_Set(This,lFlags,pszText)	\
    (This)->lpVtbl -> Set(This,lFlags,pszText)

#define IUmiURL_Get(This,lFlags,puBufSize,pszDest)	\
    (This)->lpVtbl -> Get(This,lFlags,puBufSize,pszDest)

#define IUmiURL_GetPathInfo(This,uRequestedInfo,puResponse)	\
    (This)->lpVtbl -> GetPathInfo(This,uRequestedInfo,puResponse)

#define IUmiURL_SetLocator(This,Name)	\
    (This)->lpVtbl -> SetLocator(This,Name)

#define IUmiURL_GetLocator(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetLocator(This,puNameBufLength,pName)

#define IUmiURL_SetRootNamespace(This,Name)	\
    (This)->lpVtbl -> SetRootNamespace(This,Name)

#define IUmiURL_GetRootNamespace(This,puNameBufLength,pName)	\
    (This)->lpVtbl -> GetRootNamespace(This,puNameBufLength,pName)

#define IUmiURL_GetComponentCount(This,puCount)	\
    (This)->lpVtbl -> GetComponentCount(This,puCount)

#define IUmiURL_SetComponent(This,uIndex,pszClass)	\
    (This)->lpVtbl -> SetComponent(This,uIndex,pszClass)

#define IUmiURL_SetComponentFromText(This,uIndex,pszText)	\
    (This)->lpVtbl -> SetComponentFromText(This,uIndex,pszText)

#define IUmiURL_GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)	\
    (This)->lpVtbl -> GetComponent(This,uIndex,puClassNameBufSize,pszClass,pKeyList)

#define IUmiURL_GetComponentAsText(This,uIndex,puTextBufSize,pszText)	\
    (This)->lpVtbl -> GetComponentAsText(This,uIndex,puTextBufSize,pszText)

#define IUmiURL_RemoveComponent(This,uIndex)	\
    (This)->lpVtbl -> RemoveComponent(This,uIndex)

#define IUmiURL_RemoveAllComponents(This)	\
    (This)->lpVtbl -> RemoveAllComponents(This)

#define IUmiURL_SetLeafName(This,Name)	\
    (This)->lpVtbl -> SetLeafName(This,Name)

#define IUmiURL_GetLeafName(This,puBuffLength,pszName)	\
    (This)->lpVtbl -> GetLeafName(This,puBuffLength,pszName)

#define IUmiURL_GetKeyList(This,pOut)	\
    (This)->lpVtbl -> GetKeyList(This,pOut)

#define IUmiURL_CreateLeafPart(This,lFlags,Name)	\
    (This)->lpVtbl -> CreateLeafPart(This,lFlags,Name)

#define IUmiURL_DeleteLeafPart(This,lFlags)	\
    (This)->lpVtbl -> DeleteLeafPart(This,lFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiURL_Set_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiURL_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_Get_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [out][in] */ ULONG __RPC_FAR *puBufSize,
    /* [string][in] */ LPWSTR pszDest);


void __RPC_STUB IUmiURL_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetPathInfo_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uRequestedInfo,
    /* [out] */ ULONGLONG __RPC_FAR *puResponse);


void __RPC_STUB IUmiURL_GetPathInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLocator_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetLocator_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetRootNamespace_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puNameBufLength,
    /* [string][out][in] */ LPWSTR pName);


void __RPC_STUB IUmiURL_GetRootNamespace_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentCount_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *puCount);


void __RPC_STUB IUmiURL_GetComponentCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszClass);


void __RPC_STUB IUmiURL_SetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetComponentFromText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_SetComponentFromText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puClassNameBufSize,
    /* [out][in] */ LPWSTR pszClass,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pKeyList);


void __RPC_STUB IUmiURL_GetComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetComponentAsText_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex,
    /* [out][in] */ ULONG __RPC_FAR *puTextBufSize,
    /* [out][in] */ LPWSTR pszText);


void __RPC_STUB IUmiURL_GetComponentAsText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveComponent_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ ULONG uIndex);


void __RPC_STUB IUmiURL_RemoveComponent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_RemoveAllComponents_Proxy( 
    IUmiURL __RPC_FAR * This);


void __RPC_STUB IUmiURL_RemoveAllComponents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_SetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_SetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetLeafName_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puBuffLength,
    /* [string][out][in] */ LPWSTR pszName);


void __RPC_STUB IUmiURL_GetLeafName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_GetKeyList_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [out] */ IUmiURLKeyList __RPC_FAR *__RPC_FAR *pOut);


void __RPC_STUB IUmiURL_GetKeyList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_CreateLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags,
    /* [string][in] */ LPCWSTR Name);


void __RPC_STUB IUmiURL_CreateLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiURL_DeleteLeafPart_Proxy( 
    IUmiURL __RPC_FAR * This,
    /* [in] */ long lFlags);


void __RPC_STUB IUmiURL_DeleteLeafPart_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiURL_INTERFACE_DEFINED__ */


#ifndef __IUmiQuery_INTERFACE_DEFINED__
#define __IUmiQuery_INTERFACE_DEFINED__

/* interface IUmiQuery */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiQuery;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("12575a7e-d9db-11d3-a11f-00105a1f515a")
    IUmiQuery : public IUmiBaseObject
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQuery( 
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiQueryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiQuery __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiQuery __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Put )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Get )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAt )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [out] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAs )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uCoercionType,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FreeMemory )( 
            IUmiQuery __RPC_FAR * This,
            ULONG uReserved,
            LPVOID pMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Delete )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [out] */ UMI_PROPERTY_VALUES __RPC_FAR *__RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutProps )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR __RPC_FAR *pszNames,
            /* [in] */ ULONG uNameCount,
            /* [in] */ ULONG uFlags,
            /* [in] */ UMI_PROPERTY_VALUES __RPC_FAR *pProps);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *PutFrom )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ ULONG uFlags,
            /* [in] */ ULONG uBufferLength,
            /* [in] */ LPVOID pExistingMem);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLastStatus )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ ULONG __RPC_FAR *puSpecificStatus,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ LPVOID __RPC_FAR *pStatusObj);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetInterfacePropList )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ ULONG uFlags,
            /* [out] */ IUmiPropList __RPC_FAR *__RPC_FAR *pPropList);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Set )( 
            IUmiQuery __RPC_FAR * This,
            /* [in] */ LPCWSTR pszLanguage,
            /* [in] */ ULONG uFlags,
            /* [in] */ LPCWSTR pszText);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetQuery )( 
            IUmiQuery __RPC_FAR * This,
            /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
            /* [out][in] */ LPWSTR pszLangBuf,
            /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
            /* [out][in] */ LPWSTR pszQueryTextBuf);
        
        END_INTERFACE
    } IUmiQueryVtbl;

    interface IUmiQuery
    {
        CONST_VTBL struct IUmiQueryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiQuery_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiQuery_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiQuery_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiQuery_Put(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Put(This,pszName,uFlags,pProp)

#define IUmiQuery_Get(This,pszName,uFlags,pProp)	\
    (This)->lpVtbl -> Get(This,pszName,uFlags,pProp)

#define IUmiQuery_GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> GetAt(This,pszName,uFlags,uBufferLength,pExistingMem)

#define IUmiQuery_GetAs(This,pszName,uFlags,uCoercionType,pProp)	\
    (This)->lpVtbl -> GetAs(This,pszName,uFlags,uCoercionType,pProp)

#define IUmiQuery_FreeMemory(This,uReserved,pMem)	\
    (This)->lpVtbl -> FreeMemory(This,uReserved,pMem)

#define IUmiQuery_Delete(This,pszName,uFlags)	\
    (This)->lpVtbl -> Delete(This,pszName,uFlags)

#define IUmiQuery_GetProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> GetProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutProps(This,pszNames,uNameCount,uFlags,pProps)	\
    (This)->lpVtbl -> PutProps(This,pszNames,uNameCount,uFlags,pProps)

#define IUmiQuery_PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)	\
    (This)->lpVtbl -> PutFrom(This,pszName,uFlags,uBufferLength,pExistingMem)


#define IUmiQuery_GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)	\
    (This)->lpVtbl -> GetLastStatus(This,uFlags,puSpecificStatus,riid,pStatusObj)

#define IUmiQuery_GetInterfacePropList(This,uFlags,pPropList)	\
    (This)->lpVtbl -> GetInterfacePropList(This,uFlags,pPropList)


#define IUmiQuery_Set(This,pszLanguage,uFlags,pszText)	\
    (This)->lpVtbl -> Set(This,pszLanguage,uFlags,pszText)

#define IUmiQuery_GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)	\
    (This)->lpVtbl -> GetQuery(This,puLangBufSize,pszLangBuf,puQueryTextBufSize,pszQueryTextBuf)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiQuery_Set_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [in] */ LPCWSTR pszLanguage,
    /* [in] */ ULONG uFlags,
    /* [in] */ LPCWSTR pszText);


void __RPC_STUB IUmiQuery_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiQuery_GetQuery_Proxy( 
    IUmiQuery __RPC_FAR * This,
    /* [out][in] */ ULONG __RPC_FAR *puLangBufSize,
    /* [out][in] */ LPWSTR pszLangBuf,
    /* [out][in] */ ULONG __RPC_FAR *puQueryTextBufSize,
    /* [out][in] */ LPWSTR pszQueryTextBuf);


void __RPC_STUB IUmiQuery_GetQuery_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiQuery_INTERFACE_DEFINED__ */


#ifndef __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__
#define __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__

/* interface IUmiCustomInterfaceFactory */
/* [uuid][local][object] */ 


EXTERN_C const IID IID_IUmiCustomInterfaceFactory;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("14CD599E-2BE7-4c6f-B95B-B150DCD93585")
    IUmiCustomInterfaceFactory : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForIID( 
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetObjectByCLSID( 
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCLSIDForNames( 
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IUmiCustomInterfaceFactoryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForIID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetObjectByCLSID )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [in] */ CLSID clsid,
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ DWORD dwClsContext,
            /* [in] */ REFIID riid,
            /* [in] */ long lFlags,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCLSIDForNames )( 
            IUmiCustomInterfaceFactory __RPC_FAR * This,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
            /* [in] */ long lFlags,
            /* [out][in] */ CLSID __RPC_FAR *pCLSID);
        
        END_INTERFACE
    } IUmiCustomInterfaceFactoryVtbl;

    interface IUmiCustomInterfaceFactory
    {
        CONST_VTBL struct IUmiCustomInterfaceFactoryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IUmiCustomInterfaceFactory_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IUmiCustomInterfaceFactory_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IUmiCustomInterfaceFactory_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IUmiCustomInterfaceFactory_GetCLSIDForIID(This,riid,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForIID(This,riid,lFlags,pCLSID)

#define IUmiCustomInterfaceFactory_GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)	\
    (This)->lpVtbl -> GetObjectByCLSID(This,clsid,pUnkOuter,dwClsContext,riid,lFlags,ppInterface)

#define IUmiCustomInterfaceFactory_GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)	\
    (This)->lpVtbl -> GetCLSIDForNames(This,rgszNames,cNames,lcid,rgDispId,lFlags,pCLSID)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForIID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForIID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetObjectByCLSID_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [in] */ CLSID clsid,
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ DWORD dwClsContext,
    /* [in] */ REFIID riid,
    /* [in] */ long lFlags,
    /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppInterface);


void __RPC_STUB IUmiCustomInterfaceFactory_GetObjectByCLSID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IUmiCustomInterfaceFactory_GetCLSIDForNames_Proxy( 
    IUmiCustomInterfaceFactory __RPC_FAR * This,
    /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
    /* [in] */ UINT cNames,
    /* [in] */ LCID lcid,
    /* [size_is][out] */ DISPID __RPC_FAR *rgDispId,
    /* [in] */ long lFlags,
    /* [out][in] */ CLSID __RPC_FAR *pCLSID);


void __RPC_STUB IUmiCustomInterfaceFactory_GetCLSIDForNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IUmiCustomInterfaceFactory_INTERFACE_DEFINED__ */


EXTERN_C const CLSID CLSID_UmiDefURL;

#ifdef __cplusplus

class DECLSPEC_UUID("d4b21cc2-f2a5-453e-8459-b27f362cb0e0")
UmiDefURL;
#endif
#endif /* __UMI_V6_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\newop.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:  MEMORY.CXX
//
//----------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>


//+---------------------------------------------------------------------------
//
//  Function:   ADsAlloc, public
//
//  Synopsis:   Global allocator for ADs.
//
//  Effects:    Keeps track of the most recent heap allocation in each
//        thread. This information is used to determine when to
//        unlink CUnwindable objects.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:    A pointer to the allocated memory.
//
//  Modifies:   _pLastNew in _exceptioncontext.
//
//----------------------------------------------------------------------------

void*
ADsAlloc( size_t size )
{
    void *p;

    p  = (void *)LocalAlloc( LMEM_FIXED, size );

    return ( p );
}


//+---------------------------------------------------------------------------
//
//  Function:   ADsFree
//
//  Synopsis:   Matches the ADsAlloc above
//
//  Arguments:  [p] -- The pointer to delete.
//
//  Requires:   [p] was called with ADsFree
//
//  Derivation: Never override.
//
//----------------------------------------------------------------------------

void
ADsFree ( void * p )
{
    if( p == NULL ){
        return;
    }

    if( LocalFree( (HLOCAL)p ) != NULL )
        Win4Assert(!"Bad ptr for operator delete");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\alocdbg.cxx ===
/*
 * This file implements an arena that tracks memory allocations and frees.
 *      Isaache
 */

#include <ADs.hxx>

#if     DBG && !defined(MSVC) // we don't have access to nt hdrs with MSVC

// #include <except.hxx>
#include <caiheap.h>
#include <symtrans.h>

#pragma optimize( "y", off )

DECLARE_INFOLEVEL( heap );
DECLARE_DEBUG( heap );
#define heapDebugOut(x) heapInlineDebugOut x

/*
 * The maximum number of AllocArenaCreate's we expect
 */
static const    MAXARENAS       = 5;

/*
 * When printing leak dumps, the max number we will print out.  Note, we keep
 * track of all of them, we just don't want to take forever to terminate a
 * process
 */
static const    MAXDUMP         = 50;

/*
 * The maximum size we'll let any single debug arena get
 */
static const ULONG ARENASIZE    = 1024*1024;

/*
 * The unit of growth for the arena holding the AllocArena data.
 * Must be a power of 2
 */
static const ALLOCRECINCR       = 128;


static AllocArena *AllocArenas[ MAXARENAS + 1 ];

//+---------------------------------------------------------------------------
//
//  Function:   RecordStack functions(s) below...per processor type
//
//  Synopsis:   Record a stack backtrace into fTrace
//
//  Arguments:  [cFrameSkipped] --  How many stack frames to skip over and
//                      not record
//              [fTrace] -- The recorded frames are put in here
//
//  Returns:    A checksum of the stack frames for fast initial lookups
//
//  Notes:      If we can do stack backtracing for whatever processor we're
//              compiling for, the #define CANDOSTACK
//
//----------------------------------------------------------------------------
#if defined (i386) && !defined(WIN95)


static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{

#define CANDOSTACK

        ULONG sum;
        USHORT cStack;

        // This routine is found in src/ntos/rtl/i386
        // extern "C" USHORT NTAPI
        // RtlCaptureStackBackTrace(ULONG, ULONG, PVOID *, PULONG);

        cStack = RtlCaptureStackBackTrace(cFrameSkipped + 1,
                DEPTHTRACE, fTrace, &sum );

        return sum;
}

#else // ! i386

static inline DWORD
RecordStack( int cFrameSkipped, void *fTrace[ DEPTHTRACE ] )
{
#if defined(CANDOSTACK)
#undef CANDOSTACK
#endif
    return 0;
}
#endif // ! i386

//
// This allows external monitoring of heap activity by caiheap.exe
//
STDAPI_( AllocArena ** )
AllocArenaAddr( void )
{
        return AllocArenas;
}

//
// Create an arena for recording allocation statistics.  Return the arena
// pointer to the caller
//
STDAPI_( AllocArena * )
AllocArenaCreate( DWORD memctx, char FAR *comment )
{
        struct AllocArena *paa = NULL;

        if( memctx == MEMCTX_TASK ) {
#if     defined( CANDOSTACK )
                if( heapInfoLevel & DEB_WARN ) {

                        paa = (struct AllocArena *)VirtualAlloc(
                                NULL, ARENASIZE, MEM_RESERVE, PAGE_NOACCESS );
                        if( paa == NULL )
                                return NULL;

                        paa = (AllocArena *)VirtualAlloc( paa,
                           sizeof(*paa)+(ALLOCRECINCR-1)*sizeof(HeapAllocRec),
                           MEM_COMMIT, PAGE_READWRITE );

                }
                else
#endif
                {
                        paa = (struct AllocArena *)calloc( 1, sizeof(*paa) );
                }
        }

        if( paa == NULL )
                return NULL;

        memcpy( paa->Signature,HEAPSIG,sizeof(HEAPSIG));
        if( comment )
                strncpy(paa->comment, comment, sizeof(paa->comment) );

        InitializeCriticalSection( &paa->csExclusive );

        for( int i=0; i < MAXARENAS; i++ )
                if( AllocArenas[i] == 0 ) {
                        AllocArenas[i] = paa;
                        break;
                }

#if     defined( CANDOSTACK )
        if( (heapInfoLevel & DEB_WARN) == 0 )
#endif
        {
                paa->flags.KeepStackTrace = 0;
                paa->AllocRec[0].paa = paa;
                return paa;
        }

#if     defined( CANDOSTACK )
        paa->cRecords = ALLOCRECINCR;
        paa->cTotalRecords = ALLOCRECINCR;
        paa->flags.KeepStackTrace = 1;

        return paa;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordAlloc
//
//  Synopsis:   Keep a hash table of the stack backtraces of the allocations
//              we've done.
//
//  Arguments:  [paa] -- Return value from AllocArenaCreate() above
//              [bytes] -- the number of bytes being allocated by the caller.
//                      This value is recorded in the stack backtrace entry.
//
//  Algorithm:  The arena for the AllocArena is created with VirtualAlloc.
//                      pAllocArena->cRecords is the index of the next
//                      free record.  The first ALLOCRECINCR records are heads
//                      of separate lists of the records.
//
//  Returns:    A pointer to the AllocRec structure recording the entry.
//              Can return NULL if we can't record the allocation.
//
//----------------------------------------------------------------------------
STDAPI_( HeapAllocRec FAR * )
AllocArenaRecordAlloc( AllocArena *paa, size_t bytes )
{
        if( paa == NULL )
                return NULL;

        EnterCriticalSection( &paa->csExclusive );

        if( bytes ) {
                paa->cAllocs++;
                paa->cBytesNow += bytes;
                paa->cBytesTotal += bytes;
        } else {
                paa->czAllocs++;
        }

        //
        // Record 'size' in the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

        LeaveCriticalSection( &paa->csExclusive );

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace == 0 )
#endif
                return &paa->AllocRec[0];

#if     defined( CANDOSTACK )

        DWORD sum;
        struct HeapAllocRec *phar,*hp;
        void *fTrace[ DEPTHTRACE ];

        //
        // See if we find an existing record of this stack backtrace
        //
        memset( fTrace, '\0', sizeof( fTrace ) );
        sum = RecordStack( 2, fTrace );

        hp = &paa->AllocRec[ sum & (ALLOCRECINCR-1) ];

        EnterCriticalSection( &paa->csExclusive );

        for( phar = hp; phar != NULL; phar = phar->u.next )
                if( phar->sum == sum &&
                    !memcmp(phar->fTrace,fTrace,sizeof(fTrace)))
                {
                        phar->count++;
                        phar->bytes += bytes;
                        phar->total.bytes += bytes;
                        phar->total.count++;
                        phar->paa = paa;
                        LeaveCriticalSection( &paa->csExclusive );
                        return phar;
                }
        //
        // We have no record of this allocation.  Make one!
        //
        if( hp->total.count && paa->cRecords == paa->cTotalRecords ) {
                //
                // The arena is currently full.  Grow it by ALLOCRECINCR
                //
                AllocArena *npHeap;

                npHeap = (AllocArena *)VirtualAlloc(
                        paa,
                        sizeof(AllocArena)+
                        ((paa->cTotalRecords + ALLOCRECINCR) *
                                sizeof(HeapAllocRec) ),
                        MEM_COMMIT, PAGE_READWRITE );

                if( npHeap != paa ) {
                        paa->cMissed++;
                        LeaveCriticalSection( &paa->csExclusive );
                        return NULL;
                }

                paa->cTotalRecords += ALLOCRECINCR;
        }

        if( hp->total.count == 0 ) {
                phar = hp;
        } else {
                phar = &paa->AllocRec[ paa->cRecords++ ];
                phar->u.next = hp->u.next;
                hp->u.next = phar;
        }

        paa->cPaths++;

        memcpy( phar->fTrace, fTrace, sizeof( fTrace ) );
        phar->count = phar->total.count = 1;
        phar->bytes = phar->total.bytes = bytes;
        phar->sum = sum;
        phar->paa = paa;
        LeaveCriticalSection( &paa->csExclusive );
        return phar;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordReAlloc
//
//  Synopsis:   Update the record to reflect the fact that we've ReAlloc'd
//              the memory chunk.
//
//  Arguments:  [vp] -- Return value from AllocArenaRecordAlloc() above
//              [oldbytes] -- size of the memory before ReAllocation
//              [newbytes] -- new size of the memory
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordReAlloc( HeapAllocRec FAR *vp, size_t oldbytes, size_t newbytes)
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        paa->cReAllocs++;
        paa->cBytesNow -= oldbytes;
        paa->cBytesNow += newbytes;

        if( newbytes > oldbytes )
                paa->cBytesTotal += newbytes - oldbytes;

        //
        // Take 'oldbytes' out of the histogram of requests
        //
        for( int i=31; i>=0; i-- )
                if( oldbytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        //
        // Record 'newbytes' in the histogram of requests
        //
        for( i=31; i>=0; i-- )
                if( newbytes & (1<<i) ) {
                        ++(paa->Histogram.total[i]);
                        if( paa->Histogram.simul[i] < ++(paa->Histogram.now[i]))
                                paa->Histogram.simul[i] = paa->Histogram.now[i];
                        break;
                }

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->bytes -= oldbytes;
                vp->bytes += newbytes;
                vp->total.count++;
                if( newbytes > oldbytes )
                        vp->total.bytes += newbytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

//+---------------------------------------------------------------------------
//
//  Function:   AllocArenaRecordFree
//
//  Synopsis:   Caller has freed memory -- keep accounting up to date
//
//  Arguments:  [vp] -- Value returned by AllocArenaRecordAlloc() above
//              [bytes] -- The number of bytes being freed
//
//  Algorithm:  AllocRec structures, once allocated, are never actually
//                      freed back to the Hash memory arena.  This helps us
//                      understand historical use of the heap.
//
//----------------------------------------------------------------------------
STDAPI_( void )
AllocArenaRecordFree( HeapAllocRec FAR *vp, size_t bytes )
{
        if( vp == NULL )
                return;

        struct AllocArena *paa = vp->paa;

        EnterCriticalSection( &paa->csExclusive );

        //
        // Record this free in the histogram
        //
        for( int i=31; i>=0; i-- )
                if( bytes & (1<<i) ) {
                        --(paa->Histogram.now[i]);
                        break;
                }

        paa->cFrees++;
        paa->cBytesNow -= bytes;

#if     defined( CANDOSTACK )
        if( paa->flags.KeepStackTrace ) {
                vp->count--;
                vp->bytes -= bytes;
        }
#endif

        LeaveCriticalSection( &paa->csExclusive );
}

STDAPI_( void )
AllocArenaDumpRecord( HeapAllocRec FAR *bp )
{
#if     defined( CANDOSTACK )
        char achBuffer[ MAX_TRANSLATED_LEN ], *p;

        heapDebugOut((DEB_WARN, "*** %d allocs, %u bytes:\n",
                         bp->count, bp->bytes ));

        for( int j=0; j<DEPTHTRACE && bp->fTrace[j]; j++ )
        {
                TranslateAddress(bp->fTrace[j], achBuffer );
                if( p = strchr( achBuffer, '\n' ) )
                        *p = '\0';
                heapDebugOut((DEB_WARN, "       %s\n", achBuffer));
        }
#endif
}

extern "C" ULONG DbgPrint( PCH Format, ... );

STDAPI_( void )
AllocArenaDump( AllocArena *paa )
{
        if( paa == NULL ) {
                for( int i = 0; i < MAXARENAS && AllocArenas[i]; i++ )
                        AllocArenaDump( AllocArenas[i] );
                return;
        }

        char *cmdline = GetCommandLineA();

        if( cmdline == NULL )
                cmdline = "???";

        HeapAllocRec *bp = paa->AllocRec;
        HeapAllocRec *ep = bp + paa->cRecords;

        if( paa->cBytesNow )
                heapDebugOut((DEB_WARN,
                              "***** %u bytes leaked mem for %s in '%s'\n",
                              paa->cBytesNow,
                              paa->comment,
                              cmdline ));

#if     defined( CANDOSTACK )
        if( paa->cBytesNow && paa->flags.KeepStackTrace )
        {
                int cleaks = 0;

                for( ; bp < ep; bp++) {
                        if( bp->count )
                                ++cleaks;
                }

                if( cleaks ) {
                        heapDebugOut((DEB_WARN, "***** %s %u MEM LEAKS\n",
                                paa->comment, cleaks ));

                        if( heapInfoLevel & DEB_TRACE ) {
                                HeapAllocRec *bp;
                                UINT maxdump = MAXDUMP;
                                for( bp = paa->AllocRec; maxdump && bp<ep; bp++)
                                        if( bp->count ) {
                                                heapDebugOut((DEB_TRACE, "\n"));
                                                AllocArenaDumpRecord( bp );
                                                maxdump--;
                                        }
                        } else if( cleaks )
                                heapDebugOut((DEB_WARN, "** Set formidbl!heapInfoLevel to x707 for leak backtrace\n"));

                }
        }
#endif

        if( (heapInfoLevel & DEB_TRACE) && paa->cBytesTotal )
        {
                heapDebugOut((DEB_TRACE,"\n"));
                heapDebugOut((DEB_TRACE,
                        "'%s' Memory Stats: %u allocations, %u frees\n",
                        cmdline, paa->cAllocs, paa->cFrees ));

                if( paa->czAllocs )
                        heapDebugOut((DEB_TRACE,
                                "\t%u zero allocs\n", paa->czAllocs ));

                heapDebugOut((DEB_TRACE,
                                "\t%u bytes allocated\n", paa->cBytesTotal ));

                heapDebugOut((DEB_TRACE,
                                "*** Histogram of Allocated Mem Sizes ***\n"));

                heapDebugOut((DEB_TRACE, "  Min    Max\t  Tot\t Simul\n" ));
                for( int i=0; i < 32; i++ )
                        if( paa->Histogram.total[i] )
                        {
                                heapDebugOut((DEB_TRACE,
                                        "%6u -> %6u\t%6u\t%6u\n",
                                        1<<i, (1<<(i+1))-1,
                                        paa->Histogram.total[i],
                                        paa->Histogram.simul[i]
                                ));
                        }
        }
}

#endif  // DBG && !defined(MSVC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\svcprov.h ===
#include "rpc.h"
#include "rpcndr.h"

#ifndef __svcprov_h__
#define __svcprov_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IProvideDBService_FWD_DEFINED__
#define __IProvideDBService_FWD_DEFINED__
typedef interface IProvideDBService IProvideDBService;
#endif 	/* __IProvideDBService_FWD_DEFINED__ */

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __IProvideDBService_INTERFACE_DEFINED__
#define __IProvideDBService_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IProvideDBService
 * at Mon Apr 22 16:40:51 1996
 * using MIDL 2.00.72
 ****************************************/
/* [unique][uuid][object][local] */ 

// @msg IID_IProvideDBService | {EFF65380-9C98-11CF-B963-00AA0044773D}
DEFINE_GUID(IID_IProvideDBService, 0xEFF65380L,0x9C98,0x11CF,0xB9,0x63,0x00,0xAA,0x00,0x44,0x77,0x3D);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface IProvideDBService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProvideService( 
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider) = 0;
        
    };
    
#else 	/* C style interface */
    
    typedef struct IProvideDBServiceVtbl
    {
        
        HRESULT ( __stdcall __RPC_FAR *QueryInterface )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( __stdcall __RPC_FAR *AddRef )( 
            IProvideDBService __RPC_FAR * This);
        
        ULONG ( __stdcall __RPC_FAR *Release )( 
            IProvideDBService __RPC_FAR * This);
        
        HRESULT ( __stdcall __RPC_FAR *ProvideService )( 
            IProvideDBService __RPC_FAR * This,
            /* [in] */ ULONG cProvidedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
            /* [in] */ ULONG cRequestedPropertySets,
            /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
            /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ IUnknown __RPC_FAR *pDataProvider,
            /* [in] */ REFIID riidRequested,
            /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);
        
    } IProvideDBServiceVtbl;
    
    interface IProvideDBService
    {
        CONST_VTBL struct IProvideDBServiceVtbl __RPC_FAR *lpVtbl;
    };
    
    

#ifdef COBJMACROS


#define IProvideDBService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IProvideDBService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IProvideDBService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IProvideDBService_ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)	\
    (This)->lpVtbl -> ProvideService(This,cProvidedProperties,rgProvidedProperties,cRequestedProperties,rgRequestedProperties,pUnkOuter,pDataProvider,riidRequested,ppServiceProvider)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT __stdcall IProvideDBService_ProvideService_Proxy( 
    IProvideDBService __RPC_FAR * This,
    /* [in] */ ULONG cProvidedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgProvidedPropertySets[  ],
    /* [in] */ ULONG cRequestedPropertySets,
    /* [size_is][in] */ DBPROPSET __RPC_FAR rgRequestedPropertySets[  ],
    /* [in] */ IUnknown __RPC_FAR *pUnkOuter,
    /* [in] */ IUnknown __RPC_FAR *pDataProvider,
    /* [in] */ REFIID riidRequested,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppServiceProvider);



void __RPC_STUB IProvideDBService_ProvideService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IProvideDBService_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\include\rowprov.h ===
//-----------------------------------------------------------------------------------
// Microsoft OLE DB Provider for ODBC data
// (C) Copyright 1994 - 1996 By Microsoft Corporation.
//
// @doc
//
// @module ROWPROV.H | Definition of the Row Provider interface used by the generic
//					   flavor of the TempTable.
//
//
// @rev 1 | 04-03-96 | WlodekN | Created
// @rev 2 | 07-24-96 | EricJ   | Added PropID
//
//-----------------------------------------------------------------------------------


#ifndef __ROWPROV_INCL__
#define __ROWPROV_INCL__


//---------------------------------- C L A S S E S ----------------------------------


// Abstract class for objects providing row data to the generic TempTable.
class IRowProvider : public IUnknown
{
	public:
		virtual STDMETHODIMP GetColumn
				(
				ULONG		icol,
				DBSTATUS	*pwStatus,
				ULONG		*pdwLength,
				BYTE		*pbData
				) = 0;
		virtual STDMETHODIMP NextRow
				(
				void
				) = 0;
};

EXTERN_C const IID IID_IRowProvider;
EXTERN_C const GUID DBPROPSET_TEMPTABLE;

// TempTable Property IDs.
enum tagetmptablepropid
{
	DBPROP_INSTANTPOPULATION=2,	// TRUE = Prepopulate.  FALSE = Lazy population.
	DBPROP_DBCOLBYREF,			// TRUE = Clear BYREF flags from IColumnsInfo, source owns memory.
	DBPROP_DONTALLOCBYREFCOLS,	// TRUE = TempTable only allocates ptr for BYREF columns.
};


#endif	// __ROWPROV_INCL__

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\otrack.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       otrack.cxx
//
//  Contents:   Object tracking system
//
//  Classes:    ObjectTracker
//
//  History:    06-Apr-92 MikeSe         Created
//              30-Sep-93 KyleP          DEVL obsolete
//              15-Jul-94 DonCl          grabbed from common put in forms.
//                                       absolutely minimal changes to
//                                       get it working.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#include "symtrans.h"
#include "otrackp.hxx"

// This is all unused in the retail build
#if DBG == 1
CRITICAL_SECTION g_csOT;

// this is a dummy item used as the head of the doubly-linked list
// of TrackLinks, and a mutex to protect it
static TrackLink tlHead = { &tlHead, &tlHead };

// this is a dummy item used as the head of the doubly-linked list
// of NameEntrys
static NameEntry neHead = { &neHead, &neHead };

static char * apszTypes[] = {"Create", "AddRef", "Release"};

//  initialize class static data
int ObjectTracker::_TrackAll = GetProfileIntW(L"Object Track",L"DEFAULT",1);

// standard debugging stuff
DECLARE_INFOLEVEL(Ot)

extern void RecordAction ( TrackLink *tl, FrameType ft, ULONG cRefCount );
extern void _cdecl EstablishHistory ( FrameRecord * fr, int nSkip );
extern void DumpHistory ( unsigned long fDebugMask, TrackLink *tl );


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::ObjectTracker, protected
//
//  Synopsis:   Contructor
//
//  Effects:    Allocates TrackLink structure and initialises it.
//
//  Arguments:  None
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::ObjectTracker ()
    :_ulRefs(1)
{
    // Allocate the structure which maintains the tracking history.
    // We also make space for the first FrameRecord.
    HRESULT hr = MemAlloc ( sizeof(TrackLink) + sizeof(FrameRecord),
                          (void**)&_tl);
    if ( FAILED(hr) )
    {
        OtDebugOut ((DEB_OT_ERRORS,
                     "Unable to establish tracking for %lx\n",
                     this ));
    }
    else
    {
        _tl->potr = this;
        _tl->ulSig = TRACK_LINK_SIGNATURE;
        _tl->pszName = NULL;

        FrameRecord * fr = (FrameRecord*) ( _tl + 1 );
        if ( OtInfoLevel & DEB_OT_CALLERS )
        {
            EstablishHistory ( fr, 1 );
        }
        fr->ft = FT_CREATE;
        fr->cRefCount = 1;
        fr->frNext = NULL;
        _tl->frFirst = _tl->frLast = fr;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tll = tlHead.tlPrev;
        tll->tlNext = tlHead.tlPrev = _tl;
        _tl->tlNext = &tlHead;
        _tl->tlPrev = tll;
        LeaveCriticalSection(&g_csOT);

        OtDebugOut ((DEB_OT_ACTIONS, "New object at %lx\n", this ));
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::TrackClassName, protected
//
//  Synopsis:   Records class name for tracked object
//
//  Arguments:  [pszName]       -- class name
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::TrackClassName (
    char * pszName )
{
    if ( _tl != NULL )
    {
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));

    // Copy the class name so we don't lose it if the class DLL is
    //  unloaded.
    ULONG cBytes = strlen ( pszName ) + 1;
    HRESULT hr = MemAlloc ( cBytes, (void**)&(_tl->pszName) );
    if ( SUCCEEDED(hr) )
    {
        memcpy ( _tl->pszName, pszName, cBytes );
    }
        else
    {
        OtDebugOut((DEB_OT_ERRORS,"Memory allocation failure %lx\n",hr));
        _tl->pszName = "Name lost";
    }

        _tl->fTrack = IsClassTracking(pszName);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdAddRef, public
//
//  Synopsis:   Standard implementation of AddRef for tracked objects
//
//  Effects:    Increments ref count, records history
//
//  Returns:    S_OK
//
//  Modifies:   _ulRefs
//
//  Derivation: Never
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdAddRef()
{
    InterlockedIncrement ( (LONG*)&_ulRefs );

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "AddRef [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_ADDREF, _ulRefs );
    }

    return _ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::StdRelease, public
//
//  Synopsis:   Helper function for standard implementation of Release()
//
//  Effects:    Decrements ref count, records history
//
//  Returns:    SUCCESS_NO_MORE iff ref count reached zero.
//              Otherwise S_OK or an error.
//
//  History:    31-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP ULONG
ObjectTracker::StdRelease ()
{
    LONG lResult = InterlockedDecrement((LONG*)&_ulRefs);

    if (_tl->fTrack)
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Release [%d] of object at %lx (%s)\n",
                        _ulRefs, this, _tl->pszName ));

        RecordAction ( _tl, FT_RELEASE, _ulRefs );
    }

    return (lResult==0)?0:_ulRefs;
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::~ObjectTracker, protected
//
//  Synopsis:   Destructor
//
//  Effects:    Remove this item, along with all history, from the
//              tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
ObjectTracker::~ObjectTracker()
{
    if ( _tl != NULL )
    {
        OtDebugOut ((DEB_OT_ACTIONS, "Delete of object at %lx [%s]\n",
                        this, _tl->pszName ));
        OtAssert (( _tl->ulSig == TRACK_LINK_SIGNATURE ));
        // OtAssert ( _ulRefs == 0 );

        // unlink, with concurrency control
        EnterCriticalSection(&g_csOT);
        TrackLink * tlp = _tl->tlPrev;
        TrackLink * tln = _tl->tlNext;
        tln->tlPrev = tlp;
        tlp->tlNext = tln;
        LeaveCriticalSection(&g_csOT);

        if ((_tl->fTrack) && (OtInfoLevel & DEB_OT_DELETE))
        {
            DumpHistory ( DEB_OT_DELETE, _tl );
        }
		if (_tl->pszName) {
			MemFree(_tl->pszName);
		}
        MemFree ( _tl );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     ObjectTracker::DumpTrackingInfo, public
//
//  Synopsis:   Dumps out the tracking list
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP void
ObjectTracker::DumpTrackingInfo (
    int fDeleteNode)
{
    TrackLink * tl = tlHead.tlNext;
    BOOL fHeader = FALSE;

    while ( tl != &tlHead )
    {
        // This is an unreleased item. Print out the history info

        if ( !fHeader )
        {
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            OtDebugOut((DEB_OT_OBJECTS, "* Unreleased objects found *\n"));
            OtDebugOut((DEB_OT_OBJECTS, "****************************\n"));
            fHeader = TRUE;
        }

        OtDebugOut ((DEB_OT_OBJECTS,
                     "Object at %lx (%s)\n",
                     tl->potr,
                     tl->pszName ));
        OtDebugOut ((DEB_OT_OBJECTS,
                     "  Reference count = %d\n",
                     tl->potr->GetRefCount() ));
        DumpHistory ( DEB_OT_CALLERS, tl );

        if (fDeleteNode)
        {
            // unlink, with concurrency control
            EnterCriticalSection(&g_csOT);
            tl->potr->_tl = NULL;
            TrackLink * tlp = tl->tlPrev;
            TrackLink * tln = tl->tlNext;
            tln->tlPrev = tlp;
            tlp->tlNext = tln;
            LeaveCriticalSection(&g_csOT);
            MemFree ( tl );
            tl = tln;
        }
        else
        {
            tl = tl->tlNext;
        }
    }

    //  delete all the name entries
    if (fDeleteNode)
    {
        EnterCriticalSection(&g_csOT);

        //  find the entry if there is one
        NameEntry *ne =  neHead.neNext;
        while (ne != &neHead)
        {
            // unlink, with concurrency control
            NameEntry * nep = ne->nePrev;
            NameEntry * nen = ne->neNext;
            nen->nePrev = nep;
            nep->neNext = nen;
            MemFree ( ne );
            ne = nen;
        }
        LeaveCriticalSection(&g_csOT);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     TrackClass
//
//  Synopsis:   Tells the object tracker to start/stop tracking the specified
//              class of objects.
//
//  Arguments:  [fTrack   -- debug mask controlling the output
//              [pszName] -- TrackLink record
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
void ObjectTracker::TrackClass(int fTrack, char * pszClassName)
{
    if (pszClassName == NULL)
    {
        //  set default for ALL classes
        _TrackAll = fTrack;
        return;
    }


    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;

    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            //  found our entry, update the flag
            ne->fTrack = fTrack;
            return;
        }

        ne = ne->neNext;
    }

    //  its not in the list
    HRESULT hr = MemAlloc( sizeof(NameEntry), (void **)&ne);
    if ( FAILED(hr) )
    {
        OtDebugOut((DEB_OT_ERRORS,
                    "Unable to record class for tracking %s\n",
                    pszClassName));
    }
    else
    {
        ne->pszName = pszClassName;
        ne->fTrack = fTrack;

        // insert at end of list, with concurrency control
        EnterCriticalSection(&g_csOT);
        NameEntry *neH = neHead.nePrev;
        neH->neNext = neHead.nePrev = ne;
        ne->neNext = &neHead;
        ne->nePrev = ne;
        LeaveCriticalSection(&g_csOT);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     IhrlassTracking, private
//
//  Synopsis:   returns TRUE if the object is currently tracked
//
//  Arguments:  [pszClassName] -- class name
//
//  History:    14-Apr-93 Rickhi          Created
//
//  Notes:
//
//--------------------------------------------------------------------------

EXPORTIMP
int ObjectTracker::IsClassTracking(char * pszClassName)
{
    //  find the entry if there is one
    NameEntry *ne =  neHead.neNext;
    while (ne != &neHead)
    {
        if (!strcmp(ne->pszName, pszClassName))
        {
            return ne->fTrack;
        }
        ne = ne->neNext;
    }

    return GetProfileIntA("Object Track",pszClassName,_TrackAll);
}

//+-------------------------------------------------------------------------
//
//  Function:   DumpHistory
//
//  Synopsis:   Dumps the call history represented by a particular TrackLink
//
//  Arguments:  [fDebugMask]    -- debug mask controlling the output
//              [tl]            -- TrackLink record
//
//  History:    28-Jul-92 MikeSe        Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void DumpHistory ( unsigned long fDebugMask, TrackLink * tl )
{
// we can't call TranslateAddress without access to NT header files
#ifndef MSVC
#ifndef WIN95
    //
    // Only do all of this work if it will output anything!
    //
    if (OtInfoLevel & fDebugMask)
    {
        OtDebugOut ((fDebugMask, "  Call history follows:\n" ));
        FrameRecord * fr = tl->frFirst;
        while ( fr != NULL )
        {
            char achBuffer[MAX_TRANSLATED_LEN];

            OtDebugOut ((fDebugMask,
                         "\t%s [%d]\n",
                         apszTypes[fr->ft],
                         fr->cRefCount ));

            for ( int I=0; (I < MAX_CALLERS) && (fr->callers[I]); I++ )
            {
                TranslateAddress ( fr->callers[I], achBuffer );
                OtDebugOut ((fDebugMask, "\t    %s\n", achBuffer));
            }

            fr = fr->frNext;
        }
    }
#endif
#endif
}

//+-------------------------------------------------------------------------
//
//  Function:   RecordAction
//
//  Synopsis:   Record an AddRef/Release
//
//  Effects:    Allocates and fills in a new frame record
//
//  Arguments:  [tl]            -- TrackLink for object being tracked
//              [ft]            -- Frame type (FT_ADDREF, FT_RELEASE)
//              [cRefCount]     -- current ref count
//
//  History:    6-Apr-92 MikeSe         Created
//
//  Notes:
//
//--------------------------------------------------------------------------

void RecordAction ( TrackLink * tl, FrameType ft, ULONG cRefCount )
{
    // Record the activity only if DEB_OT_CALLERS is set

    if ( tl != NULL && (OtInfoLevel & DEB_OT_CALLERS))
    {
        OtAssert(tl->ulSig == TRACK_LINK_SIGNATURE );
        FrameRecord * fr;
        HRESULT hr;

        hr = MemAlloc(sizeof(FrameRecord), (void **)&fr);

        if ( FAILED(hr) )
        {
            OtDebugOut((DEB_OT_ERRORS,
                        "Unable to record history for %lx\n",
                        tl->potr));
        }
        else
        {
            // Save call history
            EstablishHistory ( fr, 2 );
            fr->ft = ft;
            fr->cRefCount = cRefCount;
            fr->frNext = NULL;

            // Add to list, with concurrency control
            EnterCriticalSection(&g_csOT);
            FrameRecord * frl = tl->frLast;
            frl->frNext = tl->frLast = fr;
            LeaveCriticalSection(&g_csOT);
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   EstablishHistory
//
//  Synopsis:   Records calling history for an operation
//
//  Effects:    Walks back through call frames recording caller addresses.
//
//  Arguments:  [fr]            -- FrameRecord in which to save history
//              [nFramesSkip]   -- number of frames to skip before
//                                 recording.
//
//  History:    6-Apr-92 MikeSe         Created [from PaulC's imalloc code]
//      19-Apr-94 MikeSe    Converted to use RtlCaptureStackBacktrace
//
//  Notes:
//
//--------------------------------------------------------------------------

void _cdecl
EstablishHistory (
    FrameRecord * fr,
    int nFramesSkip
    )
{

#if (defined(i386) && !defined(WIN95))

    memset ( fr->callers, 0, MAX_CALLERS * sizeof(void*) );

    ULONG ulHash;
    RtlCaptureStackBackTrace ( nFramesSkip, MAX_CALLERS,
                    fr->callers, &ulHash );
#endif // i386
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\symtrans.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.c
//
//  Contents:   Address->symbolic name translation code
//
//  Functions:  TranslateAddress
//
//  History:     8-Mar-93 PeterWi   Re-ssynced to module list so that
//                                  symbol translation worked.
//              16-Jul-92 MikeSe    Created
//
//  Notes:      This is debug only code, extracted from a piece of NT.
//              (private\windows\base\client\debugint.c).
//
//              Warning: most of this stuff is black magic. You are strongly
//              advised to refer to the original code (as above) before
//              making any changes.
//
//--------------------------------------------------------------------------

#include "dswarn.h"

void
TranslateAddress(
    void * pvAddress,
    char * pchBuffer )
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\output.c ===
/***
*output.c - printf style output to a struct w4io
*
*   Copyright (c) 1989-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*   This file contains the code that does all the work for the
*   printf family of functions.  It should not be called directly, only
*   by the *printf functions.  We don't make any assumtions about the
*   sizes of ints, longs, shorts, or long doubles, but if types do overlap, we
*   also try to be efficient.  We do assume that pointers are the same size
*   as either ints or longs.
*
*Revision History:
*   06-01-89  PHG   Module created
*   08-28-89  JCR   Added cast to get rid of warning (no object changes)
*   02-15-90  GJF   Fixed copyright
*   10-03-90  WHB   Defined LOCAL(x) to "static x" for local procedures
*   14-Mar-94 DonCl stolen from Cairo common project to use with Forms so
*                   Forms can build and run on Daytona without commnot.dll
*
*******************************************************************************/

#include <stdlib.h>
#include <limits.h>
#include <string.h>
#include <stdarg.h>
#include "wchar.h"
#include "w4io.h"


/* this macro defines a function which is private and as fast as possible: */
/* for example, in C 6.0, it might be static _fastcall <type>. */
#define LOCAL(x) static x            // 100390--WHB

#define NOFLOATS                        // Win 4 doesn't need floating point

/* int/long/short/pointer sizes */

/* the following should be set depending on the sizes of various types */
// FLAT or LARGE model is assumed
#ifdef FLAT
#  define LONG_IS_INT        1       /* 1 means long is same size as int */
#  define SHORT_IS_INT       0       /* 1 means short is same size as int */
#  define PTR_IS_INT         1       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        0       /* 1 means ptr is same size as long */
#else // LARGE model
#  define LONG_IS_INT        0       /* 1 means long is same size as int */
#  define SHORT_IS_INT       1       /* 1 means short is same size as int */
#  define PTR_IS_INT         0       /* 1 means ptr is same size as int */
#  define PTR_IS_LONG        1       /* 1 means ptr is same size as long */
#endif
#define LONGDOUBLE_IS_DOUBLE 0       /* 1 means long double is same as double */

#if LONG_IS_INT
    #define get_long_arg(x) (long)get_int_arg(x)
#endif

#ifndef _WIN64
    #if PTR_IS_INT
        #define get_ptr_arg(x) (void *)get_int_arg(x)
    #elif PTR_IS_LONG
        #define get_ptr_arg(x) (void *)get_long_arg(x)
    #else
        #error Size of pointer must be same as size of int or long
    #endif
#else
    #define get_ptr_arg(x) (void *)get_ptr64_arg(x)
#endif

#ifndef NOFLOATS
/* These are "fake" double and long doubles to fool the compiler,
   so we don't drag in floating point. */
typedef struct {
    char x[sizeof(double)];
} DOUBLE;
typedef struct {
    char x[sizeof(long double)];
} LONGDOUBLE;
#endif


/* CONSTANTS */

//#define BUFFERSIZE CVTBUFSIZE     /* buffer size for maximum double conv */
#define BUFFERSIZE 20

/* flag definitions */
#define FL_SIGN       0x0001      /* put plus or minus in front */
#define FL_SIGNSP     0x0002      /* put space or minus in front */
#define FL_LEFT       0x0004      /* left justify */
#define FL_LEADZERO   0x0008      /* pad with leading zeros */
#define FL_LONG       0x0010      /* long value given */
#define FL_SHORT      0x0020      /* short value given */
#define FL_SIGNED     0x0040      /* signed data given */
#define FL_ALTERNATE  0x0080      /* alternate form requested */
#define FL_NEGATIVE   0x0100      /* value is negative */
#define FL_FORCEOCTAL 0x0200      /* force leading '0' for octals */
#define FL_LONGDOUBLE 0x0400      /* long double value given */
#define FL_WIDE       0x0800      /* wide character/string given */

/* state definitions */
enum STATE {
    ST_NORMAL,              /* normal state; outputting literal chars */
    ST_PERCENT,             /* just read '%' */
    ST_FLAG,                /* just read flag character */
    ST_WIDTH,               /* just read width specifier */
    ST_DOT,                 /* just read '.' */
    ST_PRECIS,              /* just read precision specifier */
    ST_SIZE,                /* just read size specifier */
    ST_TYPE                 /* just read type specifier */
};
#define NUMSTATES (ST_TYPE + 1)

/* character type values */
enum CHARTYPE {
    CH_OTHER,               /* character with no special meaning */
    CH_PERCENT,             /* '%' */
    CH_DOT,                 /* '.' */
    CH_STAR,                /* '*' */
    CH_ZERO,                /* '0' */
    CH_DIGIT,               /* '1'..'9' */
    CH_FLAG,                /* ' ', '+', '-', '#' */
    CH_SIZE,                /* 'h', 'l', 'L', 'N', 'F' */
    CH_TYPE                 /* type specifying character */
};

/* static data (read only, since we are re-entrant) */
char *nullstring = "(null)";    /* string to print on null ptr */

/* The state table.  This table is actually two tables combined into one. */
/* The lower nybble of each byte gives the character class of any         */
/* character; while the uper nybble of the byte gives the next state      */
/* to enter.  See the macros below the table for details.                 */
/*                                                                        */
/* The table is generated by maketab.c -- use the maketab program to make */
/* changes.                                                               */

static char lookuptable[] = {
    0x06, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00,
    0x10, 0x00, 0x03, 0x06, 0x00, 0x06, 0x02, 0x10,
    0x04, 0x45, 0x45, 0x45, 0x05, 0x05, 0x05, 0x05,
    0x05, 0x35, 0x30, 0x00, 0x50, 0x00, 0x00, 0x00,
    0x00, 0x20, 0x28, 0x38, 0x50, 0x58, 0x07, 0x08,
    0x00, 0x30, 0x30, 0x30, 0x57, 0x50, 0x07, 0x00,
    0x00, 0x20, 0x20, 0x08, 0x00, 0x00, 0x00, 0x00,
    0x08, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x00,
    0x00, 0x70, 0x70, 0x78, 0x78, 0x78, 0x78, 0x08,
    0x07, 0x08, 0x00, 0x00, 0x07, 0x00, 0x08, 0x08,
    0x08, 0x00, 0x00, 0x08, 0x00, 0x08, 0x00, 0x07,
    0x08
};

#define find_char_class(c)              \
        ((c) < ' ' || (c) > 'x' ?       \
            CH_OTHER                    \
        :                               \
            lookuptable[(c)-' '] & 0xF)

#define find_next_state(class, state)   \
        (lookuptable[(class) * NUMSTATES + (state)] >> 4)

#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr);
#endif
LOCAL(int) get_int_arg(va_list *pargptr);
#ifdef _WIN64
LOCAL(void*) get_ptr64_arg(va_list *pargptr);
#endif
LOCAL(void) writestring(char *string,
                        int len,
                        struct w4io *f,
                        int *pcchwritten,
                        int fwide);

#ifndef NOFLOATS
/* extern float convert routines */
typedef int (* PFI)();
extern PFI _cfltcvt_tab[5];
#define _cfltcvt(a,b,c,d,e) (*_cfltcvt_tab[0])(a,b,c,d,e)
#define _cropzeros(a)       (*_cfltcvt_tab[1])(a)
#define _fassign(a,b,c)     (*_cfltcvt_tab[2])(a,b,c)
#define _forcdecpt(a)       (*_cfltcvt_tab[3])(a)
#define _positive(a)        (*_cfltcvt_tab[4])(a)
#define _cldcvt(a,b,c,d,e)  (*_cfltcvt_tab[5])(a,b,c,d,e)
#endif


/***
*int w4iooutput(f, format, argptr)
*
*Purpose:
*   Output performs printf style output onto a stream.  It is called by
*   printf/fprintf/sprintf/vprintf/vfprintf/vsprintf to so the dirty
*   work.  In multi-thread situations, w4iooutput assumes that the given
*   stream is already locked.
*
*   Algorithm:
*       The format string is parsed by using a finite state automaton
*       based on the current state and the current character read from
*       the format string.  Thus, looping is on a per-character basis,
*       not a per conversion specifier basis.  Once the format specififying
*       character is read, output is performed.
*
*Entry:
*   struct w4io *f   - stream for output
*   char *format   - printf style format string
*   va_list argptr - pointer to list of subsidiary arguments
*
*Exit:
*   Returns the number of characters written, or -1 if an output error
*   occurs.
*
*Exceptions:
*
*******************************************************************************/

int _cdecl w4iooutput(struct w4io *f, const char *format, va_list argptr)
{
    int hexadd=0;       /* offset to add to number to get 'a'..'f' */
    char ch;            /* character just read */
    wchar_t wc;         /* wide character temp */
    wchar_t *pwc;       /* wide character temp pointer */
    int flags = 0;      /* flag word -- see #defines above for flag values */
    enum STATE state;   /* current state */
    enum CHARTYPE chclass; /* class of current character */
    int radix;          /* current conversion radix */
    int charsout;       /* characters currently written so far, -1 = IO error */
    int fldwidth=0;     /* selected field with -- 0 means default */
    int fwide;
    int precision=0;    /* selected precision -- -1 means default */
    char prefix[2];     /* numeric prefix -- up to two characters */
    int prefixlen=0;    /* length of prefix -- 0 means no prefix */
    int capexp;         /* non-zero = 'E' exponent signifiet, zero = 'e' */
    int no_output=0;    /* non-zero = prodcue no output for this specifier */
    char *text=NULL;    /* pointer text to be printed, not zero terminated */
    int textlen=0;      /* length of the text to be printed */
    char buffer[BUFFERSIZE];    /* buffer for conversions */

    charsout = 0;               /* no characters written yet */
    state = ST_NORMAL;          /* starting state */

    /* main loop -- loop while format character exist and no I/O errors */
    while ((ch = *format++) != '\0' && charsout >= 0) {
        chclass = find_char_class(ch);  /* find character class */
        state = find_next_state(chclass, state); /* find next state */

        /* execute code for each state */
        switch (state) {

        case ST_NORMAL:
            /* normal state -- just write character */
            f->writechar(ch, 1, f, &charsout);
            break;

        case ST_PERCENT:
            /* set default value of conversion parameters */
            prefixlen = fldwidth = no_output = capexp = 0;
            flags = 0;
            precision = -1;
            fwide = 0;
            break;

        case ST_FLAG:
            /* set flag based on which flag character */
            switch (ch) {
            case '-':
                flags |= FL_LEFT;       /* '-' => left justify */
                break;
            case '+':
                flags |= FL_SIGN;       /* '+' => force sign indicator */
                break;
            case ' ':
                flags |= FL_SIGNSP;     /* ' ' => force sign or space */
                break;
            case '#':
                flags |= FL_ALTERNATE;  /* '#' => alternate form */
                break;
            case '0':
                flags |= FL_LEADZERO;   /* '0' => pad with leading zeros */
                break;
            }
            break;

        case ST_WIDTH:
            /* update width value */
            if (ch == '*') {
                /* get width from arg list */
                fldwidth = get_int_arg(&argptr);
                if (fldwidth < 0) {
                    /* ANSI says neg fld width means '-' flag and pos width */
                    flags |= FL_LEFT;
                    fldwidth = -fldwidth;
                }
            }
            else {
                /* add digit to current field width */
                fldwidth = fldwidth * 10 + (ch - '0');
            }
            break;

        case ST_DOT:
            /* zero the precision, since dot with no number means 0
               not default, according to ANSI */
            precision = 0;
            break;

        case ST_PRECIS:
            /* update precison value */
            if (ch == '*') {
                /* get precision from arg list */
                precision = get_int_arg(&argptr);
                if (precision < 0)
                    precision = -1;     /* neg precision means default */
            }
            else {
                /* add digit to current precision */
                precision = precision * 10 + (ch - '0');
            }
            break;

        case ST_SIZE:
            /* just read a size specifier, set the flags based on it */
            switch (ch) {
#if !LONG_IS_INT
            case 'l':
                flags |= FL_LONG;   /* 'l' => long int */
                break;
#endif

#if !LONGDOUBLE_IS_DOUBLE
            case 'L':
                flags |= FL_LONGDOUBLE; /* 'L' => long double */
                break;
#endif

#if !SHORT_IS_INT
            case 'h':
                flags |= FL_SHORT;  /* 'h' => short int */
                break;
#endif
            case 'w':
                flags |= FL_WIDE;   /* 'w' => wide character */
                break;
            }
            break;

        case ST_TYPE:
            /* we have finally read the actual type character, so we       */
            /* now format and "print" the output.  We use a big switch     */
            /* statement that sets 'text' to point to the text that should */
            /* be printed, and 'textlen' to the length of this text.       */
            /* Common code later on takes care of justifying it and        */
            /* other miscellaneous chores.  Note that cases share code,    */
            /* in particular, all integer formatting is doen in one place. */
            /* Look at those funky goto statements!                        */

            switch (ch) {

            case 'c': {
                /* print a single character specified by int argument */
                wc = (wchar_t) get_int_arg(&argptr);    /* get char to print */
                * (wchar_t *) buffer = wc;
                text = buffer;
                textlen = 1;        /* print just a single character */
            }
            break;

            case 'S': {
                /* print a Counted String   */

                struct string {
                    short Length;
                    short MaximumLength;
                    char *Buffer;
                } *pstr;

                pstr = get_ptr_arg(&argptr);
                if (pstr == NULL || pstr->Buffer == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    /* 64-bit: we assume length of string is <= 4 GB */
                    textlen = (int)strlen(text);
                    flags &= ~FL_WIDE;
                } else {
                    text = pstr->Buffer;
                    /* The length field is a count of bytes, not characters. */
                    if (flags & FL_WIDE)
                        textlen = pstr->Length / sizeof( wchar_t );
                    else
                        textlen = pstr->Length;
                    if (precision != -1)
                        textlen = min( textlen, precision );
                }

            }
            break;

            case 's': {
                /* print a string --                            */
                /* ANSI rules on how much of string to print:   */
                /*   all if precision is default,               */
                /*   min(precision, length) if precision given. */
                /* prints '(null)' if a null string is passed   */

                int i;
                char *p;       /* temps */

                text = get_ptr_arg(&argptr);
                if (text == NULL) {
                    /* null ptr passed, use special string */
                    text = nullstring;
                    flags &= ~FL_WIDE;
                }

                /* At this point it is tempting to use strlen(), but */
                /* if a precision is specified, we're not allowed to */
                /* scan past there, because there might be no null   */
                /* at all.  Thus, we must do our own scan.           */

                i = (precision == -1) ? INT_MAX : precision;

                /* scan for null upto i characters */
                if (flags & FL_WIDE) {
                    pwc = (wchar_t *) text;
                    while (i-- && (wc = *pwc) != 0 && (wc & 0x00ff)) {
                        ++pwc;
                        if (wc & 0xff00) {      // if high byte set,
                            break;              // error will be indicated
                        }
                    }
                    textlen = (int)(pwc - (wchar_t *) text);  /* length of string */
                } else {
                    p = text;
                    while (i-- && *p) {
                        ++p;
                    }
                    textlen = (int)(p - text);    /* length of the string */
                }
            }
            break;

            case 'n': {
                /* write count of characters seen so far into */
                /* short/int/long thru ptr read from args */

                void *p;            /* temp */

                p = get_ptr_arg(&argptr);

                /* store chars out into short/long/int depending on flags */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    *(long *)p = charsout;
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT)
                    *(short *)p = (short) charsout;
                else
#endif
                    *(int *)p = charsout;

                no_output = 1;              /* force no output */
            }
            break;


#ifndef NOFLOATS
            case 'E':
            case 'G':
                capexp = 1;                 /* capitalize exponent */
                ch += 'a' - 'A';            /* convert format char to lower */
                /* DROP THROUGH */
            case 'e':
            case 'f':
            case 'g':   {
                /* floating point conversion -- we call cfltcvt routines */
                /* to do the work for us.                                */
                flags |= FL_SIGNED;         /* floating point is signed conversion */
                text = buffer;              /* put result in buffer */
                flags &= ~FL_WIDE;          /* 8 bit string */

                /* compute the precision value */
                if (precision < 0)
                    precision = 6;      /* default precision: 6 */
                else if (precision == 0 && ch == 'g')
                    precision = 1;      /* ANSI specified */

#if !LONGDOUBLE_IS_DOUBLE
                /* do the conversion */
                if (flags & FL_LONGDOUBLE) {
                    _cldcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, LONGDOUBLE);
                }
                else
#endif
                {
                    _cfltcvt(argptr, text, ch, precision, capexp);
                    va_arg(argptr, DOUBLE);
                }

                /* '#' and precision == 0 means force a decimal point */
                if ((flags & FL_ALTERNATE) && precision == 0)
                    _forcdecpt(text);

                /* 'g' format means crop zero unless '#' given */
                if (ch == 'g' && !(flags & FL_ALTERNATE))
                    _cropzeros(text);

                /* check if result was negative, save '-' for later */
                /* and point to positive part (this is for '0' padding) */
                if (*text == '-') {
                    flags |= FL_NEGATIVE;
                    ++text;
                }

                textlen = strlen(text);     /* compute length of text */
            }
            break;
#endif // NOFLOATS

            case 'd':
            case 'i':
                /* signed decimal output */
                flags |= FL_SIGNED;
                radix = 10;
                goto COMMON_INT;

            case 'u':
                radix = 10;
                goto COMMON_INT;

            case 'p':
                /* write a pointer -- this is like an integer or long */
                /* except we force precision to pad with zeros and */
                /* output in big hex. */

                precision = 2 * sizeof(void *);     /* number of hex digits needed */
#if !PTR_IS_INT
                flags |= FL_LONG;       /* assume we're converting a long */
#endif
                /* DROP THROUGH to hex formatting */

            case 'C':
            case 'X':
                /* unsigned upper hex output */
                hexadd = 'A' - '9' - 1;     /* set hexadd for uppercase hex */
                goto COMMON_HEX;

            case 'x':
                /* unsigned lower hex output */
                hexadd = 'a' - '9' - 1;     /* set hexadd for lowercase hex */
                /* DROP THROUGH TO COMMON_HEX */

            COMMON_HEX:
                radix = 16;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means '0x' prefix */
                    prefix[0] = '0';
                    prefix[1] = (char)('x' - 'a' + '9' + 1 + hexadd);   /* 'x' or 'X' */
                    prefixlen = 2;
                }
                goto COMMON_INT;

            case 'o':
                /* unsigned octal output */
                radix = 8;
                if (flags & FL_ALTERNATE) {
                    /* alternate form means force a leading 0 */
                    flags |= FL_FORCEOCTAL;
                }
                /* DROP THROUGH to COMMON_INT */

            COMMON_INT: {
                /* This is the general integer formatting routine. */
                /* Basically, we get an argument, make it positive */
                /* if necessary, and convert it according to the */
                /* correct radix, setting text and textlen */
                /* appropriately. */

                unsigned long number;   /* number to convert */
                int digit;              /* ascii value of digit */
                long l;                 /* temp long value */

                /* 1. read argument into l, sign extend as needed */
#if !LONG_IS_INT
                if (flags & FL_LONG)
                    l = get_long_arg(&argptr);
                else
#endif

#if !SHORT_IS_INT
                if (flags & FL_SHORT) {
                    if (flags & FL_SIGNED)
                        l = (short) get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned short) get_int_arg(&argptr);    /* zero-extend*/
                }
                else
#endif
                {
                    if (flags & FL_SIGNED)
                        l = get_int_arg(&argptr); /* sign extend */
                    else
                        l = (unsigned int) get_int_arg(&argptr);    /* zero-extend*/
                }

                /* 2. check for negative; copy into number */
                if ( (flags & FL_SIGNED) && l < 0) {
                    number = -l;
                    flags |= FL_NEGATIVE;   /* remember negative sign */
                }
                else {
                    number = l;
                }

                /* 3. check precision value for default; non-default */
                /*    turns off 0 flag, according to ANSI. */
                if (precision < 0)
                    precision = 1;              /* default precision */
                else
                    flags &= ~FL_LEADZERO;

                /* 4. Check if data is 0; if so, turn off hex prefix */
                if (number == 0)
                    prefixlen = 0;

                /* 5. Convert data to ASCII -- note if precision is zero */
                /*    and number is zero, we get no digits at all.       */

                text = &buffer[BUFFERSIZE-1];   // last digit at end of buffer
                flags &= ~FL_WIDE;              // 8 bit characters

                while (precision-- > 0 || number != 0) {
                    digit = (int)(number % radix) + '0';
                    number /= radix;            /* reduce number */
                    if (digit > '9') {
                        /* a hex digit, make it a letter */
                        digit += hexadd;
                    }
                    *text-- = (char)digit;      /* store the digit */
                }

                textlen = (int)((char *)&buffer[BUFFERSIZE-1] - text); /* compute length of number */
                ++text;         /* text points to first digit now */


                /* 6. Force a leading zero if FORCEOCTAL flag set */
                if ((flags & FL_FORCEOCTAL) && (text[0] != '0' || textlen == 0)) {
                    *--text = '0';
                    ++textlen;          /* add a zero */
                }
            }
            break;
            }

            /* At this point, we have done the specific conversion, and */
            /* 'text' points to text to print; 'textlen' is length.  Now we */
            /* justify it, put on prefixes, leading zeros, and then */
            /* print it. */

            if (!no_output) {
                int padding;    /* amount of padding, negative means zero */

                if (flags & FL_SIGNED) {
                    if (flags & FL_NEGATIVE) {
                        /* prefix is a '-' */
                        prefix[0] = '-';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGN) {
                        /* prefix is '+' */
                        prefix[0] = '+';
                        prefixlen = 1;
                    }
                    else if (flags & FL_SIGNSP) {
                        /* prefix is ' ' */
                        prefix[0] = ' ';
                        prefixlen = 1;
                    }
                }

                /* calculate amount of padding -- might be negative, */
                /* but this will just mean zero */
                padding = fldwidth - textlen - prefixlen;

                /* put out the padding, prefix, and text, in the correct order */

                if (!(flags & (FL_LEFT | FL_LEADZERO))) {
                    /* pad on left with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* write prefix */
                writestring(prefix, prefixlen, f, &charsout, 0);

                if ((flags & FL_LEADZERO) && !(flags & FL_LEFT)) {
                    /* write leading zeros */
                    f->writechar('0', padding, f, &charsout);
                }

                /* write text */
                writestring(text, textlen, f, &charsout, flags & FL_WIDE);

                if (flags & FL_LEFT) {
                    /* pad on right with blanks */
                    f->writechar(' ', padding, f, &charsout);
                }

                /* we're done! */
            }
            break;
        }
    }

    return charsout;        /* return value = number of characters written */
}


/***
*int get_int_arg(va_list pargptr)
*
*Purpose:
*   Gets an int argument off the given argument list and updates *pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the integer argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(int) get_int_arg(va_list *pargptr)
{
    return va_arg(*pargptr, int);
}

/***
*long get_long_arg(va_list pargptr)
*
*Purpose:
*   Gets an long argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the long argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#if !LONG_IS_INT
LOCAL(long) get_long_arg(va_list *pargptr)
{
    return va_arg(*pargptr, long);
}
#endif


/***
void * get_ptr64_arg(va_list pargptr)
*
*Purpose:
*   Gets an 64-bit pointer argument off the given argument list and updates pargptr.
*
*Entry:
*   va_list pargptr - pointer to argument list; updated by function
*
*Exit:
*   Returns the ptr64 argument read from the argument list.
*
*Exceptions:
*
*******************************************************************************/


#ifdef _WIN64
LOCAL(void *) get_ptr64_arg(va_list *pargptr)
{
    return va_arg(*pargptr, void *__ptr64);
}
#endif  // _WIN64


/***
*void writestring(char *string, int len, struct w4io *f, int *pcchwritten, int fwide)
*
*Purpose:
*   Writes a string of the given length to the given file.  If no error occurs,
*   then *pcchwritten is incremented by len; otherwise, *pcchwritten is set
*   to -1.  If len is negative, it is treated as zero.
*
*Entry:
*   char *string     - string to write (NOT null-terminated)
*   int len          - length of string
*   struct w4io *f   - file to write to
*   int *pcchwritten - pointer to integer to update with total chars written
*   int fwide        - wide character flag
*
*Exit:
*   No return value.
*
*Exceptions:
*
*******************************************************************************/

LOCAL(void) writestring(
        char *string,
        int len,
        struct w4io *f,
        int *pcchwritten,
        int fwide)
{
    wchar_t *pwc;

    //printf("string: str=%.*s, len=%d, cch=%d, f=%d\n", len, string, len, *pcchwritten, fwide);
    if (fwide) {
        pwc = (wchar_t *) string;
        while (len-- > 0) {
            if (*pwc & 0xff00) {
                f->writechar('^', 1, f, pcchwritten);
            }
            f->writechar((char) *pwc++, 1, f, pcchwritten);
        }
    } else {
        while (len-- > 0) {
            f->writechar(*string++, 1, f, pcchwritten);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\w4io.h ===
/***
*w4io.h - fake FILE structure for Win 4 printf/sprintf/debug printf support
*
*  History: ??-???-??  ?????     Created
*           14-Mar-94  DonCl     stolen from Cairo common project for use
*                                with Forms - allows us to have our own
*                                debug print facility exclusive of commnot.dll
*                                enabling us to build and run on Daytona.
*
*/

struct w4io
{
    union
    {
    struct
    {
        wchar_t *_pwcbuf;    // wchar_t output buffer
        wchar_t *_pwcstart;
    } wc;
    struct
    {
        char *_pchbuf;    // char output buffer
        char *_pchstart;
    } ch;
    } buf ;
    unsigned int cchleft;    // output buffer character count
    void (_cdecl *writechar)(int ch,
                 int num,
                 struct w4io *f,
                 int *pcchwritten);
};

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\symtrans.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1992.
//
//  File:       symtrans.h
//
//  Contents:   Definitions associated with address->symbol translation
//
//  History:    17-Jul-92       MikeSe  Created
//              22-Jun-93  BryanT  Increased MAX_TRANS value to account for
//                                  Line/File information.
//
//----------------------------------------------------------------------------

#ifndef __SYMTRANS_H__
#define __SYMTRANS_H__

//
// The following function provides translation of function addresses into
// symbolic (NTSD-style) names. It is only available if ANYSTRICT is defined.
// (see common\src\commnot\symtrans.c)

# ifdef __cplusplus
extern "C" {
# endif

EXPORTDEF void APINOT
TranslateAddress (
    void * pvAddress,               // address to translate
    char * pchBuffer );             // output buffer

// The output buffer should allocated by the caller, and be at least
// the following size:

#define NT_SYM_ENV              "_NT_SYMBOL_PATH"
#define NT_ALT_SYM_ENV          "_NT_ALT_SYMBOL_PATH"
#define SYS_ENV                 "SystemRoot"

#define IMAGEHLP_DLL            "imagehlp.dll"
#define MAP_DBG_INFO_CALL       "MapDebugInformation"

#define MAX_TRANSLATED_LEN      600

# ifdef __cplusplus
}
# endif

#endif  // of ifndef __SYMTRANS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\sysmem.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1992, Microsoft Corporation.
//
//  File:          SysMem.CXX
//
//  Contents:   System Memory Management routines
//
//  Functions:  MemAlloc, MemFree, MemAllocLinked
//
//  History:    10-Feb-92   AlexT   Created
//        07-May-92   MikeSe  Converted to using Win32 Heap functions.
//        14-Jul-92   randyd  Added MemSwitchRoot, see memmgmt.doc.
//        5-Oct-93    isaache Slight reorganization, conversion to 'new'
//        13-Jul-94   doncl   stole from ole32, put in ADs proj, deleted
//                            MemSwitchRoot, switched to naked
//                            Win32 CRITICAL_SECTION usage
//
//  Notes:        For additional information, see win4adm\standrds\memmgmt.doc.
//
//                This memory management package is multithread capable - the
//                only place it makes a difference is in MemAllocLinked and
//                MemSwitchRoot, where we use a critical section t
//                protect adding link blocks to the list. We rely on the fact
//                that LocalAlloc is multi-thread safe.
//
//--------------------------------------------------------------------------

#include "dswarn.h"
#include <ADs.hxx>

#if 0
#include <excpt.h>
#include <except.hxx>
#include <dllsem.hxx>
#endif

CRITICAL_SECTION g_csMem;

//  Memory block prefix (for signature and link)

typedef struct _smheader
{
    unsigned long      ulSignature;
    struct _smheader   *psmNext;
} SMHEADER, *PSMHEADER;


//  Memory block signatures (for strict checks)

const ULONG ROOT_BLOCK          = 0x726f6f74;     // 'root'
const ULONG LINKED_BLOCK        = 0x6c696e6b;     // 'link'

static BOOL
VerifySignature(PSMHEADER psm, ULONG ulSig )
{
    BOOL fReturn;

    __try
    {
        fReturn = (ulSig == psm->ulSignature );
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        fReturn = FALSE;
    }

    return fReturn;
}

// This module acts as the declarer of debug support symbols for COMMNOT
DECLARE_INFOLEVEL(Cn);



//+-------------------------------------------------------------------------
//
//  Function:   MemAlloc
//
//  Synopsis:   allocates memory block
//
//  Arguments:  [ulSize]                -- size of block in bytes
//                        [ppv]            -- output pointer
//
//  Returns:    status code
//
//  Algorithm:  call new, adding space for header
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemAlloc ( unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm;

    *ppv = NULL;

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm != NULL )
    {
        psm->ulSignature = ROOT_BLOCK;
        psm->psmNext = NULL;

        *ppv = psm + 1;
        return S_OK;
    }
    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemFree
//
//  Synopsis:   release system memory block
//
//  Arguments:  [pvBlockToFree] -- memory block to release
//
//  Algorithm:  Walk list of linked blocks, deleting each one
//
//  History:    10-Feb-92 AlexT  Created
//
//--------------------------------------------------------------------------

HRESULT
MemFree( void *pvBlockToFree )
{
    PSMHEADER psm = ((PSMHEADER) pvBlockToFree) - 1;

    if( pvBlockToFree == NULL || psm == NULL )
        return S_OK;

    if( !VerifySignature( psm, ROOT_BLOCK ) )
    {
        Win4Assert( !"MemFree -- not a root block!\n" );
        return MEM_E_INVALID_ROOT;
    }

    do {
        PSMHEADER psmNext = psm->psmNext;

        psm->ulSignature = 0;
        LocalFree(psm);
        psm = psmNext;
        if( psm && !VerifySignature( psm, LINKED_BLOCK ) )
        {
            Win4Assert( !"MemFree -- invalid linked block!\n" );
            return MEM_E_INVALID_LINK;
        }
    } while( psm != NULL );

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Function:   MemAllocLinked
//
//  Synopsis:   allocates linked memory block
//
//
//  Arguments:  [pvRootBlock]   -- root memory block
//                        [ulSize]              -- size of new memory block
//                        [ppv]            -- output pointer
//
//  Returns:   status code
//
//
//  History:    10-Feb-92 AlexT  Created
//
//  Notes:        pvRootBlock can specify either a root block, or another
//                        linked block.
//
//--------------------------------------------------------------------------

HRESULT
MemAllocLinked ( void *pvRootBlock, unsigned long ulSize, void ** ppv )
{
    PSMHEADER psm = NULL;
    PSMHEADER psmRoot = ((PSMHEADER) pvRootBlock) - 1;

    *ppv = NULL;

    if ( pvRootBlock == NULL || psmRoot == NULL )
    {
        Win4Assert( !"MemAllocLinked - null root block\n" );
        return MEM_E_INVALID_ROOT;
    }


    if ( !VerifySignature(psmRoot, ROOT_BLOCK)
       && !VerifySignature(psmRoot,LINKED_BLOCK) )
    {
        Win4Assert( !"MemAllocLinked - invalid root block\n" );
        return MEM_E_INVALID_ROOT;
    }

    psm = (PSMHEADER) LocalAlloc(LMEM_FIXED, ulSize + sizeof(SMHEADER));
    if ( psm == NULL )
        return E_OUTOFMEMORY;

    psm->ulSignature = LINKED_BLOCK;

    EnterCriticalSection(&g_csMem);
    psm->psmNext = psmRoot->psmNext;
    psmRoot->psmNext = psm;
    LeaveCriticalSection(&g_csMem);

    //  move psm past header
    *ppv = psm+1;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\nocairo\printf.h ===
/**
*printf.h - print formatted
*
*       Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*       defines w4*printf() - print formatted data
*       defines w4v*printf() - print formatted output, get data from an
*                              argument ptr instead of explicit args.
*
*Revision History:
*       09-02-83  RN    original sprintf
*       06-17-85  TC    rewrote to use new varargs macros, and to be vsprintf
*       04-13-87  JCR   added const to declaration
*       11-07-87  JCR   Multi-thread support
*       12-11-87  JCR   Added "_LOAD_DS" to declaration
*       05-27-88  PHG   Merged DLL and normal versions
*       06-13-88  JCR   Fake _iob entry is now static so that other routines
*                       can assume _iob entries are in DGROUP.
*       08-25-88  GJF   Define MAXSTR to be INT_MAX (from LIMITS.H).
*       06-06-89  JCR   386 mthread support
*       08-18-89  GJF   Clean up, now specific to OS/2 2.0 (i.e., 386 flat
*                       model). Also fixed copyright and indents.
*       02-16-90  GJF   Fixed copyright
*       14-Mar-94 DonCl stolen from common project for use with Forms so
*                       we can build on Daytona without linking to commnot.
*
*******************************************************************************/

#include <wchar.h>
#include <stdarg.h>
#include <limits.h>
#include <sys\types.h>

#define _W4DPRINTF_
#include <w4io.h>

#define pwcbuf        buf.wc._pwcbuf
#define pwcstart    buf.wc._pwcstart
#define pchbuf        buf.ch._pchbuf
#define pchstart    buf.ch._pchstart

#define REG1 register
#define REG2 register

/* prototypes */
#ifdef __cplusplus
extern "C" {
#endif
int _cdecl w4iooutput(struct w4io *stream, const char *format, va_list argptr);
#ifdef __cplusplus
}
#endif



#if defined(_W4PRINTF_)
    static long fh;
//    extern long GetStdHandle(long);
//    extern void WriteFile(long fh, char *s, long cch, long * pcchret, long);
#   define _PRINTF_
#elif defined(_W4DPRINTF_)
#   define _pwritechar  _dwritechar
#   define _pflushbuf   _dflushbuf
#   define w4printf     w4dprintf
#   define w4vprintf    w4vdprintf
#   define _PRINTF_
#elif defined(_W4SPRINTF_)
#   define _pwritechar  _swritechar
#   define w4printf     w4sprintf
#   define w4vprintf    w4vsprintf
#elif defined(_W4WCSPRINTF_)
#   define _TCHAR_      wchar_t
#   define _PBUF_       pwcbuf
#   define _PSTART_     pwcstart
#   define w4printf     w4wcsprintf
#   define w4vprintf    w4vwcsprintf
#   define _pwritechar  _wwritechar
#else
#   error configuration problem
#endif

#ifndef _TCHAR_
#  define _TCHAR_       char
#  define _PBUF_        pchbuf
#  define _PSTART_      pchstart
#endif


#ifdef _PRINTF_
#   ifdef WIN32
#     undef  OutputDebugString
#     define OutputDebugString OutputDebugStringA
#   else
      extern void _pascal OutputDebugString(char *);
#   endif
    int _cdecl _pflushbuf(struct w4io *f);
#   define SPR(a)
#   define MAXSTR       128
#else
#   define SPR(a)       a,
#   define MAXSTR       INT_MAX
#endif

void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten);
int _cdecl w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist);


/***
*int w4printf(format, ...) - print formatted data
*
*Purpose:
*       Prints formatted data using the format string to
*       format data and getting as many arguments as called for
*       Sets up a w4io so file i/o operations can be used.
*       w4iooutput does the real work here
*
*Entry:
*       char *format - format string to control data format/number
*       of arguments followed by list of arguments, number and type
*       controlled by format string
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/


int _cdecl
w4printf(SPR(_TCHAR_ *string) const char *format, ...)
/*
 * 'PRINT', 'F'ormatted
 */
{
    va_list arglist;

    va_start(arglist, format);
    return(w4vprintf(SPR(string) format, arglist));
}


/***
*int w4vprintf(format, arglist) - print formatted data from arg ptr
*
*Purpose:
*       Prints formatted data, but gets data from an argument pointer.
*       Sets up a w4io so file i/o operations can be used, make string look
*       like a huge buffer to it, but _flsbuf will refuse to flush it if it
*       fills up. Appends '\0' to make it a true string.
*
*       Multi-thread: (1) Since there is no stream, this routine must never try
*       to get the stream lock (i.e., there is no stream lock either).  (2)
*       Also, since there is only one staticly allocated 'fake' iob, we must
*       lock/unlock to prevent collisions.
*
*Entry:
*       char *format    - format string, describes format of data
*       va_list arglist - varargs argument pointer
*
*Exit:
*       returns number of characters written
*
*Exceptions:
*
*******************************************************************************/

int _cdecl
w4vprintf(SPR(_TCHAR_ *string) const char *format, va_list arglist)
/*
 * 'V'ariable argument 'PRINT', 'F'ormatted
 */
{
    struct w4io outfile;
    register int retval;
#ifdef _PRINTF_
    char string[MAXSTR + 1];            // leave room for null termination
#else
    int dummy;
#endif

#ifdef _W4PRINTF_
    long ldummy;

    if (fh == 0 || fh == -1)
    {
        ldummy = -11;                   // C7 bug workaround
        if ((fh = (long)GetStdHandle(ldummy)) == 0 || fh == -1)
        {
            OutputDebugString("GetStdHandle in " __FILE__ " failed\n");
            return(-1);
        }
    }
#endif

    outfile._PBUF_ = outfile._PSTART_ = string;
    outfile.cchleft = MAXSTR;
    outfile.writechar = _pwritechar;

    retval = w4iooutput(&outfile, format, arglist);

#ifdef _PRINTF_
    if (_pflushbuf(&outfile) == -1) {
        return(-1);
    }
#else
    _pwritechar('\0', 1, &outfile, &dummy);
#endif
    return(retval);
}


void _cdecl _pwritechar(int ch, int num, struct w4io *f, int *pcchwritten)
{
    //printf("  char: ch=%c, cnt=%d, cch=%d\n", ch, num, *pcchwritten);
    while (num-- > 0) {
#ifdef _PRINTF_
        if (f->cchleft < 2 && _pflushbuf(f) == -1) {
            *pcchwritten = -1;
            return;
        }
#endif
#ifdef _W4DPRINTF_
#  ifndef FLAT
        if (ch == '\n')
        {
            *f->_PBUF_++ = '\r';
            f->cchleft--;
            (*pcchwritten)++;
        }
#  endif
#endif
        *f->_PBUF_++ = (char) ch;
        f->cchleft--;
        (*pcchwritten)++;
    }
}


#ifdef _PRINTF_
int _cdecl _pflushbuf(struct w4io *f)
{
    int cch;

    if ((cch = (int)(f->pchbuf - f->pchstart)))
    {
#ifdef _W4DPRINTF_
        *f->pchbuf = '\0';              // null terminate
        OutputDebugString(f->pchstart);
#else
        long cchret;

        //*f->pchbuf = '\0';            // null terminate
        //printf("%d chars: \"%s\"\n", cch, f->pchstart);
        WriteFile((HANDLE)fh, f->pchstart, cch, &cchret, 0);
        if (cch != cchret)
        {
            OutputDebugString("WriteFile in " __FILE__ " failed\n");
            return(-1);
        }
#endif
        f->pchbuf -= cch;               // reset pointer
        f->cchleft += cch;              // reset count
    }
    return(0);
}
#endif // _PRINTF_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\noole\creden.cxx ===
/*++


Copyright (c) 1990  Microsoft Corporation

Module Name:

    creden.cxx

Abstract:

    This module abstracts user credentials for the multiple credential support.

Author:

    Krishna Ganugapati (KrishnaG) 03-Aug-1996

Revision History:

--*/

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <stdio.h>
#include <stdlib.h>
#include "memory.h"
#include <wincrypt.h>
}

#include <basetyps.h>

typedef  long HRESULT;

#include "misc.hxx"
#include "creden.hxx"

CCredentials::CCredentials():
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwMaxLen(0)
{
}

CCredentials::CCredentials(
    LPWSTR lpszUserName,
    LPWSTR lpszPassword,
    DWORD dwAuthFlags
    ):
    _lpszUserName(NULL),
    _lpszPassword(NULL),
    _dwAuthFlags(0),
    _dwMaxLen(0)
{
    if (lpszUserName) {
        _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    }else {
        _lpszUserName = NULL;
    }

    if (lpszPassword) {
        SetPassword(lpszPassword);
    }
    else 
    {
        _lpszPassword = NULL;
        _dwMaxLen = 0;
    }

    _dwAuthFlags = dwAuthFlags;
}

CCredentials::~CCredentials()
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsMem(_lpszPassword);
    }

}

HRESULT
CCredentials::GetUserName(
    LPWSTR *lppszUserName
    )
{
    if (!lppszUserName) {
        RRETURN(E_FAIL);
    }


    if (!_lpszUserName) {
        *lppszUserName = NULL;
    }else {

        *lppszUserName = AllocADsStr(_lpszUserName);

        if (!*lppszUserName) {

            RRETURN(E_OUTOFMEMORY);
        }

    }

    RRETURN(S_OK);
}

HRESULT
CCredentials::GetPassword(
    LPWSTR * lppszPassword
    ) const
{
    if (!lppszPassword) {
        RRETURN(E_FAIL);
    }

    if (!_lpszPassword) {
        *lppszPassword = NULL;
    }
    
    else 
    {
        LPWSTR lpszTemp = (LPWSTR)AllocADsMem(_dwMaxLen);
        if (!lpszTemp)
        {
            RRETURN(E_FAIL);
        }
        memcpy(lpszTemp, _lpszPassword, _dwMaxLen);
        CryptUnprotectMemory(lpszTemp, _dwMaxLen, CRYPTPROTECTMEMORY_SAME_PROCESS);
        *lppszPassword = lpszTemp;
    }

    RRETURN(S_OK);
}

HRESULT
CCredentials::SetUserName(
    LPWSTR lpszUserName
    )
{
    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (!lpszUserName) {

        _lpszUserName = NULL;
        RRETURN(S_OK);
    }

    _lpszUserName = AllocADsStr(
                        lpszUserName
                        );
    if(!_lpszUserName) {
        RRETURN(E_FAIL);
    }

    RRETURN(S_OK);
}

HRESULT
CCredentials::SetPassword(
    LPWSTR lpszPassword
    )
{
    if (_lpszPassword) {
        FreeADsMem(_lpszPassword);
    }

    if (!lpszPassword) {
        _lpszPassword = NULL;
        _dwMaxLen = 0;
        RRETURN(S_OK);
    }

    DWORD dwLen    = (wcslen(lpszPassword) + 1) * sizeof(WCHAR);
    DWORD dwPadLen = CRYPTPROTECTMEMORY_BLOCK_SIZE - (dwLen % CRYPTPROTECTMEMORY_BLOCK_SIZE);

    if( dwPadLen == CRYPTPROTECTMEMORY_BLOCK_SIZE )
    {
        dwPadLen = 0;
    }
    
    _dwMaxLen = dwLen + dwPadLen; 
    
    _lpszPassword = (LPWSTR)AllocADsMem(_dwMaxLen);

    if(!_lpszPassword) {
        _dwMaxLen = 0;
        RRETURN(E_FAIL);
    }

    wcscpy(_lpszPassword, lpszPassword);
    BOOL bOK = CryptProtectMemory(_lpszPassword, _dwMaxLen, CRYPTPROTECTMEMORY_SAME_PROCESS);

    if (bOK == TRUE)
    {
        RRETURN(S_OK);        
    }
    else
    {
        RRETURN(E_FAIL);
    }
}

CCredentials::CCredentials(
    const CCredentials& Credentials
    )
{
    LPWSTR pTempPass;

    _lpszUserName = NULL;
    _lpszPassword = NULL;

    _lpszUserName = AllocADsStr(
                        Credentials._lpszUserName
                        );

    Credentials.GetPassword(&pTempPass);
    if (pTempPass)
    {
        SetPassword(pTempPass);
        SecureZeroMemory(pTempPass, wcslen(pTempPass)*sizeof(WCHAR));
        FreeADsMem(pTempPass);
    }

    _dwAuthFlags = Credentials._dwAuthFlags;

}


void
CCredentials::operator=(
    const CCredentials& other
    )
{
    LPWSTR pTempPass;

    if ( &other == this) {
        return;
    }

    if (_lpszUserName) {
        FreeADsStr(_lpszUserName);
    }

    if (_lpszPassword) {
        FreeADsMem(_lpszPassword);
    }

    _lpszUserName = AllocADsStr(
                        other._lpszUserName
                        );

    other.GetPassword(&pTempPass);
    if (pTempPass)
    {
        SetPassword(pTempPass);
        SecureZeroMemory(pTempPass, wcslen(pTempPass)*sizeof(WCHAR));
        FreeADsMem(pTempPass);
    }

    _dwAuthFlags = other._dwAuthFlags;

    return;
}


BOOL
operator==(
    CCredentials& x,
    CCredentials& y
    )
{
    BOOL bEqualUser = FALSE;
    BOOL bEqualPassword = FALSE;
    BOOL bEqualFlags = FALSE;

    LPWSTR lpszXPassword = NULL;
    LPWSTR lpszYPassword = NULL;
    BOOL bReturnCode = FALSE;
    HRESULT hr = S_OK;


    if (x._lpszUserName &&  y._lpszUserName) {
        bEqualUser = !(wcscmp(x._lpszUserName, y._lpszUserName));
    }else  if (!x._lpszUserName && !y._lpszUserName){
        bEqualUser = TRUE;
    }

    hr = x.GetPassword(&lpszXPassword);
    if (FAILED(hr)) {
        goto error;
    }

    hr = y.GetPassword(&lpszYPassword);
    if (FAILED(hr)) {
        goto error;
    }


    if ((lpszXPassword && lpszYPassword)) {
        bEqualPassword = !(wcscmp(lpszXPassword, lpszYPassword));
    }else if (!lpszXPassword && !lpszYPassword) {
        bEqualPassword = TRUE;
    }


    if (x._dwAuthFlags == y._dwAuthFlags) {
        bEqualFlags = TRUE;
    }


    if (bEqualUser && bEqualPassword && bEqualFlags) {

       bReturnCode = TRUE;
    }


error:

    if (lpszXPassword) {
        FreeADsMem(lpszXPassword);
    }

    if (lpszYPassword) {
        FreeADsMem(lpszYPassword);
    }

    return(bReturnCode);

}


BOOL
CCredentials::IsNullCredentials(
    )
{
    // The function will return true even if the flags are set
    // this is because we want to try and get the default credentials
    // even if the flags were set
     if (!_lpszUserName && !_lpszPassword) {
         return(TRUE);
     }else {
         return(FALSE);
     }

}


DWORD
CCredentials::GetAuthFlags()
{
    return(_dwAuthFlags);
}


void
CCredentials::SetAuthFlags(
    DWORD dwAuthFlags
    )
{
    _dwAuthFlags = dwAuthFlags;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\noole\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

extern "C" {
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <basetyps.h>

#include "dswarn.h"
#include "oledsdbg.h"
}

#if (defined(BUILD_FOR_NT40))
typedef unsigned long HRESULT;
#endif



static HRESULT ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r);

#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   PrintHRESULT
//
//  Synopsis:   Outputs the name of the SCODE and a carriage return
//              to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI
PrintHRESULT(DWORD dwFlags, HRESULT hr)
{
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, " "));
    ADsDebugOutHRESULT(dwFlags | DEB_NOCOMPNAME, hr);
    ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "\n"));

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   ADsDebugOutHRESULT
//
//  Synopsis:   Outputs the name of the SCODE to the debugging device.
//
//  Arguments:  [dwFlags] -- Flags to ADsDebugOut.
//              [scode]   -- The status code to report.
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

static HRESULT
ADsDebugOutHRESULT(DWORD dwFlags, HRESULT r)
{
    LPWSTR lpstr;

#define CASE_SCODE(sc)  \
        case sc: lpstr = (LPWSTR)L#sc; break;

    switch (r) {
        /* SCODE's defined in SCODE.H */
        CASE_SCODE(S_OK)
        CASE_SCODE(S_FALSE)
        CASE_SCODE(OLE_S_USEREG)
        CASE_SCODE(OLE_S_STATIC)
        CASE_SCODE(OLE_S_MAC_CLIPFORMAT)
        CASE_SCODE(DRAGDROP_S_DROP)
        CASE_SCODE(DRAGDROP_S_USEDEFAULTCURSORS)
        CASE_SCODE(DRAGDROP_S_CANCEL)
        CASE_SCODE(DATA_S_SAMEFORMATETC)
        CASE_SCODE(VIEW_S_ALREADY_FROZEN)
        CASE_SCODE(CACHE_S_FORMATETC_NOTSUPPORTED)
        CASE_SCODE(CACHE_S_SAMECACHE)
        CASE_SCODE(CACHE_S_SOMECACHES_NOTUPDATED)
        CASE_SCODE(OLEOBJ_S_INVALIDVERB)
        CASE_SCODE(OLEOBJ_S_CANNOT_DOVERB_NOW)
        CASE_SCODE(OLEOBJ_S_INVALIDHWND)
        CASE_SCODE(INPLACE_S_TRUNCATED)
        CASE_SCODE(CONVERT10_S_NO_PRESENTATION)
        CASE_SCODE(MK_S_REDUCED_TO_SELF)
        CASE_SCODE(MK_S_ME)
        CASE_SCODE(MK_S_HIM)
        CASE_SCODE(MK_S_US)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
        CASE_SCODE(STG_S_CONVERTED)

        CASE_SCODE(E_UNEXPECTED)
        CASE_SCODE(E_NOTIMPL)
        CASE_SCODE(E_OUTOFMEMORY)
        CASE_SCODE(E_INVALIDARG)
        CASE_SCODE(E_NOINTERFACE)
        CASE_SCODE(E_POINTER)
        CASE_SCODE(E_HANDLE)
        CASE_SCODE(E_ABORT)
        CASE_SCODE(E_FAIL)
        CASE_SCODE(E_ACCESSDENIED)

        /* SCODE's defined in DVOBJ.H */
        // CASE_SCODE(DATA_E_FORMATETC)
// same as DATA_E_FORMATETC     CASE_SCODE(DV_E_FORMATETC)
        CASE_SCODE(VIEW_E_DRAW)
//  same as VIEW_E_DRAW         CASE_SCODE(E_DRAW)
        CASE_SCODE(CACHE_E_NOCACHE_UPDATED)

        /* SCODE's defined in OLE2.H */
        CASE_SCODE(OLE_E_OLEVERB)
        CASE_SCODE(OLE_E_ADVF)
        CASE_SCODE(OLE_E_ENUM_NOMORE)
        CASE_SCODE(OLE_E_ADVISENOTSUPPORTED)
        CASE_SCODE(OLE_E_NOCONNECTION)
        CASE_SCODE(OLE_E_NOTRUNNING)
        CASE_SCODE(OLE_E_NOCACHE)
        CASE_SCODE(OLE_E_BLANK)
        CASE_SCODE(OLE_E_CLASSDIFF)
        CASE_SCODE(OLE_E_CANT_GETMONIKER)
        CASE_SCODE(OLE_E_CANT_BINDTOSOURCE)
        CASE_SCODE(OLE_E_STATIC)
        CASE_SCODE(OLE_E_PROMPTSAVECANCELLED)
        CASE_SCODE(OLE_E_INVALIDRECT)
        CASE_SCODE(OLE_E_WRONGCOMPOBJ)
        CASE_SCODE(OLE_E_INVALIDHWND)
        CASE_SCODE(DV_E_DVTARGETDEVICE)
        CASE_SCODE(DV_E_STGMEDIUM)
        CASE_SCODE(DV_E_STATDATA)
        CASE_SCODE(DV_E_LINDEX)
        CASE_SCODE(DV_E_TYMED)
        CASE_SCODE(DV_E_CLIPFORMAT)
        CASE_SCODE(DV_E_DVASPECT)
        CASE_SCODE(DV_E_DVTARGETDEVICE_SIZE)
        CASE_SCODE(DV_E_NOIVIEWOBJECT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_GET)
        CASE_SCODE(CONVERT10_E_OLESTREAM_PUT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_FMT)
        CASE_SCODE(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB)
        CASE_SCODE(CONVERT10_E_STG_FMT)
        CASE_SCODE(CONVERT10_E_STG_NO_STD_STREAM)
        CASE_SCODE(CONVERT10_E_STG_DIB_TO_BITMAP)
        CASE_SCODE(CLIPBRD_E_CANT_OPEN)
        CASE_SCODE(CLIPBRD_E_CANT_EMPTY)
        CASE_SCODE(CLIPBRD_E_CANT_SET)
        CASE_SCODE(CLIPBRD_E_BAD_DATA)
        CASE_SCODE(CLIPBRD_E_CANT_CLOSE)
        CASE_SCODE(DRAGDROP_E_NOTREGISTERED)
        CASE_SCODE(DRAGDROP_E_ALREADYREGISTERED)
        CASE_SCODE(DRAGDROP_E_INVALIDHWND)
        CASE_SCODE(OLEOBJ_E_NOVERBS)
        CASE_SCODE(INPLACE_E_NOTUNDOABLE)
        CASE_SCODE(INPLACE_E_NOTOOLSPACE)

        /* SCODE's defined in STORAGE.H */
        CASE_SCODE(STG_E_INVALIDFUNCTION)
        CASE_SCODE(STG_E_FILENOTFOUND)
        CASE_SCODE(STG_E_PATHNOTFOUND)
        CASE_SCODE(STG_E_TOOMANYOPENFILES)
        CASE_SCODE(STG_E_ACCESSDENIED)
        CASE_SCODE(STG_E_INVALIDHANDLE)
        CASE_SCODE(STG_E_INSUFFICIENTMEMORY)
        CASE_SCODE(STG_E_INVALIDPOINTER)
        CASE_SCODE(STG_E_NOMOREFILES)
        CASE_SCODE(STG_E_DISKISWRITEPROTECTED)
        CASE_SCODE(STG_E_SEEKERROR)
        CASE_SCODE(STG_E_WRITEFAULT)
        CASE_SCODE(STG_E_READFAULT)
        CASE_SCODE(STG_E_LOCKVIOLATION)
        CASE_SCODE(STG_E_FILEALREADYEXISTS)
        CASE_SCODE(STG_E_INVALIDPARAMETER)
        CASE_SCODE(STG_E_MEDIUMFULL)
        CASE_SCODE(STG_E_ABNORMALAPIEXIT)
        CASE_SCODE(STG_E_INVALIDHEADER)
        CASE_SCODE(STG_E_INVALIDNAME)
        CASE_SCODE(STG_E_UNKNOWN)
        CASE_SCODE(STG_E_UNIMPLEMENTEDFUNCTION)
        CASE_SCODE(STG_E_INVALIDFLAG)
        CASE_SCODE(STG_E_INUSE)
        CASE_SCODE(STG_E_NOTCURRENT)
        CASE_SCODE(STG_E_REVERTED)
        CASE_SCODE(STG_E_CANTSAVE)
        CASE_SCODE(STG_E_OLDFORMAT)
        CASE_SCODE(STG_E_OLDDLL)
        CASE_SCODE(STG_E_SHAREREQUIRED)

        /* SCODE's defined in COMPOBJ.H */
        CASE_SCODE(CO_E_NOTINITIALIZED)
        CASE_SCODE(CO_E_ALREADYINITIALIZED)
        CASE_SCODE(CO_E_CANTDETERMINECLASS)
        CASE_SCODE(CO_E_CLASSSTRING)
        CASE_SCODE(CO_E_IIDSTRING)
        CASE_SCODE(CO_E_APPNOTFOUND)
        CASE_SCODE(CO_E_APPSINGLEUSE)
        CASE_SCODE(CO_E_ERRORINAPP)
        CASE_SCODE(CO_E_DLLNOTFOUND)
        CASE_SCODE(CO_E_ERRORINDLL)
        CASE_SCODE(CO_E_WRONGOSFORAPP)
        CASE_SCODE(CO_E_OBJNOTREG)
        CASE_SCODE(CO_E_OBJISREG)
        CASE_SCODE(CO_E_OBJNOTCONNECTED)
        CASE_SCODE(CO_E_APPDIDNTREG)
        CASE_SCODE(CLASS_E_NOAGGREGATION)
        CASE_SCODE(REGDB_E_READREGDB)
        CASE_SCODE(REGDB_E_WRITEREGDB)
        CASE_SCODE(REGDB_E_KEYMISSING)
        CASE_SCODE(REGDB_E_INVALIDVALUE)
        CASE_SCODE(REGDB_E_CLASSNOTREG)
        CASE_SCODE(REGDB_E_IIDNOTREG)
        CASE_SCODE(RPC_E_CALL_REJECTED)
        CASE_SCODE(RPC_E_CALL_CANCELED)
        CASE_SCODE(RPC_E_CANTPOST_INSENDCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INASYNCCALL)
        CASE_SCODE(RPC_E_CANTCALLOUT_INEXTERNALCALL)
        CASE_SCODE(RPC_E_CONNECTION_TERMINATED)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(RPC_E_SERVER_DIED)
#endif // NO_NTOLEBUGS
        CASE_SCODE(RPC_E_CLIENT_DIED)
        CASE_SCODE(RPC_E_INVALID_DATAPACKET)
        CASE_SCODE(RPC_E_CANTTRANSMIT_CALL)
        CASE_SCODE(RPC_E_CLIENT_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_CLIENT_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTMARSHAL_DATA)
        CASE_SCODE(RPC_E_SERVER_CANTUNMARSHAL_DATA)
        CASE_SCODE(RPC_E_INVALID_DATA)
        CASE_SCODE(RPC_E_INVALID_PARAMETER)
        CASE_SCODE(RPC_E_UNEXPECTED)

        /* SCODE's defined in MONIKER.H */
        CASE_SCODE(MK_E_CONNECTMANUALLY)
        CASE_SCODE(MK_E_EXCEEDEDDEADLINE)
        CASE_SCODE(MK_E_NEEDGENERIC)
        CASE_SCODE(MK_E_UNAVAILABLE)
        CASE_SCODE(MK_E_SYNTAX)
        CASE_SCODE(MK_E_NOOBJECT)
        CASE_SCODE(MK_E_INVALIDEXTENSION)
        CASE_SCODE(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED)
        CASE_SCODE(MK_E_NOTBINDABLE)
        CASE_SCODE(MK_E_NOTBOUND)
        CASE_SCODE(MK_E_CANTOPENFILE)
        CASE_SCODE(MK_E_MUSTBOTHERUSER)
        CASE_SCODE(MK_E_NOINVERSE)
        CASE_SCODE(MK_E_NOSTORAGE)
#if defined(NO_NTOLEBUGS)
        CASE_SCODE(MK_S_MONIKERALREADYREGISTERED)
#endif //NO_NTOLEBUGS


        // Dispatch error codes
        CASE_SCODE(DISP_E_MEMBERNOTFOUND)

        default:
            ADsDebugOut((dwFlags, "<UNKNOWN SCODE  0x%lx>", r));
            return r;
    }

#undef CASE_SCODE

    ADsDebugOut((dwFlags, "<%ws (0x%lx)>", lpstr, r));
    return r;
}



//+---------------------------------------------------------------------------
//
//  Function:   BreakOnFailed
//
//  Synopsis:   Function called when CheckAndReturnResult or CheckResult
//              examines a failure code.  Set a breakpoint on this function
//              to break on failures.
//
//  History:    5-18-94   adams   Created
//
//----------------------------------------------------------------------------

static void
BreakOnFailed(void)
{
    int x;
    x = 1;
}


//+---------------------------------------------------------------
//
//  Function:   CheckAndReturnResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure,
//              and asserts if the HRESULT is not a permitted success code.
//
//  Arguments:  [hr]        -- the HRESULT to be checked.
//              [lpstrFile] -- the file where the HRESULT is being checked.
//              [line]      -- the line in the file where the HRESULT is
//                              being checked.
//              [cSuccess]  -- the number of permitted non-zero success codes.
//              [...]       -- list of success codes.
//
//  Returns:    The return value is exactly the HRESULT passed in.
//
//  History:    1-06-94   adams   Created.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  Use
//              the SRETURN and RRETURN macros instead.
//
//----------------------------------------------------------------

STDAPI
CheckAndReturnResult(
        HRESULT hr,
        LPSTR   lpstrFile,
        UINT    line,
        int     cSuccess,
        ...)
{
    BOOL    fOKReturnCode;
    va_list va;
    int     i;
    HRESULT hrSuccess;

    //
    // Check if code is an error or permitted success.
    //

    fOKReturnCode = (FAILED(hr) || hr == S_OK || hr == S_FALSE ||
                     cSuccess == -1);
    if (!fOKReturnCode && cSuccess > 0)
    {
        va_start(va, cSuccess);
        for (i = 0; i < cSuccess; i++)
        {
            hrSuccess = va_arg(va, HRESULT);
            ADsAssert(SUCCEEDED(hrSuccess));
            if (hr == hrSuccess)
            {
                fOKReturnCode = TRUE;
                break;
            }
        }

        va_end(va);
    }

    //
    // Assert on non-permitted success code.
    //

    if (!fOKReturnCode)
    {
/* ADsDebugOut((
                DEB_ERROR,
                "ERROR: %s:%d returned bad success code",
                lpstrFile,
                line)); */

        // (void) PrintHRESULT(DEB_ERROR | DEB_NOCOMPNAME, hr);

        //
        // I've removed the Assert but we should enable this
        // to monitor all functions that are returning S_FALSE
        // As far as possible, functions should not return
        // S_FALSE except for the Next function of an Enumerator
        // object.

        // ADsAssert(0 && "An unpermitted success code was returned.");
    }

    //
    // Warn on error result.
    //

    if (FAILED(hr))
    {
        ADsDebugOut((
                DEB_IWARN,
                "WARNING: %s:%d returning",
                lpstrFile,
                line));

        PrintHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);

        BreakOnFailed();
    }

    return hr;
}



//+---------------------------------------------------------------
//
//  Function:   CheckResult
//
//  Synopsis:   Issues a warning if the HRESULT indicates failure
//
//  Arguments:  [hr] -- the HRESULT to be checked
//              [lpstrFile] -- the file where the HRESULT is being checked
//              [line] -- the line in the file where the HRESULT is being checked
//
//
//  History:    1-06-94   adams   Error printed only on FAILURE, not also
//                                  on non-zero success.
//              5-24-94   adams   Added call to BreakOnFailed.
//
//  Notes:      This function should not be used directly.  The RRETURN
//              macro is provided for convenience.
//
//----------------------------------------------------------------

STDAPI_(void)
CheckResult(HRESULT hr, LPSTR lpstrFile, UINT line)
{
    if (FAILED(hr))
    {
        ADsDebugOut((DEB_IWARN, "WARNING: "));
        ADsDebugOutHRESULT(DEB_IWARN | DEB_NOCOMPNAME, hr);
        ADsDebugOut((
                DEB_IWARN | DEB_NOCOMPNAME,
                " occurred at %s:%d.\n",
                lpstrFile,
                line));

        BreakOnFailed();
    }
}


#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\cenum.cxx ===
//+------------------------------------------------------------------------
//
//  File:       cenum.cxx
//
//  Contents:   Generic enumerator class.
//
//  Classes:    CBaseEnum
//              CEnumGeneric
//              CEnumVARIANT
//
//  History:    05-05-93    ChrisZ      Added class object caching
//              05-11-93    ChrisZ      Cleanup on CF caching
//              02-24-93    LyleC       Moved from ADs directory
//              01-Sep-93   DonCl       new (NullOnFail)
//              08-Sep-93   LyleC       Changed Next() to accept NULL 3rd param
//              15-May-94   adams       Added CBaseEnum, CEnumVARIANT
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

// Determines whether a variant is a base type.
#define ISBASEVARTYPE(vt) ((vt & ~VT_TYPEMASK) == 0)

//+------------------------------------------------------------------------
//
//  CBaseEnum Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Init
//
//  Synopsis:   2nd stage initialization perADs copy of array if necessary.
//
//  Arguments:  [pary]    -- Array to enumrate.
//              [fCopy]   -- Copy array?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CBaseEnum::Init(CADsAry * pary, BOOL fCopy)
{
    HRESULT     hr          = S_OK;
    CADsAry * paryCopy    = NULL;     // copied array

    ADsAssert(pary);

    // Copy array if necessary.
    if (fCopy)
    {
        paryCopy = new CADsAry;
        if (!paryCopy)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = paryCopy->Copy(_cb, *pary, _fAddRef);
        if (hr)
            goto Error;

        pary = paryCopy;
    }

    _pary = pary;

Cleanup:
    RRETURN(hr);

Error:
    delete paryCopy;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- addref enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete)
{
    _ulRefs     = 1;

    _cb         = cb;
    _pary       = NULL;
    _piid       = &iid;
    _i          = 0;
    _fAddRef    = fAddRef;
    _fDelete    = fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::CBaseEnum
//
//  Synopsis:   Constructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::CBaseEnum(const CBaseEnum& benum)
{
    _ulRefs     = 1;

    _cb         = benum._cb;
    _piid       = benum._piid;
    _pary       = benum._pary;
    _i          = benum._i;
    _fAddRef    = benum._fAddRef;
    _fDelete    = benum._fDelete;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::~CBaseEnum
//
//  Synopsis:   Destructor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CBaseEnum::~CBaseEnum(void)
{
    IUnknown ** ppUnk;
    int         i;

    if (_pary && _fDelete)
    {
        if (_fAddRef)
        {
            for (i = 0, ppUnk = (IUnknown **) Deref(0);
                 i < _pary->Size();
                 i++, ppUnk++)
            {
                (*ppUnk)->Release();
            }
        }

        delete _pary;
    }

    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::QueryInterface
//
//  Synopsis:   Per IUnknown::QueryInterface.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::QueryInterface(REFIID iid, LPVOID * ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(iid, IID_IUnknown) || IsEqualIID(iid, *_piid))
    {
        AddRef();
        *ppv = this;
        return NOERROR;
    }

    return E_NOTIMPL;
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Skip
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Skip(ULONG celt)
{
    int c = min((int) celt, _pary->Size() - _i);
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseEnum::Reset
//
//  Synopsis:   Per IEnum*
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CBaseEnum::Reset(void)
{
    _i = 0;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  CEnumGeneric Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumGeneric::Create(
        size_t          cb,
        CADsAry *     pary,
        REFIID          iid,
        BOOL            fAddRef,
        BOOL            fCopy,
        BOOL            fDelete,
        CEnumGeneric ** ppenum)
{
    HRESULT         hr      = S_OK;
    CEnumGeneric *  penum;

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(!fCopy || fDelete);
    *ppenum = NULL;
    penum = new CEnumGeneric(cb, iid, fAddRef, fDelete);
    if (!penum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  Arguments:  [iid]     -- IID of enumerator interface.
//              [fAddRef] -- AddRef enumerated elements?
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this].
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(size_t cb, REFIID iid, BOOL fAddRef, BOOL fDelete) :
        CBaseEnum(cb, iid, fAddRef, fDelete)
{
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumGeneric
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumGeneric::CEnumGeneric(const CEnumGeneric& enumg) : CBaseEnum(enumg)
{
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    IUnknown ** ppUnk;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    if (_fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) Deref(_i); i < c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }
    memcpy(reelt, (BYTE *) Deref(_i), c * _cb);
    if (pceltFetched)
    {
        *pceltFetched = c;
    }
    _i += c;

    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumGeneric::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumGeneric::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumElements(_cb, *_piid, (void **) ppenum, _fAddRef);
    if (hr)
        RRETURN(hr);

    (**(CEnumGeneric **)ppenum)._i = _i;
    return S_OK;
}



//+------------------------------------------------------------------------
//
//  CEnumVARIANT Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Create
//
//  Synopsis:   Creates a new CEnumGeneric object.
//
//  Arguments:  [pary]    -- Array to enumerate.
//              [vt]      -- Type of elements enumerated.
//              [fCopy]   -- Copy array enumerated?
//              [fDelete] -- Delete array when zero enumerators of array?
//              [ppenum]  -- Resulting CEnumGeneric object.
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CEnumVARIANT::Create(
        size_t          cb,
        CADsAry *     pary,
        VARTYPE         vt,
        BOOL            fCopy,
        BOOL            fDelete,
        IEnumVARIANT ** ppenum)
{
    HRESULT         hr          = S_OK;
    CEnumVARIANT *  penum;              // enumerator to return.

    ADsAssert(pary);
    ADsAssert(ppenum);
    ADsAssert(ISBASEVARTYPE(vt));
    *ppenum = NULL;
    penum = new CEnumVARIANT(cb, vt, fDelete);
    if (!*ppenum)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = penum->Init(pary, fCopy);
    if (hr)
        goto Error;

    *ppenum = (IEnumVARIANT *) (void *) penum;

Cleanup:
    RRETURN(hr);

Error:
    penum->Release();
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  Arguments:  [vt]      -- Type of elements enumerated.
//              [fDelete] -- delete array on zero enumerators?
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(size_t cb, VARTYPE vt, BOOL fDelete) :
        CBaseEnum(cb, IID_IEnumVARIANT, vt == VT_UNKNOWN || vt == VT_DISPATCH, fDelete)
{
    ADsAssert(ISBASEVARTYPE(vt));
    _vt         = vt;
}



//+---------------------------------------------------------------------------
//
//  Function:   CEnumVARIANT
//
//  Synopsis:   ctor.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

CEnumVARIANT::CEnumVARIANT(const CEnumVARIANT& enumv) : CBaseEnum(enumv)
{
    _vt     = enumv._vt;
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Next
//
//  Synopsis:   Returns the next celt members in the enumeration. If less
//              than celt members remain, then the remaining members are
//              returned and S_FALSE is reported. In all cases, the number
//              of elements actually returned in placed in *pceltFetched.
//
//  Arguments:  [celt]          Number of elements to fetch
//              [reelt]         The elements are returned in reelt[]
//              [pceltFetched]  Number of elements actually fetched
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------
STDMETHODIMP
CEnumVARIANT::Next(ULONG celt, void * reelt, ULONG * pceltFetched)
{
    int         c;
    int         i;
    BYTE *      pb;
    VARIANT *   pvar;

    c = min((int) celt, _pary->Size() - _i);
    if (c > 0 && !reelt)
        RRETURN(E_INVALIDARG);

    for (i = 0, pb = (BYTE *) Deref(_i), pvar = (VARIANT *) reelt;
         i < c;
         i++, pb += _cb, pvar++)
    {
        V_VT(pvar) = _vt;
        switch (_vt)
        {
        case VT_I2:
            ADsAssert(sizeof(V_I2(pvar)) == _cb);
            V_I2(pvar) = *(short *) pb;
            break;

        case VT_I4:
            ADsAssert(sizeof(V_I4(pvar)) == _cb);
            V_I4(pvar) = *(long *) pb;
            break;

        case VT_BOOL:
            ADsAssert(sizeof(V_BOOL(pvar)) == _cb);
            V_BOOL(pvar) = (short) -*(int *) pb;
            break;

        case VT_BSTR:
            ADsAssert(sizeof(V_BSTR(pvar)) == _cb);
            V_BSTR(pvar) = *(BSTR *) pb;
            break;

        case VT_UNKNOWN:
        case VT_DISPATCH:
            ADsAssert(sizeof(V_UNKNOWN(pvar)) == _cb);
            V_UNKNOWN(pvar) = *(IUnknown **) pb;
            V_UNKNOWN(pvar)->AddRef();
            break;

        default:
            ADsAssert(0 && "Unknown VARTYPE in IEnumVARIANT::Next");
            break;
        }
    }

    if (pceltFetched)
    {
        *pceltFetched = c;
    }

    _i += c;
    return ((c == (int) celt) ? NOERROR : S_FALSE);
}



//+------------------------------------------------------------------------
//
//  Member:     CEnumVARIANT::Clone
//
//  Synopsis:   Creates a copy of this enumerator; the copy should have the
//              same state as this enumerator.
//
//  Arguments:  [ppenum]    New enumerator is returned in *ppenum
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

STDMETHODIMP
CEnumVARIANT::Clone(CBaseEnum ** ppenum)
{
    HRESULT hr;

    if (!ppenum)
        RRETURN(E_INVALIDARG);

    *ppenum = NULL;
    hr = _pary->EnumVARIANT(_cb, _vt, (IEnumVARIANT **)ppenum);
    if (hr)
        RRETURN(hr);

    (**(CEnumVARIANT **)ppenum)._i = _i;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\fbstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       fbstr.cxx
//
//  Contents:   Wrappers around BSTR api to account for wierdness with NULL
//
//  Functions:  ADsAllocString
//              ADsAllocStringLen
//              ADsReAllocString
//              ADsReAllocStringLen
//              ADsFreeString
//              ADsStringLen
//              ADsStringByteLen
//              ADsAllocStringByteLen
//              ADsStringCmp
//              ADsStringNCmp
//              ADsStringICmp
//              ADsStringNICmp
//
//  History:   25-Oct-94 krishnag
//
//
//----------------------------------------------------------------------------

#include "procs.hxx"


//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocString
//
//  Synopsis:   Allocs a BSTR and initializes it from a string.  If the
//              initializer is NULL or the empty string, the resulting bstr is
//              NULL.
//
//  Arguments:  [pch]   -- String to initialize BSTR.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR]
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocString(const OLECHAR * pch, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);
    if (!pch)
    {
        *pBSTR = NULL;
        return S_OK;
    }

    *pBSTR = SysAllocString(pch);
    hr = (*pBSTR) ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringLen
//
//  Synopsis:   Allocs a BSTR of [uc] + 1 OLECHARS, and
//              initializes it from an optional string.  If [uc] == 0, the
//              resulting bstr is NULL.
//
//  Arguments:  [pch]   -- String to initialize.
//              [uc]    -- Count of characters of string.
//              [pBSTR] -- The result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringLen(const OLECHAR * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;

     }


    *pBSTR = SysAllocStringLen(pch, uc);
    hr =  *pBSTR ? S_OK : E_OUTOFMEMORY;
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocString
//
//  Synopsis:   Allocates a BSTR initialized from a string; if successful,
//              frees the original string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocString(BSTR * pBSTR, const OLECHAR * pch)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocString(pch, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }


    return SysReAllocString(pBSTR, pch) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsReAllocStringLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 OLECHARs and optionally
//              initializes it from a string; if successful, frees the original
//              string and replaces it.
//
//  Arguments:  [pBSTR] -- String to reallocate.
//              [pch]   -- Initializer.
//              [uc]    -- Count of characters.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsReAllocStringLen(BSTR * pBSTR, const OLECHAR * pch, UINT uc)
{
    ADsAssert(pBSTR);

#if DBG == 1
    HRESULT hr;
    BSTR    bstrTmp;

    hr = ADsAllocStringLen(pch, uc, &bstrTmp);
    if (hr)
        RRETURN(hr);

    ADsFreeString(*pBSTR);
    *pBSTR = bstrTmp;
    return S_OK;
#else

    if (!pch){

        SysFreeString(*pBSTR);
        *pBSTR = NULL;
        return S_OK;
     }

    return SysReAllocStringLen(pBSTR, pch, uc) ? S_OK : E_OUTOFMEMORY;
#endif
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringLen
//
//  Synopsis:   Returns the length of the BSTR.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringLen(BSTR bstr)
{
    return bstr ? SysStringLen(bstr) : 0;
}



#ifdef WIN32

//+---------------------------------------------------------------------------
//
//  Function:   ADsStringByteLen
//
//  Synopsis:   Returns the length of a BSTR in bytes.
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI_(UINT)
ADsStringByteLen(BSTR bstr)
{
    return bstr ? SysStringByteLen(bstr) : 0;
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsAllocStringByteLen
//
//  Synopsis:   Allocates a BSTR of [uc] + 1 chars and optionally initializes
//              from a string.  If [uc] = 0, the resulting bstr is NULL.
//
//  Arguments:  [pch]   -- Initializer.
//              [uc]    -- Count of chars.
//              [pBSTR] -- Result.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pBSTR].
//
//  History:    5-06-94   adams   Created
//
//----------------------------------------------------------------------------

STDAPI
ADsAllocStringByteLen(const char * pch, UINT uc, BSTR * pBSTR)
{
    HRESULT hr = S_OK;

    ADsAssert(pBSTR);

    if (!pch){

        *pBSTR = NULL;
        return S_OK;
     }


    *pBSTR = SysAllocStringByteLen(pch, uc);

    RRETURN(hr);
}
#endif



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringCmp
//
//  Synopsis:   As per wcscmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringCmp(CBSTR bstr1, CBSTR bstr2)
{
    return wcscmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNCmp
//
//  Synopsis:   As per wcsncmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNCmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return wcsncmp(STRVAL(bstr1), STRVAL(bstr2), c);
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringICmp
//
//  Synopsis:   As per wcsicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsicmp to _wcsicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringICmp(CBSTR bstr1, CBSTR bstr2)
{
    return _wcsicmp(STRVAL(bstr1), STRVAL(bstr2));
}



//+---------------------------------------------------------------------------
//
//  Function:   ADsStringNICmp
//
//  Synopsis:   As per wcsnicmp, checking for NULL bstrs.
//
//  History:    5-06-94   adams   Created
//              25-Jun-94 doncl   changed from _tc to wc
//              15-Aug-94 doncl   changed from wcsnicmp to _wcsnicmp
//
//----------------------------------------------------------------------------

STDAPI_(int)
ADsStringNICmp(CBSTR bstr1, CBSTR bstr2, size_t c)
{
    return _wcsnicmp(STRVAL(bstr1), STRVAL(bstr2), c);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\date.cxx ===
#include "Procs.hxx"

#define BAIL_ON_FAILURE(hr) \
        if (FAILED(hr)) {       \
                goto error;   \
        }\

#define BAIL_ON_SUCCESS(hr) \
        if (SUCCEEDED(hr)) {       \
                goto error;   \
        }\


HRESULT
NTTimeFormattoDateFormat(
    LARGE_INTEGER *NTTimeFormat,
    DATE *DateFormat
    )
{
    *DateFormat = (DATE)0;
    RRETURN(S_OK);
}


HRESULT
ConvertDWORDtoDATE(
    DWORD dwDate,
    DATE * pdaDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    SYSTEMTIME SystemTime, LocalTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;    

    if (pdaDate) {
        memset(pdaDate, 0, sizeof(DATE));
    }

    memset(&fileTime, 0, sizeof(FILETIME));

    ::RtlSecondsSince1970ToTime(dwDate, &tmpTime );

    fileTime.dwLowDateTime = tmpTime.LowPart;
    fileTime.dwHighDateTime = tmpTime.HighPart;

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        FileTimeToLocalFileTime(&fileTime, &fileTime);

    if (!FileTimeToSystemTime(&fileTime, &SystemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToVariantTime(&SystemTime, pdaDate)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

error:

    RRETURN(hr);
}


HRESULT
ConvertDATEtoDWORD(
    DATE daDate,
    DWORD *pdwDate,
    BOOL fIsGMT
    )
{

    FILETIME fileTime;
    LARGE_INTEGER tmpTime;
    HRESULT hr = S_OK;
    SYSTEMTIME systemTime;

    if (!VariantTimeToSystemTime(daDate, &systemTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if (!SystemTimeToFileTime(&systemTime, &fileTime)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        BAIL_ON_FAILURE(hr);
    }

    if(!fIsGMT)
    // OLE DB on NDS does not convert to local file time. We don't
    // convert here to be consistent.
        LocalFileTimeToFileTime(&fileTime, &fileTime);

    tmpTime.LowPart = fileTime.dwLowDateTime;
    tmpTime.HighPart = fileTime.dwHighDateTime;


    ::RtlTimeToSecondsSince1970(&tmpTime, (ULONG *)pdwDate);

error:
    RRETURN(hr);

}


HRESULT
ConvertDATEToDWORD(
    DATE  daDate,
    DWORD *pdwDate
    )
{
    RRETURN(S_OK);
}

HRESULT
ConvertSystemTimeToDATE(
    SYSTEMTIME Time,
    DATE *     pdaTime
    )
{
    FILETIME ft;
    BOOL fRetval = FALSE;
    USHORT wDosDate;
    USHORT wDosTime;
    SYSTEMTIME LocalTime;

    //
    // Get Time-zone specific local time.
    //

    fRetval = SystemTimeToTzSpecificLocalTime(
                  NULL,
                  &Time,
                  &LocalTime
                  );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // System Time To File Time.
    //

    fRetval = SystemTimeToFileTime(&LocalTime,
                                   &ft);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // File Time to DosDateTime.
    //

    fRetval = FileTimeToDosDateTime(&ft,
                                    &wDosDate,
                                    &wDosTime);
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    //
    // DosDateTime to VariantTime.
    //

    fRetval = DosDateTimeToVariantTime(wDosDate,
                                       wDosTime,
                                       pdaTime );
    if(!fRetval){
      RRETURN(HRESULT_FROM_WIN32(GetLastError()));
    }

    RRETURN(S_OK);
}


HRESULT
ConvertDWORDToDATE(
    DWORD    dwTime,
    DATE *     pdaTime
    )

{
    RRETURN(S_OK);
}

HRESULT
ConvertDATEToSYSTEMTIME(
    DATE  daDate,
    SYSTEMTIME *pSysTime
    )
{
    HRESULT hr;
    FILETIME ft;
    FILETIME lft; //local file time
    BOOL fRetval = FALSE;
    SYSTEMTIME LocalTime;
    USHORT wDosDate;
    USHORT wDosTime;

    fRetval = VariantTimeToDosDateTime(daDate,
                                       &wDosDate,
                                       &wDosTime );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = DosDateTimeToFileTime(wDosDate,
                                    wDosTime,
                                    &lft);



    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    //
    // convert local file time to filetime
    //

    fRetval = LocalFileTimeToFileTime(&lft,
                                      &ft );

    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    fRetval = FileTimeToSystemTime(&ft,
                                   pSysTime );


    if(!fRetval){
        hr = HRESULT_FROM_WIN32(GetLastError());
        RRETURN(hr);
    }

    RRETURN(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\cdispmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1997.
//
//  File:       cdispmgr.cxx
//
//  Contents:   The dispatch manager -- a class to manage
//              multiple IDispatch-callable interfaces.
//
//  Classes:    CDispatchMgr
//
//  Functions:  None external.
//
//  History:    ??-???-??   KrishnaG   created
//              07-Sep-97   t-blakej   Commented, cleaned up, made
//                                     independent of ADSI.
//
//  See cdispmgr.hxx for a more thorough description of the dispatch manager.
//
//----------------------------------------------------------------------------

//
// Since this class is useful outside of ADSI, some work has been taken to
// make it not depend on any ADSI-specific code.  It needs two ADSI header
// files (cdispmgr.hxx and iprops.hxx), but they only depend on definitions
// from standard system header files.
//
// To accomodate the current building method in ADSI, the precompiled
// header "procs.hxx" is included; this includes all the necessary ADSI
// header files and definitions.  But for use outside of ADSI, the few
// necessary header files are explicitly included below; see the comment by
// "#ifndef ADsAssert".
//
// So if not compiling for ADSI, comment the following two lines out.
//

#include "procs.hxx"
#pragma hdrstop

//////////////////////////////////////////////////////////////////////////////
//
// General helper definitions, routines, and inclusions:

// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    Begin Non-ADSI compile stuff
//
// This macro is defined by the precompiled header file, so the following
// will only be included if not compiling for ADSI.
//
#ifndef ADsAssert

//
// Necessary system headers.
//
#define UNICODE
#define _UNICODE
#define _OLEAUT32_
#define INC_OLE2
#include <windows.h>
#include <stdio.h>

//
// Necessary class definitions used by the dispatch manager.
// Edit these paths if necessary.
//
#include "cdispmgr.hxx"
#include "iprops.hxx"

#endif  // ADsAssert
// -=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-    End Non-ADSI compile stuff

//
// Error recovery.
//
#define BAIL_ON_FAILURE(hr) if (FAILED(hr)) { goto cleanup; }

//
// A simple assert function.
//
#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertEx
//
//  Synopsis:   Display assertion information.
//
//  Effects:    Called when an assertion is hit.
//
//  History:    Simplified from Win4AssertEx, to make this dispatch manager
//              not depend on other files.
//
//----------------------------------------------------------------------------
static void
AssertEx(char const *szFile, int iLine, char const *szMessage)
{
    static char szAssertCaption[100];

    sprintf(szAssertCaption, "File: %s line %u, thread id %d",
        szFile, iLine, GetCurrentThreadId());

    if (IDCANCEL == MessageBoxA(
                NULL,
                (char *) szMessage,
                (LPSTR) szAssertCaption,
                MB_SETFOREGROUND |
                MB_TASKMODAL | MB_ICONEXCLAMATION | MB_OKCANCEL
                ))
    {
        DebugBreak();
    }
}
# define DispMgrAssert(x)  (void)((x) || (AssertEx(__FILE__, __LINE__, #x),0))
#else
# define AssertEx(f,l,m)   do {} while(0)
# define DispMgrAssert(x)  do {} while(0)
#endif

//////////////////////////////////////////////////////////////////////////////
//
// Inline routines:

static inline LONG
getDispMgrId(DISPID InputDispId)
{
    return (InputDispId & 0x7f000000) >> 24;
}

static inline LONG
getTypeInfoId(DISPID InputDispId)
{
    return (InputDispId & 0x00ff0000) >> 16;
}

static inline LONG
getDispId(DISPID InputDispId)
{
    return (InputDispId & 0x0000ffff);
}

static inline void
MakeDISPID(LONG TypeInfoId, LONG DispId, DISPID *pResult)
{
    if (DispId == DISPID_UNKNOWN)
        *pResult = DispId;
    else if (TypeInfoId < 0 || TypeInfoId >= 0x100 ||
        DispId < 0 || DispId >= 0x10000)
    {
        //
        // Might happen if some object has very large dispid's.
        // But we can't handle it if it does.
        //
        *pResult = DISPID_UNKNOWN;
    }
    else
        *pResult = ((TypeInfoId & 0xff) << 16) | (DispId & 0xffff);

}

static inline void
IncDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        if (rgdispid[i] == DISPID_UNKNOWN)
            continue;

        //
        // This is either a stack of DispMgrs >127 high, or
        // a programming error.  More likely the latter.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) < 0x7f);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) + 1) & 0x7f) << 24);
    }
}

static inline void
DecDispMgrIds(DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; ++i)
    {
        //
        // It should never be less than zero, and the only place
        // this is called from guarantees it is not zero.
        //
        DispMgrAssert(getDispMgrId(rgdispid[i]) > 0);

        rgdispid[i] =
            (rgdispid[i] & 0x00ffffff) |
            (((getDispMgrId(rgdispid[i]) - 1) & 0x7f) << 24);
    }
}

static inline void
MakeDISPIDs(LONG TypeInfoId, DISPID *rgdispid, unsigned int cNames)
{
    for (unsigned int i = 0; i < cNames; i++)
    {
        MakeDISPID(TypeInfoId, rgdispid[i], &rgdispid[i]);
    }
}

//
// Struct defs
//
typedef struct _typeinfotable
{
    GUID iid;
    ITypeInfo * pTypeInfo;
    struct _typeinfotable *pNext;
}TYPEINFO_TABLE, *PTYPEINFO_TABLE;


PTYPEINFO_TABLE gpTypeInfoTable = NULL;

CRITICAL_SECTION g_DispTypeInfoCritSect;

#define ENTER_DISP_TYPEINFO_CRITSECT()  EnterCriticalSection(&g_DispTypeInfoCritSect)
#define LEAVE_DISP_TYPEINFO_CRITSECT()  LeaveCriticalSection(&g_DispTypeInfoCritSect)

LONG glnObjCount = 0;
LONG glnTypesOfInfo = 0;
LONG glnOledbObjCnt = 0;


//////////////////////////////////////////////////////////////////////////////
//
// Public methods:

CDispatchMgr::CDispatchMgr()
{
    _pTypeInfoEntry = NULL;
    _pDispidNewEnum = NULL;
    _dwTypeInfoId = 0;
    _pDispidValue = NULL;
    _pPropertyCache = NULL;
    _dwPropCacheID = 0;
    _pDispatch = NULL;
}

CDispatchMgr::~CDispatchMgr()
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    PTYPEINFOENTRY pTemp = NULL;
    ITypeInfo *pTypeInfo = NULL;

    pTypeInfoEntry = _pTypeInfoEntry;

    while (pTypeInfoEntry) {

        pTemp = pTypeInfoEntry;

        pTypeInfo = (ITypeInfo *)pTypeInfoEntry->ptypeinfo;
        pTypeInfo->Release();

        InterlockedDecrement(&glnObjCount);

        pTypeInfoEntry = pTemp->pNext;

        LocalFree(pTemp);
    }

    ENTER_DISP_TYPEINFO_CRITSECT();
    if (glnObjCount == glnTypesOfInfo) {
        //
        // We need to clean up the list
        //
        FreeTypeInfoTable();

        glnObjCount = glnTypesOfInfo = 0;

    }
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (_pDispatch)
        _pDispatch->Release();
}

void
CDispatchMgr::RegisterPropertyCache(IPropertyCache *pPropertyCache)
{
    _pPropertyCache = pPropertyCache;
    _dwPropCacheID = gentypeinfoid();
}

void
CDispatchMgr::RegisterBaseDispatchPtr(IDispatch *pDispatch)
{
    _pDispatch = pDispatch;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfoCount(unsigned int *pctinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetTypeInfo(unsigned int itinfo, LCID lcid, ITypeInfo **pptinfo)
{
    return E_NOTIMPL;
}

STDMETHODIMP
CDispatchMgr::GetIDsOfNames(REFIID iid, LPWSTR *rgszNames,
        unsigned int cNames, LCID lcid, DISPID *rgdispid)
{
    PTYPEINFOENTRY pTypeInfo = NULL;
    HRESULT hr = DISP_E_UNKNOWNNAME;

    //
    // Try our list of TypeInfos.
    //
    pTypeInfo = _pTypeInfoEntry;
    while (pTypeInfo) {
        hr = DispGetIDsOfNames(((ITypeInfo *)pTypeInfo->ptypeinfo),
                                rgszNames,
                                cNames,
                                rgdispid
                                );
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(pTypeInfo->TypeInfoId, rgdispid, cNames);
            return hr;
        }
        pTypeInfo = pTypeInfo->pNext;
    }

    //
    // Try our property cache.
    //
    if (FAILED(hr) && _pPropertyCache) {
        hr = S_OK;
        for (DWORD dw = 0; dw < cNames; dw++) {
            if (FAILED(_pPropertyCache->locateproperty(rgszNames[dw],
                    (PDWORD)(rgdispid + dw)))) {
                hr = DISP_E_UNKNOWNNAME;
                rgdispid[dw] = DISPID_UNKNOWN;
            }
        }
        if (SUCCEEDED(hr)) {
            MakeDISPIDs(_dwPropCacheID, rgdispid, cNames);
        }
    }

    //
    // Try our "base class" dispatch pointer.
    //
    if (FAILED(hr) && _pDispatch) {
        hr = _pDispatch->GetIDsOfNames(iid, rgszNames, cNames, lcid, rgdispid);

        if (SUCCEEDED(hr)) {
            IncDispMgrIds(rgdispid, cNames);
        }
    }

    return hr;
}

STDMETHODIMP
CDispatchMgr::Invoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
        //
        // Clear the error object before we call invoke.
        //
        SetErrorInfo(0, NULL);

        return TypeInfoInvoke(dispidMember,
                               iid,
                               lcid,
                               wFlags,
                               pdispparams,
                               pvarResult,
                               pexcepinfo,
                               puArgErr
                               );
}

//////////////////////////////////////////////////////////////////////////////
//
// Private methods and helper functions:

void *
CDispatchMgr::getInterfacePtr(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (pTypeInfoEntry ? pTypeInfoEntry->pInterfacePointer : NULL);
}

ITypeInfo *
CDispatchMgr::getTypeInfo(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry = FindTypeInfoEntry(TypeInfoId);
    return (ITypeInfo *)(pTypeInfoEntry ? pTypeInfoEntry->ptypeinfo : NULL);
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfoEntry(LONG TypeInfoId)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->TypeInfoId == TypeInfoId) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

PTYPEINFOENTRY
CDispatchMgr::FindTypeInfo(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    pTypeInfoEntry = _pTypeInfoEntry;
    while (pTypeInfoEntry) {
        if (pTypeInfoEntry->ptypeinfo == pTypeInfo) {
            return pTypeInfoEntry;
        }
        pTypeInfoEntry = pTypeInfoEntry->pNext;
    }
    return NULL;
}

HRESULT
CDispatchMgr::AddTypeInfo(void *ptypeinfo, void *pIntfptr)
{
    PTYPEINFOENTRY pTypeInfoEntry = NULL;
    HRESULT hr;

    if (FindTypeInfo(ptypeinfo)) {
        return E_FAIL;
    }
    pTypeInfoEntry = (PTYPEINFOENTRY)LocalAlloc(LPTR,sizeof(TYPEINFOENTRY));
    if (!pTypeInfoEntry) {
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    pTypeInfoEntry->ptypeinfo = ptypeinfo;
    pTypeInfoEntry->TypeInfoId = gentypeinfoid();
    pTypeInfoEntry->pInterfacePointer = pIntfptr;

    pTypeInfoEntry->pNext = _pTypeInfoEntry;
    _pTypeInfoEntry = pTypeInfoEntry;

    return S_OK;

cleanup:
    return hr;
}

STDMETHODIMP
CDispatchMgr::TypeInfoInvoke(DISPID dispidMember, REFIID iid, LCID lcid,
        unsigned short wFlags, DISPPARAMS *pdispparams, VARIANT *pvarResult,
        EXCEPINFO *pexcepinfo, unsigned int *puArgErr)
{
    void *pInterfacePtr = NULL;
    DISPID dispid = 0;
    DISPID typeinfoid = 0;
    ITypeInfo *pTypeInfo = NULL;
    HRESULT hr = S_OK;

    if (dispidMember <= 0) {

        //
            // One of the special DISPIDs.
            //
            // If we have an interface pointer for it, use that.
            // If we don't, and we have a base IDispatch pointer,
            //   pass it to the base pointer's Invoke() method.
            // If we don't, and we don't have a base IDispatch pointer,
            //   return failure.
            //

        dispid = dispidMember;
        switch (dispid) {

        case DISPID_VALUE:
            if (_pDispidValue) {
                pTypeInfo = (ITypeInfo *)_pDispidValue->ptypeinfo;
                pInterfacePtr = _pDispidValue->pInterfacePointer;
            }
            break;

        case DISPID_NEWENUM:
            if (_pDispidNewEnum) {
                pTypeInfo = (ITypeInfo *)_pDispidNewEnum->ptypeinfo;
                pInterfacePtr = _pDispidNewEnum->pInterfacePointer;
            }
            break;

        default:
            break;
        }

            if (!pInterfacePtr) {
            if (_pDispatch) {
                    return _pDispatch->Invoke(dispidMember, iid, lcid, wFlags,
                        pdispparams, pvarResult, pexcepinfo, puArgErr);
                } else {
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
                }
            }else {

            //
            // Fill in the special case scenarios here
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );

            return(hr);

        }

    } else if (getDispMgrId(dispidMember)) {

            //
            // A regular DISPID of a "base class" dispatch manager.
            //

            if (!_pDispatch){

                char szMessage[80];
                sprintf(szMessage, "_pDispatch is NULL, dispid = 0x%08x",
                        dispidMember);
                 AssertEx(__FILE__, __LINE__, szMessage);
                return DISP_E_MEMBERNOTFOUND;
            }

            DecDispMgrIds(&dispidMember, 1);

            hr = _pDispatch->Invoke(
                    dispidMember,
                    iid,
                    lcid,
                    wFlags,
                        pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        return(hr);

    } else {

        //
            // A regular DISPID of ours.
            //

        typeinfoid = getTypeInfoId(dispidMember);
        dispid = getDispId(dispidMember);

            if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {
                pInterfacePtr = getInterfacePtr(typeinfoid);
                pTypeInfo = getTypeInfo(typeinfoid);
                if (!pTypeInfo)
                        //
                    // Shouldn't happen.
                    //
                    BAIL_ON_FAILURE(hr = DISP_E_MEMBERNOTFOUND);
            }

        if ((_pPropertyCache == NULL) || (typeinfoid != _dwPropCacheID)) {

            //
            // A regular interface.
            //

            hr = DispInvoke(
                    pInterfacePtr,
                    pTypeInfo,
                    dispid,
                    wFlags,
                    pdispparams,
                    pvarResult,
                    pexcepinfo,
                    puArgErr
                    );
        }else {

            //
            // A "dynamic DISPID", for the property cache.
            //

            hr = DynamicDispidInvoke(
                        _pPropertyCache,
                        dispid,
                        wFlags,
                        pdispparams,
                        pvarResult
                        );

        }

    }

cleanup:
    return hr;
}


HRESULT
DynamicDispidInvoke(
    IPropertyCache * pPropertyCache,
    DISPID  dispid,
    unsigned short wFlags,
    DISPPARAMS *pdispparams,
    VARIANT * pvarResult
    )
{
    HRESULT hr = S_OK;

    if (!pPropertyCache) {

        return(E_INVALIDARG);
    }

    if (wFlags & DISPATCH_PROPERTYGET) {

        if (!pvarResult) {
            BAIL_ON_FAILURE(hr = E_INVALIDARG);
        }

        hr = pPropertyCache->getproperty((DWORD)dispid,pvarResult);

        if (FAILED(hr)) {

#if 1
            // This lets us return S_OK and a VT_EMPTY variant if
            // there's no data.  #if this out to disable it.
            V_VT(pvarResult) = VT_EMPTY;
            hr = S_OK;
#else

            V_VT(pvarResult) = VT_ERROR;
#endif

        }
    }else if (wFlags & DISPATCH_PROPERTYPUT) {

        if (pdispparams[0].cArgs != 1){
            hr = DISP_E_BADPARAMCOUNT;
        }
        else {

            hr = pPropertyCache->putproperty(
                        (DWORD)dispid,
                        pdispparams[0].rgvarg[0]
                        );
        }

    }else {
        hr = E_INVALIDARG;
    }

cleanup:
    return(hr);

}


HRESULT
CDispatchMgr::MarkAsNewEnum(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidNewEnum = pTypeInfoEntry;
    return S_OK;
}

HRESULT
CDispatchMgr::MarkAsItem(void *pTypeInfo)
{
    PTYPEINFOENTRY pTypeInfoEntry;

    if (!pTypeInfo) {
        return E_FAIL;
    }
    if (!(pTypeInfoEntry = FindTypeInfo(pTypeInfo))) {
        return E_FAIL;
    }
    _pDispidValue = pTypeInfoEntry;
    return S_OK;
}

LONG
CDispatchMgr::gentypeinfoid()
{
    //
    // This would mean we've registered 65536 IDispatch methods
    //   in this object's dispatch manager.  We lose.
    //
    DispMgrAssert(_dwTypeInfoId < 0xffff);

    return (_dwTypeInfoId++);
}

ITypeInfo *
FindTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = pTypeInfoTable;

    while (pTemp) {
        if (IsEqualIID(iid, pTemp->iid)) {
            return pTemp->pTypeInfo;
        }
        pTemp = pTemp->pNext;
    }
    return NULL;
}


PTYPEINFO_TABLE
AddTypeInfo(
    PTYPEINFO_TABLE pTypeInfoTable,
    REFIID iid,
    ITypeInfo * pTypeInfo
    )
{
    PTYPEINFO_TABLE pTemp = NULL;

    pTemp = (PTYPEINFO_TABLE)LocalAlloc(LPTR, sizeof(TYPEINFO_TABLE));
    if (!pTemp) {
        return NULL;
    }

    memcpy(&pTemp->iid, &iid, sizeof(GUID));
    pTemp->pTypeInfo = pTypeInfo;
    pTemp->pNext = pTypeInfoTable;

    return pTemp;
}

//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    DispMgrAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        return hr;

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    return hr;
}

HRESULT
CDispatchMgr::LoadTypeInfoEntry(
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    ITypeInfo * pTypeInfo = NULL;
    HRESULT hr;

    ENTER_DISP_TYPEINFO_CRITSECT();

    pTypeInfo = ::FindTypeInfo(gpTypeInfoTable, iid);

    if (!pTypeInfo) {

        LEAVE_DISP_TYPEINFO_CRITSECT();

        hr = LoadTypeInfo(libid, iid, &pTypeInfo);
        BAIL_ON_FAILURE(hr);

        ENTER_DISP_TYPEINFO_CRITSECT();

        gpTypeInfoTable = ::AddTypeInfo(
                                gpTypeInfoTable,
                                iid,
                                pTypeInfo
                                );
        if (!gpTypeInfoTable) {

                LEAVE_DISP_TYPEINFO_CRITSECT();
                BAIL_ON_FAILURE(hr = HRESULT_FROM_WIN32(GetLastError()));
        }

        //
        // Increment the global list of the types of type info's.
        //
        InterlockedIncrement(&glnTypesOfInfo);

        InterlockedIncrement(&glnObjCount);
    }
    pTypeInfo->AddRef();


    hr = AddTypeInfo(pTypeInfo, pIntf);

    if (FAILED(hr)) {
        LEAVE_DISP_TYPEINFO_CRITSECT();
        BAIL_ON_FAILURE(hr);
    }

    //
    // We have a ref on the object as add was succesful
    //
    InterlockedIncrement(&glnObjCount);
    LEAVE_DISP_TYPEINFO_CRITSECT();

    if (SpecialId == -4) {
        hr = MarkAsNewEnum(pTypeInfo);
    } else if (SpecialId == DISPID_VALUE) {
        hr = MarkAsItem(pTypeInfo);
    }

    return S_OK;

cleanup:
    if (pTypeInfo)
        pTypeInfo->Release();

    return hr;
}

//
// Kept for backwards compatibility.
//
HRESULT
LoadTypeInfoEntry(
    CDispatchMgr *pDispMgr,
    REFIID libid,
    REFIID iid,
    void * pIntf,
    DISPID SpecialId
    )
{
    return pDispMgr->LoadTypeInfoEntry(libid, iid, pIntf, SpecialId);
}

void
FreeTypeInfoTable()
{
    PTYPEINFO_TABLE pTypeInfoTable = NULL;
    PTYPEINFO_TABLE pTemp = NULL;
    ITypeInfo * pTypeInfo = NULL;

    pTypeInfoTable = gpTypeInfoTable;

    while (pTypeInfoTable) {

        pTypeInfo = pTypeInfoTable->pTypeInfo;

        pTypeInfo->Release();


        pTemp = pTypeInfoTable;

        pTypeInfoTable = pTypeInfoTable->pNext;

        LocalFree(pTemp);
    }

    gpTypeInfoTable = NULL;
}

BOOL
DllReadyToUnload()
{
    BOOL retVal = FALSE;

    ENTER_DISP_TYPEINFO_CRITSECT();
        retVal = ((glnTypesOfInfo == 0) && (glnOledbObjCnt == 0));
    LEAVE_DISP_TYPEINFO_CRITSECT();

    return retVal;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\netolary.cxx ===
//+------------------------------------------------------------------------
//
//  File:   netolary.cxx
//
//  Contents:   Generic dynamic array class
//
//  Classes:    CADsAry
//
//  History:
//
//-------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//  CADsAry class





//+------------------------------------------------------------------------
//
//  Member: CADsAry::~CADsAry
//
//  Synopsis:   Resizeable array destructor. Frees storage allocated for the
//      array.
//
//-------------------------------------------------------------------------
CADsAry::~CADsAry( )
{
    if (_pv)
        LocalFree(_pv);
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::EnsureSize
//
//  Synopsis:   Ensures that the array is at least the given size. That is,
//      if EnsureSize(c) succeeds, then (c-1) is a valid index. Note
//      that the array maintains a separate count of the number of
//      elements logically in the array, which is obtained with the
//      Size/SetSize methods. The logical size of the array is never
//      larger than the allocated size of the array.
//
//  Arguments:  [cb]    Element size
//              [c]     New allocated size for the array.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::EnsureSize(size_t cb, int c)
{
    void *  pv;

    if (c <= GetAlloced(cb))
        return NOERROR;

    //  CONSIDER should we use a more sophisticated array-growing
    //    algorithm?
    c = ((c - 1) & -8) + 8;
    ADsAssert(c > 0);
    if (!_pv)
    {
        pv = LocalAlloc(LMEM_FIXED, c * cb);
    }
    else
    {
        pv = LocalReAlloc(_pv, c * cb, LMEM_MOVEABLE);
    }

    if (!pv)
        RRETURN(E_OUTOFMEMORY);

    _pv = pv;
    return NOERROR;
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Append
//
//  Synopsis:   Appends the given pointer to the end of the array, incrementing
//      the array's logical size, and growing its allocated size if
//      necessary. This method should only be called for arrays of
//      pointers; AppendIndirect should be used for arrays of
//      non-pointers.
//
//  Arguments:  [pv]        Pointer to append.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Append(void * pv)
{
    HRESULT hr;

    ADsAssert(_cb == 4);

    hr = EnsureSize(_c + 1);
    if (hr)
        RRETURN(hr);

    * (void **) Deref(_c) = pv;
    _c++;

    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::AppendIndirect
//
//  Synopsis:   Appends the given element to the end of the array, incrementing
//      the array's logical size, and growing the array's allocated
//      size if necessary.  Note that the element is passed with a
//      pointer, rather than directly.
//
//  Arguments:  [cb]        --  Element size
//              [pv]        --  Pointer to the element to be appended
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::AppendIndirect(size_t cb, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memcpy(Deref(cb, _c), pv, cb);
    _c++;

    return NOERROR;
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Delete
//
//  Synopsis:   Removes the i'th element of the array, shuffling all elements
//      that follow one slot towards the beginning of the array.
//
//  Arguments:  [cb]    Element size
//              [i]     Element to delete
//
//-------------------------------------------------------------------------
void
CADsAry::Delete(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < _c);

    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    _c--;
}


//+------------------------------------------------------------------------
//
//  Member: CADsAry::DeleteAll
//
//  Synopsis:   Efficient method for emptying array of any contents
//
//-------------------------------------------------------------------------
void
CADsAry::DeleteAll(void)
{
    if (_pv)
        LocalFree(_pv);

    _pv = NULL;
    _c = 0;
}


#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Insert
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.
//      This method should only be called for arrays of
//      pointers; InsertIndirect should be used for arrays of
//      non-pointers.
//
//
//  Arguments:  [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::Insert(int i, void * pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * _cb),
            ((BYTE *) _pv) + (i * _cb),
            (_c - i ) * _cb);

    ((void **) _pv)[i] = pv;
    _c++;
    return NOERROR;
}
#endif


//+------------------------------------------------------------------------
//
//  Member: CADsAry::InsertIndirect
//
//  Synopsis:   Inserts a pointer pv at index i. The element previously at
//      index i, and all elements that follow it, are shuffled one
//      slot away towards the end of the array.Note that the
//      clement is passed with a pointer, rather than directly.
//
//  Arguments:  [cb]    Element size
//              [i]     Index to insert...
//              [pv]        ...this pointer at
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CADsAry::InsertIndirect(size_t cb, int i, void *pv)
{
    HRESULT hr;

    hr = EnsureSize(cb, _c + 1);
    if (hr)
        RRETURN(hr);

    memmove(((BYTE *) _pv) + ((i + 1) * cb),
            ((BYTE *) _pv) + (i * cb),
            (_c - i ) * cb);

    memcpy(Deref(cb, i), pv, cb);
    _c++;
    return NOERROR;

}

//+------------------------------------------------------------------------
//
//  Member: CADsAry::BringToFront
//
//  Synopsis:   Moves the i'th element to the front of the array, shuffling
//              intervening elements to make room.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::BringToFront(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + cb, _pv, i * cb);
    memcpy(_pv, rgb, cb);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::SendToBack
//
//  Synopsis:   Moves the i'th element to the back of the array (that is,
//      the largest index less than the logical size.) Any intervening
//      elements are shuffled out of the way.
//
//  Arguments:  [i]
//
//-------------------------------------------------------------------------
void
CADsAry::SendToBack(size_t cb, int i)
{
    BYTE    rgb[CADsAry_MAXELEMSIZE];

    ADsAssert(cb <= CADsAry_MAXELEMSIZE);

    memcpy(rgb, ((BYTE *) _pv) + (i * cb), cb);
    memmove(((BYTE *) _pv) + (i * cb),
            ((BYTE *) _pv) + ((i + 1) * cb),
            (_c - i - 1) * cb);

    memcpy(((BYTE *) _pv) + ((_c - 1) * cb), rgb, cb);
}



#if 0
//+------------------------------------------------------------------------
//
//  Member: CADsAry::Find
//
//  Synopsis:   Returns the index at which the given pointer is found, or -1
//      if it is not found. The pointer values are compared directly;
//      there is no compare function.
//
//  Arguments:  [pv]        Pointer to find
//
//  Returns:    int; index of pointer, or -1 if not found
//
//-------------------------------------------------------------------------
int
CADsAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    Assert(_cb == 4);

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}
#endif


//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::Copy
//
//  Synopsis:   Creates a copy from another CADsAry object.
//
//  Arguments:  [ary]     -- Object to copy.
//              [fAddRef] -- Addref the elements on copy?
//
//  Returns:    HRESULT.
//
//  Modifies:   [this]
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::Copy(size_t cb, const CADsAry& ary, BOOL fAddRef)
{
    int         cbArray;                // size of array
    IUnknown ** ppUnk;                  // elem to addref
    int         i;                      // counter

    // avoid copy of self
    if (this == &ary)
        return S_OK;

    DeleteAll();
    if (ary._pv)
    {
        cbArray = ary._c * cb;
        _pv = LocalAlloc(LMEM_FIXED, cbArray);
        if (!_pv)
            RRETURN(E_OUTOFMEMORY);

        memcpy(_pv, ary._pv, cbArray);
    }

    _c          = ary._c;

    if (fAddRef)
    {
        for (i = 0, ppUnk = (IUnknown **) _pv; i < _c; i++, ppUnk++)
        {
            (*ppUnk)->AddRef();
        }
    }

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an enumerator for the elements of the
//              array.
//
//  Arguments:  [iid]     --    Type of the enumerator.
//              [ppv]     --    Location to put enumerator.
//              [fAddRef] --    AddRef enumerated elements?
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumElements(
        size_t  cb,
        REFIID  iid,
        void ** ppv,
        BOOL    fAddRef,
        BOOL    fCopy,
        BOOL    fDelete)
{
    HRESULT hr;

    ADsAssert(ppv);
    hr = CEnumGeneric::Create(
            cb,
            this,
            iid,
            fAddRef,
            fCopy,
            fDelete,
            (CEnumGeneric **)ppv);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     CADsAry::EnumElements
//
//  Synopsis:   Creates and returns an IEnumVARIANT enumerator for the elements
//              of the array.
//
//  Arguments:  [vt]      --    Type of elements enumerated.
//              [ppv]     --    Location to put enumerator.
//              [fCopy]   --    Create copy of this array for enumerator?
//              [fDelete] --    Delete this after no longer being used by
//                              enumerators?
//
//  Returns:    HRESULT.
//
//  History:    5-15-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CADsAry::EnumVARIANT(
        size_t          cb,
        VARTYPE         vt,
        IEnumVARIANT ** ppenum,
        BOOL            fCopy,
        BOOL            fDelete)
{
    HRESULT hr;

    ADsAssert(ppenum);
    hr = CEnumVARIANT::Create(cb, this, vt, fCopy, fDelete, ppenum);
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Member: CADsAry::Deref
//
//  Synopsis:   Returns a pointer to the i'th element of the array. This
//              method is normally called by type-safe methods in derived
//              classes.
//
//  Arguments:  [i]
//
//  Returns:    void *
//
//  BUGBUG:     This function should be inline; however, since nothing is
//              inlined in debug builds, it requires an export, which
//              then doesn't apply in retail builds and breaks the retail
//              build.  Near ship time, the def file will be fixed handle
//              inlining.
//
//-------------------------------------------------------------------------

void *
CADsAry::Deref(size_t cb, int i)
{
    ADsAssert(i >= 0);
    ADsAssert(i < GetAlloced(cb));

    return ((BYTE *) _pv) + i * cb;
};





HRESULT
CADsPtrAry::EnsureSize(int c)
{
    return CADsAry::EnsureSize(sizeof(LPVOID), c);
}



HRESULT
CADsPtrAry::Append(void * pv)
{
    return CADsAry::AppendIndirect(sizeof(void *), &pv);
}


HRESULT
CADsPtrAry::Insert(int i, void * pv)
{
    return CADsAry::InsertIndirect(sizeof(void *), i, &pv);
}


int
CADsPtrAry::Find(void * pv)
{
    int     i;
    void ** ppv;

    for (i = 0, ppv = (void **) _pv; i < _c; i++, ppv++)
    {
        if (pv == *ppv)
            return i;
    }

    return -1;
}


void
CADsPtrAry::Delete(int i)
{
    CADsAry::Delete(sizeof(void *), i);
}


void
CADsPtrAry::BringToFront(int i)
{
    CADsAry::BringToFront(sizeof(void *), i);
}


void
CADsPtrAry::SendToBack(int i)
{
    CADsAry::SendToBack(sizeof(void *), i);
}


HRESULT
CADsPtrAry::Copy(const CADsAry& ary, BOOL fAddRef)
{
    return CADsAry::Copy(sizeof(void *), ary, fAddRef);
}


HRESULT
CADsPtrAry::EnumElements(
        REFIID iid,
        void ** ppv,
        BOOL fAddRef,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumElements(
            sizeof(void *),
            iid,
            ppv,
            fAddRef,
            fCopy,
            fDelete);
}


HRESULT
CADsPtrAry::EnumVARIANT(
        VARTYPE vt,
        IEnumVARIANT ** ppenum,
        BOOL fCopy,
        BOOL fDelete)
{
    return CADsAry::EnumVARIANT(
            sizeof(void *),
            vt,
            ppenum,
            fCopy,
            fDelete);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\misc.cxx ===
//+---------------------------------------------------------------------
//
//  File:       misc.cxx
//
//  Contents:   Useful OLE helper and debugging functions
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  Function:   GetLastWin32Error
//
//  Synopsis:   Returns the last Win32 error, converted to an HRESULT.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
GetLastWin32Error( )
{
    return HRESULT_FROM_WIN32(GetLastError());
}



#if DBG == 1

//+---------------------------------------------------------------
//
//  Function:   TraceIID
//
//  Synopsis:   Outputs the name of the interface to the debugging device
//
//  Arguments:  [riid] -- the interface
//
//  Notes:      This function disappears in retail builds.
//
//----------------------------------------------------------------

STDAPI_(void)
PrintIID(DWORD dwFlags, REFIID riid)
{
    LPWSTR lpstr = NULL;

#define CASE_IID(iid)  \
        if (IsEqualIID(IID_##iid, riid)) lpstr = (LPWSTR)L#iid;

    CASE_IID(IUnknown)
    CASE_IID(IOleLink)
    CASE_IID(IOleCache)
    CASE_IID(IOleManager)
    CASE_IID(IOlePresObj)
    CASE_IID(IDebug)
    CASE_IID(IDebugStream)
    CASE_IID(IAdviseSink2)
    CASE_IID(IDataObject)
    CASE_IID(IViewObject)
    CASE_IID(IOleObject)
    CASE_IID(IOleInPlaceObject)
    CASE_IID(IParseDisplayName)
    CASE_IID(IOleContainer)
    CASE_IID(IOleItemContainer)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IPersist)
    CASE_IID(IPersistStorage)
    CASE_IID(IPersistFile)
    CASE_IID(IPersistStream)
    CASE_IID(IOleClientSite)
    CASE_IID(IOleInPlaceSite)
    CASE_IID(IAdviseSink)
    CASE_IID(IDataAdviseHolder)
    CASE_IID(IOleAdviseHolder)
    CASE_IID(IClassFactory)
    CASE_IID(IOleWindow)
    CASE_IID(IOleInPlaceActiveObject)
    CASE_IID(IOleInPlaceUIWindow)
    CASE_IID(IOleInPlaceFrame)
    CASE_IID(IDropSource)
    CASE_IID(IDropTarget)
    CASE_IID(IBindCtx)
    CASE_IID(IEnumUnknown)
    CASE_IID(IEnumString)
    CASE_IID(IEnumFORMATETC)
    CASE_IID(IEnumSTATDATA)
    CASE_IID(IEnumOLEVERB)
    CASE_IID(IEnumMoniker)
    CASE_IID(IEnumGeneric)
    CASE_IID(IEnumHolder)
    CASE_IID(IEnumCallback)
    CASE_IID(ILockBytes)
    CASE_IID(IStorage)
    CASE_IID(IStream)
    CASE_IID(IDispatch)
    CASE_IID(IMarshal)
    //CASE_IID(IEnumVARIANT)
    //CASE_IID(ITypeInfo)
    //CASE_IID(ITypeLib)
    //CASE_IID(ITypeComp)
    //CASE_IID(ICreateTypeInfo)
    //CASE_IID(ICreateTypeLib)

#undef CASE_IID

    if (lpstr == NULL)
    {
        WCHAR chBuf[256];
        StringFromGUID2(riid, chBuf, 256);

        ADsDebugOut((dwFlags | DEB_NOCOMPNAME,
                       "UNKNOWN ITF %ws", chBuf));
    }
    else
        ADsDebugOut((dwFlags | DEB_NOCOMPNAME, "%ws", lpstr));
}

#endif  // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\disputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:  25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff

#define BAIL_ON_FAILURE(hr) \
    if (FAILED(hr)) {       \
        goto error;         \
    }

#define CONTINUE_ON_FAILURE(hr) \
    if (FAILED(hr)) {           \
        continue;               \
    }

HMODULE g_hActiveDs = NULL; // Module handle of activeds.dll. This should be
                            // initialized when the provider module is loaded
                            // into a process' address space. The handle
                            // is used by FillExcepInfo to retrieve error
                            // description strings from activeds.dll.

static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);




//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = (DWORD)(pvtCur - pvt);
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}

HRESULT
ConvertSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    HRESULT hr = S_OK;
    DWORD dwSLBound = 0;
    DWORD dwSUBound = 0;
    DWORD dwNumVariants = 0;
    DWORD i = 0;
    VARIANT * pVarArray = NULL;
    SAFEARRAY * pArray = NULL;
    VARIANT *pvProp = NULL;

    *pdwNumVariants = 0;
    *ppVarArray  = 0;

    //
    // It has to be a variant and a safearray. It might
    // also be a variant that is byref and safe array
    //
    //

    pvProp = &varSafeArray;
    if (V_VT(pvProp) == (VT_BYREF|VT_VARIANT)) {
        pvProp = V_VARIANTREF(&varSafeArray);
    }

    if(!(((V_VT(pvProp) & VT_VARIANT)== VT_VARIANT)
         && V_ISARRAY(pvProp))) {
        //
        // We need to make this additional check. This is not really 
        // legal but it could be that just the tag at this level is wrong.
        // This was allowed in older versions of ADSI and therefore needs
        // on future versions (backward compatibility). 
        //
        if(!((V_VT(&varSafeArray) & VT_VARIANT) && V_ISARRAY(&varSafeArray)))
          RRETURN(E_FAIL);
    }

    if (V_VT(pvProp) == (VT_BYREF | VT_VARIANT | VT_ARRAY)) {
        //
        // in this case we need to use the ARRAY_REF.
        //
        pArray = *(V_ARRAYREF(pvProp));
    }
    else {
        //
        // pvProp will always have the correc info, byref or not.
        //
        pArray = V_ARRAY(pvProp);
    }

    //
    // Check that there is only one dimension in this array
    //
    if (pArray->cDims != 1) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    //
    // Check that there is at least one element in this array
    //

    if (pArray->rgsabound[0].cElements == 0){
        RRETURN(S_OK);  // Return success and null array
    }

    //
    // We know that this is a valid single dimension array
    //

    hr = SafeArrayGetLBound(pArray,
                            1,
                            (long FAR *)&dwSLBound
                            );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(pArray,
                            1,
                            (long FAR *)&dwSUBound
                            );
    BAIL_ON_FAILURE(hr);

    dwNumVariants = dwSUBound - dwSLBound + 1;
    pVarArray = (PVARIANT)AllocADsMem(
                                sizeof(VARIANT)*dwNumVariants
                                );
    if (!pVarArray) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    for (i = dwSLBound; i <= dwSUBound; i++) {

        VariantInit(pVarArray + i);
        hr = SafeArrayGetElement(pArray,
                                (long FAR *)&i,
                                (pVarArray + i)
                                );
        CONTINUE_ON_FAILURE(hr);
    }

    *ppVarArray = pVarArray;
    *pdwNumVariants = dwNumVariants;

error:

    RRETURN(hr);
}

//
// This method should go away.  ConvertSafeArrayToVariantArray does the job.
//
HRESULT
ConvertByRefSafeArrayToVariantArray(
    VARIANT varSafeArray,
    PVARIANT * ppVarArray,
    PDWORD pdwNumVariants
    )
{
    RRETURN(ConvertSafeArrayToVariantArray(
        varSafeArray,
        ppVarArray,
        pdwNumVariants
        ));
}

//
// An LDAP query needs a NULL-terminated array of strings.
//
HRESULT
ConvertVariantArrayToLDAPStringArray(
    PVARIANT pVarArray,
    PWSTR **pppszStringArray,
    DWORD dwNumStrings
    )
{
    HRESULT hr = S_OK;
    PWSTR *ppszStringArray = NULL;
    DWORD i = 0;

    //
    // Start off with a zero-length array.
    //
    *pppszStringArray = NULL;

    //
    // The LDAP library expects an array terminated with a NULL string.
    // So make space for an extra one.
    //
    dwNumStrings++;

    ppszStringArray = (PWSTR *)AllocADsMem(dwNumStrings * sizeof(PWSTR));
    if (!ppszStringArray)
        BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);

    for (i = 0; i < dwNumStrings - 1; i++)
    {
        if (!(V_VT(pVarArray + i) == VT_BSTR))
            BAIL_ON_FAILURE(hr = E_ADS_CANT_CONVERT_DATATYPE);

        ppszStringArray[i] = AllocADsStr(V_BSTR(pVarArray + i));
        if (!ppszStringArray[i])
            BAIL_ON_FAILURE(hr = E_OUTOFMEMORY);
    }

    //
    // NULL-terminated for LDAP.
    //
    ppszStringArray[i] = NULL;

    *pppszStringArray = ppszStringArray;
    RRETURN(hr);

error:
    if (ppszStringArray)
    {
        for (DWORD j = 0; j < i; j++)
            if (ppszStringArray[i])
                FreeADsStr(ppszStringArray[i]);

        FreeADsMem(ppszStringArray);
    }
    RRETURN(hr);
}

HRESULT
VariantToBinary(
    PVARIANT pVarSrcObject,
    DWORD *pdwLength,
    BYTE  **ppByte
    )
{
    HRESULT hr = S_OK;
    LONG dwSLBound = 0;
    LONG dwSUBound = 0;
    CHAR HUGEP *pArray = NULL;
    BYTE  *pByte = NULL;

    if( pVarSrcObject->vt != (VT_ARRAY | VT_UI1)) {
        RRETURN(hr = E_ADS_CANT_CONVERT_DATATYPE);
    }

    hr = SafeArrayGetLBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSLBound );
    BAIL_ON_FAILURE(hr);

    hr = SafeArrayGetUBound(V_ARRAY(pVarSrcObject),
                            1,
                            (long FAR *) &dwSUBound );
    BAIL_ON_FAILURE(hr);

    pByte = (BYTE*)AllocADsMem( dwSUBound - dwSLBound + 1);
    if ( pByte == NULL) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }
    hr = SafeArrayAccessData( V_ARRAY(pVarSrcObject),
                              (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pByte,
            pArray,
            dwSUBound-dwSLBound+1);

    SafeArrayUnaccessData( V_ARRAY(pVarSrcObject) );

    *pdwLength = dwSUBound - dwSLBound + 1;
    *ppByte = pByte;

    RRETURN(hr);
error:
    if (pByte) {
        FreeADsMem(pByte);
    }
    RRETURN(hr);
}

HRESULT
BinaryToVariant(
    DWORD Length,
    BYTE* pByte,
    PVARIANT lpVarDestObject
    )
{
    HRESULT hr = S_OK;
    SAFEARRAY *aList = NULL;
    SAFEARRAYBOUND aBound;
    CHAR HUGEP *pArray = NULL;

    aBound.lLbound = 0;
    aBound.cElements = Length;
    aList = SafeArrayCreate( VT_UI1, 1, &aBound );

    if ( aList == NULL ) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    hr = SafeArrayAccessData( aList, (void HUGEP * FAR *) &pArray );
    BAIL_ON_FAILURE(hr);

    memcpy( pArray, pByte, aBound.cElements );
    SafeArrayUnaccessData( aList );

    V_VT(lpVarDestObject) = VT_ARRAY | VT_UI1;
    V_ARRAY(lpVarDestObject) = aList;

    RRETURN(hr);

error:

    if ( aList ) {
        SafeArrayDestroy( aList );
    }
    RRETURN(hr);
}

HRESULT
CopyOctetString(
    DWORD dwNumBytes,
    BYTE *pData,
    DWORD *pdwNumBytes,
    BYTE **ppByte
    )
{
    LPBYTE lpByteStream = NULL;
    HRESULT hr = S_OK;

    if (dwNumBytes) {
        lpByteStream = (LPBYTE)AllocADsMem(dwNumBytes);
        if (lpByteStream == NULL) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }

        memcpy(
            lpByteStream,
            pData,
            dwNumBytes
            );

        *pdwNumBytes = dwNumBytes;
        *ppByte =  lpByteStream;
    }
    else {
        *pdwNumBytes = 0;
        *ppByte = NULL;
    }
error:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   RaiseException, public API
//
//  Synopsis:   Generic function for translating ADS HRESULT codes to an
//              OLE error object.
//
//  Arguments:  [hr] - The HRESULT code to be translated into
//                     an OLE error object.
//
//
//  Returns:    Nothing. This function is called when an error occurred.
//              There isn't much the caller can do if this function fails.
//
//  History:    10-Sep-97   t-rmak      Created.
//
//
//  Notes:      1) Only ADS error codes are properly translated to
//                 corresponding OLE error objects.
//              2) This function will ignore the lcid passed into
//                 ITypeInfo::Invoke and it always passes 0 as the langid
//                 to FormatMessage.
//              3) Only the source field and the description field of the
//                 error object will be filled by this function.
//              4) This function does not support inserts in the description
//                 string.
//
//-------------------------------------------------------------------------
void
RaiseException(HRESULT hr)
{

    DWORD            dwStrLen;
    LPTSTR           lpszMessage = NULL;
    ICreateErrorInfo *pICreateErrorInfo = NULL;
    IErrorInfo       *pIErrorInfo = NULL;
    HRESULT          localhr = S_OK;

    if (g_hActiveDs != NULL) {

        //
        // Clear any previously set error object
        //
        SetErrorInfo(0, NULL);

        //
        // Let FormatMessage allocate the message buffer.
        // In a multi-threaded environment, this is the simplest
        // solution.
        //
        dwStrLen = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 // Ignore inserts for now.
                                 FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 (LPCVOID) g_hActiveDs,
                                 hr,
                                 0,
                                 (LPTSTR) &lpszMessage,
                                 0,
                                 NULL);

        //
        // We may want to fail with a special error code if the specified
        // lcid is not supported.
        //
        if (dwStrLen == 0) {
            goto error;
        }

        //
        // We may want to add support for help file in the future.
        //
        localhr = CreateErrorInfo(&pICreateErrorInfo);

        BAIL_ON_FAILURE(localhr);

        //
        // Note that we don't care whether the following calls succeed since
        // there is nothing we can if they fail.
        //
        pICreateErrorInfo->SetDescription(lpszMessage);
        pICreateErrorInfo->SetSource(TEXT("Active Directory"));

        //
        // Set the threads error object.
        //
        pICreateErrorInfo->QueryInterface(IID_IErrorInfo, (void **)&pIErrorInfo);
        SetErrorInfo(0, pIErrorInfo);

    }

error:

    if (lpszMessage != NULL) {
        LocalFree(lpszMessage);
    }

    //
    // Release the error object's interface pointers
    //
    if (pIErrorInfo != NULL) {
        pIErrorInfo->Release();
    }

    if (pICreateErrorInfo != NULL) {
        pICreateErrorInfo->Release();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\pack.cxx ===
#include "procs.hxx"
#pragma hdrstop
#include "macro.h"

HRESULT
PackStringinVariant(
    BSTR bstrString,
    VARIANT * pvarInputData
    )
{
    HRESULT hr = S_OK;

    if ( bstrString == NULL )
        RRETURN(E_FAIL);

    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BSTR;

    if (!bstrString) {
        V_BSTR(pvarInputData) = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(bstrString, &(V_BSTR(pvarInputData)));

    RRETURN(hr);
}


HRESULT
UnpackStringfromVariant(
    VARIANT varSrcData,
    BSTR * pbstrDestString
    )
{
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_BSTR){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    if (!V_BSTR(&varSrcData)) {
        *pbstrDestString = NULL;
        RRETURN(S_OK);
    }

    hr = ADsAllocString(V_BSTR(&varSrcData), pbstrDestString);

    RRETURN(hr);
}


HRESULT
PackLONGinVariant(
    LONG  lValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_I4;
    V_I4(pvarInputData) = lValue;

    RRETURN(S_OK);
}

HRESULT
UnpackLONGfromVariant(
    VARIANT varSrcData,
    LONG * plValue
    )
{
    if( varSrcData.vt != VT_I4){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *plValue = V_I4(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackDATEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_DATE;
    V_DATE(pvarInputData) = daValue;

    RRETURN(S_OK);
}

HRESULT
UnpackDATEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    if( varSrcData.vt != VT_DATE){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pdaValue = V_DATE(&varSrcData);

    RRETURN(S_OK);
}



HRESULT
PackFILETIMEinVariant(
    DATE  daValue,
    VARIANT * pvarInputData
    )
{
    IADsLargeInteger *pTime = NULL;
    VARIANT var;
    SYSTEMTIME systemtime;
    FILETIME filetime;
    HRESULT hr = S_OK;

    if (VariantTimeToSystemTime(daValue,
                                &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    if (SystemTimeToFileTime(&systemtime,
                             &filetime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (LocalFileTimeToFileTime(&filetime, &filetime ) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    hr = CoCreateInstance(
                CLSID_LargeInteger,
                NULL,
                CLSCTX_ALL,
                IID_IADsLargeInteger,
                (void**)&pTime
                );
    BAIL_ON_FAILURE(hr);

    hr = pTime->put_HighPart(filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);
    hr = pTime->put_LowPart(filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    VariantInit(pvarInputData);
    pvarInputData->pdispVal = pTime;
    pvarInputData->vt = VT_DISPATCH;

error:
    return hr;
}

HRESULT
UnpackFILETIMEfromVariant(
    VARIANT varSrcData,
    DATE * pdaValue
    )
{
    IADsLargeInteger *pLarge = NULL;
    IDispatch *pDispatch = NULL;
    FILETIME filetime;
    FILETIME locFiletime;
    SYSTEMTIME systemtime;
    DATE date;
    HRESULT hr = S_OK;

    if( varSrcData.vt != VT_DISPATCH){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    pDispatch = varSrcData.pdispVal;
    hr = pDispatch->QueryInterface(IID_IADsLargeInteger, (VOID **) &pLarge);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_HighPart((long*)&filetime.dwHighDateTime);
    BAIL_ON_FAILURE(hr);

    hr = pLarge->get_LowPart((long*)&filetime.dwLowDateTime);
    BAIL_ON_FAILURE(hr);

    if (FileTimeToLocalFileTime(&filetime, &locFiletime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (FileTimeToSystemTime(&locFiletime,
                             &systemtime) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }

    if (SystemTimeToVariantTime(&systemtime,
                                &date) == 0) {
        hr = E_FAIL;
        BAIL_ON_FAILURE(hr);
    }
    *pdaValue = date;
error:
    return hr;
}

HRESULT
PackVARIANT_BOOLinVariant(
    VARIANT_BOOL  fValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_BOOL;
    V_BOOL(pvarInputData) = fValue;

    RRETURN(S_OK);
}

HRESULT
UnpackVARIANT_BOOLfromVariant(
    VARIANT varSrcData,
    VARIANT_BOOL * pfValue
    )
{
    if( varSrcData.vt != VT_BOOL){
        RRETURN(E_ADS_CANT_CONVERT_DATATYPE);
    }

    *pfValue = V_BOOL(&varSrcData);

    RRETURN(S_OK);
}


HRESULT
PackVARIANTinVariant(
    VARIANT vaValue,
    VARIANT * pvarInputData
    )
{
    VariantInit(pvarInputData);

    pvarInputData->vt = VT_VARIANT;
    RRETURN( VariantCopy( pvarInputData, &vaValue ));
}

HRESULT
UnpackVARIANTfromVariant(
    VARIANT varSrcData,
    VARIANT * pvaValue
    )
{
    VariantInit( pvaValue );

    RRETURN( VariantCopy( pvaValue, &varSrcData ));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\stdfact.cxx ===
//+---------------------------------------------------------------------
//
//  File:       stdfact.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    StdClassFactory
//              CDynamicCF
//
//  History:    6-21-94   adams   added CDynamicCF
//              19-Jul-94 doncl   init StdClassFactory::_ulRefs to 1
//
//----------------------------------------------------------------------

#include "procs.hxx"

//+------------------------------------------------------------------------
//
//  StdClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::AddRef(void)
{
    ADsAssert(_ulRefs);

    if (_ulRefs == 1)
        INC_OBJECT_COUNT();

    return ++_ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
StdClassFactory::Release(void)
{
    ADsAssert(_ulRefs > 1);

    if (--_ulRefs == 1)
        DEC_OBJECT_COUNT();

    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    return NOERROR;
}

#ifdef DOCGEN
//+---------------------------------------------------------------
//
//  Member:     StdClassFactory::CreateInstance, public
//
//  Synopsis:   Manufactures an instance of the class
//
//  Notes:      This pure virtual function must be overridden by the
//              inheriting class because the base class does not know what
//              class to instantiate.
//
//----------------------------------------------------------------

STDMETHODIMP
StdClassFactory::CreateInstance(LPUNKNOWN pUnkOuter,
        REFIID iid,
        LPVOID FAR* ppv) {};

//REVIEW: how to enforce ref counting of Class factory in object
// constructor/destructor?  Can we do this in a conjunction of StdUnknown
// with StdClassFactory.
#endif  // DOCGEN


//+------------------------------------------------------------------------
//
//  CDynamicCF Implementation
//
//-------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::CDynamicCF
//
//  Synopsis:   Constructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::CDynamicCF(void)
{
    _ulRefs = 1;

    INC_OBJECT_COUNT();
}



//+---------------------------------------------------------------------------
//
//  Member:     CDynamicCF::~CDynamicCF
//
//  Synopsis:   Destructor.
//
//  History:    7-20-94   adams   Created
//
//----------------------------------------------------------------------------

CDynamicCF::~CDynamicCF(void)
{
    DEC_OBJECT_COUNT();
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        RRETURN(E_INVALIDARG);

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}



//+---------------------------------------------------------------
//
//  Member:     CDynamicCF::LockServer, public
//
//  Synopsis:   Since these class factories are on the heap, we have
//              to implement this properly.  In our case, LockServer is
//              equivalent to AddRef/Release because we don't have a single
//              'application' object that we can put an external lock on.
//              Each time CreateInstance is called, we return a newly created
//              object.  If, instead, we returned a pointer to an existing
//              object, we would need to call CoLockObjectExternal on that
//              global object in the implementation of LockServer to keep it
//              alive.
//
//----------------------------------------------------------------

STDMETHODIMP
CDynamicCF::LockServer (BOOL fLock)
{
    if (fLock)
    {
        _ulRefs++;
    }
    else
    {
        _ulRefs--;
        Assert(_ulRefs != 0 && "Improper use of IClassFactory::LockServer!");
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\registry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996.
//
//  File:       registry.cxx
//
//  Contents:   Registry utilities
//
//  Classes:
//
//  Functions:
//
//  History:    23-May-1996  RamV (Ram Viswanathan) Created
//
//----------------------------------------------------------------------------

#include "procs.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   SetKeyAndValue
//
//  Synopsis:   Used for setting a key value
//
//
//  Arguments:  pszRegLocation: where to look for/create key
//              pszKey :   name of the Key
//              pszSubKey: name of the subkey
//              pszValue : Value to set
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    5/21/1996  RamV   Created.
//
//----------------------------------------------------------------------------


HRESULT
SetKeyAndValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR pszSubKey,
    LPTSTR pszValue
    )

{

    HKEY        hKey;
    TCHAR       szKey[MAX_PATH];
    LONG        lErrorCode;
    HRESULT     hr = S_OK;

    _tcscpy(szKey, pszRegLocation);

    if (pszSubKey != NULL){
        _tcscpy(szKey, TEXT("\\"));
        _tcscat(szKey, pszSubKey);
    }

    lErrorCode = RegCreateKeyEx(HKEY_CURRENT_USER,
                                szKey,
                                0,
                                NULL,
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                NULL,
                                &hKey,
                                NULL);

    if (lErrorCode != ERROR_SUCCESS){
        return HRESULT_FROM_WIN32(lErrorCode);
    }

    if (pszValue != NULL){
        lErrorCode = RegSetValueEx(hKey,
                                   pszKey,
                                   0,
                                   REG_SZ,
                                   (BYTE *)pszValue,
                                   (_tcslen(pszValue)+1)*sizeof(TCHAR));

        if(lErrorCode != ERROR_SUCCESS){
            hr = HRESULT_FROM_WIN32(lErrorCode);
            goto cleanup;
        }

    }

cleanup:
    RegCloseKey(hKey);
    return S_OK;
}


HRESULT
QueryKeyValue(
    LPTSTR pszRegLocation,
    LPTSTR pszKey,
    LPTSTR * ppszValue
    )

{
    LONG lErrorCode;
    TCHAR szKey[MAX_PATH];
    DWORD dwDataLen;
    DWORD dwType;
    HKEY  hKey = NULL;
    HRESULT hr = S_OK;

    dwDataLen = sizeof(TCHAR)* MAX_PATH;
    
    *ppszValue = (LPTSTR)AllocADsMem( dwDataLen );

    if(!*ppszValue){
        hr = E_OUTOFMEMORY;
        goto cleanup;
    }

    _tcscpy(szKey, pszRegLocation);

    lErrorCode = RegOpenKeyEx(HKEY_CURRENT_USER,
                              szKey,
                              NULL,
                              KEY_ALL_ACCESS,
                              &hKey);

    if( lErrorCode != ERROR_SUCCESS){
        hr = HRESULT_FROM_WIN32(lErrorCode);
        goto cleanup;
    }

    lErrorCode = RegQueryValueEx(hKey,
                                 pszKey,
                                 NULL,
                                 &dwType,
                                 (LPBYTE)*ppszValue,
                                 &dwDataLen);

    if (lErrorCode == ERROR_MORE_DATA){
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
        *ppszValue = (LPTSTR)AllocADsMem (dwDataLen);

        if(!*ppszValue){
            hr = E_OUTOFMEMORY;
            goto cleanup;
        }

        lErrorCode = RegQueryValueEx(hKey,
                                     pszKey,
                                     NULL,
                                     &dwType,
                                     (LPBYTE)*ppszValue,
                                     &dwDataLen);


        hr = HRESULT_FROM_WIN32(lErrorCode);
        BAIL_IF_ERROR(hr);

    } else if (lErrorCode != ERROR_SUCCESS) {
        hr = HRESULT_FROM_WIN32(lErrorCode);
        FreeADsMem(*ppszValue);
        *ppszValue = NULL;
    }
cleanup:
    if(hKey){
        RegCloseKey(hKey);
    }
    RRETURN(hr);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\capoolcf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  capoolcf.cxx
//
//  Contents:  IIS ApplicationPool Object Class Factory Code
//
//             CIISApplicationPoolCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISApplicationPoolCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApplicationPoolCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApplicationPool::CreateApplicationPool(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\capoolscf.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:  capoolcf.cxx
//
//  Contents:  IIS ApplicationPools Object Class Factory Code
//
//             CIISApplicationPoolsCF::CreateInstance
//
//----------------------------------------------------------------------------
#include "iisext.hxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   CIISApplicationPoolsCF::CreateInstance
//
//  Synopsis:
//
//  Arguments:  [pUnkOuter]
//              [iid]
//              [ppv]
//
//  Returns:    HRESULT
//
//  Modifies:
//
//  History:    11-10-2000    BrentMid     Created.
//----------------------------------------------------------------------------
STDMETHODIMP
CIISApplicationPoolsCF::CreateInstance(IUnknown * pUnkOuter, REFIID iid, LPVOID * ppv)
{
    HRESULT     hr = S_OK;

    if (!pUnkOuter)
        RRETURN(E_FAIL);

    hr = CIISApplicationPools::CreateApplicationPools(
                pUnkOuter,
                iid,
                ppv
                );

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\capools.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  capools.cxx
//
//  Contents:  Contains methods for CIISApplicationPools object
//
//  History:   11-09-2000     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop


//  Class CIISApplicationPools

DEFINE_IPrivateDispatch_Implementation(CIISApplicationPools)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApplicationPools)
DEFINE_CONTAINED_IADs_Implementation(CIISApplicationPools)
DEFINE_IADsExtension_Implementation(CIISApplicationPools)

CIISApplicationPools::CIISApplicationPools():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApplicationPools);
}

HRESULT
CIISApplicationPools::CreateApplicationPools(
    IUnknown *pUnkOuter,
    REFIID riid,
    void **ppvObj
    )
{
    CCredentials Credentials;
    CIISApplicationPools FAR * pApplicationPools = NULL;
    HRESULT hr = S_OK;
    BSTR bstrAdsPath = NULL;
    OBJECTINFO ObjectInfo;
    POBJECTINFO pObjectInfo = &ObjectInfo;
    CLexer * pLexer = NULL;
    LPWSTR pszIISPathName  = NULL;

    memset(pObjectInfo, 0, sizeof(OBJECTINFO));

    hr = AllocateApplicationPoolsObject(pUnkOuter, Credentials, &pApplicationPools);
    BAIL_ON_FAILURE(hr);

    //
    // get ServerName and pszPath
    //

    hr = pApplicationPools->_pADs->get_ADsPath(&bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    pLexer = new CLexer();
    hr = pLexer->Initialize(bstrAdsPath);
    BAIL_ON_FAILURE(hr);

    //
    // Parse the pathname
    //

    hr = ADsObject(pLexer, pObjectInfo);
    BAIL_ON_FAILURE(hr);

    pszIISPathName = AllocADsStr(bstrAdsPath);
    if (!pszIISPathName) {
        hr = E_OUTOFMEMORY;
        BAIL_ON_FAILURE(hr);
    }

    *pszIISPathName = L'\0';
    hr = BuildIISPathFromADsPath(
                    pObjectInfo,
                    pszIISPathName
                    );
    BAIL_ON_FAILURE(hr);

    hr = pApplicationPools->InitializeApplicationPoolsObject(
                pObjectInfo->TreeName,
                pszIISPathName );
    BAIL_ON_FAILURE(hr);

    //
    // pass non-delegating IUnknown back to the aggregator
    //

    *ppvObj = (INonDelegatingUnknown FAR *) pApplicationPools;

    if (bstrAdsPath)
    {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    RRETURN(hr);

error:

    if (bstrAdsPath) {
        ADsFreeString(bstrAdsPath);
    }

    if (pLexer) {
        delete pLexer;
    }

    if (pszIISPathName ) {
        FreeADsStr( pszIISPathName );
    }

    FreeObjectInfo( &ObjectInfo );

    *ppvObj = NULL;

    delete pApplicationPools;

    RRETURN(hr);

}


CIISApplicationPools::~CIISApplicationPools( )
{
    if (_pszServerName) {
        FreeADsStr(_pszServerName);
    }

    if (_pszMetaBasePath) {
        FreeADsStr(_pszMetaBasePath);
    }

    delete _pDispMgr;
}


STDMETHODIMP
CIISApplicationPools::QueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    HRESULT hr = S_OK;
   
    hr = _pUnkOuter->QueryInterface(iid,ppv);

    RRETURN(hr);
}

HRESULT
CIISApplicationPools::AllocateApplicationPoolsObject(
    IUnknown *pUnkOuter,
    CCredentials& Credentials,
    CIISApplicationPools ** ppApplicationPools
    )
{
    CIISApplicationPools FAR * pApplicationPools = NULL;
    IADs FAR *  pADs = NULL;
    CAggregateeDispMgr FAR * pDispMgr = NULL;
    HRESULT hr = S_OK;

    pApplicationPools = new CIISApplicationPools();
    if (pApplicationPools == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    pDispMgr = new CAggregateeDispMgr;
    if (pDispMgr == NULL) {
        hr = E_OUTOFMEMORY;
    }
    BAIL_ON_FAILURE(hr);

    hr = pDispMgr->LoadTypeInfoEntry(
                LIBID_IISExt,
                IID_IISApplicationPools,
                (IISApplicationPools *)pApplicationPools,
                DISPID_REGULAR
                );
    BAIL_ON_FAILURE(hr);

    //
    // Store the IADs Pointer, but again do NOT ref-count
    // this pointer - we keep the pointer around, but do
    // a release immediately.
    //
 
    hr = pUnkOuter->QueryInterface(IID_IADs, (void **)&pADs);
    pADs->Release();
    pApplicationPools->_pADs = pADs;

    //
    // Store the pointer to the pUnkOuter object
    // AND DO NOT add ref this pointer
    //
    pApplicationPools->_pUnkOuter = pUnkOuter;
  
    pApplicationPools->_Credentials = Credentials;
    pApplicationPools->_pDispMgr = pDispMgr;
    *ppApplicationPools = pApplicationPools;

    RRETURN(hr);

error:

    delete  pDispMgr;
    delete  pApplicationPools;

    RRETURN(hr);
}

HRESULT
CIISApplicationPools::InitializeApplicationPoolsObject(
    LPWSTR pszServerName,
    LPWSTR pszPath
    )
{
    HRESULT hr = S_OK;

    if (pszServerName) {
        _pszServerName = AllocADsStr(pszServerName);

        if (!_pszServerName) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    if (pszPath) {
        _pszMetaBasePath = AllocADsStr(pszPath);

        if (!_pszMetaBasePath) {
            hr = E_OUTOFMEMORY;
            BAIL_ON_FAILURE(hr);
        }
    }

    hr = InitServerInfo(pszServerName, &_pAdminBase);
    BAIL_ON_FAILURE(hr);

error:

    RRETURN(hr);
}

STDMETHODIMP
CIISApplicationPools::ADSIInitializeDispatchManager(
    long dwExtensionId
    )
{
    HRESULT hr = S_OK;

    if (_fDispInitialized) {

        RRETURN(E_FAIL);
    }

    hr = _pDispMgr->InitializeDispMgr(dwExtensionId);

    if (SUCCEEDED(hr)) {
        _fDispInitialized = TRUE;
    }

    RRETURN(hr);
}


STDMETHODIMP
CIISApplicationPools::ADSIInitializeObject(
    THIS_ BSTR lpszUserName,
    BSTR lpszPassword,
    long lnReserved
    )
{
    CCredentials NewCredentials(lpszUserName, lpszPassword, lnReserved);

    _Credentials = NewCredentials;

    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPools::ADSIReleaseObject()
{
    delete this;
    RRETURN(S_OK);
}


STDMETHODIMP
CIISApplicationPools::NonDelegatingQueryInterface(
    REFIID iid,
    LPVOID FAR* ppv
    )
{
    ASSERT(ppv);
    
    if (IsEqualIID(iid, IID_IISApplicationPools)) {

        *ppv = (IADsUser FAR *) this;

    } else if (IsEqualIID(iid, IID_IADsExtension)) {

        *ppv = (IADsExtension FAR *) this;
                                
    } else if (IsEqualIID(iid, IID_IUnknown)) {
        
        //
        // probably not needed since our 3rd party extension does not stand 
        // alone and provider does not ask for this, but to be safe
        //
        *ppv = (INonDelegatingUnknown FAR *) this;

    } else {
        
        *ppv = NULL;
        return E_NOINTERFACE;
    } 


    //
    // Delegating AddRef to aggregator for IADsExtesnion and IISApplicationPools.
    // AddRef on itself for IPrivateUnknown.   (both tested.)
    //

    ((IUnknown *) (*ppv)) -> AddRef();       

    return S_OK;
}


//
// IADsExtension::Operate()
//

STDMETHODIMP
CIISApplicationPools::Operate(
    THIS_ DWORD dwCode,
    VARIANT varUserName,
    VARIANT varPassword,
    VARIANT varFlags
    )
{
    RRETURN(E_NOTIMPL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\helper\utils\variant.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       disputil.cxx
//
//  Contents:   Dispatch Utilities.
//
//  Classes:
//
//  Functions:
//
//  History:    21-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified Set/GetDispProp to take REFIID
//                                  to meet sysmgmt needs
//              25-Oct-94   KrishnaG appropriated from the ADs project
//
//----------------------------------------------------------------------------

#include "procs.hxx"

#define VT_TYPEMASK   0x3ff


static HRESULT VARIANTARGToCVar(VARIANTARG * pvarg, VARTYPE vt, void* pv);
static void CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg);


//+---------------------------------------------------------------------------
//
//  Function:   FreeEXCEPINFO
//
//  Synopsis:   Frees resources in an excepinfo.  Does not reinitialize
//              these fields.
//
//----------------------------------------------------------------------------

void
FreeEXCEPINFO(EXCEPINFO * pEI)
{
    if (pEI)
    {
        ADsFreeString(pEI->bstrSource);
        ADsFreeString(pEI->bstrDescription);
        ADsFreeString(pEI->bstrHelpFile);
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   ValidateInvoke
//
//  Synopsis:   Validates arguments to a call of IDispatch::Invoke.  A call
//              to this function takes less space than the function itself.
//
//----------------------------------------------------------------------------

HRESULT
ValidateInvoke(
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    if (pvarResult)
        VariantInit(pvarResult);

    if (pexcepinfo)
        InitEXCEPINFO(pexcepinfo);

    if (puArgErr)
        *puArgErr = 0;

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Function:   LoadTypeInfo
//
//  Synopsis:   Loads a typeinfo from a registered typelib.
//
//  Arguments:  [clsidTL] --  TypeLib GUID
//              [clsidTI] --  TypeInfo GUID
//              [ppTI]    --  Resulting typeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
LoadTypeInfo(CLSID clsidTL, CLSID clsidTI, LPTYPEINFO *ppTI)
{
    HRESULT     hr;
    ITypeLib *  pTL;

    ADsAssert(ppTI);
    *ppTI = NULL;
    hr = LoadRegTypeLib(clsidTL, 1, 0, LOCALE_SYSTEM_DEFAULT, &pTL);
    if (hr)
        RRETURN(hr);

    hr = pTL->GetTypeInfoOfGuid(clsidTI, ppTI);
    pTL->Release();
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   VARIANTARGToCVar
//
//  Synopsis:   Converts a VARIANT to a C-language variable.
//
//  Arguments:  [pvarg] -- Variant to convert.
//              [vt]    -- Type to convert to.
//              [pv]    -- Location to place C-language variable.
//
//  Modifies:   [pv].
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_I2, VT_I4, VT_R4,
//              VT_R8.
//----------------------------------------------------------------------------

static HRESULT
VARIANTARGToCVar(VARIANT * pvarg, VARTYPE vt, void * pv)
{
    HRESULT     hr      = S_OK;
    VARIANTARG  vargNew;                    // variant of new type

    ADsAssert(pvarg);
    ADsAssert(pv);
    ADsAssert((vt & ~VT_TYPEMASK) == 0 || (vt & ~VT_TYPEMASK) == VT_BYREF);

    if (vt & VT_BYREF)
    {
        if (V_VT(pvarg) != vt)
        {
            hr = DISP_E_TYPEMISMATCH;
            goto Cleanup;
        }

        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
        vargNew = *pvarg;
    }
    else
    {
        VariantInit(&vargNew);
        hr = VariantChangeType(&vargNew, pvarg, 0, vt);
        if (hr)
            goto Cleanup;
    }

    switch (vt)
    {
    case VT_BOOL:
        if (V_BOOL(&vargNew) != VB_FALSE && V_BOOL(&vargNew) != VB_TRUE)
        {
            hr = E_FAIL;           // BUGBUG: scode?
            goto Cleanup;
        }

        // convert VT_TRUE to TRUE
        *(BOOL *)pv = - V_BOOL(&vargNew);
        break;

    case VT_I2:
        *(short *)pv = V_I2(&vargNew);
        break;

    case VT_I4:
        *(long *)pv = V_I4(&vargNew);
        break;

    case VT_R4:
        *(float *)pv = V_R4(&vargNew);
        break;

    case VT_R8:
        *(double *)pv = V_R8(&vargNew);
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        *(void **)pv = V_BYREF(&vargNew);
        break;

    default:
        ADsAssert(FALSE && "Unknown type in VARIANTARGToCVar().\n");
        break;
    }

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CVarToVARIANTARG
//
//  Synopsis:   Converts a C-language variable to a VARIANT.
//
//  Arguments:  [pv]    -- Pointer to C-language variable.
//              [vt]    -- Type of C-language variable.
//              [pvarg] -- Resulting VARIANT.  Must be initialized by caller.
//                         Any contents will be freed.
//
//  Modifies:   [pvarg]
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports all variant pointer types, VT_UI2, VT_I2, VT_UI4,
//              VT_I4, VT_R4, VT_R8.
//
//----------------------------------------------------------------------------

static void
CVarToVARIANTARG(void* pv, VARTYPE vt, VARIANTARG * pvarg)
{
    ADsAssert(pv);
    ADsAssert(pvarg);

    VariantClear(pvarg);

    V_VT(pvarg) = vt;
    if (V_ISBYREF(pvarg))
    {
        // Use a supported pointer type for derefencing.
        vt = VT_UNKNOWN;
    }

    switch (vt)
    {
    case VT_BOOL:
        // convert TRUE to VT_TRUE
        ADsAssert(*(BOOL *) pv == 1 || *(BOOL *) pv == 0);
        V_BOOL(pvarg) = VARIANT_BOOL(-*(BOOL *) pv);
        break;

    case VT_I2:
        V_I2(pvarg) = *(short *) pv;
        break;

    case VT_I4:
        V_I4(pvarg) = *(long *) pv;
        break;

    case VT_R4:
         V_R4(pvarg) = *(float *) pv;
        break;

    case VT_R8:
        V_R8(pvarg) = *(double *) pv;
        break;

    //
    // All Pointer types.
    //
    case VT_BSTR:
    case VT_LPSTR:
    case VT_LPWSTR:
    case VT_DISPATCH:
    case VT_UNKNOWN:
        V_BYREF(pvarg) = *(long **)pv;
        break;

    default:
        Assert(FALSE && "Unknown type.");
        break;
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   CParamsToDispParams
//
//  Synopsis:   Converts a C parameter list to a dispatch parameter list.
//
//  Arguments:  [pDispParams] -- Resulting dispatch parameter list.
//                               Note that the rgvarg member of pDispParams
//                               must be initialized with an array of
//                               EVENTPARAMS_MAX VARIANTs.
//
//              [pvt]         -- List of C parameter types.  May be NULL.
//                               If not NULL, Last elem in list MUST be
//                               VT_EMPTY.
//
//              [va]          -- List of C arguments.
//
//  Modifies:   [pDispParams]
//
//  History:    05-Jan-94   adams   Created
//              23-Feb-94   adams   Reversed order of disp arguments, added
//                                  support for VT_R4, VT_R8, and pointer
//                                  types.
//
//  Notes:      Only types VT_I2,VT_I4, and VT_UNKNOWN are supported.
//
//----------------------------------------------------------------------------

void
CParamsToDispParams(
        DISPPARAMS *    pDispParams,
        VARTYPE *       pvt,
        va_list         va)
{
    ADsAssert(pDispParams);
    ADsAssert(pDispParams->rgvarg);

    VARIANTARG *    pvargCur;           // current variant
    VARTYPE *       pvtCur;            // current vartype

    // Assign vals to dispatch param list.
    pDispParams->cNamedArgs         = 0;
    pDispParams->rgdispidNamedArgs  = NULL;

    // Get count of arguments.
    if (!pvt)
    {
        pDispParams->cArgs = 0;
        return;
    }

    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
        ;

    pDispParams->cArgs = pvtCur - pvt;
    ADsAssert(pDispParams->cArgs < EVENTPARAMS_MAX);


    //
    // Convert each C-param to a dispparam.  Note that the order of dispatch
    // parameters is the reverse of the order of c-params.
    //

    ADsAssert(pDispParams->rgvarg);
    pvargCur = pDispParams->rgvarg + pDispParams->cArgs;
    for (pvtCur = pvt; *pvtCur != VT_EMPTY; pvtCur++)
    {
        pvargCur--;
        ADsAssert(pvargCur >= pDispParams->rgvarg);

        V_VT(pvargCur) = *pvtCur;
        if ((*pvtCur & VT_BYREF) == VT_BYREF)
        {
            V_BYREF(pvargCur) = va_arg(va, long *);
        }
        else
        {
            switch (*pvtCur)
            {
            case VT_BOOL:
                // convert TRUE to VT_TRUE
                V_BOOL(pvargCur) = VARIANT_BOOL(-va_arg(va, BOOL));
                ADsAssert(V_BOOL(pvargCur) == VB_FALSE ||
                        V_BOOL(pvargCur) == VB_TRUE);
                break;

            case VT_I2:
                V_I2(pvargCur) = va_arg(va, short);
                break;

            case VT_I4:
                V_I4(pvargCur) = va_arg(va, long);
                break;

            case VT_R4:
                V_R4(pvargCur) = va_arg(va, float);
                break;

            case VT_R8:
                V_R8(pvargCur) = va_arg(va, double);
                break;

            //
            // All Pointer types.
            //
            case VT_BSTR:
            case VT_LPSTR:
            case VT_LPWSTR:
            case VT_DISPATCH:
            case VT_UNKNOWN:
                V_BYREF(pvargCur) = va_arg(va, long *);
                break;

            default:
                Assert(FALSE && "Unknown type.\n");
            }
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Function:   DispParamsToCParams
//
//  Synopsis:   Converts Dispatch::Invoke method params to C-language params.
//
//  Arguments:  [pDP] -- Dispatch params to be converted.
//              [pvt] -- Array of types of C-params.  May be NULL.  If
//                       non-NULL, last element must be VT_EMPTY.
//              [...] -- List of pointers to c-params to be converted to.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types listed in VARIANTToCParam.
//
//----------------------------------------------------------------------------

STDAPI
DispParamsToCParams(
        DISPPARAMS *    pDP,
        UINT *          puArgErr,
        VARTYPE *       pvt,
        ...)
{
    HRESULT         hr;
    va_list         va;                // list of pointers to c-params.
    VARTYPE *       pvtCur;            // current VARTYPE of c-param.
    VARIANTARG *    pvargCur;          // current VARIANT being converted.
    void *          pv;                // current c-param being converted.
    int             cArgs;             // count of arguments.

    ADsAssert(pDP);

    hr = S_OK;
    va_start(va, pvt);
    if (!pvt)
    {
        if (pDP->cArgs > 0)
            goto BadParamCountError;

        goto Cleanup;
    }

    pvargCur = pDP->rgvarg + pDP->cArgs - 1;
    pvtCur = pvt;
    for (cArgs = 0; cArgs < (int)pDP->cArgs; cArgs++)
    {
        if (*pvtCur == VT_EMPTY)
            goto BadParamCountError;

        pv = va_arg(va, void *);
        hr = VARIANTARGToCVar(pvargCur, *pvtCur, pv);
        if (hr)
        {
            if (puArgErr)
                *puArgErr = cArgs;

            goto Cleanup;
        }

        pvargCur--;
        pvtCur++;
    }

    if (*pvtCur != VT_EMPTY)
        goto BadParamCountError;

Cleanup:
    va_end(va);
    RRETURN(hr);

BadParamCountError:
    hr = DISP_E_BADPARAMCOUNT;
    goto Cleanup;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispProp
//
//  Synopsis:   Gets a property of an object.
//
//  Arguments:  [pDisp]  -- The object containing the property.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object desired
//              [lcid]   -- The locale of the object.
//              [pvar]   -- The resulting property.  Must be initialized.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pvarg].
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
GetDispProp(
        IDispatch * pDisp,
        DISPID      dispid,
        REFIID      riid,
        LCID        lcid,
        VARIANT *   pvar,
        EXCEPINFO * pexcepinfo)
{
    HRESULT     hr;
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.
    UINT        uiErr;                 // Argument error.

    ADsAssert(pDisp);
    ADsAssert(pvar);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            pvar,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispProp
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- The object to set the property on.
//              [dispid] -- The ID of the property.
//              [riid]   -- interface of object
//              [lcid]   -- The locale of the property.
//              [pvarg]  -- The value to set.
//
//  Returns:    HRESULT.
//
//  History:    23-Feb-94   adams   Created
//              08-Apr-94   DonCl   modified to take REFIID
//
//----------------------------------------------------------------------------

HRESULT
SetDispProp(
        IDispatch *     pDisp,
        DISPID          dispid,
        REFIID          riid,
        LCID            lcid,
        VARIANTARG *    pvarg,
        EXCEPINFO *     pexcepinfo)
{
    HRESULT     hr;
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke
    UINT        uiErr;                 // Invoke error param.

    ADsAssert(pDisp);
    ADsAssert(pvarg);

    dp.rgvarg = pvarg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            riid,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            pexcepinfo,
            &uiErr);

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   GetDispPropOfType
//
//  Synopsis:   Gets a property from an object, and converts it to a c
//              variable.
//
//  Arguments:  [pDisp]  -- The object to retrieve the property from.
//              [dispid] -- Property ID.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of c-variable to receive property.
//              [pv]     -- Pointer to resulting c-variable.
//
//  Returns:    HRESULT.
//
//  Modifies:   [pv].
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports variable types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
GetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANT     varProp;               // Property retrieved.
    DISPPARAMS  dp;                    // Params for IDispatch::Invoke.

    ADsAssert(pDisp);
    ADsAssert(pv);

    dp.rgvarg = NULL;
    dp.rgdispidNamedArgs = NULL;
    dp.cArgs = 0;
    dp.cNamedArgs = 0;

    VariantInit(&varProp);
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYGET,
            &dp,
            &varProp,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    hr = VARIANTARGToCVar(&varProp, vt, pv);

Cleanup:
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   SetDispPropOfType
//
//  Synopsis:   Sets a property on an object.
//
//  Arguments:  [pDisp]  -- Object to set property on.
//              [dispid] -- Property ID to set.
//              [lcid]   -- Locale of property.
//              [vt]     -- Type of property to set.
//              [pv]     -- Pointer to property value.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//  Notes:      Supports types found in VARIANTARGToCVar.
//
//----------------------------------------------------------------------------

HRESULT
SetDispPropOfType(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vt,
        void *      pv)
{
    HRESULT     hr;
    VARIANTARG  varg;                   // Variant property to put.
    DISPID      dispidPut = DISPID_PROPERTYPUT; // Dispid of prop arg.
    DISPPARAMS  dp;                    // Params for Invoke

    ADsAssert(pDisp);
    ADsAssert(pv);

    VariantInit(&varg);
    CVarToVARIANTARG(pv, vt, &varg);
    dp.rgvarg = &varg;
    dp.rgdispidNamedArgs = &dispidPut;
    dp.cArgs = 1;
    dp.cNamedArgs = 1;
    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_PROPERTYPUT,
            &dp,
            NULL,
            NULL,
            NULL);
    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Function:   CallDispMethod
//
//  Synopsis:   Calls a late-bound method on a object via IDispatch::Invoke.
//
//  Arguments:  [pDisp]     -- Object to call method on.
//              [dispid]    -- Method ID.
//              [lcid]      -- Locale of method.
//              [vtReturn]  -- Type of return value.  If no return value,
//                             must be VT_VOID.
//              [pvReturn]  -- Location of return value.  If no return value,
//                             must be NULL.
//              [pvtParams] -- List of param types.  May be NULL.  If
//                             non-NULL, last entry must be VT_EMPTY.
//              [...]       -- List of params.
//
//  Returns:    HRESULT.
//
//  History:    2-23-94   adams   Created
//
//----------------------------------------------------------------------------

HRESULT
CallDispMethod(
        IDispatch * pDisp,
        DISPID      dispid,
        LCID        lcid,
        VARTYPE     vtReturn,
        void *      pvReturn,
        VARTYPE *   pvtParams,
        ...)
{
    HRESULT     hr;
    VARIANTARG  av[EVENTPARAMS_MAX];   // List of args for Invoke.
    DISPPARAMS  dp;                    // Params for Invoke.
    VARIANT     varReturn;             // Return value.
    va_list     va;                    // List of C-params.

    ADsAssert(pDisp);
    ADsAssert((vtReturn != VT_VOID) == (pvReturn != NULL));

    va_start(va, pvtParams);
    dp.rgvarg = av;
    CParamsToDispParams(&dp, pvtParams, va);
    va_end(va);

    if (pvReturn)
        VariantInit(&varReturn);

    hr = pDisp->Invoke(
            dispid,
            IID_NULL,
            lcid,
            DISPATCH_METHOD,
            &dp,
            pvReturn ? &varReturn : NULL,
            NULL,
            NULL);
    if (hr)
        goto Cleanup;

    if (pvReturn)
        hr = VARIANTARGToCVar(&varReturn, vtReturn, pvReturn);

Cleanup:
    RRETURN(hr);
}



//+------------------------------------------------------------------------
//
//  Function:   IsVariantEqual, public API
//
//  Synopsis:   Compares the values of two VARIANTARGs.
//
//  Arguments:  [pvar1], [pvar2] -- VARIANTARGs to compare.
//
//  Returns:    TRUE if equal, FALSE if not.
//
//  History:    18-Mar-93   SumitC      Created.
//              11-May-94   SumitC      don't assert for VT_UNKNOWN
//
//  Notes:      Variant type unequal returns FALSE, even if actual values
//              are the same.
//              Currently does I2, I4, R4, R8, CY, BSTR, BOOL
//              Returns FALSE for all other VariantTypes.
//
//-------------------------------------------------------------------------

BOOL
IsVariantEqual( VARIANTARG FAR* pvar1, VARIANTARG FAR* pvar2 )
{
    if( V_VT(pvar1) != V_VT(pvar2) )
        return FALSE;

    switch (V_VT(pvar1))
    {
    case VT_EMPTY :
    case VT_NULL:
        return TRUE;    // just the types being equal is good enough

    case VT_I2 :
        return (V_I2(pvar1) == V_I2(pvar2));

    case VT_I4 :
        return (V_I4(pvar1) == V_I4(pvar2));

    case VT_R4 :
        return (V_R4(pvar1) == V_R4(pvar2));

    case VT_R8 :
        return (V_R8(pvar1) == V_R8(pvar2));

    case VT_CY :
        return !memcmp(&V_CY(pvar1), &V_CY(pvar2), sizeof(CY));

    case VT_BSTR :
        return !ADsStringCmp(V_BSTR(pvar1), V_BSTR(pvar2));

    case VT_BOOL :
        return (V_BOOL(pvar1) == V_BOOL(pvar2));

    case VT_UNKNOWN:
        // returns FALSE unless the objects are the same
        return (V_UNKNOWN(pvar1) == V_UNKNOWN(pvar2));

    default:
        ADsAssert(0 && "Type not handled");
        break;
    };

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\inetsrv\iis\admin\adsi\iisext\capool.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001
//
//  File:  capool.cxx
//
//  Contents:  Contains methods for CIISApplicationPool object
//
//  History:   11-09-2000     BrentMid    Created.
//
//----------------------------------------------------------------------------

#include "iisext.hxx"
#pragma hdrstop

//
// Period to sleep while waiting for service to attain desired state
//
#define SLEEP_INTERVAL (500L)
#define MAX_SLEEP_INST (60000)       // For an instance

//  Class CIISApplicationPool

DEFINE_IPrivateDispatch_Implementation(CIISApplicationPool)
DEFINE_DELEGATING_IDispatch_Implementation(CIISApplicationPool)
DEFINE_CONTAINED_IADs_Implementation(CIISApplicationPool)
DEFINE_IADsExtension_Implementation(CIISApplicationPool)

CIISApplicationPool::CIISApplicationPool():
        _pUnkOuter(NULL),
        _pADs(NULL),
        _pszServerName(NULL),
        _pszPoolName(NULL),
        _pszMetaBasePath(NULL),
        _pAdminBase(NULL),
        _pDispMgr(NULL),
        _fDispInitialized(FALSE)
{
    ENLIST_TRACKING(CIISApplicationPool);
}

HRESULT
CIISApplicationPool::CreateApplicationPool(
  