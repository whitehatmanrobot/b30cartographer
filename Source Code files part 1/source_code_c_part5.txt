 while (quit == FALSE);
}  /* end ManageHelpDialogBox */


int CalculateDialogBoxSize(DIALOG_LIST_RECORD *currentDialogList, int *top, int *left, int *bottom, int *right,
									int extraHeight, int extraWidth)
{
	int titleWidth, maxTitleWidth = 0, settingsWidth, maxSettingsWidth = 0;
   int i, height, width, numberOfOptionLists = 0;

	while (currentDialogList[numberOfOptionLists++].lastRecord == FALSE);

	for (i=0; i<numberOfOptionLists; i++)
	{
		if (currentDialogList[i].selectable != SELECTABLE_TITLE)
		{
			int j, numberOfSettings;
      	OPTION_LIST_RECORD *currentOptionList;

			titleWidth = strlen(currentDialogList[i].leftText) + strlen(currentDialogList[i].midText) +
                   	strlen(currentDialogList[i].rightText);
			if (titleWidth > maxTitleWidth) maxTitleWidth = titleWidth;

			currentOptionList = currentDialogList[i].optionList;
   		numberOfSettings = 0;
			while (currentOptionList[numberOfSettings++].lastRecord == FALSE);

			settingsWidth = 0;
			for (j=0; j<numberOfSettings; j++)
			{
				settingsWidth += strlen(currentOptionList[j].leftText) + strlen(currentOptionList[j].midText) +
                          	strlen(currentOptionList[j].rightText);
			}
      	if (settingsWidth > maxSettingsWidth) maxSettingsWidth = settingsWidth;
		}
	}

   if ((height = numberOfOptionLists+extraHeight) > 20) height = 20;
   if ((width = maxTitleWidth+maxSettingsWidth+extraWidth) > 78) width = 78;
	if (width > 59) width = ((width+1) >> 1) << 1;      /* make width an even number >= original width */

	*top    = 14-height/2;
	*bottom = *top+height-1;
	*left   = 41-width/2;
	*right  = *left+width-1;

	return maxTitleWidth+5;
}	/* end CalculateDialogBoxSize() */


void DrawDialogBox(int top, int left, int bottom, int right, short borderFG, long borderBG, short insideFG, long insideBG, char *title)
{
   int i, height, width;

	ClearDesktop();

	height = bottom-top+1;
	width = right-left+1;

   _settextcolor(borderFG);
   _setbkcolor(borderBG);
   memset(charBuffer, '\0', LINE_LENGTH+1);
	memset(charBuffer, '', width+2);
	charBuffer[0] = '';
	charBuffer[width+1] = '';
	_settextposition(top-1, left-1);
	_outtext(charBuffer);

	memset(charBuffer, ' ', width+2);
	charBuffer[0] = '';
	charBuffer[width+1] = '';
	for (i=top; i<= bottom; i++)
	{
		_settextposition(i, left-1);
		_outtext(charBuffer);
	}

	memset(charBuffer, '', width+2);
	charBuffer[0] = '';
	charBuffer[width+1] = '';
	_settextposition(bottom+1, left-1);
	_outtext(charBuffer);

	if (*title)
	{
		charBufferLength = sprintf(charBuffer, " %s ", title);
		_settextposition(top-1, left+(width/2-charBufferLength/2));
		_outtext(charBuffer);
	}

	_settextwindow(top, left, bottom, right);
   _settextcolor(insideFG);
   _setbkcolor(insideBG);
   _clearscreen(_GWINDOW);
}	/* end DrawDialogBox() */


int PrintOptionLists(DIALOG_LIST_RECORD *currentDialogList, int currentOption, int numberOfOptionLists,
							int top, int left, int bottom, int right, int alignmentColumn)
{
	int i, j, numberOfSettings, line = 2, helpMessageFlag = FALSE;
   OPTION_LIST_RECORD *currentOptionList;

	for (i=0; i<numberOfOptionLists; i++)
	{
      _settextwindow(top, left, bottom, right);
      if (currentDialogList[i].selectable != SELECTABLE_NEVER)
      {
			_settextposition(line, 2);
																				 
				/* fill charBuffer with the title of the option */
			charBufferLength = sprintf(charBuffer, "%s%s%s", currentDialogList[i].leftText,
												currentDialogList[i].midText, currentDialogList[i].rightText);

				/* if this is not a SELECTABLE_TITLE item, right-justify title into tempBuffer */
			if (currentDialogList[i].selectable != SELECTABLE_TITLE)
			{
				tempBufferLength = sprintf(tempBuffer, "%*.*s", alignmentColumn-5, alignmentColumn-5, charBuffer);

					/* Add arrow or spaces to the front and place into charBuffer */
				if (i == currentOption)
				{
					charBufferLength = sprintf(charBuffer, "%s", tempBuffer);
				}
				else
				{
					charBufferLength = sprintf(charBuffer, "    %s", tempBuffer);
				}
			}
			switch (currentDialogList[i].selectable)
			{
				case SELECTABLE_YES		:	if (i == currentOption)
													{
         											_settextcolor(dialogBoxArrowFG);
         											_setbkcolor(dialogBoxArrowBG);
													}
													else
													{
            										_settextcolor(dialogBoxFG);
            										_setbkcolor(dialogBoxBG);
													}
													break;

				case SELECTABLE_NO		:	_settextcolor(dialogBoxDeadFG);
													_setbkcolor(dialogBoxDeadBG);
													break;

				case SELECTABLE_TITLE	:	_settextcolor(dialogBoxFG);
													_setbkcolor(dialogBoxBG);
													break;
			}
			_outtext(charBuffer);

			currentOptionList = currentDialogList[i].optionList;
   		numberOfSettings = 0;
			while (currentOptionList[numberOfSettings++].lastRecord == FALSE);

				/* print the settings for this option */
			for (j=0; j<numberOfSettings; j++)
			{
				if (currentOptionList[j].selectable == SELECTABLE_NO ||
					 currentDialogList[i].selectable == SELECTABLE_NO)
				{
					_settextcolor(dialogBoxDeadFG);
					_setbkcolor(dialogBoxDeadBG);
				}
				else if (currentOptionList[j].hot)
				{
					_settextcolor(dialogBoxHotFG);
					_setbkcolor(dialogBoxHotBG);
				}
            else
            {
				   _settextcolor(dialogBoxFG);
				   _setbkcolor(dialogBoxBG);
            }
				charBufferLength = sprintf(charBuffer, "%s%s%s", currentOptionList[j].leftText,
													currentOptionList[j].midText, currentOptionList[j].rightText);
				_outtext(charBuffer);
			}

			if (i == currentOption) charBufferLength = sprintf(charBuffer, "");
			else charBufferLength = sprintf(charBuffer, "    ");
			_settextcolor(dialogBoxArrowFG);
			_setbkcolor(dialogBoxArrowBG);
			_settextposition(line, right-left-3);
			_outtext(charBuffer);

					/* print the hint bar */
			if (i == currentOption) OutputHintBar(currentDialogList[i].hintText, JUSTIFY_LEFT, helpMessageFlag);
      }
		line++;
	}
   return line;
}  /* end PrintOptionLists() */


void PrintOkCancelButtons(int line, int width, int okHot, int cancelHot)
{
	int helpMessageFlag = FALSE;
	_settextcolor(dialogBoxArrowFG);
	_setbkcolor(dialogBoxArrowBG);

		/* print the top line of the OK button */
	if (!cancelHot) charBufferLength = sprintf(charBuffer, "ͻ");
	else charBufferLength = sprintf(charBuffer, "            ");
	_settextposition(line++, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

		/* print the middle line of the OK button */
	if (okHot) charBufferLength = sprintf(charBuffer, "");
	else	charBufferLength = sprintf(charBuffer, "    ");
	_settextposition(line, 2);
	_outtext(charBuffer);

	if (!cancelHot) charBufferLength = sprintf(charBuffer, "    OK    ");
	else charBufferLength = sprintf(charBuffer, "     OK     ");
	_settextposition(line, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	if (okHot) charBufferLength = sprintf(charBuffer, "");
	else	charBufferLength = sprintf(charBuffer, "    ");
	_settextposition(line++, width-4);
	_outtext(charBuffer);

		/* print the bottom line of the OK button / top line of Cancel button */
	if (cancelHot) charBufferLength = sprintf(charBuffer, "ͻ");
	else charBufferLength = sprintf(charBuffer, "ͼ");
	_settextposition(line++, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

		/* print the middle line of the cancel button */
	if (cancelHot) charBufferLength = sprintf(charBuffer, "");
	else charBufferLength = sprintf(charBuffer, "    ");
	_settextposition(line, 2);
	_outtext(charBuffer);

	if (cancelHot) charBufferLength = sprintf(charBuffer, "  Cancel  ");
	else charBufferLength = sprintf(charBuffer, "   Cancel   ");
	_settextposition(line, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

	if (cancelHot) charBufferLength = sprintf(charBuffer, "");
	else charBufferLength = sprintf(charBuffer, "    ");
	_settextposition(line++, width-4);
	_outtext(charBuffer);

		/* print the bottom line of the Cancel button */
	if (cancelHot)	charBufferLength = sprintf(charBuffer, "ͼ");
	else charBufferLength = sprintf(charBuffer, "            ");
	_settextposition(line++, width/2-charBufferLength/2+1);
	_outtext(charBuffer);

		/* print the hint bar if needed */
	if (cancelHot)
	{
		OutputHintBar("Press Enter now or Escape anytime to ignore these settings.", JUSTIFY_LEFT, helpMessageFlag);
	}
   else if (okHot)
	{
		OutputHintBar("Press Enter to accept these settings.", JUSTIFY_LEFT, helpMessageFlag);
	}
}	/* end PrintOkCancelButtons() */


int ProcessKeystroke(DIALOG_LIST_RECORD *currentDialogList, int *currentOptionPtr, int numberOfOptionLists, void (*helpProcPtr)(void))
{
	unsigned key;
	int ascii, scanCode;
   int returnValue = PK_NOT_DONE;
   int currentSetting = 0, numberOfSettings, currentOption = *currentOptionPtr;
	OPTION_LIST_RECORD *currentOptionList;

		/* get the current setting information */
	currentOptionList = currentDialogList[currentOption].optionList;
   numberOfSettings = 0;
	do
	{
		if (currentOptionList[numberOfSettings].hot) currentSetting = numberOfSettings;
	}
	while (currentOptionList[numberOfSettings++].lastRecord == FALSE);

	key = _bios_keybrd(keybrdRead);
	ascii = key & 0x00ff;
	scanCode = ascii ? 0 : key >> 8;

	if (ascii)
	{
      int legalKey = FALSE;

      switch (ascii)
      {
         case ENTER  :  returnValue = PK_DONE;
                        legalKey = TRUE;

									/* if currentOption > numberOfOptionLists, Cancel is highlighted */
								if (currentOption <= numberOfOptionLists)
	                        GetOptionListHotFlags(currentDialogList, numberOfOptionLists);
                        break;

         case ESCAPE :  returnValue = PK_DONE;
                        legalKey = TRUE;
                        break;

         default     :  {
                           int i;

				               ascii = toupper(ascii);

					               /* Is Key a menu line hot key? */
				               for (i=0; i<numberOfSettings; i++)
				               {
					               if (ascii == currentOptionList[i].hotKey)
					               {
						               currentOptionList[currentSetting].hot = FALSE;
						               currentOptionList[currentSetting=i].hot = TRUE;
                                 legalKey = TRUE;
						               break;
					               }
				               }
                        }
		}
      if (legalKey == FALSE)
		{
			putchar('\07');
			ClearKeyboardBuffer();
		}
	}
	else switch (scanCode)
	{
		case UP			:	do
                        {
                           if (currentOption) currentOption--;
   								else currentOption = numberOfOptionLists-1;
                        } while (currentOption < numberOfOptionLists && currentDialogList[currentOption].selectable != SELECTABLE_YES);
								break;

		case DOWN		:	do
                        {
                           if (++currentOption == numberOfOptionLists) currentOption = 0;
                        } while (currentOption < numberOfOptionLists && currentDialogList[currentOption].selectable != SELECTABLE_YES);
								break;

		case LEFT		:	if (currentOption < numberOfOptionLists)
                        {
                           currentOptionList[currentSetting].hot = FALSE;
                           do
                           {
									   if (currentSetting) currentSetting--;
									   else currentSetting = numberOfSettings-1;
                           } while (currentOptionList[currentSetting].selectable != SELECTABLE_YES);
									currentOptionList[currentSetting].hot = TRUE;
                        }
                        else putchar('\07');
								break;

		case RIGHT		:	if (currentOption < numberOfOptionLists)
                        {
                           currentOptionList[currentSetting].hot = FALSE;
                           do
                           {
   									if (++currentSetting == numberOfSettings) currentSetting = 0;
                           } while (currentOptionList[currentSetting].selectable != SELECTABLE_YES);
									currentOptionList[currentSetting].hot = TRUE;
                        }
                        else putchar('\07');
								break;

      case F1_KEY    :  (helpProcPtr)();
                        returnValue = PK_REDRAW_SCREEN;
                        break;

      default        :  putchar('\07');
								ClearKeyboardBuffer();
								break;
	}
   *currentOptionPtr = currentOption;
   return returnValue;
}  /* end ProcessKeystroke() */


void ManageDialogBox(DIALOG_LIST_RECORD *currentDialogList, char *title, void (*helpProcPtr)())
{
	int numberOfOptionLists, currentOption=0;
   int line, top, bottom, left, right, width = 0, titleWidth = 0;
	int returnValue = PK_REDRAW_SCREEN;

   numberOfOptionLists = 0;
	while (currentDialogList[numberOfOptionLists++].lastRecord == FALSE);

   SetOptionListHotFlags(currentDialogList, numberOfOptionLists);
	do
	{
      if (returnValue == PK_REDRAW_SCREEN)
      {
	      int extraHeight = 7, extraWidth = 11;
	      titleWidth = CalculateDialogBoxSize(currentDialogList, &top, &left, &bottom, &right, extraHeight, extraWidth);
	      DrawDialogBox(top, left, bottom, right, dialogBoxBorderFG, dialogBoxBorderBG, dialogBoxFG, dialogBoxBG, title);
			width = right-left+1;
         returnValue = PK_NOT_DONE;
      }
			/* Print the option lists in the dialog box */
      line = PrintOptionLists(currentDialogList, currentOption, numberOfOptionLists, top, left, bottom, right, titleWidth);
		_settextwindow(top, left, bottom, right);
/*
		PrintOkCancelButtons(line, width, currentOption == numberOfOptionLists, currentOption > numberOfOptionLists);
*/

		_settextcolor(dialogBoxFG);
		_setbkcolor(dialogBoxBG);
		charBufferLength = sprintf(charBuffer, "Press Enter to accept");
		_settextposition(bottom-top-2, width/2-charBufferLength/2+1);
		_outtext(charBuffer);
		charBufferLength = sprintf(charBuffer, "Press Esc to cancel");
		_settextposition(bottom-top-1, width/2-charBufferLength/2+1);
		_outtext(charBuffer);
		charBufferLength = sprintf(charBuffer, "Press F1 for more information");
		_settextwindow(top, left, bottom, right);
		_settextposition(bottom-top+1, width/2-charBufferLength/2+1);
		_outtext(charBuffer);

		returnValue = ProcessKeystroke(currentDialogList, &currentOption, numberOfOptionLists, helpProcPtr);
	} while (returnValue != PK_DONE);
   _settextwindow(1, 1, 25, 80);
}	/* end ManageDialogBox() */


void DisplayAlertBox(char *alertText, int alertBoxHeight, int alertBoxWidth)
{
   int top, bottom, left, right;
   int line, count, quit = FALSE, helpMessageFlag = FALSE;
   char *currentLine, currentChar;

	top    = 13-alertBoxHeight/2;
	bottom = top+alertBoxHeight-1;
	left   = 41-alertBoxWidth/2;
	right  = left+alertBoxWidth-1;

   DrawDialogBox(top, left-1, bottom, right+1, alertBoxFG, alertBoxBG, alertBoxFG, alertBoxBG, "ALERT");

	currentLine = alertText;
	currentChar = currentLine[count=0];

   line = 1;
	while (quit == FALSE)
	{
		while (currentChar != '\n' && currentChar != '\0' && count < alertBoxWidth)
			currentChar = currentLine[++count];
		if (count == alertBoxWidth)
		{
			while (currentChar != ' ' && count) currentChar = currentLine[--count];
			if (count == 0) count = alertBoxWidth;
		}

		strncpy(charBuffer, currentLine, count+1);
		charBuffer[count] = '\0';
		_settextposition(line++, 2);
		_outtext(charBuffer);

		if (currentLine[count] == 0) quit = TRUE;
      else if (line == alertBoxHeight-1)
      {
         charBufferLength = sprintf(charBuffer, "Press any key to continue");
         _settextposition(alertBoxHeight, (alertBoxWidth-charBufferLength)/2+2);
         _outtext(charBuffer);
         putchar('\07');
         WaitForAnyKey();
         _clearscreen(_GWINDOW);
         line = 2;
      }
      else
		{
			currentLine += count+1;
			count = 0;
			currentChar = currentLine[count];
		}
	}

   charBufferLength = sprintf(charBuffer, "Press any key to continue");
   _settextposition(alertBoxHeight, (alertBoxWidth-charBufferLength)/2+2);
   _outtext(charBuffer);
	ClearKeyboardBuffer();
   WaitForAnyKey();
}  /* end DisplayAlertBox() */


void SetOptionListHotFlags(DIALOG_LIST_RECORD *currentDialogList, int numberOfOptionLists)
{
	int i, j;
   OPTION_LIST_RECORD *currentOptionList;

      /* Initialize the data structure of the current feature from the global variables */
   for (i=0; i<numberOfOptionLists; i++)
   {
      currentOptionList = currentDialogList[i].optionList;
      j=0;
      do
      {
				/* if the option is not selectable, it can not be hot */
			if (currentOptionList[j].selectable != SELECTABLE_YES)
				currentOptionList[j].hot = FALSE;
			else switch (currentDialogList[i].paramLength)
         {
            case 1 : currentOptionList[j].hot = ((*(unsigned char far *) (currentDialogList[i].paramPtr) ==
																  (unsigned char) currentOptionList[j].paramValue) ? TRUE : FALSE); break;
            case 2 : currentOptionList[j].hot = ((*(unsigned int  far *) (currentDialogList[i].paramPtr) ==
																  (unsigned int)  currentOptionList[j].paramValue) ? TRUE : FALSE); break;
         }
      } while (currentOptionList[j++].lastRecord == FALSE);
   }
}	/* end SetOptionListHotFlags() */


void GetOptionListHotFlags(DIALOG_LIST_RECORD *currentDialogList, int numberOfOptionLists)
{
	int i, j;
   OPTION_LIST_RECORD *currentOptionList;

      /* Update global variables from data structure of current feature */
   for (i=0; i<numberOfOptionLists; i++)
   {
      currentOptionList = currentDialogList[i].optionList;
      j=0;
      do
      {
         switch (currentDialogList[i].paramLength)
         {
            case 1 : if (currentOptionList[j].hot) (*(unsigned char far *) (currentDialogList[i].paramPtr) =
																	 (unsigned char) currentOptionList[j].paramValue); break;
            case 2 : if (currentOptionList[j].hot) (*(unsigned int  far *) (currentDialogList[i].paramPtr) =
																	 (unsigned int)  currentOptionList[j].paramValue); break;
         }
      } while (currentOptionList[j++].lastRecord == FALSE);
   }
}	/* end GetOptionListHotFlags() */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\drv.c ===
/*  drv.c  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "drv.h"
#include "serkeys.h"
#include "init.h"
#include "int9.h"
#include <dos.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>



/*******************************/
void kickStartSerialKeys(void)
{
	BYTE biosPauseFlag;

	/* take care of mouse stuff */
	sendMouseData();

	/*
		This section is to make sure the serial int does not get hung up if the int 15h does not run.
		This was put here especially for when you are running serialkey in a DOS shell under windows.  When you
		send the keys to exit back to Windows, Windows traps them,
	*/
	_asm cmp byte ptr cs:forcedInt9Flag,TRUE
	_asm jne kickDone
		if (!(--waitForInt9Timeout)) {
			_asm mov byte ptr cs:forcedInt9Flag,FALSE
			tryingToWriteKeyboardData = FALSE;
			initGIDEI();
			putPosSBuf = commBuf;
			getPosSBuf = commBuf;
			numCommChars = 0;
			waitForInt9Timeout = INT9TIMEOUT;
			}
kickDone:


	biosPauseFlag = inPauseCondition();

	/* this will get serial keys running again if we injected a key that caused */
	/* a pause to occur.  Serial keys will then handle the pause itself. */
	if (inSerialKeys && biosPauseFlag) {
		if (weInjectedFlag) {
			inPauseFlag = TRUE;
			clearInPause();
			}
		/* this will clear a pause that occurred from the keyboard while we were in*/
		/* the serial keys routine.  The typist will just have to do it again. */
		else if (!prevPauseState && !inPauseFlag) clearInPause();
		}

	if (!fatalErrorFlag && (keyBufferEmpty() || biosPauseFlag)) {

		/* will turn handshaking back on if we exited because the keyboard buffer was full */
		/* and all other buffers were empty */
		if (needTimerHelp) {
	 		needTimerHelp = FALSE;
			if (!inSerialKeys && !numCommChars) turnOnHandshake();
			}
		/* will get serial keys going if we exited for whatever reason and serial chars stopped */
		/* but our buffers still have chars to process */
		else if (!inSerialKeys && (numCommChars || (putPosOBuf != getPosOBuf))) {
			if (!(--timerCount)) {
				if (inp(LSR+skCommPortAddr) & THRE_FLAG) {
					if (inp(MCR+skCommPortAddr) & (RTS_BIT | DTR_BIT))
						outp(THR+skCommPortAddr,XON);
					else
						outp(THR+skCommPortAddr,XOFF);
					}
				outp(IER+skCommPortAddr,inp(IER+skCommPortAddr) | INT_THRE);
				sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
				}
			}
		}

/*	if (!(--sendSoftHandshakeStatus)) {
		if (inp(MCR+skCommPortAddr) & (RTS_BIT | DTR_BIT))
			outp(THR+skCommPortAddr,XON);
		else
			outp(THR+skCommPortAddr,XOFF);
		sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
		}
*/

}


/*******************************/

/*******************************/
void doSerial (void)
{

	BOOL inIntFlag, inPauseTemp;
	BOOL doneWithLoop;
	BYTE temp;

	inIntFlag = inSerialKeys;							/* get flag to see if 1st instance already active */
	inSerialKeys = TRUE;									/* set global because if we were not already active, we are now */
	timerCount = TIMERTIMEOUT;
	sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
	_asm cli
	temp = inp(IIR+skCommPortAddr) & 7;				/* get interrupt id */
	outp(IER+skCommPortAddr,inp(IER+skCommPortAddr) & (INT_RCV | INT_RLS));		/* clear out int on THRE in case it is set */
	if ((temp == 4) || (temp == 6)) {				/* 4=receive char   6=error */

		/* store character and status if room available */
		if (numCommChars < COMMBUFLEN) {		
			putPosSBuf->serChar = inp(RBR+skCommPortAddr);
			putPosSBuf->status = (temp == 6) ? inp(LSR+skCommPortAddr) : 0;
			putPosSBuf = (putPosSBuf+1 >= (commBuf+COMMBUFLEN)) ? commBuf : putPosSBuf+1;
			numCommChars++;
			if (numCommChars >= DEACTHANDSHAKE) turnOffHandshake();
			}
		/* if no room, just clear interrupt */
		else if (temp == 6) inp(LSR+skCommPortAddr);
		else inp(RBR+skCommPortAddr);
		}
	_asm cli
	if (tryingToWriteKeyboardData)					/* do send EOI if in this mode */
		tryingToWriteKeyboardData = FALSE;
	else
		outp(0x20,0x20);									/* reset int controller so serial ints can come it again */

	if (!waitingForIndicatorUpdate() && !inIntFlag) {
		inPauseFlag = FALSE;
		prevPauseState = inPauseCondition();
		_asm sti;
		if (!needTimerHelp || prevPauseState) {
			doneWithLoop = false;
			do {
				/* clear out output buffer before processing anymore serial chars */
				while ((putPosOBuf != getPosOBuf) && (inPauseFlag || !keyBufferFull())) {
					if (mouBufHeadPtr != mouBufTailPtr) {
						doneWithLoop = true;
						break;
						}
					else {
						timerCount = TIMERTIMEOUT;
						sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
						getOutputBufChar();
						if (dataBlk.id == MOUSEID) injectMouse();
						else if ((dataBlk.id == KEYBDID) && (dataBlk.scanCode != 0)) {
							if (injectKeysVector == kbdBufferInjectKeysRoutine)
								(*injectKeysVector)(dataBlk.scanCode);
							else if ((injectKeysVector == write60InjectRoutine) || (injectKeysVector == int15InjectRoutine))
								softInt9InjectKeysRoutine(dataBlk.scanCode);
							else hardwareInjectKeysRoutine(dataBlk.scanCode);
							}
						}
					}
				timerCount = TIMERTIMEOUT;
				sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
				if (keyBufferFull() && !inPauseFlag) {
					turnOffHandshake();
					doneWithLoop = TRUE;
					needTimerHelp = TRUE;
					}
				/* if output buffer is empty, we can finally get serial chars */
				else if ((putPosOBuf == getPosOBuf) && (numCommChars)) {
					if (getCommByte()) serialKeysBegin();
					}
				else doneWithLoop = true;
				}
			while ((inPauseCondition() && inPauseFlag) || !doneWithLoop);
			}
		_asm cli;
		inPauseFlag = FALSE;
		inSerialKeys = FALSE;
		}
}



/************************/
BOOL getCommByte(void)
{
	BOOL temp;
	struct serialDataType tempData;

	if (temp = numCommChars) {
		_asm cli;
		numCommChars--;
		tempData = *getPosSBuf;
		getPosSBuf = (getPosSBuf+1 >= (commBuf+COMMBUFLEN)) ? commBuf : getPosSBuf+1;
		_asm sti;
		if (tempData.status) {							/* errors found */
			if (tempData.status & (BI_FLAG | FE_FLAG)) {
				if ((++feCount) >= 3) {
					_asm cli;
					handleFatalError = TRUE;
					disableComm();
					turnOffHandshake();
					timerCount = TIMERTIMEOUT;
					clearOutComm();
					_asm sti;
					disableKeyEnhance();
					initGIDEI();
					putPosSBuf = commBuf;
					getPosSBuf = commBuf;
					numCommChars = 0;
					waitForInt9Timeout = INT9TIMEOUT;
					doBeep();
					doBeep();
					doBeep();
					while (!(inp(LSR+skCommPortAddr) & (THRE_FLAG | TSRE_FLAG)));
					if (!singleUserSetup) skBaudRate = BAUD300;
					setBaudRate();
					clearOutComm();
					serialKeysStateInit();
					_asm cli
					feCount = 0;
					enableComm();
					turnOnHandshake();
					handleFatalError = FALSE;
					_asm sti;
					}
				doBeep();
				}
			else doBeep();
			}
		else {
			feCount = 0;
			serByte = tempData.serChar;
			}
		if (temp <= ACTHANDSHAKE) {
			if (!(inp(MCR+skCommPortAddr) & (RTS_BIT | DTR_BIT)))
				turnOnHandshake();
			}
		return (!tempData.status);
		}
	else return (FALSE);

}


	
/*******************************************************/
void hardwareInjectKeysRoutine(BYTE scanCode) 	/* part of keyboard driver */
{
	int timeOut;

	timeOut = 0x100;
	while (--timeOut);
	waitForInt9Timeout = INT9TIMEOUT;
	if (inPauseCondition()) weInjectedFlag = FALSE;
	else {
		inPauseFlag = FALSE;
		weInjectedFlag = TRUE;
		}
	_asm {
		sti
		sub	cx,cx
hardlp1:
		in		al,64h
		jmp	$+2
		test	al,2
		loopnz	hardlp1
		}
		(*injectKeysVector)(scanCode);
	_asm {
		sti
hardlp3:
		mov	al,cs:serialKeysOn
		or		al,al
		jnz	hardlp4
		mov	cs:forcedInt9Flag,0
hardlp4:
//		cmp BYTE PTR cs:forcedInt9Flag,0
//		jne hardlp3
		cli
		}
	if (weInjectedFlag && inPauseFlag)
		setInPause();
	weInjectedFlag = FALSE;
	_asm sti
	return;
}

/*******************************************************/
void D2InjectRoutine(BYTE scanCode)
{
	_asm {
		cli
		mov	al,0d2h
		out	64h,al
		jmp	$+2
		mov	al,scanCode
		mov	BYTE PTR cs:injectByte,al
		mov	BYTE PTR cs:forcedInt9Flag,1;
		sub	cx,cx
D2lp2:
		in		al,64h
		jmp	$+2
		test	al,2
		loopnz	D2lp2
		mov	al,scanCode
		out	60h,al
		sti
		}
}

/*******************************************************/
void write3fInjectRoutine(BYTE scanCode)
{
	_asm {
		cli
		mov	al,07Fh
		out	64h,al
		jmp	$+2
		sub	cx,cx
althardlp2:
		in		al,64h
		jmp	$+2
		test	al,3
		loopnz	althardlp2
		mov	al,scanCode
		out	60h,al
		sti
		mov	BYTE PTR cs:injectByte,al
		mov	BYTE PTR cs:forcedInt9Flag,1;
		sub	cx,cx
althardlp3:
		in		al,64h
		jmp	$+2
		test	al,3
		loopnz	althardlp3
		mov	al,03Fh
		out	64h,al
		sti

althardlp4:
;		in		al,64h
;		jmp	$+2
;		test	al,3
;		loopnz	althardlp4
;		sub	cx,cx
;althardlp5:
;		in		al,64h
;		jmp	$+2
;		test	al,3
;		loopz	althardlp5
;		cli

		}
}

/*******************************************************/
void write20InjectRoutine(BYTE scanCode)
{
	_asm {
		mov	al,scanCode
		mov	BYTE PTR cs:injectByte,al
		mov	BYTE PTR cs:forcedInt9Flag,1;
		mov	al,020h
		out	64h,al
		}
}

/*******************************************************/
void softInt9InjectKeysRoutine(BYTE scanCode)
{
	waitForInt9Timeout = INT9TIMEOUT;
	_asm cli
	if (inp(MCR+skCommPortAddr) & (RTS_BIT | DTR_BIT))
		outp(THR+skCommPortAddr,XON);
	else
		outp(THR+skCommPortAddr,XOFF);
	outp(IER+skCommPortAddr,inp(IER+skCommPortAddr) | INT_THRE);			 /* set to interrupt on receive char, error and THRE */
	tryingToWriteKeyboardData = TRUE;
	_asm sti
	while (tryingToWriteKeyboardData);
	waitForInt9Timeout = INT9TIMEOUT;
	if (inPauseCondition()) weInjectedFlag = FALSE;
	else {
		inPauseFlag = FALSE;
		weInjectedFlag = TRUE;
		}
	_asm {
		cli
		mov	al,scanCode
		mov	BYTE PTR cs:injectByte,al
		mov	BYTE PTR cs:forcedInt9Flag,1;
		}
	(*injectKeysVector)(scanCode);
	_asm	sti
	_asm	int	9h

	if (weInjectedFlag && inPauseFlag)
		setInPause();
	weInjectedFlag = FALSE;
	_asm sti
	return;
}

/*******************************************************/
void write60InjectRoutine(BYTE scanCode)
{
	_asm	mov	al,scanCode
	_asm	out	60h,al
}

/*******************************************************/
void int15InjectRoutine(BYTE scanCode)
{
}


/************************/
void putInOutputBuf(void)
{
	/* putPosOBuf points to next free storage spot */
	/* If putPosOBuf+1 = getPosOBuf then buffer is full*/
	/* also, if putPosOBuf+1 = end of codebuffer then rap around */
	/* to begin unless getPosOBuf=begin cuz buffer is full */

	if (!((putPosOBuf+1 == getPosOBuf) || ((putPosOBuf+1 >= (outputBuf+OUTPUTBUFLEN)) && (getPosOBuf == outputBuf)))) {
		*putPosOBuf = dataBlk;
		putPosOBuf = (putPosOBuf+1 >= (outputBuf+OUTPUTBUFLEN)) ? outputBuf : putPosOBuf+1;
		}
}


/************************/

void getOutputBufChar(void)
{
	if (putPosOBuf != getPosOBuf) {
		dataBlk.id = getPosOBuf->id;
		dataBlk.mou.status = getPosOBuf->mou.status;
		dataBlk.mou.deltaX = getPosOBuf->mou.deltaX;
		dataBlk.mou.deltaY = getPosOBuf->mou.deltaY;
		getPosOBuf = (getPosOBuf+1 >= (outputBuf+OUTPUTBUFLEN)) ? outputBuf : getPosOBuf++;
		}
	return;
}

/************************/
BOOL keyInTbl(BYTE searchElement, BYTE * tblPtr)
{
	for (;(*tblPtr != searchElement) && (*tblPtr != 0); tblPtr++);
	if (*tblPtr == searchElement) return (TRUE);
	else return(FALSE);
}

/************************/
BOOL suppressCode (BYTE keyCode)
{
	/* extended keyboard doesn't send out codes for some keys when both alt keys are down */
	if (kState.lAlt && kState.rAlt && keyInTbl(keyCode,altSuppressedTbl)) return (TRUE);

	/* extended keyboard doesn't send out codes for some keys when both control keys are down */
	else if (kState.lCtrl && kState.rCtrl && keyInTbl(keyCode,ctrlSuppressedTbl)) return (TRUE);

	/* extended keyboard doesn't send out codes for some keys when both shift keys are down */
	else if (kState.lShift && kState.rShift && keyInTbl(keyCode,shiftSuppressedTbl)) return(TRUE);

	else return (FALSE);
}




/*******************************************************/
void upScanPS2 (BYTE keynum)
{

	BYTE *tempPtr;
	BYTE temp;

	dataBlk.id = KEYBDID;

	switch (keynum)
		{
		case 57:
			kState.rShift = FALSE;
			break;
		case 44:
			kState.lShift = FALSE;
			break;
		case 64:
			kState.rCtrl = FALSE;
			break;
		case 58:
			kState.lCtrl = FALSE;
			break;
		case 62:
			kState.rAlt = FALSE;
			break;
		case 60:
			kState.lAlt = FALSE;
			break;
		case 90:
/*			kState.numlck = FALSE;*/
			break;
		}
	keynum &= 0x7F;

	if (suppressCode(keynum)) return;

	temp = IBMextendedScanCodeSet1[keynum] | 0x80;
	switch (keynum)
		{
		case 62:
		case 64:
		case 108:
			dataBlk.scanCode = 0xE0;
			putInOutputBuf ();
			dataBlk.scanCode = temp;
			putInOutputBuf ();
			break;

		case 75:
		case 76:
		case 79:
		case 80:
		case 81:
		case 83:
		case 84:
		case 85:
		case 86:
		case 89:
		case 95:
			dataBlk.scanCode = 0xE0;
			putInOutputBuf ();
			dataBlk.scanCode = temp;
			putInOutputBuf ();
			if (kState.numlck && (keynum != 95))
				{
				if (!(kState.rShift || kState.lShift))
					{
					dataBlk.scanCode = 0xE0;
					putInOutputBuf ();
					dataBlk.scanCode = 0xAA;
					putInOutputBuf ();
					}
				}
			else if (!kState.rShift && kState.lShift)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x2A;
				putInOutputBuf ();
				}
			else if (kState.rShift && !kState.lShift)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x36;
				putInOutputBuf ();
				}
			else if (kState.rShift && kState.lShift)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x36;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x2A;
				putInOutputBuf ();
				}
			break;
	
		case 124:
			if (kState.rAlt || kState.lAlt) {
				dataBlk.scanCode = 0xD4;
				putInOutputBuf ();
				}
			else if (kState.rCtrl || kState.lCtrl || kState.rShift || kState.lShift)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0xB7;
				putInOutputBuf ();
				}
			else
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0xB7;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0xAA;
				putInOutputBuf ();
				}
			break;
	
		case 126:
			break;
	
		default:
			if (temp != 0x80) {
				dataBlk.scanCode = temp;
				putInOutputBuf ();
				}
			break;
		}
	return;
}
	
	
	
	
/*******************************************************/
void downScanPS2 (BYTE keynum)
{
	BYTE *tempPtr;

	dataBlk.id = KEYBDID;

	switch (keynum)
		{
		case 57:
			kState.rShift = TRUE;
			break;
		case 44: 
			kState.lShift = TRUE;
			break;
		case 64: 
			kState.rCtrl = TRUE;
			break;
		case 58: 
			kState.lCtrl = TRUE;
			break;
		case 62: 
			kState.rAlt = TRUE;
			break;
		case 60:
			kState.lAlt = TRUE;
			break;
		case 90: 
			kState.numlck = ~kState.numlck;
			break;
		}

	keynum &= 0x7F;

	if (suppressCode(keynum)) return;

	switch (keynum)
		{

		case 62:
		case 64:
		case 108:
			dataBlk.scanCode = 0xE0;
			putInOutputBuf ();
			break;
		
		case 75:
		case 76:
		case 79:
		case 80:
		case 81:
		case 83:
		case 84:
		case 85:
		case 86:
		case 89:
		case 95:
			dataBlk.scanCode = 0xE0;
			putInOutputBuf ();
			if (kState.numlck && (keynum != 95))
				{
				if (!(kState.rShift || kState.lShift)) 
					{
					dataBlk.scanCode = 0x2A;
					putInOutputBuf ();
					dataBlk.scanCode = 0xE0;
					putInOutputBuf ();
					}
				}
			else if (!kState.rShift && kState.lShift)
				{
				dataBlk.scanCode = 0xAA;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				}
			else if (kState.rShift && !kState.lShift)
				{
				dataBlk.scanCode = 0xB6;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				}
			else if (kState.rShift && kState.lShift)
				{
				dataBlk.scanCode = 0xAA;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0xB6;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				}
			break;
	
		case 124:
			if (kState.rAlt || kState.lAlt) {
				dataBlk.scanCode = 0x54;
				putInOutputBuf ();
				}
			else if (kState.rCtrl || kState.lCtrl || kState.rShift || kState.lShift)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x37;
				putInOutputBuf ();
				}
			else
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x2A;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x37;
				putInOutputBuf ();
				}
			break;
	
		case 126:
			if (kState.rCtrl || kState.lCtrl)
				{
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0x46;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE0;
				putInOutputBuf ();
				dataBlk.scanCode = 0xC6;
				putInOutputBuf ();
				}
			else
				{
				dataBlk.scanCode = 0xE1;
				putInOutputBuf ();
				dataBlk.scanCode = 0x1D;
				putInOutputBuf ();
				dataBlk.scanCode = 0x45;
				putInOutputBuf ();
				dataBlk.scanCode = 0xE1;
				putInOutputBuf ();
				dataBlk.scanCode = 0x9D;
				putInOutputBuf ();
				dataBlk.scanCode = 0xC5;
				putInOutputBuf ();
				}
			break;
		}
	dataBlk.scanCode = IBMextendedScanCodeSet1[keynum];
	putInOutputBuf ();
}


/*******************************************************/
void downScanAT (BYTE keynum)
{
	dataBlk.id = KEYBDID;
	dataBlk.scanCode = keynum;
	putInOutputBuf ();
}


/*******************************************************/
void upScanAT (BYTE keynum)
{
	dataBlk.id = KEYBDID;
	dataBlk.scanCode = (BYTE)(keynum | 0x80);
	putInOutputBuf ();
}



/********************************************************************************/
/********************************************************************************/
/********************************************************************************/
/********************************************************************************/
/********************************************************************************/
/*****
Serial Mouse
(serial format = 7 data bits)

           7  6  5  4  3  2  1  0
           |  |  |  |  |  |  |  |
           |  |  |  |  |  |  |  |-- D6 of X
           |  |  |  |  |  |  |
           |  |  |  |  |  |  |----- X sign bit (positive right)
           |  |  |  |  |  |
           |  |  |  |  |  |-------- D6 of Y
           |  |  |  |  |
           |  |  |  |  |----------- Y sign bit (positive up)
           |  |  |  |
           |  |  |  |-------------- Right Button (0=up 1=down)
           |  |  |
           |  |  |----------------- Left Button (0=up  1=down)
           |  |
           |  |-------------------- 1  1st packet of 3  ( 0 for packets 2 and 3)
           |
           |----------------------- 0

PS2 Mouse

byte order:   status/sign, X, Y

           7  6  5  4  3  2  1  0
           |  |  |  |  |  |  |  |
           |  |  |  |  |  |  |  |-- Left Button (0=up  1=down)
           |  |  |  |  |  |  |
           |  |  |  |  |  |  |----- Right Button (0=up 1=down)
           |  |  |  |  |  |
           |  |  |  |  |  |-------- 0
           |  |  |  |  |
           |  |  |  |  |----------- 1                       
           |  |  |  |                                                         
           |  |  |  |-------------- X sign bit (positive right)
           |  |  |                                                          
           |  |  |----------------- Y sign bit (positive up)
           |  |   
           |  |-------------------- 0 (1 if X overflow)                        
           |
           |----------------------- 0 (1 if Y overflow)
********************************************************************************/

void injectMouse(void)
{
	switch (fmouse_id) {
		case PS2MOUSE:
			injectPS2Mouse();
			break;
		case SERIALMOUSE:
			if (combase)
				injectSerialMouse();
			break;
		default:
			break;
		}
}


/*******************************************************************************/
void injectSerialMouse(void)
{
	volatile BYTE tmp;
	BYTE tmpStatus;
	signed char tempX,tempY;

	/* Can only send -128 to +127 at a time so must repeat until all is sent */
	do {
		if (dataBlk.mou.deltaX < -128) tempX = -128;
		else if (dataBlk.mou.deltaX > 127) tempX = 127;
		else tempX = dataBlk.mou.deltaX;
		dataBlk.mou.deltaX -= tempX;

		if (dataBlk.mou.deltaY < -127) tempY = -127;	/* use 127 because -(-128) undefined */
		else if (dataBlk.mou.deltaY > 127) tempY = 127;
		else tempY = (signed char) dataBlk.mou.deltaY;
		dataBlk.mou.deltaY -= tempY;

		tmpStatus = (dataBlk.mou.status & LEFTBUTTONCODE) ? 0x20 : 0;	/* set or clear left button  */
		tmpStatus |= (dataBlk.mou.status & RIGHTBUTTONCODE) ? 0x10 : 0;	/* set or clear right button  */
		tmpStatus |= 0x40;			/* set first packet bit */
		if (tempX < 0) tmpStatus |= 0x02;
		if (tempY < 0) tmpStatus |= 0x08;
		if (tempX & 0x40) {
			tmpStatus |= 0x01;
			tempX &= 0x3f;
			}
		if (tempY & 0x40) {
			tmpStatus |= 0x04;
			tempY &= 0x3f;
			}

		putInMouseBuffer(tmpStatus,tempX,tempY);
/*		putInMouseBuffer(tmpStatus);
		putInMouseBuffer(tempX);
		putInMouseBuffer(tempY);
*/
		}
	while (dataBlk.mou.deltaX || dataBlk.mou.deltaY);
}



/*******************************************************************************/
void injectPS2Mouse(void)
{
	BYTE tmpStatus;
	signed char tempX,tempY;

	/* Can only send -128 to +127 at a time so must repeat until all is sent */
	do {
		if (dataBlk.mou.deltaX < -128) tempX = -128;
		else if (dataBlk.mou.deltaX > 127) tempX = 127;
		else tempX = dataBlk.mou.deltaX;
		dataBlk.mou.deltaX -= tempX;

		if (dataBlk.mou.deltaY < -127) tempY = -127;	/* use 127 because -(-128) undefined */
		else if (dataBlk.mou.deltaY > 127) tempY = 127;
		else tempY = (signed char) dataBlk.mou.deltaY;
		dataBlk.mou.deltaY -= tempY;

		/* Unfortunately, down on the IBM is negative so we switch the sign */
		/* to make down positive for the GIDEI standard */

		tempY = -tempY;
		tmpStatus = dataBlk.mou.status | 0x08;
		if (tempX < 0) tmpStatus |= 0x10;
		if (tempY < 0) tmpStatus |= 0x20;

		putInMouseBuffer(tmpStatus,tempX,tempY);
		}

	while (dataBlk.mou.deltaX || dataBlk.mou.deltaY);
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dialogs.h ===
#if !defined(MESSAGES)
#include "messages.h"		/* messages.h needed for declaration of HELP_SCREEN_RECORD */
#endif

#if !defined(MENUDATA)
#include "menudata.h"		/* messages.h needed for declaration of DIALOG_LIST_RECORD */
#endif

#define  PK_DONE           1
#define  PK_NOT_DONE       2
#define  PK_REDRAW_SCREEN  3


	/* begin Prototypes */

void DisplayNotImplementedMessage(char *messageText);

void AboutAccess(void);
void QuitAccess(int callingRoutine);
void InstallAccess(void);
void CancelAccess(void);

void StickyKeys(void);
void MouseKeys(void);
void ToggleKeys(void);
void SerialKeys(void);
void KeyboardPackage(void);
void ShowSounds(void);
void TimeOut(void);
void Miscellaneous(void);

void CancelAccessHelp(void);
void InstallAccessHelp(void);
void SaveParametersHelp(void);

void MenuHelp(void);
void GeneralInfo(void);
void StickyKeysHelp(void);
void MouseKeysHelp(void);
void ToggleKeysHelp(void);
void SerialKeysHelp(void);
void KeyboardPackageHelp(void);
void ShowSoundsHelp(void);
void TimeOutHelp(void);
void MiscellaneousHelp(void);

void DisplayTextInHelpDialogBox(char *dialogText, int height, int width);
void ManageHelpDialogBox(HELP_SCREEN_RECORD *helpScreen, char *title);
int PrintOptionLists(DIALOG_LIST_RECORD *currentDialogList, int currentOption, int numberOfOptionLists,
							int top, int left, int bottom, int right, int alignmentColumn);
int ProcessKeystroke(DIALOG_LIST_RECORD *currentDialogList, int *currentOptionPtr, int numberOfOptionLists, void (*helpProcPtr)(void));
void ManageDialogBox(DIALOG_LIST_RECORD *currentDialogList, char *title, void (*helpProcPtr)());
int CalculateDialogBoxSize(DIALOG_LIST_RECORD *currentDialogList, int *top, int *left, int *bottom, int *right,
									int extraHeight, int extraWidth);
void DrawDialogBox(int top, int left, int bottom, int right, short borderFG, long borderBG, short insideFG, long insodeBG, char *title);
void DisplayAlertBox(char *alertText, int alertBoxHeight, int alertBoxWidth);
void PrintOkCancelButtons(int line, int width, int okHot, int cancelHot);
void SetOptionListHotFlags(DIALOG_LIST_RECORD *currentDialogList, int numberOfOptionLists);
void GetOptionListHotFlags(DIALOG_LIST_RECORD *currentDialogList, int numberOfOptionLists);

	/* end Prototypes */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\drv.h ===
/*  drv.h  */


void kickStartSerialKeys(void);
void doSerial (void);

BOOL getCommByte(void);

void hardwareInjectKeysRoutine(BYTE scanCode);
void D2InjectRoutine(BYTE scanCode);
void write3fInjectRoutine(BYTE scanCode);
void write20InjectRoutine(BYTE scanCode);
void softInt9InjectKeysRoutine(BYTE scanCode);
void write60InjectRoutine(BYTE scanCode);
void int15InjectRoutine(BYTE scanCode);

void putInOutputBuf(void);
void getOutputBufChar(void);

void upScanPS2 (BYTE keynum);
void downScanPS2 (BYTE keynum);
void upScanAT (BYTE keynum);
void downScanAT (BYTE keynum);

void injectPS2Mouse(void);
void injectSerialMouse(void);
void injectMouse(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\frontend.h ===
/* Start of Function Protocols */

void RedrawScreen(int helpMessageFlag);
void OutputHintBar(char *hintText, int justifyFlag, int helpMessageFlag);
void ClearDesktop(void);
void OutputTitleBar(void);

void ManageMenu(void);
int  PrintMenuBar(int currentMenu);
void PrintMenuList(int currentMenuList, int leftMargin);

   /* end of Function Protocols */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\filter.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	FILTER.ASM							*
;									*
;************************************************************************

TITLE	FilterKeys

INCLUDE	keyboard.inc

	EXTRN	shift_tbl:byte				; in Handicap.asm
	EXTRN	shift_tbl_len:abs
	EXTRN 	real_states:byte
	EXTRN	prev_real_states:byte
	EXTRN	current_shift:byte
	EXTRN	beep_high:PROC
	EXTRN	beep_low:PROC
	EXTRN	no_beep:PROC
	EXTRN	beep_turn_on:PROC
	EXTRN	beep_turn_off:PROC
	EXTRN	click:PROC
	EXTRN	_comp_id:byte
	EXTRN	fsilent_click:byte
	EXTRN	fbios_called_timing:byte
	EXTRN	_vector:byte
	EXTRN	fswitching_video:byte
	EXTRN	faccess_sound:byte
	EXTRN	fsecond_cue:byte

	EXTRN	SticKeys:PROC	  			; in StickeyKeys.asm

	EXTRN	TimeOut_Reset:PROC			; in ToggleKeys.asm

	EXTRN	fFilterKeysOn:byte			; from Param.asm
	EXTRN	fFK_On_Off_Feedback:byte
	EXTRN	fUser_SetUp_Option1:byte
	EXTRN	fUser_SetUp_Option2:byte
	EXTRN	wait_ticks:word
	EXTRN	delay_ticks:word
	EXTRN	repeat_ticks:word
	EXTRN	fmax_default:byte
	EXTRN	fclick_on:byte
	EXTRN	fDialog_Filter_off:byte

	EXTRN	fRecovery_On:byte
	EXTRN	recovery_ticks:word


	PUBLIC	FilterKeys				; in FilterKeys.asm
	PUBLIC	FilterKeys_timer
	PUBLIC	FilterKeys_TurnOff
	PUBLIC	FilterKeys_dialog
	PUBLIC	fshift_click
	PUBLIC	on_repeat_ticks	     
	PUBLIC	on_wait_ticks

IFDEF	BUG

	EXTRN	HexCharsOut:PROC
	EXTRN	portid:byte
	EXTRN	portout:byte

ENDIF; BUG

;----------------------------------------------------------------------------
_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;
;  The below area defines the resident data area.


repeating?		DB	false		; beginning repeat
hot_key_only?		DB	false		; only hot key is down
previous_code		DW	0  		; holds previous code
prior_code		DW	0		; holds code before previous code
tick_count		DW	0		; holds the actual count that gets dec
toggle_time		DW	reset_cnt	; holds count for toggle time
fshift_click		DB	false		; holds a flag such that a modifier only clicks once
frecovery_timing	DB	false		; flag used to tell us that recovery_ticks is counting out by timer

on_wait_ticks		DW	0		; holds wait tick count while running
on_delay_ticks		DW	0		; holds delay tick count while running
on_repeat_ticks		DW	0		; holds repeat tick count while running
on_recovery_ticks	DW	0		; holds recovery tick count while running
on_delay_ticks_adj	DW	0		; holds adjusted value for delay ticks assuming recovery keys is on

;----------------------------------------------------------------------------
; FilterKeys
;
;   This routine does typeamatic rate adjustment and acceptance key timing and
;   the recovery keys routine.
;   It is called by the hardware interrupt routine keybd_int in the file, "handicap.asm".
;   FilterKeys does not depend on any register to be saved, but
;   we must save whatever we use since we are in an interrupt routine.  
;
; Expects:	AX = extended scan code
;
; Changes:	Nothing
;-----------------------------------------------------------------------------

FilterKeys	proc

	assume	DS:_TEXT
	assume	ES:_TEXT

	jmp	filter_begin

;----------------------------------------------------------------------------
; FilterKeys_timer 
;
; Increments the counts used in the turn on/off of FilterKeys and the
; acceptance, delay until repeat, and key repeat time out options.  


FilterKeys_timer	proc

	assume	DS:_TEXT

;----------------------------------------------------------------------------
; first check to see if we are manually being turned off or on.  To toggle 
; it on or off, we have it set so that the persom must hold down the
; carriage return key for at least eight seconds.  The person receives a 3 warning 
; beeps after 4 seconds.
;
FKT_10:
	cmp	hot_key_only?,false			; hot key not down?
	jne	FKT_12

	jmp	start_cnt_over				; no, it is down -->
FKT_12:

	mov	ax,toggle_time				; get current count
	cmp	ax,0					; are we at no repeat amount = 0?
	je	set_max_default				; yes -->
	jg	FKT_15

	jmp	begin_FilterKeys_timer			; less than, so already done

; Now check for toggle on/off of FilterKeys

FKT_15:
	dec	toggle_time				; no, decrement count
	cmp	ax,warning_cnt				; are we at the warning count ?
	je	warning_cnt_sub

	cmp	ax,toggle_dflt_cnt			; are we at toggle amount?
	je	turn_filter

	cmp	ax,no_accept_cnt			; are we at User setup option 1??
	je	no_accept_cnt_sub			; yes

	jmp	begin_FilterKeys_timer			; no -->

; Reached on/off time limit so toggle.

turn_filter:

	cmp	fFilterKeysOn,false			; are we off?
	je	turn_filter_on				; yes -->
	call	fk_turn_off_fb
	mov	toggle_time,to_dflt_cnt			; make toggle_time very large so if user
							; cont. to hold rshift key after FilterK/eys turns
							; off, it will not just turn back on.  After the user
							; finally releases the rshift key, then the correct count
							; is restored to toggle_time
	jmp	hot_key_end
turn_filter_on:
	call	fk_turn_on_fb
	jmp	hot_key_end

set_max_default:

	dec	toggle_time
	cmp 	fswitching_video,false
	jne	set_max_default_5
	mov	faccess_sound,true
	mov	fsecond_cue,24				; up arrow for up siren

set_max_default_5:

	cmp	fFK_On_Off_Feedback,false
	je	set_max_default_10

	call	beep_turn_on
	call	no_beep
	call	beep_turn_on
	call	no_beep
	call	beep_turn_on

set_max_default_10:

	mov	on_wait_ticks,max_dflt_wait_cnt
;;	mov	on_delay_ticks,32760			; put on_delay_ticks at maximum
	mov	fUser_SetUp_Option2,true		; set user option 2 true
	mov	fUser_SetUp_Option1,false		;reset flag
	jmp	hot_key_end

warning_cnt_sub:

	cmp 	fswitching_video,false
	jne	warning_cnt_sub_5
	mov	faccess_sound,true
	mov	fsecond_cue,7				; filled circle for high beep

warning_cnt_sub_5:

	call	beep_high
	call	no_beep
	call	beep_high
	call	no_beep
	call	beep_high
	jmp	hot_key_end

no_accept_cnt_sub:

	cmp 	fswitching_video,false
	jne	no_accept_cnt_sub_5
	mov	faccess_sound,true
	mov	fsecond_cue,24

no_accept_cnt_sub_5:

	cmp	fFK_On_Off_Feedback,false
	je	no_accept_cnt_sub_10

	call	beep_turn_on
	call	no_beep
	call	beep_turn_on

no_accept_cnt_sub_10:

	mov	fUser_SetUp_Option1,true		; set user option 1 true
	mov	fUser_SetUp_Option2,false		; set user option 2 false
	mov	on_wait_ticks,0				; in User_SetUp_Option1, the is no acceptance delay
	mov	on_delay_ticks,18			; default User_SetUp_Option1 BounceKeys of 1 second
	mov	on_delay_ticks,32760			; put on_delay_ticks at maximum
hot_key_end:
	jmp	FilterKeys_timer_end

;----------------------------------------------------------------------------
; NOT Hot Key down by itself.
;
start_cnt_over:
	mov	toggle_time,reset_cnt

;----------------------------------------------------------------------------
; check and see if it is time to send a key through, both delayed acceptance
; and repeat.

begin_FilterKeys_timer:
	cmp	fFilterKeysOn,false
	jne	check_time
	jmp	FilterKeys_timer_end			; if not on, quit
check_time:

	mov	ax,tick_count
	or	ax,ax					; are we at 0?
	jz	generate_key				; yes, then time to pass on key -->
	dec	ax					; no, decrement count
	jmp	set_ticks				; save value -->
generate_key:
	cmp	frecovery_timing,true			; is RecoveryKeys On, and a key already passed
	jne	generate_key_15				; if not, cont as before

	mov	frecovery_timing,false			; incase RecoveryKeys is On, we elapsed the timer
	jmp	short FKT_35				; reset counter to next delay (ie on_delay_ticks)

generate_key_15:

	mov	ax,previous_code			; get key to pass
	or	ax,ax					; is a key down?
	jnz	go_ahead
	jmp	FilterKeys_timer_end			; 

go_ahead:


;***********
; We do not expect any registers to be saved upon return from SticKeys
; Added call to Click for whenever SlowKeys is on.
;
;	cmp	_comp_id,1				; IBM PC or PC/XT ?
;	jne	FKT_25					; if so, we will click later in pass_to_computer
;	push	ax					; temp save
;	in	al,kb_data				; read in data from keyboard port
;	cmp	al,0					; was byte a 0??
;	jne	FKT_20					; if not, okay to click if on
;	pop	ax					; restore ax
;
;;;	cmp	fclick_on,true				; is click sound turned on
;;;	jne	FKT_16
;;;	call	click
;;;	jmp	short FKT_18
;;;FKT_16:
;	mov	fsilent_click,true			; flag to allow time for PC /XT
;	call	click
;FKT_18:
;	call	SticKeys				; pass on actual code
;	cmp	fsilent_click,true			; if we return from call to Stickeys, and fsilent_click
;	je	FilterKeys_timer_end			; is true, then al=0 here in Filters or in handicap (pass_to_computer)
;							; meaning no scan code was passed, so we need to jump to the end without
;							; changing the current delay we are in, and the next timer int. will try
;							; once again to pass this same scan code along
;
;	cmp	fclick_on,true				; if we get here, we passed a key, is click sound turned on
;	jne	FKT_19
;	call	click
;FKT_19:
;	jmp	short FKT_35
;
;FKT_20:
;	pop	ax					; restore ax
;***********


FKT_25:

;*	cmp	fclick_on,true				; is click sound turned on
;* 	jne	FKT_30

;; suggestion was made to not have the repeat of modifier keys cause a click, so added short check here to 
;; do this, but not to the PC or PC/XT (ax [al] has the scan code at this point)

;*	cmp	fshift_click,true			; was at least one modifier key passed with a click ?
;*	je	FKT_30					; is so, cont. on., if not, calll click and then set flag true
;*
;*	cmp	current_shift,0
;*	jne	FKT_30
;*	mov	fshift_click,true			; if we clicked once, alway set true, as any non modifier key will clear
;*	cmp	on_wait_ticks,0				; is there an acceptance delay ?
;*	je	FKT_30					; if not, don't click the modifier key at all
;*
;*
;***********
;FKT_27:
;	cmp	_vector,15h				; are we on a computer which supports int 15h
;	je	FKT_30					; if yes, save click for when key is actually pased int kybd int15
; 	call	click					; audible feedback that SlowKeys is on	
;***********
;*
;*
;*FKT_30:	

	mov	fbios_called_timing,true		; tell kybd_int 15h that timer passed a key
							; and do it before we call StickeyKeys, in case 
							; MouseKeys cancels it (i.e. MouseKeys not sent on)

	call	SticKeys				; pass on actual code

FKT_35:
	mov	ax,on_repeat_ticks    		 	; get on_repeat_ticks value
	cmp	repeating?,true				; are in typematic?
	je	set_ticks				; yes -->
	mov	repeating?,true				; no, then say we are repeating

	cmp	fRecovery_On,true			; is RecoveryKEys On ?
	jne	FKT_40					; if not, cont.
	mov	ax,on_delay_ticks_adj			; use value of on_delay_ticks_adj instead
	jmp	short set_ticks

FKT_40:
	mov	ax,on_delay_ticks    		  	; get on_delay_ticks
set_ticks:
	mov	tick_count,ax
FilterKeys_timer_end:
	ret
FilterKeys_timer	endp

;---------------------------------------------------------------------------

; the following routines provide the sound feedback.

fk_turn_off_fb	proc	near

	assume	DS:_TEXT

	cmp	fFK_On_Off_Feedback,false
	je	FilterKeys_TurnOff
	call	beep_turn_off

FilterKeys_TurnOff:
	cmp	fswitching_video,false
	jne	FilterKeys_TurnOff_5
	mov	faccess_sound,true
	mov	fsecond_cue,25				; down arrow for falling siren

FilterKeys_TurnOff_5:

	mov	fFilterKeysOn,false			; turn off
fk_Restart:
	mov	toggle_time,reset_cnt			; reset count down
	mov	previous_code,0				; clear previous code
	mov	prior_code,0				; clear as well
	mov	repeating?,false			; reset flag
	mov	fUser_SetUp_Option1,false		; reset flag
	mov	fUser_SetUp_Option2,false		; reset flag
	ret

fk_turn_off_fb	endp

;----------------------------------------------------------------------------

fk_turn_on_fb	proc	near

	assume DS:_TEXT

	cmp	fFK_On_Off_Feedback,false
	je	FilterKeys_TurnOn
	call	beep_turn_on

FilterKeys_TurnOn:
;;	call	TimeOut_Reset

	cmp	fswitching_video,false
	jne	FilterKeys_TurnOn_5
	mov	faccess_sound,true
	mov	fsecond_cue,24

FilterKeys_TurnOn_5:

	mov	fFilterKeysOn,true			; turn on

	push	ax

	mov	ax,delay_ticks
	mov	on_delay_ticks,ax

	mov	ax,repeat_ticks
	mov	on_repeat_ticks,ax

	mov	ax,recovery_ticks
	mov	on_recovery_ticks,ax

	mov	ax,wait_ticks
	mov	on_wait_ticks,ax

;******** DO NOT ALLOW RecoveryKeys to be on, if Acceptance Delay is NOT zero *****************

	cmp	ax,0					; is wait_ticks zero?
	je	FKTO_15					; if yes, then don't affect fRecovery_On flag, may be On or Off
	mov	fRecovery_On,false  			; if no, then be sure to NOT allow fRecovery_On to be ON

FKTO_15:
	pop	ax

	cmp	fRecovery_On,true			; if RecoveryKeys is On, setup on_delay_ticks_adj
	jne	FKTO_50

	cmp	on_delay_ticks,32760			; is delay_ticks "off" (i.ei no repeats)
	jne	FKTO_18					; if delay_ticks is not off, adjust it for RecoveryTicks
	mov	on_delay_ticks_adj,32760		; if it was off, also make on_delay_ticks_adj off
	jmp	short FKTO_50  				; and exit


FKTO_18:

	push	ax
	push	bx
	mov	ax,on_delay_ticks

;IFDEF	BUG
;	mov	portid,0ddh
;	mov	portout,ah
;	call	HexCharsOut
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG

	mov	bx,on_recovery_ticks

;IFDEF	BUG
;	mov	portid,0deh
;	mov	portout,bh
;	call	HexCharsOut
;	mov	portout,bl
;	call	HexCharsOut
;ENDIF;	BUG
	cmp	ax,bx					; be sure delay ticks is greater than recovery ticks
	jg	FKTO_20
	mov	on_delay_ticks_adj,0			; if not greater, force on_delay_ticks_adj to 0
	jmp	short FKTO_30

FKTO_20:
	sub	ax,bx					; subtract  on_recoveryticks from on_delay_ticks
	mov	on_delay_ticks_adj,ax			; store that value in on_delay_ticks_adj

;IFDEF	BUG
;	mov	portid,0dfh
;	mov	portout,ah
;	call	HexCharsOut
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG

FKTO_30:
	pop	bx
	pop	ax

FKTO_50:

	ret

fk_turn_on_fb	endp
;----------------------------------------------------------------------------
; FilterKeys_dialog 
;
;	Checks a single flag from Dialog box to see if FilterKeys was turned
; on/off.  If it was, this routine makes a call to FilterKeys_TurnOn/Off so the realstates
; can be updated to match the computer.  Upon exit the flag that was set by 
; Dialog box is cleared.(returned to false)


FilterKeys_dialog	proc	

	assume	DS:_TEXT
	cmp	fFilterKeysOn,true			; was FilterKeys turned on
	jne	Fd_25
	call	FilterKeys_TurnOn_5	   		; yes it was a 1, so turn on
	jmp	short Fd_50

Fd_25:
	call	FilterKeys_TurnOff_5			; fFilterKeysOn was false, so turn off
Fd_50:
	mov	fDialog_Filter_off,false		; reset flag to false
	ret

FilterKeys_dialog	endp

;----------------------------------------------------------------------------

filter_begin:

	push	ds					; save the world away
	push	es
	push	di
	push	si
	push	dx
	push	cx
	push	bx
	push	ax

;----------------------------------------------------------------------------
; first thing to do is to check for the right shift key or other modifier key
; (shift, control, and alternate keys) and keep track of the real
; states.  This is needed by the timer routine to determine if the 
; fFilterKeysOn is being manually toggled on and off and by
; the next routine in line, StickeyKeys.

	mov	bx,ax					; save copy in bx
	mov	current_shift,0				; assume not a shift key

	and	al,not break_bit			; get make scan code in al
	mov	cx,shift_tbl_len			; search for a modifier key
	mov	di,offset shift_tbl			; when done, cl will hold modifier
	cld						; count to get modifier flag
	repne	scasw					; ne=not found  e=found

	jne	FK_30					; not a modifier (shift, ctrl, alt) key -->

	mov	al,1
	shl	al,cl					; get modifier key flag

	mov	current_shift,al			; set current modifier to flag

;----------------------------------------------------------------------------
;
; Now set real states
;
	mov	ah,real_states				; get real current state
	test	bl,break_bit				; is it a break of a shift?
	jz	FK_10					; no -->
	not	al					; yes, clear flag
	and	ah,al
	jmp	short FK_20
FK_10:
	or	ah,al					; set flag
FK_20:
	mov	real_states,ah				; save

	cmp	bl,RShift	 	   		; is it a make of the right shift key ?
	jne	FK_32					; if not, jump around hot key setting

;----------------------------------------------------------------------------
;
; Now see if only the turn on hot key is down 
; changed hot key to carriage return key to match T-TAM
;

FK_25:
; not sure if I need this next test any more either 

	test	ah,fNotToggles				; any ctl, alt keys down?
	jnz	FK_30					; yes -->

	mov	hot_key_only?,true			; no, then set hot_key_only to true
	jmp	short FK_100
FK_30:
      	mov	fshift_click,false			; reset fshift_click flag for any non modifier keys
FK_32:

	mov	hot_key_only?,false

;----------------------------------------------------------------------------
; We now start the logic for the Filter features
;
FK_100:
	mov	ax,bx					; restore extended scan
	and	bl,not break_bit			; get make in bl
	cmp	fFilterKeysOn,false			; are we to filter?
	jne	FK_105					; yes, cont on
	jmp	FK_800					; no -->pass around

FK_105:
	test	al,break_bit				; is it a break?
	jz	FK_200					; no, it is a make -->

;----------------------------------------------------------------------------
; BREAK CODE HANDLING
;----------------------------------------------------------------------------
; must let all break keys go through immediately since they are only sent 
; once.  Check to see if break of current down key.  To be true to the
; function of FilterKeys, we should only let the break codes get passed
; on through if a make of the same code has been sent.  However, due to
; n-key roll over and single keys which send multiple makes and breaks, this
; is a complicated (i.e. more lines of code) to check for.

      	mov	fshift_click,false			; reset fshift_click flag for any non modifier keys
	cmp	previous_code,bx			; break of previous make?
	je	FK_110					; yes, cont. on
	jmp	FK_800					; no -->pass around
	
FK_110:
	cmp	fRecovery_On,true			; is RecoveryKeys On ?
	jne	FK_130
	mov	bx,on_recovery_ticks			; if it did time out, load or reeload counter
	mov	tick_count,bx
	mov	repeating?,false			; fake out FilterKeys timer, it will think it's doing acceptance delay
	mov	frecovery_timing,true			; set to true because we are going to pass this key press on 

FK_130:

	mov	previous_code,0				; yes clear previous code
	mov	repeating?,false			; reset flag
	jmp	FK_800					; pass key on -->

;----------------------------------------------------------------------------
; MAKE CODE HANDLING
;----------------------------------------------------------------------------
; Must make exception for fake keys that are only ever sent once since they
; are part of a sequence of keystrokes.  These keys are the left shift key 
; that is preceded by E0 (e02ah or e0aah), or the left ctrl that is preceded 
; by E1 (e11dh or e19dh).

FK_200:
	cmp	ax,0e02ah				; left shift make (keys 75-89)
	je	FK_230	     				; yes, pass on -->
FK_210:

	cmp	ax,0e036h				; right shift make (keys 75-89)
	je	FK_230	 				; yes, pass on -->
FK_220:
	cmp	ax,0e11dh				; key 126 PAUSE ?
	je	FK_230					; yes, pass on -->

;----------------------------------------------------------------------------
; Check for the special sequence caused by the key 126 (Pause).  The keyboard
; sends this sequence straight as shown.  It does not wait to the actual 
; release of the key to send the up codes sequence.  So we need to pass on
; the down stroke right away.  The up strokes will get sent right away since
; they are break keys.
;
; e0 46 e0 c6   or   (e1 1d) 45 (e1 9d) c5

	cmp	ax,0e046h				; is it the pause key?
	je	FK_230					; yes, send on -->
	cmp	previous_code,0e11dh			; previous one a 0e1dh ?
	jne	FK_300					; no, go on -->
	cmp	al,45h					; is current key a 45h?
	jne	FK_300					; yes, then pass on -->

FK_230:
       	jmp	FK_800

;----------------------------------------------------------------------------
; we will always inhibit a code that is identical to previous one since
; the initial key and repeat will always be done via the timer routine since
; this gives better resolution then depending on the keyboard.
;
FK_300:
	cmp	ax,previous_code			; equal to previous code?
							; previous code set to 0 on a break
	jne	FK_300A
	jmp	filter_ret				; bypass all typematic makes of a key

;-----------------------------------------------------------------------------
; Check if RecoveryKeys is On, if it is On, we will not pass a key along (make code)
; if that key is determined to be the same as the previous key (check prior key), and the 
; on_recovery_ticks counter has not elapsed.  If the on_recovery_ticks counter has elapsed,
; we will pass the make code along, and reset the frecovery_timing variable

FK_300A:
	cmp	fRecovery_On,true			; check if RecoveryKeys is On ?
;	jne	FK_300B					; if not, cont here
	jne	FK_306					; if not, cont here
	mov	bx,prior_code				; check make code against pre-previous code
	cmp	ax,bx					; same key after a tremor
;	je	FK_300B					; yes, allow recovery_timing to elapse
	je	FK_306					; yes, allow recovery_timing to elapse

; If not the same as the prior code, elapse frecovery_timing flag

	mov	frecovery_timing,false			; if user targetted a new key, reset this counter

;------------------------------------------------------------------------------
; Now determine if we should send the key on right away, and what value to set
; the tick_count, but first make sure that if fUser_SetUp_Option is set or checked,that we
; keep the settings for each. i.e. Don't allow thses settings to change unless operator
; leaves the User_SetUp_Option mode
;******************
; REMOVE DUE TO REMOVAL FROM DIALOG BOX
;******************
;;
;;
;;FK_300B:
;;	cmp	fUser_SetUp_Option1,true		; if set reset on_wait_ticks and on_delay_ticks
;;	je	FK_302
;;	cmp	fUser_SetUp_Option2,true		; if set reset on_wait_ticks and on_delay_ticks
;;	je	FK_304
;;	jmp	short FK_306	  			; not equal to either User SetUp Option 
;;
;;FK_302:
;;	mov	on_wait_ticks,0				; in User_SetUp_Option1, the is no acceptance delay
;;	mov	on_delay_ticks,32760			; put on_delay_ticks at maximum, i.e. do repeat keys
;;	jmp	short FK_306				; cont. on
;;FK_304:
;;	mov	on_wait_ticks,max_dflt_wait_cnt		; put at maximum
;;	mov	on_delay_ticks,32760			; put on_delay_ticks at maximum, i.e. do repeat keys


FK_306:

	mov	bx,on_wait_ticks			; reset count

FK_310:

; Now test to see if we have an acceptance delay time

	or	bx,bx					; any wait tick value?
	jz	FK_318

; Yes, have Acceptance delay time.  Let timer routine pass the initial make
; as well as the repeats.
; Added call to Click for whenever SlowKeys is on with an acceptance delay.

        cmp	fclick_on,true				; is click sound turned on
	jne	FK_315					; no, jump around
 	call	click					; audible feedback that SlowKeys is on
FK_315:
	mov	tick_count,bx				; yes, just set count
	mov	repeating?,false			; not repeating yet
	mov	previous_code,ax			; no, update previous code to new one
	jmp	short filter_ret    			; let timer send on the key

; No, we do not have an acceptance delay time.  Pass current make right now
; and let timer do the repeats. But also check for RecoveryKeys since we do not
; have any acceptance delay

FK_318:

	cmp	fRecovery_On,true			; check if RecoveryKeys is On ?
	jne	FK_320					; if not, cont here

	cmp	frecovery_timing,true			; if RecoveryKeys is On, has an earlier count timed out ?
	jne	FK_318A					; if yes, start a new count

	mov	bx,on_recovery_ticks			; if it did not time out, reeload counter again
	mov	tick_count,bx
	mov	previous_code,ax			; save as previous code
	mov	prior_code,ax				; save code previous to
	jmp	short filter_ret	

FK_318A:

	mov	bx,on_recovery_ticks			; if it did time out, load or reeload counter
	mov	tick_count,bx
	mov	repeating?,false			; fake out FilterKeys timer, it will think it's doing acceptance delay
	mov	frecovery_timing,true			; set to true because we are going to pass this key press on 

        cmp	fclick_on,true				; is click sound turned on
	jne	FK_319					; no, jump around
	call	click					; click if flag set 
FK_319:

	jmp	short FK_700

FK_320:
	mov	bx,on_delay_ticks			; get on_delay_ticks
	mov	tick_count,bx				; set count
	mov	repeating?,true				; repeating after this count

;----------------------------------------------------------------------------
; pass on the extended scan code in AX, but save as previous code if needed.

FK_700:

	mov	previous_code,ax			; save as previous code
	mov	prior_code,ax				; save code previous to previous code


; We do not expect any registers to be saved upon return from SticKeys

FK_800:
	call	SticKeys				; pass on actual code

filter_ret:

	pop	ax					; restore the world
	pop	bx
	pop	cx
	pop	dx
	pop	si
	pop	di
	pop	es
	pop	ds
	ret

FilterKeys	endp

_TEXT	ends

	end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\gideidef.h ===
/********************/
/*	GIDEIDEF.H		*/
/********************/


/*	FIRST ESCAPE LEVEL CODES 0-255 */


/*	0 reserved for NULL character	*/


/* Device Command Codes */

/* reserved						1 */
#define KBDPRESSCODE			2
#define KBDCOMBINECODE		3
#define KBDHOLDCODE			4
#define KBDLOCKCODE			5
#define KBDRELCODE			6
#define KBDEXPANSIONCODE	10

#define MOULOCKCODE			11
#define MOURELCODE			12
#define MOUCLICKCODE			13
#define MOUDOUBLECLICKCODE	14
#define MOUMOVECODE			15
#define MOUGOTOCODE			16
#define MOURESETCODE			17
#define MOUEXPANSIONCODE	20

/* NOTE: 27 		reserved for escape */
/*       32 - 127	reserved for alias	*/

#define COMMCODE			150
#define BAUDRATECODE		151
#define GENCODE			160
#define DEBUGCODE			220


/*	GIDEI Directive Codes  - valid in any Level */

#define LOWESTGIDEICODE	236

/*	236 - 242 reserved for future expansion  */

#define DOUBLECODE		243
#define LONGCODE			244
#define INTEGERCODE		245
#define BYTECODE			246
#define BLKTRANSCODE		247
#define DELIMITERCODE	248
#define ENDCODE			249
#define BEGINCODE			250
#define CLEARCODE			251
#define DEFAULTCODE		252
#define UNKNOWNCODE		253
#define EXTENDEDCODE		254
#define TERMCODE			255
#define NOCODE				0


/********************************************/
/*	Second Escape Level Codes  0 - 236		*/

/* GEN  Codes */

#define gen1				 	1
#define gen2			 		2
#define gen3					3
#define COMPUTERID			4
#define SINGLEUSER			5
#define gen6					6
#define gen7					7



/* Keyboard Model Codes */

#define IBMENHANCEDCODE 	1
#define IBMATCODE		 		2
#define IBMPCCODE				3

#define KBDINDICATORCODE	6
#define KBDVERSIONCODE		7
#define KBDMODELCODE			8
#define KBDDESCRIPTIONCODE	9
#define KBDUNKNOWNCODE		10


#define NOBUTTON				0
#define DEFAULTBUTTONCODE	1
#define LEFTBUTTONCODE		1
#define RIGHTBUTTONCODE		2


/* BAUDRATE CODES  */

#define BAUD300CODE			1
#define BAUD600CODE			2
#define BAUD1200CODE			3
#define BAUD2400CODE			4
#define BAUD4800CODE			5
#define BAUD9600CODE			6
#define BAUD19200CODE 		7


/* GIDEI KEY CODES */
/*************************************************************************/
/*************************************************************************/
/* Internal Key number table  */

#define	no_key			0
#define	NOKEY				0
#define	lquote_key		1
#define	one_key			2
#define	two_key			3
#define	three_key		4
#define	four_key			5
#define	five_key			6
#define	six_key			7
#define	seven_key		8
#define	eight_key		9
#define	nine_key			10
#define	zero_key			11
#define	hyphen_key		12
#define	equal_key		13
#define	backspace_key	15

#define	tab_key			16
#define	q_key				17
#define	w_key				18
#define	e_key				19
#define	r_key				20
#define	t_key				21
#define	y_key				22
#define	u_key				23
#define	i_key				24
#define	o_key				25
#define	p_key				26
#define	lbracket_key	27
#define	rbracket_key	28
#define	bslash_key		29

#define	caps_key			30
#define	a_key				31
#define	s_key				32
#define	d_key				33
#define	f_key				34
#define	g_key				35
#define	h_key				36
#define	j_key				37
#define	k_key				38
#define	l_key				39
#define	semicolon_key	40
#define	rquote_key		41
#define	return_key		43

#define	lshift_key		44
#define	z_key				46
#define	x_key				47
#define	c_key				48
#define	v_key				49
#define	b_key				50
#define	n_key				51
#define	m_key				52
#define	comma_key		53
#define	period_key		54
#define	fslash_key		55
#define	rshift_key		57

#define	lcontrol_key	58
#define	lcommand_key	59
#define	lalt_key			60
#define	space_key		61
#define	ralt_key			62
#define	rcommand_key	63
#define	rcontrol_key	64

#define	insert_key		75
#define	delete_key		76
#define	left_key			79
#define	home_key			80
#define	end_key			81
#define	up_key			83
#define	down_key			84
#define	pageup_key		85
#define	pagedown_key	86
#define	right_key		89

#define	numlock_key		90
#define	kp7_key			91
#define	kp4_key			92
#define	kp1_key			93
#define	kpfslash_key	95
#define	kp8_key			96
#define	kp5_key			97
#define	kp2_key			98
#define	kp0_key			99
#define	kpstar_key		100
#define	kp9_key			101
#define	kp6_key			102
#define	kp3_key			103
#define	kpperiod_key	104
#define	kpminus_key		105
#define	kpplus_key		106
#define	kpequal_key		107
#define	kpenter_key		108

#define	escape_key		110

#define	f1_key			112
#define	f2_key			113
#define	f3_key			114
#define	f4_key			115

#define	f5_key			116
#define	f6_key			117
#define	f7_key			118
#define	f8_key			119

#define	f9_key			120
#define	f10_key			121
#define	f11_key			122
#define	f12_key			123

#define	print_key		124
#define	scroll_key		125
#define	pause_key		126
#define	reset_key		127

#define	shift_key		lshift_key
#define	control_key		lcontrol_key
#define	alt_key			lalt_key





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\frontend.c ===
#include <bios.h>
#include <graph.h>
#include <io.h>
#include <stdio.h>
#include <stdlib.h>
#include <dos.h>
#include <string.h>
#include <memory.h>
#include <ctype.h>

#include "defines.h"
#include "globals.h"
#include "access.h"
#include "frontend.h"
#include "menudata.h"
#include "messages.h"
#include "dialogs.h"


void OutputTitleBar(void)
{
   _settextwindow(1, 1, 1, 80);
   _settextcolor(titleBarFG);
   _setbkcolor(titleBarBG);
   _clearscreen(_GWINDOW);
   charBufferLength = sprintf(charBuffer, "AccessDOS 1.1");
   _settextposition(1, 40-charBufferLength/2);
   _outtext(charBuffer);
}	/* end OutputTitleBar() */


void ClearDesktop(void)
{
	int i;

   _settextwindow(1, 1, 25, 80);
   _setbkcolor(desktopBG);
   _settextcolor(desktopFG);
   for (i=3; i<25; i++)
   {
      _settextposition(i, 1);
      _outtext(backgroundString);
   }
}	/* end ClearDesktop() */


void OutputHintBar(char *hintText, int justifyFlag, int helpMessageFlag)
{
   _settextwindow(25, 1, 25, 80);
   _settextcolor(hintBarFG);
   _setbkcolor(hintBarBG);
   _clearscreen(_GWINDOW);
	charBufferLength = sprintf(charBuffer, "%s", hintText);
   switch (justifyFlag)
   {
      case JUSTIFY_LEFT    :  _settextposition(1, 2); break;
      case JUSTIFY_CENTER  :  _settextposition(1, 40-charBufferLength/2); break;
      case JUSTIFY_RIGHT   :  _settextposition(1, 79-charBufferLength); break;
   }
	_outtext(charBuffer);

	if (helpMessageFlag)
	{
		charBufferLength = sprintf(charBuffer, "<F1 = Help>");
		_settextposition(1, 80-charBufferLength);
		_outtext(charBuffer);
	}
}	/* end OutputHintBar() */


void RedrawScreen(int helpMessageFlag)
{
	OutputTitleBar();
	ClearDesktop();
	OutputHintBar("", JUSTIFY_LEFT, helpMessageFlag);
}	/* end RedrawScreen() */


void ManageMenu(void)
{
	int leftMargin, numberOfMenuLists, currentMenu, lastMenu;
   int currentMenuLine, numberOfMenuLines;
	int redrawScreen = TRUE, helpMessageFlag = TRUE;
	MENU_LIST_RECORD *currentMenuList;
	unsigned key;
	int ascii, scanCode;

   quitFlag = FALSE;

   numberOfMenuLists = 0;
	while (menuList[numberOfMenuLists++].lastRecord == FALSE);

	currentMenu = 1;
   lastMenu = -1;
	do
	{
		if (redrawScreen)
		{
			RedrawScreen(helpMessageFlag);
			redrawScreen = FALSE;
			lastMenu = -1;
		}

		if (lastMenu != currentMenu)
		{
         int i;

			currentMenuList = menuList[currentMenu].menuList;

			numberOfMenuLines = 0;
			while (currentMenuList[numberOfMenuLines++].lastRecord == FALSE);

         for (i=0; i<numberOfMenuLines; i++)
            if (currentMenuList[i].hot) currentMenuLine = i;

         leftMargin = PrintMenuBar(currentMenu);
		}

      lastMenu = currentMenu;
		if (currentMenu >= 0 && currentMenu < numberOfMenuLists)
			PrintMenuList(currentMenu, leftMargin);
		
			/* Get a key and process it into ascii and scan codes */
		key = _bios_keybrd(keybrdRead);
		ascii = key & 0x00ff;
		scanCode = ascii ? 0 : key >> 8;

		if (ascii)
		{
         int legalKey = FALSE;

			if (ascii == ENTER)
			{
				currentMenuLine = 0;
            while (currentMenuList[currentMenuLine].hot == FALSE) currentMenuLine++;

            (currentMenuList[currentMenuLine].dialogProcPtr)();
            redrawScreen = TRUE;
            legalKey = TRUE;
			}
			else
			{
            int i;

				ascii = toupper(ascii);

					/* Is Key a menu line hot key? */
				for (i=0; i<numberOfMenuLines; i++)
				{
					if (ascii == currentMenuList[i].hotKey)
					{
						currentMenuList[currentMenuLine].hot = FALSE;
						currentMenuList[currentMenuLine=i].hot = TRUE;
                  legalKey = TRUE;

            		(currentMenuList[currentMenuLine].dialogProcPtr)();
            		redrawScreen = TRUE;
						break;
					}
				}
			}
         if (legalKey == FALSE)
			{
				putchar('\07');
				ClearKeyboardBuffer();
			}
		}
		else switch (scanCode)
		{
			case LEFT		:	if (--currentMenu < 0) currentMenu = numberOfMenuLists-1;
									break;

			case RIGHT		:	if (++currentMenu == numberOfMenuLists) currentMenu = 0;
									break;

			case UP			:	currentMenuLine = 0;
									while (currentMenuList[currentMenuLine].hot == FALSE) currentMenuLine++;
									currentMenuList[currentMenuLine].hot = FALSE;
									if (currentMenuLine == 0) currentMenuLine = numberOfMenuLines;
									while (currentMenuList[--currentMenuLine].selectable != SELECTABLE_YES);
									currentMenuList[currentMenuLine].hot = TRUE;
									break;

			case DOWN		:	currentMenuLine = 0;
									while (currentMenuList[currentMenuLine].hot == FALSE) currentMenuLine++;
									currentMenuList[currentMenuLine].hot = FALSE;
									if (currentMenuLine == numberOfMenuLines-1) currentMenuLine = -1;
									while (currentMenuList[++currentMenuLine].selectable != SELECTABLE_YES);
									currentMenuList[currentMenuLine].hot = TRUE;
									break;

			case F1_KEY		:	(currentMenuList[currentMenuLine].helpProcPtr)();
									redrawScreen = TRUE;
									break;

         default        :  {
                              int i, legalKey = FALSE;

                              for (i=0; i<numberOfMenuLists; i++)
                              {
                                 if (scanCode == menuList[i].hotKey)
                                 {
                                    currentMenu = i;
                                    legalKey = TRUE;
                                 }
                              }
                              if (legalKey == FALSE)
										{
											putchar('\07');
											ClearKeyboardBuffer();
										}
                           }
									break;
		}
	} while (quitFlag == FALSE);
}	/* end ManageMenu() */


int PrintMenuBar(int currentMenu)
{
	int i, previousMenuTitleHot = FALSE;
	int startColumn = 0, leftMargin = 0;

	ClearDesktop();

	_settextwindow(2, 1, 2, 80);
	_setbkcolor(menuBarBG);
	_settextcolor(menuBarFG);
	_clearscreen(_GWINDOW);
	_settextwindow(1, 1, 25, 80);

	_settextposition(2, 1);
	i=0;
	do
	{
		if (i == currentMenu)
		{
			leftMargin = startColumn+1;
         _settextcolor(menuBoxFG);
         _setbkcolor(menuBarBG);
         startColumn += sprintf(charBuffer, "");
         _outtext(charBuffer);

			_setbkcolor(menuBarHotBG);
			_settextcolor(menuBarHotFG);
			startColumn += sprintf(charBuffer, "%s%s%s", menuList[i].leftText,
										  menuList[i].midText, menuList[i].rightText);
			_outtext(charBuffer);
			previousMenuTitleHot = TRUE;
		}
		else
		{
			if (previousMenuTitleHot)
			{
				_setbkcolor(menuBarBG);
				_settextcolor(menuBoxFG);
				startColumn += sprintf(charBuffer, "");
				_outtext(charBuffer);
				previousMenuTitleHot = FALSE;
			}
			else
			{
				_setbkcolor(menuBarBG);
				_settextcolor(menuBarFG);
				startColumn += sprintf(charBuffer, " ");
				_outtext(charBuffer);
			}

				/* output the non-highlighted text of this menu title */
			_setbkcolor(menuBarBG);
			_settextcolor(menuBarFG);
			startColumn += sprintf(charBuffer, "%s%", menuList[i].leftText);
			_outtext(charBuffer);

				/* output the Highlight letter of this menu title */
			_setbkcolor(menuBarHotKeyBG);
			_settextcolor(menuBarHotKeyFG);
			startColumn += sprintf(charBuffer, "%s", menuList[i].midText);
			_outtext(charBuffer);

				/* output the rest of the menu title */
			_setbkcolor(menuBarBG);
			_settextcolor(menuBarFG);
			startColumn += sprintf(charBuffer, "%s", menuList[i].rightText);
			_outtext(charBuffer);
		}
	}
	while (menuList[i++].lastRecord == FALSE);

		/* output the vertical bar if the last menu title was hot */
	if (previousMenuTitleHot)
	{
		_setbkcolor(menuBarBG);
		_settextcolor(menuBoxFG);
		startColumn += sprintf(charBuffer, "");
		_outtext(charBuffer);
	}
	else
	{
		_setbkcolor(menuBarBG);
		_settextcolor(menuBarFG);
		startColumn += sprintf(charBuffer, " ");
		_outtext(charBuffer);
	}

	return(leftMargin);
}	/* end PrintMenuBar() */


void PrintMenuList(int currentMenu, int leftMargin)
{
	int line=3, menuTitleLength, menuLineLength, numberOfMenuLines, currentMenuLine, helpMessageFlag = TRUE;
   char *hintTextPtr = '\0';
	MENU_LIST_RECORD *currentMenuList = menuList[currentMenu].menuList;

	menuTitleLength = strlen(menuList[currentMenu].leftText) +
							strlen(menuList[currentMenu].midText) +
							strlen(menuList[currentMenu].rightText);
	menuLineLength  = strlen(currentMenuList[0].leftText) +
							strlen(currentMenuList[0].midText) +
							strlen(currentMenuList[0].rightText);
	numberOfMenuLines = 0;
	while (currentMenuList[numberOfMenuLines++].lastRecord == FALSE);

		/* output top line menu box */
	_settextwindow(1, 1, 25, 80);
	_setbkcolor(menuBoxBG);
	_settextcolor(menuBoxFG);
	_settextposition(line,leftMargin);
	charBufferLength = sprintf(charBuffer, "%s%s%s",
										currentMenuList[numberOfMenuLines].leftText,
										currentMenuList[numberOfMenuLines].midText,
										currentMenuList[numberOfMenuLines].rightText);
	_outtext(charBuffer);
	_settextposition(line++, leftMargin+menuTitleLength+1);
	charBufferLength = sprintf(charBuffer, "");
	_outtext(charBuffer);

		/* output each line of the menu */
	for (currentMenuLine = 0; currentMenuLine < numberOfMenuLines; currentMenuLine++)
	{
			/* output left edge of menu line */
		_settextposition(line++, leftMargin);
		_setbkcolor(menuBoxBG);
		_settextcolor(menuBoxFG);
		if (currentMenuList[currentMenuLine].selectable == SELECTABLE_NEVER)
			charBufferLength = sprintf(charBuffer, "");
		else
			charBufferLength = sprintf(charBuffer, "");
		_outtext(charBuffer);

			/* output body of menu line */
		if (currentMenuList[currentMenuLine].hot)
		{
         hintTextPtr = currentMenuList[currentMenuLine].hintText;
			_setbkcolor(menuLineHotBG);
			_settextcolor(menuLineHotFG);
			charBufferLength = sprintf(charBuffer, "%s%s%s", 
												currentMenuList[currentMenuLine].leftText,
												currentMenuList[currentMenuLine].midText,
												currentMenuList[currentMenuLine].rightText);
			_outtext(charBuffer);
		}
		else switch (currentMenuList[currentMenuLine].selectable)
		{
			case SELECTABLE_YES		:	_setbkcolor(menuLineBG);
												_settextcolor(menuLineFG);
												charBufferLength = sprintf(charBuffer, "%s", currentMenuList[currentMenuLine].leftText);
												_outtext(charBuffer);
												_setbkcolor(menuLineHotKeyBG);
												_settextcolor(menuLineHotKeyFG);
												charBufferLength = sprintf(charBuffer, "%s", currentMenuList[currentMenuLine].midText);
												_outtext(charBuffer);
												_setbkcolor(menuLineBG);
												_settextcolor(menuLineFG);
												charBufferLength = sprintf(charBuffer, "%s", currentMenuList[currentMenuLine].rightText);
												_outtext(charBuffer);
												break;

			case SELECTABLE_NO		:	_setbkcolor(menuLineDeadBG);
												_settextcolor(menuLineDeadFG);
												charBufferLength = sprintf(charBuffer, "%s%s%s",
																					currentMenuList[currentMenuLine].leftText,
																					currentMenuList[currentMenuLine].midText,
																					currentMenuList[currentMenuLine].rightText);
												_outtext(charBuffer);
												break;

			case SELECTABLE_NEVER	:	_setbkcolor(menuBoxBG);
												_settextcolor(menuBoxFG);
												charBufferLength = sprintf(charBuffer, "%s%s%s", 
																					currentMenuList[numberOfMenuLines].leftText,
																					currentMenuList[numberOfMenuLines].midText,
																					currentMenuList[numberOfMenuLines].rightText);
												_outtext(charBuffer);
												break;
		}

			/* output right edge of menu line */
		_setbkcolor(menuBoxBG);
		_settextcolor(menuBoxFG);
		if (currentMenuList[currentMenuLine].selectable == SELECTABLE_NEVER)
			charBufferLength = sprintf(charBuffer, "");
		else
			charBufferLength = sprintf(charBuffer, "");
		_outtext(charBuffer);
	}	/* for each line of current menu list */

		/* output the bottom line of the menu box */
	_setbkcolor(menuBoxBG);
	_settextcolor(menuBoxFG);
	_settextposition(line++, leftMargin);
	charBufferLength = sprintf(charBuffer, "%s%s%s",
										currentMenuList[numberOfMenuLines].leftText,
										currentMenuList[numberOfMenuLines].midText,
										currentMenuList[numberOfMenuLines].rightText);
	_outtext(charBuffer);

      /* Print the Hint Bar */
	OutputHintBar(hintTextPtr, JUSTIFY_LEFT, helpMessageFlag);
}	/* end PrintMenuList() */

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\equip.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center 				*
;									*
;	EQUIP.ASM							*
;									*
;************************************************************************

TITLE	Equip
	page 80,180

;        BUG     equ     true


	EXTRN	fslow_baud_mouse:byte

	EXTRN	_singleUserSetup:byte
	EXTRN   _comp_id:byte
	EXTRN   _combase:word
	EXTRN   _vector:byte
	EXTRN   _finject_keys:byte
	EXTRN   fcomp_dialog:byte
	EXTRN	fcomp_dialog_id:byte
	EXTRN	fcomputer_not_found:byte
	EXTRN   btn_1:byte
	EXTRN   btn_2:byte
	EXTRN   Current_Button:byte
	EXTRN   fmouse_driver:byte
	EXTRN   _fmouse_id:byte
	EXTRN   ExtendedSeg:word
	EXTRN   fvideo_type:byte
	EXTRN	comp_flag:byte
	EXTRN	fmousetrapping:byte			; in handicap.asm

	EXTRN	_end:abs				; variable buily by assembler
	EXTRN	_dataBlock:byte				; in param.asm
	EXTRN	_dataBlockSize:word			; in param.asm
	EXTRN	_serialKeysOn:byte
	EXTRN	_skWindowCompatible:byte

	EXTRN   fAccessAlreadyLoaded:byte
	EXTRN	fserial_keys_loaded:byte
	EXTRN	fDialog_Filter_off:byte
	EXTRN	fDialog_Stickeys_off:byte
	EXTRN	fDialog_Mouse_off:byte
	EXTRN   fDialog_Toggle_off:byte
	EXTRN	fDialog_TimeOut_off:byte
	EXTRN	fDialog_Action:byte

	EXTRN	last_address:word			; in TimeOut.asm

	EXTRN	Enable:NEAR				; in Handicap.asm

	EXTRN	_serialKeysEnableFar:FAR		; in SerialKeys
	EXTRN	_serialKeysDisableFar:FAR		

	EXTRN cmdLineLen:byte
	EXTRN intNumber:byte
	EXTRN functionNumber:byte
	EXTRN tsrLoaded:word
	
	EXTRN parameters:dword
	EXTRN paramsOffset:word
	EXTRN paramsSegment:word

	EXTRN originalInt:dword
	EXTRN orgIntOffset:word
	EXTRN orgIntSegment:word

	EXTRN accessIntHandler:near

	EXTRN programStamp:byte
	EXTRN pgm_stamp_len:word
	EXTRN pgm_stamp_ofs:word

DGROUP	GROUP _TEXT, CONST, _DATA, c_common, _BSS

_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
c_common segment word public 'BSS'
c_common ends
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS



_BSS	segment
	

include KEYBOARD.INC

	PUBLIC runFrontEnd
	PUBLIC	throwAwayAddr



throwAwayAddr		label	word			; everything below is expendable

display 	MACRO	string
;        	mov	dx,OFFSET string
		lea	dx,string
	        mov	ah,9
        	int	21h
	        ENDM

displaydebug	MACRO	string
		local	displaydebug10

		cmp	_debug,false
		je	displaydebug10
;        	mov	dx,OFFSET string
		lea	dx,string
	        mov	ah,9
        	int	21h
displaydebug10:
	        ENDM

error0Msg       db      'Error opening configuration file',  13, 10, '$'
error0aMsg      db      'Error reading configuration file',  13, 10, '$'
error0bMsg      db      'Error closing configuration file',  13, 10, '$'
error1Msg       db      'Error releasing memory block',      13, 10, '$'
error2Msg       db      'Error spawning child process',      13, 10, '$'

abortAccessMsg  db      'Aborting AccessDOS installation.',			 	   13, 10, '$'
exitMsg         db      'Exiting AccessDOS menu and AccessDOS is still loaded.',	   13, 10, '$'
removeHelperMsg db      'Removing AccessDOS and subroutines from memory.',     		   13, 10, '$'
residentMsg     db      'AccessDOS is now loaded and resident on your computer.',      	   13, 10, '$'
userRespMsg	db	'Press any key to continue. ',   				   13, 10, '$'

debugMsg1	db	'AccessDOS is searching for a mouse, please wait. ',               13, 10, '$'
debugMsg2	db	'AccessDOS is determining your computer type, please wait. ',      13, 10, '$'
debugMsg3	db	'AccessDOS has finished hardware checks.',       		   13, 10, '$'



;;mesg100		db	'SerialKeys installed, but turned off', 13, 10, '$'
;;mesg101		db	'SerialKeys installed, and turned on', 13, 10, '$'


_debug		dw	false				; debug flag set to true when /d on command line

saveStackPtr    dw      ?
saveStackSeg	dw	?


param_block	label   word
        	dw      0				; 0 = use parent environmet segment
cmd_ofs	        dw      ?				; offset of command line sent to child
cmd_seg		dw	?				; segment of command line sent to child
        	dw      5Ch				; FCB1 offset
fcb1_seg        dw      ?				; FCB1 segment
        	dw      6Ch				; FCB2 offset
fcb2_seg        dw      ?				; FCB2 segment


cmd_buf	        db      ?				; command line buffer (also length byte)
cmd_txt	        db      80 dup (?)		
                db      '$',0				; make sure end of string defined

		even
transferBuf 	db	127 dup (?)			; temp storage when reading configuration data
handle		dw	0				; handle to configuration file

programName     db 15 dup ('ADOS.OVL',0)
prgmNameLen	dw 5
defaultPgmName	db 'ADOS.OVL',0
defaultPgmNameLen equ 5


alreadyLoaded   db      false
inhibitmessage	db	false

tempIntNumber	db	0
firstUnusedVect db	0
segOfFirstInst	dw	0

serkeyRoutine	label	dword
serkeyRoutOfs	dw	0
serkeyRoutSeg	dw	0


status			dw	0

INSTALLACCESS          	equ     1			; any modifications made here must also be made in datablk.c
ABORTACCESS            	equ     2			; any modifications made here must also be made in datablk.c


cmdLineSwitch		dw	0

DEBUGON			equ	01h
AUTOLOAD		equ	02h
USECFGFILE		equ	04h
SERIALKEYSPARAM		equ	80h


skCmdLineSwitch		dw	0

SKSINGLEUSER		equ	01h
SKDISABLE		equ	02h
SKENABLE 		equ	04h
SKWINDOWS		equ	08h



		even
stack		db	64 dup ('stackspc')
topOfStack	dw	0

;--------------------------------------------------------------------------------

	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT


runFrontEnd	proc	near

	lea	sp,topOfStack
	call	checkIfLoaded			; are we already installed once
	jnc	runFrontEnd10			; jump if we ARE INSTALLED
	call	loadUs				; install our int vector
runFrontEnd10:
	call	getPath				; get path to ados.xxx
	call	cmdLineTransfer			; copy the command line to our buffer
	call	cmdLineRead			; read the command line switches

; added one variables to inhibit erro messages from 'ados /? ' inquires @ the command line
; this still doesn't protect us if user enter command line switch (good or bad) w/o the '/'

	mov	cl,cmd_buf
	cmp	cl,0				; did we have any command line parameters ?
	je	runFrontEnd20			; if not, carry on
	mov	inhibitmessage,true		; if yes, flag it, so if we later ABORT, do not append 
						; abort message
	
runFrontEnd20:
	test	cmdLineSwitch,DEBUGON		; was the debug switch found
	jz	runFrontEnd30			; jump if not
	mov	_debug,true			; set debug variable

runFrontEnd30:

	; if this is the first instance, we have to determine the equipment setup
	; (this done here because we wanted to get the debug status from the command line)

	cmp	alreadyLoaded,true
	je	runFrontEnd50			; jump if this is the second instance running now

	displaydebug	debugMsg1

	call	_FindMouse			; determine mouse device installed
	displaydebug	debugMsg2

	call	_FindComputer			; determine computer running on
	displaydebug	debugMsg3

	; wait for keystroke if in debug mode
	cmp	_debug,true			; wait for keystroke if in debug mode
	jne	runFrontEnd50			; jump around if not in debug

	displaydebug	userRespMsg
	mov	ah,0Ch				; 21h function C - Clear Keyboard buffer and execute function in al
	mov	al,08h				; 21h function 8 - Console input without echo
	int	21h

runFrontEnd50:
	test	cmdLineSwitch,AUTOLOAD		; if /a on command line, do overlay
	jz	runFrontEnd100
	call	runOverlay
	jmp	runFrontEnd1000

runFrontEnd100:
	test	cmdLineSwitch,USECFGFILE	; was /x on command line
	jz	runFrontEnd200			; jump in NO

	; Force the user to run the overlay if already loaded
	; because some equipment dependent settings in the .cfg file
	; may not apply now and cause problems

	cmp     alreadyLoaded, true
	je	runFrontEnd110			; jump if this is the second instance running now

	call	runWithCFGfile			; try to load the configuration file
	jc	runFrontEnd110			; jump if there was a problem
	mov	status,INSTALLACCESS		; configuration file loaded, now install
	jmp	runFrontEnd1000
runFrontEnd110:
	call	runOverlay			; there was a problem with the cfg file so let overlay handle it
	jmp	runFrontEnd1000

runFrontEnd200:
	test	cmdLineSwitch,SERIALKEYSPARAM	; were there any serial keys switches
	jz	runFrontEnd500			; jump if NO
	cmp	alreadyLoaded,true		; if already loaded, we don't have to run the overlay or the cfg
	jne	runFrontEnd500			; jump if not loaded yet
	mov	status,INSTALLACCESS		; deal with switches later, for now skip overlay and jump to install
	jmp	runFrontEnd1000

runFrontEnd500:
	call	runOverlay			; if no switches (or not loaded and sk switches) do the overlay (sounds like a dance)
	jmp	runFrontEnd1000

;---
runFrontEnd1000:
	; what is the status of ADOS now? Do we install it, quit, modifiy paramaters, er what!

	cmp	status,ABORTACCESS		; should we cancel/abort
	jne	runFrontEnd1020			; jump if NO
	call	cancelAccess			; do cleanup and quit
	jmp	runFrontEndDone

runFrontEnd1020:
	cmp	status,INSTALLACCESS		; should we install it
	jne	runFrontEnd1040			; jump if NO

	; OK let's install/run ADOS
	; If already loaded, install means update remaining parameters and exit,
	; otherwise install means update remaining parameters and tsr

	cmp	alreadyLoaded,true              ; are we already installed once
	je	runFrontEnd1025			; jump if YES we are already installed

	call	updateAndTSR			; initialize our routines and Terminate and Stay resident

	; we do not come back from here unless there is an error
	jmp	runFrontEndDone

runFrontEnd1025:
	call	updateAndExit			; just update the remaining parameters and quit
	jmp	runFrontEndDone

runFrontEnd1040:

runFrontEndDone:
	mov	ax,4c00h
	int	21h
	int	20h
runFrontEnd	endp


;--------------------------------------------------------------
;checkIfLoaded - returns carry flag: carry = NOT LOADED
;
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC checkIfLoaded
checkIfLoaded	proc	near

	; initialize variable for CHECK-IF-LOADED routines below
	mov	firstUnusedVect,0		; signal no vector found yet
	sub	bx,bx				; BX will hold int number 
	mov	bl,START_INT_NUMBER-1
	mov	si,offset programStamp		; si initialized for string compare
	cld
	jmp	short checkIfLoaded20

	assume  es:nothing			; keep here because of looping below
checkIfLoaded10:
	cmp	firstUnusedVect,0		; have we found the first unused vector already?
	jne	checkIfLoaded20			; jump if yes
	mov	firstUnusedVect,bl		; if not, we have now
checkIfLoaded20:
	inc	bx				; get next vector to check
	cmp	bx,END_INT_NUMBER		; are we at end of INTs to check?
	ja	checkIfLoaded60			; if yes, we are not loaded
	mov	di,bx				; get offset 
	shl	di,1				; x 4 to get vector table addr
	shl	di,1				; x 4 to get vector table addr
	sub     ax, ax				; get segment
	mov     es, ax
	assume  es:nothing
	mov     ax, WORD PTR es:[di]		; is there a vector (other than to 0) here
	or      ax, WORD PTR es:[di+2]
	jz	checkIfLoaded10			; jump if we know it is not loaded
	les	di,es:[di]			; get vector routine
	add	di,pgm_stamp_ofs 		; add offset to our ID message
	; es:di from vector table;    ds:si from our string
	mov	cx,pgm_stamp_len
	repe	cmpsb
	jcxz	checkIfLoaded50			; jump if loaded
	jmp	checkIfLoaded20			; we are NOT found

;------------
checkIfLoaded50:
	; yes we are loaded.  Save interrupt number
	mov	segOfFirstInst,es
	mov     alreadyLoaded, true		; signal already loaded
	mov	tempIntNumber, bl
	clc
	jmp	checkIfLoadedDone

;------------
checkIfLoaded60:
	; we have not been installed previously, so save interrupt
	; of the first unused vector

	mov	segOfFirstInst,cs
	mov     alreadyLoaded, false		; signal not already loaded
	mov	al,firstUnusedVect
	or	al,al				; did we find a vector that was not used already
	jnz	checkIfLoaded80			; jump if we had

	; All the vectors apparently are used.  We'll just have
	; to pick one for us to use
	mov	al,DEFAULT_INTERRUPT
checkIfLoaded80:
	mov	tempIntNumber,al		; save it
	stc

;------------
checkIfLoadedDone:
	push	cs
	push    cs
	pop	ds
	pop     es
	assume  es:DGROUP
	ret
checkIfLoaded	endp



;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC loadUs
loadUs	proc near
	; initialize our ISR variables
	mov     functionNumber, ACCESS_FUNCTION ; function number to respond to
	mov     tsrLoaded, TSR_HERE             ; value to return if TSR is loaded
	mov     paramsOffset, offset _dataBlock ; address of the shared data block
	mov	paramsSegment, cs		; segment of shared data block
	mov	segOfFirstInst,cs
	mov	al,tempIntNumber
	mov     intNumber, al		        ; interrupt to tag onto
	mov	ah, 35h			        ; get the original interrupt handler
	int	21h			        ; old vector in ES:BX
	assume	es:nothing
	mov	orgIntOffset, bx
	mov	orgIntSegment, es

	mov	ah, 25h                         ; set new interrupt handler
	mov	al, intNumber
	mov	dx, offset accessIntHandler
	int	21h
	push	cs
	pop	es
	assume	es:DGROUP
	ret
loadUs	endp

;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC getPath
getPath	proc near
	; get path of .com file for overlay file
	; only works for DOS 3 and above

	mov	ah,30h				; function 30h: Get DOS Version Number
	int	21h				; major version # in al, minor version # in ah
	cmp	al,3				; if 3 or higher then path can be found
	jge	getPath50
	jmp	getPathDone			; skip looking for path
getPath50:
	mov	es,cs:2Ch			; es now points to environment segment
	assume  es:nothing
	sub	di,di				; di points to offset within environment
	sub	ax,ax				; indicate searching for null
	cld
	mov	cx,8000h			; set up count
getPath100:
	; search for end of environment es:di ( two null chars together )
	repne	scasb
	jcxz	getPathDone			; if count ended then use default name
	scasb					; look for second null character
	jne	getPath100			; jump if not a null character

	; complete path of file running found two bytes after
	inc	di				; bypass two bytes of junk(?)
	inc	di
	mov	si,di				; set si to beginning of path string for later
	mov	cx,-1				; get length
	repne	scasb				; es:di
	jcxz	getPathDone			; if count ended then use default name
	not	cx				; length to . 
	cmp	cx,80h				; make sure it is not too long
	jb	getPath200			; jump if ok
	jmp	getPathDone			; use default if too long
getPath200:
	mov	prgmNameLen,cx			; save length
	lea	di,programName			; store path here
	push	ds				; setup segments so source = ds:si  and destin = es:di
	push	es
	pop	ds
	assume  ds:nothing
	pop	es
	rep	movsb				; transfer string to our buffer; add extension later

	; now set length from beginning to period starting extension
	mov	al,'.'				; set char to look for
	mov	cx,prgmNameLen			; get stored length
	std					; search backward
	dec	di				; point to null
	dec	di				; point to last char
	repne	scasb				; continue until found
	jcxz	getPath300			; if cx = 0 then period not found, use default name
	mov	prgmNameLen,cx			; save length
	jmp	getPathDone

getPath300:
	; restore default program name
	push	cs
	pop	ds
	mov	cx,defaultPgmNameLen
	mov	prgmNameLen,cx
	add	cx,4
	cld
	lea	di,programName
	lea	si,defaultPgmName
	rep	movsb
getPathDone:
	cld
	push	cs
	push	cs
	pop	es				; restore segments
	pop	ds
	assume	ds:DGROUP
	assume  es:DGROUP
	ret
getPath	endp


;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC cmdLineTransfer
cmdLineTransfer proc near
	; Copy the command line for use by us and the child process
	sub     cx, cx
	mov     cl, cmdLineLen
	inc     cx				; once for length byte
	inc     cx				; again for '0D' at end of command tail
	cld
	mov     si, offset cmdLineLen
;	mov     di, offset cmd_buf
	lea	di,cmd_buf
	rep     movsb
	mov	al,0h				; just to make sure there is an end of string
	stosb
	ret
cmdLineTransfer endp

;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC cmdLineRead
cmdLineRead proc near
	mov	cmdLineSwitch,0
	mov	skCmdLineSwitch,0
	mov	cl, cmd_buf			; get length
;	mov	di, offset cmd_txt		; es:di
	lea	di,cmd_txt
	mov	al,'/'				; look for switch
cmdLineRead10:
	repne	scasb
	jcxz	cmdLineReadjmp			; finished with command line checking
	mov	bl,[di]				; get character after /

	cmp	bl,'s'				; is it serial keys flag
	jne	cmdLineRead20			; if no, jump
	call	cmdLineReadSK			; look at next characters to verify serial keys
	jmp	cmdLineRead10

cmdLineReadjmp:
	jmp	cmdLineReadDone			; finished with command line checking

cmdLineRead20:
	cmp	bl,'d'				; is it debug flag
	jne	cmdLineRead40			; if no, jump
	or	cmdLineSwitch,DEBUGON		; signal /d detected
	jmp	cmdLineRead10
cmdLineRead40:
	cmp	bl,'a'				; is auto load indicated
	jne	cmdLineRead60			; if no, jump
	or	cmdLineSwitch,AUTOLOAD		; signal /a detected
	jmp	cmdLineRead10
cmdLineRead60:
	cmp	bl,'A'				; is auto load indicated
	jne	cmdLineRead80			; if no, jump
	or	cmdLineSwitch,AUTOLOAD		; signal /a detected
	jmp	cmdLineRead10
cmdLineRead80:
	cmp	bl,'x'				; is it no-load overlay switch
	jne	cmdLineRead100			; if no, jump
	or	cmdLineSwitch,USECFGFILE	; signal /x detected
	jmp	cmdLineRead10			
cmdLineRead100:
	cmp	bl,'X'				; is it no-load overlay switch
	jne	cmdLineRead105			; if no, jump
	or	cmdLineSwitch,USECFGFILE	; signal /x detected
	jmp	cmdLineRead10

cmdLineRead105:
	cmp	bl,'i'				; is it mouse switch
	jne	cmdLineRead110			; if no, jump
	cmp	alreadyLoaded,true		; if already loaded, ignore this switch
	je	cmdLineRead120
	mov	fmousetrapping,true		; if not loaded, set flag and cont.
	jmp	cmdLineRead10
cmdLineRead110:
	cmp	bl,'I'				; is it mouse switch
	jne	cmdLineRead120			; if no, jump
	cmp	alreadyLoaded,true		; if already loaded, ignore this switch
	je	cmdLineRead120
	mov	fmousetrapping,true		; if not loaded, set flag and cont.
	jmp	cmdLineRead10

cmdLineRead120:
	jmp	cmdLineRead10

cmdLineReadDone:
	ret

cmdLineRead	endp

;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC cmdLineReadSK
cmdLineReadSK	proc near

	; see if serial keys switch
	mov	bl,[di+1]
	cmp	bl,'k'				; is it /sk
	je	cmdLineReadSK10			; jump if yes
	jmp	cmdLineReadSKdone		; it isn't so quit on this one
cmdLineReadSK10:
	; find out what switch
	mov	bl,[di+2]			; get next char
	cmp	bl,'s'				; is it single user flag
	jne	cmdLineReadSK20			; jump if NO
	or	skCmdLineSwitch,SKSINGLEUSER	; signal /sks found
	jmp	cmdLineReadSK100
cmdLineReadSK20:
	cmp	bl,'d'				; is it serial keys disable cmd
	jne	cmdLineReadSK30			; jump if NO
	or	skCmdLineSwitch,SKDISABLE	; signal /skd found
	jmp	cmdLineReadSK100
cmdLineReadSK30:
	cmp	bl,'e'				; is it serial keys enable cmd
	jne	cmdLineReadSK40			; jump if NO
	or	skCmdLineSwitch,SKENABLE	; signal /ske found
	jmp	cmdLineReadSK100
cmdLineReadSK40:
	cmp	bl,'w'				; is it serial keys windows compatible command
	jne	cmdLineReadSKdone		; jump if NO
	or	skCmdLineSwitch,SKWINDOWS	; signal /skw found
cmdLineReadSK100:
	or	cmdLineSwitch,SERIALKEYSPARAM	; signal serial keys command line switch found
cmdLineReadSKdone:
	ret

cmdLineReadSK endp


		
;----------------------------------------------------------------------
; runWithCFGfile returns carry flag: carry set if error
;
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT


runWithCFGfile:
	; user indicated that we should load with previous configuration file and go
	; without loading the overlay.

	; add filename extension to path
;	mov	di,offset programName
	lea	di,programName
	add	di,prgmNameLen
	mov	al,'C'				; add CFG extension
	stosb
	mov	al,'F'
	stosb
	mov	al,'G'
	stosb
	mov	al,0h
	stosb

	; try to open the configuration file
;	mov	dx,offset programName
	lea	dx,programName
	mov	ah,3Dh				; int 21h function 3Dh - Open a file
	mov	al, 00000000b			; inherited, compatibility mode, read access
	int	21h
	mov	handle,ax			; save handle to file
	jnc	runWithCFGfile100		; jump if no error

	; error of some type detected.  Close file and run ovl
	mov	ah,3Eh				; int 21h function 3Eh - Close a File handle
	mov	bx,handle
	int	21h
	display error0Msg
	stc
	jmp	runWithCFGfileDone		; run overlay, probably no cfg file

runWithCFGfile100:
	; read file into buffer
	mov	cx,_dataBlockSize		; get size of buffer
;	mov	dx,offset transferBuf
	lea	dx,transferBuf
	mov	ah,3Fh				; int 21h function 3Fh - Read from a file or device
	mov	bx,handle			; get handle to file
	int	21h
	cmp	ax,_dataBlockSize		; see how many bytes read
	je	runWithCFGfile200		; jump if ok

	; something is wrong with the config file. Close it and run ovl
	mov	ah,3Eh				; int 21h function 3Eh - Close a File handle
	mov	bx,handle
	int	21h
	display	error0aMsg			; 
	stc
	jmp	runWithCFGfileDone		; run overlay, probably no cfg file

runWithCFGfile200:
	; Bytes have been read into buffer.  Close file

	mov	ah,3Eh				; int 21h function 3Eh - Close a File handle
	mov	bx,handle
	int	21h
	jnc	runWithCFGfile300		; jump if no error
	display error0bMsg			; display error and continue

runWithCFGfile300:
	; now store data in shared parameter block
	; set up so ds:si = source (ds = this instance)
	;           es:di = destin (es = first instance)

	lea	si,transferBuf
	mov	di,offset _dataBlock
	mov	cx,_dataBlockSize
	cld
	cli					; don't want to upset ADOS if interrupts come along
	rep	movsb
	mov	fDialog_Filter_off,true
	mov	fDialog_Stickeys_off,true
	mov	fDialog_Mouse_off,true
	mov	fDialog_Toggle_off,true
	mov	fDialog_TimeOut_off,true
	mov	fDialog_Action,true
	sti
	clc
	jmp	runWithCFGfileDone

runWithCFGfileDone:
	ret


;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC runOverlay
runOverlay	proc near

	call	freeMemory
	jnc	runOverlay20
	display error1Msg
	mov	status,ABORTACCESS
	jmp	runOverlayDone

runOverlay20:
	call	spawnChild
	jnc	runOverlay40
	display error2Msg
	mov	status,ABORTACCESS
	jmp	runOverlayDone

runOverlay40:
	mov     ah, 4dh				; get return code
	int     21h
	cmp     al, ABORTACCESS			; Does user want to abort ACCESS?
	jne	runOverlay60
	mov	status,ABORTACCESS
	jmp	runOverlayDone
runOverlay60:
	cmp     al, INSTALLACCESS		; load access?
	jne	runOverlay80
	mov	status,INSTALLACCESS
	jmp	runOverlayDone
runOverlay80:
	mov	status,ABORTACCESS
	jmp	runOverlayDone

runOverlayDone:
	ret
runOverlay endp

;----------------------------------------------------------------------
; freeMemory returns carry set if error

	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC freeMemory
freeMemory	proc near
	mov	bx, offset _end		        ; free memory for child process
	mov	cl, 4
	shr	bx, cl
	inc     bx                              ; add 1 paragraph for rounding
	mov     ah, 4Ah
	int     21h
	; returns code in carry bit
	ret
freeMemory endp
        

;----------------------------------------------------------------------
; spawnChild returns carry set if error

	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC spawnChild
spawnChild	proc near

	; add filename extension to path
;	mov	di,offset programName
	lea	di,programName
	add	di,prgmNameLen
	mov	al,'O'				; add OVL extension
	stosb
	mov	al,'V'
	stosb
	mov	al,'L'
	stosb
	mov	al,0h
	stosb

	mov	ax, cs                          ; set up parameter block for child process
	mov	cmd_seg, ax
	mov	fcb1_seg, ax
	mov	fcb2_seg, ax
	lea	ax,cmd_buf
	mov	cmd_ofs,ax

	lea	dx,programName			; ds:dx points to program name
	lea	bx,param_block			; es:bx points to parameter block
	mov     saveStackPtr,sp		        ; save the stack pointer
	mov	saveStackSeg,ss
	mov	ax, 4b00h                       ; execute child process
	int	21h
	cli
	assume  es:nothing
	assume  ds:nothing
	assume	ss:nothing

	mov	ss, cs:saveStackSeg		; seg reg done first so no interrupt
	mov	sp, cs:saveStackPtr		;   until after the next instruction
	mov	cx, cs			        ; restore segment regs and stack
	mov	ds, cx
	mov	es, cx
	assume  es:DGROUP
	assume  ds:DGROUP
	assume	ss:DGROUP
	sti

	; returns code in carry bit
	ret

spawnChild endp


;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC updateAndTSR
updateAndTSR	proc near
	;this is the first instance so we already have segment register
	mov     fAccessAlreadyLoaded, true      ; set fAccessAlreadyLoaded (in Shared Parameter Block) to true

	cmp	fcomputer_not_found, false	; if computer was not found, we must call Find_Computer again
	je	updateAndTSR20
	call	_FindComputer

updateAndTSR20:
	call	Enable			        ; initialize Handicap and SerialKeys features
	display cs:residentMsg

	cmp	_serialKeysOn,true  		; is SerialKeys code installed ?
	je	updateAndTSR100	    		; yes, do TSR at _end
				    		; if not, do TSR at
	mov	dx,offset last_address		; last_address which is in TimeOut
				      		; last file of keyboard/mouse linked
	mov	fserial_keys_loaded,false	; set to false if SerialKeys not initially loaded
	jmp	short updateAndTSR200
	
updateAndTSR100:
	mov	fserial_keys_loaded,true	; set to true if SerialKeys is initially loaded

	test	cmdLineSwitch,SERIALKEYSPARAM
	jz	updateAndTSR150
	test	skCmdLineSwitch,SKSINGLEUSER
	jz	updateAndTSR150
	mov	_singleUserSetup,true
	jmp	updateAndTSR155

updateAndTSR150:
	mov	_singleUserSetup,false
updateAndTSR155:
;	mov	dx, offset _end
;	mov	dx, offset throwAwayAddr
	lea	dx,throwAwayAddr
	
updateAndTSR200:

	mov	cl,4
	shr	dx,cl
	inc	dx				; dx # of paragraphs
	inc	dx
	mov	ax,3100H
	int	21H				;TSR

	; don't come back unless error of some sort?

	ret

updateAndTSR endp

;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC updateAndExit
updateAndExit	proc near
	display cs:exitMsg

	mov	es,segOfFirstInst		; get segment of dataBlock, 1st instance
	assume	es:nothing
	cmp	es:fserial_keys_loaded,true	; was serial keys loaded
	je	updateAndExit50			; jmp if YES
	jmp	updateAndExitDone		; nothing to update so just exit

updateAndExit50:

; if we get here, fserial_keys_loaded must be true, this means AccesDOS must have been loaded, and SerialKeys
; was installed.  Therefore, whenever we exit again, we must check if we need to disable SerialKeys or re-enable it
; in case the user choose to turn SerialKeys On/Off from the menu !!!

; We also have to check for command line switches and change globals accordingly

	; assume no switches so change settins back to default
	mov	es:_singleUserSetup,false
	mov	es:_skWindowCompatible,false

	test	cmdLineSwitch,SERIALKEYSPARAM	; any serial keys stuff
	jz	updateAndExit150		; jump if NO serial keys switches

	test	skCmdLineSwitch,SKSINGLEUSER	; single user request?
	jz	updateAndExit100		; jump if NOT single user
	mov	es:_singleUserSetup,true	; set single user flag

updateAndExit100:
	; for the rest of the flags more than one on the command line doesn't make sense
	; so we will accept only one in the following priority- enable, disable, windows compatible

	test	skCmdLineSwitch,SKENABLE	; enable serial keys with current settings
	jz	updateAndExit105		; jump if NO
	mov	es:_serialKeysOn,true		; set global flag ON
	jmp	updateAndExit150
updateAndExit105:
	test	skCmdLineSwitch,SKDISABLE	; disable serial keys 
	jz	updateAndExit110		; jump if NO
	mov	es:_serialKeysOn,false		; set global flag OFF
	jmp	updateAndExit150
updateAndExit110:
	test	skCmdLineSwitch,SKWINDOWS	; disable serial keys for windows batch file
	jz	updateAndExit150		; jump if NO
	mov	es:_serialKeysOn,false		; turn serial keys OFF
	mov	es:_skWindowCompatible,true	; set WINDOWS flag ON so DOS SHELL will run serial keys

updateAndExit150:

	mov	ax,es
	mov	cs:serkeyRoutSeg,ax		; set up segment of enable/disable routines
	cmp	es:_serialKeysOn,true		; should serial keys be ON
	jne	updateAndExit225		; jump if NO

	mov	cs:serkeyRoutOfs,offset _serialKeysEnableFar
	call	dword ptr cs:serkeyRoutine	; make sure serial keys is ON
	jmp	updateAndExitDone

updateAndExit225:
	mov	serkeyRoutOfs,offset _serialKeysDisableFar
	call	dword ptr cs:serkeyRoutine	; make sure serial keys is OFF
	jmp	updateAndExitDone

updateAndExitDone:
	push	cs
	push	cs
	pop	es
	pop	ds
	ret
updateAndExit endp

;----------------------------------------------------------------------
	assume	cs:DGROUP
	assume  es:_TEXT
	assume  ds:_TEXT
	assume	ss:_TEXT

	PUBLIC cancelAccess
cancelAccess	proc near
	; if already Loaded, then cancel simply means quit,
	; otherwise cancel means remove our routine
	cmp	alreadyLoaded,false
	je	cancelAccess10			; jump if not already loaded
	cmp	inhibitmessage,true
	je	cancelAccess5
	display cs:exitMsg
cancelAccess5:
	mov	inhibitmessage,false		; reset
	jmp	cancelAccessDone
cancelAccess10:
	cmp	inhibitmessage,true
	je	cancelAccess15
	display cs:removeHelperMsg
cancelAccess15:
	mov	inhibitmessage,false		; reset
	mov	ah, 25h                         ; Set interrupt Vector
	mov     al, tempIntNumber
	mov     dx, cs:orgIntOffset
	mov	bx, cs:orgIntSegment            ; remove our TSR and replace original
	push    ds
	mov     ds, bx
	assume	ds:nothing
	int	21h
	pop     ds
	assume ds:DGROUP
cancelAccessDone:
	ret
	;exit
cancelAccess endp


;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; Equipment check starts here
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------


	assume cs:DGROUP
	assume ds:nothing
        assume es:nothing
	assume ss:nothing


;;mesg00		DB	 13, 10, 13, 10, "$"
mesg0		DB	"Mouse driver not found", 13, 10, "$"
mesg1		DB	"Mouse not found", 13, 10, "$"
mesg2		DB	"Mouse found and reset", 13, 10, "$"
mesg3		DB	"A bus mouse was found", 13, 10, "$"
mesg4		DB	"A serial mouse was found", 13, 10, "$"
mesg5		DB	"An InPort mouse was found", 13, 10, "$"
mesg6		DB	"A PS/2 mouse was found", 13, 10, "$"
mesg7		DB	"A HP mouse was found", 13, 10, "$"
mesg8		DB	"Mouse type found was not recognized", 13, 10, "$"
;;mesg9		DB	"Com Port 2 Int. enabled, serial mouse is here", 13, 10, "$"
;;mesg10		DB	"Com Port 1 Int. enabled, serial mouse is here", 13, 10, "$"
mesg11		DB	"Mouse type found is not currently supported", 13, 10, "$"
mesg14		DB	"Computer ID is an IBM PS/2 Model L40SX, 55SX, 65SX, 70, 80, 90 or 95 ", 13, 10, "$"
mesg15		DB	"Computer ID is an IBM PS/1 or PS/2 Model 25/30-80286, 50, 50Z, or 60", 13, 10, "$"
mesg15A		DB	"Computer ID is an IBM AT or equivalent compatible", 13, 10, "$"
mesg15B		DB	"Computer ID is an IBM New AT/XT or equivalent 286/386/... compatible", 13, 10, "$"
mesg16		DB	"Computer ID is an IBM PS/2 Model 25/30-8086", 13, 10, "$"
mesg17		DB	"Computer ID is an IBM Original AT with 84 key keyboard", 13, 10, "$"
mesg17A		DB	"Computer ID is an IBM Original AT with 101 key keyboard", 13, 10, "$"
mesg18		DB	"Computer ID is an IBM PC Convertible and is not supported", 13, 10, "$"
mesg19		DB	"Computer ID is an IBM PC Junior and is not supported", 13, 10, "$"
mesg20		DB	"Computer ID is an IBM New PC/XT", 13, 10, "$"
mesg21		DB	"Computer ID is an IBM PC or an Original IBM PC/XT", 13, 10, "$"
mesg30		DB	"The serial mouse was found to be attached to COMM port 2", 13, 10, "$"
mesg31		DB	"The serial mouse was found to be attached to COMM port 1", 13, 10, "$"
mesg32		DB	"Computer type found to support Inject Keys routine", 13, 10, "$"
mesg33		DB	"Extended BIOS data area not found, PS/2 style MouseKeys not supported, try Serial Mouse", 13, 10, "$"
mesg47		DB	"Your computer supports int 15h calls", 13, 10, "$"
mesg48		DB	"Your computer supports the Extended BIOS data area", 13, 10, "$"
mesg49		DB	"A CGA monitor was detected", 13, 10, "$"
mesg50		DB	"A EGA monitor was detected", 13, 10, "$"
mesg51		DB	"A VGA monitor was detected", 13, 10, "$"
mesg52		DB	"A Monochrome monitor was detected", 13, 10, "$"
mesg53		DB	"A MCGA monitor was detected", 13, 10, "$"

mesg55		db	"Your serial mouse is runnning at 300 BAUD", 13, 10, "$"

mesg22		DB	"Computer was not identifiable and will be treated as a PC/XT/AT with an 84 key keyboard.", 13, 10, "$"
mesg22A		DB	"Please restart AccessDOS menu, type ados,  to change this selection if your ", 13, 10, "$"
mesg22B		DB	"computer is NOT a PC/XT/AT with an 84 key keyboard.", 13, 10, "$"

mesg70		DB	"AccessDOS detected DOS keyb.com to be running.", 13, 10, "$"

;j1		DB	"step1", 13, 10, "$"
;j2		DB	"step2", 13, 10, "$"
;j3		DB	"step3", 13, 10, "$"
;j4		DB	"step4", 13, 10, "$"

bios_table	label	byte

db	"01/10/84"		; OldAT	
db	"06/10/85"		; AT239	
db	"11/15/85"		; AT339	
db	"04/21/86"		; XT286	


NOMOUSE		equ 0
BUSMOUSE	equ 1
SERIALMOUSE	equ 2
INPORTMOUSE	equ 3
PS2MOUSE	equ 4
HPMOUSE		equ 5



print	MACRO	string
;	mov	dx,OFFSET string
	lea	dx,string
	mov	ah,9
	int	21h
	ENDM

;----------------------------------------------------------------------------
; Find_Mouse
; 
; This routine determines if a valid mouse driver is loaded, and what kind of hardware
; mouse is attached to the computer.  It was intended to be called prior to loading
; AccessDos, and therefore if a mouse was found and identified, MouseKeys would be 
; allowed to work.  By blocking it out into seperate code, I can now call it any time, 
; and therefore, the mouse driver could be loaded after AccessDos, and we could still
; use MouseKeys.
;
; Determine presence of MOUSE driver (from Microsoft's mouse prog. ref.)
; check first for a valid mouse interrupt

	PUBLIC _FindMouse
_FindMouse	proc	near
	
        push    si                                      ; save registers
        push    di
        push    ax
        push    bx
        push    cx
        push    dx

        push    ds
        push    es

        mov     ax, cs					; set up data segment
        mov     ds, ax
	assume	ds:DGROUP


	mov	ax,3533h				; get int. 33h vector
	int	21h

	assume	es:nothing
	mov	ax,es
	or	ax,bx
	jz	no_mouse_driver
	cmp	byte ptr es:[bx],207			; iret?
	jne	mouse_reset

no_mouse_driver:
	cmp	_debug, false
	je	debug_0
        print   mesg0
debug_0:
	mov	fmouse_driver,false
	mov	_fmouse_id,false				; if mouse not found, keep fmouse_id=0
	jmp	mouse_driver_end

mouse_reset:
  	xor	ax,ax
	int	33h					; check to see if mouse found
	or	ax,ax					; if mouse not found, ax will = 0
	jnz	mouse_found

	cmp	_debug, false
	je	debug_1
        print   mesg1
debug_1:

	mov	fmouse_driver,false
	jmp	mouse_driver_end

mouse_found:

	cmp	_debug, false
	je	debug_2
        print   mesg2
debug_2:

; determine which type of mouse was found

	mov	ax,36					; get version, mouse type and IRQ #
	int	33h					; call int, mouse type is returned in "Ch" register
	cmp	ch,BUSMOUSE				; was it a bus mouse
	jne	mou_drv_5

	cmp	_debug, false
	je	debug_3
        print   mesg3
        print   mesg11
debug_3:

	jmp	mouse_driver_end

mou_drv_5:
	cmp	ch,SERIALMOUSE
	je	mou_drv_5B
	jmp	mou_drv_10

mou_drv_5B:

	cmp	_debug, false
	je	debug_4
        print   mesg4
debug_4:

	mov	_fmouse_id,SERIALMOUSE
	mov	fmouse_driver,true
	mov	btn_1,20h				; define mouse btn_1
	mov	btn_2,10h				; define mouse btn_2
	mov	Current_Button,20h			; default to left button

; find out which int. we are using so we can identify which COMM port the mouse is attached to ???
; check which int. number was returned so we can load the correct COMM port address for the serial mouse

	cmp	cl,3					; if cl=3, then the mouse was found on COMM 2 or 4
	jne	mou_drv_5A
	mov	_combase,02f8h				; set for COM 2

	cmp	_debug, false
	je	debug_5
        print   mesg30
debug_5:

	jmp	short mou_drv_6

mou_drv_5A:
	mov	_combase,03f8h				; set for COM 1

	cmp	_debug, false
	je	debug_6
        print   mesg31
debug_6:

mou_drv_6:

; One more check to look for a slow (300 baud) serial mouse

	cli						; prevent interrupts while changing registers in serial port

	mov	dx,_combase
	add	dx,3
	in	al,dx					; get line control register
	mov	ah,al					; save status in ah for later restore
	or	al,080h					; prepare to set bit 7 high
	out	dx,al					; write to line control register so we can read lsb/msb of divisor latch

	mov	dx,_combase	
	in	al,dx					; get LSB
	mov	bl,al					; save in bl
	inc	dx
	in	al,dx					; get MSB
	mov	bh,al					; save in bh
	mov	al,ah					; get saved status of line control register

	mov	dx,_combase
	add	dx,3
	out	dx,al					; restore line control register

	sti						; re-enable interrupts

; Now check divisor in bh,bl and see if 300 Baud (384d or 180h), 1200 Baud (96d or 60h) or 2400 Baud (48d or 30h)
; Really only concerned with 300 Baud, so we will look for bh=01h,bl=80h for 300 Baud and set a flag if we find it
	
	cmp	bh,01h					; is this 300 baud ?
	jne	mou_drv_7
	cmp	bl,80h					; ""
	jne	mou_drv_7

	mov	fslow_baud_mouse,true			; flag that we found a slow 300 buad rate mouse
	cmp	_debug,false
	je	mou_drv_7
	print	mesg55					; print out message that we found a slow mouse

mou_drv_7:

	jmp	mouse_driver_end
;-----------------------------------------------------------------------------

mou_drv_10:
	cmp	ch,INPORTMOUSE
	jne	mou_drv_15

	cmp	_debug, false
	je	debug_7
        print   mesg5
        print   mesg11
debug_7:

	jmp	mouse_driver_end

mou_drv_15:
	cmp	ch,PS2MOUSE
	jne	mou_drv_20

	cmp	_debug, false
	je	debug_8
        print   mesg6
debug_8:

	mov	_fmouse_id,PS2MOUSE
	mov	fmouse_driver,true

;initialize or get mouse driver location for use later when MouseKeys is called

	sub 	ax,ax					; zero ax
	mov	ah,0c1h					; preload ah with "c1"
	int 	15h			   		; call int15 to get segment of mouse driver
	jc	mou_drv_18				; if call returns and carry flag set, erro occurred, flag it and exit
	mov	ax,es					; load mouse driver segment address into variable extendseg
	mov 	ExtendedSeg,ax		       	
	mov	btn_1,1					; define mouse btn_1
	mov	btn_2,2					; define mouse btn_2
	mov	Current_Button,01h			; default to left button
	jmp	mouse_driver_end

mou_drv_18:

	cmp	_debug, false
	je	debug_9
        print   mesg33
debug_9:

	jmp	mou_drv_26

mou_drv_20:
	cmp	ch,HPMOUSE
	jne	mou_drv_25

	cmp	_debug, false
	je	debug_10
        print   mesg7
        print   mesg11
debug_10:

	jmp	mouse_driver_end

mou_drv_25:

	cmp	_debug, false
	je	debug_11
        print   mesg8
debug_11:

mou_drv_26:
	mov	fmouse_driver,false
	mov	_fmouse_id,false				; if mouse found but not recognized, keep fmouse_id=0

mouse_driver_end:
        pop     es                                      ; restore registers
        pop     ds

        pop     dx
        pop     cx
        pop     bx
        pop     ax
        pop     di
        pop     si
	ret
_FindMouse	endp





;----------------------------------------------------------------------------
; Find_Computer
;
; Determine computer type.  For a complete computer ID list, see Keyboard.Inc file
; This routine was designed to call the ROM to determine what kind of computer
; that AccessDos was being installed on.  This is necessary to set up various flags
; that are required through the routines.
;
; With the use of int15, ah=0C0h, we can poll the hardware and check the computer ID, submodel,
; etc. just as easily, so we start out this way.  If it is determined that the computer
; does not support int 15h, then the calls to the ROMBIOS are made directly.
;
;--------------------------------------------------
; Need to add the ability to set neither/either/ or both computer flags for various other routine 
; which follow the comp_id needs
;--------------------------------------------------

	PUBLIC _FindComputer
_FindComputer	proc near

;-----------------------------------------------------------------------------
; Find out if computer supports int 15h calls.  Upon return , if the Carry flag is set, 
; (i.e. CF=1), then it definitely does not support int 15h calls.  If the Carry Flag is clear
; (i.e. CF=0), then we must query deeper into a data block to determine if int 15h is supported.
; This is also a traditional call for computer ID bytes.......

	assume cs:DGROUP
	assume ds:nothing
        assume es:nothing
	assume ss:nothing

	
        push    si                                      ; save registers
        push    di
        push    ax
        push    bx
        push    cx
        push    dx

        push    ds
        push    es

        mov     ax, cs					; set up data segment
        mov     ds, ax
	assume	ds:DGROUP

	mov	ah,0c0h					; load Ah register with C0h
	int	15h					; try an int 15
	assume	es:nothing
	cmp	ah,0					; if ah = 0, then we can check further
	je	FC_3					; if zero, we can check for other flags
							; if NOT zero, then Int 15 NOT supported, set vector and jump ahead
FC_2:

; last resort, check if DOS 4.0+/5.0.. is running with keyb.com, as it doesn't change ROM table which int 15h, with 
; C0h would test, just replaces int 9h, with an int 9/int15h equivalent, and we could use the int 15h intercept
; if we can detect keyb.com running.  We can check for this by using int 2Fh, with "ax"= AD80h.  IF "ax" comes back unaltered,
; then keyb.com is not loaded, if "ax" comes back as ffffh, then keyb.com is loaded, and we should use int 15h intercept...

	mov	ax,0AD80h				; request for kryb.com info ??
	int	2Fh					; interrrupt 
	cmp	ax,0ffffh				; is keyb.com loaded
	jne	FC_2A					; if yes, use int. 15h intercept
	cmp	_debug,false
	je	FC_4
	print	mesg70					; inform us that DOS keyb.com is running
	jmp	short FC_4

FC_2A:
	mov	_vector,09h				; kybd must use int. vector 09
	jmp	FC_100					; no need to check data area and PS/2 computer, 

FC_3:
	mov	ah,es:[bx+5]				; get descriptor byte that will tell us if int15h supported
	test	ah,10h					; mask off bit 4
	jz	FC_2					; if zero, bit 4 not set and int 15h intercept not supported, go back to int 9h
FC_4:
	mov	_vector,15h				; kybd can use int. vector 15


	cmp	_debug, false
	je	debug_12
        print   mesg47
	mov	ah,es:[bx+5]				; get descriptor byte again since print wiped out Ah register
	test	ah,04h					; mask off bit 2
	jz	FC_10
        print   mesg48
debug_12:


FC_10:
; Is the operator overriding the computer type ?

	cmp	fcomp_dialog,true			; has the computer type been over ridden by user from dialog box ??
	jne	FC_20					; if not use int 15h to cont
	jmp	FC_200					; if yes, cont. here

FC_20:
;------------------------------------------------------------------------------------------------------------------------------------------
; IBM PS/1 and PS/2 determination done here
;------------------------------------------------------------------------------------------------------------------------------------------
	xor	ax,ax					; zero ax register
	mov	al,es:[bx+2]				; get model byte

	cmp	al,0f8h					; DO WE HAVE A MODEL 55sx,65sx,70,80,90,95,L40sx ???
	jne	FC_23
;;        jmp     FC_175                                ; debug code to force computer not found on model 55, 70, 80

	mov	_comp_id,8				; 
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

	cmp	_debug, false
	je	debug_13
        print   mesg14
debug_13:

	mov	_finject_keys,true			; flag to tell us the computer supports key injection at keyboard hardware buffer

	cmp	_debug, false
	je	debug_14
        print   mesg32
debug_14:

	jmp	FC_end

FC_23:
	cmp	al,0fch					; DO WE HAVE A MODEL PS/1, 25/286, 30/286, 50, 60 or IBM New XT/AT ???
	je	FC_24
	jmp	FC_30

FC_24:

; if we have a PS/1 or PS/2 Model 25/30-286, 50, 60, then we can inject.  If we have either the  New XT/286
; or New AT 339, we CANNOT inject at the hardware but may use int15h.  We need to look at the sub model byte
; to determine this.

	mov	al,es:[bx+3]				; get submmodel byte

	cmp	al,0Bh					; was it a PS/1 ?
	je	FC_25

	cmp	al,04h					; was it a PS/2 Model 50,50z ?
	je	FC_25

	cmp	al,05h					; was it a PS/2 Model 60 ?
	je	FC_25

	cmp	al,09h					; was it a PS/2 Model 30/286 or 25/286 ?
	jne	FC_27

FC_25:

	cmp	_debug, false
	je	debug_15
        print   mesg32
debug_15:

	mov	_comp_id,7				; PS1, 25/30-386,50,60,50Z,
	mov	_finject_keys,true			; flag to tell us the computer supports key injection at keyboard hardware buffer
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

	cmp	_debug, false
	je	debug_16
        print   mesg15
debug_16:

	jmp	FC_end

FC_27:
; turns out that only IBM's will allow the write/read ot the 8042 trick, therefore, I will check if we 
; have an IBM Old AT, New AT (2 models) or a New XT, if not I will distinguis with another _comp_id value of 5Bh
; Also turns out that CLONES compy the FC,submodel,and revision such that I cannot distinguish between them.  THe only other method I 
; know of, is to look at the actual BIOS dates, saved as strings above 90-7 characters)
;
;	OldAT,AT239,AT339,XT286

	mov	ax,ROMBIOS				; Load segment location into
	mov	es,ax					; ES register also

	xor	ax,ax
	xor	di,di
	xor	dx,dx
	xor	si,si

string_5:
	xor	bx,bx
	mov	cx,8
string_6:


	mov	al,es:computer_bios_date[bx]
;	mov	dl,offset bios_table[si]
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	mov	dl,bios_table[si]

	cmp	al,dl
	jne	string_10
	dec	cx
	cmp	cx,0
	je	FC_27A
	inc	bl
	inc	si
	jmp	string_6

string_10:

	inc	di
	cmp	di,4
	je	string_20
	xor	si,si
	mov	si,di
	mov	cx,3
	shl	si,cl
	jmp	string_5

string_20:


	mov	_comp_id,5Bh				; we have a CLONE !!!stick with reading 8042 status method
	jmp	short FC_28

FC_27A:

	mov	_comp_id,5Ah				; we have an New XT/AT, Clone, or Old AT running DOS 4+/5 w/keyb.com
FC_28:

;Need to check if we have 84 or 101 style kybd before we allow next flag to be set
; since the AT-239 (i.e I think this is the 6/10/85 BIOS date) supportes int 15h but may use an 84
; key keyboard. Most clones of 286 or higher will probably be using 101 key keyboard, but this simple check
; should tell us

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jnz	FC_29					; if not ZERO, bit is set and we have 101 kybd

	cmp	_debug, false
	je	debug_17
        print   mesg15A
debug_17:

	jmp	FC_end

FC_29:
	mov	comp_flag,true			 	; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

	cmp	_debug, false
	je	debug_18
        print   mesg15B
debug_18:

	jmp	FC_end

FC_30:

	cmp	al,0fah					; DO WE HAVE A MODEL 25/86 or 30/86 ???
	jne	FC_40

FC_32:	
	mov	_comp_id,6				; 
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3


	cmp	_debug, false
	je	debug_19
        print   mesg16
debug_19:

	jmp	FC_end

FC_40:

	cmp	al,0fbh					; DO WE HAVE A New IBM PC/XT ???
	jne	FC_50
	mov	_comp_id,2				; 

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_45					; if ZERO, bit is clear and we do not have 101 kybd
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3


	cmp	_debug, false
	je	debug_20
        print   mesg20
debug_20:


FC_45:
	jmp	FC_end

FC_50:

;******************************************************************************************************************************************
; If we get here, we have exhausted all IBM combinations of int15h computers that can do the key injection either 
; first by the hardware or second by the writing/reading from the 8042.  Note above, the only way the Old AT (1/10/84)
; can do int15h is with DOS 4+/5 and keyb.com running.  Also Note, that the only reason the OldAT gets caught above
; is that it has the same default ID byte, "FC", as a new AT.  Unfortunately, any other computer running
; will not be ID'ed in ROM, but may have been decidedly made an int 15h computer via keyb.com.  There-
; fore, I will need to go direct to the hardware ID byte and check further for these int 15h computers.
;
; Any IBM computers found beyond this point supporting int15h, are doing so
; because they are running DOS 4+/5 w/keyb.com loaded.  Since we already caught the Old AT, all that is left that we will support
; is the original PC or PC/XT (do not support PCjr or PCconv.).  I treat the PC and PC/XT as a computer ID of 1, so I can catch them both
; if I call them something like 1A...Beyond this check, we should jump to FC_175 for un ID'ed computer running int 15h.


	mov	ax,ROMBIOS				; Load segment location into
	mov	es,ax					; ES register also

	xor	ax,ax
	mov	al,es:[computer_model_id]


	cmp	al,0feh					; Do we have an old XT
	jne	FC_52
	jmp	short FC_55
FC_52:
	cmp	al,0ffh					; Do we have an old PC
	jne	FC_60
FC_55:

	mov	_comp_id,1Ah				; 
	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_58					; if ZERO, bit is clear and we do not have 101 kybd
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3


	cmp	_debug, false
	je	debug_21
        print   mesg21
debug_21:


FC_58:
	jmp	FC_end					; go check video

FC_60:
	jmp	FC_175					; computer type not found above

;------------------------------------------------------------------------------------------------------------------------------------------
; NON IBM PS/1 and PS/2 determination done here
;------------------------------------------------------------------------------------------------------------------------------------------
; If we junp to here, int 15h not supported, vector = 09h, and we nust go directly to the
; hardware to try to ID the ocmputer

FC_100:

	mov	ax,ROMBIOS				; Load segment location into
	mov	es,ax					; ES register also

	xor	ax,ax
	mov	al,es:[computer_model_id]

	cmp	al,0fch					; do we have Orig AT ?
	jne	FC_110

	mov	_comp_id,5				; we have an Original IBM AT

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_105					; if ZERO, bit is clear and we do not have 101 kybd

	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3
	cmp	_debug, false
	je	debug_22
        print   mesg17A
	jmp	FC_end

FC_105:
	cmp	_debug, false
	je	debug_22
        print   mesg17
debug_22:

	jmp	FC_end

FC_110:
	cmp	al,0f9h					; DO WE HAVE AN IBM CONVERTIBLE ???
	jne	FC_120

	mov	_comp_id,4				;

	cmp	_debug, false
	je	debug_23
        print   mesg18
debug_23:

	jmp	FC_end

FC_120:
	cmp	al,0fdh					; DO WE HAVE AN IBM PC/JR ???
	jne	FC_130

	mov	_comp_id,3				; 

	cmp	_debug, false
	je	debug_24
        print   mesg19
debug_24:

	jmp	FC_end

FC_130:


FC_135:
	cmp	al,0feh					; DO WE HAVE AN IBM PC OR Original PC/XT ???
	jne	FC_140

	mov	_comp_id,1				; 

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_136					; if ZERO, bit is clear and we do not have 101 kybd

	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

FC_136:
	cmp	_debug, false
	je	debug_25
        print   mesg21
debug_25:

	jmp	FC_end

FC_140:
	cmp	al,0ffh					; DO WE HAVE AN IBM PC OR Original PC/XT ???
	jne	FC_175


	cmp	_debug, false
	je	debug_26
        print   mesg21
debug_26:

	mov	_comp_id,1				; 

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_145					; if ZERO, bit is clear and we do not have 101 kybd

	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

FC_145:
	jmp	FC_end
;--------------------------------------------------------
; Computer not ID'ed above
;--------------------------------------------------------
FC_175:
        print   mesg22
        print   mesg22A
        print   mesg22B

	mov	fcomputer_not_found,true		; flag back to menu that computer OPTIONS need to be displayed now
	mov	_comp_id,1				; default to a PC if not ID'able
        mov     fcomp_dialog_id, 1
	mov	comp_flag,false				; reset flag incase user chose or chooses again
	mov	_finject_keys,false
	jmp	FC_end

FC_200:
; The operator chose a computer from the menu, and we should setup our variables here
; vector will get set by the computer regardless of the operator setting

	mov	fcomp_dialog,false			; reset flag incase user chose or chooses again
	mov	fcomputer_not_found,false		; reset this flag since user choose a computer
	mov	al,fcomp_dialog_id			; get user choice
	cmp	al,1					; did user choose clone PC/PCXT/PCAT w/84 key keyboard
	jne	FC_210
	mov	_comp_id,1
	jmp	short FC_end

FC_210:
; user must have choose 2 or 3, 2=clone PC/AT w/101 key keyboard, 3=clone PC/386 w/101 key keyboard 	

	mov	_comp_id,5

	mov	ax,RAMBIOS				; Load segment location into
	mov	es,ax					; ES register also
	mov	al,es:[kb_flag_3]			; get 40:96h contents
	test	al,010h					; mask off bit 4, 101/102 kybd id bit
	jz	FC_end					; if ZERO, bit is clear and we do not have 101 kybd
	mov	comp_flag,true				; flag to tell us that we have a computer which supports BIOS kb_flag_1/3

FC_end:
;*****************************************************************************************************************
; quick check of video
;*****************************************************************************************************************
; Video type is a mess to sort out.  What I will do is check the PS/2 sytems first, and if they are not supported, I will
; make a different int 10h function call and try to decipher what other video combinations I have.
; We will determine eqVideoType as follows
;
;	1=monocrome display adapter
;	2= open
;	3= CGA
;	4= EGA mono
;	5= EGA color
;	6= MCGA	(multi color graphics adapter ) special PS/2, usually 25/30-8086
;	7= VGA

; For PS/2, we can call int 10h with function 1Ah in ah, if it comes back 1Ah, we know it was a PS/2 and that
; the function is supported.

	mov	al,0h					; read dispaly code
	mov	ah,1ah					; PS/2 read display code function
	int	10h

	cmp	al,1Ah					; was function call supported ?
	je	FC_end_ps2
	jmp	FC_end_12				; if not, not a PS/2 so try another int 10h function call

FC_end_ps2:
	cmp	bl,01h
	jne	FC_end_2
	mov	fvideo_type,1				; was monochrome (5151)


	cmp	_debug, false
	je	debug_27
        print   mesg52
debug_27:


	jmp	FC_end_50

FC_end_2:

	cmp	bl,02h
	jne	FC_end_4
	mov	fvideo_type,3				; was CGA

	cmp	_debug, false
	je	debug_28
        print   mesg49
debug_28:

	jmp	FC_end_50

FC_end_4:

	cmp	bl,04h
	jne	FC_end_6
	mov	fvideo_type,5				; was EGA color

	cmp	_debug, false
	je	debug_29
        print   mesg50
debug_29:

	jmp	FC_end_50

FC_end_6:

	cmp	bl,05h
	jne	FC_end_8
	mov	fvideo_type,4				; was EGA mono

	cmp	_debug, false
	je	debug_30
        print   mesg50
debug_30:

	jmp	FC_end_50


FC_end_8:

	cmp	bl,06h
	jne	FC_end_10

	mov	fvideo_type,6				; was MCGA """GUESSING"""

	cmp	_debug, false
	je	debug_31
        print   mesg53
debug_31:

	jmp	FC_end_50

FC_end_10:
; above bl=6, is unused or VGA

	mov	fvideo_type,7				; was VGA

	cmp	_debug, false
	je	debug_32
        print   mesg51
debug_32:

	jmp	FC_end_50


; non PS/2 jump to here to be determined ???
FC_end_12:
	
	mov	ah,12h					; next try int 10h function "ah"=12h
	mov	bl,10h					; and ask for EGA info if it exists
	int	10h

	cmp	bl,10h					; if upon return bl does not = 10h, then EGA is present
	je	FC_end_18
	cmp	bh,0
	jne	FC_end_15
	mov	fvideo_type,5				; was EGA color 
	cmp	_debug, false
	je	debug_34
        print   mesg50
debug_34:
	jmp	short FC_end_50

FC_end_15:
	mov	fvideo_type,4				; was EGA mono
	cmp	_debug, false
	je	debug_34A
        print   mesg50
debug_34A:
	jmp	short FC_end_50

FC_end_18:

; didn't find VGA or EGA, could still be CGA or MDA ?  Need to check presence 
; of video buffers, 0B8000h or 0B0000h to determine which one....
; Since I am currently unsure as to just what this test is, I think I will query
; using int 11h, and see if mono is set
;
;	int	11h					; get equioment list
;	test	al,00110000b				; check bits 5,4 
;	jz	FC_end_20
;	mov	fvideo_type,1				; was MDA
;	cmp	_debug, false
;	je	debug_40
;        print   mesg52
;debug_40:
;	jmp	short FC_end_50
;
;FC_end_20:
;
; the video mode with function "0fh', int 10h, and if it is in mode 7, I will 
; say MDA, otherwise the monitor is or can support CGA

	mov	ah,0fh
	int	10h

	cmp	al,7
	jne	FC_end_22

	mov	fvideo_type,1				; was MDA
	cmp	_debug, false
	je	debug_42
        print   mesg52
debug_42:
	jmp	short FC_end_50


FC_end_22:
; give up, if PS/2 it was found above, if EGA, it was found above, if MDA, one of the above
; tests should have found it, if not any of the above, make a CGA and quit

	mov	fvideo_type,3				; was CGA,or operating at CGA resolution

	cmp	_debug, false
	je	debug_33
        print   mesg49
debug_33:


FC_end_50:
        pop     es                                      ; restore registers
        pop     ds

        pop     dx 
        pop     cx
        pop     bx
        pop     ax
        pop     di
        pop     si

	ret
_FindComputer	endp

_BSS		ends

                end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\globals.h ===
/* the following buffers are used to construct lines of text for printing with _outtext()
		backgroundString holds a copy of the characters that make up the desktop */
extern char charBuffer[], tempBuffer[], backgroundString[];
extern int charBufferLength, tempBufferLength;


	/* The following variables hold the original values for the screen color and cursor size so we can reset after */
extern long oldBkColor;
extern short oldTextColor, oldTextCursor;

	/* Used to hold the values for reading the keyboard using _bios_keybrd() */
extern int keybrdRead, keybrdReady, keybrdShiftStatus;

	/* address of shared parameter block in the first instance of ADOS.COM */
extern unsigned char _far *currentParameters;

	/* the variables below are local copies of data from the shared parameter block */
extern unsigned char skSerialKeysOn, skSerialKeysLoaded, skInterrupt;
extern unsigned int  skPortAddress, skBaudRate, oldPortAddress;
extern unsigned int  serialPort1, serialPort2, serialPort3, serialPort4, numberOfSerialPorts;

extern unsigned char fFilterKeysOn, fOnOffFeedback;
extern unsigned int  fWaitTicks, fDelayTicks, fRepeatTicks, fBounceTicks;
extern unsigned char fMaxDefault, fClickOn, fBounceOn, fDialogFilterKeysOff;

extern unsigned char sStickyKeysOn, sOnOffFeedback, sAudibleFeedback, sTriState, sTwoKeysOff, sDialogStickyKeysOff, sClickOn;

extern unsigned char mMouseKeysOn, mOnOffFeedback;
extern unsigned int  mMaxSpeed, mTimeToMaxSpeed;
extern unsigned char mDialogMouseKeysOff, mMouseKeysOverride;

extern unsigned char tToggleKeysOn, tOnOffFeedback, tDialogToggleKeysOff;

extern unsigned char toTimeOut, toOnOffFeedback;
extern unsigned int  toValue;
extern unsigned char toDialogTimeOutOff;

extern unsigned char compDialog, compDialogId, compDialogAction, fSpaceSaver;
extern unsigned char fComputerNotFound, fHearingOn, fVideoFlash, fAccessAlreadyLoaded;

extern unsigned char eqButton1, eqButton2, eqCurrentButton, eqComputerId, eqMouseDriver, eqMouseId;
extern unsigned int  eqCommBase, eqExtendedSegment;
extern unsigned char eqVector, eqInjectKeys, eqVideoType, eqComputerFlag;

	/* global storage used to construct the configuration filename from the data on the command line */
extern char configurationFilename[], *configurationFileExtension;

	/* boolean flags to determine whether or not to install AccessDOS, quit the user interface,
		what video mode to run in, and whether or not to display debug information throughout the user inferface */
extern int displayModeFlag, installFlag, quitFlag, debug;

   /* Colors for various features of the menu */
extern long desktopBG, titleBarBG, hintBarBG, menuBarBG, menuBarHotBG, menuBarHotKeyBG;
extern long menuLineBG, menuLineHotBG, menuLineDeadBG, menuLineHotKeyBG, menuBoxBG;
extern long dialogBoxBG, dialogBoxHotBG, dialogBoxDeadBG, dialogBoxBorderBG, dialogBoxArrowBG, alertBoxBG;
extern short desktopFG, titleBarFG, hintBarFG, menuBarFG, menuBarHotFG, menuBarHotKeyFG;
extern short menuLineFG, menuLineHotFG, menuLineDeadFG, menuLineHotKeyFG, menuBoxFG;
extern short dialogBoxFG, dialogBoxHotFG, dialogBoxDeadFG, dialogBoxBorderFG, dialogBoxArrowFG, alertBoxFG;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\gide.c ===
/* GIDE.C  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "gide.h"
#include "kbd.h"
#include "mou.h"
#include "comm.h"
#include "init.h"
#include "serkeys.h"

/*************************************************************************
**************************************************************************
**************************************************************************
*********                       ******************************************
*********   Program structure   ******************************************
*********                       ******************************************
**************************************************************************
**************************************************************************
**************************************************************************

 	CHAR HANDLER
					changes pointers when Escape character comes in and
					converts ASCII char mode to Escape sequence.
						
 	DETERMINE FORMAT
					determines escape sequence format i.e. is it alias
 					mode, GIDEI code mode, old KEI mode, or implied press
 					mode.  Changes vectors to appropriate routines.

 	PROCESS ALIAS
					converts the alias field into GIDEI codes.
 
	PASS ALL CODES
					a pass through routine for serial vector when in
 					GIDEI code mode since no preprocessing is needed.
 
	PROCESS KEI
					if included, this routine handles the old KEI std.
					escape sequence format.  Since the command is at
					the end in the old KEI std, we have to collect the
					entire string before it is processed.

*****************************************************************************
CODE VECTOR
					Points to routines which sift out special GIDEI codes.
 					The special GIDEI codes affect how escape sequences
 					will be handled
 
 	PROCESS GIDEI CODE
					sifts out the special GIDEI codes, if any.  This
 					routine will call additional routines if the
 					special GIDEI codes require additional processing:
 
 		PROCESS GIDEI CLEAR
					handles the :clear command
 
 		PROCESS GIDEI END
					handles the :end command

 		PROCESS GIDEI BLOCK TRANSFER
					handles :blktrans command
 			PROCESS BLOCK
 
 		PROCESS BYTES
					handles the :byte, :integer, etc commands

*****************************************************************************
COMMAND VECTOR
					These routines do the actual processing of the GIDEI
					codes which control the devices such as the keyboard,
					mouse, and serial port.  This pointer will point to
					the routine to handle a particular action on a
					particular device.  The routines are found in files
					whose names correspond to the device.  (kbd.c, mou.c,
					comm.c, etc.)

	PROCESS COMMAND
					this routine determines which device/command has
					been received and changes the pointers to the
					necessary routine and corresponding alias table
					for that routine.

	other routines
					all the other routines are in their respective
					files as mentioned above.


**************************************************************************
**************************************************************************
**************************************************************************
*/


/**************************************************************************

	FUNCTION:	charHandler

	PURPOSE:	If ESCAPE then set up new state.  If ASCII, processes the char

	COMMENTS:
*/

void charHandler(void)
{
	BYTE tempBuf;

	codeVector = processGideiCode;					/*  make sure these were done  */
	cmdVector = processCommand;
	if (serByte == ESC) {								/*  set up for next state  */
		serVector = determineFormat;
		beginOK = TRUE;
		}
	else if (waitForClear || (serByte > 127)) errDetect();
	else {													/*  get codes from ASCII table */
		tempBuf = (asciiTblPtr[serByte]).code1;
		if (!inLst(&kLock,tempBuf) && (!inLst(&kHold,tempBuf)))
			tmpLst.list[tmpLst.len++] = tempBuf;
		if ((tempBuf=(asciiTblPtr[serByte]).code2) != NOCODE)
			if (!inLst(&kLock,tempBuf) && (!inLst(&kHold,tempBuf)))
				tmpLst.list[tmpLst.len++] = tempBuf;
		doCombineLst();
		}
}





/****************************************************************************

	FUNCTION:	determineFormat

	PURPOSE:	Figure out what Escape Sequence form (i.e. Alias, Code, KEI, etc)

	COMMENTS:
*/

void determineFormat(void)
{
	switch (serByte) {
		case COMMA:											/* signals alias mode */
			serVector = processAlias;					/* set up next state */
			aliasPtr = commandsAliasTable;
			break;
		case ESC:											/* if another esc, do nothing */
			break;
		default:
			if ((serByte >= ' ') && (serByte <= '~'))
				{												/* simulate Implied Press */
				gCode = KBDPRESSCODE;					/* send press code */
				(*codeVector)();
				serVector = processAlias;				/* set up new state */
				processAlias();
				}
			else {  											/*  GIDEI code mode */
				serVector = passAllCodes;				/* set up next state */
				gCode = serByte;
				(*codeVector)();
				}
			break;
		}
}






/****************************************************************************

	FUNCTION:	processAlias()

	PURPOSE:	This routine builds up the alias field.  After receiving field
				it translates to GIDEI codes and passes on to processing routines.

	COMMENTS:
*/

void processAlias(void)
{
	BYTE aLen;
	unsigned int iTemp;

	if (serByte == ESCAPE) aliasStr[0] = '\0';	/* reset field in esc 	*/
	else if (serByte == SPACE) {}						/* ignore space chars in esc seq	*/
	else {
		for (aLen=0;aliasStr[aLen] != '\0';aLen++);
		if (serByte==COMMA || serByte==PERIOD) {	/* if field delimiter, process field */
			if (!aLen) storeByte(DEFAULTCODE);		/* empty field-assume default	*/
			else if (aLen > MAXALIASLEN)				/* field too long, what is it?	*/
				storeByte(UNKNOWNCODE);

			/* Now search alias tables to see if legal alias. */
			/* First check if alias for GIDEI directive, else check */
			/* table related to the command */

			else if (tblSearch(gideiAliasTable)) storeByte(aliasStr[0]);
			else if (aliasUsedInStandard(aLen)) storeByte(aliasStr[0]);
			else {
				/* Well, not in alias tables.  Maybe it is a numeric parameter. */
				iTemp = convertStringToInt();
					/* if cannot convert string to an integer, */
					/* iTemp = 0xFFFF and aliasStr[0] = '\0' */

				/* Now, is it an ASCII coded number or ASCII coded GIDEI code? */
				switch (aliasStr[0]) {
					case '0':
					case '+':
					case '-':								/* ASCII coded number*/
						storeByte(INTEGERCODE);
						storeByte((BYTE) iTemp);
						storeByte((BYTE) (iTemp >> 8));
						break;
					default:
						/* ASCII coded GIDEI code? */
						if (iTemp > 255) storeByte(UNKNOWNCODE);
						else storeByte((BYTE) iTemp);
						break;
					}
				}
			if (serByte == '.') storeByte(TERMCODE);
			aliasStr[0] = '\0';
			for (;retrieveByte();) (*codeVector)();/* byte returned in gCode*/
			}
		else {
	  		/* just add the char to the string */
			if ((serByte > ' ') && (serByte <= '~')) {
				if (aLen < MAXALIASLEN+1) {			/* ignore if no room*/
					if ((serByte>='A')&&(serByte<='Z'))/* make sure lower case	*/
						serByte += 'a' - 'A';
					aliasStr[aLen++] = serByte;		/* now add to string	*/
					aliasStr[aLen] = '\0';
					}
				}
			else
				errDetect();								/* not an alias	*/
			}
		}
}



/****************************************************************************/
BOOL aliasUsedInStandard(BYTE aLen)
{
	BOOL found;
	BYTE iCode;

	/* if alias is an alias for a key and alias is a single character,  */
	/* use ASCII table for code.  This saves table space.  */

	if ((aLen == 1) && (aliasPtr == keyAliasTable)) {
		iCode = asciiTable[aliasStr[0]].code1;
		if ((iCode == control_key) || (iCode == shift_key))
			aliasStr[0] = asciiTable[aliasStr[0]].code2;
		else
			aliasStr[0] = iCode;
		found = TRUE;
		}
	else found = tblSearch(aliasPtr);
	return (found);
}

/****************************************************************************/
BOOL tblSearch(struct aliasTableType * tblPtr)
{
	BOOL found;
	int result;

	found = FALSE;
	for (;(tblPtr->aliasName[0]!='\0')&&(!found); tblPtr++) {
		result = strcmp(aliasStr,tblPtr->aliasName);
 		if ( result == 0) {
			found = TRUE;
			aliasStr[0] = tblPtr->gideiCode;
			}
		else if (result < 0) break;					/* past all so may as well	*/
		}														/*  quit now	*/
	return (found);
}




/****************************************************************************

	FUNCTION:	passAllCodes

	PURPOSE:	Just keeps the GIDEI hierarchy consistant

	COMMENTS:	
*/

void passAllCodes(void)
{
	gCode = serByte;
	(*codeVector)();
	return;
}



/****************************************************************************************/



/****************************************************************************

	FUNCTION:	processGideiCode

	PURPOSE:
				

	COMMENTS:

*/

void processGideiCode(void)
{
	if (waitForClear) {
		if (gCode == CLEARCODE) codeVector = processGideiClear;
		else errDetect();
		}
	else
		switch (gCode) {

			case BEGINCODE:
				if (beginOK) {
					if (pushPointers()) lastCode = gCode;
					else errDetect();
					}
				else errDetect();
				break;

			case ENDCODE:
				if (lastCode == TERMCODE) {
					codeVector = processGideiEnd;
					beginOK = FALSE;
					lastCode = gCode;
					}
				else errDetect();
				break;

			case CLEARCODE:
				codeVector = processGideiClear;
				lastCode = gCode;
				break;

			case TERMCODE:
				(*cmdVector)();
				if (!restorePointers()) {
					cmdVector = processCommand;
					codeVector = processGideiCode;
					serVector = charHandler;
					beginOK = FALSE;
					}
				else
					beginOK = TRUE;
				lastCode = gCode;
				break;

			case BLKTRANSCODE:
				codeVector = processGideiBlockTransfer;
				(*cmdVector)();
				lastCode = gCode;
				break;

			case BYTECODE:
				codeVector = processBytes;
				byteCount = 1;
				passAll = TRUE;
				(*cmdVector)();
				lastCode = gCode;
				break;

			case INTEGERCODE:
				codeVector = processBytes;
				byteCount = 2;
				passAll = TRUE;
				(*cmdVector)();
				lastCode = gCode;
				break;

			case LONGCODE:
				codeVector = processBytes;
				byteCount = 4;
				passAll = TRUE;
				(*cmdVector)();
				lastCode = gCode;
				break;

			case DOUBLECODE:
				codeVector = processBytes;
				byteCount = 8;
				passAll = TRUE;
				(*cmdVector)();
				lastCode = gCode;
				break;

			default:
				(*cmdVector)();
				lastCode = gCode;
				break;
			}

}



/************************/
void processGideiClear(void)
{
	if (gCode == TERMCODE) initGIDEI();
	else errDetect();
}



/************************/
void processGideiEnd(void)
{
	if (gCode == TERMCODE) {
		if (!popPointers()) errDetect();
		else {
			if (restorePointers()) {
				beginOK = TRUE;
				codeVector = processGideiCode;
				}
			else {
				cmdVector = processCommand;
				codeVector = processGideiCode;
				serVector = charHandler;
				beginOK = FALSE;
				}
			lastCode = gCode;
			}
		}
	else errDetect();
}



/************************/
void processGideiBlockTransfer(void)
{
	byteCount = gCode;
	codeVector = processBlock;
	passAll = TRUE;
}




/************************/
void processBlock(void)
{
	if (byteCount--) (*cmdVector)();
	else {
		passAll = FALSE;
		if (gCode == TERMCODE) codeVector = processGideiCode;
		else errDetect();
		}
}



/************************/
void processBytes(void)
{
	(*cmdVector)();
	if (!(--byteCount)) {
		passAll = FALSE;
		codeVector = processGideiCode;
		}
}



/****************************************************************************

	FUNCTION:	processCommand

	PURPOSE:	Determine which command is active.  Then set cmdVector to
				point to appropriate routine.

	COMMENTS:

*/
void processCommand(void)
{
	switch(gCode) {
		case KBDEXPANSIONCODE:
			cmdVector = processKbd;
			aliasPtr = kbdAliasTable;
			beginOK = TRUE;
			break;
		case MOUEXPANSIONCODE:
			cmdVector = processMou;
			aliasPtr = mouseAliasTable;
			beginOK = TRUE;
			break;
		case GENCODE:
			cmdVector = processGen;
			aliasPtr = genAliasTable;
			beginOK = TRUE;
			break;
		case COMMCODE:
			cmdVector = processComm;
			aliasPtr = commAliasTable;
			beginOK = TRUE;
			break;
		case KBDLOCKCODE:
			cmdVector = processKbdLock;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDRELCODE:
			cmdVector = processKbdRel;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDPRESSCODE:
			cmdVector = processKbdPress;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDCOMBINECODE:
			cmdVector = processKbdCombine;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case KBDHOLDCODE:
			cmdVector = processKbdHold;
			aliasPtr = keyAliasTable;
			beginOK = TRUE;
			break;
		case MOULOCKCODE:
			cmdVector = processMouLock;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOURELCODE:
			cmdVector = processMouRel;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUCLICKCODE:
			cmdVector = processMouClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUDOUBLECLICKCODE:
			cmdVector = processMouDoubleClick;
			aliasPtr = mouButtonAliasTable;
			beginOK = TRUE;
			break;
		case MOUMOVECODE:
			cmdVector = processMouMove;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOUGOTOCODE:
			cmdVector = processMouGoto;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case MOURESETCODE:
			cmdVector = processMouReset;
			aliasPtr = nullTable;
			beginOK = TRUE;
			break;
		case BAUDRATECODE:
			cmdVector = processBaudrate;
			aliasPtr = baudrateAliasTable;
			beginOK = TRUE;
			break;
		case UNKNOWNCODE:
			errDetect();
/*			cmdVector = noOpRoutine;
			beginOK = TRUE;
*/
		default:
			if (gCode >= LOWESTGIDEICODE) errDetect();
			else {
				errDetect();
/*				cmdVector = noOpRoutine;
				beginOK = TRUE;
*/
				}
			break;
		}
}

/*****************************************************************************************/
/**********************  MISC ROUTINES     ***********************************************/
/****************************************************************************

	FUNCTION:	pushPointers

	PURPOSE:	push cmdVector on to vectorStack

	COMMENTS:	*/


BOOL pushPointers(void)
{
	if (ptrStackPtr >= (ptrStack+MAXPOINTERSTACK)) return FALSE;
	ptrStackPtr->aliasTablePtr = aliasPtr;
	ptrStackPtr->commandRoutinePtr = cmdVector;
	++ptrStackPtr;
	return TRUE;
}




/****************************************************************************

	FUNCTION:	restorePointers

	PURPOSE:	restore Pointers from vectorStack but does not update 
				stack pointer.

	COMMENTS: */


BOOL restorePointers(void)
{
	if (ptrStackPtr <= ptrStack) return FALSE;
	aliasPtr = (ptrStackPtr-1)->aliasTablePtr;
	cmdVector = (ptrStackPtr-1)->commandRoutinePtr;
	return TRUE;
}




/****************************************************************************

	FUNCTION:	popPointers

	PURPOSE:	pop pointers from stack

	COMMENTS:	*/


BOOL popPointers(void)
{
	if (restorePointers()) {
		--ptrStackPtr;
		return TRUE;
		}
	return FALSE;
}





/************************/
BOOL storeByte(BYTE theByte)
{
	/*spos points to next free storage spot */
	/*If spos+1 = rpos then buffer is full*/
	/*also, if spos+1 = end of codebuffer then rap around */
	/*to 0 unless rpos=0 cuz buffer is full */

	if ((spos+1==rpos)||((spos+1==CODEBUFFERLEN) && !rpos)) return FALSE;
	buf[spos] = theByte;
	spos = (spos+1==CODEBUFFERLEN) ? 0 : spos+1;
	return TRUE;
}


/************************/
BOOL retrieveByte(void)
{
	/* rpos points to byte to retrieve.  If rpos = spos then buffer empty */

	if (spos==rpos) return FALSE;
	gCode = buf[rpos];
	rpos = (rpos+1==CODEBUFFERLEN) ? 0 : rpos+1;
	return TRUE;
}





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\gide.h ===
/*  GIDE.H   */


void charHandler(void);
void determineFormat(void);
void processAlias(void);
BOOL aliasUsedInStandard(BYTE aliasLen);
BOOL tblSearch(struct aliasTableType * tblPtr);
void passAllCodes(void);

void processGideiCode(void);
void processGideiClear(void);
void processGideiEnd(void);
void processGideiBlockTransfer(void);
void processBlock(void);
void processBytes(void);

void processCommand(void);

BOOL pushPointers(void);
BOOL restorePointers(void);
BOOL popPointers(void);
BOOL storeByte(BYTE theByte);
BOOL retrieveByte(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\handicap.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	HANDICAP.ASM							*
;									*
;************************************************************************
;----------------------------------------------------------------------------
; HANDICAP.ASM
;
; FilterKeys  = Adjustment of typematic rate, key acceptance, debounce time and recovery times
; StickyKeys = One finger typing feature
; MouseKeys   = Complete mouse function from the numeric keypad
; ToggleKeys  = Audible feedback of indicator light states of keyboard
;
; The way this is done is to chain together the routines that implement 
; these features.  The routine below, keybd_int, actually reads the keyboard 
; port and then builds up the extended scan code which consists of the 
; "hidden" byte and then the scan byte.  It then passes it in AX to the first 
; routine in line (FilterKeys).  Each successive routine then continues to 
; pass it on or inhibits it.  Note, that if the scan code is an "e0", "e1", or 
; a response to a keyboard command, (>"f0"), then this routine passes the
; code to the original keyboard int. while also saving it to use as a scan code
; identification as the real scan code is later passed along between the routines.
; There may be a few exceptions to this, like if a control break is being trapped.
;
; The routine keybd_int does all the hardware management, unless one of the 
; routines (namely the BIOS in the computer ROM ) resets the hardware, in which case 
; keybd_int does not.  The variable fbios_called_direct is used to flag this condition.


print	MACRO	string
	mov	dx,OFFSET string
	mov	ah,9
	int	21h
	ENDM

INCLUDE	keyboard.inc

IFDEF	BUG

	PUBLIC	portid,portout
	EXTRN	HexCharsOut:PROC

ENDIF; BUG

	EXTRN	_end:ABS

	EXTRN	flatch:byte				; in Stickeys.asm
	EXTRN	shift_flg:byte

	EXTRN	FilterKeys:NEAR				; in FilterKeys.asm
	EXTRN	FilterKeys_timer:PROC
	EXTRN	FilterKeys_dialog:PROC
	EXTRN	fshift_click:byte

	EXTRN	MouseKeys_timer:PROC			; in  MouseKeys.asm
	EXTRN	InjectMouse:PROC			
	EXTRN	button_click:PROC			
;;	EXTRN	Put_Mouse_Data:PROC
	EXTRN	fMoving:byte
	EXTRN	Mouse_Status:word
	EXTRN	Delta_X:word
	EXTRN	Delta_Y:word
	EXTRN	Last_Direction:byte
	EXTRN	Status:byte
	EXTRN	mouse_data:word
	EXTRN	mouse_data_head:word
	EXTRN	mouse_data_tail:word
	EXTRN	mouse_data_end:word
	EXTRN	fbutton_up:byte
	EXTRN	fbutton_down:byte
	EXTRN	MouseKeys_dialog:PROC
	EXTRN	Button_Status:byte
	EXTRN	mouse_cnt:byte
	EXTRN	fnum_lock_was_off:byte
	EXTRN	fserial_stop:byte

	EXTRN	ToggleKeys_timer:PROC			; in ToggleKeys.asm
	EXTRN	ToggleKeys_dialog:PROC

	EXTRN	TimeOut_Reset:PROC			; in TimeOut.asm
	EXTRN	TimeOut_dialog:PROC
	EXTRN	last_address:word

	EXTRN	key_cnt:byte				; in StickeyKeys.asm
	EXTRN	StickeyKeys_dialog:PROC
	EXTRN	fkeys_injected:byte
	EXTRN	set_shift_states:PROC

;	EXTRN	_serialKeysInit:PROC			; in SerialKeys
	EXTRN	_kickStartSerialKeys:PROC
;	EXTRN	_initCommPort:PROC
;	EXTRN	_serialKeysStartupInit:PROC
	EXTRN	_forcedInt9Flag:byte
	EXTRN	_injectByte:byte
	EXTRN	_skWindowCompatible:byte
	EXTRN	_serialKeysEnableFar:FAR
	EXTRN	_serialKeysDisableFar:FAR

	EXTRN	fFilterKeysOn:byte			; from Param.asm
	EXTRN	fMouseKeysOn:byte	
	EXTRN	fcomp_dialog:byte
	EXTRN	fcomp_dialog_id:byte
	EXTRN	fDialog_Filter_off:byte
	EXTRN	fDialog_Stickeys_off:byte
	EXTRN	fDialog_Mouse_off:byte
	EXTRN	fDialog_Toggle_off:byte
	EXTRN	fDialog_TimeOut_off:byte
	EXTRN	fDialog_Action:byte
	EXTRN	fmkeys_override:byte
	EXTRN	fspace_saver:byte
	EXTRN	fhearing_on:byte
	EXTRN	fvideo_flash:byte
	EXTRN	fcomputer_not_found:byte
	EXTRN	fSticKeysOn:byte   
	EXTRN	fclick_on:byte
	EXTRN	_serialKeysOn:byte
	EXTRN	fslow_baud_mouse:byte

	EXTRN	_comp_id:byte
	EXTRN   _combase:word
	EXTRN	fmouse_driver:byte
	EXTRN	_finject_keys:byte
	EXTRN	_vector:byte
	EXTRN	comp_flag:byte
	EXTRN	ExtendedSeg:word
	EXTRN	_fmouse_id:byte
        EXTRN   comp_flag:byte
        EXTRN   btn_1:byte
        EXTRN   btn_2:byte
        EXTRN   Current_Button:byte
        EXTRN   fmouse_driver:byte
        EXTRN   fvideo_type:byte
	EXTRN	fserial_keys_loaded:byte


	PUBLIC	beep_low				; in Handicap.asm
	PUBLIC	pass_to_computer
	PUBLIC	beep_high
	PUBLIC	click
	PUBLIC	no_beep
	PUBLIC	beep_turn_on
	PUBLIC	beep_turn_off
	PUBLIC	InjectKeys
	PUBLIC	Get_Mouse_Data
	PUBLIC  Put_Key_Data
	PUBLIC	shift_tbl
	PUBLIC	shift_tbl_len
	PUBLIC	real_states
	PUBLIC	prev_real_states
	PUBLIC	current_shift
	PUBLIC	fpause_being_sent
	PUBLIC	fmouse_button
	PUBLIC	fwindows_st_re
	PUBLIC	fsilent_click
	PUBLIC	key_data_tail
	PUBLIC	key_data_head
	PUBLIC	key_data
	PUBLIC	key_data_end
	PUBLIC	faccess_sound
	PUBLIC	fswitching_video

	PUBLIC	fbios_called_timing
	PUBLIC	Enable
	PUBLIC	fsecond_cue
	PUBLIC	fkey_not_passed
	PUBLIC	ftimer_1C_active 
	PUBLIC	fserial_key_recieved
	PUBLIC	fmousetrapping
;	PUBLIC  fwindows_enh				; DEBUGGING

;----------------------------------------------------------------------------

_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:_TEXT
	assume ES:_TEXT
	assume SS:NOTHING

;;PUBLIC	timer_Stack_top

PUBLIC	kybd_Stack_top


;		even
;timer_sp_save		dw 0
;timer_ss_save		dw 0
;		db 'tstacke'
;		even
;timer_Stack		dw 150 dup(0)
;timer_Stack_top	dw $-2
;		db 'tstacks'

		even
kybd_sp_save		dw 0
kybd_ss_save		dw 0
		db 'kstacke'
		even
kybd_Stack		dw 75 dup(0)
kybd_Stack_top	dw $-2
		db 'kstacks'


;;	ORG	100h
;;
;;begin:
;;
;;	jmp	_enable		  
;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;

;  The below area defines the resident data area.
;
;----------------------------------------------------------------------------

fserial_key_recieved	db	false		; flag used to tell my code modules that they are processing a serial key input
fkey_not_passed		db	false		; flag used to signal that a key didn't pass yet in int 9 w/stickeys on

ftimer_1C_active	db	false		; flag to signal me when I am in a timer 1C interrupt
fint9_active_temp	db	false		; flag used by int 9 to prevent double pushing of stack
;;fint1C_active_temp	db	false		; flag used by int 1C to prevent double pushing of stack

fdonnot_hook_address	db	false		; flag used by int 33 routine to hook or unhook address's
fslow_mouse		db	false		; flag used in slow serial mice to tell timer to write every other clock tic

fvideo_flash_cnt	db	0		; reset counter at start
fvideo_flash_on		db	false		; reset flag at start
video_cnst		db	4		; 4 for wait between toggling screen

shift_tbl	label	byte
	dw	RAlt,RCtrl,Alt,Ctrl,LShift,RShift
shift_tbl_len	equ	6

ctrl_break_buf	label	byte
	db	0e0h,046h,0e0h,0c6h
ctrl_break_buf_len	equ	4


ctrl_break_buf_cnt	DB	false			; counter into buffer when keys are being Injected

prev_real_states	DB	0			; previous state of real shift keys
real_states		DB	0			; current state of real shift keys

current_shift		DB	0			; holds flag of current shift if there is one

video_state		DB	0			; hold current video state for comparison checking
old_char_1		DB	0			; hold the char, which gets over written by hearing impaired symbol
old_char_2		DB	0			; hold the char, which gets over written by hearing impaired symbol
old_char_1_attr		db	0			; hold attribute of char 1
old_char_2_attr		db	0			; hold attribute of char 2
fsecond_cue		db	0			; holds second character if needed for visual cue

old_row			DB	0			; temp storage of cursor row position if hearing flag set
old_col			DB	0			; temp storage of cursor column position if hearing flag set
old_cursor_1		DB	0			; temp save of cursor type
old_cursor_2		DB	0			; temp save of cursor type
txt_or_grph		DB	0			; temp save of current video state, text or graphics mode

video_count		DB	false			; counter used if hearing flag set
faccess_sound		DB	false			; flag which will cause video output for AccesDos beeps 
							; since some of them are too short in length to be trapped by the timer int.
fswitching_video	DB	false			; flag to inform ADOS that video is switching when true	
fint9_by_timer		DB	false			; flag to our int15 routine that timer inititated an int9h
							; and that we should get scan code out of the key_data_buffer

floop_back     		db	false			; flag to let me know if I need to grab byte/replace byte
							; to prevent keyboard int from getting between timer injected codes

count_down_ticks	label	word			; counter used during tone setup
no_tone			DW	014h			; soft tone sound
low_tone		DW	06c0h			; 500 hz FilterKeys tones
high_tone		DW	0120h			; 2.0 khz
click_tone		DW	06c0h			;  hz ??????
turn_on_start_beep	DW	0360h			; 1.0 khz
turn_off_start_beep	DW	0120h			; 2.0 khz
on_off_change		DW	6			; for 100 steps

fbios_called_direct	DB	false			; flag for if BIOS routine called
fbios_called_timing	DB	false			; flag for when timer function calls BIOS routine

fpause_being_sent	DB	false			; flag to tell MouseKeys that a real PAUSE key is passing, so don't 
							; turn off on the "45h" part of it
fmouse_or_kybd		DB	false			; flag to tell us if the int. routine called the keybd or mouse int. vector
frehook_mouse		DB	false			; flag to during int33h
fmouse_button		DB	false			; flag to tell int 33 or timer when mousekeys has a mouse button down for polled mice
fFake_mouse		DB	false			; flag to tell sub int33h, when mask has been set for Int. driven mice
fsilent_click		DB	false			; flag to call click but silently
							; so we should convert to control break on computers which support it

fmousetrapping		DB	false			; if this flag is false, we allow MouseKeys to hook int 33h (added 4/92)
fctrl_break_on		DB	false			; same as above,used in Handicap.asm to eat keystrokes

fsysreq	   	  	DB	false			; flag to tell us the alternate key is down and a print screen key was pressed
							; so we should convert to system request on computers which support it
							; keyboard buffer
fscroll_changed		DB	false			; flag to tell us we detected shift+numlock on space saver keyboard
fvideo_flash_save	DB	false			; temp storage flag for fvideo_flash when Windows takes over
fhearing_on_save	DB	false			; "" "" ""

call_mask		DW	0			; mask sent by applications to mouse driver

;------------------------------------------------------------------------------------------------------------------------------
fwindows		DB	false			; flag to tell us if we started program inside of or under windows
							; anytime we exit Windows, this TSR program will have to terminate if started
							; after Windows was already running.
fwindows_st_re		DB	false			; flag to tell us which mode of Windows we are running in
fwindows_enh		DB	false			; flag to tell us which mode of Windows we are running in
;------------------------------------------------------------------------------------------------------------------------------

fwindows_after		DB	false 			; flag to tell us that Windows was loaded after ADOS was already started
fwindows_after_st	DB	false			; flag that says Windows started after ADOS in standard mode
fwindows_after_re	DB	false			; flag that says Windows started after ADOS in real mode
fwinfows_after_enh 	DB	false			; flag that says Windows started after ADOS in enhanced mode

fDOS_box		DB	false			; flag to Windows and serial keys that Windows is either DOS boxing
							; int2f w/ax=1680 =true first fime, or alt/ctrl+esc from DSO box back to Windows
							; and fDOS_box=false
;-------------------------------------------------------------------------------------------------------------------------------

falt_esc		DB	false			; flag to tell us that an alt+esc make was sent
falt_esc_send		DB	false			; flag that alt+esc break was sent and we can now safely inject Windows Alt+esc

fctrl_esc		DB	false			; flag to tell us that an ctrl+esc make was sent
fctrl_esc_send		DB	false			; flag that ctrl+esc break was sent and we can now safely inject Windows Ctrl+esc


mouse_x_temp		DB	false			; byte used to keep semi track of mouse x coordinate, to tell if it moved 
							; during int. 33 polling
mouse_y_temp		DB	false			; byte used to keep semi track of mouse y coordinate, to tell if it moved 
							; during int. 33 polling

hidden_code		DB	0			; holds either E0 or E1 or 00

key_data_tail		DW	?			; pointer into key_data
key_data_head		DW	?			; pointer into key_data
key_data		DW	20 DUP (?)		; array of (20 words) for circular buffer of keyboard scan code data
key_data_end	label	word

IFDEF	BUG
	portid		DB	0
	portout		DB	0

fserial_debugging	DB	0

	PUBLIC	old_row,old_col
	PUBLIC	fserial_debugging

; Message data area for the various routines used during initialization

	mesg41		DB	"Program started while running Windows in Enhanced Mode", 13, 10, "$"
	mesg42		DB	"Program started while running Windows in Real/Standard Mode", 13, 10, "$"

	mesg45		DB	"Your version of DOS (pre 3.0) does not support all Access DOS features", 13, 10, "$"
	mesg46		DB	"Your computer is running DOS version 3.0 or higher", 13, 10, "$"

ENDIF;	BUG

	mesg22		DB	"Computer was not identifiable and will be treated as a PC/XT/AT with an 84 key keyboard.", 13, 10, "$"
	mesg22A		DB	"Please restart AccesDOS menu, type access,  to change this selection if your ", 13, 10, "$"
	mesg22B		DB	"computer is NOT a PC/XT/AT with an 84 key keyboard.", 13, 10, "$"

	mesg43		DB	"Windows loading aborted, DO NOT run Enhanced Mode after AccessDOS is started", 13, 10, "$"
	mesg44		DB	"Unload Access DOS or run Windows in Standard Mode (win /s) ", 13, 10, "$"
	mesg60		DB	"Please wait, AccessDOS is loading...", 13, 10, "$"

; store these old vector variables here such that they always get addressed correcly


old_1C_int		label	word			; holds far call vector to previous timer int
old_1C_int_off		DW	0			; holds old timer routine offset address
old_1C_int_seg		DW	0			; holds old timer routine segment address

old_kybd_int		label	word			; holds far call vector to previous keyboard int
old_kybd_int_off	DW	0
old_kybd_int_seg	DW	0

old_2f_int		label	word			; holds far call vector to previous int 2f service routine
old_2f_int_off		DW	0		    	; we watch this int solely to know if windows is loaded after
old_2f_int_seg		DW	0		    	; ADOS has been started

old_33_int		label	word			; holds far call vector to previous int 33 service routine
old_33_int_off		DW	0
old_33_int_seg		DW	0

old_ps2mou_int		label	word			; holds far call vector to previous int
old_ps2mou_int_off	DW	0
old_ps2mou_int_seg	DW	0

;testpattern		db	'markstart'
sub_int33_ptr		label	word
sub_int33_ptr_off	DW	0			; holds far call vector to an address if an application trys
sub_int33_ptr_seg	DW	0			; holds far call vector to an address if an application trys

;sub_int33_ptr_2		label	word
;sub_int33_ptr_off_2	DW	0			; holds far call vector to an address if an application trys
;sub_int33_ptr_seg_2	DW	0			; holds far call vector to an address if an application trys
;
;sub_int33_ptr_3		label	word
;sub_int33_ptr_off_3	DW	0			; holds far call vector to an address if an application trys
;sub_int33_ptr_seg_3	DW	0			; holds far call vector to an address if an application trys

;---------------------------------------------------------------------------
; ship_it
;
; Routine to disable and enable the keyboard.  Works for IBM AT, NAT, 50,60 70,80
; according to Tech Ref. manual.  Send what is in al register to status port of 
; keyboard.  We only need to use this routine for int 9 computers of AT class
;
; expects	al register to contain code to send to the keyboard control chip


ship_it	proc

	push	cx
	push	ax
	xor	cx,cx				; zero cx register

ship_it_5:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; wait till we are allowed to write to port
	loopnz	ship_it_5
	pop	ax				; char to send is in al register
	out	status_port,al			; may have gotten an  enable or disable code for keyboard in "al" register
	pop	cx				; clean up stack
	ret

ship_it	endp

;----------------------------------------------------------------------------
; pass_to_computer 
;
; This routine passes the scan code to the original keyboard device driver when 
; called on a computer using keyboard interrupt 9h in byte form in al.
;
; In reality, the original keyboard int. reads the kb_data
; in port, and places the result in "al" register, which is the same scan code
; which this routine is passing along
;
; If this computer supports int 15h, then the only thing this routine does is set the 
; fbios_called_direct flag to true, telling the return code that this key should get
; passed to the computer



pass_to_computer	proc

	assume	DS:_TEXT

;;	push	ax
;;	push	ds

	cmp	_vector,15h				; are we running under int 15h
	je	pass_to_computer_100			; if yes, life as usual

; int 9h computers will get ot this code

	cmp	fFilterKeysOn,false			; is FilterKeys On ???
	je	pass_to_computer_25			; if FilterKeys is off, safe to pass key in this int 9 pass

	cmp	ftimer_1C_active,true			; is the timerr trying to pass a key
	jne	pass_to_computer_25			; if not, allow key to pass

; if stickeys is on, we need to flag that we didn't pass the key as yet

	cmp	fSticKeysOn,true
	jne	pass_to_computer_10
	mov	fkey_not_passed,true			; flag that timed key has not yet passed

pass_to_computer_10:

	jmp	pass_to_computer_end

;**************
;	cmp	_comp_id,1				; is this an IBM PC or original PC/XT ??
;	jne	pass_to_computer_25			; if not, don't need to bother with the following check
;
;	mov	ah,al					; save al, the scan code we are supposed to pass on
;	in	al,kb_data				; read in data from keyboard port
;	cmp	al,0					; was bit 0 a 0??
;	je	pass_to_computer_110			; yes, no data in buffer, skip call to orig. kybd int.
;
;	cmp	al,ah					; was the data at the keybd port, the same as what is supposed to be passed ?
;	jne	pass_to_computer_110			; if not, don't send it
;**************

pass_to_computer_25:
  	
	mov	fkey_not_passed,false			; reset this flag
	push	ds

	pushf
	call	dword ptr cs:old_kybd_int

	pop	ds
	assume	ds:_TEXT

pass_to_computer_100:
  	
	mov	fbios_called_direct,true


;************
;	jmp	short pass_to_computer_120
;
;pass_to_computer_110:
;
;	mov	fsilent_click,true			; set true if didn't send anything
;
;pass_to_computer_120:
;
;	pop	ds
;	pop	ax
;************

pass_to_computer_end:

	ret

pass_to_computer	endp
;----------------------------------------------------------------------------
; 
; InjectKeys
; 
; This procedure is used on computers which support the Injection of key scan codes 
; into the hardware buffer to inject either a control break scan code or an alternate
; print screen (SYSREQ) scan code if the user tries to do so with StickeyKeys.
;
; This routine is also used to inject StickeyKeys modifier break codes.
; This routine should never be called if the computer type is determined not capable of 
; handling scan codes injected into the hardware buffer.  Currently, the only computers
; which support hardware injections are PS/1 and all PS/2 except the 25/30-86 models.
;
; Expects 	al=code to inject


InjectKeys	proc

	assume	DS:_TEXT

;	push	cx				; DO NOT need to save any registers, called from inside timer int. only..
	mov	cx,995				; approx. 15msec/15.086*10-6/sec

IK_5:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; wait till we are allowed to write to port
	jz	IK_8				; yes buffers are empty, okay to do inject so far


	in	al,kb_ctl			; buffer not empty, check time
	and	al,10h				; mask to check refresh bit = 10h
	cmp	al,ah				; did it change? or first time thru
	jz	short IK_5    			; no wait for change, else cont.
	mov	ah,al
	loop	IK_5	      			; have we timed out ?
	jmp	short IK_20			; can't write this time thru, exit inject 

IK_8:
	mov	cx,995				; approx. 15msec/15.086*10-6/sec
	mov	al,0d2h				; code to tell keyboard output buffer that next byte
	out	status_port,al			; written is to I/O address hex 060 (kb_data) 	
IK_10:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; wait till we are allowed to write to port
	jz	IK_15				; yes buffers are empty, okay to do inject so far

	in	al,kb_ctl			; buffer not empty, check time
	and	al,10h				; mask to check refresh bit = 10h
	cmp	al,ah				; did it change? or first time thru
	jz	short IK_10    			; no wait for change, else cont.
	mov	ah,al
	loop	IK_10	      			; have we timed out ?
	jmp	short IK_20			; can't write this time thru, exit inject 

IK_15:
	call	Get_Key_Data		       	; ax has the data upon return
	out	kb_data,al			; send our char. which will generate an int. as if sent by kybd.

;IFDEF	BUG
;;	mov	fserial_debugging,true
;	mov	portid,06
;	mov	portout,al
;	call	HexCharsOut
;;	mov	fserial_debugging,false
;ENDIF;	BUG

	mov	floop_back,true			; flag that we sent a byte
IK_20:
;	pop	cx				; clean up stack
	ret

InjectKeys	endp

;----------------DEBUGGING------------------------------------------------
;
;Inject_Mouse_Low	proc
;
;	assume	DS:_TEXT
;	call	click	       
;	mov	cx,995				; approx. 15msec/15.086*10-6/sec
;
;IKM_5:
;
;	in	al,status_port			; read keyboard status port
;	test	al,inpt_buf_full		; wait till we are allowed to write to port
;	jz	IKM_8				; yes buffers are empty, okay to do inject so far
;
;
;	in	al,kb_ctl			; buffer not empty, check time
;	and	al,10h				; mask to check refresh bit = 10h
;	cmp	al,ah				; did it change? or first time thru
;	jz	short IKM_5    			; no wait for change, else cont.
;	mov	ah,al
;	loop	IKM_5	      			; have we timed out ?
;	jmp	short IKM_20			; can't write this time thru, exit inject 
;
;IKM_8:
;	mov	cx,995				; approx. 15msec/15.086*10-6/sec
;	mov	al,0d3h				; code to tell mouse output buffer that next byte
;	out	status_port,al			; written is to I/O address hex 060 (kb_data) 	
;IKM_10:
;
;	in	al,status_port			; read keyboard status port
;	test	al,inpt_buf_full		; wait till we are allowed to write to port
;	jz	IKM_15				; yes buffers are empty, okay to do inject so far
;
;	in	al,kb_ctl			; buffer not empty, check time
;	and	al,10h				; mask to check refresh bit = 10h
;	cmp	al,ah				; did it change? or first time thru
;	jz	short IKM_10    			; no wait for change, else cont.
;	mov	ah,al
;	loop	IKM_10	      			; have we timed out ?
;	jmp	short IKM_20			; can't write this time thru, exit inject 
;
;IKM_15:
;	call	Get_Mouse_Data		 	; ax has the data upon return
;	out	kb_data,al			; send our char. which will generate an int. as if sent by kybd.
;
;IKM_20:
;	ret
;
;Inject_Mouse_Low	endp
;----------------DEBUGGING------------------------------------------------

;----------------------------------------------------------------------------
; 
; kybd_echo
; 
; This routine is used on computers which DO NOT support hardware injection of scan codes but
; do support int 15h, to cause an int9h to occur, such that when int15 is called, we can trap for
; it and inject our scan code.  For IBM's, we will do this by using an undocumented call to 8042, which will
; cause it to do an interrupt with our data loaded into port 60h.  For non IBM's, we will write to status port
; which caused the 8042 to return a byte, which we then trapped.

kybd_echo	proc

	assume	DS:_TEXT

	cmp	_comp_id,5Ah			; is this an IBM product (Old AT, AT239, AT339)?
	je	kybd_echo_10			; if yes, do 2nd half of kybd_echo
						; if not, do the first half
 	cmp	_comp_id,2			; is this a New XT (1/10-5/9/86) running 
	je	kybd_echo_10			; if yes, do 2nd half of kybd_echo

;----------------------------------------------------------

kybd_echo_5:

	xor	cx,cx				; zero cx

kybd_echo_5A:

	in	al,status_port			; read keyboard status port
	test	al,both_buf_full		; check to be sure we can write to the port
	jz	kybd_echo_6
	loop	kybd_echo_5A
	jmp	short kybd_echo_8		; if cannot write this time, exit out


kybd_echo_6:

	mov	al,020h
	out	status_port,al			; a write to the keyboard status port (ctrl port) generates an interrupt

; if succesful in generating an interrupt, set a flag for myself to watch for when int 9 calls int 15h

	mov	fint9_by_timer,true 		; set flag so I know when int 9 occur, to disregard
				    		; the scan code int 9 has, and to read the key_data_buffer
				    		; for the scan code I want to insert
kybd_echo_8:

	jmp	kybd_echo_end			; exit

;----------------------------------------------------------

kybd_echo_10:

;	push	cx
	xor	cx,cx				; zero cx

kybd_echo_10A:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; check to be sure we can we can write buffer
	jz	kybd_echo_15
	loop	kybd_echo_10A
	jmp	kybd_echo_end			; if can't write this time, exit

kybd_echo_15:

	mov	al,7fh				; write command for 8042
	out	status_port,al			; write to port 64h
	jmp	$+2				; delay
	xor	cx,cx				; reset cx to 0

kybd_echo_20:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; check to be sure we can we can write buffer
	jz	kybd_echo_25
	loop	kybd_echo_20
	jmp	short kybd_echo_end		; if can't write this time, exit

kybd_echo_25:

	call	Get_Key_Data		       	; ax has the data upon return
	mov	floop_back,true			; flag to be sure we get our keystroke on the way back thru int 15h

	out	kb_data,al			; write "al"register to port 60h
	jmp	$+2				; delay
	xor	cx,cx				; reset cx to 0
	
kybd_echo_30:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; check to be sure we can we can write buffer
	jz	kybd_echo_35
	loop	kybd_echo_30
	jmp	short kybd_echo_end		; if can't write this time, exit

kybd_echo_35:

	mov	al,3fh				; read command to 8042
	out	status_port,al			; write to port 64h
	jmp	$+2				; delay
	xor	cx,cx				; reset cx to 0

kybd_echo_40:

	in	al,status_port			; read keyboard status port
	test	al,inpt_buf_full		; check to be sure input buffer empties
	jz	kybd_echo_45
	loop	kybd_echo_40
	jmp	short kybd_echo_end		; if can't write this time, exit

kybd_echo_45:

	xor	cx,cx				; reset cx to 0

kybd_echo_50:

	in	al,status_port			; read keyboard status port
	test	al,out_buf_full			; check to be sure output buffer filled
	jnz	kybd_echo_end
	loop	kybd_echo_50			; wait till not zero, (i.e. buffer is filled)

;	pop	cx				; clean up stack

kybd_echo_end:

	ret

kybd_echo	endp


;----------------------------------------------------------------------------
;	Put_Key_Data
; 
; This procedure loads keyboard key data into a buffer where the timer will later
; retrieve it and send it to the InjectKeys.  
;
; Key scan codes may be retrieved by computers which support int 15h also.  If they 
; do, the fbios_called_timer flag will be set.
;
;	Expects   Ax= keyboard data to be stored, order is
;			
;		  ah = 0
;		  al = hidden code and scan code if called twice, scan code if called once 

Put_Key_Data	proc

	assume	DS:_TEXT

	push	bx				; temp store of bx register
	push	si				; temp store of si register

	mov	bx,key_data_tail		; get tail pointer of key_data buffer
	mov	si,bx				; save pointer value
	add	bx,2				; move to next word address in buffer
	cmp	bx,OFFSET key_data_end		; are we at the end of the buffer ?
	jne	PKD_5				; no
	mov	bx,OFFSET key_data		; yes we are, so reset to the buffer beginning

PKD_5:
	cmp	bx,key_data_head		; has the buffer wrapped around ?
	jne	PKD_10

; if equal, buffer is full, beep high to inform user, and exit

	jmp	Put_Key_Data_End		; if full, error beep and leave routine

PKD_10:
	mov	[si],ax				; move whats in ax into address pointed to by si
	mov	key_data_tail,bx		; update tail pointer

Put_Key_Data_End:

	pop	si
	pop	bx
	ret

Put_Key_Data	endp

;----------------------------------------------------------------------------
;	Get_Key_Data
; 
; This procedure retrieves keyboard keystroke info. from a buffer for the timer 
; to send it to InjectKeys or for int15h to retrieve.
;
;	Returns   ax = keyboard keystroke data stored
;
;		  ah = 0
;		  al = hidden code and scan code if called twice, scan code if called once 


Get_Key_Data	proc

	assume	DS:_TEXT

	push	bx				; temp store of bx register

	mov	bx,key_data_head		; get head pointer of key_data buffer
	cmp	bx,key_data_tail		; test to see if head = tail, i.e. no data to send
	je	Get_Key_Data_End

	mov	ax,[bx]				; move whats in address pointed to by bx into ax
	add	bx,2				; move to next word in list
	cmp	bx,OFFSET key_data_end		; are we at the end of the buffer
	jne	GKD_5				; no, then we are done, except update the pointer
	mov	bx,OFFSET key_data		; if yes, then reset to the beginning of the buffer
GKD_5:
	mov	key_data_head,bx   		; move the head pointer to the start also

Get_Key_Data_End:

	pop	bx
	ret

Get_Key_Data	endp

;----------------------------------------------------------------------------
; beep
;
; Expects:	bx = length (number of cycles)
;		cx = tone (length of cycle)
;
; Changes:	bx

beep	proc

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	ax			; save ax
	IN	al,kb_ctl		; get keyboard control

	push	ax			; save
	push	cx			; save cx=wave length
b_1:	
	and	al,0fch			; set speaker bits
	OUT	kb_ctl,al		; send out to speaker
	pop	cx			; get cx=wave length
	push	cx			; save cx
b_2:	
	loop	b_2			; keep on for wave length of time
	cmp	fsilent_click,true	; should this be a silent click
	je	b_2A
	or	al,2			; set speaker bit
	jmp	short b_2B
b_2A:
	or	al,0			; NO SOUND 
b_2B:
	OUT	kb_ctl,al		; send out to speaker
	pop	cx			; get cx
	push	cx			; save cx
b_3:	
	loop	b_3			; keep off for wave length of time
	dec	bx			; decrement length of tone
	jnz	b_1			; loop if not zero

	pop	cx			; restore cx
	pop	ax			; get old keyboard control
	OUT	kb_ctl,al		; send out
	pop	ax			; restore old ax

	pop	ds

	ret
beep	endp

;----------------------------------------------------------------------------
; beep_high
; beep_low
; beep_turn_on
; beep_turn_off
; no_beep
; click
;
; The following routines provide the sound feedback.
;
; Expects:	Nothing
;
; Changes:	Nothing
;


beep_high	proc	

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	bx,high_tone_len	; give low tone
	mov	cx,high_tone
beep_high_20:
	call	beep
	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
beep_high	endp



beep_low	proc	

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	bx,low_tone_len		; give low tone
	mov	cx,low_tone
	call	beep
	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
beep_low	endp



no_beep		proc	

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	bx,no_tone_len		; give no tone
	mov	cx,no_tone
no_beep_20:
	call	beep
	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
no_beep		endp

;--------------------------------------------------------------	

beep_turn_on	proc	

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	cx,turn_on_start_beep	; low frequency
bon_20:	
	mov	bx,02h
	call	beep
	sub	cx,on_off_change	; rate of change
	cmp	cx,turn_off_start_beep	; high frequency
	jg	bon_20

	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
beep_turn_on	endp
;---------------------------------------------------------------
	
beep_turn_off	proc   

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	cx,turn_off_start_beep	; high frequency
bof_20:	
	mov	bx,02h
	call	beep
	add	cx,on_off_change	; rate of change
	cmp	cx,turn_on_start_beep	; low frequency
	jl	bof_20

	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
beep_turn_off	endp

;----------------------------------------------------------------------------

click 	proc

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	push	cx			; save registers
	push	bx
	mov	bx,click_tone_len      	; give click tone
	mov	cx,click_tone
	call	beep
	mov	fsilent_click,false	; reset to clear for PC or XT
	pop	bx			; restore registers
	pop	cx

	pop	ds
;	assume	DS:NOTHING

	ret
click	endp

;----------------------------------------------------------------------------
;	Get_Mouse_Data
; 
; This procedure retrieves mouse button info. from a buffer for the timer 
; to send it to the appropriate mouse input mechanism.
;
;	Returns   Ax= mouse data stored
;
;		  1st Mouse_Status
;		  2nd Delta_X
;		  3rd Delta_Y

Get_Mouse_Data	proc

	assume	DS:_TEXT

	push	bx				; temp store of bx register

	mov	bx,mouse_data_head		; get head pointer of mouse_data buffer
	cmp	bx,mouse_data_tail		; test to see if head = tail, i.e. no data to send
	je	Get_Mouse_Data_End

	mov	ax,[bx]				; move whats in address pointed to by bx into ax
	dec	mouse_cnt			; derease counter since we took a word out of the buffer

	add	bx,2				; move to next word in list
	cmp	bx,OFFSET mouse_data_end	; are we at the end of the buffer
	jne	GMD_5				; no, then we are done, except update the pointer
	mov	bx,OFFSET mouse_data		; if yes, then reset to the beginning of the buffer
GMD_5:
	mov	mouse_data_head,bx   		; move the head pointer to the start also

Get_Mouse_Data_End:

	pop	bx
	ret

Get_Mouse_Data	endp

;---------------------------------------------------------------------------
; _int2f
;
; We hook int2fh, to monitor if Windows is ever loaded after Access Dos is already 
; loaded.  To test, we will abort Enhanced loading and put up a message.
; AccessDOS version 1.1 allows enhanced mode windows.


_int2f	proc	far

	cmp	ax,01605h				; watch for Windows to load after us
	jne	int2f_50				; this is what Windows broadcasts when it loads

	push	dx
	and	dx,001h					; mask off bit 0
	cmp	dx,0					; is this Windows 3 in enhanced mode ?
	pop	dx   
	jne	int2f_45				; if not, exit to next int 2fh handler

; If we find enhanced mode, flag it accordingly instead of aborting as AccessDOS v1.00 did
;
;	mov	cx,1					; return cx=1, will cause windows to abort
;	pop	dx					; 
;	jmp	int2f_100

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	mov	fwindows_after,true			; general flag for Windows standard mode loading after ADOS
	mov	fwindows_enh,true			; flag that we are in Windows enhanced mode

	push	ax
	mov	al,fhearing_on				; save state of hearing impaired flag(s)
	mov	fhearing_on_save,al
	mov	fhearing_on,false
	mov	al,fvideo_flash				; ""
	mov	fvideo_flash_save,al
	mov	fvideo_flash,false
	pop	ax
	jmp	int2f_90


int2f_45:

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	mov	fwindows_after,true			; general flag for Windows standard mode loading after ADOS
	mov	fwindows_after_st,true			; flag that Windows stand. mode is starting after ADOS

	push	ax
	mov	al,fhearing_on				; save state of hearing impaired flag(s)
	mov	fhearing_on_save,al
	mov	fhearing_on,false
	mov	al,fvideo_flash				; ""
	mov	fvideo_flash_save,al
	mov	fvideo_flash,false
	pop	ax

;	call	serialKeysDisableFar

	jmp	int2f_90

int2f_50:

	cmp	ax,01606h				; watch for Windows to unload after us
	jne	int2f_75				; this is what Windows broadcasts when it unloads
 
; right now don't need to check if unloading from enhanced or stand./real  -- change for 1.1

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

;;	cmp	fwindows_after_st,true			; this would have been set true by a successful Windows loading
;;	je	int2f_70				; if not, operator tried enhanced windows, so give error messasge
;;
;;	print	mesg43					; print message to abort
;;	print	mesg44					; instruct user to try Windows in Real/Standard Mode

int2f_70:
; reset flags upon exit

	mov	fwindows_after,false			; general flag for Windows real mode running after ADOS
	mov	fwindows_after_st,false			; flag that Windows stand. mode is running after ADOS
	mov	fwindows_enh,false
	mov	video_count,07fh			; reset such that it will take 5 seconds to start video 

	push	ax
	mov	al,fhearing_on_save			; restore upon exit
	mov	fhearing_on,al
	mov	al,fvideo_flash_save
	mov	fvideo_flash,al
	pop	ax

;	cmp	fserial_keys_loaded,true		; is serial keys loaded ?
;	jne	int2f_72
;	cmp	_serialKeysOn,true			; is SerialKeys code on ?
;	jne	int2f_72
;
;	call	_serialKeysEnableFar
;	call	_initCommPort				; reset 
;	call	_serialKeysStartupInit			; clear serialkeys buffers

int2f_72:

	jmp	short int2f_90


int2f_75:

	cmp	ax,01684h				; watch for Windows to load after us
	jne	int2f_80				; this is what Windows broadcasts when it loads Real Mode
							; NOTE, Windows doesn't broadcast REAL mode exit of 01606h !@!

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	mov	fwindows_after,true			; general flag for Windows loading after ADOS
	mov	fwindows_after_re,true			; flag that Windows real mode is starting after ADOS

	push	ax
	mov	al,fhearing_on				; save state of hearing impaired flag(s)
	mov	fhearing_on_save,al
	mov	fhearing_on,false
	mov	al,fvideo_flash				; ""
	mov	fvideo_flash_save,al
	mov	fvideo_flash,false
	pop	ax
							; and no way to tell when we exit, use timer to find out if we exitted
;	call	_serialKeysDisableFar

	mov	video_count,07fh			; reset such that it will take 5 seconds to start video 
	jmp	short int2f_90

								   
int2f_80:

	cmp	ax,04680h				; watch for Windows 3.0 to DOS box
	je	int2f_85

	cmp	ax,04810h				; watch for Windows 3.1 to DOS box
	jne	int2f_100

int2f_85:

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	cmp	fwindows_after_st,true			; are we DOS boxing after Windows standard was started ?
	jne	int2f_86 
	jmp	short int2f_88

int2f_86:
	cmp	fwindows_enh,true			; are we DOS boxing after Windows enhanced mode was started ?
	jne	int2f_87 
;	jmp	short int2f_88
	jmp	short int2f_90				; if running in enhanced mode, allow Access Utility SerialKeys
							; to run as is, do not attempt tp take back the port in a DOS box
int2f_87:
	cmp	fwindows_after_re,true			; are we DOS boxing after Windows real was started ?
	jne	int2f_90				; if not, exit as some one is asking if Windows is loaded
int2f_88:

;	call	click					; DEBUGGING
	cmp	fserial_keys_loaded,true		; is serial keys loaded ?
	jne	int2f_90

	cmp	_skWindowCompatible,true
	je	int2f_89

	cmp	_serialKeysOn,true			; is SerialKeys code on ?
	jne	int2f_90

int2f_89:

	cmp	_serialKeysOn,true
	je	int2f_90

	call	_serialKeysEnableFar
;	call	_initCommPort				; reset 
;;	call	_serialKeysStartupInit			; clear serialkeys buffers

int2f_90:

	pop	ds
	assume	DS:NOTHING

int2f_100:

	jmp	dword ptr cs:old_2f_int	    		; jump to original interrupt 2fh handler

_int2f	endp

;---------------------------------------------------------------------------
; _int71/74
; 
; All we are doing is hooking the input of the mouse to be able to reset the 
; StickeyKeys count (key_cnt) if we get real mouse activity.  Turns out for the the PS/2 Model
; 25..30/86, the keyboard int9h, is shared by the keyboard and the pointing device.  Therefore,
; we don't necessarily know if the interrupt was generated by the mouse or the keyboard, unless
; we do some further investigation.  After looking at the new PS/2 BIOS, (or what DOS adds to it)the 
; original keybd. int. has a pre-amble attached which decifers whether or not the interrupt was a 
; keystroke or the pointing device.  After review, I decided to set my own flag, such that if the 
; keyboard int 9h routine is called by the original int ? device(mouse or keyboard), then I will 
; not reset the key_cnt variable of StickeyKeys, since it was not mouse activity.
;

_intps2mou	proc
		  
	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	mov	fmouse_or_kybd,false 			; set flag to false at entry

	pushf
	call	dword ptr cs:old_ps2mou_int	    	; call original interrupt 71 or 74h

	cmp	fmouse_or_kybd,false			; if keybd int 9h. was called, this would have been set true
	jne	_intps2mou_25				; if false, then it was mouse activity, and we need to reset key_cnt
	mov	key_cnt,false

_intps2mou_25:

	pop	ds
	assume	DS:NOTHING

	iret

_intps2mou	endp


;---------------------------------------------------------------------------
; sub_int33 
;
;	If this suroutine is called, it's because an application passed the mouse driver
; a new address to send data when ever the mouse int. occurs.  If this is called, we are really only 
; interested in maintaining the button status connection between MouseKeys and the real mouse.
;
; This routine is called with ax=mask=bit1=left but. pressed, bit2=left button released
; bit3=right button pressed, bit4=right button released

sub_int33	proc	far

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

; if this routine gets called, then there was mouse activity, a mouse int. was generated, so reset StickeyKey count

	mov	key_cnt,0				; reset key_cnt to 0
	cmp	fMouseKeysOn,true			; check to see if MouseKeys is even On ?
	je	sub_int33_2
	jmp  	sub_int33_65
  
sub_int33_2:

	cmp	fmouse_button,true			; using a MouseKeys button ?
	je	sub_int33_4				; if yes, then the int. was initiated by kybd, follow thru

; If not a MouseKeys int. (i.e. from the kybd), then the real mouse was moved or a real mouse button was pushed while
; MouseKeys is on, so if we want to allow the MouseKeys mouse button to override the real mouse button, then we better
; check that they agree, and if not, alter the real mouse button info accordingly. 


	cmp	fbutton_down,true			; is the MouseKeys button down ???
	jne	sub_int33_3A				; if no, MouseKeys button is down, then don't need to compare status'

;********************************************************************************************************************************
; REAL MOUSE HANDLING
;
; Real mouse input while the MouseKeys mouse button is being held down, so we must act on it
; If we see that the REAL mouse depresses a button, we will assume it is a mouse capable users, 
; and reset allow the real mouse to release the depressed MouseKeys button.  However, do not
; let only button up information reset the MouseKeys mouse button so check to see if the real 
; mouse is sending any mouse button up info ??(ax=0001 0100 ?)
;
; ax = mask passed back to application from mouse driver to inform application why mouse driver is sending data
;
; mouse moved           ax = 0000 0001 (01h)
; mouse r/l button down ax = 0000 1010 (0Ah)
; mouse r/l button up	ax = 0001 0100 (14h)
;
;********************************************************************************************************************************

	push	bx
	push	ax

; check if button down info

	mov	bx,ax					; get button info into ax
	and	ax,0ah					; mask ax for either right/left/both buttons down
	jz	sub_int33_2A				; if zero, then there was not any button pressed down
	pop	ax

	mov	fbutton_down,false			; reset MouseKeys button down flag
	mov	Button_Status,0				; reset since we let MouseKeys mouse button up

	cmp	_fmouse_id,4				; check if a PS/2 mouse ?
	jne	sub_int33_2B
	mov	Mouse_Status,08h			; reset Mouse_Status to button up also for PS2 mouse
	jmp	short sub_int33_3			; exit

sub_int33_2B:
	mov	Mouse_Status,040h			; reset Mouse_Status to button up also for serial mouse
	jmp	short sub_int33_3			; exit

sub_int33_2A:

	mov	ax,bx					; get button info into ax
	and	ax,014h					; mask ax for either right/left/both buttons up
	pop	ax					; pop has no affect on the flags status
	jz	sub_int33_3				; if zero, there was no button release info, so pass along as is

; If we get here, then we have Real mouse button up info, and we want to suppress it
; Some applications need to see mouse button dowm to remain in sync, so we will try to fool them also


	xor	ax,ax					; zero ax mask, causing real mouse info to not pass on the fact that real mouse 
							; button is actually up, since we want MouseKeys mouse button to override
	mov	ax,01					; first bit is set in real codes
;	shr	bx,1					; move whatever up mask bit right 1 bit to a down mask bit
;	or	ax,bx					; logical -or- them to ax, so it looks like mouse button is down


sub_int33_3:
	pop	bx

sub_int33_3A:

	jmp	sub_int33_50				; we can exit

;************************************************************************************************************************************

sub_int33_4:

; if we get a MouseKeys button_up key, we want to EAT the down portion of the button_click
; and not pass that along to the application.  Remember, we added the button_click to a standard
; button_up to fool the mouse driver for those occassions when the user operates both MouseKeys
; and the real mouse

	cmp	fbutton_up,true				; did we have a button up ?
	jne	sub_int33_50
	mov	bx,0					; clear button down mask before the application gets it
	xor	ax,ax					; clear ax
	mov	ax,14h					; mask to release both buttons
	mov	fbutton_up,false			; reset flag to false since we ate the button down code as designed

sub_int33_50:

	push	ax
	mov	ax,mouse_data_head			; get head pointer of mouse_data buffer
	cmp	ax,mouse_data_tail			; test to see if head = tail, i.e. no data to send
	jne	sub_int33_60			   	; if not equal, data in mouse_data buffer, so don't reset this flag yet
	mov	fmouse_button,false			; after we have sent the ALL THE mouse info, reset this flag

sub_int33_60:
	pop	ax

sub_int33_65:

	call	dword ptr cs:sub_int33_ptr

	pop	ds
	assume	ds:NOTHING
	ret

sub_int33	endp

;----------------------------------------------------------------------------
; int33h hook
; 
; Hooked int33h in an attempt to watch mouse activity and to keep mousekeys in 
; sync with real mouse activity, i.e. if mousekeys locks a button down, movement 
; real mouse will alter this, so if we monitor for this condition, we can correct
; or keep the two mice in sync
;----------------------------------------------------------------------------

PUBLIC	_int33

_int33	proc

	push	ds					; save registers used

	push	cs
	pop	ds
	assume DS:_TEXT

	cmp	fmousetrapping,false			; is mouse address hooking allowed
	je	i33_2
	jmp	i33_A_50  				; if not,call original int 33h

i33_2:
;-------------
; AX=0 or 33 decimal (21h)
;-------------
	cmp	ax,0					; did we get a call to mouse reset and status
	je	i33_3
	cmp	ax,21h					; did we do a software reset ?, if so, only clear mask
	je	i33_4
	jmp	short i33_5

i33_3:
	mov	sub_int33_ptr_off,0
	mov	sub_int33_ptr_seg,0
i33_4:
	mov	call_mask,0				; reset call mask with 0 or 21h calls
	jmp	i33_A_50

;-------------
; AX= 12 decimal (0Ch) or 20 decimal (14h)
;-------------
;
; If we get here, someone is using int 33 vector with function 12 decimal, which will be
; passed an address for the mouse driver to send mouse data when a mouse int. occurs, based 
; upon a mouse mask which gets set.  We have to trap for this address, if we want to monitor
; what the real mouse might be doing, to keep it in sync with MouseKeys.  This situation occurs
; for example, if MouseKeys has a mouse button down, and then I move the real mouse, normally the 
; real mouse movement would cancel the mouse button down of MouseKeys, and we didn't want it to.
; Therefore, we need to be able to trap such conditions, and alter them to the desired condition, 
; before the application actually gets the mouse info.

i33_5:

	cmp	ax,0Ch					; is int 33h being called with ax=12, i.e. reseting an address
	je	i33_5_A
	cmp	ax,014h
	je	i33_5_A
	jmp	short i33_8

i33_5_A:
	mov	call_mask,cx
	
i33_5_D:

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

	push	es
	push	ax
	push	bx
	push	cx
	push	dx

	mov	ax,cs
	mov	bx,ax
	mov	es,ax
assume es:_TEXT
	mov	dx,OFFSET sub_int33			; our routine that gets executed if an application repoints the 
							; now int 33h, called with ax=12, will load our sub_int33h address 
							; as es:dx instead of the application's es:dx
	mov	cx,call_mask
	mov	ax,0014h				; call to swap int. routines

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

i33_5_G:
	mov	word ptr [sub_int33_ptr_off],dx 	; save address our call returned as new sub_int33_ptr
	mov	word ptr [sub_int33_ptr_seg],es	 	

	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
assume es:nothing

	jmp	i33_B_50


;-------------
; AX=22 decimal (16h)
;-------------
; If we get here, application is exitting for some reason, and wants to save the state of the mouse.
; We need to put back the address the application may have originally passed to the mouse driver, to 
; tell the mouse driver where to send data, so when the application resatarts, we will have an address
; we can use to rehook ourselves.

i33_8:

	cmp	ax,016h
	je	i33_8_A
	jmp	short i33_10

i33_8_A:

	push	es
	push	ax
	push	bx
	push	cx
	push	dx

	mov	dx,word ptr [sub_int33_ptr_off]
	mov	es,word ptr [sub_int33_ptr_seg]
	mov	bx,es
	mov	cx,call_mask
	mov	ax,0014h				; call to swap int. routines

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es

	jmp	i33_3

;------------------------------------
; AX = 23 decimal (17h) 
;------------------------------------

i33_10:
	cmp	ax,017h
	je	i33_10_A
	jmp	short i33_A_50

i33_10_A:

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

	push	es
	push	ax
	push	bx
	push	cx
	push	dx

	mov	ax,cs
	mov	bx,ax
	mov	es,ax
assume es:_TEXT
	mov	dx,OFFSET sub_int33			; our routine that gets executed if an application repoints the 
							; now int 33h, called with ax=12, will load our sub_int33h address 
							; as es:dx instead of the application's es:dx
	mov	cx,01fh
	mov	ax,0014h				; call to swap int. routines

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

; check call_mask returned, to see if this is an active mouse application

	cmp	cx,0   
	jne	i33_10_G

; we did get back a zero for call_mask
; so call back with ax = 0014h, es:dx are the address we received
; leave CX alone, as we want to pass back the original call_mask

	mov	ax,0014h				; call to swap int. routines
	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h	

	mov	ax,0
	mov	cx,ax					; to rezero call mask coming up if was zero
;	mov	es,ax
;	mov	dx,ax					; clear our sub_int33_ptr upon return

i33_10_G:

	mov	call_mask,cx				; get new call mask
	mov	word ptr [sub_int33_ptr_off],dx 	; save address our call returned as new sub_int33_ptr
	mov	word ptr [sub_int33_ptr_seg],es	 	

	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	es
assume es:nothing

	jmp	short i33_B_50

;-----------------------------------------------

i33_A_50:

	pushf
	call	dword ptr cs:old_33_int			; call original interrupt 33h

;-----------------------------------------------

i33_B_50:

; at this point, we don't know if this is a MouseKeys or real mouse entry, using int. 33 or polled, so we need to 
; check if button status or x,y coordinate info was requested, so we can decide if we should reset key_cnt of 
; StickeyKeys.

	cmp	ax,03					; request for button status and mouse postion ?
	je	i33_26A
	jmp	i33_50

; is requesting mouse button or movement info, unfortunately, this may be a polled mouse, which would do this
; request several times each second, even if no mouse activity occurred, or this may be from an int. mouse
; which didn' use int.33 to repoint the mouse vector like seen in sub_int33 routine, so we have to check if any mouse
; data is being returned, before we can judge to reset the key_cnt variable of StickeyKeys
; Not setting mouse_x/y_temp first time thru, so may miss a StickeyKeys count, but unlikely, since polling is so fast

i33_26A:
	cmp	bx,0					; if bx=0, the mouse button(s) is/are up
	jne	i33_26B					; if not zero, then we had mouse button activity, so reset key_cnt

	cmp	mouse_x_temp,cl				; did mouse x data change from last poll ??
	jne	i33_26B					

	cmp	mouse_y_temp,dl				; did mouse y data change from last poll ??
	je	i33_27					; no change, so jump to cont

i33_26B:
	mov	mouse_x_temp,cl				; update mouse_x_temp position	
	mov	mouse_y_temp,dl				; update mouse_y_temp position
	mov	key_cnt,0				; reset key_cnt to 0


i33_27:
; now we can continue as normal, by first checking to see if MouseKeys is even on ???

	cmp	fMouseKeysOn,true
	je	int33_27
	jmp	i33_50

int33_27:

;; Okay, MouseKeys is On and Int33h, requested button info.  Is there a MouseKeys keys down???
;

	cmp	fbutton_up,true				; did we have a button up ?
	jne	int33_27B
	mov	bx,0					; clear the extra button down mask that MouseKeys sends, before the 
							; application gets it

	mov	fbutton_up,false			; reset flag to false since we ate the button down code as designed
	jmp	i33_50					; then jump around all this checking

int33_27B:

; if no MouseKeys keys are currently down, look out for real mouse info, if get any real mouse info, and we want to 
; keep the MouseKeys mouse button down if it was down, then we must alter the real mouse button info if it tries to
; let the mouse buttons up

	cmp	fbutton_down,true			; is the MouseKeys button down ???
	je	int33_28				; if yes, then a MouseKeys button is down, and we need to check on REAL mouse status
	jmp	i33_50					; if not, jump around all this checking

int33_28:

;********************************************************************************************************************************
; REAL MOUSE HANDLING
;
; Real mouse input while the MouseKeys mouse button is being held down, so we must act on it
; If the REAL mouse button is pushed, allow it to release the MouseKeys mouse button.
; Problem with a "polled" mouse routine, is that it constantly asks for mouse status updates, and MouseKeys
; buttons are one time things.  If this routine gets asked for mouse status info, we have no way of
; knowing if it is MouseKeys mouse button down, or REAL mouse buttons down, since the asking is continous
; which is alot different than asking only when an action occurs (interrupt driven) as in the 
; mouse routines above which handle the interrupt driven mouse.  We can figure one thing out however,
; and that is that we should never see mouse button up information, as long as the fbutton_down flag
; is set within MouseKeys, unless the REAL mouse sent it.  

; Next check to see if the real mouse is sending any mouse button up info ??(bx=0000 0000 ?)
; We could get REAL mouse button up info. from moving the REAL mouse or from clicking the REAL mouse button ?
; Problem is, we want to override a button up if it was from moving, and allow a button up if it was a click

	cmp	bx,0					; if zero, real mouse is sending all buttons are up info.
	jz	int33_29				; if zero, there is button up info, so we must alter
	jmp	i33_50					; if not, jump around all this checking

int33_29:
	
; If we get here, then we have Real mouse button up info, and we want to suppress it, so we have to check and see what
; MouseKeys mouse button is down, and echo this condition

	cmp	_fmouse_id,4				; check if a PS/2 mouse ?
	jne	int33_37

;-------------------------------------------------------------------------------------------------
; PS/2 Mouse

	push	ax					; temp store
	mov	ax,Mouse_Status
	and	al,03h					; mask off lowest bits
	cmp	al,01					; is the left MouseKeys button down ?
	jne	int33_30
	xor	bx,bx					; clear what ever was in bx
	or	bx,01h					; or the left button pressed in bx mask
	pop	ax
	jmp	i33_50	  				; exit to normal address called

int33_30:
	cmp	al,02h
	jne	int33_32
	xor	bx,bx					; clear what ever was in bx
	or	bx,02h					; or the right button pressed
	pop	ax
	jmp	i33_50

int33_32:

	cmp	al,03h
	jne	int33_34				; if we do this jump, no buttons were down
	xor	bx,bx					; clear what ever was in bx
	or	bx,03h					; or both the left and right buttons pressed
	pop	ax
	jmp	i33_50

int33_34:
	pop	ax
	jmp	i33_50					; if we already called int33h, jump around doing it again
;----------------------------------------------------------------------------------------------------------------------------
; serial mouse

int33_37:

	cmp	_fmouse_id,2				; check if a serial mouse ?
	jne	i33_50

	push	ax					; temp store
	mov	ax,Mouse_Status
	and	al,030h					; mask off high byte low bits
	cmp	al,00h					; any MouseKeys buttons down
	je	int33_44				; no
	cmp	al,020h
	jne	int33_40
	xor	bx,bx					; clear what ever was in bx
	or	bx,01h					; or the left button pressed in bx mask
	pop	ax
	jmp	i33_50					; exit to normal address called

int33_40:
	cmp	al,010h
	jne	int33_42
	xor	bx,bx					; clear what ever was in bx
	or	bx,02h					; or the right button pressed
	pop	ax
	jmp	i33_50

int33_42:

	cmp	al,030h
	jne	int33_44				; if we do this jump, we had an error ?
	xor	bx,bx					; clear what ever was in bx
	or	bx,03h					; or both the left and right buttons pressed
	pop	ax
	jmp	i33_50

int33_44:
	pop	ax

i33_50:

	pop	ds
	assume	DS:NOTHING

	iret

_int33	endp
									    
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
; new_timer_int 
;
; Calls various procedures to handle time dependent function of the different
; features.  Also calls the original timer 1Ch interrupt

_new_timer_int	proc

	push	ds					; save registers used
	push	es
	push	si
	push	di
	push	dx
	push	cx
	push	bx
	push	ax

	push	cs
	pop	ds
	assume DS:_TEXT
	push	cs
	pop	es
	assume ES:_TEXT

;	cmp	ftimer_1C_active,true 			; check to see if we got re-interrupted ?
;	jne	NT_5
;	call	click
;	jmp	NT_END_5
;NT_5:

	mov	ftimer_1C_active,true

; TimeOut_timer is currently called from the Togglekeys_timer routine and seems to work there ????

	call	FilterKeys_timer			; service FilterKeys
	call	ToggleKeys_timer			; service ToggleKeys

	cmp	fMouseKeysOn,true			; is MouseKeys On, if not don't call MouseKey_timer
	jne	NT_8					; if MouseKeys is Off, make sure buffer got emptied on turn off

	call	MouseKeys_timer				; yes, so call the timer

NT_8:

	mov	bx,mouse_data_head			; get head pointer of mouse_data buffer
	cmp	bx,mouse_data_tail			; test to see if head = tail, i.e. no data to send
	jne	NT_10					; if not equal, we have mouse data in the buffer
	jmp	NT_105 					; nothing to send from mouse buffer so jump to here

;---------------------------------------------------------------------------------------------
; if not equal, we have mouse_data to send, after we call, ax will have the data to send
; at this point, we should also disable the real mouse from int. and messing up mousekey 
; data from the buffer.  Quick and dirty way to do this would be to force the mouse clock
; line low, so the mouse would think that the host computer is inhibiting, but we have a serial
; mouse here, not the PS/2 mouse.   Since we again are not inside the mouse driver, we have
; a problem of knowing when it is safe to disable the real mouse (serial this time), since we
; have no way of knowing which data byte might currently be being sent. (i.e. 1st, 2nd or 
; 3rd)  Therefore, we can not truely disable the real mouse safely, so we will NOT currently
; inhibit the real mouse, but inform the user that both mice are active (real serial mouse 
; and MouseKeys) but that the user should not try to input data from both at the same instant 
; of time......
;---------------------------------------------------------------------------------------------
; If we get here,we have mouse data in buffer, so we need to check if PS/2 mouse check

NT_10:

	cmp	_fmouse_id,4				; do we have a PS/2 mouse ?
	jne	NT_50

;-----DEBUGGING------------------------------------------------------
;;;	cmp	fwindows_enh,true			; DEBUGGING
;;;	jne	NT_20
;	call	Inject_Mouse_Low
;	jmp	NT_110	
;
;-----DEBUGGING------------------------------------------------------

NT_20:
	call	Get_Mouse_Data				; ax has the data upon return
	mov	Mouse_Status,ax
	call	Get_Mouse_Data				; ax has the data upon return
	mov	Delta_X,ax
	call	Get_Mouse_Data				; ax has the data upon return
	mov	Delta_Y,ax

	call	InjectMouse
	jmp	short NT_110

;----------------------------------------------------------------------------------------------
; If we get here,we have mouse data in buffer, and we must have a Serial Mouse 

NT_50:

	cmp	_fmouse_id,2				; do we have a serial mouse ?
	jne	NT_110


	cmp	_comp_id,1				; are we on a PC/XT
	je	NT_60
	cmp	_comp_id,1Ah				; are we on a PC/XT with int 15h
	je	NT_60

NT_55:
	cmp	fslow_baud_mouse,true			; do we have a slow mouse
	jne	NT_65

NT_60:

	cmp	fslow_mouse,true			; is this first pass at slow mouse or second ?
	je	NT_65					; second pas, so cont. on
	mov	fslow_mouse,true			; first pass, set flag and exit
	jmp	short NT_110

NT_65:
	mov	fslow_mouse,false			; reset on second pass or every pass if not a slow mouse
	mov	dx,_combase				; put address of combase in dx

; first check to be sure the byte we may have transmitted previously has been sent out

	add	dx,5
	in	al,dx
	test	al,00100000b				; bit 5, transmit buffer should be clear if okay to write
	jz	NT_110					; if zero, register is not empty, jump around

; next check to be sure we are not suppossed to stop sending serial mouse data

	cmp	fserial_stop,true			; if set true, we should stop sending serial mouse data and flush th buffer
	jne	NT_70					; if not set, okay to send so cont

; if we get here, we are suppossed to stop sending serial mouse data, but we need to be sure we have sent a complete packet (3 bytes)
; before we quit.  The easiest way to do this, will be to get a byte from the buffer, and if bit 6 is set, then it is the first byte
; of another three byte packet, and then it is safe to stop sending serial mouse data

	call	Get_Mouse_Data				; get the next mouse data if it exists
	test	al,01000000b				; is bit 6 set high
	jz	NT_80					; if bit 6 is 0, not forst byte, cont. on

; if we get here, bit 6 was set, it is a first byte of a packet, and it is safe to flush the mouse data buffer

	mov	bx,OFFSET mouse_data			; get address of mouse_data buffer
	mov	mouse_data_head,bx			; reset head pointer to start of buffer
	mov	mouse_data_tail,bx			; reset tail pointer to start of buffer
	mov	mouse_cnt,false				; 
	mov	fserial_stop,false
	jmp	short NT_105


NT_70:
	call	Get_Mouse_Data				; get the next mouse data if it exists
NT_80:

	mov	dx,_combase				; put address of combase in dx
	out	dx,al		

NT_90:
	jmp	short NT_110

NT_105:
;--------------------------------------------------------------------------------------------------------------------
; call original timer, If jump was to NT_105, then mouse data buffer is empty, and we can reset fmouse_button flag

	mov	fmouse_button,false			; if buffer is empty reset flag for a serial mouse

NT_110:

; ************ later setup that if this is called and serial port has input, we won't do stuff after orig. int *****************

	cmp	fserial_keys_loaded,true		; is serial keys loaded ?
	jne	NT_112
	cmp	_serialKeysOn,true			; is SerialKeys code on ?
	jne	NT_112

	push	ds
	push	es
	call	_kickStartSerialKeys			; check if SerialKeys needs anything
	pop	es
	pop	ds

; ******************************************************************************************************************************

NT_112:

; If jump was to NT_110, then there was mouse data in the buffer buffer is empty, and after we call orig. int, we should 
; exit the timer int. since we have been inside the timer interrupt extra long doing something with mouse buffer data

	pushf
	call	dword ptr cs:old_1C_int			; call original timer 1Ch interrupt in case any one else chained in

	cmp	fmouse_button,false			; is mouse data buffer empty, (i.e. we didn't do any mouse activity)


	je	NT_115					; if the mouse data buffer was empty, we have the time to cont.
							; inside the timer interrupt


	jmp	NT_END					; since we had mouse activity, exit timer interrupt

;--------------------------------------------------------------------------------------------------------------------
; check to see if we need to call InjectKeys or just fake an interrupt 9h
; because we are running on a computer which supports int 15h and not hardware injection
;--------------------------------------------------------------------------------------------------------------------

NT_115:

; We will never inject if it is not a computer which supports int 15 intercept method of some kind...

	cmp	_vector,15h				; does this computer support int 15 h ?
							; this check should be REDUNDANT !!!!!
	je	NT_118					; cont. on and do an injection method if int 15h computer
	jmp	NT_200					; if not an int 15h computer, buffer should never get data and we should 
							; NEVER attempt to inject in any fashion

NT_118:

	mov	bx,key_data_head			; get head pointer of key_data buffer
	cmp	bx,key_data_tail			; test to see if head = tail, i.e. no data to send
	jne	NT_120					; if not equal, then we may need to empty buffer
	mov	fint9_by_timer,false			; if equal, reset this flag
	jmp	NT_200


NT_120:

; We will never try to inject if keyboard and system are talking...check mode indicator flag at 40:97 in BIOS...

	push	es
	mov	ax,RAMBIOS
	mov	es,ax
	assume	es:RAMBIOS
	mov	al,es:[97h]
	test	al,01000000b				; look at keyboard mode indicator update
	pop	es
	assume	es:_TEXT
	jz	NT_122					; if this flag is zero, safe to talke with keyboard since system is not
	jmp	NT_200					; if this flag is set, system is talking with keyboard, jump around and 
							; wait tilll that interaction is complete before trying to inject

NT_122:

; We will never try to inject if we are simultaneously filling our own keystroke buffer...

	cmp	fkeys_injected,true			; when this is true, something is filling the buffer, so we wait
	jne	NT_123					; when this is false, we can check the buffer for emptying
	jmp	short NT_200				


NT_123:

; Need to check 8259 interrupt controller to be sure that nothing other than the timer interrupt
; which we are currently in is pending before we fake a keyboard int using software int 9h.  We do this to avoid
; unwanted and dangerous extra EOI's being generated. We check "al" register upon return, and if it doesn't 
; equal 1, then we have other pending interrupts and we don't do an inject method now..

	call	controller_check			; check if 8259 controller has any other pending interrupts 
						     	

	cmp	al,01h					; is the timer and only the timer int. pending ?
	jne	NT_200					; if not, don't insert a key just yet
							; if yes, disable interrupts 

	cli						; disable interrupts, leaving timer int. will re-enable 

NT_125:

; Buffer HAS data, and we want to empty it, but need to check which method to use.

	cmp	_finject_keys,true			; can we inject into the hardware ?
	je	NT_150					; if yes, jump to here to do that routine


NT_130:

; If we get here, we do have a computer which supports int 15, but NOT hardware injection
; we must check for the two exception comnputers to the int15, 8042 insert of keys, they are the PS/2 Model 25/30-8086
; and the old PC or PX/XT running DOS 4+/5 with keyb.com loaded simulating int15 services
       
; Exception 1
; if _comp_id = 6, then we have the PS/2 Model 25/30-8086 and we must handle it by checking to see that
; that the timer didn't interrupt a keyboard interrupt, if not, cli, write to port 60h, and do and software int9h

; Exception 2
; if _comp_id = 1A, then we have the PC or PC/XT running DOS 4+/5 with keyb.com loaded and we must handle it by checking to see that
; that the timer didn't interrupt a keyboard interrupt, if not, do software int9h, and insert our code via int15h when it comes by
; since we cannot write a byte to keyboard port 60h on this computer.

	cmp	_comp_id,6
	jne	NT_142

	cmp	fnum_lock_was_off,true			; if we have a space saver kybd, wait till numlock kybd codes have passed
	je	NT_200					; before injecting StickyKey breaks
	jmp	short NT_145

NT_142:
	cmp	_comp_id,1Ah
	jne	NT_148

NT_145:
	cmp	_comp_id,1Ah				; is is the PC or PC/XT ?
	jne	NT_146
	mov	fint9_by_timer,true			; if PC or PC/XT signal to catch in int15h on the way back
	jmp	short NT_147

NT_146:

	call	Get_Key_Data				; ax has the data upon return when doing PS/2 Model 25/20-8086
	out	kb_data,al				; write to kybd data port
	mov	floop_back,true

NT_147:

	int	9h					; do a software int 9h
	jmp	NT_END

NT_148:

; I we get here, it was not one of the exception type computers form the abocve list, so cont. on with the kybd_echo routines...

	call	kybd_echo				; call our routine to insert a keystroke via 8042 undocumented feature
	jmp	NT_END

NT_150:

	cmp	fnum_lock_was_off,true			; if we have a space saver kybd, wait till numlock kybd codes have passed
	je	NT_200					; before injecting StickyKey breaks

	call	InjectKeys				; inject buffer data, keystrokes, into keyboard hardware buffer
	jmp	NT_END

NT_200:

;-----------------------------------------------------------------------------------------------------------------------
; Need to check our dialog flags here.  If fDialog_Action flag is false, (=0), then no action occurred and we can ignore
; any call to the respective turn on or turn off function.  If fDdialog_Action flag is true (1 ), then we need to call the
; respective routine to handle turning on or off of the feature.
;-----------------------------------------------------------------------------------------------------------------------

	cmp	fDialog_Action,true			; any action occur in Dialog or Menu's ?
	jne	NT_300					; if not, skip to next major check

	cmp	fDialog_Filter_off,false		; is filterkeys off ?
	je	NT_220					; yes
	call	FilterKeys_dialog
	jmp	NT_END					; exit timer int. any time we do a routine

NT_220:
	cmp	fDialog_Stickeys_off,false		; is stickeys off ?
	je	NT_240					; yes
	call	StickeyKeys_dialog
	jmp	NT_END					; exit timer int. any time we do a routine


NT_240:
	cmp	fDialog_Mouse_off,false			; is mousekeys off ?
	je	NT_260					; yes
	call	MouseKeys_dialog
	jmp	NT_END					; exit timer int. any time we do a routine

NT_260:
	cmp	fDialog_Toggle_off,false		; is togglekeys off ?
	je	NT_280
	call	ToggleKeys_dialog
	jmp	NT_END					; exit timer int. any time we do a routine
	
NT_280:	
	cmp	fDialog_TimeOut_off,false		; is timeout off ?
	je	NT_300
	call	TimeOut_dialog
	jmp	NT_END					; exit timer int. any time we do a routine

NT_300:
	mov	fDialog_Action,false			; reset this flag upon exit the above routines

;-------------------------------------------------------------------------------------------------------
; Hearing impaired attempt to display to screen a character for sound on/off
; check only 2 times a second otherwise cursor blinking is too annoying
; and also programs which take over the video like Microsoft Works will not
; start if we check the speaker port too often
;-------------------------------------------------------------------------------------------------------

	cmp	fhearing_on,true			; is hearing inpaired viaual cue flag set on ?
	je	video_1
	cmp	fvideo_flash,true			; is hearing impaired video flashing flag set on ?
	je	video_0
	mov	faccess_sound,false			; reset flag and
video_0:
	jmp	video_end				; if hearing impaired flag is not on, jump to here

; Go get the current video state and save it.  If it changes from the previous video state, we
; will prevent writes to video for a short period of time in hopes of not messing up the switched
; video state.
;
; Before we do anything, we will get current video state and check it with the old. Since we asssign
; video state a ZERO to start, it will alway pause when ADOS is first enabled.  We could try to read
; the video state in _Enable Proc and avoid this, if it seems to miss any beeps.

video_1:

	push	es
	mov	ax,RAMBIOS
	mov	es,ax
	assume	es:RAMBIOS
	mov	al,es:[49h]				; read same area int 10h would, but cause less video trouble if not
	pop	es					; going to write visual cue this time thru
	assume	es:_TEXT

;	mov	ah,0fh					; read current video state
;	int	10h					; int 10

	cmp	al,video_state				; is the read video state the same as previous video state ?
	je	video_3					; if yes, cont. on here
	mov	video_state,al				; if not, save current video state
							; and set the video_count such that a 5 second delay will 
							; take palce while the video state is changing

	mov	video_count,07fh			; reset such that it will take 5 seconds to start video 
							; for hearing impaired if on
	mov	faccess_sound,false			; if ADOS produced a sound during a switch, reset that flag also
	mov	fswitching_video,true			; inform myself (ADOS) that video mode is switching
	jmp	video_end				; if switching video , jump out

video_3:

	inc	video_count				; increment counter each time through
	cmp	video_count,9				; have we reach 1/2 second ?
	je	video_4
	jmp	video_end				; if not at 9 yet, jump around

video_4:
	mov	video_count,0				; reset count to 0
	mov	fswitching_video,false			; inform myself (ADOS) that safe to do video

; any reason to produce a video que for some kind of sound which happened or is happening ?

	cmp	faccess_sound,true			; did AccesDos produce a beep
	je	video_20				; yes or speaker did 

video_10:	

	in	al,kb_ctl				; read speaker control port
	and	al,02					; test speaker bit on/off
	jnz	video_18				; speaker bit is high, do video
	jmp	video_end

video_18:
	mov	faccess_sound,true			; use our variable to flag speaker bit toggling also

video_20:

	cmp	video_state,7				; is this mode 7, Mono text
	je	video_22
	cmp	video_state,3				; is this any of the Text video modes below 3
	jle	video_22
		       					; if not, must be in a graphics mode, so 
	mov	txt_or_grph,09h	     			; write a character to video graphically
	jmp	short video_23

video_22:
	mov	txt_or_grph,0ah	 			; write a character to video as text

video_23:

	cmp	fvideo_type,3				; check if we have a CGA monitor
	jne	video_25				; if not, continue

; if yes, don't write to video memory until horizontal retrace is in progress

	mov	dx,3dah
	in	al,dx					; read CGA status byte
	test	al,1					; test bit 1
	jnz	video_25				; if bit is set, in retrace, semi safe to write
	jmp	video_end

video_25:

; if not true, not a CGA monitor and we can write to video directly

	mov	ah,3					; read current cursor position
	mov	bh,0					; page 0
	int	10h					; video interrupt
	mov	old_row,dh				; save current row
	mov	old_col,dl				; save current column
	mov	old_cursor_1,cl				; save current cursor type
	mov	old_cursor_2,ch				; save current cursor type

	mov	ah,2					; prepare to set current position
	mov	dh,0					; row 0
	mov	dl,0					; column 0
	mov	bh,0					; page 0
	int	10h					; video int
			     
video_30:

	mov	ah,08h					; read character and attribute at cursor
	int 	10h
	mov	old_char_1_attr,ah	 		; put attributes into variable

	cmp	al,14					; did we just read back the hearing impaired sysbol ?
	je	video_50

	mov	old_char_1,al				; save orig. char. to rewrite

	mov	ah,2					; prepare to set current position
	mov	dh,0					; row 0
	mov	dl,1					; column 1
	mov	bh,0					; page 0
	int	10h					; video int

	mov	ah,08h					; read character and attribute at cursor
	int 	10h
	mov	old_char_2_attr,ah	  		; put attributes into variable
	mov	old_char_2,al				; save orig. char. to rewrite

	mov	ah,txt_or_grph				; set video mode to write in
video_40:

	cmp	fsecond_cue,false
	je	video_45

	mov	cx,1					; write 1 character			
	mov	al,fsecond_cue				; 
	mov	bl,old_char_2_attr
	int	10h

video_45:

	mov	ah,2					; prepare to set current position
	mov	dh,0					; row 0
	mov	dl,0					; column 0
	mov	bh,0					; page 0
	int	10h					; video int

	mov	cx,1					; write 1 character			
	mov	ah,txt_or_grph				; set video mode to write in
	mov	bl,old_char_1_attr
	mov	al,14					; send ASCII character 14 to video for sounds on
	int	10h

	jmp	video_70				; jump to restore cursor

video_50:

	mov	ah,txt_or_grph				; set video mode to write in
video_66:

	mov	cx,1					; write 1 character			
	mov	faccess_sound,false
	mov	bl,old_char_1_attr
	mov	al,old_char_1				; replace original character
	int	10h

	cmp	fsecond_cue,false
	je	video_70

	mov	ah,2					; prepare to set current position
	mov	dh,0					; row 0
	mov	dl,1					; column 1
	mov	bh,0					; page 0
	int	10h					; video int

	mov	ah,txt_or_grph				; set video mode to write in
	mov	bl,old_char_2_attr
	mov	al,old_char_2				; replace original character
	mov	fsecond_cue,false			; reset fsecond_cue flag
	int	10h

video_70:

	mov	ah,2					; restore current cursor position
	mov	ch,old_cursor_2
	mov	cl,old_cursor_1
	mov	dh,old_row
	mov	dl,old_col
	mov	bh,0
	int	10h

	jmp	NT_END					; exit timer int. any time we do a routine

video_end:

;-------------------------------------------------------------------------------------------------------
; video flash routines


	cmp	fvideo_flash,true			; is hearing impaired video flashing flag set on ?
	je	flash_10
	jmp	flash_end_out

flash_10:

	cmp	fvideo_flash_on,true			; did we already flash
	je	flash_40				; if yes, jump to routine to turn video back on

	cmp	faccess_sound,true			; did AccesDos produce a beep
	jne	flash_15				
	mov	video_cnst,4				; yes  
	jmp	short flash_30

flash_15:	

	in	al,kb_ctl				; read speaker control port
	and	al,02					; test speaker bit on/off
	jnz	flash_20				; speaker bit is high, do video
	jmp	flash_end_out

flash_20:
	mov	faccess_sound,true			; use our variable to flag speaker bit toggling also
	mov	video_cnst,4				; speaker did, keep seperateincase we change system flash length

flash_30:

;;	cmp	fvideo_flash_on,true			; did we already flash
;;	je	flash_40				; if yes, jump to routine to turn video back on

	mov	fvideo_flash_on,true
	call	video_flash_on				; subroutine to do borderflash on
	jmp	short flash_end

flash_40:


	inc	fvideo_flash_cnt
	mov	al,video_cnst
	cmp	al,fvideo_flash_cnt
	jne	flash_end_out

	call	video_flash_off				; subroutine to do borderflash off
	mov	faccess_sound,false
	mov	fvideo_flash_cnt,0
	mov	fvideo_flash_on,false

flash_end:

	jmp	NT_END					; exit timer int. any time we do a routine

flash_end_out:

;--------------------------------- End of Video for Hearing Impaired flag ------------------------------

	cmp	_finject_keys,true			; if flag isn't true, donot check any further
	jne	NT_END

	cmp	fwindows_enh,true			; are we in enhanced mode ?
	jne	NT_END

	cmp	falt_esc_send,true			; safe to send codes ?
	jne	sound_100

	mov	al,038h					; put ALT make into buffer
	call	Put_Key_Data
	mov	al,001h					; put ESC make into buffer
	call	Put_Key_Data
	mov	al,081h					; put ESC break into buffer
	call	Put_Key_Data
	mov	al,0b8h					; put ALT break into buffer
	call	Put_Key_Data

sound_90:

	mov	falt_esc,false
	mov	falt_esc_send,false
	jmp	short NT_END

sound_100:

;--------------------------------- check if we ever loaded Windows Real mode, and if we did, did we exit

	cmp	fwindows_after_re,true			; was Windows ever startec in REAL mode ?
	jne	NT_500

	mov	ax,04680h				; use int2f to see if still loaded
	int	2fh
	cmp	al,00					; al = 00, if REAL mode still running
	je	NT_500
							; if al <> 00, then REAL mode exitted, reset flags

	mov	video_count,07fh			; reset such that it will take 5 seconds to start video 
	mov	fwindows_after_re,false
	mov	fwindows_after,false
	mov	al,fhearing_on_save			; restore upon exit
	mov	fhearing_on,al
	mov	al,fvideo_flash_save
	mov	fvideo_flash,al


NT_500:

;----------------------------------- run if and only if ADOS started after windows in enhanced mode-----------------

	cmp	fctrl_esc_send,true			; safe to send codes ?
	jne	NT_END

	mov	al,01dh					; put CTRL make into buffer
	call	Put_Key_Data
	mov	al,001h					; put ESC make into buffer
	call	Put_Key_Data
	mov	al,081h					; put ESC break into buffer
	call	Put_Key_Data
	mov	al,09dh					; put CTRL break into buffer
	call	Put_Key_Data

	mov	fctrl_esc,false
	mov	fctrl_esc_send,false

NT_END:

	mov	ftimer_1C_active,false

;NT_END_5:

	pop	ax
	pop	bx					; restore registers
	pop	cx
	pop	dx
	pop	di
	pop	si
	pop	es
	assume	ES:NOTHING
	pop	ds
	assume	DS:NOTHING

	iret

_new_timer_int	endp

;--------------------------------------------------------------------------------------------------------

controller_check	proc	near

	assume DS:_TEXT

	mov	al,0Bh
	out	ack_port,al				; write operation command byte 3, to get ISR 
	jmp	$+2

	in	al,ack_port				; read the 8259 controller port
	jmp	$+2

	mov	ah,al
	mov	al,08h
	out	ack_port,al				; write operation to rese controller

	mov	al,ah
	ret

	controller_check	endp
;--------------------------------------------------------------------------------------------------------

video_flash_on	proc	near

	assume DS:_TEXT
	assume	es:NOTHING

	mov	ax,RAMBIOS
	mov	es,ax

	assume	es:RAMBIOS
	mov	al,es:vid_flag
	and	al,0f7h

	cmp	fvideo_type,1
	jne	von_10
	
        mov     dx,3b8h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short von_end

von_10:

	cmp	fvideo_type,3
	jne	von_30

        mov     dx,3d8h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short von_end

von_30:	

	cmp	fvideo_type,4
	jne	von_40

        mov     dx,3bah
        in      al,dx
        mov     dx,3c0h
        xor     al,al
        out     dx,al
	jmp	short von_end

von_40:

	cmp	fvideo_type,5
	jne	von_50
        mov     dx,3dah
        in      al,dx
        mov     dx,3c0h
        xor     al,al
        out     dx,al
	jmp	short von_end


von_50:

	cmp	fvideo_type,6
	jne	von_60
        mov     dx,3d8h
        in      al,dx
        and     al,0f7h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short von_end

von_60:
	cmp	fvideo_type,7
	jne	von_end
        mov     ax,1201h
        mov     bx,0036h
        int     10h

von_end:
	assume	es:NOTHING
	ret

video_flash_on	endp

;--------------------------------------------------------------------------------------------------------

video_flash_off proc	near

	assume DS:_TEXT
	assume	es:NOTHING

	mov	ax,RAMBIOS
	mov	es,ax

	assume	es:RAMBIOS
	mov	al,es:vid_flag
	or	al,08h

	cmp	fvideo_type,1
	jne	voff_10

        mov     dx,3b8h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short voff_end

voff_10:

	cmp	fvideo_type,3
	jne	voff_30

        mov     dx,3d8h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short voff_end

voff_30:	

	cmp	fvideo_type,4
	jne	voff_40
        mov     dx,3bah
        in      al,dx
        mov     dx,3c0h
        mov     al,20h
        out     dx,al
	jmp	short voff_end


voff_40:

	cmp	fvideo_type,5
	jne	voff_50
        mov     dx,3dah
        in      al,dx
        mov     dx,3c0h
        mov     al,20h
        out     dx,al
	jmp	short voff_end


voff_50:

	cmp	fvideo_type,6
	jne	voff_60
        mov     dx,3d8h
        in      al,dx
        or      al,08h
        out     dx,al
	mov	es:vid_flag,al
	jmp	short voff_end

voff_60:
	cmp	fvideo_type,7
	jne	voff_end

        mov     ax,1200h
        mov     bx,0036h
        int     10h

voff_end:

	assume	es:NOTHING
	ret

video_flash_off	endp

;-----------------------------------------------------------------------------------------------------------------
;*****************************************************************************************************************
; This is the beginning of the resident code of the routine which receives
; the keyboard scan code via int 15h from the keyboard interrupt, int 9h.  It builds up 
; the extended scan code while also passing the scan code along back to interrupt 9, most of the time.
; If after passing thru the keyboard features, it is detemined that the scan code should not pass along,
; the software returns to int. 9h with the carry flag cleared.  
;
; The flags fbios_called_direct or fbios_called_timing are used to tell if the scan code should get
; passed back to interrupt 9h, or should be eaten upon passing back to interrrpt 9h.
;
; The scan code is in Al when int 15h is called with Ah = 4f
;*****************************************************************************************************************
;-----------------------------------------------------------------------------------------------------------------


_keybd_int_15  PROC	far

	cmp	ah,4fh					; is this an int15 for the keyboard ?
	je	kybd_int_15_5

	jmp	not_kybd_int_15

kybd_int_15_5:

	push	ds					; save the ds and ax
	push	es
	push	bx
	push	ax

	push	cs
	pop	ds
	assume DS:_TEXT
	push	cs
	pop	es
	assume ES:_TEXT

;---------------------------------------------------------------------------------------------------------------------------
; difference here to standard int 9h routine *******************************************************************************
;---------------------------------------------------------------------------------------------------------------------------

	mov	fmouse_or_kybd,true			; flag any int. callers, that kybd int. 9h executed
	call	TimeOut_Reset				; reset the time out count
	mov	fbios_called_direct,false 		; reset to false upon entry

;----------------------------------------------------------------------------
; we do not want to have any of the routines that process key input have to
; deal with any of the commands that are specifc to the operation of the 
; keyboard, so we will pass them on directly to the BIOS routine since the
; original device driver routine also passed commands to the BIOS routine.
; See original BIOS of Tech. Ref. manuals for PC/PCXT/PCAT
;
	pop	ax

	cmp	al,kybd_Command				; is it a command (0EDh)?
	jb	not_command_15				; no -->

kybd_command_50:

	jmp	kybd_int_15_exit	  		; done -->

;----------------------------------------------------------------------------

not_command_15:

;	cmp	fserial_keys_loaded,true		; is serial keys loaded ?
;	jne	kybd_int_15_5A
	cmp	_serialKeysOn,true			; is SerialKeys code on ?
	jne	kybd_int_15_5A

;---------------------------- serial port keyboard emulation ----------
; if we get here, we need to first look and see if SerialKeys injected a code

 	test	cs:_forcedInt9Flag,true			; if flag is true, SerialKeys injected a scan code
	jz	kybd_int_15_5A

	mov	cs:_forcedInt9Flag,false   		; reset flag
	mov	fserial_key_recieved,true		; set flag for my code modules
	mov	ah,04fh					; fill in the rest of a fake int 15h AX 
	mov	al,cs:_injectByte   			; inject new scan code

;IFDEF	BUG
;	mov	portid,9
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG			

;	call	click
	jmp	short kybd_int_15_7


kybd_int_15_5A:
;---------------------------- keyboard emulation-----------------------
; When we get here, we need to check if this is a real int9 or did the timer simulate an int9 when int 15h was called ?

	cmp	fint9_by_timer,true			; if the timer simulated an int9, this flag will be true
	jne	kybd_int_15_6				; if false, it is a real int 9 and call to int 15
	call	Get_Key_Data				; if true, this is a fake int9, and we want to get 
							; the scan code to pass out of the key_data_buffer
							; the scan code we want to pass is now in AL register
	mov	ah,04fh					; fill in the rest of a fake int 15h AX 
	jmp	short kybd_int_15_7

kybd_int_15_6:


;IFDEF	BUG
;;	mov	fserial_debugging,true
;	mov	portid,0
;	mov	portout,al
;	call	HexCharsOut
;;	mov	fserial_debugging,false
;ENDIF;	BUG

	cmp	fkeys_injected,false
	jne	kybd_int_15_6C
	push	bx
	mov	bx,key_data_head			; get head pointer of key_data buffer
	cmp	bx,key_data_tail			; test to see if head = tail, i.e. no data to send

	je	kybd_int_15_6B				; if equal, then we may need to empty buffer
	cmp	floop_back,true
	je	kybd_int_15_6B

	push	es
	push	ax
	mov	ax,RAMBIOS
	mov	es,ax
	assume	es:RAMBIOS
	mov	al,es:[97h]
	test	al,01000000b				; look at keyboard mode indicator update
	pop	ax
	pop	es
	assume	es:_TEXT
	jz	kybd_int_15_6A				; if clear, comp. and kybd are not talking, okay to in-line inject
	jmp	short kybd_int_15_6B

kybd_int_15_6A:

	call	Put_Key_Data				; save current al
	call	Get_Key_Data				; get my code
	mov	ah,04fh					; fill in the rest of a fake int 15h AX 

kybd_int_15_6B:
	mov	floop_back,false	 		; reset
	pop	bx


kybd_int_15_6C:


;IFDEF	BUG
;;	mov	fserial_debugging,true
;	mov	portid,1
;	mov	portout,al
;	call	HexCharsOut
;;	mov	fserial_debugging,false
;ENDIF;	BUG

kybd_int_15_7:
;---------------------------------------------------------
; first check to see if the space saver keyboard is in use
;---------------------------------------------------------

	cmp	fspace_saver,true			; is flag set to indicate space saver ?
	jne	kybd_space_saver_end			; if not, exit to next check

kybd_space_saver_15_3:

	cmp	al,046h					; is space saver kybd, so check is this SCROLL LOCK make key ?
	jne	kybd_space_saver_15_5
	jmp	short kybd_space_saver_15_15

kybd_space_saver_15_5:

	cmp	al,0C6h					; is this SCROLL LOCK break key ?
	jne	kybd_space_saver_end			; if not, exit
	cmp	fscroll_changed,true			; did we previously detect shift+numlock ?
	jne	kybd_space_saver_end			; if not, exit
	mov	fscroll_changed,false			; reset flag
	mov	al,0C5h					; insert NUM LOCK break into "al" register instead of scroll lock break
	jmp	short kybd_space_saver_end

kybd_space_saver_15_15:

	cmp	fscroll_changed,true			; did we already change scroll lock to num lock and this is typematic
	jne	kybd_space_saver_15_25			; because if it is, it will also need to be changed, as StickyKeys would have cleared
							; the shift flag by now...If a person hold both keys down, we don't have a problem, since the
							; keyboard will then send a "45,C5", not a "46,C6" code

	jmp	short kybd_space_saver_15_30		; fscroill was set, so keep changing makes until we get a break


kybd_space_saver_15_25:

	push	es
	push	ax
	push	bx
	assume	ES:NOTHING
	mov	bx,RAMBIOS
	mov	es,bx
	ASSUME	ES:RAMBIOS
	mov	al,es:kb_flag
	test	al,03h					; is a shift key also down with the scroll lock ?
	jz	kybd_space_saver_15_50			; if not, cont
	mov	fscroll_changed,true			; if yes, set htis flag to catch on the scroll break
	pop	bx
	pop	ax
	pop	es
	assume ES:_TEXT

kybd_space_saver_15_30:

	mov	al,045h				      	; change al to NUM LOCK make
	jmp	short kybd_space_saver_end

kybd_space_saver_15_50:

	pop	bx
	pop	ax
	pop	es
	assume ES:_TEXT

kybd_space_saver_end:

;-----------------------------------------------------
; Next, need to check if we are in a control break condition
;-----------------------------------------------------

	cmp	fctrl_break_on,true			; was ctrl break flagged on previous int ?
	jne	kybd_int_15_13
	cmp	al,0c5h					; control break condition on, wait for "C5h" to clear
	jne	kybd_int_15_12				; if not "C5h" yet, jump to end

kybd_int_15_10:
; if we get here, we are looking for the "C5h" scan code only-last part of PAUSE key
; what ever is in "ax" register doesn't need to be saved, since we are throwing it away
	
	push	cx
	push	si
	push	ax
	xor	cx,cx
	xor	ax,ax
	mov	fkeys_injected,true			; set flag since we are going to put keys in the buffer

kybd_int_15_11:

	mov	cl,ctrl_break_buf_cnt
	mov	bx,offset ctrl_break_buf
	mov	si,cx
	mov	al,[bx+si]
	call	Put_Key_Data
	inc	ctrl_break_buf_cnt

	mov	al,ctrl_break_buf_cnt
	mov	bl,ctrl_break_buf_len
	cmp	al,bl
	jne	kybd_int_15_11

	mov	ctrl_break_buf_cnt,false		; reset buffer count
	mov	fkeys_injected,false			; buffer stuffed, turn off flag so timer can inject
	mov	fctrl_break_on,false			; if it is "C5h" jump to end

	pop	ax
	pop	si
	pop	cx

kybd_int_15_12:

	jmp	keybd_int_15_end     			; jump to end, since we ate a code

kybd_int_15_13:

;;----------------------------------------------------------------------------------------------------------------------
;; For this next routine, we need to check if we support Inject keys routine

	cmp	_finject_keys,true			; first check if we can inject ?
	je	kybd_win_15_5				; if we can inject, do next code which is based on the ability to INJECT

	jmp	kybd_win_end				; if we CAN NOT inject, cont. at _13

;-------------------------------------------------------------------------------------------
; THIS CODE ASSUMES THE KEYBOARD AND COMPUTER ACCEPT DIRECT INJECTION OF MOUSE AND KYBD CODES
;-------------------------------------------------------------------------------------------
;-------------------------------------------------------------------------------------------
; next check to see if we are running under Windows 3.0 in the enhanced mode only
;-------------------------------------------------------------------------------------------

kybd_win_15_5:


	cmp	fwindows_enh,true			; is windows running ?
	jne	kybd_win_end


kybd_win_15_7:

	cmp	al,01h					; did we read in an "ESC" key ?
	jne	kybd_win_15_10
 	jmp	short kybd_win_15_30			; was an "ESC" key make , check if "ALT" key down ?

kybd_win_15_10:

	cmp	al,081h					; is this the "ESC" break ?
	jne	kybd_win_end

kybd_win_15_20:						; was an "ESC" key break

	cmp	falt_esc,true
	jne	kybd_win_15_25
	mov	falt_esc_send,true
	mov	falt_esc,false
	jmp	short kybd_win_end

kybd_win_15_25:

	cmp	fctrl_esc,true
	jne	kybd_win_end
	mov	fctrl_esc_send,true
	mov	fctrl_esc,false
	jmp	short kybd_win_end

kybd_win_15_30:

	push	es
	push	ax
	push	bx
	assume	ES:NOTHING
	mov	bx,RAMBIOS
	mov	es,bx
	assume	ES:RAMBIOS
	mov	al,es:kb_flag
	test	al,08h
	jz	kybd_win_15_50

	mov	falt_esc,true
	jmp	short kybd_win_15_95

kybd_win_15_50:
	mov	falt_esc,false
	test	al,04h
	jz	kybd_win_15_60

	mov	fctrl_esc,true
	jmp	short kybd_win_15_95

kybd_win_15_60:

	mov	fctrl_esc,false

kybd_win_15_95:

	pop	bx
	pop	ax
	pop	es
	assume ES:_TEXT

kybd_win_end:

;;;----------------------------------------------------------------------------
;;; we do not want to have any of the routines that process key input have to
;;; deal with any of the commands that are specifc to the operation of the 
;;; keyboard, so we will pass them on directly to the BIOS routine since the
;;; original device driver routine also passed commands to the BIOS routine.
;;; See original BIOS of Tech. Ref. manuals for PC/PCXT/PCAT
;;;
;;	cmp	al,kybd_Command				; is it a command (0F0h)?
;;	jb	not_command_15				; no -->
;;	jmp	kybd_int_15_exit	  		; done -->
;;
;----------------------------------------------------------------------------
; we need to build up the two byte key codes if appropriate.

	cmp	al,kb_ext_code1				; is it a hidden code prefix e0?
	je	is_hidden_code_15			; yes, save -->
	cmp	al,kb_ext_code2				; is it a hidden code prefix e1?
	jne	not_hidden_code_15			; no, -->

is_hidden_code_15:

	mov	hidden_code,al				; yes, save

; at this point, we know we had a hidden code, so check for ctrl-break
; or alt-print screen for sysreq.

	push	es					; save es
	push	ax
	assume	ES:NOTHING
	mov	bx, RAMBIOS				; BIOS RAM segment at 40h
	mov	es,bx					;  .. point ES to that!
	assume	ES:RAMBIOS
	mov	al,es:kb_flag				; 

	cmp	hidden_code,0E1h			; is it "E1h" ?
	jne	kybd_int_15_20				; if not jump to check the "E0h" code

	test	al,04h
	jz	kybd_int_15_30				; if zero, the control key isn't pressed
	mov	fctrl_break_on,true			; set flag to tell us we have ctrl break condition
	mov	fpause_being_sent,false			; if control break, not a PAUSE
	jmp	short kybd_int_15_30


kybd_int_15_20:
; if it jumps here, we know we have a hidden code, and it must be "E0h" only, and all we want to check is if an alt. key is down

	test	al,08h
	jz	kybd_int_15_25				; if not set, jump out
	mov	fsysreq,true				; alt. key is down with "E0h" code, MAY have sys req. in progress
	jmp	short kybd_int_15_30

kybd_int_15_25:
	mov	fsysreq,false				; alt key not down with "E0h" code
kybd_int_15_30:

	pop	ax
	pop	es
	assume ES:_TEXT

kybd_int_15_35:

	cmp	fctrl_break_on,true			; are we in a ctrl break condition ???
	jne	kybd_int_15_45
	jmp	keybd_int_15_end 			; reset without any call to original BIOS

kybd_int_15_45:
	cmp	al,0E1h					; is this an E1h hidden code ?
	jne	kybd_int_15_46

	mov	fpause_being_sent,true			; if "E1h" unaltered, then PAUSE key is being sent, flag this so MouseKeys
							; doesn't turn off on the "45h" part of the scan code
							; will alway stay on unless MouseKeys is on, detects this, and clears it
							; or it is a computer which Injects, then it is turned off above kybd_int_20
kybd_int_15_46:	   

	jmp	kybd_int_15_exit 			; pass the E0 or E1 code

;------------------------------------------------------------
; now build up the code and pass to first one of the routines
;------------------------------------------------------------
; last check for alt-print screen for sysreq done here
;------------------------------------------------------------

not_hidden_code_15:

; int 15h with ah = 4fh will get burnt here, since ah is replaced with hidden code and passed thru AccessDos features
; appears not to bother int 15h, 4fh, unless DOS keyb.com is running, so I reworked this 
; code to maintain the "ah"=4fh ..........

	push	ax					; save al, ah =4fh 

	mov	ah,hidden_code				; get current hidden code value
	mov	hidden_code,0				; reset hidden code

; for passing thru keyboard features only

	cmp	fsysreq,true				; did we previously set this flag due to alt.+"E0h" code ?
	jne	kybd_int_15_48				; if not, cont.
; if yes, then we must watch for the "B7h" scan code which is PrtSc make code

	cmp	al,0B7h					; is this the "37h" key  scan code ?
	jne	kybd_int_15_48				; cont. on if not

; if we get here, it was "B7h" scan code, so we pass the last code and inject the SysReq codes (54/D4)

	push	ax
	mov	fkeys_injected,true			; set this flag to inject
	mov	al,054h					; SysReq make code
	call	Put_Key_Data
	mov	al,0D4h					; SysReq break code
	call	Put_Key_Data
	mov	fsysreq,false				; we've inject sysreq, so clear htis falg 
	pop	ax

;;	mov	fkeys_injected,false			; we are done stuffing buffer, so reset this flag to allow timer to inject
;;	jmp	short kybd_int_15_exit      		; exit

kybd_int_15_48:

; Now call Handicap routines.  We do not expect any registers to be
; the same.  So the routine does not need to save any.


	call	FilterKeys				; pass on extended code in AX

	pop	ax					; restore ah, and al, to code to be passed or eaten

	test	al,break_bit				; was this code a break code ?
	jz	kybd_int_15_48A				; it was a make scan code, check other condition 

	mov	fkeys_injected,false			; reset this flag if a break upon return
	jmp	short kybd_int_15_49			; 

kybd_int_15_48A:

	cmp	fSticKeysOn,true			; is StickeyKeys On ?
	je	kybd_int_15_48C				; 

	cmp	fint9_by_timer,true			; is this an injected scan code by the timer ?
	je	kybd_int_15_48C				; 
	cmp	al,46h
	je	kybd_int_15_48C				; 
	cmp	al,54h
	je	kybd_int_15_48C				; 
	jmp	short kybd_int_15_49			; if flag gets reset on a break, okay

kybd_int_15_48C:

	mov	fkeys_injected,false			; if yes, reset this flag also so buffer will empty makes/breaks

kybd_int_15_49:

	cmp	fbios_called_timing,true		; Does the timer want to let a key pass ? (FROM FILTERKEYS ONLY)
	jne	kybd_int_15_50

	cmp	fclick_on,true
	jne	kybd_int_15_49A

	cmp	fshift_click,true
	je	kybd_int_15_49A

	cmp	current_shift,0
	je	kybd_int_15_49B				; if not a modifier key, call click
	mov	fshift_click,true			; if we clicked once, set, as non-modifier will clear

kybd_int_15_49B:

	call	click

kybd_int_15_49A:

	mov	fbios_called_timing,false		; reset flag
	jmp	short kybd_int_15_exit			; and allow code to pass

kybd_int_15_50:

	cmp	fbios_called_direct,true  		; do we want to pass on the code ?
	jne	keybd_int_15_end 			; no, so end and eat the code
		
;-----------------------------------------
; jumps to here, if passing scan code on as is or what ever has been stored in the AL register

kybd_int_15_exit:

	mov	fserial_key_recieved,false		; reset flag for my code modules

;IFDEF	BUG
;;	mov	fserial_debugging,true
;	mov	portid,2
;	mov	portout,al
;	call	HexCharsOut
;;	mov	fserial_debugging,false
;ENDIF;	BUG

	pop	bx
	pop	es
	pop	ds
	assume	DS:NOTHING
	assume	ES:NOTHING

	stc
	jmp	dword ptr cs:old_kybd_int			; call old int 15 routine

;-----------------------------------------
; jumps to here if ate a code, if we eat code, return to int15 caller
; with ret 2, which in effect, through away flags on stack and allows
; our carry flag clear to return as it should

keybd_int_15_end:


	mov	fserial_key_recieved,false		; reset flag for my code modules

;;IFDEF	BUG
;;	mov	fserial_debugging,true
;;	mov	portid,3
;;	mov	portout,al
;;	call	HexCharsOut
;;	mov	fserial_debugging,false
;;ENDIF;	BUG

	pop	bx
	pop	es
	pop	ds

	assume	DS:NOTHING
	assume	ES:NOTHING

	clc
	ret	2

;-----------------------------------------
; jumps to here, if not int15h with Ah=4fh

not_kybd_int_15:

	jmp	dword ptr cs:old_kybd_int			; call old int 15 routine

_keybd_int_15	endp

;----------------------------------------------------------------------------
; keybd_int
;
; This is the beginning of the resident code of the routine which intercepts 
; the keyboard interrupt, int 9h.  This keyboard interrput routine should only load
; and run for IBM PC /PCXT/ PCAT Original 1/10/84 (i.e. 84 key keyboard) computers.
; Non of these computer should ever see a hidden code (i.e E0/E1), and non of these 
; computers support the Extended BIOS or kb_flags1/3 or hardware keyboard injection.  
;
; Since I know some PC/PCXT/PCAT users prefer 101 keyboard, and that these keyboards
; typically cheat by sending hidden codes for the extra keys expecting the BIOS 
; to straighten the situation out, I can easily send on any hidden codes straight to BIOS
; where the computer will ignore them, and this may allow our code to work on 
; these NASTY keyboards.
;-----------------------------------------------------------------------------
; NOTE: IF I get codes for 101 cursor keys like 2A 4D AA 2A CD AA for the --> key, 
; we will still have trouble since the extra 2A and AA look like shift keys to PC/PCXT/PCAT
; Original, since it never had cursor keys, and if it did have cursor keys, they should 
; send E0 2A E0 4D E0 CD E0 AA for the --> key, which would distinguish it correctly,
; and this code should handle by passing along to BIOS where the hidden codes would be ignored.
;-----------------------------------------------------------------------------

_keybd_int  PROC	


	push	ax
	mov	ax,1					; watch for myself to be re-entrant
	xchg	cs:fint9_active_temp,al			; flag that I'm in interrupt

	cmp	al,1					; which time are we ???
	je	kybd_int_3
	
	mov	cs:kybd_ss_save,ss
	mov	cs:kybd_sp_save,sp
	push	cs
	pop	ss
	mov	sp,offset kybd_Stack_top

kybd_int_3:

	push	ax					; save value of ax

	push	ds					; save the ds and ax
	push	ax
	push	bx
	push	es

	push	cs
	pop	ds
	assume DS:_TEXT
	push	cs
	pop	es
	assume ES:_TEXT

	call	TimeOut_Reset				; reset the time out count
	mov	fbios_called_direct,false
	mov	fmouse_or_kybd,true			; flag any int. callers, that kybd int. 9h executed

kybd_int_5:

	cmp	_comp_id,5				; do we have an AT class machine
	jne	kybd_int_8				; if not, cont.

	mov	al,dis_kbd				; if yes, disable keyboard
	call 	ship_it


kybd_int_8:
	
	in	al,kb_data				; read in data from keyboard port

;IFDEF	BUG
;	mov	portid,0
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG

;----------------------------------------------------------------------------
; we do not want to have any of the routines that process key input have to
; deal with any of the commands that are specifc to the operation of the 
; keyboard, so we will pass them on directly to the BIOS routine since the
; original device driver routine also passed commands to the BIOS routine.
; See original BIOS of Tech. Ref. manuals for PC/PCXT/PCAT
;
	cmp	al,kybd_Command				; is it a command (0EDh)?
	jb	not_command				; no -->

kybd_int_10:

	pushf						; yes, call bios routine
	call	dword ptr cs:old_kybd_int
	jmp	keybd_int_ret				; done -->

not_command:
;----------------------------------------------------------------------------
; we need to pass on hidden key codes if appropriate.

	cmp	al,kb_ext_code1				; is it a hidden code prefix e0?
	je	is_hidden_code				; yes, eat-->
	cmp	al,kb_ext_code2				; is it a hidden code prefix e1?
	jne	not_hidden_code				; no, -->

is_hidden_code:

	mov	hidden_code,al	
	jmp	short kybd_int_10			; allow BIOS to deal with any hidden codes we may get


not_hidden_code:

; if the hidden code is not zero, then the previous scan code was either E0/E1 and something, which
; should not exist on these computers, so I will pass them along to the original BIOS and let it
; sort them out.

	mov	ah,hidden_code				; get previous hidden code if any ?
	mov	hidden_code,0				; reset for next key

	cmp	ah,0					; was there a previous hidden code ?
	je	kybd_int_20				; if not, we can cont.----else goto BIOS

; Before we send all E0 /E1 codes to BIOS, ....
; check for right alt. and ctrl. as these older computers shouldn't have these keys, but someone may
; use a 101 key keyboard on tis type of computer as the BIOS just treat the right alt. and ctrl. keys
; as the left alt. and ctrl. keys, as should I

	push	ax
	and	al,not break_bit			; be sure al is the make version of a make/break code
	cmp	al,38h					; an right alt. key ?
	jne	kybd_int_11
	jmp	short kybd_int_18

kybd_int_11:

	cmp	al,1dh					; an right ctrl. key ?
	jne	kybd_int_12
	jmp	short kybd_int_18

kybd_int_12:

	cmp	al,1ch					; an right enter key ?
	jne	kybd_int_15
	jmp	short kybd_int_18

kybd_int_15:
	pop	ax
	jmp	short kybd_int_10			; allow BIOS to deal with any codes

kybd_int_18:
	pop	ax

kybd_int_20:

; Now call Handicap routines.  We do not expect any registers to be
; the same.  So the routine does not need to save any.

;	sti

;IFDEF	BUG
;	mov	portid,0
;	mov	portout,ah
;	call	HexCharsOut
;	mov	portid,1
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG

	call	FilterKeys				; pass on code in Al

; Disable int. and then re-enable keyboard INTs at the interrupt controller

	cli						; Ints off again. NOTE: don't need
							; to turn them back on because we are
							; going to to an IRET when we finish.

	cmp	fbios_called_direct,true  		; did we pass on to ROM routine?
	je	keybd_int_ret				; yes, so no need to reset it again
							; and no need to re-enable jeyboard as original
							; BIOS routine already did if it was supposed to

	cmp	fFilterKeysOn,true			; is FilterKeys on ???
	jne	keybd_int_end				; if not, this must have been a stickeys eat or something

	cmp	fbios_called_timing,true		; Does the timer want to let a key pass ? (FROM FILTERKEYS ONLY)
	jne	keybd_int_end				; if not, exit w/o out calling old int 9 kybd routine

kybd_int_25:

	cmp	fclick_on,true
	jne	kybd_int_40

	cmp	fshift_click,true
	je	kybd_int_40

	cmp	current_shift,0
	jne	kybd_int_40				; if not a modifier key, call click
	mov	fshift_click,true			; if we clicked once, set, as non-modifier will clear
	call	click

kybd_int_40:

	mov	fbios_called_timing,false		; reset flag
	mov	fkey_not_passed,false			; reset flag

	push	ds
	pushf
	call	dword ptr cs:old_kybd_int
	pop	ds

; any other clean up to do,like reset stickey flags ???

	cmp	fSticKeysOn,true
	jne	kybd_int_50
	cmp	flatch,true
	jne	kybd_int_50

	call	set_shift_states			; clear latched key(s) states
	mov	shift_flg,0				; clear shifted states

kybd_int_50:

	assume	ds:_TEXT
	jmp	keybd_int_ret		

;-----------------------------------------------------------------------


keybd_int_end:

; If we get here, then we did a call to FilterKeys, StickeyKeys,.....and we DID NOT want to
; call the Original BIOS, so we need to reset the kybd hardware ourselves to allow 
; any other key strokes to generate interrupts.


;IFDEF	BUG
;	mov	portid,3
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG


	in	al,kb_ctl				; reset interface chip (8042)
	mov	ah,al
	or	al,80h
	jmp	$ + 2					; jump delay for fast computers
	out	kb_ctl,al
	xchg	ah,al
	jmp	$ + 2					; jump delay for fast computers
	out	kb_ctl,al

	mov	al,020h					; acknowledge interrupt  (8259)
	jmp	$ + 2					; jump delay for fast computers
	out	ack_port,al

	cmp	_comp_id,5				; do we have an AT class machine
	jne	keybd_int_ret				; if not, cont.

	mov	al,ena_kbd				; if yes, disable keyboard
	call 	ship_it

keybd_int_ret:

;IFDEF	BUG
;	mov	portid,2
;	mov	portout,al
;	call	HexCharsOut
;ENDIF;	BUG

	pop	es

	assume	ES:NOTHING
	pop	bx
	pop	ax					; restore the world
	pop	ds

	assume	DS:NOTHING

	pop	ax					; save value of ax
	cmp	al,1					; which time are we ???
	je	kybd_int_ret_3

	mov	ss,cs:kybd_ss_save
	mov	sp,cs:kybd_sp_save
	mov	cs:fint9_active_temp,0			; clear my flag since I'm out finally

kybd_int_ret_3:

	pop	ax
	iret						; also clears any int. which were set

_keybd_int	endp

;;----------------------------------------------------------------------------
; speed_timer_int 
;
; increments the counts used in the time out and key delay repeat options for setting up
; the beep sounds on the various computers.  This routine is called during initialization only.


speed_timer_int	PROC

	push	ds
	push	cs
	pop	ds
	assume DS:_TEXT

	dec	count_down_ticks	; decrement the count

	pushf
	call	dword ptr cs:old_1C_int	; call original interrupt

	pop	ds
	assume	DS:NOTHING

	iret

speed_timer_int	endp

;----------------------------------------------------------------------------
;****************************************************************************
;----------------------------------------------------------------------------
; Enable_Handicap
;----------------------------------------------------------------------------
;****************************************************************************
;----------------------------------------------------------------------------

Enable	PROC	NEAR

	push	ds					; save registers used
	push	es
	push	si
	push	di
	push	dx
	push	cx
	push	bx
	push	ax

	assume DS:_TEXT

; reset key_data buffer to empty, i.e. point head and tail to the start of the buffer

	mov	bx,OFFSET key_data			; get address of key_data buffer
	mov	key_data_head,bx			; reset head pointer to start of buffer
	mov	key_data_tail,bx			; reset tail pointer to start of buffer

; reset mouse_data buffer to empty, i.e. point head and tail to the start of the buffer

	mov	bx,OFFSET mouse_data			; get address of mouse_data buffer
	mov	mouse_data_head,bx			; reset head pointer to start of buffer
	mov	mouse_data_tail,bx			; reset tail pointer to start of buffer
	mov	mouse_cnt,false				; 

	print	mesg60					; tell user we are loading


ena_2:

;------------------------------------------------------------------------------
; Enable serial port COMM 1/2 at 9600, n, 8, 1 if DEBUG is On
IFDEF	BUG

	cli
;	cmp	_comp_id,8				; am I on the PS2 Model 70 ?
;	je	com_set_20
	mov	dx,0   					; com1
	mov	ah,0					; init com port
	jmp	short com_set_30
;
;com_set_20:
;
;	mov	dx,1   					; com2
;	mov	ah,0					; init com port
;
com_set_30:

	mov	al,0e3h					; 9600 baud, 1 stop bit, no parity, 8 data bits
;	mov	al,043h					; 300 baud, 1 stop bit, no parity, 8 data bits

	int	14h

;	mov	fserial_debugging,true
	mov	al,_vector
	mov	portid,0fh
	mov	portout,al
	call	HexCharsOut
;	mov	fserial_debugging,false

	sti
ENDIF;BUG


;---------------------------------------------------------------------------
; Check if DOS version 3.0 or higher, so we know if we have support for DOS int2f

	mov	ah,30h					; call int21h with al=30h
	int	21h					; major version # in al, minor version # in ah
	cmp	al,3					; if 3 or higher, then int2f supported
	jge	ena_4
IFDEF	BUG
	print 	mesg45					; message that pre 3.0 version of DOS is running
ENDIF;	BUG
	jmp	short ena_10


ena_4:
;IFDEF	BUG
;	print	mesg46					; running DOS 3.0 or higher
;ENDIF;	BUG

;---------------------------------------------------------------------------
; check if AccesDos was started under Windows 3.0 in real, standard or enhanced mode ?

	mov	ax,1600h				; code to ask Windows if running enhanced ?
	int	2fh					; DOS int call
	test	al,7fh					; if al=0 or 80h, then Windows enhanced in NOT running
	jz	ena_5					; if jump, enhanced not running, go check if real or standard ?

	assume	DS:_TEXT

	mov	fwindows,true				; flag set true if we are in Windows
	mov	fwindows_enh,true			; flag that we are in Windows enhanced mode
	mov	fwindows_st_re,false

;IFDEF	BUG
;	print	mesg41					; tell users program started under Windows Enhanced
;ENDIF;	BUG

	jmp	short ena_10				; no need to hook int2f if ADOS started after Windows

ena_5:

	mov	ax,4680h				; code to ask Windows if real or standard
	int	2fh					; DOS int call
	cmp	ax,0					; if ax=0, then real or standard Windows is running
	jne	ena_8					; if not, running Windows, hook int 2fh incase 

	assume	DS:_TEXT							; Windows is started after us

	mov	fwindows,true				; if ax=0, then we are in real or standard mode
	mov	fwindows_st_re,true			; flag that we are in Windows standard or real mode
	mov	fwindows_enh,false


;IFDEF	BUG
;	print	mesg42					; tell user
;ENDIF;	BUG
	jmp	short ena_10				; no need to hook int2f if ADOS started after Windows
ena_8:

;-----------------------------------------------------------------------------
; get INT 2Fh vector and save away
; Need to hook into int2Fh to watch if Windows is loaded after Access Dos
    				
	assume ES:NOTHING
	mov	ax,352fh
	int	21h
	mov	word ptr [old_2f_int_off],bx
	mov	word ptr [old_2f_int_seg],es

;-----------------------------------------------------------------------------
; get INT 2fh vector and save away

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _int2f			; hook int. 2fh also
	mov	ax,252fh
	int	21h
	pop	ds

ena_10:

;-----------------------------------------------------------------------------
	cmp	_vector,09				; do we hook int 9 or int 15
	jne	ena_10A

	mov	ax,3509h				; get INT 09h vector and save away
	jmp	short ena_10B

ena_10A:

	mov	ax,3515h				; get INT 15h vector and save away
ena_10B:
	
	int	21h
	mov	word ptr [old_kybd_int_off],bx
	mov	word ptr [old_kybd_int_seg],es

;----------------------------------------------------------------------------
; Setup timer interrupt vector to point to our interrupt routine
; get INT 1Ch vector and save away in old_timer_int this time
; NOTE: Original timer 08h must have been previously restored above.

	assume ES:NOTHING
	mov	ax,351Ch
	int	21h
	mov	word ptr [old_1C_int_off],bx
	mov	word ptr [old_1C_int_seg],es

;----------------------------------------------------------------------------
; Setup timer interrupt vector to point to our speed timer interrupt routine

	push	ds				; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET speed_timer_int
	mov	ax,251Ch
	int	21h				; set the vector
	pop	ds

	xor	ax,ax
	mov	count_down_ticks,2
;
; The way we will do this is to simulate the exact same set of code that
; is our beep routine.  There will be some overhead, but hopefully it will
; not factor into the accuracy that much.  We will keep track of how many
; times we will be able to get through the beep routine before we
; get through 1 tick of the real time timer.

ena11:

	cmp	count_down_ticks,1
	jg	ena11
;
; 46h is the value for a 2000hz square wave running on a PC.  Therefore,
; there would be about 110 cycles within the 18.2 clock (54.95ms).
; If we do 5 cycles, then the count in AX would be 22.  Assume that a fast
; 386 machine running at 25Mhz is about 15 times faster than a PC so AX
; in the upper range would be 330.
;

	cmp	fwindows,true
	jne	ena12			; if Windows isn't running, don't need cli
	cli

ena12:
	mov	cx,46h			; test tone, length of square cycle
	mov	bx,5			; length of test tone

	push	ax			; save ax, count
	IN	al,kb_ctl		; get keyboard control
	push	ax			; save
	push	cx			; save cx=wave length
ena13:	
	and	al,0ffh			; set speaker bits, really don't
	OUT	kb_ctl,al		; send out to speaker
	pop	cx			; get cx=wave length
	push	cx			; save cx
ena14:	
	loop	ena14			; keep on for wave length of time
	or	al,0			; set speaker bit, really don't
	OUT	kb_ctl,al		; send out to speaker
	pop	cx			; get cx
	push	cx			; save cx
ena15:	
	loop	ena15			; keep off for wave length of time
	dec	bx			; decrement length of tone
	jnz	ena13			; loop if not zero

	pop	cx			; restore cx
	pop	ax			; get old keyboard control
	OUT	kb_ctl,al		; send out
	pop	ax			; restore old ax


	sti
;
; Now keep track of count
;

	inc	ax			; increment count

	cmp	count_down_ticks,0	; are we done?
;;	ja	ena12			; no
	jg	ena12			; if count_down_ticks is >= to zero,loop again
					; make this a signed check so if we miss it, FFFF
					; is -1, and we will pass
;--------------------------------------------------------------------------------
; for some unknown reason, if running under Windows, especially enhanced mode, the DOS
; timer doesn't seem to handle the speed timer routine correctly all the time, so we will
; check the "ax" register value here to see if it messed up

	cmp	fwindows,true		; did we find out earlier that Window is running ?
	jne	ena_20
	cmp	ax,80			; Low end 8/10 Mhz Model 50/60 value we might expect for Windows
	jg	ena_20			; if ax from speed loop is higher, don't change
	mov	ax,150			; otherwise override Windows loop to 150 decimal

ena_20:
; for a 4.77 MHz PC, the count in ax should be about 22
; for a 16   MHz PC, the count in ax should be about 165
; for a 25   MHz PC, the count in ax should be about 330

	mov	cx,ax			; save a copy in cx
	mov	ax,46h			; put tone value in ax
	mul	cx			; multiply by number of times through
	mov	bx,22			; normalize to standard pc
	div	bx

	mov	high_tone,ax

	mov	turn_off_start_beep,ax

	shl	ax,1			; multiply by 2 to get 1000hz
	mov	turn_on_start_beep,ax

	shl	ax,1			; multiply by 2 to get 500hz
	mov	low_tone,ax

	mov	ax,turn_on_start_beep		; get 1000hz back
	sub	ax,turn_off_start_beep		; get difference

	mov	bx,100				; 100 steps
	xor	dx,dx
	div	bx

	mov	on_off_change,ax

	cmp	ax,00				; did on_off_change crank out to be ZERO ??
	jne	ena25				; if not, things should be okay, so cont

	mov	on_off_change,1			; if it was ZERO, very slow computer, so override prev. calc.

ena25:

;-----------------------------------------------------------------------------
	cmp	fmouse_driver,false
	je	ena_100				; if we didn't find a mouse, do not need to hook into any of these

;-----------------------------------------------------------------------------
; get INT 33h vector and save away
; Need to hook into int33h for either serial or PS/2 mouse

	assume ES:NOTHING
	mov	ax,3533h
	int	21h
	mov	word ptr [old_33_int_off],bx
	mov	word ptr [old_33_int_seg],es

;-----------------------------------------------------------------------------
; PS/2 MOUSE
;
; If we get here, we found a PS/2 mouse, so we need to check which computer we are on

	assume ES:NOTHING

	cmp	_comp_id,6			; Int 71h is for computer id=6, 25..30/86
	jne	ena_70				; if not equal, jump to other PS/2 mouse int

	mov	ax,3571h			; get INT 71h vector and save away
	jmp	short ena_75
ena_70:
						; If we get here, then we should have computer id = 7 or 8
	mov	ax,3574h			; get INT 74h vector and save away
ena_75:

	int	21h
	mov	word ptr [old_ps2mou_int_off],bx
	mov	word ptr [old_ps2mou_int_seg],es

ena_100:

;-------------------------------------------------------------------------------------
; Setup kybd interrupt vector to point to our interrupt routine

	cmp	_vector,09h				; do we hook int9 or int 15 ?
	jne	ena_102

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _keybd_int			; hook into int. 09h, keyboard
	mov	ax,2509h
	int	21h					; set the vector
	pop	ds
	jmp	short ena_103

ena_102:
	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _keybd_int_15			; hook into int. 15h of the keyboard interrupt
	mov	ax,2515h
	int	21h					; set the vector
	pop	ds

ena_103:

; if not on during a call to Enable, serialkeys will not be loaded, so we don'y have to check the other flags

	cmp	_serialKeysOn,true			; is SerialKeys code on ?
	jne	ena_104

	push	ds
;	call	_serialKeysInit     			; initialize serial keys
	call	_serialKeysEnableFar
	pop	ds


ena_104:
;-------------------------------------------------------------------------------------
; Setup 1C timer interrupt vector to point to our interrupt routine

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _new_timer_int		; hook into int. 1Ch, timer
	mov	ax,251Ch
	int	21h					; set the vector
	pop	ds

;---------------------------------------------------------------------------------------

	cmp	fmouse_driver,false			; did we load a mouse driver ???
	je	ena_200					; if not, quit

;---------------------------------------------------------------------------------------
; Setup interrupt 33h vector to point to our interrupt routine. we need int33h for either serial or PS/2 mouse

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _int33			; hook int. 33h also
	mov	ax,2533h
	int	21h
	pop	ds

;-----------------------------------------------------------------------------
; get INT 71h vector and save away
; If we get here, we found a PS/2 mouse, so we need to check which computer we are on

	cmp	_comp_id,6				; Int 71h is for computer id=6, 25..30/86
	jne	ena_140					; if not equal, jump to other PS/2 int

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _intps2mou			; hook int. 71h also
	mov	ax,2571h
	int	21h
	pop	ds
	jmp	ena_200				

ena_140:
;-----------------------------------------------------------------------------
; get INT 74h vector and save away
; If we get here, then we should have computer id = 7 or 8

	push	ds					; SAVE DS for restore
	mov	ax,cs
	mov	ds,ax
	mov	dx,OFFSET _intps2mou			; hook int. 74h also
	mov	ax,2574h
	int	21h
	pop	ds

ena_200:

	pop	ax
	pop	bx					; restore registers
	pop	cx
	pop	dx
	pop	di
	pop	si
	pop	es
	pop	ds

	ret	


Enable	endp

_TEXT	ends

	end




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\hexout.asm ===
;----------------------------------------------------------------------------
; HexCharsOut
;
; Expects: 	portout = the byte
;		portid	= the ID of where the byte originated
;
; Returns:	Nothing
;
; Changes:	Nothing
;----------------------------------------------------------------------------

	TITLE HexCharsOut

INCLUDE	keyboard.inc

	EXTRN	_comp_id:byte				; from Handicap.asm
	EXTRN	old_row:byte
	EXTRN	old_col:byte
	EXTRN	fserial_debugging:byte

IFDEF	BUG

	EXTRN	portid:byte
	EXTRN	portout:byte

ENDIF; BUG

_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;-----------------------------------------------------------------------------

temp_col	DB	00				; temporary col. count

HexCharsTable	DB	"0123456789ABCDEF"



serialout	PROC	NEAR

	assume	DS:_TEXT
	
	mov	ah,1
;	cmp	_comp_id,8
;	je	SO_10
	mov	dx,0					; for COMM 1
	jmp	short SO_20

SO_10:

	mov	dx,1					; for COMM 2
SO_20:

	int	14h
	ret	  

serialout	endp
;-----------------------------------------------------------------------------

print	proc	near

	assume	DS:_TEXT

	push	bx
	push	cx
	push	dx
	push	ax


	mov	ah,3					; read current cursor position
	mov	bh,0					; page 0
	int	10h					; video interrupt
	mov	old_row,dh				; save current row
	mov	old_col,dl				; save current column

	cmp	temp_col,70
;	cmp	temp_col,130
	jl	print_5
	mov	temp_col,0

print_1:

	mov	ah,2					; prepare to set current position
	mov	dh,23					; row 23
;	mov	dh,43
	mov	dl,temp_col    				; column 0 to start
	int	10h

	mov	al,32
	mov	cx,1					; line of spaces
	inc	temp_col
	mov	ah,0ah
	int	10h

	cmp	temp_col,70
;	cmp	temp_col,130
	jle	print_1
	mov	temp_col,0

print_5:
	mov	ah,2					; prepare to set current position
	mov	dh,23					; row 23
;	mov	dh,43
	mov	dl,temp_col    				; column 0 to start
	int	10h
	inc	temp_col

; character to write is in al

print_10:

	pop	ax
	mov	dx,ax
	push	ax

	mov	al,dl
	mov	ah,0ah					; write a character to the screen Text
	mov	cx,1					; write 1 character
	int	10h


	mov	ah,2					; restore current cursor position
	mov	dh,old_row
	mov	dl,old_col
	mov	bh,0
	int	10h

	pop	ax
	pop	dx
	pop	cx
	pop	bx


	ret

print	endp

	PUBLIC	HexCharsOut

HexCharsOut	PROC
	
;	push	cs
;	pop	ds
	assume DS:_TEXT


	push	ax
	push	dx
	push	si
	push	bx
	push	cx
	push	ds

;	mov	ax,@data
;	mov	ds,ax



;--------------------------------------------------------------------

	mov	cl,4
	xor	ax,ax				; clear ax register

	mov	ah,portid			; put byte in AH
	and	ah,0f0h				; high nibble first
	mov	al,ah
	rcr	al,cl				; rotate right 4 bits
	xor	ah,ah
	mov	si,ax
	mov	bx,Offset HexCharsTable
	mov	al,[bx+si]			; move contents of address bx + si into  al

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_15

	call	serialout
	jmp	short HCO_20
HCO_15:
	call	print

HCO_20:
	xor	ax,ax

	mov	ah,portid		
	and	ah,0fh				; low nibble second
	mov	al,ah
	xor	ah,ah
	mov	si,ax
	mov	bx,Offset HexCharsTable
	mov	al,[bx+si]

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_25

	call	serialout
	jmp	short HCO_30

HCO_25:
	call	print
HCO_30:

;---------------------------------------------------------------------
	mov	al,32

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_35

	call	serialout
	jmp	short HCO_40

HCO_35:
	call	print

HCO_40:
;---------------------------------------------------------------------

	xor	ax,ax

	mov	ah,portout			; put byte in AH
	and	ah,0f0h				; high nibble first
	mov	al,ah
	rcr	al,cl				; rotate right 4 bits
	xor	ah,ah
	mov	si,ax
	mov	bx,Offset HexCharsTable
	mov	al,[bx+si]

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_45

	call	serialout
	jmp	short HCO_50
HCO_45:
	call	print
HCO_50:

	xor	ax,ax

	mov	ah,portout	
	and	ah,0fh				; low nibble second
	mov	al,ah
	xor	ah,ah
	mov	si,ax
	mov	bx,Offset HexCharsTable
	mov	al,[bx+si]

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_55

	call	serialout
	jmp	short HCO_60
HCO_55:
	call	print
HCO_60:
;---------------------------------------------------------------------
	mov	al,32

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_65

	call	serialout
	jmp	short HCO_70
HCO_65:
	call	print
HCO_70:
;----------------------------------------------------------------------
	
	mov	ah,portout
	cmp	ah,0e0h				; hidden E0 ?
	je	HexCharsOutEnd

	cmp	ah,0e1h				; hidden E1 ?
	je	HexCharsOutEnd

	and	ah,80h				; is it the Break of a Key
	cmp	ah,0
	je	HexCharsOutEnd

	mov	al,0dh				; carriage return

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_75

	call	serialout
	jmp	short HCO_80
HCO_75:
;	call	print

HCO_80:

	mov	al,0ah				; line feed

	cmp	fserial_debugging,true		; are we to send out serial port ?
	jne	HCO_85

	call	serialout
	jmp	short HCO_90

HCO_85:
;	call	print

HCO_90:

;-----------------------------------------------------------------------	

HexCharsOutEnd:	

	pop	ds

	assume DS:NOTHING
	pop	cx
	pop	bx
	pop	si
	pop	dx
	pop	ax	

	ret

HexCharsOut	endp

_TEXT	ends

	end













=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\init.h ===
/*  INIT.H   */

void selectInjectMethod(void);
void serialKeysInit(void);
void serialKeysStartupInit(void);
void serialKeysStateInit(void);
void initGIDEI(void);

void serialKeysBegin(void);

void errorCode(BYTE errorNum);
void writeCommPort(void);
void errDetect(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\kbd.h ===
/* KBD.H  */


void processKbdPress(void);
void processKbdCombine(void);
void processKbdHold(void);
void processKbdLock(void);
void processKbdRel(void);
BOOL validKCode(void);

void processKbd(void);
void processKbdIndicator(void);
void processKbdVersion(void);
void processKbdModel(void);
void processKbdDescription(void);
void processKbdUnknown(void);


BOOL inLst(struct listType *listPtr, BYTE searchChar);

void removeKeyFromHoldList(BYTE theKey);
void removeKeyFromLockList(BYTE theKey);

void doPressLst(void);
void doCombineLst(void);

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\int9.h ===
/*  INT9.H  */


BOOL keyAffectedByCaps (unsigned char key);
BOOL keyAffectedByNum (unsigned char key);
void kbdBufferInjectKeysRoutine (BYTE key);
void injectDownInKbdBuffer (unsigned char key);
void injectUpInKbdBuffer (unsigned char key);






















=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\kbd.c ===
/* KBD.C  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "kbd.h"
#include "drv.h"
#include "init.h"


/****************************************************************************

	FUNCTION:	processKbdPress(void);

	SYNTAX:		<esc> <press code> [param1] [,param2] [,param3] ... [,param5] <term code>
					at this point, we already have <press code>

	COMMENTS:	With PRESS, each key gets typed individually.
					For example, if string is  a,b,left,f1.  then the sequence goes like:
					a-down, a-up, b-down, b-up, left-down, left-up, f1-down, f1-up.
*/
void processKbdPress(void)
{
	if (gCode==TERMCODE) doPressLst();				/* if term, process the list	*/
	else {													/* if no room for code, ignore	*/
		if (tmpLst.len<MAXLISTLEN && validKCode())	/* if not illegal param, continue*/
																/* If LOCKed or HOLDed, ignore	*/
			if (!inLst(&kLock,gCode) && !inLst(&kHold,gCode))
				tmpLst.list[tmpLst.len++] = gCode;	/* Finally! add to list	*/
		}
}


/****************************************************************************

	FUNCTION:	processKbdCombine(void)

	SYNTAX:		<esc> <combine code> [param1] [,param2] [,param3] ... [,param5] <term code>
					at this point, we already have <combine code>

	COMMENTS:	With COMBINE, the keys are typed in combination.
					For example, if string is  a,b,left,f1.  then the sequence goes like:
					a-down, b-down, left-down, f1-down, f1-up, left-up, b-up, a-up.


*/
void processKbdCombine(void)
{
	if (gCode==TERMCODE) doCombineLst();			/* if term, process the list	*/
	else {													/* if no room for code, ignore	*/
		if (tmpLst.len<MAXLISTLEN && validKCode())	/* if not illegal param, continue*/
																/* If LOCKed HOLDed, ignore	*/
			if (!inLst(&kLock,gCode) && !inLst(&kHold,gCode)) {
				if (!inLst(&tmpLst,gCode))				/* duplicates NOT ok here */
					tmpLst.list[tmpLst.len++] = gCode;
				}

		}
}

/****************************************************************************

	FUNCTION:	processKbdHold(void)

	SYNTAX:		<esc> <hold code> [param1] [,param2] [,param3] ... [,param5] <term code>
					at this point, we already have <hold code>

	COMMENTS:	With HOLD, the keys are put in list to be typed later - after next char
					mode char or press/combine escape sequence.
					For example, if string is:      <esc>,hold,shift. a
					then the shift gets saved until after the "a" and the sequence goes like
					shift-down a-down, a-up, shift-up. The routines doPressLst() and
					doCombineLst() will type the hold keys at the appropriate time.  Here we
					simply put the keys in the kHold list for use later.

*/
void processKbdHold(void)
{
	int i;

	if (gCode==TERMCODE) {								/* term, transfer keys to kHold	*/
		for (i=0; i < tmpLst.len; kHold.list[kHold.len++]=tmpLst.list[i++]);
																/* note: if empty list, nop	*/
		tmpLst.len = 0;									/* clear out tmpLst	*/
		}
	else
		if (((tmpLst.len+kHold.len) < MAXLISTLEN)	/* if no room for code, ignore	*/
				&& validKCode()) {						/* if not illegal param, continue*/
																/* if LOCKed or HOLDed, ignore	*/
			if (!inLst(&kLock,gCode) && !inLst(&kHold,gCode))
				if (!inLst(&tmpLst,gCode))				/* duplicates NOT ok here */
					tmpLst.list[tmpLst.len++] = gCode;
			}
}



/****************************************************************************

	FUNCTION:	processKbdLock(void)

	SYNTAX:		<esc> <lock code> [param1] [,param2] [,param3] ... [,param5] <term code>
					at this point, we already have <lock code>

	COMMENTS:	With lock, the keys are put in list to be locked down i.e. only
					their down code is sent.  They are later released with a REL command.
					For example, if string is:      <esc>,lock,shift.
					the sequence goes like:   shift-down

*/
void processKbdLock(void)
{
	int i;
	BYTE temp;

	if (gCode == TERMCODE) {							/* if term, transfer keys to	*/
		for (i=0; i < tmpLst.len; i++) {				/*  kLock and send down codes.	*/
			temp = tmpLst.list[i];						/*  note: if empty list, nop	*/
			kLock.list[kLock.len++] = temp;
			(*scanDownTransVector)(temp);
			removeKeyFromHoldList(temp);				/* if key was in hold list	*/
			}													/*  remove cuz lock has priority	*/
		tmpLst.len = 0;									/* clear out tmpLst	*/
		}
	else if (((tmpLst.len+kLock.len)<MAXLISTLEN)	/* if no room for code, ignore	*/
				&& validKCode())							/* if not illegal param, continue*/
		if (!inLst(&kLock,gCode)) {					/* if LOCKed ignore	*/
			if (!inLst(&tmpLst,gCode))					/* duplicates NOT ok here */
				tmpLst.list[tmpLst.len++] = gCode;
			}
}



/****************************************************************************

	FUNCTION:	processKbdRel(void)

	SYNTAX:		<esc> <rel code> [param1] [,param2] [,param3] ... [,param5] <term code>
					at this point, we already have <rel code>

	COMMENTS:	REL is used to release keys that were LOCKed (i.e. remove them from
					kLock, and send their up codes) and to remove keys from the kHold list
					(i.e. remove them before they can be acted on).  You can release
					individual keys or all keys.  If no param is given, then all keys
					will be release/removed.

*/
void processKbdRel(void)
{
	int i;

	if (gCode == TERMCODE) {							/* if term, now process	*/
		if (!tmpLst.len) {								/* if list empty, rel all keys	*/
			for (i=0; i < kLock.len; (*scanUpTransVector)(kLock.list[i++]));
			kLock.len=0;									/* rel all locks	*/
			kHold.len = 0;									/* rel all holds	*/
			}
		else {												/* not empty so rel one by one	*/
			for (i=0; i<tmpLst.len; i++) {
				removeKeyFromLockList(tmpLst.list[i]);
				removeKeyFromHoldList(tmpLst.list[i]);
				}
			tmpLst.len = 0;								/* clear tmpList	*/
			}
		}
	else {													/* if no room for code, ignore	*/
		if (tmpLst.len<MAXLISTLEN && validKCode())	/* if not illegal param, continue*/

			/* Even if not LOCKed or HOLDed put key in list in case program and	*/
			/*  computer get out of synch		*/
			if (!inLst(&tmpLst,gCode))
				tmpLst.list[tmpLst.len++] = gCode;
		}
}




BOOL validKCode(void)
{
	int i;

	/* search table of valid codes for gCode */
	for (i=0; okKeyTbl[i] && (okKeyTbl[i] != gCode); i++);
	if (!okKeyTbl[i]) {
		errDetect();
		return FALSE;
		}
	else return TRUE;
}



BOOL inLst(struct listType *listPtr, BYTE searchChar)
{
	int i;
	BOOL found;

	found = FALSE;
	for (i=0; !found && (i < listPtr->len); i++)
		found = (listPtr->list[i] == searchChar);
	return (found);

}


void doPressLst(void)
{
	int i;

	/* notice, if lists are empty, nothing is done */
	for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));
	for (i=0; i < tmpLst.len; i++) {
		(*scanDownTransVector)(tmpLst.list[i]);
		(*scanUpTransVector)(tmpLst.list[i]);
		}
	for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
	kHold.len = tmpLst.len = 0;
	return;
}

void doCombineLst(void)
{
	int i;

	/* notice, if lists are empty, nothing is done */
	for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));
	for (i=0; i < tmpLst.len; (*scanDownTransVector)(tmpLst.list[i++]));
	for (i=tmpLst.len; i > 0; (*scanUpTransVector)(tmpLst.list[--i]));
	for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
	kHold.len = tmpLst.len = 0;
	return;
}

void removeKeyFromHoldList(BYTE theKey)
{
	int new,old;

	for (new=old=0; old < kHold.len; old++)
		if ((kHold.list[new] = kHold.list[old]) != theKey) new++;
	kHold.len = new;
}

void removeKeyFromLockList(BYTE theKey)
{
	int new,old;

	for (new=old=0; old < kLock.len; old++) {
		if ((kLock.list[new] = kLock.list[old]) != theKey) new++;
		else (*scanUpTransVector)(theKey);
		}
	kLock.len = new;
}



/****************************************************************************

	FUNCTION:

	PURPOSE:
				

	COMMENTS:

*/
void processKbd(void)
{
	switch (gCode) {
		case KBDINDICATORCODE:
			cmdVector = processKbdIndicator;
			aliasPtr = kbdIndicatorAliasTable;
			beginOK = TRUE;
			break;

		case KBDVERSIONCODE:
			cmdVector = processKbdVersion;
			aliasPtr = kbdVersionAliasTable;
			beginOK = TRUE;
			break;

		case KBDMODELCODE:
			cmdVector = processKbdModel;
			aliasPtr = kbdModelAliasTable;
			beginOK = TRUE;
			break;

		case KBDDESCRIPTIONCODE:
			cmdVector = processKbdDescription;
			aliasPtr = kbdDescriptionAliasTable;
			beginOK = TRUE;
			break;

/*		case KBDUNKNOWNCODE:
			cmdVector = processKbdUnknown;
			aliasPtr = kbdUnknownAliasTable;
			beginOK = TRUE;
			break;
*/
		default:
			if (gCode < LOWESTGIDEICODE) errDetect();
			else {
				errDetect();
/*				cmdVector = noOpRoutine;
				beginOK = TRUE;
*/
				}
			break;
		}
	return;
}


void processKbdIndicator(void)
{
	return;
}

void processKbdVersion(void)
{
	return;
}

void processKbdModel(void)
{
	return;
}

void processKbdDescription(void)
{
	return;
}

void processKbdUnknown(void)
{
	return;
}





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\int9.c ===
/*  INT9.C  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "drv.h"
#include "int9.h"
#include "serkeys.h"
#include "init.h"
#include <dos.h>
#include <stdio.h>


/****************************************************************************/
BOOL keyAffectedByCaps (unsigned char key)
{
	int i;

	for (i=0; capsKeysTbl[i] && (capsKeysTbl[i] != key); i++);
	return (capsKeysTbl[i]);
}

/****************************************************************************/
BOOL keyAffectedByNum (unsigned char key)
{
	int i;

	if (key == kpperiod_key) return TRUE;
	for (i=0; keyPadKeysTbl[i] && (keyPadKeysTbl[i] != key); i++);
	return (keyPadKeysTbl[i]);
}


/****************************************************************************/
void kbdBufferInjectKeysRoutine (BYTE key)
{

	if (!inPauseCondition()) inPauseFlag = FALSE;
	if (key & 0x80) injectUpInKbdBuffer((BYTE)(key & 0x7f));
	else injectDownInKbdBuffer(key);
}


/****************************************************************************/
void injectDownInKbdBuffer (BYTE key)
{
	union {
		struct scanCodeType codes;
		unsigned int codeWord;
		BYTE ascii, scan;
		} tmp;
	int i;

	getBiosFlags();

	/* check for modifying key */
	switch (key) {
		case ignoreCode:
			altKeypad = 0;
			break;
		case lcontrol_key:
			kbFlag |= CTRL_DOWN_MASK;
			kbFlag1 |= LCTRL_DOWN_MASK;
			break;
		case rcontrol_key:
			kbFlag |= CTRL_DOWN_MASK;
			kbFlag2 |= RCTRL_DOWN_MASK;
			break;
		case lalt_key:
			kbFlag |= ALT_DOWN_MASK;
			kbFlag1 |= LALT_DOWN_MASK;
			break;
		case ralt_key:
			kbFlag |= ALT_DOWN_MASK;
			kbFlag2 |= RALT_DOWN_MASK;
			break;
		case lshift_key:
			kbFlag |= LSHIFT_DOWN_MASK;
			break;
		case rshift_key:
			kbFlag |= RSHIFT_DOWN_MASK;
			break;
		default:
			if (kbFlag & ALT_DOWN_MASK) {				/* is ALT key down? */
				if ((kbFlag & CTRL_DOWN_MASK) && ((key == delete_key) || (key == kpperiod_key))) {
					doReboot();
					}
				else {
					tmp.codes = scanTbl[key].alt;		/* get alt codes */
/*					if (tmp.codeWord == ignoreCode) altKeypad = 0;*/
					}
				}
			else {
				altKeypad = 0;
				if (kbFlag & CTRL_DOWN_MASK)					/* is CONTROL key down? */
					tmp.codes = scanTbl[key].ctrl;			/* get ctrl code */
				else if ((kbFlag & CAPS_MODE_MASK) && keyAffectedByCaps(key)) {
					if (kbFlag & (LSHIFT_DOWN_MASK | RSHIFT_DOWN_MASK))
						tmp.codes = scanTbl[key].base;		/* they cancel so get base code */
					else
						tmp.codes = scanTbl[key].shift;		/* get shift code */
					}
				else if ((kbFlag & NUM_MODE_MASK) && keyAffectedByNum(key)) {
					if (kbFlag & (LSHIFT_DOWN_MASK | RSHIFT_DOWN_MASK))
						tmp.codes = scanTbl[key].base;		/* they cancel so get base code */
					else
						tmp.codes = scanTbl[key].shift;		/* get shift code */
					}
				else if (kbFlag & (LSHIFT_DOWN_MASK | RSHIFT_DOWN_MASK))
					tmp.codes = scanTbl[key].shift;			/* get shift code */
				else tmp.codes = scanTbl[key].base;			/* just get base code */
				}
			switch (key) {
				case caps_key:
					if (!(kbFlag & CTRL_DOWN_MASK) && (!(kbFlag1 & CAPS_DOWN_MASK)))
						kbFlag ^= CAPS_MODE_MASK;
					kbFlag1 |= CAPS_DOWN_MASK;
					break;
				case numlock_key:
					if (!(kbFlag & CTRL_DOWN_MASK) && (!(kbFlag1 & NUM_DOWN_MASK)))
						kbFlag ^= NUM_MODE_MASK;
					kbFlag1 |= NUM_DOWN_MASK;
					break;
				case scroll_key:
					if (!(kbFlag & CTRL_DOWN_MASK) && (!(kbFlag1 & SCROLL_DOWN_MASK)))
						kbFlag ^= SCROLL_MODE_MASK;
					kbFlag1 |= SCROLL_DOWN_MASK;
					break;
				case insert_key:
					if (!(kbFlag1 & INSERT_DOWN_MASK))
						kbFlag ^= INSERT_MODE_MASK;
					kbFlag1 |= INSERT_DOWN_MASK;
					break;
				default:
					{
					}
				}


			if (kbFlag1 & PAUSE_MODE_MASK) {
				switch (key) {
					case caps_key:
					case scroll_key:
						if (kbFlag & CTRL_DOWN_MASK) kbFlag1 &= ~PAUSE_MODE_MASK;
						break;
					case insert_key:
						if (kbFlag & (CTRL_DOWN_MASK | ALT_DOWN_MASK)) kbFlag1 &= ~PAUSE_MODE_MASK;
						break;
					case numlock_key:
						break;
					default:
						kbFlag1 &= ~PAUSE_MODE_MASK;
					}
				if (!(kbFlag1 & PAUSE_MODE_MASK)) tmp.codeWord = ignoreCode;
				}
			else if (key == pause_key) {
				altKeypad = 0;
				if (kbFlag & CTRL_DOWN_MASK) {
					if (kbFlag & ALT_DOWN_MASK) {
						inPauseFlag = TRUE;
						kbFlag1 |= PAUSE_MODE_MASK;		/* pause */
						}
					else {
						handleBreak();							/* break */
						getBiosFlags();
						}
					}
				else {
					inPauseFlag = TRUE;
					kbFlag1 |= PAUSE_MODE_MASK;		/* pause */
					}
				}
			else if (key == print_key) {
				altKeypad = 0;
				if (kbFlag & ALT_DOWN_MASK) {			/* sys req */
					if (!(kbFlag1 & SYSREQ_DOWN_MASK)) {
						kbFlag1 |= SYSREQ_DOWN_MASK;
						_asm mov ax,0x8500;
						_enable();
						_asm	int 15h;
						}
					}
				else if (!(kbFlag & CTRL_DOWN_MASK)) _asm  int 05h;		/* print screen */
				}
			else if (kbFlag & ALT_DOWN_MASK) {
				for (i=0; keyPadKeysTbl[i] && (keyPadKeysTbl[i] != key); i++);
				if (keyPadKeysTbl[i]) altKeypad = (altKeypad * 10) + i;
				else {
					switch (key) {
						case caps_key:
						case numlock_key:
						case scroll_key:
						case insert_key:
							break;
						default:
							altKeypad = 0;
							break;
						}
					}
				}
			else altKeypad = 0;
			if (tmp.codeWord != ignoreCode) putInKbdBuffer(tmp.codeWord);
		}
	putBiosFlags();
}			



/****************************************************************************/
void injectUpInKbdBuffer (unsigned char key)
{
	unsigned int kpVal;

  	getBiosFlags();
	/* check for modifying key */
	switch (key) {
		case ignoreCode:
			break;
		case lcontrol_key:
			kbFlag1 &= ~LCTRL_DOWN_MASK;
			if (!(kbFlag2 & RCTRL_DOWN_MASK))
				kbFlag &= ~CTRL_DOWN_MASK;
			break;
		case rcontrol_key:
			kbFlag2 &= ~RCTRL_DOWN_MASK;
			if (!(kbFlag1 & LCTRL_DOWN_MASK))
				kbFlag &= ~CTRL_DOWN_MASK;
			break;
		case lshift_key:
			kbFlag &= ~LSHIFT_DOWN_MASK;
			break;
		case rshift_key:
			kbFlag &= ~RSHIFT_DOWN_MASK;
			break;
		case lalt_key:
			kbFlag1 &= ~LALT_DOWN_MASK;
			if (!(kbFlag2 & RALT_DOWN_MASK))
				kbFlag &= ~ALT_DOWN_MASK;
			if ((kpVal=altKeypad) != 0) {
				putInKbdBuffer(kpVal);
				altKeypad = 0;
				}
			break;
		case ralt_key:
			kbFlag2 &= ~RALT_DOWN_MASK;
			if (!(kbFlag1 & LALT_DOWN_MASK))
				kbFlag &= ~ALT_DOWN_MASK;
			if ((kpVal=altKeypad) != 0) {
				putInKbdBuffer(kpVal);
				altKeypad = 0;
				}
			break;
		case caps_key:
			kbFlag1 &= ~CAPS_DOWN_MASK;
			break;
		case numlock_key:
			kbFlag1 &= ~NUM_DOWN_MASK;
			break;
		case scroll_key:
			kbFlag1 &= ~SCROLL_DOWN_MASK;
			break;
		case insert_key:
			kbFlag1 &= ~INSERT_DOWN_MASK;
			break;
		case print_key:
			/* sys req */
			if (kbFlag1 & SYSREQ_DOWN_MASK) {
				kbFlag1 &= ~SYSREQ_DOWN_MASK;
				_asm mov ax,0x8501;
				_enable();
				_asm	int 15h;
				}
		default:
			{
			}
		}

	putBiosFlags();
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\init.c ===
/* init.C  */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "serkeys.h"
#include "gide.h"
#include "init.h"

#include "drv.h"
#include "int9.h"
#include <dos.h>
#include <string.h>
#include <stdio.h>



/***********************/
void selectInjectMethod(void)
{
	scanDownTransVector = downScanPS2;
	scanUpTransVector = upScanPS2;
	switch (skCompId) {
		case 8:
		case 7:
			/* D2 inject / int 15h 4Fh intercept monitor */
			injectKeysVector = D2InjectRoutine;
			break;

		case 2:
		case 90:
			/* write 3F / read 3F / replace / int 15h 4Fh intercept monitor */
			injectKeysVector = write3fInjectRoutine;
			break;

		case 91:
			/* 20 command byte read/ int 15h 4Fh intercept replace */
			injectKeysVector = write20InjectRoutine;
			break;

		case 6:
			/* write 60h / soft Int 9h / int 15h 4Fh intercept monitor */
			/* model 25/30 - 8086 */
			injectKeysVector = write60InjectRoutine;
			break;

		case 26:
			/* soft Int 9h / int 15h 4Fh intercept replace */
			injectKeysVector = int15InjectRoutine;
			break;

		case 5:
		case 4:
		case 3:
		case 1:
		default:
			/* keyboard buffer inject */
			scanDownTransVector = downScanAT;
			scanUpTransVector = upScanAT;
			injectKeysVector = kbdBufferInjectKeysRoutine;
			break;
		}
}

/***********************/

void serialKeysInit(void)
{
	skCompId = comp_id;

	selectInjectMethod();

	fatalErrorFlag = FALSE;
	handleFatalError = FALSE;
	needTimerHelp = FALSE;

	serialKeysStartupInit();
	serialKeysCommInit();
}

/**************************************************************************/
void serialKeysStartupInit(void)
{
	feCount = 0;

	initGIDEI();

	waitForInt9Timeout = INT9TIMEOUT;
	sendSoftHandshakeStatus = HANDSHAKETIMEOUT;
	timerCount = TIMERTIMEOUT;
	_asm mov byte ptr cs:forcedInt9Flag,FALSE
	inPauseFlag = FALSE;
	weInjectedFlag = FALSE;
	inSerialKeys = FALSE;
	tryingToWriteKeyboardData = FALSE;

	serialKeysStateInit();
	_asm mov byte ptr cs:injectByte,0
	putPosSBuf = commBuf;
	getPosSBuf = commBuf;
	numCommChars = 0;
	mouBufTailPtr = mouBuffer;
	mouBufHeadPtr = mouBuffer;

}

/**************************************************************************/
void serialKeysStateInit(void)
{
	mouseX = 0;
	mouseY = 0;
	mouseState = 0;

	kHold.len = 0;
	kLock.len = 0;


	kState.rShift = 0;
	kState.lShift = 0;
	kState.rCtrl = 0;
	kState.lCtrl = 0;
	kState.rAlt = 0;
	kState.lAlt = 0;
	getBiosFlags();
	if (kbFlag & NUM_MODE_MASK) kState.numlck = 1;
	else kState.numlck = 0;
	kbFlag &= ~(ALT_DOWN_MASK | CTRL_DOWN_MASK | LSHIFT_DOWN_MASK | RSHIFT_DOWN_MASK);
	kbFlag1 &= ~(LALT_DOWN_MASK | LCTRL_DOWN_MASK);
	kbFlag2 &= ~(RALT_DOWN_MASK | RCTRL_DOWN_MASK);
	putBiosFlags();

}


/**************************************************************************/
void initGIDEI(void)
{
	asciiTblPtr = asciiTable;
	aliasPtr = nullTable;
	serVector = charHandler;
	codeVector = processGideiCode;
	cmdVector = processCommand;
	ptrStackPtr = ptrStack;
	spos = 0;
	rpos = 0;
	putPosOBuf = outputBuf;
	getPosOBuf = outputBuf;
	mouBufTailPtr = mouBuffer;
	mouBufHeadPtr = mouBuffer;
	dataBlk.id = 0;
	lastCode = 0;
	serByte = 0;
	aliasStr[0] = '\0';
	gCode = 0;
	tmpLst.len = 0;
	passAll = FALSE;
	stdErrorFlag = FALSE;
	waitForClear = FALSE;
	beginOK = FALSE;
	tmpStatus = 0;
	tmpDist = 0;
	nullCount = 0;
	byteCount = 0;
	tempskBaudRate = skBaudRate;
}


/**************************************************************************/
void serialKeysBegin(void)
{

	if ((!passAll) && (serByte == NULLCHAR)) {	/* only if passAll = false */
		if (inp(MCR+skCommPortAddr) & (RTS_BIT | DTR_BIT))
			outp(THR+skCommPortAddr,XON);
		doBeep();
		if (++nullCount >= 3) {
			doBeep();
			_asm cli
			initGIDEI();									/* if 3 nulls then reset */
			disableKeyEnhance();
			_asm sti
			}
		else errorCode(0);								/* just beep if no reset */
		}
	else {
		nullCount = 0;										/* reset null count */
		(*serVector)();									/* vector to current routine */
		if (stdErrorFlag) {
			doBeep();
			_asm cli
			initGIDEI();
			_asm sti
			}
		}
}




/****************************************************************************/
void errorCode(BYTE errorNum)
{
	return;
}



/****************************************************************************

	FUNCTION:	writeCommPort(void)

	PURPOSE:	

	COMMENTS:	outputs string to comm port

*/

void writeCommPort(void)
{
	return;
}


/****************************************************************************/
void errDetect(void)
{
	errorCode(3);
	_asm cli
	initGIDEI();
	_asm sti
	doBeep();
	return;
}





=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\menudata.h ===
#define MENUDATA	1

typedef struct
{
	char *leftText;
	char *midText;
	char *rightText;
   char hotKey;
	int selectable;
	int hot;
	void (*dialogProcPtr)(void);
	void (*helpProcPtr)(void);
	int lastRecord;
   char *hintText;
} MENU_LIST_RECORD;


typedef struct
{
	char *leftText;
	char *midText;
	char *rightText;
   char hotKey;
	MENU_LIST_RECORD *menuList;
	int  lastRecord;
} MENU_BAR_RECORD;


typedef struct
{
	char *leftText;
	char *midText;
	char *rightText;
	char hotKey;
	int selectable;
	int hot;
	unsigned paramValue;
	int lastRecord;
} OPTION_LIST_RECORD;


typedef struct
{
	char *leftText;
	char *midText;
	char *rightText;
	char hotKey;
   int   selectable;
	OPTION_LIST_RECORD *optionList;
	void *paramPtr;
   int paramLength;
	int lastRecord;
	char *hintText;
} DIALOG_LIST_RECORD;


extern MENU_BAR_RECORD menuList[];
extern DIALOG_LIST_RECORD stickyKeysDialogList[], keyboardDialogList[], mouseKeysDialogList[], toggleKeysDialogList[];
extern DIALOG_LIST_RECORD serialKeysDialogList[], timeOutDialogList[], miscellaneousDialogList[], quitAccessDialogList[];


extern MENU_LIST_RECORD fileMenuList[], adjustMenuList[], helpMenuList[];

extern OPTION_LIST_RECORD dummyOptionList[];

extern OPTION_LIST_RECORD stickyKeysOnOption[], stickyFeedbackOption[], stickyTwoKeysOffOption[];
extern OPTION_LIST_RECORD stickyAudibleOption[], stickyClickOption[], stickyTriStateOption[];
extern DIALOG_LIST_RECORD stickyKeysDialogList[];


extern OPTION_LIST_RECORD slowKeysOnOption[], slowFeedbackOption[], slowClickOption[], slowAcceptanceOption[];
extern OPTION_LIST_RECORD repeatDelayOption[], repeatRateOption[], bounceTimeOption[];
extern DIALOG_LIST_RECORD keyboardDialogList[];


extern OPTION_LIST_RECORD mouseKeysOnOption[], mouseFeedbackOption[], mouseVelocityOption[], mouseAccelerationOption[];
extern DIALOG_LIST_RECORD mouseKeysDialogList[];


extern OPTION_LIST_RECORD toggleKeysOnOption[], toggleFeedbackOption[];
extern DIALOG_LIST_RECORD toggleKeysDialogList[];


extern OPTION_LIST_RECORD serialKeysOnOption[], serialBaudOption[], serialPortOption[];
extern DIALOG_LIST_RECORD serialKeysDialogList[];


extern OPTION_LIST_RECORD timeOutOnOption[], timeOutTimeOption[], timeOutFeedbackOption[];
extern DIALOG_LIST_RECORD timeOutDialogList[];


extern OPTION_LIST_RECORD visualNoteOnOption[];
extern OPTION_LIST_RECORD screenFlashOnOption[];
extern DIALOG_LIST_RECORD showSoundsDialogList[];


extern OPTION_LIST_RECORD spaceSaverOption[], computerOption[];
extern DIALOG_LIST_RECORD miscellaneousDialogList[];


/*extern DIALOG_LIST_RECORD quitAccessDialogList[];*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\menudata.c ===
#include "defines.h"
#include "globals.h"
#include "access.h"
#include "datablk.h"
#include "menudata.h"
#include "messages.h"
#include "dialogs.h"


MENU_LIST_RECORD fileMenuList[] =
{
	" ", "A", "bout AccessDOS... ", 'A',  SELECTABLE_YES,   FALSE, AboutAccess,		AboutAccess, 			FALSE,
         "View Information about this version of AccessDOS.",
	"",  "",  "",                   '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         "",
	" ", "S", "ave Settings...   ", 'S',  SELECTABLE_YES,   TRUE,  SaveParameters,	SaveParametersHelp,	FALSE,
         "Save the current AccessDOS settings.",
	"",  "",  "",                   '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         "",
	" ", "I", "nstall/Run...     ", 'I',  SELECTABLE_YES,   FALSE, InstallAccess,		InstallAccessHelp,	FALSE,
         "Install/Run AccessDOS with the current Settings.",
	" ", "C", "ancel/Quit...     ", 'C',  SELECTABLE_YES,   FALSE, CancelAccess,		CancelAccessHelp,		TRUE,
         "Cancel/Quit AccessDOS ignoring any changes made to settings.",
	"", "", "", '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         ""
};

MENU_LIST_RECORD adjustMenuList[] =
{
	" ", "S", "tickyKeys...        ", 'S',  SELECTABLE_YES,   TRUE,  StickyKeys,			StickyKeysHelp,		FALSE,
         "Make Adjustments to the StickyKeys feature.",
	" ", "M", "ouseKeys...         ", 'M',  SELECTABLE_YES,   FALSE, MouseKeys,			MouseKeysHelp,			FALSE,
         "Make Adjustments to the MouseKeys feature.",
	" ", "T", "oggleKeys...        ", 'T',  SELECTABLE_YES,   FALSE, ToggleKeys,			ToggleKeysHelp,		FALSE,
         "Make Adjustments to the ToggleKeys feature.",
	" ", "K", "eyboard Response... ", 'K',  SELECTABLE_YES,   FALSE, KeyboardPackage,	KeyboardPackageHelp,	FALSE,
         "Make Adjustments to the Keyboard Response feature.",
	"",  "",  "",                     '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         "",
	" S", "e", "rialKeys...        ", 'E',  SELECTABLE_YES,   FALSE, SerialKeys,			SerialKeysHelp,		FALSE,
         "Make Adjustments to the SerialKeys feature.",
	"",  "",  "",                     '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         "",
	" S", "h", "owSounds...        ", 'H',  SELECTABLE_YES,   FALSE, ShowSounds,			ShowSoundsHelp,		FALSE,
         "Make Adjustments to the ShowSounds feature.",
	" Time", "O", "ut...           ", 'O',  SELECTABLE_YES,   FALSE, TimeOut,				TimeOutHelp,			FALSE,
         "Make Adjustments to the TimeOut feature.",
	"",  "",  "",                     '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         "",
	" M", "i", "scellaneous...     ", 'I',  SELECTABLE_YES,   FALSE, Miscellaneous,		MiscellaneousHelp,	TRUE,
         "Make Miscellaneous adjustments.",
	"", "", "", '\0', SELECTABLE_NEVER, FALSE, DummyFunction,		DummyFunction,			FALSE,
         ""
};

MENU_LIST_RECORD helpMenuList[] =
{
	" Men", "u", " Help...              ", 'U',  SELECTABLE_YES,   TRUE,  MenuHelp,					MenuHelp,				FALSE,
         "View help on using the menu.",
	" ", "G", "eneral Help...           ", 'G',  SELECTABLE_YES,   FALSE, GeneralInfo,				GeneralInfo,			FALSE,
         "View some General Help Information.",
	"",  "",  "",                          '\0', SELECTABLE_NEVER, FALSE, DummyFunction,			DummyFunction,			FALSE,
         "",
	" ", "S", "tickyKeys Help...        ", 'S',  SELECTABLE_YES,   FALSE, StickyKeysHelp,			StickyKeysHelp,		FALSE,
         "View help for the StickyKeys feature.",
	" ", "M", "ouseKeys Help...         ", 'M',  SELECTABLE_YES,   FALSE, MouseKeysHelp,			MouseKeysHelp,			FALSE,
         "View help for the MouseKeys feature.",
	" ", "T", "oggleKeys Help...        ", 'T',  SELECTABLE_YES,   FALSE, ToggleKeysHelp,			ToggleKeysHelp,		FALSE,
         "View help for the ToggleKeys feature.",
	" ", "K", "eyboard Response Help... ", 'K',  SELECTABLE_YES,   FALSE, KeyboardPackageHelp,	KeyboardPackageHelp,	FALSE,
         "View help for Keyboard Response.",
	" S", "e", "rialKeys Help...        ", 'E',  SELECTABLE_YES,   FALSE, SerialKeysHelp,			SerialKeysHelp,		FALSE,
         "View help for the SerialKeys feature.",
	" S", "h", "owSounds Help...        ", 'H',  SELECTABLE_YES,   FALSE, ShowSoundsHelp,			ShowSoundsHelp,		FALSE,
         "View help for the ShowSounds feature.",
	" Time", "O", "ut Help...           ", 'O',  SELECTABLE_YES,   FALSE, TimeOutHelp,				TimeOutHelp,			FALSE,
         "View help for the TimeOut feature.",
	" M", "i", "scellaneous Features... ", 'I',  SELECTABLE_YES,   FALSE, MiscellaneousHelp,		MiscellaneousHelp,	TRUE,
         "View help for miscellaneous features.",
	"", "", "", '\0', SELECTABLE_NEVER, FALSE, DummyFunction,			DummyFunction,			FALSE,
         ""
};


MENU_BAR_RECORD menuList[] =
{
	" ", "F", "ile ",   SCAN_F, fileMenuList,   FALSE,
	" ", "A", "djust ", SCAN_A, adjustMenuList, FALSE,
	" ", "H", "elp ",   SCAN_H, helpMenuList,   TRUE
};


OPTION_LIST_RECORD dummyOptionList[] =
{
   "", "", "", '\0', SELECTABLE_NEVER, FALSE, FALSE, TRUE
};


OPTION_LIST_RECORD stickyKeysOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD stickyFeedbackOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD stickyTwoKeysOffOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD stickyAudibleOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD stickyClickOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD stickyTriStateOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

DIALOG_LIST_RECORD stickyKeysDialogList[] =
{
	" ", "StickyKeys On........................:", " ", '\0', SELECTABLE_YES, stickyKeysOnOption,     &sStickyKeysOn,   1, FALSE,
         "Do you want StickyKeys On?",
	" ", "Sound when turned on or off..........:", " ", '\0', SELECTABLE_YES, stickyFeedbackOption,   &sOnOffFeedback,   1, FALSE,
         "Do you want to hear when StickyKeys turns on or off?",
	" ", "Sound when pressing a StickyKey......:", " ", '\0', SELECTABLE_YES, stickyAudibleOption,    &sAudibleFeedback, 1, FALSE,
         "Do you want to hear when you press a StickyKey?",
	" ", "Sound when pressing any key..........:", " ", '\0', SELECTABLE_YES, stickyClickOption,      &sClickOn,         1, FALSE,
         "Do you want to hear key clicks?",
	" ", "Turn off when pressing 2 keys at once:", " ", '\0', SELECTABLE_YES, stickyTwoKeysOffOption, &sTwoKeysOff,      1, FALSE,
         "Do you want StickyKeys to turn off when two keys are pressed simultaneously?",
	" ", "Lock MOD key when pressed twice......:", " ", '\0', SELECTABLE_YES, stickyTriStateOption,   &sTriState,        1, FALSE,
         "The MOD keys are the SHIFT, CONTROL, and ALTERNATE keys.",
   " ", " ", " ", '\0', SELECTABLE_NEVER, dummyOptionList, &dummyInt, 2, TRUE, " "
};




OPTION_LIST_RECORD slowKeysOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD slowFeedbackOption[] =
{
	" ", "On",  " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "Off", " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD slowClickOption[] =
{
	" ", "On",  " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "Off", " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD slowAcceptanceOption[] =
{
	" ", "Off", " ", '\0', SELECTABLE_YES, TRUE,   0,  FALSE,
	" ", "0.3", " ", '\0', SELECTABLE_YES, FALSE,  5,  FALSE,
	" ", "0.5", " ", '\0', SELECTABLE_YES, FALSE,  9,  FALSE,
	" ", "0.7", " ", '\0', SELECTABLE_YES, FALSE, 12,  FALSE,
	" ", "1.0", " ", '\0', SELECTABLE_YES, FALSE, 18,  FALSE,
	" ", "1.4", " ", '\0', SELECTABLE_YES, FALSE, 25,  FALSE,
	" ", "2.0", " ", '\0', SELECTABLE_YES, FALSE, 36,  TRUE
};

OPTION_LIST_RECORD repeatDelayOption[] =
{
	" ", "2.0",  " ", '\0', SELECTABLE_YES, FALSE, 36,    FALSE,
	" ", "1.5",  " ", '\0', SELECTABLE_YES, FALSE, 27,    FALSE,
	" ", "1.0",  " ", '\0', SELECTABLE_YES, FALSE, 18,    FALSE,
	" ", "0.75", " ", '\0', SELECTABLE_YES, FALSE, 13,    TRUE
};

OPTION_LIST_RECORD repeatRateOption[] =
{
	" ", "Off",  " ", '\0', SELECTABLE_YES, FALSE, 32760, FALSE,
	" ", "1.5",  " ", '\0', SELECTABLE_YES, TRUE,     27, FALSE,
	" ", "1.0",  " ", '\0', SELECTABLE_YES, FALSE,    18, FALSE,
	" ", "0.75", " ", '\0', SELECTABLE_YES, FALSE,    13, FALSE,
	" ", "0.5",  " ", '\0', SELECTABLE_YES, FALSE,     9, FALSE,
	" ", "0.25", " ", '\0', SELECTABLE_YES, FALSE,     4, TRUE
};

OPTION_LIST_RECORD bounceTimeOption[] =
{
	" ", "Off",  " ", '\0', SELECTABLE_YES, TRUE,  32760, FALSE,
	" ", "2.0",  " ", '\0', SELECTABLE_YES, FALSE,    36, FALSE,
	" ", "1.5",  " ", '\0', SELECTABLE_YES, FALSE,    27, FALSE,
	" ", "1.0",  " ", '\0', SELECTABLE_YES, FALSE,    18, FALSE,
	" ", "0.75", " ", '\0', SELECTABLE_YES, FALSE,    13, FALSE,
	" ", "0.5",  " ", '\0', SELECTABLE_YES, FALSE,     9, TRUE
};

DIALOG_LIST_RECORD keyboardDialogList[] =
{
	" ", "Enable Group.....:", " ",                  '\0', SELECTABLE_YES,   slowKeysOnOption,		&fFilterKeysOn,	1, FALSE,
         "Do you want to Enable this group of Keyboard functions as currently set?",
	" ", "Sound on Enable..:", " ",                  '\0', SELECTABLE_YES,   slowFeedbackOption,		&fOnOffFeedback,	1, FALSE,
         "Do you want to hear when this group is enabled or disabled?",
   " ", " ", " ",                                   '\0', SELECTABLE_NEVER, dummyOptionList,			&dummyInt,			2, FALSE,
         " ",
   " ", "RepeatKey Settings:", " ",                 '\0', SELECTABLE_TITLE, dummyOptionList,			&dummyInt,			2, FALSE,
         " ",
	" ", "Repeat Rate (seconds/character):", " ",    '\0', SELECTABLE_YES,   repeatRateOption,		&fRepeatTicks,		2, FALSE,
         "How fast do you want the keys to repeat (or do you want repeat turned off)?",
	" ", "Delay until repeat (seconds)...:", " ",    '\0', SELECTABLE_YES,   repeatDelayOption,		&fDelayTicks,		2, FALSE,
         "How many seconds should the keyboard wait before starting to repeat keys?",
   " ", "SlowKey Settings:", " ",                   '\0', SELECTABLE_TITLE, dummyOptionList,			&dummyInt,			2, FALSE,
         " ",
	" ", "Acceptance Delay (seconds).....:", " ",    '\0', SELECTABLE_YES,   slowAcceptanceOption,	&fWaitTicks,		2, FALSE,
         "How many seconds do you want the keyboard to wait before accepting a key?",
	" ", "Key Click Feedback.............:", " ",    '\0', SELECTABLE_YES,   slowClickOption,			&fClickOn,			1, FALSE,
         "Do you want to hear a sound when a key is depressed and when it is accepted?",
   " ", "BounceKeys Settings:", " ",                '\0', SELECTABLE_TITLE, dummyOptionList,			&dummyInt,			2, FALSE,
         " ",
  	" ", "Debounce time (seconds)........:", " ",    '\0', SELECTABLE_YES,   bounceTimeOption,		&fBounceTicks,		2, TRUE,
        "A key must be released for this long before the same key will be re-typed."
};



OPTION_LIST_RECORD mouseKeysOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD mouseFeedbackOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD mouseVelocityOption[] =
{
	" ",  "10", " ", '\0', SELECTABLE_YES, TRUE,   1, FALSE,
	" ",  "20", " ", '\0', SELECTABLE_YES, FALSE,  2, FALSE,
	" ",  "30", " ", '\0', SELECTABLE_YES, FALSE,  3, FALSE,
	" ",  "40", " ", '\0', SELECTABLE_YES, FALSE,  4, FALSE,
	" ",  "60", " ", '\0', SELECTABLE_YES, FALSE,  6, FALSE,
	" ",  "80", " ", '\0', SELECTABLE_YES, FALSE,  8, FALSE,
	" ", "120", " ", '\0', SELECTABLE_YES, FALSE, 12, FALSE,
	" ", "180", " ", '\0', SELECTABLE_YES, FALSE, 18, FALSE,
	" ", "360", " ", '\0', SELECTABLE_YES, FALSE, 36, TRUE
};

OPTION_LIST_RECORD mouseAccelerationOption[] =
{
	" ", "1", " ", '\0', SELECTABLE_YES, TRUE,  1, FALSE,
	" ", "2", " ", '\0', SELECTABLE_YES, FALSE, 2, FALSE,
	" ", "3", " ", '\0', SELECTABLE_YES, FALSE, 3, FALSE,
	" ", "4", " ", '\0', SELECTABLE_YES, FALSE, 4, TRUE
};

DIALOG_LIST_RECORD mouseKeysDialogList[] =
{
	" ", "MouseKeys On............:", " ", '\0', SELECTABLE_YES, mouseKeysOnOption,       &mMouseKeysOn,    1, FALSE,
         "Do you want MouseKeys On?",
	" ", "Sound when turned on/off:", " ", '\0', SELECTABLE_YES, mouseFeedbackOption,     &mOnOffFeedback,  1, FALSE,
         "Do you want to hear when MouseKeys turns on or off?",
	" ", "Max Speed (pix/sec).....:", " ", '\0', SELECTABLE_YES, mouseVelocityOption,     &mMaxSpeed,       2, FALSE,
         "Select the maximum speed of the mouse. (Pixels per second)",
	" ", "Time to Max Speed (secs):", " ", '\0', SELECTABLE_YES, mouseAccelerationOption, &mTimeToMaxSpeed, 2, FALSE,
         "Select the number of seconds it takes to reach the maximum speed.",
   " ", " ", " ", '\0', SELECTABLE_NEVER, dummyOptionList, &dummyInt, 2, TRUE, " "
};




OPTION_LIST_RECORD toggleKeysOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD toggleFeedbackOption[] =
{
	" ", "On",  " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "Off", " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

DIALOG_LIST_RECORD toggleKeysDialogList[] =
{
	" ", "ToggleKeys On..............:", " ", '\0', SELECTABLE_YES, toggleKeysOnOption,   &tToggleKeysOn,  1, FALSE,
         "Do you want ToggleKeys On?",
	" ", "Sound when turned on or off:", " ", '\0', SELECTABLE_YES, toggleFeedbackOption, &tOnOffFeedback, 1, FALSE,
         "Do you want to hear when ToggleKeys turns on or off?",
   " ", " ", " ", '\0', SELECTABLE_NEVER, dummyOptionList, &dummyInt, 2, TRUE, " "
};




OPTION_LIST_RECORD serialKeysOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD serialBaudOption[] =
{
	" ", "300",   " ", '\0', SELECTABLE_YES, TRUE,  BAUD300,   FALSE,
	" ", "600",   " ", '\0', SELECTABLE_YES, FALSE, BAUD600,   FALSE,
	" ", "1200",  " ", '\0', SELECTABLE_YES, FALSE, BAUD1200,  FALSE,
	" ", "2400",  " ", '\0', SELECTABLE_YES, FALSE, BAUD2400,  FALSE,
	" ", "4800",  " ", '\0', SELECTABLE_YES, FALSE, BAUD4800,  FALSE,
	" ", "9600",  " ", '\0', SELECTABLE_YES, FALSE, BAUD9600,  TRUE
};

OPTION_LIST_RECORD serialPortOption[] =
{
	" ", "COM1", " ", '\0', SELECTABLE_YES,   FALSE, 0x03f8, FALSE,
	" ", "COM2", " ", '\0', SELECTABLE_YES,   FALSE, 0x02f8, FALSE,
	" ", "COM3", " ", '\0', SELECTABLE_YES,   FALSE, 0,      FALSE,
	" ", "COM4", " ", '\0', SELECTABLE_YES,   FALSE, 0,      TRUE
};

DIALOG_LIST_RECORD serialKeysDialogList[] =
{
  	" ", "Install SerialKeys:", " ", '\0', SELECTABLE_YES, serialKeysOnOption, &skSerialKeysOn, 1, FALSE,
         "Do you want to install SerialKeys?",
  	" ", "Serial Port.......:", " ", '\0', SELECTABLE_YES, serialPortOption,   &skPortAddress,  2, FALSE,
         "Select the Serial Port to use for SerialKeys.",
  	" ", "Baud Rate.........:", " ", '\0', SELECTABLE_YES, serialBaudOption,   &skBaudRate,     2, FALSE,
         "Select the Baud Rate of your serial port.",
   " ", " ", " ", '\0', SELECTABLE_NEVER, dummyOptionList, &dummyInt, 2, TRUE, " "
};




OPTION_LIST_RECORD timeOutOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD timeOutTimeOption[] =
{
	" ", "5",  " ", '\0', SELECTABLE_YES, FALSE,  5400, FALSE,
	" ", "10", " ", '\0', SELECTABLE_YES, FALSE, 10800, FALSE,
	" ", "15", " ", '\0', SELECTABLE_YES, FALSE, 16200, FALSE,
	" ", "30", " ", '\0', SELECTABLE_YES, FALSE, 32400, TRUE
};

OPTION_LIST_RECORD timeOutFeedbackOption[] =
{
	" ", "On",  " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "Off", " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

DIALOG_LIST_RECORD timeOutDialogList[] =
{
	" ", "TimeOut On........................:", " ", '\0', SELECTABLE_YES,   timeOutOnOption,       &toTimeOut,       1, FALSE,
         "Do you want TimeOut to automatically turn AccessDOS off after idle delay?",
	" ", "Idle time before turnoff (minutes):", " ", '\0', SELECTABLE_YES,   timeOutTimeOption,     &toValue,         2, FALSE,
         "How many minutes should AccessDOS wait before automatically turning off?",
	" ", "Sound when turned off.............:", " ", '\0', SELECTABLE_YES,   timeOutFeedbackOption, &toOnOffFeedback, 1, FALSE,
         "Do you want to hear when TimeOut turns AccessDOS off?",
   " ", " ", " ", '\0', SELECTABLE_NEVER, dummyOptionList, &dummyInt, 2, TRUE, " "
};



OPTION_LIST_RECORD visualNoteOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD screenFlashOnOption[] =
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

DIALOG_LIST_RECORD showSoundsDialogList[] =
{
   " ", "Visual Note On..........:", " ", '\0', SELECTABLE_YES, visualNoteOnOption, &fHearingOn, 1, FALSE,
         "Do you want a visual indicator when your computer makes sounds?",
   " ", "Screen Flash On.........:", " ", '\0', SELECTABLE_YES, screenFlashOnOption, &fVideoFlash, 1, TRUE,
         "Do you want the screen to flash when your computer makes sounds?"
};



OPTION_LIST_RECORD spaceSaverOption[] = 
{
	" ", "Yes", " ", '\0', SELECTABLE_YES,   TRUE,  TRUE,  FALSE,
	"",  " ",   "",  '\0', SELECTABLE_NEVER, FALSE, FALSE, FALSE,
	" ", "No",  " ", '\0', SELECTABLE_YES,   FALSE, FALSE, TRUE
};

OPTION_LIST_RECORD computerOption[] = 
{
	" ", "1", " ",   '\0', SELECTABLE_YES, TRUE,  1, FALSE,
	" ", "2",   " ", '\0', SELECTABLE_YES, FALSE, 2, FALSE,
	" ", "3",  " ",  '\0', SELECTABLE_YES, FALSE, 3, TRUE
};

DIALOG_LIST_RECORD miscellaneousDialogList[] =
{
   " ", "Space Saving Keyboard.............:", " ", '\0', SELECTABLE_YES,   spaceSaverOption, &fSpaceSaver,  1, FALSE,
         "Are you using IBM's Space Saving keyboard on your computer?",
   " ", "Computer Type.....................:", " ", '\0', SELECTABLE_NEVER, computerOption,   &compDialogId, 1, TRUE,
         "1 = PC/PC-XT/PC-AT w/ 84 Key;  2 = PC-AT or Clone w/ 101 Key; 3 = '386 PC"
};



/*
DIALOG_LIST_RECORD quitAccessDialogList[] =
{
	"  ", "Install AccessDOS",                 "  ", '\0', SELECTABLE_YES, dummyOptionList, &dummyInt, 1, FALSE,
         "Install AccessDOS using the parameters as set in this session.",
	"  ", "Quit without installing AccessDOS", "  ", '\0', SELECTABLE_YES, dummyOptionList, &dummyInt, 1, FALSE,
         "Quit AccessDOS without installing.",
	"  ", "Cancel",                            "  ", '\0', SELECTABLE_YES, dummyOptionList, &dummyInt, 1, TRUE,
         "Press Escape to return to the menu."
};
*/

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\messages.h ===
#define MESSAGES	1

typedef struct
{
	char *text;
	int lastRecord;
} HELP_SCREEN_RECORD;

extern char *SlowNotValidWithBounceAlertText;
extern char *BounceNotValidWithSlowAlertText;
extern char *NoSlowWithBounceAlertText;
extern char *NoNoteWithFlashAlertText;
extern char *SerialKeysNotLoadedAlertText;
extern char *CannotChangeCommPortAlertText;
extern char *NoMouseFoundAlertText;
extern char *SerKeysMouseConflictAlertText;
extern char *NoSerialPortAvailableAlertText;
extern char *OneSerialPortWithMouseAlertText;
extern char *NoCommTwoAlertText;
extern char *ComputerNotFoundAlertText;
extern char *LoadSuccessfulAlertText;
extern char *LoadFailedAlertText;
extern char *SaveSuccessfulAlertText;
extern char *SaveFailedAlertText;


extern HELP_SCREEN_RECORD helpTextSaveParameters[], helpTextInstallAccess[], helpTextCancelAccess[];
extern HELP_SCREEN_RECORD helpTextMenu[], helpTextGeneral[], helpTextSticky[], helpTextMouse[], helpTextToggle[];
extern HELP_SCREEN_RECORD helpTextSerial[], helpTextKeyboard[], helpTextShowSounds[], helpTextTimeOut[], helpTextMisc[];




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\keyboard.inc ===
;***************************************************************************
;                                                                          *
;	Copyright (C) 1990 by Trace Center (just kidding)		   *
;									   *
;	KEYBOARD.INC							   *
;								           *
;***************************************************************************

ack_port 	equ	20h		; 8259 acknowledge port

;eoi		equ	20h		; 8259 end of interrupt (Specific)
;timer_port 	 equ	40h 		; 8253/4 Counter Timer

kb_data	   	 equ	60h 		; 8042 data port
kb_ctl	   	 equ	61h 		; 8042 ctrl port

;----------------------------------------------------------------------------
; these equs are port definitions for getting the key, sounding the speaker,
; and terminating the interrupt.

status_port	equ	064h		; 8042 status port
inpt_buf_full	equ	002h		; input buffer full
out_buf_full	equ	001h		; output buffer full
both_buf_full	equ	003h		; input and output buffers full on 8042 keyboard status

dis_kbd		equ	0adh		; disable keyboard command
ena_kbd		equ	0aeh		; enable keyboard command

;dis_mou		equ	0a7h		; disable mouse command
;ena_mou		equ	0a8h		; enable mouse command

;----------------------------------------------------------------------------

;TRUE		equ	1			; equ's used in startup.asm
;FALSE		equ	0

ACCESS_FUNCTION equ     0adh            ; ****** any changes here must also be made in DATABLK.C
TSR_HERE	equ	0ACCEh          ; ****** any changes here must also be made in DATABLK.C
TSR_DETECT      equ     0e1h            ; ****** any changes here must also be made in DATABLK.C
TSR_PARAMS      equ     0e2h            ; ****** any changes here must also be made in DATABLK.C

DEFAULT_INTERRUPT 	equ	63h
START_INT_NUMBER	equ	60h
END_INT_NUMBER		equ	67h


newprog	        equ	82h
newstr	        equ	81h

;***************************************************************************
; Definition of BIOS RAM and ROM data area
;***************************************************************************

RAMBIOS	SEGMENT	AT 40H

	org 17h
kb_flag label byte

	org 18h
kb_flag_1 label byte

	org  96h
kb_flag_3 label byte  			; contains Extended Keyboard ID, Rt Alt/Ctrl. and E0/E1 info

	org  65h
vid_flag	label	byte

RAMBIOS	ENDS

ROMBIOS SEGMENT AT 0f000h

	org	0fffeh
computer_model_id	label	byte

;	org	0fffch
;computer_submodel	label	byte
;
;	org	0fffah	
;computer_revision	label	byte
;
	org	0fff5h
computer_bios_date	label	byte

ROMBIOS ENDS

;***************************************************************************
; bits in kb_flag and kb_flag_1
;***************************************************************************


; Flag bits in kb_flag

fCaps		equ	01000000b		; caps (or shift-) lock
fNum		equ	00100000b		; numlock
fScroll		equ	00010000b		; scroll lock
fAlt		equ	00001000b		; ALT key
fCtrl		equ	00000100b		; Control key
fLshift		equ	00000010b		; left shift key
fRshift		equ	00000001b		; right shift key
fShift		equ	fLshift+fRshift		; either or both shift keys

;----------------------------------------------------------------------------
;			       E Q U S

false		equ	0
true		equ	1			; to match Microsoft C's TRUE, when working with C code

break_bit	equ	080h			; set if key was a break
kb_ext_code1	equ	0e0h			; 101/102 extra or extended key hidden codes
kb_ext_code2	equ	0e1h			; 101/102 extra or extended key hidden codes

fLCtrl		equ	00000100b
fLAlt		equ	00001000b
fRCtrl		equ	00010000b
fRAlt		equ	00100000b
fNotToggles   	equ	fRAlt + fRCtrl + fLAlt + fLCtrl

RAlt		equ	0e038h
RCtrl		equ	0e01dh
;kybd_Ret     	equ	01ch			; scan set 1 return key make code 
;kybd_BkSpace	equ	00eh			; scan set 1 backspace key make code
kybd_Command	equ	0EDh
Alt		equ	038h
RShift		equ	036h
Ctrl		equ	01dh
LShift		equ	02ah

no_tone_len	equ	 1			; very soft click
low_tone_len	equ	20			; 0.04 seconds
high_tone_len	equ	80			; 0.04 seconds
click_tone_len	equ	 3			; 

shift_flags	equ	00fh		
clear_flags	equ	not shift_flags
clear_fShift	equ	not fShift

fShift_word	equ	0303h			; left and right shift
fCtrl_word	equ	1414h			; left and right ctl
fAlt_word	equ	2828h			; left and right alt

fLShift_word	equ	0102h			; opposite (rshift) + left shift
;fLShift_flag	equ	0201h			; left and right shift for StickeyKeys

fRShift_word	equ	0201h			; opposite (lshift) + right shift
;fRShift_flag	equ	0102h			; right and left shift for StickeyKeys

fLCtrl_word	equ	0104h			; opposite (rctrl) + ctrl
;fLCtrl_flag	equ	0104h			; left and right ctrl, kb_flag_1 and kb_flag_3

fRCtrl_word	equ	0410h			; opposite (lctrl) + rctrl
;fRCtrl_flag	equ	0401h			; right and left ctrl, kb_flag_1 and kb_flag_3

fLAlt_word	equ	0208h			; opposite (ralt) + alt
;fLAlt_flag	equ	0208h			; left and right alt, kb_flag_1, and kb_flag_3

fRAlt_word	equ	0820h			; opposite (lalt) + ralt
;fRAlt_flag	equ	0802h			; right and left alt, kb_flag_1, and kb_flag_3

dly_dflt_cnt		equ	18		; = 1 sec at 18.2/sec
rpt_dflt_cnt		equ	18		; = 1 sec at 18.2/sec
wait_dflt_cnt		equ	18		; = 1 sec at 18.2/sec
;rec_dflt_cnt		equ	18		; = 1 sec at 18.2/sec.

no_accept_cnt		equ	73		; = 4 sec at 18.2/sec
warning_cnt		equ	218		; = 12 sec at 18.2/sec
toggle_dflt_cnt  	equ	146		; = 8 sec at 18.2/sec
reset_cnt		equ	291		; = 16 sec at 18.2/sec
max_dflt_wait_cnt	equ	36		; = 2 sec at 18.2/sec
tk_reset_cnt		equ	91		; = 5 sec at 18.2/sec

NumLock		equ	045h
CapsLock	equ	03ah
ScrollLock	equ	046h

NumPad_0	equ	00052h
NumPad_1	equ	0004fh
NumPad_2	equ	00050h
NumPad_3	equ	00051h
NumPad_4	equ	0004bh
NumPad_5	equ	0004ch
NumPad_6	equ	0004dh
NumPad_7	equ	00047h
NumPad_8	equ	00048h
NumPad_9	equ	00049h
NumPad_Period	equ	00053h
NumPad_Plus	equ	0004eh
NumPad_Minus	equ	0004ah
NumPad_Times	equ	00037h
NumPad_Enter	equ	0e01ch			; has kb_ext_code_1
NumPad_Divide	equ	0e035h			; has kb_ext_code_1

to_dflt		equ	10			; time out default in minutes	  
to_dflt_cnt	equ	to_dflt*60*18		; *60 for seconds *18 for ticks

;***************************************************************************
;	 System ID byte or word values used for reference only
;***************************************************************************
;-------comp_id=1
;
;IBM_pc			equ	0ffh	    	; IBM PC, all
;				       	
;IBM_xt			equ	0feh	    	; IBM PC XT  BIOS 11/8/82
;
;
;;-------comp_id=2
;
;IBM_xt_1		equ	0fbh	    	; IBM PC XT  revision 1 BIOS 1/10/86 
;IBM_xt_2		equ	0fbh	    	; IBM PC XT  revisiom 2 BIOS 5/9/86
;
;
;;-------comp_id=3
;
;IBM_pcjr		equ	0fdh		; IBM PC JR  BIOS 6/1/83
;
;;-------comp_id=4
;
;IBM_conv		equ	0f9h		; IBM Convertible  BIOS 9/13/85
;
;;-------comp_id=5
;
;IBM_at			equ	0fch		; IBM PC AT  BIOS 1/10/84
;
;;-------comp_id=6
;
;IBM_ps2_30		equ	0fah 		; IBM PS/2 mod 30, 25 (8086 machines ???)  BIOS 9/2/86
;
;;-------comp_id=7
;
;; Old AT
;IBM_at_1		equ	0fch		; IBM PC AT  submodel 0 revision 1 BIOS 6/10/85 (01/10/84 also)
;
;; New AT
;IBM_at_2		equ	0fch		; IBM PC AT  submodel 1 BIOS 11/15/85				       	
;
;
;IBM_xt_286		equ	0fch		; IBM XT/286 submodel 2 BIOS 4/21/86
;						; PS/2 Models 50, 60 have an AT ID! NO KIDDING
;IBM_ps2_50		equ	0fch		; IBM PS/2 mod 50, submodel 4
;IBM_ps2_60		equ	0fch		; IBM PS/2 mod 60, submodel 5
;
;
;;-------comp_id=8
;
;IBM_ps2_80		equ	0f8h		; IBM PS/2 mod 80, submodel 0, 16 Mhz
;IBM_ps2_80		equ	0f8h		; IBM PS/2 mod 80, submodel 1, 20 Mhz
;
;IBM_ps2_55		equ	0f8h		; IBM PS/2 mod 55, submodel 0C
;
;IBM_ps2_70		equ	0f8h		; IBM PS/2 mod 80, submodel 09
;IBM_ps2_70		equ	0f8h		; IBM PS/2 mod 80, submodel 04
;IBM_ps2_70		equ	0f8h		; IBM PS/2 mod 80, submodel 0D


;----------------------------------------------------------------------------------------------------
; We will determine fvideo_type as follows
;
;	1=monocrome display adapter
;	2= open
;	3= CGA
;	4= EGA mono
;	5= EGA color
;	6= MCGA	(multi color graphics adapter ) special PS/2, usually 25/30-8086
;	7= VGA


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\mou.h ===
/*  MOU.H  */


void processMouClick(void);
void processMouDoubleClick(void);
void processMouLock(void);
void processMouRel(void);
void processMouReset(void);
void processMouMove(void);
void collectMoveByte(void);
void collectMoveInteger(void);
void moveTheMouseRelative(void);
void processMouGoto(void);
void collectGotoByte(void);
void collectGotoInteger(void);
void moveTheMouseAbsolute(void);
void processMou(void);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\mousekey.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	MOUSEKEY.ASM							*
;									*
;************************************************************************

TITLE	MouseKeys

INCLUDE	keyboard.inc

	EXTRN 	real_states:byte
	EXTRN	shift_flg:byte
	EXTRN	lock_flg:byte

	EXTRN	ToggleKeys:PROC				; in ToggleKeys.asm


	EXTRN	beep_high:PROC				; in Handicap.asm
	EXTRN	beep_low:PROC
	EXTRN	no_beep:PROC
	EXTRN	beep_turn_on:PROC
	EXTRN	beep_turn_off:PROC
	EXTRN	click:PROC
	EXTRN	fmouse_driver:byte
	EXTRN	_fmouse_id:byte
	EXTRN	btn_1:byte
	EXTRN	btn_2:byte
	EXTRN	Current_Button:byte
	EXTRN	fmouse_button:byte
	EXTRN	_comp_id:byte
	EXTRN	comp_flag:byte
	EXTRN	Get_Mouse_Data:PROC
	EXTRN	ExtendedSeg:word
	EXTRN	fpause_being_sent:byte
	EXTRN	fswitching_video:byte
	EXTRN	faccess_sound:byte
	EXTRN	fbios_called_timing:byte
	EXTRN	fsecond_cue:byte
	EXTRN	Put_Key_Data:PROC
	EXTRN	ftimer_1C_active:byte
	EXTRN	fserial_key_recieved:byte
	EXTRN	fmousetrapping:byte
;	EXTRN	fwindows_enh:byte			; DEBUGGING

	EXTRN	fMouseKeysOn:byte			; from Param.asm
	EXTRN	fMK_On_Off_Feedback:byte
	EXTRN	Max_Speed:word
	EXTRN	Time_To_Max_Speed:word
	EXTRN	fDialog_Mouse_off:byte
	EXTRN	fRecovery_On:byte
	EXTRN	fspace_saver:byte
	EXTRN	fToggleKeysOn:byte			
	EXTRN 	fSticKeysOn:byte

	EXTRN	TimeOut_Reset:PROC			; in TimeOut.asm

	EXTRN	fUser_SetUp_Option1:byte		; in FilterKeys.asm
	EXTRN	fUser_SetUp_Option2:byte
	EXTRN	on_repeat_ticks:word

	PUBLIC	MouseKeys				; in MouseKeys.asm
	PUBLIC	MouseKeys_timer
	PUBLIC	MouseKeys_TurnOff
	PUBLIC	InjectMouse
	PUBLIC	button_click,Status
	PUBLIC	fMoving,fbutton_up,Last_Direction,fbutton_down
	PUBLIC	Delta_X,Delta_Y,Mouse_Status
	PUBLIC	mouse_data
	PUBLIC	mouse_data_head
	PUBLIC	mouse_data_tail
	PUBLIC	mouse_data_end
	PUBLIC	Put_Mouse_Data
	PUBLIC	MouseKeys_dialog
	PUBLIC	Button_Status
	PUBLIC	mouse_cnt 
	PUBLIC	fnum_lock_was_off
	PUBLIC	fserial_stop

IFDEF	BUG

	EXTRN	portid:byte
	EXTRN	portout:byte
	EXTRN	HexCharsOut:PROC

ENDIF; BUG

;----------------------------------------------------------------------------

_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;
;  The below area defines the resident data area.

fMoving			DB	false			; flag for accelerated Moving
fSteady			DB	false			; flag for if at constant speed
fJust_Manually_On	DB	false			; flag to prevent turn off right after turn on
fJust_Manually_Off	DB	false			; flag to prevent turn on right after turn off
fbutton			DB	false			; flag to indicate a mousekey mouse button was pressed
fbutton_up		DB	false			; flag to tell code after the mouse driver that MouseKeys button up was sent
fbutton_down		DB	false			; flag to tell code that mouse button down has been pressed once already
foff_mousekeys		DB	false			; flag that MouseKeys is turning off after we get numlock break code
fpass_mousekeys		DB	true			; flag that turns numeric pad on/off to mousekeys with numlock key only
fnum_lock_was_off	db	false			; flag used with space saver kybd, should on num lock be passed or not ?
fpass_numlock_spsav	db	false			; flag used with space saver kybd to block typematic numlock makes from
fserial_stop		db	false			; flag used to tell timer when to stop sending serial mouse mvmnts to driver

							; toggling MouseKeys on/off/on/off/on.......

Accel_Ptr		DB	0			; pointer into table
Constant_Ptr		DB	0

Last_Direction	label	word

Y_Direction		DB	0			; direction
X_Direction		DB	0			; direction

Status			DB	0			; byte to hold the mouse status as built
Button_Status		DB	0			; holds button_status info for the mouse
Temp_Button		DB	0			; holds al register while I check if kybd supports 3rd button

Mouse_Packet	label	word				; next four words

Delta_Z			DW	0			; added for our matching in AccesDos
Delta_Y			DW	0
Delta_X			DW	0
Mouse_Status		DW	0			; only changes in states
mouse_cnt		DB	0			; mouse data packet buffer counter

mouse_data_tail		DW	?			; pointer into mouse_data
mouse_data_head		DW	?			; pointer into mouse_data
mouse_data		DW	120 DUP (?)		; array of (120 words) for circular buffer of mouse button data
mouse_data_end	label	word

;----------------------------------------------------------------------------
; MouseKeys_Param

Accel_Table_Len		DB	73			; just storage initially
							; 73 bytes gives alittle more 4 seconds maximum if choosen
							; to complete the accel. table ( 73 tics / 18.2 ticks/sec)
 
Accel_Table	db	 0, 0, 1, 0, 0, 1, 0, 1
		db	 0, 1, 0, 1, 0, 1, 0, 1
		db	 0, 1, 0, 1, 0, 1, 0, 1
		db	 1, 0, 1, 0, 1, 0, 1, 0

		db	 1, 0, 1, 0, 1, 0, 1, 1
		db	 0, 1, 0, 1, 0, 1, 0, 1
		db	 0, 1, 0, 1, 1, 1, 1, 1
		db	 1, 1, 1, 1, 1, 1, 1, 1
		db	 1, 1, 1, 1, 1, 1, 1, 1
		db	 1 


Constant_Table_Len	DB	21			; just storage

Constant_Table	db	 1, 1, 1, 1, 1, 1, 1, 1
		db	 1, 1, 1, 1, 1, 1, 1, 1
		db	 1, 1, 1, 1, 1 
		
;----------------------------------------------------------------------------
; search table for a shift key.

mouse_tbl	label	 word

		dw	NumLock
		dw	NumPad_Divide
		dw	NumPad_Times
		dw	NumPad_Minus
		dw	NumPad_Plus
		dw	NumPad_Enter	
		dw	NumPad_Period	
		dw	NumPad_9	
		dw	NumPad_8	
		dw	NumPad_7	
		dw	NumPad_6	
		dw	NumPad_5	
		dw	NumPad_4	
		dw	NumPad_3	
		dw	NumPad_2	
		dw	NumPad_1	
		dw	NumPad_0	
mouse_tbl_len	equ	17

MK_call_table	label	word

		dw	button_delta			; button down
		dw	move_proc	
		dw	move_proc	
		dw	move_proc	
		dw	move_proc	
		dw	button_click			; button click
		dw	move_proc	
		dw	move_proc	
		dw	move_proc	
		dw	move_proc	
		dw	button_click  			; button up, changed to accomadate MouseKeys and real mouse together
		dw	dummy_proc	
		dw	dbl_click_proc			; double click
		dw	btn_sel_proc	
		dw	btn_sel_proc	
		dw	btn_sel_proc	
		dw	off_proc	

MK_data_table	label	word

		dw	1				; numpad 0 button down
		dw	0ffffh				; numpad 1 -x,-y
		dw	000ffh				; numpad 2  0,-y
		dw	001ffh				; numpad 3 +x,-y
		dw	0ff00h				; numpad 4 -x, 0
		dw	0				; numpad +, click
		dw	00100h				; numpad 6 +x, 0
		dw	0ff01h				; numpad 7 -x,+y
		dw	00001h		  		; numpad 8  0,+y
		dw	00101h				; numpad 9 +x,+y
		dw	1				; numpad . button up
		dw	0				; numpad   "Enter"
		dw	0				; numpad + double click
		dw	01002h				; high=10,serial right button, low=2 AUX right button		
		dw	03003h				; high=30,serial both buttons, low=3 AUX both buttons
		dw	02001h				; high=20,serial left button, low=1 AUX left button		
		dw	0				; numpad "Num Lock" key for On/Off

;----------------------------------------------------------------------------
;
; The mouseKeys routine allows everyone who has difficulty controlling a standard mouse input
; device, the ability to alternately control the standard mouse from the keyboard.  Mousekeys
; remaps the numeric keypad into a mouse control pad, with all the same functionality of the 
; standard input mouse available to the user from the keyboard.
;----------------------------------------------------------------------------

MouseKeys	proc	

	assume	DS:_TEXT

	jmp	mouse_begin


;----------------------------------------------------------------------------
;	Put_Mouse_Data
; 
; This procedure loads mouse button info into a buffer where the timer will later
; retrieve it and send it to the appropriate mouse input mechanism.  All serial
; mouse info ends up in this buffer, but only the ps/2 mouse button info needs 
; to be buffered, the rest of the PS/2 mouse information can be injected directly.
;
;	Expects   Ax= mouse data to be stored, order is
;
;		  1st Mouse_Status
;		  2nd Delta_X
;		  3rd Delta_Y

Put_Mouse_Data	proc

	assume	DS:_TEXT

	push	bx				; temp store of bx register
	push	si				; temp store of si register

	mov	bx,mouse_data_tail		; get tail pointer of mouse_data buffer
	mov	si,bx				; save pointer value
	add	bx,2				; move to next word address in buffer
	cmp	bx,OFFSET mouse_data_end	; are we at the end of the buffer ?
	jne	PMD_5				; no
	mov	bx,OFFSET mouse_data		; yes we are, so reset to the buffer beginning

PMD_5:
	cmp	bx,mouse_data_head		; has the buffer wrapped around ?
	jne	PMD_10

; if equal, buffer is full, exit

	jmp	Put_Mouse_Data_End		; if full, leave routine
PMD_10:
	mov	[si],ax				; move whats in ax into address pointed to by si
	inc	mouse_cnt			; increase counter by 1, since we put a word into the buffer

	mov	mouse_data_tail,bx		; update tail pointer

Put_Mouse_Data_End:

	pop	si
	pop	bx
	ret

Put_Mouse_Data	endp

;----------------------------------------------------------------------------
; MouseKeys_timer
;
; Expects:	Nothing
;
; Changes:	ax,bx

MouseKeys_timer	proc	

	assume	DS:_TEXT

	cmp	fMouseKeysOn,true		; is mouse key on?
	jne	mt_10				; no, skip routine -->
	cmp	fMoving,true			; are we in motion?
	je	mt_20				; yes -->
mt_10:
	jmp	MouseKeys_timer_end		; don't do anything
mt_20:
	xor	ax,ax				; clear motion value
	xor	bx,bx				; clear pointer
	cmp	fSteady,false			; are we in a steady motion?
	jne	mt_40				; yes -->
	mov	bl,Accel_Ptr			; motion is accelerating

	cmp	Time_To_Max_Speed,1		; do we accel. for 1 sec. ?
	jne	mt_22				; not a 1
	mov	al,18				; 1 sec <=> 18 ticks
	mov	Accel_Table_Len,al
	jmp	mt_28

mt_22:
	cmp	Time_To_Max_Speed,2		; do we accel. for 2 sec. ?
	jne	mt_24
	mov	al,36				; 2 sec <=> 36 ticks
	mov	Accel_Table_Len,al
	jmp	mt_28

mt_24:
	cmp	Time_To_Max_Speed,3		; do we accel. for 3 sec. ?
	jne	mt_26
	mov	al,54				; 3 sec <=> 54 ticks
	mov	Accel_Table_Len,al
	jmp	mt_28

mt_26:
	mov	al,73				; 4 sec <=> 73 ticks Default back to
	mov	Accel_Table_Len,al

mt_28:

	cmp	bl,Accel_Table_Len		; are we at end of accel?
	jb	mt_30				; no -->
	mov	fSteady,true			; yes, start using constant table
	xor	bx,bx
	jmp	short mt_50			; -->
mt_30:
	mov	al,Accel_Table[bx]
	cbw
	inc	bx				; increment pointer
	mov	Accel_Ptr,bl
	jmp	short mt_60

mt_40:
	mov	bl,Constant_Ptr			; yes, get next movement
	cmp	bl,Constant_Table_Len		; are we at end of table?
	jb	mt_50				; no -->
	xor	bx,bx				; yes, reset to beginning
mt_50:
	mov	al,Constant_Table[bx]
	cbw
	inc	bx				; increment pointer
	mov	Constant_Ptr,bl
mt_60:
	or	ax,ax				; motion on this interrupt?, based on "..."table value
	jnz	mt_62				; we have a non zero, so cont. to do motion
	jmp	MouseKeys_timer_end		; no motion this time,end

mt_62:
	cmp	fSteady,false			; catches here and below (x and y direction)
	jne	mt_65
	cmp	Max_Speed,8			; don't adjust speed unless above Max_Speed 8
	jle	mt_65
	mov	ax,Max_Speed
	cmp	ax,36				; if Max_Sped is 36, shr twice
	jne	mt_64

	shr	ax,1		
mt_64:
	shr	ax,1		
;------------------
; acceleration speed adjustments

	xor	bx,bx				; clear x direction
	cmp	X_Direction,bl			; is direction 0?
	je	mt_70A				; yes -->
	mov	bx,ax				; get current acceleration variable, doesn't change flag bits
	jg	mt_70A				; is it positive? yes --> from above compare YET !!!
	neg	bx			

mt_70A:
	xor	cx,cx				; clear y direction
	cmp	Y_Direction,cl			; is direction 0?
	je	mt_80				; yes -->
	mov	cx,ax				; get accel. variable***
	jg	mt_80				; is it positive?, yes -->from above compare YET !!!
	neg	cx
	jmp	short mt_80
;------------------
; standard acceleration and constant speed

mt_65:
	xor	bx,bx				; clear x direction
	cmp	X_Direction,bl			; is direction 0?
	je	mt_70				; yes -->
	mov	bx,Max_Speed			; get current acceleration variable, doesn't change flag bits
	jg	mt_70				; is it positive? yes --> from above compare YET !!!
	neg	bx			

mt_70:
	xor	cx,cx				; clear y direction
	cmp	Y_Direction,cl			; is direction 0?
	je	mt_80				; yes -->
	mov	cx,Max_Speed			; get accel. variable***
	jg	mt_80				; is it positive?, yes -->from above compare YET !!!
	neg	cx

mt_80:
	cmp	_fmouse_id,4			; is the PS/2 mouse driver loaded
	jne	mt_90

	mov	Delta_Y,cx			; preload Delta_X before calling Inject Mouse
	mov	Delta_X,bx			; preload Delta_Y before calling Inject Mouse

	xor	ax,ax
	mov	al,Status			; now have direction status in al register
	or	al,Button_Status		; get button status info. into al register
	mov	Mouse_Status,ax

	call	InjectMouse
	jmp	short MouseKeys_timer_end

mt_90:
; cx register has Delta_y, and bx register has Delta_X data

	cmp	_fmouse_id,2	 		; do we have a serial mouse ?
	jne	MouseKeys_timer_end

	cmp	cl,00h				; if y is zero, leave alone
	je	mt_95

	test	cl,80h				; if y is neg, for serial mouse must switch
	jnz	mt_92
	or	Status,0Ch			; build Status for neg. Y dir.

mt_92:
	neg	cl				; 2's compl. Y, 

mt_95:

	mov	Delta_Y,cx			; load Delta_Y
	and	Delta_Y,03fh			; flag not the first byte

	mov	Delta_X,bx			; load Delta_X 

	test	bl,80h				; is x neg?
	jz	mt_97
	or	Status,03h			; build Status for neg X dir.

mt_97:
	and 	Delta_X,03fh			; flag not the first byte
	xor	ax,ax				; make sure ax is 0
      	mov	al,Status
	or	al,Button_Status
	or	al,40h		  		; need to always set this bit for serial mouse button byte


	mov	Mouse_Status,ax	

	cmp	mouse_cnt,100			; are there 100 nouse data wors in buffer already ?
	jge	MouseKeys_timer_end

	call	Put_Mouse_Data			; store info on serial mouse in buffer
	mov	ax,Delta_X
	call	Put_Mouse_Data			; store info on serial mouse in buffer
	mov	ax,Delta_Y
	call	Put_Mouse_Data			; store info on serial mouse in buffer

	mov	fmouse_button,true     		; is a mousekeys mouse button data

MouseKeys_timer_end:
	ret
MouseKeys_timer	endp
;------------------------------------------------------------------------
; the following routines provide the sound feedback.

mk_turn_on_fb	proc	
	assume	DS:_TEXT

	cmp	fMK_On_Off_Feedback,false
	je	MouseKeys_TurnOn
	call	beep_turn_on
MouseKeys_TurnOn:
	cmp	fswitching_video,false
	jne	MouseKeys_TurnOn_3
	mov	faccess_sound,true
	mov	fsecond_cue,24

MouseKeys_TurnOn_3:

	mov	fJust_Manually_On,true

MouseKeys_TurnOn_5:

	mov	fpass_numlock_spsav,false	
	mov	fpass_mousekeys,true			; trap numeric pad keys as MouseKeys

	call	stop_moving
	mov	fbutton,false				; reset mousekey mouse button to false
	mov	fbutton_up,false
	mov	fbutton_down,false
	mov	fmouse_button,false


; reset mouse_data buffer to empty, i.e. point head and tail to the start of the buffer

	push	bx					; temp save of bx register
	mov	bx,OFFSET mouse_data			; get address of mouse_data buffer
	mov	mouse_data_head,bx			; reset head pointer to start of buffer
	mov	mouse_data_tail,bx			; reset tail pointer to start of buffer
	mov	mouse_cnt,false				; 
	mov	fserial_stop,false	
	pop	bx

	call	TimeOut_Reset
	mov	fMouseKeysOn,true
	cmp	_fmouse_id,4				; do we have a PS/2 mouse ?
	jne	mk_turn_on_5
	mov	Current_Button,01h
	mov	Temp_Button,false
	jmp	short mk_turn_on_10
mk_turn_on_5:
	cmp	_fmouse_id,2				; do we have a serial mouse ?
	jne	short mk_turn_on_10
	mov	Current_Button,20h
mk_turn_on_10:
	mov	Button_Status,0				; buttons default up at turn on

	ret

mk_turn_on_fb	endp

;----------------------------------------------------------------------------

mk_turn_off_fb	proc	

	assume	DS:_TEXT

	cmp	fMK_On_Off_Feedback,false
	je	MouseKeys_TurnOff
	call	beep_turn_off

MouseKeys_TurnOff:

	cmp	fswitching_video,false
	jne	MouseKeys_TurnOff_5
	mov	faccess_sound,true
	mov	fsecond_cue,25

MouseKeys_TurnOff_5:

	mov	fJust_Manually_Off,true			; flag that we just turned off
	mov	fserial_stop,false	
	call	stop_moving

	cmp	Button_Status,0				; check to see if MouseButton's are up?
	je	MKTOff_20				; yes, ignore and jump around resetting of button code				       

	push	ax					; temp save
	push	cx					; temp save
	mov	cx,0053h				; button up key code
	mov	ax,1					; same as if called from table for a button up
	mov	fbutton_up,true				; ""
	mov	fbutton_down,false			; ""
	call	button_click				; 
	pop	cx					; restore register
	pop	ax					; restore register

MKTOff_20:

	mov	fMouseKeysOn,false			; no, then turn off
	mov	fnum_lock_was_off,false			; reset to false
	ret

mk_turn_off_fb	endp
;----------------------------------------------------------------------------
; MouseKeys_dialog 
;
;	Checks a single flag from Dialog box to see if MouseKeys was turned
; on/off.  If it was, this routine makes a call to MouseKeys_TurnOn/Off so the realstates
; can be updated to match the computer.  Upon exit the flag that was set by 
; Dialog box is cleared.(returned to false)


MouseKeys_dialog	proc	

	assume	DS:_TEXT

	cmp	fMouseKeysOn,true			; was Stickeys turned on
	jne	Md_25
	cmp	fmouse_driver,false			; if fmouse_driver false, don't turn mousekeys on
	je	Md_50					; no, just pass on -->
	call	MouseKeys_TurnOn_5     			; yes it was true, so turn on
	cmp	fspace_saver,true
	jne	Md_50
	mov	fpass_mousekeys,false			; start space_saver kybd in off position if turned on via menu
	jmp	short Md_50

Md_25:
	call	MouseKeys_TurnOff_5			; fMouseKeyOn was false, so turn off
Md_50:
	mov	fDialog_Mouse_off,false			; reset flag to false
	ret

MouseKeys_dialog	endp

;----------------------------------------------------------------------------
;     INJECT MOUSE
;
;expects:  
;	AX Mouse Status Word
;	BX X Data Word
;	CX Y Data Word
;	DX Z Data Word
;
;returns: nothing
;
;calls:	Pointing Device Driver at segment [40:0E], offset [22h]
;	Int 74h (80286 or higher CPUs) or 71h (8086 CPUs)
;
;----------------------------------------------------------------------------

InjectMouse	proc

	assume	DS:_TEXT

;-DEBUGGING---------------------------------------------------------------------
;
;;;	cmp	fwindows_enh,true
;;;	jne	IM_10
;;;	call	click	       
;	push	ax
;	mov	ax,Mouse_Status
;	call	Put_Mouse_Data	 
;	mov	ax,Delta_X
;	call	Put_Mouse_Data	 
;	mov	ax,Delta_Y
;	call	Put_Mouse_Data	 
;	pop	ax
;	jmp	IM_150		; ADDED LABEL
;----------------------------------------------------------------------
;
;IM_10:

	cli					; disable int

	push 	es
	push	ax
	push	bx
	push	cx
	push	dx

	xor	ax,ax				; make sure the registers are zero
	xor	bx,bx
	xor	cx,cx
	xor 	dx,dx

	mov	fmouse_button,true     		; is a mousekeys mouse button data

	mov	ax,Mouse_Status
	push 	ax			 	;first status goes on stack

	mov	bx,Delta_X
	push 	bx			 	;now X data

       	mov	cx,Delta_Y
	push 	cx			 	;now Y

       	mov	dx,Delta_Z
	push 	dx			 	;now Z, always equal to 0


;now call device driver pointer routine to store values in its data area

	assume ES:NOTHING

	mov 	ax,ExtendedSeg      		;get extended BIOS segment
	mov	es,ax

	call dword ptr es:[22h]			;call user pointer routine

; Since the device driver does most of its processing in the hardware interrupt routine rather than the pointer 
; routine, we have to call it.  This is done by simulating an interrupt.  The device driver calls the 
; normal bios interrupt routine, checks to see if it got any data, and then processes the data.  We stuffed data 
; in already, (i.e. simulated the normal bios interrupt routine).  When the normal bios interrupt routine is 
; called, it will see no data at the hardware port so it should just return.  We assume this will always happen 
; but we may have to disable the mouse to make sure it will always happen.  Also, since no data was found, the
; normal bios interrupt routine will not call the pointer routine. This is great since we called the pointer 
; routine with our data. The device driver will now process our data.
;
; Now call interrupt routine to process the new data

	cmp	_comp_id,8			; which computer model do we have ?
	jne	IM_40
	int 74h					; works for high end PS/2 Models (55SX,70,80)
	jmp	IM_100

IM_40:
	cmp	_comp_id,7			; which computer model do we have ?
	jne	IM_50
	int 74h					; works for high end PS/2 Models ("25/286","30/286",50,60)
	jmp	IM_100

IM_50:
	cmp	_comp_id,6
	jne	IM_120
	int	71h				; works for low end PS/2 Models (25,30,.../86)


IM_100:
	add sp,+8				; get our stuff off stack after the interrupt

IM_120:
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop 	es

	sti					; re-enable int.'s
;;IM_150:

	ret

InjectMouse endp

;----------------------------------------------------------------------------
; stops smooth motion moving of the PS/2 and Serial mouse

stop_moving	proc	

	assume	DS:_TEXT

	mov	Last_Direction,0
	mov	fMoving,false
	mov	fSteady,false
	mov	Accel_Ptr,0
	mov	Delta_X,0
	mov	Delta_Y,0
	mov	Status,0

; don't reset mouse_data buffer on a mouse button (i.e. button down/up, click, dblclick)
	cmp	fbutton,true
	je	stop_moving_end

; don't reset mouse data buffer unless it's a serial mouse
	cmp	_fmouse_id,2
	jne	stop_moving_end

	mov	fserial_stop,true			; flag that we want to stop sending serial mouse novmnts

;	push	bx					; temp save of bx register
;	mov	bx,OFFSET mouse_data			; get address of mouse_data buffer
;	mov	mouse_data_head,bx			; reset head pointer to start of buffer
;	mov	mouse_data_tail,bx			; reset tail pointer to start of buffer
;	mov	mouse_cnt,false				; 
;	pop	bx

stop_moving_end:

	ret
stop_moving	endp

;----------------------------------------------------------------------------
; dummy_proc
;
; Expects:	Nothing

dummy_proc	proc	

	assume	DS:_TEXT

; When this procedure is called, the actual scan code still resides in "cx" register
; so if we mov "cx" back to "ax" and then call ToggleKeys, then everything is back to normal.

	mov	ax,cx					; restore scan code to "ax" register
	mov	fbutton,false				; move mousekey mouse button to false

	call	ToggleKeys				; pass ENTER key on, actually the "E0" part of scan code
							; was passed by handicap.asm

	cmp	ftimer_1C_active,true			; if space_saver kybd, and we called ToggleKeys, 
							; must undo previous clearing of fbios_called_timing if fFilterKeys is On
	jne	dummy_proc_end

	mov	fbios_called_timing,true		; reset flag so int. 15 will pass the key and exit

dummy_proc_end:

	ret
dummy_proc	endp

;----------------------------------------------------------------------------
; off_proc
;
; Expects:	cx = extended scan code
;
; This routine only gets the break codes of numlock when turned on, the make/break
; code of the numlock if the operator wants to toggle MouseKeys on/off, or the make num lock
; scan code when the operator wants to turn off MouseKeys.  It is set up for laptops especially,
; and all other computers that toggling the numlock key by itself whilc MouseKeys is on, will
; toggle the Numeric KeyPad On/Off (i.e. MouseKeys will toggle On/Off but not tottaly off)
; which requires three key left shift left alt and numlock keys

off_proc	proc	

	assume	DS:_TEXT

	cmp	fJust_Manually_On,true			; is this the break of turn On numlock ?
	jne	off_25

	test	cl,break_bit				; is it a make numlock, if so pass
	jnz	off_10					; wait for numlock break to turn on
       	jmp	off_112					; typematic makes of num lock turn on, eat

off_10:
       	cmp	fspace_saver,true			; if space saver keyboard, must pass on break
	jne	off_20 					; if we passed on the num lock make originally

	cmp	fSticKeysOn,true			; is StickeyKeys On ???
	jne	off_20

	cmp	fnum_lock_was_off,true			; see if we originally passed num lock make code ?
	jne	off_20					; if not, do not pass on the break as well
	jmp	off_107
						
off_20:
	jmp	off_110					; if not, exit at 110 by not passing key on

off_25:

; if gets here, it could be numlock make/break and we don't know if the user waants to turn MouseKeys Off
; unless we check if the left shift and the left alt keys are depressed
; NOTE: If StickeyKeys is On, the modifier flags will only be set on the make of the num lock key.

	cmp	dh,fLshift + fAlt			; are the left shift and alt down?
	jne	off_100					; no, so just a numlock make by itself, pass on
							; if yes, left alt + left shift + numlock so shut off
	call	mk_turn_off_fb	       	
	mov	fbutton,false				; move mousekey mouse button to false
	mov	fpass_numlock_spsav,false		; clear flag
	jmp	off_110					; jump to here so we eat the numlock make code
		
off_100:
; if gets here, it is just a numlock make/break without any modifier keys

	test	cl,break_bit				; is it a make numlock, if yes, change status
	jz	off_101
	jmp	off_106       			 	; it was a break, pass on for all KYBDS 
 
off_101:
	cmp   	fpass_numlock_spsav,true		; flag to stop typematic on/off/on/off... of MouseKeys
	jne	off_102
	jmp	off_110

off_102:
	mov	fpass_numlock_spsav,true

	cmp	fpass_mousekeys,true			; are MouseKeys currently being trapped ???
	je	off_105

	mov	fpass_mousekeys,true			; trap numeric keys (i.e MouseKeys is On)
       	cmp	fspace_saver,true			; it was a make, do we have the space saver ?
	jne	off_103D
	cmp	fSticKeysOn,true			; is StickeyKeys On ???
	jne	off_103D				; if StickeyKeys isn't On, don't mess with Num Lock


off_103A:
	cmp	fToggleKeysOn,true
	jne	off_103D
	jmp	off_107					; passing num lock on by space saver will do beeps

off_103D:
	cmp	fMK_On_Off_Feedback,false
	je	off_103E
	call	beep_high				; beep high if toggle Mousekeys back on
off_103E:
	cmp	fswitching_video,false
	jne	off_104
	mov	faccess_sound,true
	mov	fsecond_cue,7
off_104:
       	cmp	fspace_saver,true			; is it space saver ?
	je	off_107
	jmp	short off_110

;--------------------------------------------
off_105:
	mov	fpass_mousekeys,false			; untrap or pass numeric keys (i.e MouseKeys is Off)
       	cmp	fspace_saver,true			; it was a make, do we have the space saver ?
	jne	off_105C
	cmp	fSticKeysOn,true			; is StickeyKeys On ???
	jne	off_105C				; if StickeyKeys isn't On, don't mess with Num Lock

off_105A:

	cmp	fToggleKeysOn,true
	jne	off_105C
	jmp	short off_107				; passing num lock on by space saver will do beeps

off_105C:
	cmp	fMK_On_Off_Feedback,false
	je	off_105D
	call	beep_low				; beep low if toggle Mousekeys back off
off_105D:

	cmp	fswitching_video,false
	jne	off_105E
	mov	faccess_sound,true
	mov	fsecond_cue,9

off_105E:

; if we toggle off, we must be sure that mousekeys mouse buttons are released

	push	ax					; temp save
	push	cx					; temp save
	mov	cx,0053h				; button up key code
	mov	ax,1					; same as if called from table for a button up
	mov	fbutton_up,true				; ""
	mov	fbutton_down,false			; ""
	call	button_click	   			; ""
	pop	cx					; restore register
	pop	ax					; restore register
       	cmp	fspace_saver,true			; it was a make, do we have the space saver ?
	je	off_107
	jmp	short off_110

off_106:
	mov	fpass_numlock_spsav,false		; we got a break of the num lock, clear flag

off_107:
	cmp	fSticKeysOn,true			; is StickeyKeys On ???
	jne	off_110					; if StickeyKeys isn't On, don't mess with Num Lock

	mov	ax,cx					; ToggleKeys expects scan code in ax register
	call	ToggleKeys				; pass num lock key on, regardless if Mkeys On/Off
	cmp	ftimer_1C_active,true			; if space_saver kybd, and we called ToggleKeys, 
							; must undo previous clearing of fbios_called_timing if fFilterKeys is On
	jne	off_110
	mov	fbios_called_timing,true		; reset flag so int. 15 will pass the key and exit

off_110:
	mov	fnum_lock_was_off,false
	mov	fJust_Manually_On,false
off_112:	
	ret
off_proc	endp

;----------------------------------------------------------------------------
; btn_sel_proc
;
; Expects:	ax = button value, where ah=button if serial mouse and al=button if AUX. port mouse
;
;		Must check here for which type of keyboard we have.  If we have the 101/102
;		key beyboard, then we can emulate a 3 button mouse because we have "/,*, and-"
;		on the numeric keypad.  If we do not have the 101/102 keyboard, then we 
;		probably only have the 84 key keyboard, which only has the "* and -" key,
;		so we can only emulate a 2 button mouse.  If ax="btn_1 + btn_2", or "03h",(AUX) mouse,
;		then, we must check to keyboard type and either leave ax alone for the 
;		101/102 key keyboard, or reset to only "btn_1" for an 84 key keyboard.



btn_sel_proc	proc	

	assume	DS:_TEXT

	push	ax

	mov	fbutton,false				; move mousekey mouse button to false
	cmp	_fmouse_id,4				; do we have a AUX. port PS/2 mouse ?
	jne	btn_sel_10

	mov	Temp_Button,al				; set to which ever button(s)
	cmp	Temp_Button,03h				; is it a "btn_1 + btn_2" ?
	je	btn_sel_20				; yes, so check if we support it

	mov	Current_Button,al			; no, select what ever button, and quit
	jmp	short btn_sel_60     			; process both buttons pushed together


btn_sel_10:
	cmp	_fmouse_id,2				; do we have a serial port mouse ?
	jne	btn_sel_50				; no, somethings wrong !!! this should never execute !

	mov	Temp_Button,ah				; set to which ever button(s)
	cmp	Temp_Button,030h			; is it a "btn_1 + btn_2" ?
	je	btn_sel_20	 			; yes, so check if we support it

	mov	Current_Button,ah			; no, select what ever button, and quit
	jmp	short btn_sel_60     			; process both buttons pushed together


btn_sel_20:

; if we get here, we have a "btn_1 + btn_2" push, and need to verify the keyboard type
; we can now check comp_id, and if we don't have a 2(New XT), 6(25..30/86), 7(New XT
; New AT, 25..30..50..60/286) or 8(55SX..70..80), then we don't have a kb_flag_3 to check !!!
; Could also be true for new 5A or 1A....see new keyboard.inc

 	cmp	comp_flag,true	 		   	; do we have a comp_id of #2,#5A,#5B,#6,#7, or #8 ?
	jne	btn_sel_25
	mov	Current_Button,al			; let btn1+btn2 through
	jmp	short btn_sel_60

btn_sel_25:

; if comp_flag is not set, we have a comp_id of 1=PC, 5=Orig. AT
; 3= Jr. or 4=Conv.  We do not support selections 3 and 4, and if it is either
; 1 or 5, the mouse must be a serial mouse, so reset the mouse button to the left 
; button for either of these two, or beep error for Jr./Conv. and then set button

	cmp	_comp_id,1
	je	btn_sel_55
	cmp	_comp_id,5
	je	btn_sel_55

btn_sel_50:

	call	beep_high				; beep high for button error selection
	cmp	fswitching_video,false
	jne	btn_sel_55
	mov	faccess_sound,true
	mov	fsecond_cue,7

btn_sel_55:
; there is really no reason why a PS/2 should have an 84 key keyboard and a serial mouse !!!

	cmp	_fmouse_id,4				; do we have a AUX. port PS/2 mouse ?
	jne	btn_sel_56
	mov	Current_Button,01h			; left button AUX
	jmp	short btn_sel_60

btn_sel_56:
	cmp	_fmouse_id,2				; do we have a serial port mouse ?
	jne	btn_sel_60				; no, somethings wrong !!! this should never execute !
	mov	Current_Button,020h			; left button serial

btn_sel_60:

	pop	ax
	ret

btn_sel_proc	endp

;----------------------------------------------------------------------------
; button_delta
;
; Expects:	ax = 0 - buttons up
;		   = non 0 - buttons down
;		cx = extended scan code
;
; Changes:	bx,dx

button_delta	proc

	assume	DS:_TEXT

	push	ax
	push	bx
	push	cx
	push	dx

	mov	fbutton,true				; mousekeys mouse button 
	test	cl,break_bit				; is this the break key?
	jz	bd_5					; no, so cont. on
	jmp	button_delta_end			; was a break key, so quit

bd_5:

	call	stop_moving				; yes, so stop any motion
	mov	bl,Button_Status			; current status
	mov	cl,Current_Button			; current button(s) to press


	or	ax,ax					; do a button(s) down?
	jz	bd_10					; no -->

; Button down

	or	dl,cl					; get new status
	mov	Button_Status,dl			; keep Button_Status for next time thru
	jmp	bd_100

; Button up

bd_10:

	or	bl,bl					; any buttons down to let up
	jnz	bd_15
	jmp	button_delta_end			; no, was zero, so quit

bd_15:

	not	cl					; get mask to clear state
	and	dl,cl					; get new status
	mov	Button_Status,dl			; keep Button_Status for next time thru

; Now do delta

bd_100:

	cmp	_fmouse_id,4				; is the PS/2 mouse driver loaded
	jne	bd_140		

	cmp	Current_Button,1			; left button ?
	jne	bd_110
	cmp	dl,0					; button up ?
	jne	bd_105
	mov	dx,0008h				; release button 1
	jmp	bd_130

bd_105:
	mov	dx,0009h				; press button 1
	jmp	bd_130

bd_110:

	cmp	Current_Button,2			; right button ?
	jne	bd_120
	cmp	dl,0					; button up ?
	jne	bd_115
	mov	dx,0008h				; release button 2
	jmp	bd_130

bd_115:
	mov	dx,000ah				; press button 2
	jmp	bd_130

bd_120:							; if gets here, both buttons must be down/up

	cmp	dl,0					; button up ?
	jne	bd_125
	mov	dx,0008h 				; release both buttons
	jmp	bd_130

bd_125:
	mov	dx,000bh 				; press both buttons
bd_130:

	mov	Mouse_Status,dx
	jmp	bd_200

;-----------------------------------------------------------------------------
; serial mouse buttons

bd_140:

	cmp	_fmouse_id,2	 			; do we have a serial mouse ?
	jne	button_delta_end
							; process serial mouse data
	cmp	Current_Button,20h			; left button ?
	jne	bd_150
	cmp	dl,0h					; button up ?
	jne	bd_145
	mov	dx,0040h				; release button 1
	jmp	bd_190

bd_145:
	mov	dx,0060h				; press button 1
	jmp	bd_190

bd_150:

	cmp	Current_Button,10h			; right button ?
	jne	bd_160
	cmp	dl,0h					; button up ?
	jne	bd_155
	mov	dx,0040h				; release button 2
	jmp	bd_190

bd_155:
	mov	dx,0050h     				; press button 2
	jmp	bd_190

bd_160:							; if gets here, both buttons must be down/up

	cmp	dl,00h					; button up ?
	jne	bd_165
	mov	dx,0040h 				; release both buttons
	jmp	bd_190

bd_165:
	mov	dx,0070h 				; press both buttons

bd_190:

	mov	Mouse_Status,dx	

bd_200:

	cmp	mouse_cnt,100				; are there 100 mouse data words in buffer already ?
	jge	button_delta_end

	push	ax

	mov	ax,Mouse_Status
	call	Put_Mouse_Data				; store info on serial mouse or PS/2 mouse in buffer
	mov	ax,Delta_X
	call	Put_Mouse_Data				; store info on serial mouse or PS/2 mouse in buffer
	mov	ax,Delta_Y
	call	Put_Mouse_Data				; store info on serial mouse or PS/2 mouse in buffer

	pop	ax
	mov	fmouse_button,true     			; is a mousekeys mouse button data

button_delta_end:

	pop	dx
	pop	cx
	pop	bx
	pop	ax

	ret
button_delta	endp

;----------------------------------------------------------------------------
; button_click
;
; Expects:	nothing
;
; Changes:	ax,bx,cx,dx

button_click 	proc

	assume	DS:_TEXT

  	mov	fbutton,true			; mousekeys mouse button to true

	cmp	fbutton_up,true			; if we got a MouseKeys button_up, jump to do a button down/up only
	jne	button_click_5
	cmp	fmousetrapping,true		; is mouse int. hook off?
	jne	button_click_10
	mov	fbutton_up,false		; reset here if mouse int. trapping is off
	jmp	short button_click_15

button_click_5:

	xor	ax,ax
	call	button_delta			; make sure they are all up
	not	ax

button_click_10:

	call	button_delta			; then do click

button_click_15:

	xor	ax,ax
	call	button_delta
	ret
button_click	endp

;----------------------------------------------------------------------------
; dbl_click_proc
;
; Expects:	Nothing

dbl_click_proc	proc	

	assume	DS:_TEXT

	call	button_click
	call	button_click
	ret
dbl_click_proc	endp

;----------------------------------------------------------------------------
; move_proc
;
; Expects:	ax = direction	ah = x dir
;				al = y dir
;		cx = extended code
;
; Changes:	ax,cx


move_proc	proc	

	assume	DS:_TEXT

	push	cx
	push	ax

; check for break of key
	
	mov	fbutton,false		; move mousekey mouse button to false
	test	cl,break_bit		; is it a break key?
	jz	move_10			; no -->

; deal with break of key

move_proc_5:

	call	stop_moving		; yes, stop moving mouse

move_7:	
	jmp	move_proc_end

; deal with the make of a mousekey

move_10:
	cmp	Last_Direction,ax	; is this the same as last direction?
	jne	move_20			; no -->
	mov	fMoving,true
	jmp	move_proc_end
move_20:
	call	stop_moving		; stop any other current motion

	mov	Last_Direction,ax	; save direction

; added code to allow the mouse cursor to move using mousekeys even if RepeatKeys is off

	cmp	fUser_SetUp_Option1,true	; if set, reallow fmoving
	je	MK_10

	cmp	fUser_SetUp_Option2,true	; if set, reallow fmoving
	je	MK_10

	cmp	on_repeat_ticks,32760		; if set, repeat keys is off, reallow fmoving
	je	MK_10

	cmp	fRecovery_On,true		; if RecoveryKeys is on, reallow fmoving
	je	MK_10

	cmp	fserial_key_recieved,true	; if serial_key input, reallow fmoving
	je	MK_10

	cmp	_fmouse_id,2	 		; do we have a serial mouse ?
	jne	MK_20				; if we have a serial mouse, allow each key tap to get sent

MK_10:
	mov	fMoving,true			; allow mousekeys to work even if RepeatKeys is off

MK_20:
	mov	cx,ax				; get copy into cx

	cmp	_fmouse_id,4			; is the PS/2 mouse driver loaded
	jne	MK_60

	and	ax,00ffh			; mask off ah, so al = y data

	mov	Delta_Y,ax			; Set delta Y

	test	al,80h				; is the high bit set (i.e. neg ?)
	jz	MK_30
	or	Status,20h			; if was neg, set bit 5 for negative Y
MK_30:

	mov	ax,cx				; restore ax with ah = x data, and al = y data
	mov	al,ah
	and	ax,00ffh			; mask off ah, so al now = x data

	mov	Delta_X,ax			; Set delta X

	test	al,80h				; is the high bit set (i.e. neg ?)
	jz	MK_50
	or	Status,10h			; if was neg, set bit 4 for negative X

MK_50:

	mov	al,Status			; now have direction in al register
	or	al,Button_Status		; get button status info. into al register
	mov	Mouse_Status,ax			; store into mouse_status for prep. to call inject proc.
	call	InjectMouse
	jmp	move_proc_end
;-------------------------------------------------------------------------------------
; serial mouse


MK_60:

	cmp	_fmouse_id,2	 		; do we have a serial mouse ?
	jne	move_proc_end
						; process serial mouse data
MK_70:
	and	ax,00ffh			; mask off ah, so al = y data

	cmp	al,00h				; if zero y movement, cont. on
	je	MK_80

	test	al,80h				; is the high bit set (i.e. neg ?)
	jnz	MK_75
	or	Status,0Ch			; if was pos, set bit 3 and 2 for negative Y
MK_75:
	neg	al				; serial mouse neg Y is up ! 
						
MK_80:
	mov	Delta_Y,ax			; Set delta Y
	and	Delta_Y,03fh			; flag not the first byte

	mov	ax,cx				; restore ax with ah = x data, and al = y data
	mov	al,ah
	and	ax,00ffh			; mask off ah, so al now = x data

	mov	Delta_X,ax			; Set delta X


	test	al,80h				; is the high bit set (i.e. neg ?)
	jz	MK_85
	or	Status,03h			; if was neg, set bit 1 and 0 for negative X

MK_85:

	and	Delta_X,03fh			; flag not the first byte

	mov	al,Status			; now have direction in al register
	or	al,Button_Status		; get button status info. into al register
	or	al,40h				; set the bit which always needs to be set for serial mouse

	mov	Mouse_Status,ax			; store into mouse_status for prep. to call inject proc.

	cmp	mouse_cnt,100			; are there 100 nouse data wors in buffer already ?
	jge	move_proc_end

	call	Put_Mouse_Data			; store info on serial mouse in buffer
	mov	ax,Delta_X
	call	Put_Mouse_Data			; store info on serial mouse in buffer
	mov	ax,Delta_Y
	call	Put_Mouse_Data			; store info on serial mouse in buffer

	mov	fmouse_button,true     		; is a mousekeys mouse button data

move_proc_end:

	pop	ax
	pop	cx
	ret
move_proc	endp

;---------------------------------------------------------------------------------------
;---------------------------------------------------------------------------------------
;---------------------------------------------------------------------------------------
; MouseKeys
;
;   This is the beginning of the routine to emulate a mouse with the keypad
; of the keyboard.  It expects the extended scan code to be in AX.
;---------------------------------------------------------------------------------------
;---------------------------------------------------------------------------------------
;---------------------------------------------------------------------------------------

mouse_begin:

	assume	DS:_TEXT

	push	es
	push	cs
	pop	es
	assume	ES:_TEXT

	mov	dh,shift_flg			; get assumed current states
	or	dh,real_states
	or	dh,lock_flg

	cmp	fMouseKeysOn,true		; is mouse key on?
	je	mouse_100			; yes, do routines -->

;----------------------------------------------------------------------------
; We are off so only check to see if turned on
;
	
	cmp	ax,NumLock			; make of numlock?
	jne	mouse_108			; no, just pass on
	cmp	dh,fLshift + fAlt		; only the left shift and alt down?
	jne	mouse_110			; no, pass on -->

; must check if turned on by 3 key sequence, if mouse driver is not loaded,
; then don't allow mousekeys to turn on 
 
	cmp	fmouse_driver,false		; if fmouse_driver false, don't turn mousekeys on
	je	mouse_112			; no, just pass on -->

	cmp	fJust_Manually_Off,true		; did we just turn off
	je	mouse_112

	call	mk_turn_on_fb
	cmp	fspace_saver,true
	jne	mouse_55

	cmp	fSticKeysOn,true		; is StickeyKeys On ???
	jne	mouse_55			; if StickeyKeys isn't On, don't mess with Num Lock
				       	
	push	es
	push	bx
	push	ax
	assume 	es:NOTHING
	mov	bx,RAMBIOS
	mov	es,bx
	assume	es:RAMBIOS
	mov	al,es:[kb_flag]
	test	al,fNum				; is the num lock key already down ?
	jnz	mouse_50			; if not zero, then it is already down and we don't want to pass it again
	mov	fnum_lock_was_off,true		; flag ourselves that we are going to pass the make
	pop	ax
	pop	bx
	pop	es
	assume	es:_TEXT
	jmp	short mouse_110			; if space saver keyboard, pass num lock make on, as it will 
						; set up mousekeys correctly as num lock will be on
mouse_50:
	pop	ax
	pop	bx
	pop	es
	assume	es:_TEXT
	mov	fnum_lock_was_off,false		; flag ourselves that we did not pass the make, so we don't have to
						; pass the break in off_proc

mouse_55:
	jmp	MouseKeys_end			; inhibit key stroke -->

;----------------------------------------------------------------------------
; we are on, so check for pertainent keys of mousekeys
;
mouse_100:

; must check if turned on by Dialog Box, if mouse driver is not loaded,
; then don't allow mousekeys to call Inject Mouse 

mouse_102:

	cmp	fmouse_driver,false		; if fmouse_driver false, don't turn mousekeys on
	je	mouse_110			; no, just pass on -->

	mov	si,ax				; save extended scan code in bx
	and	al,not break_bit		; get make scan code in al
	mov	cx,mouse_tbl_len		; search for a mouse key
	mov	di,offset mouse_tbl		; when done, cl will hold shift
	cld					;   count to get flag for mouse key
	repne	scasw				; ne=not found  e=found
	je	mouse_10			; yes, a key we are interested in -->
;
; Does not assume ToggleKeys saves any registers
;
	call	stop_moving			; no
	mov	ax,si				; restore original extended scan

	push	es
	push	ax
	assume	ES:NOTHING
	mov	ax, RAMBIOS	 		; BIOS RAM segment at 40h
	mov	es,ax		 		;  .. point ES to that!
	assume	ES:RAMBIOS
	mov	al,es:kb_flag			; take a quick look at the flags
	and	al,03h				; mask off eveything except bits 1 and 0, left and right shift
	jnz	mouse_105			; if either bit is set, then don't reset fmouse_button flag (i.e. shift click in progress)
	mov	fmouse_button,false  		; not a mousekeys mouse button

mouse_105:

	pop	ax			
	pop	es
	assume	ES:_TEXT

mouse_108:
	mov	fJust_Manually_Off,false	 ; reset to false upon non mousekey 

mouse_110:
	call	ToggleKeys			; pass key on
mouse_112:
	jmp	MouseKeys_end
;
; We expect cx to hold the count of the key we found.  We will now use it
; as an index into tables and jump to the appropriate routine to handle the
; key.

mouse_10:

	shl	cx,1				; multiply by 2 to get offset to words
	mov	bx,cx				; put in bx
	mov	cx,si				; put scan in cx
	cmp	cx,052h				; is it mouse button down ?
	jne	mouse_12
	mov	fbutton_down,true		; yes it was, flag for later processing
	mov	fbutton_up,false		; reset other button flag
	jmp	short mouse_20

mouse_12:

	cmp	cx,053h				; button_up make code only, break falls thru per norm
	jne	mouse_20
	mov 	fbutton_up,true			; if it is button_up, flag for later processing
	mov	fbutton_down,false		; reset other button flag

; since it is the period key, or "DEL", check to see if "CTRL and ALT" keys are down,
; i.e. the user wants to reboot, so don't make them have to turn off MouseKeys to do so
; for those users who do not have a seperate "DEL" cursor pad key

	push	es
	push	ax
	assume	ES:NOTHING
	mov	ax, RAMBIOS	 		; BIOS RAM segment at 40h
	mov	es,ax		 		;  .. point ES to that!
	assume	ES:RAMBIOS
	mov	al,es:kb_flag			; take a quick look at the flags
	and	al,0ch				; mask off eveything except bits 2 and 3(ctrl and alt)
	cmp	al,0ch				; are both bits set
	jne	mouse_18			; if no flags are set, cont. on as normal
	pop	ax			
	pop	es
	mov	fmouse_button,false		; not a mousekeys mouse button
	mov	ax,si				; restore original extended scan
	call	ToggleKeys			; pass key on, which will cause a reboot !!!
	jmp	short MouseKeys_end	

mouse_18:
	pop	ax
	pop	es
	assume	ES:_TEXT

mouse_20:

	cmp	cx,045h				; numlock make key ???
	jne	mouse_21
	jmp	short mouse_22	

mouse_21:
	cmp	cx,0c5h				; numlock break key ???
	jne	mouse_25

mouse_22:

; was a numlock make/break code, so check if it is really the nulock, or part of the PAUSE key?


	cmp	fpause_being_sent,true		; is PAUSE key being sent ??
	jne	mouse_25			; if not a PAUSE, send on as normal MouseKey

; if part of PAUSE key, pass on to ToggleKeys

	mov	ax,si				; restore original extended scan
	call	ToggleKeys			; pass key on
						; when we retrun from ToggleKeys
  	mov	fpause_being_sent,false		; reset this flag after we pass the PAUSE key parts along
	jmp	short MouseKeys_end

mouse_25:

; check first if we've been silently toggled off due to num lock key (used for laptops)

	cmp	fpass_mousekeys,true 	    	; allow numeric keys to be trapped
	je	mouse_40      		  	; yes, cont on

; fpass_mousekeys is false, we are not trapping mousekeys, so only trap numlock key

	cmp	cx,045h	     		  	; numlock make key ???
	je	mouse_40
	cmp	cx,0c5h			  	; numlock break key ??
	je	mouse_40	   	

	mov	ax,si			  	; restore original extended scan
	call	ToggleKeys		  	; pass key on
	jmp	short MouseKeys_end

mouse_40:

	mov	fbios_called_timing,false 	; reset flag if it was a mousekey and we are not calling ToggleKeys
	mov	ax,MK_data_table[bx]	  	; get data to pass to routine
	call	MK_call_table[bx]	  	; now do it

MouseKeys_end:

	pop	es
	assume ES:NOTHING

	ret
MouseKeys	endp

_TEXT	ends
	
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\mou.c ===
/* MOU.C */

#include "skdefs.h"
#include "gideidef.h"
#include "vars.h"
#include "mou.h"
#include "drv.h"
#include "init.h"

/************************************************************/
void processMouClick(void)
{
	int i;

	switch (gCode) {
		case TERMCODE:
			if (tmpStatus == 0) 							/* select default	*/
				tmpStatus = LEFTBUTTONMASK;
			if ((tmpStatus = (mouseState | tmpStatus)) != mouseState) {

				/* User is requesting clicking at least one button that isn't */
				/*  locked */
				for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));
				dataBlk.id = MOUSEID;
				dataBlk.mou.deltaX = 0;
				dataBlk.mou.deltaY = 0;
				dataBlk.mou.status = tmpStatus;
				putInOutputBuf();
				dataBlk.mou.status = mouseState;		/* return to previous state	*/
				putInOutputBuf();
				for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
				kHold.len = 0;
				}
			tmpStatus = 0;
			beginOK = TRUE;
			break;
		case LEFTBUTTONCODE:
			tmpStatus |= LEFTBUTTONMASK;
			break;
		case RIGHTBUTTONCODE:
			tmpStatus |= RIGHTBUTTONMASK;
			break;
		default:
			errDetect();
			break;
		}
}

/************************************************************/
void processMouDoubleClick(void)
{
	int i;

	if (gCode == TERMCODE) {
		if (tmpStatus == 0) 								/* select default	*/
			tmpStatus = LEFTBUTTONMASK;
		if ((tmpStatus = (mouseState | tmpStatus)) != mouseState) {
			/* User is requesting clicking at least one button that isn't */
			/*  locked */
			for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));
			dataBlk.id = MOUSEID;
			dataBlk.mou.deltaX = 0;
			dataBlk.mou.deltaY = 0;
			dataBlk.mou.status = tmpStatus;
			putInOutputBuf();
			dataBlk.mou.status = mouseState;		/* return to previous state	*/
			putInOutputBuf();
			dataBlk.mou.status = tmpStatus;
			putInOutputBuf();
			dataBlk.mou.status = mouseState;		/* return to previous state	*/
			putInOutputBuf();
			for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
			kHold.len = 0;
			}
		tmpStatus = 0;
		beginOK = TRUE;
		}
	else processMouClick();
}

/************************************************************/
void processMouLock(void)
{
	int i;

	if (gCode == TERMCODE) {
		if (tmpStatus == 0) 								/* select default	*/
			tmpStatus = LEFTBUTTONMASK;
		if ((tmpStatus = (mouseState | tmpStatus)) != mouseState) {
			/* User is requesting locking at least one button that isn't */
			/*  locked */
			for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));
			dataBlk.id = MOUSEID;
			dataBlk.mou.deltaX = 0;
			dataBlk.mou.deltaY = 0;
			dataBlk.mou.status = tmpStatus;
			putInOutputBuf();
			for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
			kHold.len = 0;
			mouseState = tmpStatus;						/* store new state	*/
			}
		tmpStatus = 0;
		beginOK = TRUE;
		}
	else processMouClick();
}


/************************************************************/
void processMouRel(void)
{
	if (gCode == TERMCODE) {
		if (tmpStatus == 0) 								/* select all	*/
			tmpStatus = (LEFTBUTTONMASK | RIGHTBUTTONMASK);
		if ((tmpStatus = (mouseState & (~tmpStatus))) != mouseState) {
			/* User is requesting releasing at least one button that is */
			/*  locked */
			dataBlk.id = MOUSEID;
			dataBlk.mou.deltaX = 0;
			dataBlk.mou.deltaY = 0;
			dataBlk.mou.status = tmpStatus;
			putInOutputBuf();
			mouseState = tmpStatus;						/* store new state	*/
			}
		tmpStatus = 0;
		beginOK = TRUE;
		}
	else processMouClick();
}

/************************************************************/
void processMouReset(void)
{
	if (gCode == TERMCODE) {
		dataBlk.id = MOUSEID;
		dataBlk.mou.deltaX = -1000;
		dataBlk.mou.deltaY = -1000;
		dataBlk.mou.status = 0;
		putInOutputBuf();
		mouseX = mouseY = 0;								/* store new state	*/
		mouseState = 0;
		beginOK = TRUE;
		}
	else errDetect();
}


/************************************************************/
void processMouMove(void)
{
	switch (gCode) {
		case TERMCODE:
			if (tmpLst.len < 4)
				for ( ; tmpLst.len >= 4; tmpLst.list[tmpLst.len++] = 0);
			moveTheMouseRelative();
			tmpLst.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			cmdVector = collectMoveByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			cmdVector = collectMoveInteger;
			beginOK = FALSE;
			break;
		default:
			errDetect();
			break;
		}
}


/************************************************************/
void collectMoveByte(void)
{
	if (tmpLst.len >= 4) errDetect();
	else {
		tmpLst.list[tmpLst.len++] = gCode;
		tmpLst.list[tmpLst.len++] = 0;
		cmdVector = processMouMove;
		}
}


/************************************************************/
void collectMoveInteger(void)
{
	if (tmpLst.len >= 4) errDetect();
	else {
		tmpLst.list[tmpLst.len++] = gCode;
		if ((tmpLst.len == 2) || (tmpLst.len == 4)) cmdVector = processMouMove;
		}
}

/************************************************************/
void moveTheMouseRelative(void)
{
	int i;

	for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));

	tmpDist = (tmpLst.list[1] << 8) + tmpLst.list[0];
	dataBlk.mou.deltaX = tmpDist;
	tmpDist += mouseX;
	mouseX = (tmpDist < 0) ? 0 : tmpDist;

	tmpDist = (tmpLst.list[3] << 8) + tmpLst.list[2];
	dataBlk.mou.deltaY = tmpDist;
	tmpDist += mouseY;
	mouseY = (tmpDist < 0) ? 0 : tmpDist;

	dataBlk.mou.status = mouseState;
	dataBlk.id = MOUSEID;
	putInOutputBuf();

	for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
	kHold.len = 0;
}



/************************************************************/
void processMouGoto(void)
{
	switch (gCode) {
		case TERMCODE:
			if (tmpLst.len < 4)
				for ( ; tmpLst.len >= 4; tmpLst.list[tmpLst.len++] = 0);
			moveTheMouseAbsolute();
			tmpLst.len = 0;
			beginOK = TRUE;
			break;
		case BYTECODE:
			cmdVector = collectGotoByte;
			beginOK = FALSE;
			break;
		case INTEGERCODE:
			cmdVector = collectGotoInteger;
			beginOK = FALSE;
			break;
		default:
			errDetect();
			break;
		}
}

/************************************************************/
void collectGotoByte(void)
{
	if (tmpLst.len >= 4) errDetect();
	else {
		tmpLst.list[tmpLst.len++] = gCode;
		tmpLst.list[tmpLst.len++] = 0;
		cmdVector = processMouGoto;
		}
}

/************************************************************/
void collectGotoInteger(void)
{
	if (tmpLst.len >= 4) errDetect();
	else {
		tmpLst.list[tmpLst.len++] = gCode;
		if ((tmpLst.len == 2) || (tmpLst.len == 4)) cmdVector = processMouGoto;
		}
}

/************************************************************/
void moveTheMouseAbsolute(void)
{
	int i;

	for (i=0; i < kHold.len; (*scanDownTransVector)(kHold.list[i++]));

	tmpDist = (tmpLst.list[1] << 8) + tmpLst.list[0];
	dataBlk.mou.deltaX = tmpDist - mouseX;
	mouseX = (tmpDist < 0) ? 0 : tmpDist;

	tmpDist = (tmpLst.list[3] << 8) + tmpLst.list[2];
	dataBlk.mou.deltaY = tmpDist - mouseY;
	mouseY = (tmpDist < 0) ? 0 : tmpDist;

	dataBlk.mou.status = mouseState;
	dataBlk.id = MOUSEID;
	putInOutputBuf();

	for (i=kHold.len; i > 0; (*scanUpTransVector)(kHold.list[--i]));
	kHold.len = 0;
}


/************************************************************/
void processMou(void)
{
	errDetect();
}

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\messages.c ===
#include "defines.h"
#include "messages.h"

char *SlowNotValidWithBounceAlertText =   "     You can not have the SlowKeys function turned on with an Acceptance Delay "
                                          "value and use the BounceKeys function at the same time.  Please note that the "
                                          "'SlowKeys On' option will be set to 'Off.'\n\n     If you want to set an Acceptance "
                                          "Delay for SlowKeys you must first select 'BounceKeys' from the Adjust menu and change "
                                          "the 'Bounce Time' option to 'Off.'";
char *BounceNotValidWithSlowAlertText =   "     You can not use the BounceKeys function when the SlowKeys function is "
                                          "turned on and Acceptance Delay has a value.  Please note that the BounceKeys function "
                                          "will be set to 'Off.'\n\n     If you want to use the BounceKeys function you must "
                                          "select 'SlowKeys' from the Adjust menu, set the 'SlowKeys On' option to 'On', "
                                          "and set 'Acceptance Delay' to 'Off.'";
char *NoSlowWithBounceAlertText        =  "     Sorry, you can not use SlowKeys and BounceKeys at the same time.";
char *NoNoteWithFlashAlertText			=  "     Sorry, you can not use the visual note and the screen flash at the same time.";
char *SerialKeysNotLoadedAlertText     =  "     You initially installed AccessDOS without enabling the SerialKeys feature.  It "
                                          "is not possible to enable SerialKeys when AccessDOS is initially loaded without it.  "
                                          "Please note that SerialKeys has been turned off.\n\n     If you want to use the "
                                          "SerialKeys function you must reboot the computer, re-run AccessDOS, and turn "
                                          "SerialKeys on before installing AccessDOS.";
char *CannotChangeCommPortAlertText    =  "     It is not possible to change the comm port once SerialKeys has been loaded.  "
                                          "Please note that the comm port has been changed back to it's original value.\n\n     "
                                          "If you want to change the comm port you must reboot the computer, re-run "
                                          "AccessDOS, select the desired comm port, and turn SerialKeys on before installing "
                                          "AccessDOS.";
char *NoMouseFoundAlertText            =  "    In order to use the MouseKeys function there must be a mouse attached to the "
                                          "computer.  AccessDOS did not find a supported mouse attached to the computer.  Please "
                                          "note that the MouseKeys function has been set to 'Off.'\n\n     If you want to use "
                                          "MouseKeys function, you must restart the computer with a mouse attached.";
char *SerKeysMouseConflictAlertText    =  "     You can not have a SerialKeys and your serial mouse attached to the same comm "
                                          "port.  Please note that the comm port for SerialKeys has been set to avoid conflicts "
                                          "with your serial mouse.\n\n  If you want to use both SerialKeys and MouseKeys, you "
                                          "must attach the mouse and the aid to different comm ports and tell AccessDOS which "
                                          "comm port the aid is attached to in the SerialKeys menu.  If you only have one comm "
                                          "port, you can not use both SerialKeys and a Serial mouse.";
char *NoSerialPortAvailableAlertText   =  "     There are no serial ports available for SerialKeys to use.  There are no serial "
                                          "ports in your computer and SerialKeys can not be used without one.  Please note that "
                                          "the SerialKeys function has been turned to 'Off.'";
char *OneSerialPortWithMouseAlertText  =  "     There are no serial ports available for SerialKeys to use.  AccessDOS has "
                                          "detected only one serial port in this computer and it is currently in use by a "
                                          "serial mouse.  Please note that the SerialKeys function has been set to 'Off.'\n\n"
                                          "     If you want to use the SerialKeys function, you will need to turn off the "
                                          "computer, disconnect the mouse, attach the communication aid to the serial port, "
                                          "and re-boot the computer.  Of course, you will not be able to use the MouseKeys "
                                          "feature in this case.";
char *NoCommTwoAlertText               =  "     You have elected to use comm port 2 for the SerialKeys function, but there is "
                                          "only one serial port in the computer.  Please note that the 'Serial Port' option has "
                                          "been set to 'COM1.'";
char *ComputerNotFoundAlertText 			=  "     AccessDOS was unable to determine what type of computer you are using.  Please "
														"select 'Miscellaneous' from the Adjust menu and choose the type of computer that most "
														"closely matches the one you are using.\n\n     If you don't choose a computer type, "
														"AccessDOS will assume you are using an IBM PC/XT with a 84 key keyboard.  This may "
														"limit the number of functions available for your use.";
char *LoadSuccessfulAlertText       	=  "\n\n AccessDOS settings were loaded successfully.";
char *LoadFailedAlertText           	=  "\nAn error has occured trying to load your saved settings.  AccessDOS "
														"requires the file ADOS.CFG to be present in the same directory that contains "
														"ADOS.COM.\n\nPlease note that AccessDOS will continue without your saved settings.";
char *SaveSuccessfulAlertText				=  "\n\n         AccessDOS settings were saved successfully.";
char *SaveFailedAlertText					=  "\n\n An error has occured trying to save AccessDOS settings.";



HELP_SCREEN_RECORD helpTextSaveParameters[] =
{
	"                                                              Page 1 of 1\n"
	"          ^SAVING AND AUTOMATICALLY STARTING UP WITH YOUR "
	"SETTINGS^\n\n     Whenever you initially run AccessDOS by just typing:  ^ADOS^\nAccessDOS will start up with the preset "
	"or default settings which were originally set at the Trace Center.  You are then brought into this program where you can "
	"change the settings to meet your particular needs.\n\n     Most users however would like to be able to save their "
	"settings so that they can use the same settings each time they start AccessDOS.  This can be done by saving your settings "
	"and then asking AccessDOS to use the saved settings when it starts up.  To do this you should:\n     1)  Use the ADJUST "
	"menu to set AccessDOS to meet your needs.\n     2)  Select SAVE SETTINGS... from the FILE menu. (saves them to disk)\n"
	"Thereafter if you ^initially^ start AccessDOS by typing:  ^ADOS /A^   or by putting   ^ADOS /A^   in your AUTOEXEC.BAT "
	"file, AccessDOS will start up with your saved settings."
	"\n                                 - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextInstallAccess[] =
{
	"                                                              Page 1 of 1\n                                ^INSTALL/RUN^"
	"\n\n     Choosing INSTALL/RUN from the FILE menu will cause AccessDOS to leave this setup program and install itself in "
	"your computer.  Once AccessDOS is installed, it will work with most of your other software programs.\n\n     If you are "
	"using SerialKeys, AccessDOS will use 25KB of your computer's memory.  If you are not using SerialKeys, it will use 10KB."
	"\n\n       You can use special key combinations on the keyboard to turn the various functions of AccessDOS on and off "
	"(see manual).  You can also turn functions on or off, and change their settings, by rerunning AccessDOS. (just type:  "
	"ADOS).\n\n    If you want to get AccessDOS completely out of your computer's memory, just reboot (restart) your computer."
	"\n                                 - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextCancelAccess[] =
{
	"                                                              Page 1 of 1\n\n                              ^CANCEL/QUIT^"
	"\n\n     Choosing CANCEL/QUIT from the FILE menu will cause AccessDOS to leave this setup program WITHOUT installing "
	"AccessDOS in your computer.\n\nUse CANCEL/QUIT if you:\n   - Want to discard any settings you just made while in the "
	"setup program\n   - Want to exit the Setup Program without installing AccessDOS.\n\nCANCEL/QUIT will NOT unload AccessDOS "
	"if you already have it installed.  If you want to unload AccessDOS you should reboot (restart) your computer.\n(NOTE: If "
	"you put ADOS in your AUTOEXEC.BAT file then see the manual for details on how to restart your computer without installing "
	"AccessDOS.)\n\n"
	"\n                                 - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextMenu[] =
{
	"                                                              Page 1 of 4\n    All of the adjustments for AccessDOS as "
	"well as the help screens can be reached by using the menus at the top of the screen.  You can move about in the menus by "
	"using the arrow keys on your keyboard.\n\n   -  Use the RIGHT and LEFT arrows to move between menus.\n   -  Use the UP "
	"and DOWN arrows to move up and down within a menu.\n   -  Use the ENTER key to select an item from the menu.\n\nSHORTCUT"
	"\n   You can also jump directly to an item in a menu (instead of using the UP and DOWN keys) by typing the hot key "
	"for that menu item.  The hot key for each menu item is the character that is a different color from the rest (on "
	"a black and white LCD display it would be Capitalized).\n     For example:    E would be the hot key for "
	"sErialkeys.\n                     M would be the hot key for Mousekeys.\n"
	"\n                                                                   MORE...",
	FALSE,
	"                                                              Page 2 of 4\n                  ^ Help Screens For "
	"Individual Functions ^\n\n    Help screens are available for each of the Functions in AccessDOS.  You can reach the help "
	"screens in two ways.\n\n     1) You can open the dialog box for the feature (under the\n        ADJUST menu) "
	"and then hit the F1 key.\n\nor   2) You can open up the help screens for any feature directly by going\n        to "
	"the appropriate item in the HELP menu.\n\n\n    All of the information in the Help screens (and more) is included in "
	"the manual that accompanies this program.  For those who find electronic documentation easier to use, there is also an "
	"electronic copy of the manual on the disk with this program.  "
	"\n                                                                   MORE...",
	FALSE,
	"             ^ IF YOU ARE HAVING TROUBLE USING THE MENUS  ^     Page 3 of 4\n\nPROBLEM 1:  I use the up and down "
	"arrows but it doesn't seem to have any\n            effect (except that the message at the bottom of the screen"
	"\n            changes).\n\nSOLUTION: AccessDOS tries to figure out what kind of screen you are using and then use a "
	"compatible color for highlighting.  Sometimes a computer will fool AccessDOS and it will try to highlight the characters "
	"in a way that is invisible on your computer.  (Which means you ARE moving up and down the menus but you won't be able to "
	"see it.)  To fix this problem you should tell AccessDOS what type of display you have by typing a special character after "
	"its name when you start AccessDOS.\n\n   If you are using a computer with an LCD display type:   ADOS /L\n   If you are "
	"using a MONOCHROME display type:             ADOS /M\n   If you are using a COLOR display type:                  ADOS /C"
	"\n                                                                   MORE...",
	FALSE,
	"PROBLEM 2:  I can move around on the menus just fine using the arrow keys\n            but it just seems to skip over "
	"MouseKeys (Or SerialKeys) on\n            the menus. (The hot key for this item won't work either.)\n\nSOLUTION: If "
	"AccessDOS skips over a menu item it means that that item is not available to you for some reason. (It will also be dimmer "
	"on most displays - or in parentheses on an LCD display.)\n\n   If it skips over SerialKeys: It means that you don't "
	"have a serial port available.  Maybe your computer doesn't have one installed or perhaps the only port available is used "
	"up by a serial mouse or built in modem.\n\n   If it skips over MouseKeys: It means that AccessDOS can't find a mouse "
	"driver.  Perhaps your mouse driver wasn't installed yet; you didn't have a mouse connected (and the mouse driver didn't "
	"load); or you are using an incompatible mouse (see manual or MouseKeys Help for more information)."
	"\n\n                                - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextGeneral[] =
{
	"\n\n\n\n                   ^TABLE OF CONTENTS  for  GENERAL HELP^\n\n\n        Page 1 - General Information\n             2 "
	"- Setting Up AccessDOS to Meet Your Needs\n             3 - Making AccessDOS load Automatically at StartUp\n             "
	"4 - Memory Considerations\n             5 - AccessDOS Command Line Switches\n",
	FALSE,
	"                                                               Page 1 of 5\n                            ^General Information^"
	"\n     AccessDOS is a set of DOS extensions which provide additional flexibility in the user-interface for DOS, and which "
	"are useful to individuals both with and without disabilities.  The extensions in this package allow the user to control "
	"the key repeat, to adjust the way the keys on the keyboard respond when pressed, to make all modifier keys into locking "
	"keys (something like the caps lock key), to control the mouse cursor with precision from the keyboard, and to obtain a "
	"visual indication of beeps or other sounds made by the computer.\n\n     AccessDOS consists of two files on your hard "
	"disk, labelled ADOS.COM and ADOS.OVL.  A third file labeled ADOS.CFG is created by AccessDOS to hold user settings.  "
	"A copy of the instruction manual is included on the disk as a text file labeled ADOS.TXT.  This file can be read or "
	"printed using most any word processor, or by using the PRINT command in DOS.  "
	"\n\n                                                              MORE...",
	FALSE,
	"                                                               Page 2 of 5\n                  ^Setting Up AccessDOS to "
	"Meet Your Needs^\n\n1)  Adjust AccessDOS\n     - Use the items you will find under the ADJUST menu to adjust\n       "
	"AccessDOS to meet your individual needs.\n\n2)  Save Your Settings.\n     - If you want to save these settings so "
	"that they can be used in\n       the future then select SAVE SETTINGS from the FILE menu.\n\n3)  Exit this Setup Program"
	"\n     - When you are done you can exit this program 2 ways.\n          1) select INSTALL/RUN from the FILE menu, or"
	"\n          2) select CANCEL/QUIT from the FILE menu.\n\n"
	"\n                                                              MORE...",
	FALSE,
	"                                                               Page 3 of 5\n\n              ^Making AccessDOS load "
	"Automatically at StartUp^\n\n     In many cases it will be desirable to have AccessDOS automatically load "
	"itself each time you restart or reboot the computer.  Individual users may need it in order to use their computers.  In "
	"shared-use computers, AccessDOS can be running in the background and be inactive until a user with a disability comes "
	"along.  Then a few taps on the proper keys will allow the disabled user to access the functions without having to reboot "
	"the computer.\n\n     To make AccessDOS load automatically each time the computer is restarted you should insert the "
	"program name (ADOS) along with the command line switch /A in your AUTOEXEC.BAT file.  (e.g.  ADOS /A)\n"
   "\n                                                               MORE...",
	FALSE,
	"                                                               Page 4 of 5\n\n                           ^Memory "
	"Considerations^\n\n     AccessDOS is a TSR (terminate and stay resident) program.  That means that a small piece of it "
	"remains in your computer's memory after you install it, so that it can work in conjunction with your other software "
	"programs.\n\n     When loading AccessDOS it takes 150 KB of memory to hold both AccessDOS (ADOS.COM) and its overlay "
	"(ADOS.OVL).  After AccessDOS is installed, it occupies:\n            10 KB  if you DON'T use "
	"SerialKeys (most people don't)\n            25 KB  if you DO use SerialKeys\n\n"
   "\n                                                               MORE...",
	FALSE,
	"                                                               Page 5 of 5\n                      ^AccessDOS Command Line "
	"Switches^\n\n     There are two major ways to run AccessDOS\n        1) you can type ADOS while you are at the DOS prompt\n"
	"        2) you can put ADOS into your AUTOEXEC.BAT file.\n\n     In either case there are loading options that you can "
	"enable by including any of the following command line switches:\n    /A = Automatic install with your settings or option "
	"to use the menu\n         without your saved settings.\n    /X = Automatic install with your settings and no option to use "
	"menu.\n    /C = Use Color display.\n    /M = Use Monochrome (with highlight) display.\n    /L = Use LCD display.\n    /? "
	"or /H = Show this list of command line switches.\n"
	"\n                                - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextSticky[] =
{
   "                                                              Page 1 of 3\n\n                                ^StickyKeys^"
   "\n\n   StickyKeys is a feature that allows people who must type with 1 finger, a mouthstick or a headstick to be able "
   "to use modifier keys (SHIFT, CTRL, and ALT keys).  With StickyKeys turned on, a "
   "person can press a modifier key and then another key in sequence rather than at the same time, to get shifted "
   "(modified) characters.\n\n   To turn StickyKeys on, tap either shift key five times (without disturbing the mouse).  "
   "You will hear an 'up-siren' tone. To turn off StickyKeys, tap a shift key five times (you will hear a 'down-"
   "siren').\n\n\n                                                               MORE...",
   FALSE,
   "                                                              Page 2 of 3\n                             ^Using "
   "StickyKeys^\n\n   StickyKeys operates in two modes: key latching mode and key locking mode.\n\n   Tapping ONCE on a "
	"modifier key causes it to go into LATCHED mode.  A short low beep - high beep will be heard.  As soon as the next "
	"non-modifier key is pressed the modifier key(s) will be released.\n\n    Tapping TWICE in "
   "succession on a modifier key will put it into LOCKED mode.  You will hear a short low - high beep after the first tap and a "
   "single high beep after the second tap.  Once a modifier key is LOCKED it will stay 'locked down' until that modifier "
   "key is hit a third time.\n\n    Any and all of the modifier keys (SHIFT, CTRL, and ALT) can be "
   "latched or locked in combination.\n                                                               MORE...",
   FALSE,
   "                                                              Page 3 of 3\n                             ^StickyKey "
   "Options^\n\n      For shared or public computers there is an optional\n'Two-Key Auto Shutoff' feature to keep non-"
   "disabled users from being confused if StickyKeys is accidentally left on.  Whenever an able-bodied typist uses "
   "a keyboard, they will hold the shift key down and strike another key simultaneously.  If the Two-Key shutoff feature "
   "is enabled, StickyKeys will detect that two keys are down simultaneously and automatically turn the StickyKeys "
   "feature off.\n\n     Some people do not like to have keyboard sounds while others find them useful.  The ability "
   "to turn the different feedback sounds on or off is therefore provided.\n\n     Finally, it is possible to "
   "disable the LOCKED mode of StickyKeys described above if it is not desired.\n                                - END -",
   TRUE
};

HELP_SCREEN_RECORD helpTextMouse[] =
{
	"\n\n\n\n                    ^TABLE OF CONTENTS - MOUSEKEYS HELP^\n\n\n        Page 1 - Introduction to MouseKeys"
	"\n             2 - MouseKeys Numeric Keypad Functions   (Summary Chart)\n             3 - How to Operate the Mouse "
	"Buttons\n             4 - Moving the Cursor Around the Screen\n             5 - Using MouseKeys On Keyboards without "
	"Numeric Keypads\n             6 - Using MouseKeys Along with a Standard Mouse\n             7 - Using MouseKeys Without "
	"a Mouse Connected",
	FALSE,
   "                                                              Page 1 of 7\n^                        Introduction to "
	"MouseKeys^\n\n     Some Users do not have the physical control to operate a mouse yet need to access software which "
	"requires a mouse.  MouseKeys provides a means to control the mouse cursor on the screen by using the numeric keypad on "
	"the keyboard.\n\n    You turn MouseKeys on or off by simultaneously pressing the\nleft ALT key, the left SHIFT key and "
	"the NUM LOCK key.  When MouseKeys turns on, you will hear an up-siren.    (If you are using only one finger, a "
	"mouthstick, or a headpointer, the easiest way to activate MouseKeys is to first activate StickyKeys by tapping the SHIFT "
	"key 5 times.  You can then hit the three keys in sequence rather than simultaneously.)\n\n    Once MouseKeys is turned "
	"on, the numeric keypad becomes a mouse control pad.  Each key on the keypad performs a different mouse function.  "
	"These functions are...",
   FALSE,
   "                                                              Page 2 of 7\n\n                    ^MouseKeys Numeric "
	"Keypad Functions^\n\n1 - Moves the mouse down and to the left\n2 - Moves the mouse down\n3 - Moves the mouse down and "
	"to the right\n4 - Moves the mouse to the left\n5 - Clicks the currently active mouse button\n6 - Moves the mouse to the "
	"right\n7 - Moves the mouse up and to the left\n8 - Moves the mouse up\n9 - Moves the mouse up and to the right\n0 - Locks "
	"the currently active mouse button down\n. - Releases the currently active mouse button\n+ - Double-clicks the currently "
	"active mouse button\n"
	"\n                                                               MORE...",
   FALSE,
   "                     ^How to Operate the Mouse Buttons^         Page 3 of 7\n\n     The 5, +, 0, and . keys operate "
	"the buttons on the mouse.  Use the '5' key when you want to click a button once.  To "
   "double-click a button use the '+' key.   When you want to hold a button down while you use the mouse (as for dragging), "
   "press the '0' key to lock the button down and the '.' key to release the button.\n\n"
	"^Which button is the currently active button?^\n   On 101-key keyboards:\n      / makes the left mouse button the "
	"currently active button\n      - makes the right mouse button the currently active button\n      * makes both mouse "
	"buttons the currently active button.\n   On 84-key keyboards:\n      * makes the left mouse button the currently "
	"active button\n      - makes the right mouse button the currently active button.\n      It is not possible to make both "
	"mouse buttons the currently active\n      button on an 84-key keyboard.",
   FALSE,
   "                                                              Page 4 of 7\n                    ^Moving the Cursor "
   "Around the Screen^\n\n   The keys 1, 2, 3, 4, 6, 7, 8, and 9 are used to move the mouse cursor around the screen in the "
   "directions listed above (and suggested by their location on the numeric keypad).\n\n   Pressing the key once will move "
   "the cursor one unit in that direction.  (The definition of a 'unit' varies with different programs and screens.)\n\n"
   "   Holding the key down will cause the mouse cursor to continue to move in the respective direction, slowly at first, "
   "and then increasing to the maximum speed.  The mouse pointer will then continue at maximum speed (units per second) "
   "until the key is released.\n\n   Both the maximum speed of the mouse cursor and the time it takes to get to "
   "maximum speed are adjustable in the MouseKeys ADJUST menu.\n"
   "                                                               MORE...",
   FALSE,
   "                                                              Page 5 of 7\n\n           ^Using MouseKeys on Keyboards "
   "Without Numeric Keypads^\n\n     While MouseKeys is on, you can use the NUM LOCK key to toggle the MouseKeys control "
	"pad back to a numeric keypad.\n\n     This feature is especially useful if you are using a laptop or notebook computer "
	"which doesn't have a separate numeric keypad.  On these keyboards the 'numeric keypad' is usually overlaid on top of "
	"part of the standard keyboard.  You can then use the NUM LOCK key to toggle between having those keys on the standard "
	"keyboard act as the MouseKeys control pad and having them act as the regular keyboard keys.\n"
	"\n\n                                                               MORE...",
   FALSE,
   "                                                              Page 6 of 7\n                  ^Using MouseKeys with "
   "the Standard Mouse^\n\n     MouseKeys will work in conjunction with the standard Microsoft or IBM PS/2 mouse.\n\n"
	"     You can use the standard mouse to move quickly about the screen and then use "
   "MouseKeys to move more precisely (unit by unit) to your final destination.\n\n    Some people cannot use the standard "
   "mouse while simultaneously holding down the mouse button.  You can use MouseKeys to lock down the currently active mouse "
	"button ('0'), move the mouse cursor using MouseKeys or the real mouse, then release the mouse button ('.').\n\n"
	"\n                                                               MORE...",
   FALSE,
	"                                                              Page 7 of 7\n\n                 ^Using MouseKeys without a "
	"Mouse Connected^\n\n     MouseKeys will not work unless there is a Microsoft or IBM PS/2 mouse driver installed.  Most "
	"mouse drivers will not install unless a mouse is connected to the computer.  As a result, you will need to have a mouse "
	"connected in order for MouseKeys to work.\n\n     On an IBM PS/2 computer you can run the program FAKEMOUS.COM in "
	"conjunction with MOUSE.COM to run MouseKeys without connecting a mouse.\n\n     For more information on using MouseKeys "
	"without a mouse connected, please refer to the AccessDOS manual.\n\n\n                                - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextToggle[] =
{
   "                                                              Page 1 of 1\n\n     People with visual impairments may not be "
   "able to see the lights on the keyboard that indicate CAPS LOCK, NUM LOCK and SCROLL LOCK status.  ^ToggleKeys^ provides "
	"a solution to this by emitting a tone whenever the keys are pressed.  When you press one of "
   "these keys and it turns on you will hear a high beep.  When you press a key and it turns off you will hear a low beep.\n\n"
	"     ToggleKeys is turned on by pressing the NUM-LOCK key and holding it down for a period of about 5 seconds.  When "
	"ToggleKeys turns on, you will hear an up-siren.  You turn ToggleKeys off the same way.  Just hold the NUM-LOCK key for 5 "
	"seconds and you will hear a down-siren.\n\n     ToggleKeys will also function with some keyboards which do not have "
	"indicator lights.  The audible low and high beeps can be very useful for all operators when using this style of keyboard.\n"
	"                                - END -",
   TRUE
};

HELP_SCREEN_RECORD helpTextSerial[] =
{
   "                                                              Page 1 of 2\n                                ^SerialKeys^"
   "\n\n     Some people cannot successfully use the standard keyboard even with all of the adaptations in AccessDOS.  Often, "
   "however, they have special communication or control interfaces which they can operate with proficiency.  If they are using "
   "a communication or other interface aid which has a serial port on it and has a programmable vocabulary, they can use "
   "the SerialKeys feature to connect their aid to this computer and use their communication aid instead of the computer's "
   "keyboard and mouse.\n\n     To use SerialKeys they would run a serial cable from their aid to the serial port on this "
   "computer.  They would then program their aid to send ASCII characters to the serial "
   "port which would be processed in a special way by SerialKeys so that they would look just like keystrokes from the standard "
   "keyboard or movements from the mouse.\n                                                               MORE...",
   FALSE,
	"                                                              Page 2 of 2\n                           ^Setting Up SerialKeys^"
	"\n\nThere are two parts to setting up SerialKeys...\n\n1) Making sure that the communication aid and the serial port on the "
	"computer can talk to each other.\n\n2) Programming your communication aid to send the right commands to SerialKeys.\n\n"
	"     Please refer to the owners manual for the communication aid for more information on connecting it to the computer and "
	"refer to the AccessDOS manual for more information on what needs to be programmed into the communication aid.\n"
   "\n\n                                  - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextKeyboard[] =
{
	"\n\n                TABLE OF CONTENTS - Keyboard Response Group\n\n\n        Page 1 - Introduction to RepeatKeys, "
	"SlowKeys & BounceKeys\n             2 - Enabling the Keyboard Response Group\n             3 - Adjusting RepeatKeys "
	"\n             4 - Adjusting SlowKeys\n             5 - Adjusting BounceKeys\n             6 - Enabling the Keyboard "
	"Response Group from this Program\n             7 - Enabling the Keyboard Response Group from the Keyboard\n             "
	"8 - Emergency Enabling of RepeatKeys and SlowKeys...\n             9 - Emergency Enabling... (continued)\n            "
	"10 - Emergency Enabling... (continued)",
	FALSE,
	"Some people would be able to use the standard keyboard if it functioned just a little differently than it usually does.  "
	"The Keyboard Response Group is a group of functions that modify how the individual keys on the keyboard behave or respond "
	"when you press them.\n\n     ^RepeatKeys^ - If the standard key-repeat feature of your keyboard\n                  is too "
	"fast, or you don't want it at all, ^RepeatKeys^\n                  allows you to slow it down or turn it off.\n\n     "
	"^SlowKeys^   - If you bump keys accidentally as you move around on\n                  the keyboard and would like to slow "
	"the keyboard down\n                  so that it would only accept keys after they have been\n                  held down "
	"for awhile, ^SlowKeys^ will do this for you.\n\n     ^BounceKeys^ - If you have a tremor and accidentally type keys twice"
	"\n                  as you press or release them, ^BounceKeys^ can be used\n                  to make the computer ignore "
	"the extra tap on the key.\n                                                               MORE...",
   FALSE,
   "                                                             Page 2 of 10\n\n                   ^Enabling the Keyboard "
   "Response Group^\n\n\n     The 3 functions in the Keyboard Response Group (RepeatKeys, SlowKeys and BounceKeys) are "
   "enabled and disabled together as a group.  This is done to simplify turning the group on and off from the keyboard.\n\n     "
   "Most people, however, are only interested in using one or two of the functions in the group.  This is not a problem.  "
   "You can individually adjust the functions within this group such that when enabled, unwanted functions will have no effect."
   "\n\n\n\n                                                                 MORE...",
   FALSE,
   "                           ^Adjusting RepeatKeys^              Page 3 of 10\n\n     There are two adjustments for the "
   "RepeatKeys function. The first setting, REPEAT RATE, allows you to adjust the speed at which the keys will "
   "repeat when you hold a key down.  The smaller numbers (like 0.25) will make it repeat faster.  ^If you do not want the "
   "keys to repeat at all^, then just set the REPEAT RATE to OFF.\n\n    The second setting, DELAY UNTIL REPEAT, "
   "allows you to set the length of time you must hold a key down before it will begin to repeat.  If you have trouble "
   "releasing a key in time, then set this to a higher setting.\n\nNOTE: There are some programs which have their "
   "own keyboard repeat key adjustment.  In order for RepeatKeys to work with these programs you must first turn "
   "off the repeat key adjustment in the program.\n(For example in Word Perfect, set keyboard speed to 'normal'; in "
   "Microsoft Word, set keyboard speed option to '0'.)"
	"\n                                                               MORE...",
   FALSE,
   "                            ^Adjusting SlowKeys^               Page 4 of 10\n\n   SlowKeys allows you to slow down the "
   "keyboard so that keys must be held down for a while before they will be accepted by the computer.  This is useful for "
   "individuals who could use the keyboard but accidentally bump extra keys when they try to type.  By slowing down the "
   "keyboard, these extra key bumps are ignored and only the keys that are typed and held down are accepted.\n\n"
   "   There are two adjustments for the SlowKeys function.  The first setting (called ACCEPTANCE DELAY) allows you to "
	"adjust the amount of time that you must hold a key down before it will be accepted by the computer. ^If you do not want "
	"SlowKeys^, then just set the ACCEPTANCE DELAY to  OFF.\n\n   The second setting is called KEY CLICK FEEDBACK.  If this "
	"is set to YES then you will hear a click when you press the key and another click when it is accepted.  (If you want "
	"your typing to be completely silent you must turn off this click setting and the click setting under StickyKeys.)  ...",
   FALSE,
   "                           ^Adjusting BounceKeys^              Page 5 of 10\n\n     Individuals who have tremor or "
   "impaired control of their hands may find that they type two or more of the same letter when they try to press a key.  They "
   "bounce on the key either when they are pressing it or when they release it causing the extra characters.  BounceKeys "
   "causes the keyboard to ignore these quick bounces so that only one key is accepted.\n\n    There is only one setting for "
   "BounceKeys, DEBOUNCE TIME. The larger the number the longer you will have to wait after you release a key "
   "before you can type the same key a second time (up to 2 seconds!).  ^If you do not want the BounceKeys^ function, then just "
   "set the DEBOUNCE TIME to OFF.\n\nNOTE 1: If you want to type the same key twice you just need to pause a bit between the "
   "two key presses.  BounceKeys does not prevent you from typing other keys quickly.  (You just can't type the same key "
	"quickly.)\nNOTE 2: You cannot use SlowKeys and BounceKeys at the same time (see\nmanual)."
	"                                                       MORE...",
   FALSE,
   "                                                             Page 6 of 10\n\n          ^Enabling the Keyboard Response "
   "Group from this Program^\n\n\n     Once you have set up the desired values under each of the Keyboard Response "
   "functions (RepeatKeys, SlowKeys and BounceKeys) you need to enable the Keyboard Response group.\n\nFROM THE ADJUST MENU:\n     "
   "Select 'KEYBOARD RESPONSE...' from the ADJUST menu.  Then select\n     YES for the GROUP ENABLE question at the top of "
	"the box.\n\n\n\n\n                                                               MORE...",
   FALSE,
   "                                                             Page 7 of 10\n          ^Enabling the Keyboard Response "
   "Group from the Keyboard^\n\n     Sometimes you may want to enable or disable these keyboard functions from the keyboard "
   "without having to run this program.  To do this just hold the right shift key down for 8 seconds.  After about 4 "
   "seconds you will hear 3 short warning beeps.  (These are provided just in case someone is accidentally resting their "
   "hand on the shift key and doesn't really want to enable these functions - it's sort of a 'get off the key' "
   "warning).  Since you DO want these functions enabled, just ignore these warning beeps and keep holding the key down.  "
   "After about 4 seconds more you will hear an up-siren.  You can release the key now and the "
   "functions will be enabled using the values you set for RepeatKeys, SlowKeys and BounceKeys.\n\nNOTE: You can "
   "disable this group of keyboard functions using this same procedure.  When you disable the group you will "
   "hear a down-siren.\n                                                               MORE...",
   FALSE,
   "                                                             Page 8 of 10\n\n        ^Emergency Enabling of the Keyboard "
   "Response Group - Part 1^\n\n     Some individuals are completely unable to operate the computer unless they can turn the "
   "keyboard repeat function off and/or turn SlowKeys on.  These individuals could find themselves in a Catch-22, "
	"unable to use the computer to turn the functions they need.  There is a solution to this problem built into AccessDOS.\n\n"
	"     An emergency enabling routine that allows you to turn functions on from the keyboard by simply holding the right "
	"shift key down for an extended period of time."
	"\n\n\n\n                                                               MORE...",
   FALSE,
   "                                                             Page 9 of 10\n        ^Emergency Enabling of the Keyboard "
	"Response Group - Part 2^\n\n     To enable the emergency settings for RepeatKeys and SlowKeys from the keyboard you just hold "
	"down the right shift key (as you normally do to enable the Keyboard Response Group) except that you keep holding it down "
	"even after you hear the up-siren.\n\n     If you hold the right shift key down long enough, this is the sequence of events "
	"that will happen:\n\nafter 4 seconds... 3 short beeps.    [they are the warning beeps]\n4 more seconds... an up-siren  "
	"[Kybd Resp Group turns on - your settings]\n4 more seconds... 2 up-sirens  [Repeat Rate & Acc. Dly off, Debnce 1 Sec]\n"
	"4 more seconds... 3 up-sirens  [Repeat Rate off, Acc. Dly 2 sec (Max)]\n"
	"\n                                                               MORE...",
   FALSE,
   "    In other words...  holding the right shift key down for 8 seconds will enable your normal settings for "
   "RepeatKeys, SlowKeys, and BounceKeys.\n\n    If you continue to hold it down until you hear 2 up-sirens, you "
   "will go into emergency setting #1 where the keyboard's repeat function will be turned off, Acceptance Delay "
   "will be off and Debounce Time will be 1 second.\n\n    If you continue to hold it down until you hear 3 up-sirens, "
	"you will go into emergency setting #2 where they keyboard's repeat function will be turned off and SlowKeys will be "
	"turned on to its Maximum (2 sec).\n\n    Setting #2 is a very slow keyboard response but should be usable by "
   "most anyone who can use the keyboard.  It would only be used long enough to run this program and change "
   "the settings to the values needed by the person.  Once the settings have been made and saved they shouldn't need to "
   "use this feature again unless someone changes their settings.\n                                - END -",
   TRUE
};

HELP_SCREEN_RECORD helpTextTimeOut[] =
{
   "\n    When AccessDOS is used on a shared computer it is sometimes "
   "useful to have an automatic timeout feature that would turn the AccessDOS functions off if the computer were left "
	"idle for awhile.  The TimeOut feature provides this capability.\n\n\nThere are two settings for the TimeOut feature:\n\n"
	"1) The IDLE TIME setting controls the length of time that the computer keyboard must be idle before AccessDOS will automatically "
   "turn itself off.  (AccessDOS is still loaded so it can be easily re-enabled from the keyboard without having to run "
   "this setup program.)\n\n2) You can control whether AccessDOS will make a sound (a down-siren) when it turns itself "
   "off.\n\n                                  - END -",
	TRUE
};

HELP_SCREEN_RECORD helpTextMisc[] =
{
   "\n\n                        ^Miscellaneous Adjustments^\n\n\n^ Space Saving Keyboard:^ If you are using a space "
   "saving keyboard such as\n                       the one that comes with the IBM PS/2 models 25 or\n                       "
   "you should set this option to YES so that\n                       AccessDOS will work properly with the keyboard."
   "\n\n\n\n\n\n\n\n\n                                  - END -",
   TRUE
};

HELP_SCREEN_RECORD helpTextShowSounds[] =
{
	"\n   For individuals with hearing impairments "
	"or for anyone working in a noisy environment, "
	"it is hard or impossible to hear beeps and other "
	"sounds made by the computer.  ShowSounds provides "
	"a visual indication on the screen each time a sound "
	"(other than a click) is made by AccessDOS.\n\n   "
	"ShowSounds has two options.  Whenever your computer "
	"makes a sound you can either have ShowSounds FLASH "
	"your screen or you can have it provide a small VISUAL "
	"CUE () in the upper left hand corner of your screen."
	"\n\n   For sounds created by AccessDOS, the small "
	"visual cue also gives you some additional information "
	"about the sound."
	"\n              Up-Siren                    High "
	"Beep \n              Down-Siren               	   Low Beep"
	"\n               Sounds produced by other programs\n"
	"NOTE: Not all programs permit the musical note to appear "
	"(see manual).\n\n                                  - END -",
	TRUE
};

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\param.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center 				*
;									*
;	PARAM.ASM							*
;									*
;************************************************************************

;-----------------------------------------------------------------------------
; This file contains all the parameters to pass back and forth with the user
; interface part of this program
;-----------------------------------------------------------------------------

TITLE	Parameters

INCLUDE	keyboard.inc

	PUBLIC		_dataBlock
	PUBLIC		_dataBlockSize

PUBLIC          SerialKeys_Param
        PUBLIC  _serialKeysOn
        PUBLIC  _skCommPortAddr
        PUBLIC  _skBaudRate
	PUBLIC 	_skCommIRQ
	PUBLIC	_injectByte
	PUBLIC	_forcedInt9Flag

PUBLIC	FilterKeys_Param
	PUBLIC	fFilterKeysOn
	PUBLIC	fFK_On_Off_Feedback
	PUBLIC	fUser_SetUp_Option1
	PUBLIC	fUser_SetUp_Option2
	PUBLIC	wait_ticks
	PUBLIC	delay_ticks
	PUBLIC	repeat_ticks
	PUBLIC	recovery_ticks
	PUBLIC	fmax_default
	PUBLIC	fclick_on
	PUBLIC	fRecovery_On
	PUBLIC	fDialog_Filter_off


PUBLIC  SticKeys_Param
	PUBLIC	fSticKeysOn
	PUBLIC	fSK_On_Off_Feedback
	PUBLIC	fAudible_Feedback
	PUBLIC	fTriState
	PUBLIC	fTwo_Keys_Off
	PUBLIC	fDialog_Stickeys_off
	PUBLIC	fstickeys_click


PUBLIC	MouseKeys_Param
	PUBLIC	fMouseKeysOn
	PUBLIC	fMK_On_Off_Feedback
	PUBLIC	Max_Speed
	PUBLIC	Time_To_Max_Speed
	PUBLIC	fDialog_Mouse_off
	PUBLIC	fmkeys_override


PUBLIC	ToggleKeys_Param
	PUBLIC	fToggleKeysOn
	PUBLIC	fTK_On_Off_Feedback
	PUBLIC	fDialog_Toggle_off


PUBLIC	TimeOut_Param
	PUBLIC	fTime_Out
	PUBLIC	fTO_On_Off_Feedback
	PUBLIC	to_value
	PUBLIC	fDialog_TimeOut_off

PUBLIC	Handicap_Param
	PUBLIC	fcomp_dialog
	PUBLIC	fcomp_dialog_id
	PUBLIC	fDialog_Action
	PUBLIC	fhearing_on
	PUBLIC	fvideo_flash
	PUBLIC	fspace_saver
	PUBLIC	fcomputer_not_found

	PUBLIC	fslow_baud_mouse 

	PUBLIC	fserial_keys_loaded	
        PUBLIC  fAccessAlreadyLoaded

PUBLIC  Find_Mouse_Param
        PUBLIC  btn_1
        PUBLIC  btn_2
        PUBLIC  Current_Button
	PUBLIC	_comp_id
	PUBLIC  _combase
	PUBLIC	fmouse_driver
	PUBLIC	_finject_keys
	PUBLIC	_vector
	PUBLIC	comp_flag
	PUBLIC	ExtendedSeg	
	PUBLIC	_fmouse_id
        PUBLIC  fvideo_type





_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

	
_dataBlock		label	byte

SerialKeys_Param        label   byte
_serialKeysOn           DB      false           ; position 00 -- must be in this order -- SerialKeys Off       
_skCommPortAddr         DW      03f8h           ; position 01, 02 -- must be in this order -- COM1:
_skBaudRate             DW      0180h           ; position 03, 04 -- must be in this order -- 300 Baud


FilterKeys_Param	label	byte
fFilterKeysOn		DB	false		; position 05 -- must be in this order
fFK_On_Off_Feedback	DB	true		; position 06 -- must be in this order
fUser_SetUp_Option1	DB	false		; position 07 -- must be in this order
fUser_SetUp_Option2	DB	false		; position 08 -- must be in this order
wait_ticks		DW	wait_dflt_cnt	; position 09, 10 -- must be in this order
delay_ticks		DW	dly_dflt_cnt   	; position 11, 12 -- must be in this order
repeat_ticks		DW	rpt_dflt_cnt	; position 13, 14 -- must be in this order
;recovery_ticks		DW	rec_dflt_cnt	; position 15, 16 -- must be in this order
recovery_ticks		DW	32760		; position 15, 16 -- must be in this order

fmax_default		DB	false		; position 17 -- must be in this order
fclick_on		DB	true		; position 18 -- must be in this order
fRecovery_On		DB	false		; position 19 -- must be in this order
fDialog_Filter_off	DB	false		; position 20 -- must be in this order -- flag for dialog box on/off
FilterKeys_Param_Len	equ	16		; 16 bytes long



SticKeys_Param	label	word
fSticKeysOn		DB	false           ; position 21 -- must be in this order
fSK_On_Off_Feedback	DB	true            ; position 22 -- must be in this order
fAudible_Feedback	DB	true            ; position 23 -- must be in this order
fTriState  		DB	true            ; position 24 -- must be in this order
fTwo_Keys_Off		DB	true            ; position 25 -- must be in this order
fDialog_Stickeys_off	DB	false		; position 26 -- must be in this order -- flag for dialog box on/off
fstickeys_click	        DB	false		; position 27 -- must be in this order -- flag if user want StickeyKeys with a click
SticKeys_Param_Len	equ	7		; 7 bytes long 


MouseKeys_Param	label	word
fMouseKeysOn		DB	false		; position 28 -- must be in this order -- flag for if on
fMK_On_Off_Feedback	DB	true		; position 29 -- must be in this order
Max_Speed		DW	8 		; position 30, 31 -- must be in this order
Time_To_Max_Speed	DW	1		; position 32, 33 -- must be in this order
fDialog_Mouse_off	DB	false		; position 34 -- must be in this order -- flag for dialog box on/off
fmkeys_override		DB	true		; position 35 -- must be in this order -- flag to allow user to have MouseKey mouse button take 
MouseKeys_Param_Len	equ	8		; 8 bytes long


ToggleKeys_Param	label	word
fToggleKeysOn		DB	false           ; position 36 -- must be in this order
fTK_On_Off_Feedback	DB	true            ; position 37 -- must be in this order
fDialog_Toggle_off	DB	false		; position 38 -- must be in this order -- flag for dialog box on/off
ToggleKeys_Param_Len	equ	3		; 3 bytes long


TimeOut_Param	label	word
fTime_Out		DB	false           ; position 39 -- must be in this order
fTO_On_Off_Feedback	DB	true            ; position 40 -- must be in this order
to_value		DW	to_dflt_cnt 	; position 41, 42 -- must be in this order -- holds time out value to turn off
fDialog_TimeOut_off	DB	false		; position 43 -- must be in this order -- flag for dialog on/off
TimeOut_Param_Len	equ	5		; 5 bytes long

Handicap_Param	label	word
fcomp_dialog		DB	false		; position 44 -- must be in this order -- holds flag if user decided to choose alternate computer
fcomp_dialog_id		DB	false		; position 45 -- must be in this order -- holds type of computer user choose 1,2, or 3
fDialog_Action		DB	false		; position 46 -- must be in this order -- flag to tell us that a change occurred in Dialog or Menu box
fspace_saver		DB	false		; position 47 -- must be in this order
fcomputer_not_found	DB	false		; position 48 -- must be in this order -- flag to tell menu that computer was not ID'ed and to display messages
fhearing_on		DB	true		; position 49 -- must be in this order -- flag set by user to provide visual feedback for beeps

fserial_keys_loaded	db	false	   	; position 50 -- must be in this order -- flag to inform Startup.asm
					   	; when to call other SerialKeys 
					   	; routines if "AccesDOS" is restarted
fAccessAlreadyLoaded    db      false           ; position 51 -- must be in this order -- true if accessDOS is already loaded
Handicap_Param_Len	equ	8		; 8 bytes long

_skCommIRQ		db	4		; position 52 -- must be in this order -- 4 = IRQ 4,   3 = IRQ 3
fvideo_flash		db	false		; position 53 -- must be in this order -- flag for screen flash when computer beeps

filler_space		db	'1234567'       ; position 54, 55, 56, 57, 58, 59, 60 -- must be in this order
endOfDataBlock		label	word


Find_Mouse_Param        label   word
btn_1			DB	0		; position 61 -- must be in this order -- holds btn info for mouse
btn_2			DB	0		; position 62 -- must be in this order -- holds btn info for mouse
Current_Button		DB	0		; position 63 -- must be in this order -- holds which mouse button is active
_comp_id		DB	false		; position 64 -- must be in this order -- START OF COMPUTER ID FLAGS
fmouse_driver		DB	false		; position 65 -- must be in this order -- flag to indicate that a mouse and mouse driver were found
_fmouse_id		DB	false		; position 66 -- must be in this order -- id byte to tell software what type of mouse is connected to host
_combase       		DW	0		; position 67, 68 -- must be in this order -- holds address of com port which has the serial mouse if found
ExtendedSeg		DW	0		; position 69, 70 -- must be in this order -- holds segment address of mouse driver	Extended data area
_vector			DB	0		; position 71 -- must be in this order -- holds the kybd interrupt vector we need to hook during keyboard input
_finject_keys		DB	false		; position 72 -- must be in this order -- flag to tell us the computer supports Injection of keystrokes into the hardware
fvideo_type		DB	0		; position 73 -- must be in this order -- 3=CGA 4=EGA 5=VGA
comp_flag		DB	false		; position 74 -- must be in this order -- flag to tell us if we have BIOS support for kb_flag_1 and kb_flag_3
fslow_baud_mouse	db	false		; position 75 -- flag set for 300 baud mouse to slow timer writes down

_dataBlockSize		dw	endOfDataBlock -_dataBlock

_injectByte		DB 	0		; for serial keys: holds byte to inject in Int 15h 4Fh intercept
_forcedInt9Flag		DB 	0		; for serial keys: flag that signals when serial keys is injecting a key code


_TEXT	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\serkeys.asm ===
;
;
	TITLE   serkeys.a

ALL_LINK	equ 1


;********* GLOBAL FUNCTIONS
	
	EXTRN	_serialKeysOn:byte
	EXTRN	_initGIDEI:near
	EXTRN	ExtendedSeg:word
	EXTRN	_fmouse_id:byte
	EXTRN	_comp_id:byte
	EXTRN   _combase:word

	PUBLIC	_serialKeysEnableFar
	PUBLIC	_serialKeysDisableFar
	PUBLIC	_putInMouseBuffer
	PUBLIC	_sendMouseData

	PUBLIC _mouBufTailPtr
	PUBLIC _mouBufHeadPtr
	PUBLIC _mouBuffer

	PUBLIC	_doBeep
	PUBLIC	_doReboot
	PUBLIC	_handleBreak
	PUBLIC	_inPauseCondition
	PUBLIC	_clearInPause
	PUBLIC	_setInPause

	PUBLIC	_serialKeysCommInit
	PUBLIC	_serialKeysDisable
	PUBLIC	_initCommPort
	PUBLIC	_setBaudRate
	PUBLIC	_turnOffHandshake
	PUBLIC	_turnOnHandshake
	PUBLIC	_disableComm
	PUBLIC	_enableComm
	PUBLIC	_clearOutComm

	PUBLIC	_disableKeyEnhance

	PUBLIC	_waitingForIndicatorUpdate
	PUBLIC	_getBiosFlags
	PUBLIC	_putBiosFlags
	PUBLIC	_keyBufferFull
	PUBLIC	_keyBufferEmpty
	PUBLIC	_putInKbdBuffer
	PUBLIC	_convertStringToInt

;********* GLOBAL VARIABLES
	PUBLIC	_tryingToWriteKeyboardData

	PUBLIC	_altSuppressedTbl
	PUBLIC	_shiftSuppressedTbl
	PUBLIC	_ctrlSuppressedTbl
	
;********* FUNCTIONS
	EXTRN	_doSerial:NEAR
	EXTRN	_kickStartSerialKeys:NEAR
	EXTRN	_serialKeysInit:NEAR
	EXTRN	Put_Mouse_Data:NEAR

;********* VARIABLES
	EXTRN	beep_low:near
	EXTRN	fFilterKeysOn:BYTE
	EXTRN	fDialog_Filter_off:BYTE
	EXTRN	fDialog_Action:BYTE
	EXTRN	_skCommPortAddr:WORD
	EXTRN	_skCommIRQ:WORD
	EXTRN	_skBaudRate:WORD
	EXTRN	_vector:BYTE
	EXTRN	_kbFlag:BYTE
	EXTRN	_kbFlag1:BYTE
	EXTRN	_kbFlag2:BYTE
	EXTRN	_altKeypad:BYTE
	EXTRN	_aliasStr:BYTE
	EXTRN	_inSerialKeys:BYTE
	
	EXTRN	_end:ABS

;********* LOCAL FUNCTIONS
	
	; serialInt	PROC NEAR
	; timerInt	PROC NEAR
	; skInt15Routine	PROC NEAR

no_key		equ	0
NOKEY		equ	0
lquote_key	equ	1
one_key		equ	2
two_key		equ	3
three_key	equ	4
four_key	equ	5
five_key	equ	6
six_key		equ	7
seven_key	equ	8
eight_key	equ	9
nine_key	equ	10
zero_key	equ	11
hyphen_key	equ	12
equal_key	equ	13
backspace_key	equ	15

tab_key		equ	16
q_key		equ	17
w_key		equ	18
e_key		equ	19
r_key		equ	20
t_key		equ	21
y_key		equ	22
u_key		equ	23
i_key		equ	24
o_key		equ	25
p_key		equ	26
lbracket_key	equ	27
rbracket_key	equ	28
bslash_key	equ	29

caps_key	equ	30
a_key		equ	31
s_key		equ	32
d_key		equ	33
f_key		equ	34
g_key		equ	35
h_key		equ	36
j_key		equ	37
k_key		equ	38
l_key		equ	39
semicolon_key	equ	40
rquote_key	equ	41
return_key	equ	43

lshift_key	equ	44
z_key		equ	46
x_key		equ	47
c_key		equ	48
v_key		equ	49
b_key		equ	50
n_key		equ	51
m_key		equ	52
comma_key	equ	53
period_key	equ	54
fslash_key	equ	55
rshift_key	equ	57

lcontrol_key	equ	58
lcommand_key	equ	59
lalt_key	equ	60
space_key	equ	61
ralt_key	equ	62
rcommand_key	equ	63
rcontrol_key	equ	64

insert_key	equ	75
delete_key	equ	76
left_key	equ	79
home_key	equ	80
end_key		equ	81
up_key		equ	83
down_key	equ	84
pageup_key	equ	85
pagedown_key	equ	86
right_key	equ	89

numlock_key	equ	90
kp7_key		equ	91
kp4_key		equ	92
kp1_key		equ	93
kpfslash_key	equ	95
kp8_key		equ	96
kp5_key		equ	97
kp2_key		equ	98
kp0_key		equ	99
kpstar_key	equ	100
kp9_key		equ	101
kp6_key		equ	102
kp3_key		equ	103
kpperiod_key	equ	104
kpminus_key	equ	105
kpplus_key	equ	106
kpequal_key	equ	107
kpenter_key	equ	108

escape_key	equ	110

f1_key		equ	112
f2_key		equ	113
f3_key		equ	114
f4_key		equ	115

f5_key		equ	116
f6_key		equ	117
f7_key		equ	118
f8_key		equ	119

f9_key		equ	120
f10_key		equ	121
f11_key		equ	122
f12_key		equ	123

print_key	equ	124
scroll_key	equ	125
pause_key	equ	126
reset_key	equ	127

shift_key	equ	lshift_key
control_key	equ	lcontrol_key
alt_key		equ	lalt_key

TRUE		equ 1
FALSE		equ 0

;COM1		equ	3F8h
;COM2		equ	2F8h
;COM3		equ	3E8h
;COM4 		equ	2E8h

IRQ4		equ	4
IRQ3		equ	3

RBR		equ	0
THR 		equ	0
DLL 		equ	0
IER 		equ	1
DLM 		equ	1
FCR 		equ	2
IIR 		equ	2
LCR 		equ	3
MCR 		equ	4
LSR 		equ	5

XON		equ	17
XOFF		equ	19

RTS_BIT		equ	2
DTR_BIT		equ	1

DR_FLAG		equ	01h
OR_FLAG		equ	02h
PE_FLAG		equ	04h
FE_FLAG		equ	08h
BI_FLAG		equ	010h
THRE_FLAG	equ	020h
TSRE_FLAG	equ	040h

RDA_INT		equ	01h
THRE_INT	equ	02h
RLS_INT		equ	04h

NOMOUSE		equ 0
BUSMOUSE	equ 1
SERIALMOUSE	equ 2
INPORTMOUSE	equ 3
PS2MOUSE	equ 4
HPMOUSE		equ 5

PAUSE_MODE_MASK		equ 08h
KBDINDICATORUPDATE	equ 01000000b

bios_seg	segment at 40h
	org 017h
kbFlag		db ?
kbFlag1		db ?
altKeypad	db ?

	org 01Ah
kbBufHeadPtr	dw ?
kbBufTailPtr	dw ?

	org 071h
breakState	db ?
resetFlag	dw ?

	org 080h
kbBufStartPtr	dw ?
kbBufEndPtr	dw ?

	org 096h
kbFlag2		db ?
kbLEDFlag	db ?

bios_seg ends


rom_seg segment at 0f000h
	org 0fff0h
reset	label far
rom_seg ends

_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP _TEXT, CONST, _DATA, _BSS




_TEXT      SEGMENT



	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing

;**********************************************************************

	PUBLIC serkeysStartOfCode
serkeysStartOfCode	label byte
	even

oldSerialVect	DD 0

		even
skSaveSP	dw 0
skSaveSS	dw 0
		db 'SKb'
		even
skStack		dw 128 dup(0)
skTopOStack	dw $-2
		db 'SKt'


_mouBuffer	db	90 dup (0)
_mouBufferEnd	dw	$
_mouBufTailPtr	dw	_mouBuffer
_mouBufHeadPtr	dw	_mouBuffer

_tryingToWriteKeyboardData db 0


_altSuppressedTbl	db g_key, h_key, rquote_key, b_key, n_key, fslash_key, space_key, left_key
			db up_key, down_key, right_key, kp0_key, kpperiod_key, kpminus_key
			db escape_key, f4_key, f5_key, f6_key, 0,0

_shiftSuppressedTbl	db backspace_key, tab_key, t_key, y_key, lbracket_key, rbracket_key, caps_key
			db return_key, z_key, x_key, c_key, v_key, m_key, comma_key, period_key
			db rcontrol_key, kp4_key, kpfslash_key, kp5_key, kpstar_key, kp6_key
			db f3_key, f7_key, pause_key, 0, 0

_ctrlSuppressedTbl	db lquote_key, five_key, six_key, hyphen_key, equal_key, return_key, z_key
			db x_key, c_key, v_key, m_key, comma_key, period_key, rshift_key
			db insert_key, delete_key, home_key, pageup_key, kpfslash_key, kpstar_key
			db f1_key, f2_key, f8_key, f9_key, pause_key, 0, 0

;**********************************************************************
	ASSUME	CS: _TEXT
	ASSUME	DS: NOTHING
	ASSUME  SS: NOTHING
	ASSUME  ES: NOTHING

	PUBLIC	serialInt
serialInt PROC FAR
	cli
	cmp	cs:_inSerialKeys,TRUE
	je	serialInt10
	mov	cs:skSaveSP,sp
	mov	cs:skSaveSS,ss
	push	cs
	pop	ss
	mov	sp,offset skTopOStack

serialInt10:

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es
	push	bp
	mov	ax,cs
	mov	ds,ax
	mov	es,ax
	ASSUME	DS: _TEXT
	ASSUME	ES: _TEXT

	cld
	call	_doSerial			; call our routine

	cli
	pop	bp
	pop	es
	pop	ds
	ASSUME	DS: NOTHING
	ASSUME	ES: NOTHING
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	cmp	cs:_inSerialKeys,TRUE
	je	serialIntDone
	mov	ss,cs:skSaveSS
	mov	sp,cs:skSaveSP
serialIntDone:

	iret	

serialInt ENDP



;**********************************************************************

	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
_doBeep	proc	near

IFNDEF ALL_LINK
	push	ax
	push	bx
	push	cx
	mov	bx,200h
	in	al,61h
	push	ax
k65:
	and	al,0fch
	out	61h,al
	mov	cx,40h
k66:
	loop	k66
	or	al,2
	out	61h,al
	mov	cx,40h
k67:
	loop	k67
	dec	bx
	jnz	k65
	pop	ax
	out	61h,al
	pop	cx
	pop	bx
	pop	ax
	ret
ELSE
	jmp beep_low
	ret
ENDIF

_doBeep	endp


;**********************************************************************

	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME  SS: NOTHING
	ASSUME  ES: NOTHING

;**********************************************************************
_doReboot PROC NEAR
	; don't bother to save regs since computer will be rebooting
	mov	bx,bios_seg
	mov	es,bx
	assume	es:bios_seg
	mov	resetFlag,1234h			;signal for soft reset
	jmp	reset
	assume	es:nothing
_doReboot ENDP


;**********************************************************************

_handleBreak PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing

	push	es
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bx,word ptr kbBufStartPtr	; clear out kb buffer
	mov	word ptr kbBufTailPtr,bx
 	mov	word ptr kbBufHeadPtr,bx
	mov	al,080h				; set break bit
	mov	byte ptr breakState,al
	int	1Bh				; do break interrupt
	sub	ax,ax
	push	ax				; send dummy character
	call	_putInKbdBuffer
	pop	bx
	popf
	pop	es
	assume	es:nothing
	ret	

_handleBreak ENDP


;**********************************************************************

_inPauseCondition	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	es
	push	bx
	mov	bx,bios_seg
	mov	es,bx
	assume	es:bios_seg
	sub	al,al
	test	byte ptr kbFlag1,PAUSE_MODE_MASK
	jz	inPauseConditionDone
	mov	al,1
inPauseConditionDone:
	pop	bx
	pop	es
	assume	es:nothing
	ret	

_inPauseCondition	ENDP

;**********************************************************************

_setInPause PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	es
	mov	bx,bios_seg
	mov	es,bx
	assume	es:bios_seg
	or	byte ptr kbFlag1,PAUSE_MODE_MASK
	pop	es
	assume	es:nothing
	ret	

_setInPause ENDP

;**********************************************************************

_clearInPause PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	es
	mov	bx,bios_seg
	mov	es,bx
	assume	es:bios_seg
	and	byte ptr kbFlag1, NOT PAUSE_MODE_MASK
	pop	es
	assume	es:nothing
	ret	

_clearInPause ENDP


;**********************************************************************

_serialKeysCommInit	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME  SS: NOTHING
	ASSUME  ES: NOTHING

	push	ax
	push	bx
	push	cx
	push	dx
	push	es

	; disable serial interrupt at 8259 controller
	in	al,21h				; get 8259 interrupt mask
	cmp	byte ptr _skCommIRQ,IRQ4	; which IRQ
	jne	commInit100
commInit50:
	or	al,10h				; mask IRQ 4
	out	21h,al	
	mov	ax,350Ch			; setup for getting old com1 vector
	jmp	short commInit200
commInit100:
	or	al,8h				; mask IRQ 3
	out	21h,al
	mov	ax,350Bh			; setup for getting old com2 vector
commInit200:
	int	21h				; get vector (es:bx)

	; see if our routine was installed already
	cmp	bx,OFFSET serialInt		; see if vector offset is ours
	jne	commInit400			; jump if not ours
	mov	dx,es				; get vector segment
	mov	cx,cs
	cmp	dx,cx				; see if vector segment is ours
	jne	commInit400			; jump if not ours
	jmp	short commInit1000		; ours already here so skip

	; our routine was not installed so save old vectors
	; and put ours in instead
commInit400:
	mov	word ptr cs:oldSerialVect,bx
	mov	word ptr cs:oldSerialVect+2,es

	push	ds
	mov	dx,cs
	mov	ds,dx
	mov	dx,OFFSET serialInt
	mov	ah,25h
	int	21h
	pop	ds

commInit1000:
	call	_initCommPort			; initialize the comm port
	pop	es
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
_serialKeysCommInit	ENDP

;**********************************************************************

_serialKeysEnableFar	proc far
	push	ds
	push	es
	push	cs
	push	cs
	pop	ds
	pop	es
	call	_serialKeysInit
	mov	_serialKeysOn,TRUE			; set SerialKeys on ?
	pop	es
	pop	ds
	retf
_serialKeysEnableFar  endp


_serialKeysDisableFar	proc far
	push	ds
	push	es
	push	cs
	push	cs
	pop	ds
	pop	es
	mov	_serialKeysOn,FALSE			; set SerialKeys on ?
	call	_serialKeysDisable
	pop	es
	pop	ds
	retf
_serialKeysDisableFar  endp

_serialKeysDisable	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME  SS: NOTHING
	ASSUME  ES: NOTHING

	push	ax
	push	bx
	push	cx
	push	dx
	push	es

	; get serial interrupt vectors
	cmp	byte ptr _skCommIRQ,IRQ4
	jne	skDisable100
skDisable50:
	mov	ax,350Ch
	jmp	short skDisable200

skDisable100:
	mov	ax,350Bh
skDisable200:
	int	21h

	; see if our routine was installed already
	cmp	bx,OFFSET serialInt		; see if vector offset is ours
	jne	skDisable1000			; jump if not ours
	mov	bx,es				; get vector segment
	mov	cx,cs
	cmp	bx,cx				; see if vector segment is ours
	jne	skDisable1000			; jump if not ours

	cli
	; we are installed so now disable our routine
	mov	bx,word ptr _skCommPortAddr
	mov	dx,bx
	add	dx,MCR
	in	al,dx
	jmp	$+2
	and	al,NOT 0Fh
	out	dx,al
	mov	dx,bx
	add	dx,IER
	mov	al,0
	out	dx,al
	call	_clearOutComm

	in	al,21h				; get 8259 int masks
	cmp	byte ptr _skCommIRQ,IRQ4	; which IRQ
	jne	skDisable300
skDisable250:
	or	al,10h				; mask IRQ 4
	out	21h,al
	mov	ax,250Ch			; setup for com1 vectors
	jmp	short skDisable400

skDisable300:
	or	al,8h				; mask IRQ 3
	out	21h,al
	mov	ax,250Bh			; setup for com2 vector
skDisable400:
	; restore old serial vector
	push	ds
	mov	dx,word ptr cs:oldSerialVect+2
	mov	ds,dx
	mov	dx,word ptr cs:oldSerialVect
	int	21h
	cli
	pop	ds
	call	_initGIDEI
	call	_clearOutComm

skDisable1000:
	pop	es
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret	

_serialKeysDisable	ENDP

;**********************************************************************
_initCommPort	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing

	push	ax
	push	bx
	push	dx
	call	_turnOffHandshake
	call	_disableComm
	call	_clearOutComm
	mov	bx,word ptr _skCommPortAddr
	mov	ax,0
	mov	dx,bx
	add	dx,FCR
	out	dx, al				; turn off FIFO
	call	_setBaudRate
	in	al,21h				; get 8259 int mask
	cmp	byte ptr _skCommIRQ,IRQ4	; which IRQ
	jne	initCommPort100
initCommPort50:
	and	ax,0EFh				; unmask IRQ 4
	jmp	SHORT initCommPort200
initCommPort100:
	and	ax,0F7h				; unmask IRQ 3
initCommPort200:
	out	21h,al				; write updated mask byte
	call	_enableComm
	mov	dx,bx
	add	dx,MCR
	mov	al,08h
	out	dx,al
	call	_turnOnHandshake
	pop	dx
	pop	bx
	pop	ax
	ret	

_initCommPort	ENDP


;**********************************************************************

_setBaudRate	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing

	push	ax
	push	bx
	push	cx
	push	dx
	mov	ax,0083h			; set DLAB = 1
	mov	cx,word ptr _skCommPortAddr	; save for later
	mov	dx,cx
	add	dx,LCR
	out	dx,al
	jmp	short $+2

	mov	ax,word ptr _skBaudRate	; set baud rate, LSB then MSB
	mov	dx,cx
	add	dx,DLL
	out	dx, al
	jmp	short $+2

	mov	dx,cx
	add	dx,DLM
	xchg	al,ah
	out	dx,al
	jmp	short $+2
	mov	ax,3				; set DLAB=0 (and word protocol 8,n,1)
	mov	dx,cx
	add	dx,LCR
	out	dx,al
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
_setBaudRate	ENDP

;**********************************************************************

_turnOnHandshake PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	ax
	push	dx
	mov	dx,word ptr _skCommPortAddr
	add	dx,MCR
	in	al,dx
	jmp	$+2
	or	al,RTS_BIT+DTR_BIT
	out	dx,al				; turn on handshaking
	mov	dx,word ptr _skCommPortAddr
;	add	dx,THR
	mov	al,XON
	out	dx,al
	pop	dx
	pop	ax
	ret
_turnOnHandshake ENDP

;**********************************************************************

_turnOffHandshake PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	ax
	push	dx
	mov	dx,word ptr _skCommPortAddr
	add	dx,MCR
	in	al,dx
	jmp	$+2
	and	al,NOT (RTS_BIT+DTR_BIT)
	out	dx,al				; turn off handshaking
	jmp	$+2
	mov	dx,word ptr _skCommPortAddr
;	add	dx,THR
	mov	al,XOFF
	out	dx,al
	pop	dx
	pop	ax
	ret
_turnOffHandshake ENDP


;**********************************************************************

_disableComm PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	ax
	push	dx
	mov	dx,word ptr _skCommPortAddr
	add	dx,IER				; turn off int on anything
	sub	al,al
	out	dx,al
	pop	dx
	pop	ax
	ret
_disableComm ENDP

;**********************************************************************

_enableComm PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	ax
	push	dx
	mov	dx,word ptr _skCommPortAddr
	add	dx,IER
	mov	al,RLS_INT+RDA_INT
	out	dx,al
	pop	dx
	pop	ax
	ret
_enableComm ENDP


;**********************************************************************

_clearOutComm PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	ax
	push	bx
	push	dx
	mov	bx,word ptr _skCommPortAddr
	mov	dx,bx
	add	dx,RBR
	in	al,dx				; clear out any pending character
	jmp	short $+2
	mov	dx,bx
	add	dx,LSR
	in	al,dx				; reset status int
	jmp	short $+2
	mov	dx,bx
	add	dx,IER
	in	al,dx				; reset THRE int
	jmp	short $+2
	mov	dx,bx
	add	dx,RBR
	in	al,dx				; clear out any pending characters
	jmp	short $+2
	pop	dx
	pop	bx
	pop	ax
	ret
_clearOutComm ENDP

;**********************************************************************
_disableKeyEnhance PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing

	cmp	fFilterKeysOn,TRUE
	jne	disableKE_end
	mov	fDialog_Filter_off,TRUE
	mov	fDialog_Action,TRUE
disableKE_end:
	ret

_disableKeyEnhance ENDP


;**********************************************************************
_waitingForIndicatorUpdate PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	sub	ax,ax
	push	es
	push	bx
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	test	kbLEDFlag,KBDINDICATORUPDATE
	jz	waitingForIndDone
	mov	ax,1
waitingForIndDone:
	popf
	pop	bx
	pop	es
	assume	es:nothing
	ret
_waitingForIndicatorUpdate ENDP


;**********************************************************************

_getBiosFlags PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	es
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bl,byte ptr kbFlag
	mov	_kbFlag,bl
	mov	bl,byte ptr kbFlag1
	mov	_kbFlag1,bl
	mov	bl,byte ptr kbFlag2
	mov	_kbFlag2,bl
	mov	bl,byte ptr altKeypad
	mov	_altKeypad,bl
	popf
	pop	es
	assume	es:nothing
	ret
_getBiosFlags ENDP
	

;**********************************************************************

_putBiosFlags PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	es
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bl,_kbFlag
	mov	byte ptr kbFlag,bl
	mov	bl,_kbFlag1
	mov	byte ptr kbFlag1,bl
	mov	bl,_kbFlag2
	mov	byte ptr kbFlag2,bl
	mov	bl,_altKeypad
	mov	byte ptr altKeypad,bl
	popf
	pop	es
	assume	es:nothing
	ret
_putBiosFlags ENDP
	


;**********************************************************************

_keyBufferFull	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	sub	ax,ax
	push	es
	push	bx
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bx,word ptr kbBufTailPtr	;get pointer to next available spot
	inc	bx				;increment to next
	inc	bx
	cmp	bx,word ptr kbBufEndPtr		; should pointer rap around
	jb	keyBufferFull100		; jump if not
	mov	bx,word ptr kbBufStartPtr	; rap pointer to beginning of buffer
keyBufferFull100:
	cmp	bx,word ptr kbBufHeadPtr	; is buffer full
	jne	keyBufferFullDone		; jump if not full
	mov	ax,1				; signal buffer full
keyBufferFullDone:
	popf
	pop	bx
	assume	es:nothing
	pop	es
	ret	

_keyBufferFull	ENDP

;**********************************************************************

_keyBufferEmpty	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	sub	ax,ax
	push	es
	push	bx
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bx,word ptr kbBufHeadPtr	;does head=tail
	cmp	bx,word ptr kbBufTailPtr
	jne	keyBufferEmptyDone		;jump if not empty
	mov	ax,1				;signal that it is full
keyBufferEmptyDone:
	popf
	pop	bx
	pop	es
	assume	es:nothing
	ret
_keyBufferEmpty	ENDP


;**********************************************************************

_putInKbdBuffer	PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	bp
	mov	bp,sp
	push	es
	push	si
	mov	bx,bios_seg
	pushf
	cli
	mov	es,bx
	assume	es:bios_seg
	mov	bx,word ptr kbBufTailPtr	; get pointer to next available spot
	mov	si,bx				; save it for later
	inc	bx				; increment to next
	inc	bx
	cmp	bx,word ptr kbBufEndPtr		; should pointer rap around
	jb	putInKbdBuffer100		; jump if not
	mov	bx,word ptr kbBufStartPtr	; rap pointer to beginning of buffer
putInKbdBuffer100:
	cmp	bx,word ptr kbBufHeadPtr	; is buffer full
	je	putInKbdBufferDone		; jump if not full
	mov	ax,word ptr [bp+4]		; get code from stack
	mov	es:[si],ax			; put byte in buffer
	mov	word ptr kbBufTailPtr,bx	; update new tail pointer
putInKbdBufferDone:
	popf
	pop	si
	pop	es
	assume	es:nothing
	mov	sp,bp
	pop	bp
	ret	

_putInKbdBuffer	ENDP


;**********************************************************************

_sendMouseData	PROC NEAR
	pushf
	push	ax
	push	bx
	push	dx
	mov	bx,_mouBufHeadPtr
	cmp	bx,_mouBufTailPtr
	je	sendMouDataDone
	cmp	_fmouse_id,4			; do we have a PS/2 mouse ?
	jne	sendMouData50

	push	es
	sub	ax,ax
	call	getFromMouseBuffer		; ax has the data upon return
	push	ax				; push status
	call	getFromMouseBuffer		; ax has the data upon return
	push	ax				; push X
	call	getFromMouseBuffer		; ax has the data upon return
	push	ax				; push Y
	sub	ax,ax
	push	ax				; push Z
	mov	ax,ExtendedSeg
	mov	es,ax
	call	dword ptr es:[22h]
	cmp	_comp_id,6
	je	sendMouData10
	int	74h
	jmp	sendMouData30
sendMouData10:
	int	71h
sendMouData30:
	add	sp,+8
	pop	es
	jmp	sendMouDataDone

sendMouData50:
	cmp	_fmouse_id,2			; do we have a serial mouse ?
	jne	sendMouDataDone
	mov	dx,_combase			; put address of combase in dx

; first check to be sure the byte we may have transmitted previously has been sent out
	cli
	add	dx,LSR
	in	al,dx
	test	al,THRE_FLAG+TSRE_FLAG		; bit 5, transmit buffer should be clear if okay to write
	jz	sendMouDataDone
	call	getFromMouseBuffer		; ax has the data upon return
	mov	dx,_combase			; put address of combase in dx
	out	dx,al		
sendMouDataDone:
	pop	dx
	pop	bx
	pop	ax
	popf
	ret
_sendMouseData	ENDP

;**********************************************************************
_putInMouseBuffer PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	bp
	mov	bp,sp
	push	si
	push	bx				; temp store of bx register
	pushf
	cli
	mov	bx,_mouBufTailPtr		; get tail pointer of mouse_data buffer
	mov	si,bx				; save pointer value
	inc	bx
	inc	bx
	inc	bx
	cmp	bx,OFFSET _mouBufferEnd		; are we at the end of the buffer ?
	jb	putInMouBuf100			; no
	mov	bx,OFFSET _mouBuffer		; yes we are, so reset to the buffer beginning
putInMouBuf100:
	cmp	bx,_mouBufHeadPtr		; has the buffer wrapped around ?
	je	putInMouBufDone
	mov	ax,[bp+4]			; STATUS
	mov	[si],al				; move whats in ax into address pointed to by si
	inc	si
	mov	ax,[bp+6]			; X
	mov	[si],al				; move whats in ax into address pointed to by si
	inc	si
	mov	ax,[bp+8]			; Y
	mov	[si],al				; move whats in ax into address pointed to by si
	mov	_mouBufTailPtr,bx		; update tail pointer
putInMouBufDone:
	popf
	pop	bx
	pop	si
	mov	sp,bp
	pop	bp
	ret
_putInMouseBuffer ENDP

;**********************************************************************
getFromMouseBuffer PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	bx				; temp store of bx register
	pushf
	cli
	mov	bx,_mouBufHeadPtr		; get tail pointer of mouse_data buffer
	cmp	bx,_mouBufTailPtr
	je	getFromMouBufDone
	mov	al,[bx]
	inc	bx
	cmp	bx,OFFSET _mouBufferEnd		; are we at the end of the buffer ?
	jb	getFromMouBuf100			; no
	mov	bx,OFFSET _mouBuffer		; yes we are, so reset to the buffer beginning
getFromMouBuf100:
	mov	_mouBufHeadPtr,bx		; update tail pointer
getFromMouBufDone:
	popf
	pop	bx
	ret
getFromMouseBuffer ENDP

;**********************************************************************

_convertStringToInt PROC NEAR
	ASSUME	CS: _TEXT
	ASSUME	DS: _TEXT
	ASSUME	SS: nothing
	ASSUME	ES: nothing
	
	push	si
	mov	si,offset _aliasStr		;get address of string
	xor	ax,ax				;clear upper byte
	cwd
	xor	bx,bx				;clear storage
	lodsb					;get first character
	push	ax				;save it for later
	cmp	al,'+'				;if + or - then get next char
	je	StrToInt2
	cmp	al,'-'
	jne	StrToInt3			;not + or - so jump
StrToInt2:
	lodsb					;get numeric char
StrToInt3:
	cmp	al,0				;at end of string?
	je	StrToIntDone			;jump if done
	cmp	al,'9'				;make sure it is a number
	ja	StrToIntError			;
	sub	al,'0'
	jb	StrToIntError
	;valid number so now convert to integer
	;multiply running sum by 10 and add current
	shl	bx,1				;multiply by 2 and save for later
	mov	cx,bx				;
	shl	bx,1				; x4 now
	shl	bx,1				; x8 now
	add	bx,cx				; x8 + x2 = x10
	add	bx,ax				;add current value
	jmp	SHORT StrToInt2			;continue until all done
StrToIntError:
	pop	ax				;clean up stack
	mov	bx,offset _aliasStr
	xor	ax,ax				;signal bad string
	mov	byte ptr [bx],al
	xor	ax,0FFFFH			;make sure larger than 256
	jmp	SHORT StrToInt6
StrToIntDone:
	;ok we are done converting to integer
	;Now lets see if it is supposed to be a number or a command code
	pop	ax				;get back first character
	cmp	al,'-'				;if - then a number
	xchg	ax,bx				;switch for easier processing
	jne	StrToInt6			;not a - so jump
StrToInt5:
	neg	ax				;convert to a negative
StrToInt6:
	pop	si
	ret
_convertStringToInt ENDP


_TEXT	ENDS
	
;	END	serialKeysMain

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\serkeys.h ===
/*  serkeys.H   */

void doBeep(void);
void doReboot(void);
void handleBreak(void);
BOOL inPauseCondition(void);
void clearInPause(void);
void setInPause(void);
void clearOutComm(void);

void serialKeysCommInit(void);
void serialKeysDisable(void);
void initCommPort(void);
void setBaudRate(void);
void turnOffHandshake(void);
void turnOnHandshake(void);
void disableComm(void);
void enableComm(void);
void clearOutComm(void);
void disableKeyEnhance(void);

BOOL waitingForIndicatorUpdate(void);
void getBiosFlags(void);
void putBiosFlags(void);
BOOL keyBufferFull(void);
BOOL keyBufferEmpty(void);
void putInKbdBuffer(unsigned int);

void putInMouseBuffer(signed char, signed char, signed char);
void sendMouseData(void);

int convertStringToInt(void);

extern BYTE * mouBufTailPtr;
extern BYTE * mouBufHeadPtr;
extern BYTE mouBuffer[];
extern BYTE altSuppressedTbl[];
extern BYTE shiftSuppressedTbl[];
extern BYTE ctrlSuppressedTbl[];
extern BYTE tryingToWriteKeyboardData;


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\timeout.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	TIMEOUT.ASM							*
;									*
;************************************************************************

TITLE	Timeout

INCLUDE	keyboard.inc

	PUBLIC	TimeOut_Reset				; in TimeOut.asm
	PUBLIC	TimeOut_timer
	PUBLIC	TimeOut_dialog 
	PUBLIC	last_address
	
	EXTRN	FilterKeys_TurnOff:PROC			; in FilterKeys.asm

	EXTRN	SticKeys_TurnOff:PROC			; in StickeyKeys.asm

	EXTRN	MouseKeys_TurnOff:PROC			; in MOuseKeys.asm

	EXTRN	ToggleKeys_TurnOff:PROC			; in ToggleKeys.asm

	EXTRN	beep_turn_off:PROC			; in Handicap.asm
	EXTRN	fswitching_video:byte
	EXTRN	faccess_sound:byte
	EXTRN	fsecond_cue:byte


	EXTRN	fTime_Out:byte				; from Param.asm
	EXTRN	fTO_On_Off_Feedback:byte
	EXTRN	to_value:word
	EXTRN	fDialog_TimeOut_off:byte

	EXTRN	fhearing_on:byte
	EXTRN	fvideo_flash:byte

	EXTRN	fFilterKeysOn:byte
	EXTRN	fSticKeysOn:byte
	EXTRN	fMouseKeysOn:byte
	EXTRN	fToggleKeysOn:byte

;----------------------------------------------------------------------------

_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;
;  The below area defines the resident data area.
;

to_cnt		DW	to_dflt_cnt		; hold count for time out

;----------------------------------------------------------------------------
; TimeOut_timer
;
; The TimeOut routine provides the user with a choice of time settings for which if no
; activity occurred in the specified period of time, the keyboard and mouse enhancement 
; features will time out and disable themselves.
;
; Expects:	Nothing
;
; Uses:		bx
;----------------------------------------------------------------------------

TimeOut_Reset	proc	

	assume	DS:_TEXT

	jmp	timeout_begin

;----------------------------------------------------------------------------
; TimeOut_dialog 
;
;	Checks a single flag from Dialog box to see if TimeOut was turned
; on/off.  

TimeOut_dialog	proc	

	assume	DS:_TEXT

	cmp	fTime_Out,true				; was TimeOut turned on
	jne	TOd_25
	mov	fTime_Out,true				; turn time out on
	jmp	short TOd_50

TOd_25:
	mov	fTime_Out,false				; turn time out off
TOd_50:
	mov	fDialog_TimeOut_off,false  		; reset flag to false
	ret

TimeOut_dialog	endp
;-----------------------------------------------------------------------------

TimeOut_timer	proc

	assume	DS:_TEXT

	push	bx

	cmp	fTime_Out,false			; is time out off?
	je	TimeOut_timer_end		; yes, quit -->
	xor	bx,bx				; set bx to 0
	cmp	to_cnt,bx			; is count zero?
	jg	TimeOut_10			; no, just decrement count
	jl	TimeOut_timer_end		; is it less than zero? yes -->
	cmp	fFilterKeysOn,false
	je	TimeOut_1
	inc	bl				; set flag
	call	FilterKeys_TurnOff		; turn off all the features
TimeOut_1:			       	
	cmp	fSticKeysOn,false
	je	TimeOut_2
	inc	bl				; set flag
	call	SticKeys_TurnOff
TimeOut_2:
	cmp	fMouseKeysOn,false
	je	TimeOut_3
	inc	bl				; set flag
	call	MouseKeys_TurnOff
TimeOut_3:
	cmp	fToggleKeysOn,false
	je	TimeOut_4
	inc	bl				; set flag
	call	ToggleKeys_TurnOff
TimeOut_4:
	cmp	fhearing_on,false
	je	TimeOut_5
	inc	bl				; set flag
	mov	fhearing_on,false
TimeOut_5:
	cmp	fvideo_flash,false
	je	TimeOut_6
	inc	bl				; set flag
	mov	fvideo_flash,false
TimeOut_6:
	or	bl,bl				; any turned off (i.e. bl <> 0)?
	jz	TimeOut_timer_end		; no -->
	cmp	fTO_On_Off_Feedback,false
	je	TimeOut_8
	call	beep_turn_off

TimeOut_8:
	cmp	fswitching_video,false
	jne	TimeOut_10
	mov	faccess_sound,true
	mov	fsecond_cue,25

TimeOut_10: 
	dec	to_cnt				; decrement count
TimeOut_timer_end: 

	pop	bx
	ret

TimeOut_timer	endp


;----------------------------------------------------------------------------
; TimeOut_Reset
;
; Expects:	Nothing
;
; Uses:		ax
;----------------------------------------------------------------------------

timeout_begin:

	push	ax
	mov	ax,to_value			; reset time out count
	mov	to_cnt,ax
	pop	ax
	ret

TimeOut_Reset	endp

last_address	dw	"$"	    		; last address we want to save when TSR'ing

_TEXT	ends

	end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\stickeys.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	STICKEYS.ASM							*
;									*
;************************************************************************

TITLE	StickeyKeys

INCLUDE	keyboard.inc


	EXTRN	shift_tbl:byte				; in Handicap.asm
	EXTRN	shift_tbl_len:abs
	EXTRN	current_shift:byte
	EXTRN 	real_states:byte
	EXTRN	prev_real_states:byte
	EXTRN	comp_flag:byte
	EXTRN	beep_high:PROC
	EXTRN	beep_low:PROC
	EXTRN	click:PROC
	EXTRN	no_beep:PROC
	EXTRN	beep_turn_on:PROC
	EXTRN	beep_turn_off:PROC
	EXTRN	key_data_tail:word
	EXTRN	key_data_head:word
	EXTRN	key_data:word
	EXTRN	key_data_end:word
	EXTRN	Put_Key_Data:PROC
	EXTRN	_finject_keys:byte
	EXTRN	_vector:byte
	EXTRN	fswitching_video:byte
	EXTRN	faccess_sound:byte
	EXTRN	fsecond_cue:byte
	EXTRN	fkey_not_passed:byte

	EXTRN	fSticKeysOn:byte   			; from Param.asm
	EXTRN	fSK_On_Off_Feedback:byte
	EXTRN	fAudible_Feedback:byte
	EXTRN	fTriState:byte
	EXTRN	fTwo_Keys_Off:byte	 
	EXTRN	fDialog_Stickeys_off:byte
	EXTRN	fstickeys_click:byte
	EXTRN	fFilterKeysOn:byte	
	EXTRN	_comp_id:byte

	EXTRN	MouseKeys:PROC				; in Mousekey.asm

	EXTRN	TimeOut_Reset:PROC			; in Toggle.asm

	EXTRN	on_wait_ticks:word			; in Filter.asm

IFDEF	BUG

	EXTRN	portid:byte
	EXTRN	portout:byte
	EXTRN	HexCharsOut:PROC

ENDIF; BUG

	PUBLIC	SticKeys_TurnOff			; in StickeyKeys.asm
	PUBLIC	SticKeys,key_cnt
	PUBLIC	shift_flg,lock_flg,fkeys_injected
	PUBLIC	StickeyKeys_dialog
	PUBLIC	set_shift_states
	PUBLIC	flatch
	PUBLIC	shift_flg

;----------------------------------------------------------------------------
_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;
;  The below area defines the resident data area.
;
;----------------------------------------------------------------------------
SetShiftTable	label	word

	DW	fRShift_word
	dw	LShift
	dw	RShift

	DW	fLShift_word
	dw	RShift
	dw	LShift

;----------------------------- break of 4 count

	DW	fLCtrl_word
	dw	RCtrl
	dw	Ctrl

	DW	fLAlt_word
	dw	RAlt
	dw	Alt

	DW	fRCtrl_word
	dw	Ctrl
	dw	RCtrl

	DW	fRAlt_word
	dw	Alt
	dw	RAlt

SetShiftTableLen	equ	6


flgs		label	word

shift_flg		DB	0		; shift flags
lock_flg		DB	0		; lock flags


key_cnt			DB	0		; key count for turning on and off
key_to_pass		DW	0		; holds key to pass on ( ax-->ah,al)


shift_break_cnt		DB	0  		; holds the number of successive received shift breaks
flatch			DB	false		; flag to tell set_shift_states the latch key to clear
flock			DB	false		; flag to tell set_shift_states the lock key to clear
ftwo_down		DB	false		; flag to tell when two keys are down at the same time
fkeys_injected		DB	false		; flag to tell us that we put modifier break codes into Key_Data buffer
fopp_mod_sent		db	false		; flag used during injection of keys to control # of loops
;fmodel_25_30_latch	db	false		; flag used with PS/2 Model 25/30-86 during latching condition only


;----------------------------------------------------------------------------
; 
; The StickeyKey routine provide the user who may be a 1-finger typist, use a mouthstick
; or head pointer the ability to activate mutiple keystrokes sequentially instead of
; the standard simultaneous method.  For example, the Ctrl-Alt_Del. three simultaneous 
; sequence will reboot the IBM computer.  A 1-finger typist cannot depress all three keys 
; at the same time.  With StickeyKeys, the user need only press each key in order for the
; same desired result.
;----------------------------------------------------------------------------

SticKeys	proc	

	jmp	stickeys_begin	

;----------------------------------------------------------------------------
sk_turn_on_fb	proc	

	assume	DS:_TEXT

	cmp	fSK_On_Off_Feedback,false
	je	SticKeys_TurnOn
	call	beep_turn_on

SticKeys_TurnOn:
	cmp	fswitching_video,false
	jne	SticKeys_TurnOn_5
	mov	faccess_sound,true
	mov	fsecond_cue,24

SticKeys_TurnOn_5:

	mov	fSticKeysOn,true
sk_Restart:
	call	TimeOut_Reset
	mov	ftwo_down,false				; clear this flag 
	mov	fkeys_injected,false			; clear this flag at turnon
	mov	key_cnt,0				; reset key_cnt to 0
	mov	shift_break_cnt,0			; re-zero count 
;;	mov	fmodel_25_30_latch,false
	ret
sk_turn_on_fb	endp

;-----------------------------------------------------------------------------

two_keys_down	proc	near

	assume	DS:_TEXT

	cmp	fTwo_Keys_Off,false			; turn off at two keys?
	je	short two_keys_down_end
sk_turn_off_fb:
	cmp	fSK_On_Off_Feedback,false
	je	SticKeys_TurnOff
	call	beep_turn_off

SticKeys_TurnOff:
	cmp	fswitching_video,false
	jne	SticKeys_TurnOff_5
	mov	faccess_sound,true
	mov	fsecond_cue,25

SticKeys_TurnOff_5:

	mov	fSticKeysOn,false			; turn off
	mov	key_cnt,0				; reset key count
	mov	shift_break_cnt,0			; re-zero count 

set_real_states:
; currently, will shut off all modifiers when turned off, so if operator
; chooses to hold another modifier during shutoff, then it maybe cleared also 

	call	set_shift_states

	mov	ftwo_down,false				; clear this flag receiving a modifier key	
	mov	real_states,0
	mov	prev_real_states,0

two_keys_down_end:

	mov	flgs,0					; reset lock and shift flags 
	ret

two_keys_down	endp

;----------------------------------------------------------------------------
; StickeyKeys_dialog 
;
;	Checks a single flag from Dialog box to see if StickeyKeys was turned
; on/off.  If it was, this routine makes a call to Stickeys_TurnOn/Off so the realstates
; can be updated to match the computer.  Upon exit the flag that was set by 
; Dialog box is cleared.(returned to false)


StickeyKeys_dialog	proc	

	assume	DS:_TEXT

	cmp	fSticKeysOn,true			; was Stickeys turned on
	jne	Sd_25
	call	SticKeys_TurnOn_5 			; yes it was true, so turn on
	jmp	short Sd_50

Sd_25:
	call	SticKeys_TurnOff_5			; fSticKeysOn was false, so turn off
Sd_50:
	mov	fDialog_Stickeys_off,false		; reset flag to false
	ret

StickeyKeys_dialog	endp

;----------------------------------------------------------------------------
; set_shift_states
;
; assumes dl = gets set to the state to clear, if called to unlatch or unlock 
;

set_shift_states	proc

	push	ax
	push	bx
	push	cx
	push	es
	push	dx
	push	di
	push	si

	assume	ES:NOTHING
	mov	bx, RAMBIOS				; BIOS RAM segment at 40h
	mov	es,bx					;  .. point ES to that!
	assume	ES:RAMBIOS
	assume	DS:_TEXT


SticKey_On:

	mov	cx,SetShiftTableLen			; get length of table in cx
	mov	si,offset SetShiftTable			; get address of first word into si

	cmp	fSticKeysOn,false			; is Stickeys Off ?
	jne	sss_20					; No, Stickeys is ON, jmp to here
sss_10:

; If we get here, we now know that fStickeysOn = false and we have been called by either
;
;	1. Dialog Box of AccesDos Main Menu
;	2. A deactivation call, (i.e. 5 taps of the shift key)
;	3. Two key down turn off


	mov	dl,shift_flg				; need to clear any/all flags which might be set
	or	dl,lock_flg				; all modifiers !!!

; If we get here, check if Stickeys was turned off by two_keys_down

	cmp	ftwo_down,true				; was set_shift_states	called from two keys down ?
	je	sss_15					; yes, so jump to get only the locked and latched 
							; modifiers which are not actually currently pressed
	jmp	state_check				; if not from two_keys_down, jump to state_check and 
							; release all latched and locked modifiers
sss_15:

; Stickeys is Off from two keys down, but we need to only unlock any locked modifiers that are different from the
; modifiers which triggered the two_keys_down call.  dh= real_states which reflects exactly what keys are actually
; pressed down (break code not yet passed), where as dl=lock flag of those modifiers which are locked down, which may
; or may not be the key which triggered a two_key_turnoff. Also need to unlatch any other modifiers which the 
; release of the two_key_down will not unlatch.

	cmp	dh,dl
	jne	sss_18					; if the two_key_down is not the same as locked and latched, cont.
	jmp	set_shift_states_end			; if no other keys are latched or locked down, exit from a two_key_turnoff
sss_18:
	
	not	dh					; compliment real_states
	and	dl,dh					; "and" locked and complimented real states, which should leave 
	jmp	state_check	

sss_20:

; Stickeys is currently On, do we want to unlatch or unlock ?

	cmp	flatch,true				; is this an unlatch ?
	jne	undo_lock

undo_latch:						; if jump here, undo all the latched keys

	mov	dl,shift_flg				; move current shifted modifier flgs to dl
	jmp	state_check


;;	cmp	_comp_id,6				; do we have a PS/2 Model 25/30-86 ?
;;	jne	state_check				; if not the goofy PS/2 Model 25/30-86, cont. on
;;
;;;------------------------------------------------------------------------------------------------------------------------
;;; If we get here, it is the "goofy" PS/2 Model 25/30-86, which cannot recieve injected scan codes, so we must do some
;;; messing around to make it work.  If it is an unlatching condition, then we must set some flags and call when the next key is 
;;; entered, otherwise the flag bit is cleared before the shifted key is sent to the computer, effectively
;;; undoing the latch before it occurs.  For a locked condition, this is not a problem, so if the locked flag is set, we can 
;;; proced as normal.  For a latched condition, I will try to set another flag, and unlatch when another key is sent for
;;; this "goofy" computer only......in other words, clear kb_flag bits on the break or release of the intended key to
;;; be shifted, versus the make as normally done.
;;
;;
;;	cmp	fmodel_25_30_latch,true
;;	je   	state_check				; if called from the break, procede
;;
;;	mov	fmodel_25_30_latch,true			; if called from the normal make, set flag 
;;							; and exit, as break will undo flag bits
;;	jmp	set_shift_states_end_5
;;
;--------------------------------------------------------------------------------------------------------------------------

undo_lock:						; if jump here, undo the single current shift LOCKED KEY ONLY

	mov	dl,current_shift			; this is the modifier key to unlock
;;	jmp	state_check
							; modifiers not being pressed to be turned off
state_check:

	lodsw						; get flags for bits to clr (real and opposite bits)
	mov	bx,ax					; get a copy in bx

	lodsw						; get second word off table (opposite scan code)
	mov	di,ax					; save a copy in di

	lodsw						; get third word off table, correct scan code, stored in AX for later use
	and	bl,dl
	jnz	clear_flag				; no, get next set of flags
	jmp	check_loop

clear_flag:

; If we cont. here, then we found the modifier key which needs to have it's flag in BIOS reset, so we either
; "twiggle" the appropriate bit(s) or if _finject_keys is true, we can inject the scan code(s) back into the hardware buffer

	cmp	_finject_keys,true			; can we inject keys
	je	clear_scancode				; if not, check which vector compute we are 

;;	cmp	_comp_id,6				; do we have a PS/2 Model 25/30-86 ?
;;	je	clear_flag_3				; if yes, then goofy PS/2 Model 25/30-86 and we toggle bits for StickeyKeys

	cmp	_vector,15h				; are we on a computer supporting int 15 ?
	je	clear_scancode				; if we can, jump here

;-------------------------------------------------------------------------------------------------------------------------
; This area of code runs for int 9h computers and must access the BIOS flags to undo StickeyKeys
; latch and lock states.  This is very similar to how Trace program 1-finger operates

clear_flag_3:

; We must first check where we are in the SetShiftTable
	cmp	cx,2					; are we at the right ctrl or alt ?
	jg	clear_flag_3A				; no we have cx = 3...6, so we have l/r shift, lctrl or lalt
	shr	bl,1					; yes, cx=1 or 2, so we must adjust bit flag on these only(divide by 4)
	shr	bl,1					; bl was "20 or 10, and is now 08 or 04"

clear_flag_3A:

	not	bl					; clear the intended flag bit
	and	es:kb_flag,bl				; 

	cmp	cx,4					; if lshift or rshift, don't bother kb_flag_1/3
	jle	clear_flag_5

	cmp	flock,true				; are we unlocking ??
	je	clear_flag_4				; no, and it was a shift key, so out
	jmp	check_loop

clear_flag_4:

	not	bh					; yes we are unlocking, so get other shift key
	and	es:kb_flag,bh
	jmp	check_loop

clear_flag_5:

	cmp	comp_flag,true				; do we have BIOS support of kb_flag_1/3 ?
	je	clear_flag_7
	jmp	check_loop				; if not, quit at this point

clear_flag_7:
; must determine where we are in the SetShiftTable again

	cmp	cx,2					; are we at the right ctrl or alt ?
	jle	clear_flag_10
	not	bh
	and	es:kb_flag_1,ah

	cmp	flock,true				; are we unlocking ???
;	jne	check_loop				; no
	je	clear_flag_8				; 
	jmp	check_loop

clear_flag_8:

	and	es:kb_flag_3,bl
	jmp	check_loop


clear_flag_10:

	not	bh
	and	es:kb_flag_3,bh

	cmp	flock,true				; are we unlocking ???
	jne	check_loop				; no
	shr	bl,1					; yes, cx=1 or 2, so we must adjust bit flag on these only(divide by 4)
	shr	bl,1					; bl was "08 or 04, and is now 02 or 01"
	and	es:kb_flag_1,bl
	jmp	check_loop

;-----------------------------------------------------------------------------------------------------
; This area of code runs on computers which can either hardware inject scan codes into the keyboard and mouse
; buffers or can use int 15h to inject scan codes when called from int 9h.  Both method of 
; scab code injection are new to DOS programs written at Trace.
;
; cx = count into the SetShiftTable that we found the necessary modifier at 
;
clear_scancode:

	mov	fkeys_injected,true			; if it is a lock reset, then we need to set this flag

clear_scan_10:
; AX has the scan code to be injected for the modifier found to match the flag bit

	cmp	ah,0					; was there a hidden code ?
	je	clear_scan_25				; if ah = 0, then there wasn't any hidden code
	xchg	al,ah					; put ah into al prior to call

	call	Put_Key_Data				; put the scan code for the key into the buffer
	xchg	al,ah					; restore al

clear_scan_25:
	or	al,break_bit				; make it a break scan code for whatever
	call	Put_Key_Data				; put the scan code for the key into the buffer

	cmp	flock,true				; is this an unlock, then we must get the opposite modifier
	jne	check_loop				; if not, then loop to next key

; while in this loop, one computer type, AT 239, which supports int 15h, but uses an 84 key keyboard
; so comp_flag will be false since there in no right control or alternate keys.  We need to watch for this.

	cmp	comp_flag,true				; if true, we are okay
	je	clear_scan_35
	cmp	cx,4					; if not true, are we doing shift keys ? or ctrl or alt. keys ?
	jle	clear_scan_40				; if cx=4 or less, we are in the ctrl or alt. keys, and 
							; the AT 239 doesn't have any right ctrl/alt. so jump

clear_scan_35:

	cmp	fopp_mod_sent,true			; flag so we only sent one opposite modifier key
	je	clear_scan_40				; if true, we already sent the opposite modifier, so go to loop
	mov	fopp_mod_sent,true			; flag ourselves once through this inner loop
	mov	ax,di					; DI register has opposite modifier key from above

	jmp	clear_scan_10				; repeat same inner loop for opposite modifier

clear_scan_40:
	mov	fopp_mod_sent,false
check_loop:
	loop	check_loop_15
	jmp	short set_shift_states_end		; if cx =0, quit

check_loop_15:
	jmp	state_check

set_shift_states_end:

	mov	flock,false  				; reset to clear the condition flags
	mov	flatch,false

set_shift_states_end_5:

	pop	si
	pop	di
	pop	dx
	pop	es

	assume	ES:NOTHING

	pop	cx
	pop	bx
	pop	ax

	ret

set_shift_states	endp

;----------------------------------------------------------------------------
; SticKeys
;
;   This is the beginning of the routine for 1-finger operation of the
; keyboard.  It expects the raw scan code to be in AX where AH holds E0, E1 
; or nothing, and AL is the scan code.
;-----------------------------------------------------------------------------

stickeys_begin:

	push	bx
	assume	ES:NOTHING
	mov	bx, RAMBIOS				; BIOS RAM segment at 40h
	mov	es,bx					;  .. point ES to that!
	assume	ES:RAMBIOS
	pop	bx

	assume	DS:_TEXT

	mov	key_to_pass,ax				; save current key
	mov	dh,real_states
	mov	dl,prev_real_states
	mov	prev_real_states,dh			; update previous
	mov	ah,current_shift			; get bit flag of shift

	or	ah,ah					; a modifier key (ie. shift, ctrl, or alt)?	
	jnz	sk_010					; yes, a modifier key 
	jmp	ns_010					; non-shift key or fake shift keys

;----------------------------------------------------------------------------
;			s h i f t   k e y   r o u t i n e
;
; assumes 
;	al = scan code
;	ah = shift flag
;	dl = previous real states
;	dh = real states
;
; filter the shift key.  If E1 precedes shift, then it is always a fake shift.
; If E0 precedes shift and it is a left or right shift, then it is a fake 
; shift.  Fake shifts just get passed on.
;

sk_010: 

;
; We don't want the typematic make of shift to cause it to be turned
; on so we will only count number of breaks.  We also don't want typematic
; of shift make to change hold/lock state of stickeys so we will only pass
; on the first make of a shift through stickeys, and pass all typematic of
; shift key on through to mousekeys.
;
; added another test to check for two shift breaks in a row, as this is the
; check to prevent co-activation of StickeyKeys when connected to the T-TAM.
;

	test	al,break_bit				; a break?
	jnz	sk_020					; yes, check if manual on off
	mov	shift_break_cnt,0			; re-zero count if not a break
	test	dl,ah					; was it previously set?
	jz	sk_040					; no, is first make of shift
	jmp	pass_on					; not first make so just pass on

;----------------------------------------------------------------------------
; check if manually turned on or off by five shift keys in a row
;
sk_020:

	mov	cl,shift_break_cnt			; get current number of successive shift break counted
	inc	cl					; increment it
	mov	shift_break_cnt,cl			; keep track of current count
	cmp	cl,2					; have we had two breaks in a row without a make?
	jne	sk_040					; no, jump around

	cmp	fSticKeysOn,true			; are we on ???
	jne	sk_035					; if no, and if we get more than 1 shift key break in a row, reset
							; since this is a trap for the T-TAM
; if we are on,and get mutiple shift break keys in a row, check if the computer supports scan code injection, then this is okay

	cmp	_vector,15h				; can we inject or buffer ?
	jne	sk_035					; if not, something is wrong, so do our usual clean up
	dec	key_cnt					; if everything is okay, we need to reset key_cnt back by two 
	dec	key_cnt					; (we got two extra shift breaks from a unlock condition)
	cmp	key_cnt,0				; one final check to be sure key_cnt didn't go negative
	jge	sk_040					; if key_cnt >= to 0, cont. else re-zero in next line
							

sk_035:
	mov	key_cnt,0				; yes, re-zero on/off key count
	mov	shift_break_cnt,0			; re-zero count 

sk_040:
	mov	cl,key_cnt				; increment key cnt
	test	ah,fShift				; is shift an on/off shift?
	jz	sk_090					; neither on or off shift -->
	inc	cl
	cmp	cl,10					; have we reached 10 decimal
	jl	sk_100					; no -->
	test	al,break_bit				; a break?
	jz	sk_100					; no, simply update
	cmp	fSticKeysOn,true			; is it currently on?
	jne	sk_060					; no, then turn on -->
	call	sk_turn_off_fb				; yes, so turn off
	jmp	pass_on
sk_060:							; turn on
	call	sk_turn_on_fb
	jmp	pass_on					; pass on -->
sk_090:
	xor	cx,cx					; clear key_cnt

;---------------------------------------------------------------------------
; was not turned on or off just now
;
sk_100: 
	mov	key_cnt,cl				; save on/off shift count
sk_105:
	cmp	fSticKeysOn,true			; are we on?
	je	sk_110					; yes -->
	jmp	pass_on					; no, just pass on -->

;----------------------------------------------------------------------------
; process a filtered shift key.
; 
sk_110:

	mov	cx,flgs					; ch = lock_flg, cl = shift_flg
	test	al,break_bit				; break of shift flag?
	jz	sk_200					; no, process make shift key -->

;----------------------------------------------------------------------------
; process the BREAK of a shift (modifier) key
;
; There are no modifier break codes of E0AA and E0B6....These are fake modifiers with these codes
; but they should be passed as non-shift keys to ns_010, and not pass thru here.
;
;;	cmp	ax,0E0AAh				; do we have a fake shift break ?
;;	je	sk_115					; yes, just pass it on
;;	cmp	ax,0E0B6h				; do we have a fake shift break ?
;;	je	sk_115	

	or	ch,cl					; ch=locked or shifted
	test	ch,ah					; either lock or shift set?
	jnz	sk_eoi					; yes, don't pass on

sk_115:

	jmp	pass_on
sk_eoi: 
	and	es:kb_flag_3,0fch			; clear the "e0" and "e1" bits
	jmp	SticKeys_end				; end


;----------------------------------------------------------------------------
; process the MAKE of a shift (modifier) key.  check for two shift (modifier) keys down
;
sk_200: 
	cmp	dh,ah					; is another shift key down?
	je	sk_300					; no, go on -->
	mov	ftwo_down,true				; we have two keys down together
	call	two_keys_down
	cmp	fSticKeysOn,true			; are we still on? after the two_keys_down proc.
	je	sk_300					; yes, then cont. as normal
	jmp	pass_on					; no, StickeyKeys got shut off, so pass on this second modifier
							; key which is down, and the first modifier key down will
							; get passed around StickeyKeys since it will be off 

;----------------------------------------------------------------------------
; process tri-state or bi-state shift (modifier) key states 

sk_300: 
;	cmp	fjust_unlocked,false			; are weawaiting a break ?
;	je	sk_305					; if not, continue on
;	jmp	SticKeys_end				; if yes, eat present modifier key
;sk_305:

	mov	bx,fShift_word				; check for left/right shift exception
	test	ah,bl					; is current key a shift?
	jnz	sk_310					; yes, --> check for locked
	mov	bx,fCtrl_word				; check for left/right ctl exception
	test	ah,bl					; is current key a ctl?
	jnz	sk_310					; yes, --> check for locked
	mov	bx,fAlt_word				; check for left/right alt exception
sk_310: 
	test	ch,bl					; is either left or right locked?
	jz	sk_320					; no -->
	not	bx					; yes, release the keys
	and	cx,bx					; clear lock and shifts
	mov	flock,true
;	mov	fjust_unlocked,true			; flag ourselves that we just unlocked, so we don't latch 
;							; or start another lock until we see a break code
	call	set_shift_states			; set the states
	jmp	short sk_340				; continue with feedback -->
sk_320: 
	mov	bx,cx	     				; get a copy in bx
	or	bl,bh					; bl= shift or lock previously set
	test	ch,ah					; was lock previously set?
	jnz	sk_330					; yes, don't toggle shift -->
	xor	cl,ah					; no, then toggle shift
sk_330: 
	cmp	fTriState,true				; are we doing tri-state shifts?
	jne	sk_340					; no -->
	test	bl,ah					; was shift or lock prevously set?
	jz	sk_340					; no, don't toggle lock -->
	xor	ch,ah					; yes, then toggle lock
sk_340: 
	mov	flgs,cx					; save lock and shift states
;----------------------------------------------------------------------------
; the following routines provide the sound feedback.
; sound feedback, expects ch=lock states cl=shift states ah=flag

fb_010: 
	cmp	fAudible_Feedback,true			; do they want feedback?
	jne	sk_400					; no -->

	test	ch,ah					; are we in lock state?
	jnz	fb_020					; yes, just give high tone
	call	beep_low
	cmp	fswitching_video,false
	jne	fb_020
	mov	faccess_sound,true
	mov	fsecond_cue,9
fb_020: 
	test	ch,ah					; was there a lock?
	jnz	fb_030					; yes -->
	test	cl,ah					; was there a shift?
	jz	fb_end					; no
fb_030:
	call	beep_high
	cmp	fswitching_video,false
	jne	fb_end
	mov	faccess_sound,true
	mov	fsecond_cue,7
fb_end: 

;----------------------------------------------------------------------------
; determine if need to send on this modifier  key

sk_400: 
	test	ch,ah					; are we in lock state?
	jnz	sk_410					; yes, just give high tone
	cmp	fswitching_video,false
	jne	sk_410
	mov	faccess_sound,true
	mov	fsecond_cue,9
sk_410:

	test	ch,ah					; was there a lock?
	jnz	sk_415					; yes -->
	test	cl,ah					; was there a shift?
	jz	sk_420					; no
sk_415:
	cmp	fswitching_video,false
	jne	sk_420
	mov	faccess_sound,true
	mov	fsecond_cue,7

sk_420:
	test	cl,ah					; is the shift flag set?
	jnz	sk_pass_on				; yes, pass on -->
	and	es:kb_flag_3,0fch			; clear the "e0" and "e1" bits
	jmp	SticKeys_end				; no, inhibit -->
sk_pass_on: 
	jmp	pass_on					; -->

;----------------------------------------------------------------------------
;		non modifier keys (NOT a shift, alternate or control)
;
;		n o n - s h i f t   k e y
;
; assumes dh=real_states, al=scan code 
;
; current key is a non-shift or a fake shift.  Treat fake shifts like 
; non-shift keys since they are always followed by a non-shift down, so we
; want to set the real states before these fake shift keys get sent.
; check for two keys pressed.

ns_010:
	mov	key_cnt,0				; reset on/off key count
	cmp	fSticKeysOn,false			; are we off?
	je	pass_on					; yes, pass on -->
	or	dh,dh					; is a shift key down?
	jz	pass_on_non_shift			; no  --> pass_on_non_shift
	mov	ftwo_down,true				; we have two keys down together
	call	two_keys_down				; take care of two key down case

;----------------------------------------------------------------------------
; if we get here, then we have a modifier key and a non-modifier key down together
; pass scan code one to next routine and clear flags if NOT locked.

pass_on_non_shift:

	mov	ax,key_to_pass

; Assumes MouseKeys saves nothing on return

	cmp	fSticKeysOn,true			; did two_keys_down shut us off ?
	jne	pass_on					; if yes, quit

	cmp	fstickeys_click,false			; do a click in StickeyKeys ?
	je	ns_100					; if not, we don't need to check any further

; if we are going to click, be sure we don't have Filterkeys on and that it
; already did a click.  FIlterKeys will do a click if click is enabled, and there is an 
; acceptance delay.  We need to check if there is an acceptance delay first, as we would
; never StickeyKeys click for that, or we would hear alot of clicking, without any keys.

	cmp	fFilterKeysOn,true
	jne	ns_80					; if FilterKeys is off, safe to do StickeyKeys click
							; if FilterKeys is On, if we have an acceotance delay,
							; do not do a click here, as we would get multiple clicks
	cmp	on_wait_ticks,0				; if there is an acceptance delay, do not click in StickeyKeys
	jne	ns_100

ns_80:
	call	click					; StickeyKeys click
ns_100:

	call	MouseKeys

	mov	ax,key_to_pass
	cmp	ax,0e02ah	
	je	short SticKeys_end			; don't reset if fake shift
	cmp	ax,0e036h	
	je	short SticKeys_end			; don't reset if fake shift
ns_150:
	cmp	shift_flg,0				; was any key StickeyKeyed ?
	je	SticKeys_end				; if not, end
							; if yes, set latch flag and reset modifier(s)

  	mov	flatch,true				; set flag so we know what kind of flag clearing to do

	cmp	fkey_not_passed,true			; this will only occur on int 9, FilterKeysOn 
	jne	ns_160					; if not set, cont. as normal
	jmp	short SticKeys_end			; if set, don't reset flags as yet

ns_160:

	call	set_shift_states			; clear latched key(s) states
	mov	shift_flg,0				; clear shifted states
	jmp	short SticKeys_end

;----------------------------------------------------------------------------
; just pass on current key to next routine

pass_on:

	mov	ax,key_to_pass

; Assumes MouseKeys saves nothing on return

	call	MouseKeys

SticKeys_end:

	ret

SticKeys	endp

_TEXT	ends

	end	








=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\toggle.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center (just kidding)		*
;									*
;	TOGGLE.ASM							*
;									*
;************************************************************************

TITLE	ToggleKeys

INCLUDE	keyboard.inc

	PUBLIC	ToggleKeys				; in ToggleKeys.asm
	PUBLIC	ToggleKeys_timer
	PUBLIC	ToggleKeys_TurnOff
	PUBLIC	ToggleKeys_dialog

	EXTRN	pass_to_computer:PROC			; in Handicap.asm
	EXTRN	beep_high:PROC
	EXTRN	beep_low:PROC
	EXTRN	beep_turn_on:PROC
	EXTRN	beep_turn_off:PROC
	EXTRN	fpause_being_sent:byte
	EXTRN	fsecond_cue:byte
;
; Does not make any sense to give a visual que for ToggleKeys since ToggleKeys is
; intended to provide audible feedback for people with a visual disability.  They 
; would not be able to see the visual que anyway.....However, onthe PC/XT keyboard
; and on the SpaceSaver kybd, the LED's do not exist, and if the operator may want 
; a visual que from ToggleKeys and not the sound que, for any program, so we will
; turn it on here like any where else

	EXTRN	fswitching_video:byte
	EXTRN	faccess_sound:byte

	EXTRN	TimeOut_timer:PROC			; in TimeOut.asm
	EXTRN	TimeOut_Reset:PROC


	EXTRN	fToggleKeysOn:byte			; from Param.asm
	EXTRN	fTK_On_Off_Feedback:byte
	EXTRN	fDialog_Toggle_off:byte
;;	EXTRN	fspace_saver:byte

IFDEF	BUG

	EXTRN	portid:byte
	EXTRN	portout:byte
	EXTRN	HexCharsOut:PROC

ENDIF; BUG

;---------------------------------------------------------------------------

_TEXT	segment	word public 'CODE'

	assume CS:_TEXT
	assume DS:NOTHING
	assume ES:NOTHING
	assume SS:NOTHING

;----------------------------------------------------------------------------
;			R E S I D E N T   D A T A   A R E A
;
;  The below area defines the resident data area.

tk_hot_key_only?	DB	false		; only hot key is down
tk_toggle_count		DW	reset_cnt	; holds count for toggle time
tk_on_flag		DB	false		; internal flag used to avoid ToggleBeep on key repeats


;----------------------------------------------------------------------------

ToggleKeys	proc	

	assume	DS:_TEXT

	jmp	toggle_begin

;----------------------------------------------------------------------------
; ToggleKeys_timer 
;
; Increments the counts used in the turn on and off of ToggleKeys.  
;

ToggleKeys_timer	proc

	assume	DS:_TEXT

;----------------------------------------------------------------------------
; first check to see if we are manually being turned off or on.  To toggle 
; it on or off, we have it set so that the person must hold down the 
; Num Lock key for about five seconds.

	cmp	tk_hot_key_only?,true		; hot key only down?
	jne	tk_start_cnt_over		; no -->
	mov	ax,tk_toggle_count		; get current count
	cmp	ax,0				; are we at toggle ammount = 0?
	je	tk_toggle_on_off_flag		; yes -->
	jl	ToggleKeys_timer_end		; less than, so already done
	dec	tk_toggle_count			; decrement count
	jmp	ToggleKeys_timer_end

tk_toggle_on_off_flag:

	dec	tk_toggle_count			; set to -1 so must release first
	cmp	fToggleKeysOn,false		; are we off?
	je	tk_turn_toggle_on		; yes -->
	call	tk_turn_off_fb
	jmp	ToggleKeys_timer_end

tk_turn_toggle_on:

	call	tk_turn_on_fb
	jmp	ToggleKeys_timer_end

tk_start_cnt_over:

	mov	tk_toggle_count,tk_reset_cnt

ToggleKeys_timer_end:

	call	TimeOut_timer			; service TimeOut 

	ret
ToggleKeys_timer	endp

;-----------------------------------------------------------------------------
; the following routines provide the turn on/off and sound feedback.

tk_turn_on_fb	proc

	assume	DS:_TEXT

	cmp	fTK_On_Off_Feedback,false
	je	ToggleKeys_TurnOn
	call	beep_turn_on
ToggleKeys_TurnOn:
	cmp	fswitching_video,false
	jne	ToggleKeys_TurnOn_5
	mov	faccess_sound,true
	mov	fsecond_cue,24

ToggleKeys_TurnOn_5:

	mov	fToggleKeysOn,true		; turn on
	mov	tk_on_flag,true		       	; set to flag first toggle key make
	call	TimeOut_Reset
	ret
tk_turn_on_fb	endp


tk_turn_off_fb	proc
	cmp	fTK_On_Off_Feedback,false
	je	ToggleKeys_TurnOff
	call	beep_turn_off
ToggleKeys_TurnOff:

	cmp	fswitching_video,false
	jne	ToggleKeys_TurnOff_5
	mov	faccess_sound,true
	mov	fsecond_cue,25

ToggleKeys_TurnOff_5:

	mov	fToggleKeysOn,false		; turn off
	ret
tk_turn_off_fb	endp


;----------------------------------------------------------------------------
; Toggle_dialog 
;
;	Checks a single flag from Dialog box to see if ToggleKeys was turned
; on/off.  If it was, this routine makes a call to ToggleKeys_TurnOn/Off so the realstates
; can be updated to match the computer.  Upon exit the flag that was set by 
; Dialog box is cleared.(returned to false)


ToggleKeys_dialog	proc	

	assume	DS:_TEXT

	cmp	fToggleKeysOn,true			; was Stickeys turned on
	jne	Td_25
	call	ToggleKeys_TurnOn_5	  		; yes it was true, so turn on
	jmp	short Td_50

Td_25:
	call	ToggleKeys_TurnOff_5			; fToggleKEysOn was false, so turn off
Td_50:
	mov	fDialog_Toggle_off,false  		; reset flag to false
	ret

ToggleKeys_dialog	endp

;----------------------------------------------------------------------------
; ToggleBeep
;
;   This routine provides audible feedback to indicate if the lights for the
;   toggle keys got turned off or on.  If more than one light changes per
;   call, then we do not do any beeps since the program most likely changed
;   them and we would just add confusion to the situation.
;
; Expects:	ah = state of lights before changes
;
; Returns:	Nothing
;
; Uses:		ax,bx,es
;

ToggleBeep	proc	

	assume	DS:_TEXT

	push	ax
	push	bx
	push	es
	assume	ES:NOTHING
	mov	bx, RAMBIOS				; BIOS RAM segment at 40h
	mov	es,bx					;  .. point ES to that!
	assume	ES:RAMBIOS
	mov	tk_on_flag,true				; set to flag first toggle key make

	cmp	fToggleKeysOn,true
	jne	ToggleBeep_ret

	mov	al,es:[kb_flag]

	and	al,fCaps + fScroll + fNum

	and	ah,al					; turned on? assume only one changes
	jnz	tb_10					; no -->
	call	beep_high
	cmp	fswitching_video,false
	jne	ToggleBeep_ret
	mov	faccess_sound,true
	mov	fsecond_cue,7
	jmp	short ToggleBeep_ret
tb_10:
	call	beep_low
	cmp	fswitching_video,false
	jne	ToggleBeep_ret
	mov	faccess_sound,true
	mov	fsecond_cue,9
ToggleBeep_ret:

	pop	es
	assume ES:NOTHING
	pop	bx
	pop	ax

	ret
ToggleBeep	endp

;----------------------------------------------------------------------------
; ToggleKeys
;
; The ToggleKeys routine provide audible feedback or response for designated keys which can be toggled
; On or Off at the keyboard.  Typically, this includes the CAPS LCOK, NUM LOCK, and the SCROLL LOCK
; keys but could also include the cursor pad INSERT key.  When ToggleKeys is On, toggling one of the 
; above three keys on will produce a high beep while toggling that same key Off, produces a low beep.
;
;   It expects the extended scan code to be in AX.
;

toggle_begin:

;----------------------------------------------------------------------------
; first thing to do is to check for the Num Lock key to determine if the
; ToggleKeys features is being manually turned on or off.
;

	mov	bx,ax					; save copy in bx

	cmp	fpause_being_sent,true			; is PAUSE key being sent ??
	jne	togg_15					; if not a PAUSE, cont on as normal	
	cmp	ax,0C5h	 				; did we get the pause break finally ?
	jne	togg_10
	mov	fpause_being_sent,false			; if yes, reset the pause flag

togg_10:
	jmp     tk_send_key

togg_15:

	and	al,not break_bit			; get make scan code in al

	test	fToggleKeysOn,true			; is togglekeys on?
	jz	donot_toggle				; no
	cmp	al,NumLock				; is it the num lock key?
	je	toggle_check
	cmp	al,CapsLock				; is it a caps lock ?
	je	toggle_check
	cmp	al,ScrollLock				; is it a scroll lock ?
	jne	donot_toggle

toggle_check:

	test	bl,break_bit				; is it a break?
	jnz	donot_toggle				; do not do togglebeep on a break

num_check:
	cmp	al,NumLock				; is it the num lock key?
	jne	caps_check

;NOTE: We are messing up ah without saving!!!!

	mov	ah,fNum					; get numlock mask
	jmp	toggle
caps_check:

	cmp	al,CapsLock				; is it a caps lock ?
	jne	scrol_check
	mov	ah,fCaps
	jmp	toggle

scrol_check:

	cmp	al,ScrollLock				; is it a scroll lock ?
	jne	donot_toggle
	mov	ah,fScroll

toggle:
	test	tk_on_flag,true		
	jnz	on_off_toggle				; make key repeating

	call	ToggleBeep				; if was on, and wasn't a break

	jmp	on_off_toggle

donot_toggle:

	mov	tk_on_flag,false			; clear on the breaks

on_off_toggle:

	cmp	al,NumLock				; is it the num lock key?
;;	je	on_off_toggle_20			; was a num lock, so check if make/break for hot key
;;
;;	cmp	fspace_saver,true			; check to be sure we don't have a space saver keyboard ?
	jne	tk_clear_hot_key			; not a space saver keyboard either, so exit hot_key

;;	push	bx
;;	push	es
;;	push	ax
;;	assume	ES:NOTHING
;;	mov	bx, RAMBIOS				; BIOS RAM segment at 40h
;;	mov	es,bx					;  .. point ES to that!
;;	assume	ES:RAMBIOS
;;	mov	al,es:[kb_flag]
;;	test	al,03					; any shift keys down ?
;;	jz	on_off_toggle_15			; if not, don't bother checking for shift + scroll lock
;;	pop	ax
;;
;;IFDEF	BUG
;;	mov	portid,0b0h
;;	mov	portout,al
;;	call	HexCharsOut
;;ENDIF;	BUG
;;
;;	cmp	al,ScrollLock				; is this shift+scroll lock ?
;;	jne	on_off_toggle_16
;;	pop	es					; is shift+scroll lock w/space saver, so cont. at hot_key
;;	assume ES:NOTHING
;;	pop	bx
;;	call	beep_high				; DEBUGGING
;;	jmp	short on_off_toggle_20
;;
;;on_off_toggle_15:
;;	call	beep_low				; DEBUGGING
;;	pop	ax
;;
;;on_off_toggle_16:
;;
;;	pop	es
;;	assume ES:NOTHING
;;	pop	bx
;;	jmp	short tk_clear_hot_key			; not a shift+scrol lock by space saver
;;
;;on_off_toggle_20:

	test	bl,break_bit				; is it a break?
	jnz	tk_clear_hot_key			; yes, ignore -->
	mov	tk_hot_key_only?,true			; no, then set tk_hot_key_only to true
	jmp	tk_send_key				;
tk_clear_hot_key:

	mov	tk_hot_key_only?,false			;

tk_send_key:

	mov	ax,bx					; restore extended scan
;
; Doesn't assume any registers saved
;

	call	pass_to_computer			;

ToggleKeys_ret:

	ret
ToggleKeys	endp

_TEXT	ends

	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\skdefs.h ===
/*******************/
/*   skdefs.h     */
/*******************/


/*#define DEBUG			1*/


/* define this when linking with other code i.e. Front-End and Keyboard Enhancements */

#define ALL_LINK 1

/*	defines for operating system  */

#define parPort 0x3BC
#define OS_DOS			1
#define OS_WINDOWS	2
#define OS_TTAM		3

#define TARGET OS_DOS
#if !defined (FRONT)

/* GENERAL TYPEDEF's and DEFINES    */

typedef unsigned char BOOL;
typedef unsigned char BYTE;
typedef unsigned int  WORD;


#define	TRUE 	1
#define	FALSE	0

#define NEAR	near
#define LONG	long
#define VOID	void
#define true	TRUE
#define false	FALSE

#define notOKstatus 0
#define okStatus 1



/*	ASCII DEFINITIONS	*/

#define NULLCHAR		0
#define TAB				9
#define LINEFEED		10
#define VERTICALTAB	11
#define FORMFEED		12
#define RETURN			13
#define SPACE			32
#define COMMA			44
#define PERIOD			46
#define ESC				27
#define ESCAPE			27
#define XON				17
#define XOFF			19

/* INTERNAL VARIABLE SIZE SPECIFICATIONS  */

#define MAXALIASLEN		20

#define CODEBUFFERLEN	20

#define COMMBUFLEN		32
#define DEACTHANDSHAKE	24
#define ACTHANDSHAKE		6

#define OUTPUTBUFLEN		64

#define MAXPOINTERSTACK	20
#define MAXLISTLEN		5

#define TIMERTIMEOUT 2
#define INT9TIMEOUT	55
#define HANDSHAKETIMEOUT 95	/* a little more than 5 seconds */

/*	STRUCTURE DEFINITIONS  */

struct serialDataType {
	BYTE serChar, status;
	};

struct asciiTableType {
	BYTE code1, code2;
	};

struct aliasTableType {
	char *aliasName;
	BYTE gideiCode;
	};

struct listType {
	BYTE len;
	BYTE list[MAXLISTLEN];
	};

#define MOUSEID 3
#define KEYBDID 2

typedef struct {
	unsigned int status;
	int deltaX;
	int deltaY;
	} mouDataType;

typedef struct {
	BYTE id;
	union {
		BYTE scanCode;
		mouDataType mou;
		};
	} outBufferType;

struct kStateType {			/* 1=currently pressed, 0 = not pressed */
	unsigned rShift:	1;
	unsigned lShift:	1;
	unsigned rCtrl:	1;
	unsigned lCtrl:	1;
	unsigned rAlt:		1;
	unsigned lAlt:		1;
	unsigned numlck:	1;
	};

struct scanCodeType {
	BYTE ascii, scan;
	};

struct scanTblType {
	struct scanCodeType base;
	struct scanCodeType shift;
	struct scanCodeType ctrl;
	struct scanCodeType alt;
	};

typedef void (*functionPtrType)(); 	/*  functionPtr type is pointer to a*/
									/*  function that returns nothing */

struct stackType {
	struct aliasTableType *aliasTablePtr;	/*  pointer to alias table	*/
	functionPtrType commandRoutinePtr;	/*  pointer to command|vector| routine */
	};

#endif

/* SERIAL PORT DEFINITIONS    */

#if TARGET==OS_DOS 
	#define		BAUD300	 0x0180
	#define		BAUD600	 0x00C0
	#define		BAUD1200	 0x0060
	#define		BAUD2400	 0x0030
	#define		BAUD4800	 0x0018
	#define		BAUD9600	 0x000C
	#define		BAUD19200 0x0006

/*	#define		COM1		0x3F8
	#define		COM2		0x2F8
	#define		COM3		0x3E8
	#define		COM4 		0x2E8
*/
	#define		IRQ4		4
	#define		IRQ3		3

	#define		RBR 0x00		/* DLAB = 0 read	*/
	#define		THR 0x00		/* DLAB = 0 write	*/
	#define		DLL 0x00		/* DLAB = 1	*/

	#define		IER 0x01		/* DLAB = 0	*/
	#define		DLM 0x01		/* DLAB = 1	*/

	#define		FCR 0x02		/*  FIFO Control Register (some IBM machines)	*/
	#define		IIR 0x02		/*  Interrupt Identification Register */
	#define		LCR 0x03
	#define		MCR 0x04
	#define		LSR 0x05		/* Line Status Register */

	#define		DR_FLAG 0x1
	#define		OR_FLAG 0x2
	#define		PE_FLAG 0x4
	#define		FE_FLAG 0x8
	#define		BI_FLAG 0x10
	#define		THRE_FLAG 0x20
	#define		TSRE_FLAG 0x40

#define		INT_RCV 	0x1
#define		INT_THRE	0x2
#define		INT_RLS	0x4

#define		RTS_BIT 0x2
#define		DTR_BIT 0x1

#endif

#if !defined (FRONT)

/* Mouse Definitions */

#define LEFTBUTTONMASK  1
#define RIGHTBUTTONMASK	2
#define NOMOUSE		0
#define BUSMOUSE		1
#define SERIALMOUSE	2
#define INPORTMOUSE	3
#define PS2MOUSE		4
#define HPMOUSE		5

#define ignoreCode			0
#define INSERT_MODE_MASK	0x80
#define CAPS_MODE_MASK		0x40
#define NUM_MODE_MASK		0x20
#define SCROLL_MODE_MASK	0x10
#define ALT_DOWN_MASK		0x08
#define CTRL_DOWN_MASK		0x04
#define LSHIFT_DOWN_MASK	0x02
#define RSHIFT_DOWN_MASK	0x01

#define INSERT_DOWN_MASK	0x80
#define CAPS_DOWN_MASK		0x40
#define NUM_DOWN_MASK		0x20
#define SCROLL_DOWN_MASK	0x10
#define PAUSE_MODE_MASK		0x08
#define SYSREQ_DOWN_MASK	0x04
#define LALT_DOWN_MASK		0x02
#define LCTRL_DOWN_MASK		0x01

#define EXTEND_KBD_MASK		0x10
#define RALT_DOWN_MASK		0x08
#define RCTRL_DOWN_MASK		0x04
#define LAST_CODE_E0_MASK	0x02
#define LAST_CODE_E1_MASK	0x01

#endif

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\vars.c ===
/*  VARS.C  */


#include "skdefs.h"
#include "gideidef.h"

/*	SERIAL PORT VARIABLES  */


#if !defined ALL_LINK
	unsigned int skCommPortAddr = COM1;
	unsinged int combase = COM2;
	BYTE fmouse_id = SERIALMOUSE;
	unsigned int skBaudRate = BAUD300;
	unsigned char skCommIRQ = IRQ4;
	BYTE vector = 0x15;
	BYTE comp_id = 8;				/* 6 for model 30 */
	BYTE finject_keys = TRUE;
	BYTE serialKeysOn = TRUE;
#endif

/*	LOOKUP TABLES	*/

struct aliasTableType nullTable[] = {
	{ "",		0	},
};


struct aliasTableType gideiAliasTable[] = {
	{ "BEGIN",	   BEGINCODE},
	{ "BLKTRNS",	BLKTRANSCODE},
	{ "CLEAR",		CLEARCODE},
	{ "END", 		ENDCODE},
	{ "",				NOCODE},
};


struct aliasTableType commandsAliasTable[] = {
	{ "baudrate",	BAUDRATECODE},
	{ "click",		MOUCLICKCODE},
	{ "combine",	KBDCOMBINECODE},
	{ "comm",		COMMCODE},
	{ "dblclick",	MOUDOUBLECLICKCODE},
	{ "gen",			GENCODE},
	{ "goto",		MOUGOTOCODE},
	{ "hold",		KBDHOLDCODE},
	{ "kbd",			KBDEXPANSIONCODE},
	{ "lock",		KBDLOCKCODE},
	{ "mou",			MOUEXPANSIONCODE},
	{ "moulock", 	MOULOCKCODE},
	{ "mourel",		MOURELCODE},
	{ "moureset",	MOURESETCODE},
	{ "move",		MOUMOVECODE},
	{ "press",		KBDPRESSCODE},
	{ "rel",			KBDRELCODE},
	{ "",				NOCODE},
};

struct aliasTableType kbdAliasTable[] = {
	{ "desc",		KBDDESCRIPTIONCODE},
	{ "ind",			KBDINDICATORCODE},
	{ "model",		KBDMODELCODE},
	{ "ver",			KBDVERSIONCODE},
	{ "",				NOCODE},
};


struct aliasTableType kbdModelAliasTable[] = {
	{ "ibmat",		IBMATCODE},
	{ "ibmenhc",	IBMENHANCEDCODE},					/* IBM 101 key keyboard */
	{ "ibmpc",		IBMPCCODE},							/* IBM original keyboard */
	{ "",				NOCODE},
};


struct aliasTableType kbdDescriptionAliasTable[] = {
	{ "",			NOCODE},
};

struct aliasTableType kbdVersionAliasTable[] = {
	{ "",			NOCODE},
};

struct aliasTableType kbdIndicatorAliasTable[] = {
	{ "",			NOCODE},
};

struct aliasTableType mouseAliasTable[] = {
	{ "",			NOCODE},
};

struct aliasTableType genAliasTable[] = {
	{ "compid",		COMPUTERID},
	{ "user1",		SINGLEUSER},
	{ "",			NOCODE},
};


struct aliasTableType commAliasTable[] = {
	{ "",			NOCODE},
};



struct aliasTableType baudrateAliasTable[] = {
	{ "1200",	BAUD1200CODE},
	{ "19200",	BAUD19200CODE},
	{ "2400",	BAUD2400CODE},
	{ "300",		BAUD300CODE},
	{ "4800",	BAUD4800CODE},
	{ "600",		BAUD600CODE},
	{ "9600",	BAUD9600CODE},
	{ "",			NOCODE},
};

struct aliasTableType mouButtonAliasTable[] = {
	{ "left",	LEFTBUTTONCODE},
	{ "right",	RIGHTBUTTONCODE},
	{ "",			NOCODE},
};



/****************************************************************************

	Table for converting the ASCII characters to the keys that need to be typed
	on the keyboard.

****************************************************************************/

struct asciiTableType asciiTable[] = {
	{ control_key,	two_key,},							/*   0 */
	{ control_key,	a_key,},								/*   1 */
	{ control_key,	b_key,},								/*   2 */
	{ control_key,	c_key,},								/*   3 */
	{ control_key,	d_key,},								/*   4 */
	{ control_key,	e_key,},								/*   5 */
	{ control_key,	f_key,},								/*   6 */
	{ control_key,	g_key,},								/*   7 */
	{ control_key,	h_key,},								/*   8 */
	{ control_key,	i_key,},								/*   9 */
	{ control_key,	j_key,},								/*  10 */
	{ control_key,	k_key,},								/*  11 */
	{ control_key,	l_key,},								/*  12 */
	{ control_key,	m_key,},								/*  13 */
	{ control_key,	n_key,},								/*  14 */
	{ control_key,	o_key,},								/*  15 */
	{ control_key,	p_key,},								/*  16 */
	{ control_key,	q_key,},								/*  17 */
	{ control_key,	r_key,},								/*  18 */
	{ control_key,	s_key,},								/*  19 */
	{ control_key,	t_key,},								/*  20 */
	{ control_key,	u_key,},								/*  21 */
	{ control_key,	v_key,},								/*  22 */
	{ control_key,	w_key,},								/*  23 */
	{ control_key,	x_key,},								/*  24 */
	{ control_key,	y_key,},								/*  25 */
	{ control_key,	z_key,},								/*  26 */
	{ control_key,	lbracket_key,},					/*  27 */
	{ control_key,	bslash_key,},						/*  28 */
	{ control_key,	rbracket_key,},					/*  29 */
	{ control_key,	six_key,},							/*  30 */
	{ control_key,	hyphen_key,},						/*  31 */
	{ space_key,	no_key,},							/*  32 */
	{ shift_key,	one_key,},							/*  33 */
	{ shift_key,	rquote_key,},						/*  34 */
	{ shift_key,	three_key,},						/*  35 */
	{ shift_key,	four_key,},							/*  36 */
	{ shift_key,	five_key,},							/*  37 */
	{ shift_key,	seven_key,},						/*  38 */
	{ rquote_key,	no_key,},							/*  39 */
	{ shift_key,	nine_key,},							/*  40 */
	{ shift_key,	zero_key,},							/*  41 */
	{ shift_key,	eight_key,},						/*  42 */
	{ shift_key,	equal_key,},						/*  43 */
	{ comma_key,	no_key,},							/*  44 */
	{ hyphen_key,	no_key,},							/*  45 */
	{ period_key,	no_key,},							/*  46 */
	{ fslash_key,	no_key,},							/*  47 */
	{ zero_key,		no_key,},							/*  48 */
	{ one_key,		no_key,},							/*  49 */
	{ two_key,		no_key,},							/*  50 */
	{ three_key,	no_key,},							/*  51 */
	{ four_key,		no_key,},							/*  52 */
	{ five_key,		no_key,},							/*  53 */
	{ six_key,		no_key,},							/*  54 */
	{ seven_key,	no_key,},							/*  55 */
	{ eight_key,	no_key,},							/*  56 */
	{ nine_key,		no_key,},							/*  57 */
	{ shift_key,	semicolon_key,},					/*  58 */
	{ semicolon_key,no_key,},							/*  59 */
	{ shift_key,	comma_key,},						/*  60 */
	{ equal_key,	no_key,},							/*  61 */
	{ shift_key,	period_key,},						/*  62 */
	{ shift_key,	fslash_key,},						/*  63 */
	{ shift_key,	two_key,},							/*  64 */
	{ shift_key,	a_key,},								/*  65 */
	{ shift_key,	b_key,},								/*  66 */
	{ shift_key,	c_key,},								/*  67 */
	{ shift_key,	d_key,},								/*  68 */
	{ shift_key,	e_key,},								/*  69 */
	{ shift_key,	f_key,},								/*  70 */
	{ shift_key,	g_key,},								/*  71 */
	{ shift_key,	h_key,},								/*  72 */
	{ shift_key,	i_key,},								/*  73 */
	{ shift_key,	j_key,},								/*  74 */
	{ shift_key,	k_key,},								/*  75 */
	{ shift_key,	l_key,},								/*  76 */
	{ shift_key,	m_key,},								/*  77 */
	{ shift_key,	n_key,},								/*  78 */
	{ shift_key,	o_key,},								/*  79 */
	{ shift_key,	p_key,},								/*  80 */
	{ shift_key,	q_key,},								/*  81 */
	{ shift_key,	r_key,},								/*  82 */
	{ shift_key,	s_key,},								/*  83 */
	{ shift_key,	t_key,},								/*  84 */
	{ shift_key,	u_key,},								/*  85 */
	{ shift_key,	v_key,},								/*  86 */
	{ shift_key,	w_key,},								/*  87 */
	{ shift_key,	x_key,},								/*  88 */
	{ shift_key,	y_key,},								/*  89 */
	{ shift_key,	z_key,},								/*  90 */
	{ lbracket_key,	no_key,},						/*  91 */
	{ bslash_key,	no_key,},							/*  92 */
	{ rbracket_key,	no_key,},						/*  93 */
	{ shift_key,	six_key,},							/*  94 */
	{ shift_key,	hyphen_key,},						/*  95 */
	{ lquote_key,	no_key,},							/*  96 */
	{ a_key,		no_key,},								/*  97 */
	{ b_key,		no_key,},								/*  98 */
	{ c_key,		no_key,},								/*  99 */
	{ d_key,		no_key,},								/* 100 */
	{ e_key,		no_key,},								/* 101 */
	{ f_key,		no_key,},								/* 102 */
	{ g_key,		no_key,},								/* 103 */
	{ h_key,		no_key,},								/* 104 */
	{ i_key,		no_key,},								/* 105 */
	{ j_key,		no_key,},								/* 106 */
	{ k_key,		no_key,},								/* 107 */
	{ l_key,		no_key,},								/* 108 */
	{ m_key,		no_key,},								/* 109 */
	{ n_key,		no_key,},								/* 110 */
	{ o_key,		no_key,},								/* 111 */
	{ p_key,		no_key,},								/* 112 */
	{ q_key,		no_key,},								/* 113 */
	{ r_key,		no_key,},								/* 114 */
	{ s_key,		no_key,},								/* 115 */
	{ t_key,		no_key,},								/* 116 */
	{ u_key,		no_key,},								/* 117 */
	{ v_key,		no_key,},								/* 118 */
	{ w_key,		no_key,},								/* 119 */
	{ x_key,		no_key,},								/* 120 */
	{ y_key,		no_key,},								/* 121 */
	{ z_key,		no_key,},								/* 122 */
	{ shift_key,	lbracket_key,},					/* 123 */
	{ shift_key,	bslash_key,},						/* 124 */
	{ shift_key,	rbracket_key,},					/* 125 */
	{ shift_key,	lquote_key,},						/* 126 */
	{ control_key,	kpperiod_key,},					/* 127 */
};


/****************************************************************************

	Table for converting the ASCII string of the key names into the key
	number.

****************************************************************************/

struct aliasTableType	keyAliasTable[] = {
	{ "alt",		alt_key,},
	{ "backspace",	backspace_key,},
  	{ "bksp",		backspace_key,},
  	{ "break",		pause_key,},
	{ "capslk",		caps_key,},
	{ "capslock",	caps_key,},
	{ "comma",		comma_key,},
	{ "control", 	control_key,},
	{ "ctrl",		control_key,},
	{ "del",		kpperiod_key,},
	{ "delete",		delete_key,},
	{ "divide",		kpfslash_key,},
	{ "down",		down_key,},
	{ "end",		end_key,},
	{ "enter",		return_key,},
	{ "esc",		escape_key,},
	{ "escape",		escape_key,},
	{ "f1",			f1_key,},
	{ "f10",		f10_key,},
	{ "f11",		f11_key,},
	{ "f12",		f12_key,},
	{ "f2",			f2_key,},
	{ "f3",			f3_key,},
	{ "f4",			f4_key,},
	{ "f5",			f5_key,},
	{ "f6",			f6_key,},
	{ "f7",			f7_key,},
	{ "f8",			f8_key,},
	{ "f9",			f9_key,},
	{ "home",		home_key,},
	{ "ins",		kp0_key,},
	{ "insert",		insert_key,},
	{ "kp*",		kpstar_key,},
	{ "kp+",		kpplus_key,},
	{ "kp-",		kpminus_key,},
	{ "kp/",		kpfslash_key,},
	{ "kp0",		kp0_key,},
	{ "kp1",		kp1_key,},
	{ "kp2",		kp2_key,},
	{ "kp3",		kp3_key,},
	{ "kp4",		kp4_key,},
	{ "kp5",		kp5_key,},
	{ "kp6",		kp6_key,},
	{ "kp7",		kp7_key,},
	{ "kp8",		kp8_key,},
	{ "kp9",		kp9_key,},
	{ "kpdel",		kpperiod_key,},
	{ "kpdelete",	kpperiod_key,},
	{ "kpdivide",	kpfslash_key,},
	{ "kpdn",		kp2_key,},
	{ "kpdown",		kp2_key,},
	{ "kpdp",		kpperiod_key,},
	{ "kpend",		kp1_key,},
	{ "kpenter",	kpenter_key,},
	{ "kphome",		kp7_key,},
	{ "kpins",		kp0_key,},
	{ "kpinsert",	kp0_key,},
	{ "kpleft",		kp4_key,},
	{ "kpmidl",		kp5_key,},
	{ "kpminus",	kpminus_key,},
	{ "kppagedown",	kp3_key,},
	{ "kppageup",	kp9_key,},
	{ "kppgdn",		kp3_key,},
	{ "kppgup",		kp9_key,},
	{ "kpplus",		kpplus_key,},
	{ "kpright",	kp6_key,},
	{ "kpslash",	kpfslash_key,},
	{ "kpstar",		kpstar_key,},
	{ "kptimes",	kpstar_key,},
	{ "kpup",		kp8_key,},
	{ "lalt",		lalt_key,},
	{ "lcontrol",	lcontrol_key,},
	{ "lctrl",		lcontrol_key,},
	{ "left",		left_key,},
	{ "leftalt",	lalt_key,},
	{ "leftcontrol", lcontrol_key,},
	{ "leftctrl",	lcontrol_key,},
	{ "leftshift",	lshift_key,},
	{ "lshift",		lshift_key,},
	{ "multiply",	kpstar_key,},
	{ "numlk",		numlock_key,},
	{ "numlock",	numlock_key,},
	{ "pagedown", 	pagedown_key,},
	{ "pageup",		pageup_key,},
	{ "pause",		pause_key,},
	{ "period",		period_key,},
	{ "pgdn",		pagedown_key,},
	{ "pgup",		pageup_key,},
	{ "print",		print_key,},
	{ "printscreen", print_key,},
	{ "prtsc",		print_key,},
	{ "ralt",		ralt_key,},
	{ "rcontrol",	rcontrol_key,},
	{ "rctrl",		rcontrol_key,},
	{ "ret",		return_key,},
	{ "return",		return_key,},
	{ "right",		right_key,},
	{ "rightalt",	ralt_key,},
	{ "rightcontrol", rcontrol_key,},
	{ "rightctrl",	rcontrol_key,},
	{ "rightshift",	rshift_key,},
	{ "rshift",		rshift_key,},
	{ "scroll",		scroll_key,},
	{ "scrolllock",	scroll_key,},
	{ "shift",		shift_key,},
	{ "space",		space_key,},
	{ "sysreq",		print_key,},
	{ "tab",		tab_key,},
	{ "tilde",		lquote_key,},
	{ "up",			up_key,},
	{ "",			no_key,},
};




/*************************************************************************

	Table of valid key codes

**************************************************************************/

BYTE okKeyTbl[] = {
	lquote_key,one_key,two_key,
	three_key,four_key,five_key,six_key,
	seven_key,eight_key,nine_key,zero_key,
	hyphen_key,equal_key,backspace_key,tab_key,
	q_key,w_key,e_key,r_key,
	t_key,y_key,u_key,i_key,
	o_key,p_key,lbracket_key,rbracket_key,
	bslash_key,caps_key,a_key,s_key,
	d_key,f_key,g_key,h_key,
	j_key,k_key,l_key,semicolon_key,
	rquote_key,return_key,lshift_key,z_key,
	x_key,c_key,v_key,b_key,
	n_key,m_key,comma_key,period_key,
	fslash_key,rshift_key,lcontrol_key,lcommand_key,
	lalt_key,space_key,ralt_key,rcommand_key,
	rcontrol_key,insert_key,delete_key,left_key,
	home_key,end_key,up_key,down_key,
	pageup_key,pagedown_key,right_key,numlock_key,
	kp7_key,kp4_key,kp1_key,kpfslash_key,
	kp8_key,kp5_key,kp2_key,kp0_key,
	kpstar_key,kp9_key,kp6_key,kp3_key,
	kpperiod_key,kpminus_key,kpplus_key,kpequal_key,
	kpenter_key,escape_key,f1_key,f2_key,
	f3_key,f4_key,f5_key,f6_key,
	f7_key,f8_key,f9_key,f10_key,
	f11_key,f12_key,print_key,scroll_key,
	pause_key,reset_key,
	no_key
	};






/****************************************************************************

	Lookup table to convert a key by its keynumber to the
	scan code for the key.

****************************************************************************/
	BYTE IBMextendedScanCodeSet1[] = {
		0x00,	/* 0 */		
		0x29,	/* 1 */		
		0x02,	/* 2 */		
		0x03,	/* 3 */		
		0x04,	/* 4 */		
		0x05,	/* 5 */		
		0x06,	/* 6 */		
		0x07,	/* 7 */		
		0x08,	/* 8 */		
		0x09,	/* 9 */		
		0x0A,	/* 10 */	
		0x0B,	/* 11 */	
		0x0C,	/* 12 */	
		0x0D,	/* 13 */	
		0x00,	/* 14 */	
		0x0E,	/* 15 */	
		0x0F,	/* 16 */	
		0x10,	/* 17 */	
		0x11,	/* 18 */	
		0x12,	/* 19 */	
		0x13,	/* 20 */	
		0x14,	/* 21 */	
		0x15,	/* 22 */	
		0x16,	/* 23 */	
		0x17,	/* 24 */	
		0x18,	/* 25 */	
		0x19,	/* 26 */	
		0x1A,	/* 27 */	
		0x1B,	/* 28 */	
		0x2B,	/* 29 */	
		0x3A,	/* 30 */	
		0x1E,	/* 31 */	
		0x1F,	/* 32 */	
		0x20,	/* 33 */	
		0x21,	/* 34 */	
		0x22,	/* 35 */	
		0x23,	/* 36 */	
		0x24,	/* 37 */	
		0x25,	/* 38 */	
		0x26,	/* 39 */	
		0x27,	/* 40 */	
		0x28,	/* 41 */	
		0x2B,	/* 42 */	
		0x1C,	/* 43 */	
		0x2A,	/* 44 */	
		0x56,	/* 45 */	
		0x2C,	/* 46 */	
		0x2D,	/* 47 */	
		0x2E,	/* 48 */	
		0x2F,	/* 49 */	
		0x30,	/* 50 */	
		0x31,	/* 51 */	
		0x32,	/* 52 */	
		0x33,	/* 53 */	
		0x34,	/* 54 */	
		0x35,	/* 55 */	
		0x00,	/* 56 */	
		0x36,	/* 57 */	
		0x1D,	/* 58 */	
		0x00,	/* 59 */	
		0x38,	/* 60 */	
		0x39,	/* 61 */	
		0x38,	/* 62 */	
		0x00,	/* 63 */	
		0x1D,	/* 64 */	
		0x00,	/* 65 */	
		0x00,	/* 66 */	
		0x00,	/* 67 */	
		0x00,	/* 68 */	
		0x00,	/* 69 */	
		0x00,	/* 70 */	
		0x00,	/* 71 */	
		0x00,	/* 72 */	
		0x00,	/* 73 */	
		0x00,	/* 74 */	
		0x52,	/* 75 */	
		0x53,	/* 76 */	
		0x00,	/* 77 */	
		0x00,	/* 78 */	
		0x4B,	/* 79 */	
		0x47,	/* 80 */	
		0x4F,	/* 81 */	
		0x00,	/* 82 */	
		0x48,	/* 83 */	
		0x50,	/* 84 */	
		0x49,	/* 85 */	
		0x51,	/* 86 */	
		0x00,	/* 87 */	
		0x00,	/* 88 */	
		0x4D,	/* 89 */	
		0x45,	/* 90 */	
		0x47,	/* 91 */	
		0x4B,	/* 92 */	
		0x4F,	/* 93 */	
		0x00,	/* 94 */	
		0x35,	/* 95 */	
		0x48,	/* 96 */	
		0x4C,	/* 97 */	
		0x50,	/* 98 */	
		0x52,	/* 99 */	
		0x37,	/* 100 */	
		0x49,	/* 101 */	
		0x4D,	/* 102 */	
		0x51,	/* 103 */	
		0x53,	/* 104 */	
		0x4A,	/* 105 */	
		0x4E,	/* 106 */	
		0x00,	/* 107 */	
		0x1C,	/* 108 */	
		0x00,	/* 109 */	
		0x01,	/* 110 */	
		0x00,	/* 111 */	
		0x3B,	/* 112 */	
		0x3C,	/* 113 */	
		0x3D,	/* 114 */	
		0x3E,	/* 115 */	
		0x3F,	/* 116 */	
		0x40,	/* 117 */	
		0x41,	/* 118 */	
		0x42,	/* 119 */	
		0x43,	/* 120 */	
		0x44,	/* 121 */	
		0x57,	/* 122 */	
		0x58,	/* 123 */	
		0x00,	/* 124 */	
		0x46,	/* 125 */	
		0x00,	/* 126 */	
		0x00	/* 127 */
		};


BYTE capsKeysTbl[] = {				/* keys affected by caps lock */
	q_key,w_key,e_key,r_key,
	t_key,y_key,u_key,i_key,
	o_key,p_key,
	a_key,s_key,
	d_key,f_key,g_key,h_key,
	j_key,k_key,l_key,
	z_key,
	x_key,c_key,v_key,b_key,
	n_key,m_key,
	no_key
	};

BYTE keyPadKeysTbl[] = {
	kp0_key,kp1_key,kp2_key,
	kp3_key,kp4_key,kp5_key,
	kp6_key,kp7_key,kp8_key,
	kp9_key,no_key
	};


/*  al,ah */
/*  ascii, scan */

struct scanTblType scanTbl[] = {
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 0   nokey 			*/
	{{0x60, 0x29,},  {0x7e, 0x29,},  {0x00, 0x00,},  {0xF0, 0x29,}},		/* 1   lquote_key 	*/
	{{0x31, 0x02,},  {0x21, 0x02,},  {0x00, 0x00,},  {0x00, 0x78,}},		/* 2   one_key 		*/
	{{0x32, 0x03,},  {0x40, 0x03,},  {0x00, 0x03,},  {0x00, 0x79,}},		/* 3   two_key 		*/
	{{0x33, 0x04,},  {0x23, 0x04,},  {0x00, 0x00,},  {0x00, 0x7a,}},		/* 4   three_key 		*/
	{{0x34, 0x05,},  {0x24, 0x05,},  {0x00, 0x00,},  {0x00, 0x7b,}},		/* 5   four_key 		*/
	{{0x35, 0x06,},  {0x25, 0x06,},  {0x00, 0x00,},  {0x00, 0x7c,}},		/* 6   five_key 		*/
	{{0x36, 0x07,},  {0x5e, 0x07,},  {0x1e, 0x07,},  {0x00, 0x7d,}},		/* 7   six_key 		*/
	{{0x37, 0x08,},  {0x26, 0x08,},  {0x00, 0x00,},  {0x00, 0x7e,}},		/* 8   seven_key 		*/
	{{0x38, 0x09,},  {0x2a, 0x09,},  {0x00, 0x00,},  {0x00, 0x7f,}},		/* 9   eight_key 		*/
	{{0x39, 0x0a,},  {0x28, 0x0a,},  {0x00, 0x00,},  {0x00, 0x80,}},		/* 10  nine_key 		*/
	{{0x30, 0x0b,},  {0x29, 0x0b,},  {0x00, 0x00,},  {0x00, 0x81,}},		/* 11  zero_key 		*/
	{{0x2d, 0x0c,},  {0x5f, 0x0c,},  {0x1f, 0x0c,},  {0x00, 0x82,}},		/* 12  hyphen_key 	*/
	{{0x3d, 0x0d,},  {0x2b, 0x0d,},  {0x00, 0x00,},  {0x00, 0x83,}},		/* 13  equal_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 14 					*/
	{{0x08, 0x0e,},  {0x08, 0x0e,},  {0x7f, 0x0e,},  {0xF0, 0x0e,}},		/* 15  backspace_key */
	{{0x09, 0x0f,},  {0x00, 0x0f,},  {0x00, 0x94,},  {0x00, 0xa5,}},		/* 16  tab_key 		*/
	{{0x71, 0x10,},  {0x51, 0x10,},  {0x11, 0x10,},  {0x00, 0x10,}},		/* 17  q_key 			*/
	{{0x77, 0x11,},  {0x57, 0x11,},  {0x17, 0x11,},  {0x00, 0x11,}},		/* 18  w_key 			*/
	{{0x65, 0x12,},  {0x45, 0x12,},  {0x05, 0x12,},  {0x00, 0x12,}},		/* 19  e_key 			*/
	{{0x72, 0x13,},  {0x52, 0x13,},  {0x12, 0x13,},  {0x00, 0x13,}},		/* 20  r_key 			*/
	{{0x74, 0x14,},  {0x54, 0x14,},  {0x14, 0x14,},  {0x00, 0x14,}},		/* 21  t_key 			*/
	{{0x79, 0x15,},  {0x59, 0x15,},  {0x19, 0x15,},  {0x00, 0x15,}},		/* 22  y_key 			*/
	{{0x75, 0x16,},  {0x55, 0x16,},  {0x15, 0x16,},  {0x00, 0x16,}},		/* 23  u_key 			*/
	{{0x69, 0x17,},  {0x49, 0x17,},  {0x09, 0x17,},  {0x00, 0x17,}},		/* 24  i_key 			*/
	{{0x6f, 0x18,},  {0x4f, 0x18,},  {0x0f, 0x18,},  {0x00, 0x18,}},		/* 25  o_key 			*/
	{{0x70, 0x19,},  {0x50, 0x19,},  {0x10, 0x19,},  {0x00, 0x19,}},		/* 26  p_key 			*/
	{{0x5b, 0x1a,},  {0x7b, 0x1a,},  {0x1b, 0x1a,},  {0xF0, 0x1a,}},		/* 27  lbracket_key 	*/
	{{0x5d, 0x1b,},  {0x7d, 0x1b,},  {0x1d, 0x1b,},  {0xF0, 0x1b,}},		/* 28  rbracket_key 	*/
	{{0x5c, 0x2b,},  {0x7c, 0x2b,},  {0x1c, 0x2b,},  {0xF0, 0x2b,}},		/* 29  bslash_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 30  caps_key 		*/
	{{0x61, 0x1e,},  {0x41, 0x1e,},  {0x01, 0x1e,},  {0x00, 0x1e,}},		/* 31  a_key 			*/
	{{0x73, 0x1f,},  {0x53, 0x1f,},  {0x13, 0x1f,},  {0x00, 0x1f,}},		/* 32  s_key 			*/
	{{0x64, 0x20,},  {0x44, 0x20,},  {0x04, 0x20,},  {0x00, 0x20,}},		/* 33  d_key 			*/
	{{0x66, 0x21,},  {0x46, 0x21,},  {0x06, 0x21,},  {0x00, 0x21,}},		/* 34  f_key 			*/
	{{0x67, 0x22,},  {0x47, 0x22,},  {0x07, 0x22,},  {0x00, 0x22,}},		/* 35  g_key 			*/
	{{0x68, 0x23,},  {0x48, 0x23,},  {0x08, 0x23,},  {0x00, 0x23,}},		/* 36  h_key 			*/
	{{0x6a, 0x24,},  {0x4a, 0x24,},  {0x0a, 0x24,},  {0x00, 0x24,}},		/* 37  j_key 			*/
	{{0x6b, 0x25,},  {0x4b, 0x25,},  {0x0b, 0x25,},  {0x00, 0x25,}},		/* 38  k_key 			*/
	{{0x6c, 0x26,},  {0x4c, 0x26,},  {0x0c, 0x26,},  {0x00, 0x26,}},		/* 39  l_key 			*/
	{{0x3b, 0x27,},  {0x3a, 0x27,},  {0x00, 0x00,},  {0xF0, 0x27,}},		/* 40  semicolon_key */
	{{0x27, 0x28,},  {0x22, 0x28,},  {0x00, 0x00,},  {0xF0, 0x28,}},		/* 41  rquote_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 42 					*/
	{{0x0d, 0x1c,},  {0x0d, 0x1c,},  {0x0a, 0x1c,},  {0xF0, 0x1c,}},		/* 43  return_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 44  lshift_key 	*/
	{{0x5c, 0x56,},  {0x7c, 0x56,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 45  45 key 			*/
	{{0x7a, 0x2c,},  {0x5a, 0x2c,},  {0x1a, 0x2c,},  {0x00, 0x2c,}},		/* 46  z_key 			*/
	{{0x78, 0x2d,},  {0x58, 0x2d,},  {0x18, 0x2d,},  {0x00, 0x2d,}},		/* 47  x_key 			*/
	{{0x63, 0x2e,},  {0x43, 0x2e,},  {0x03, 0x2e,},  {0x00, 0x2e,}},		/* 48  c_key 			*/
	{{0x76, 0x2f,},  {0x56, 0x2f,},  {0x16, 0x2f,},  {0x00, 0x2f,}},		/* 49  v_key 			*/
	{{0x62, 0x30,},  {0x42, 0x30,},  {0x02, 0x30,},  {0x00, 0x30,}},		/* 50  b_key 			*/
	{{0x6e, 0x31,},  {0x4e, 0x31,},  {0x0e, 0x31,},  {0x00, 0x31,}},		/* 51  n_key 			*/
	{{0x6d, 0x32,},  {0x4d, 0x32,},  {0x0d, 0x32,},  {0x00, 0x32,}},		/* 52  m_key 			*/
	{{0x2c, 0x33,},  {0x3c, 0x33,},  {0x00, 0x00,},  {0xF0, 0x33,}},		/* 53  comma_key 		*/
	{{0x2e, 0x34,},  {0x3e, 0x34,},  {0x00, 0x00,},  {0xF0, 0x34,}},		/* 54  period_key 	*/
	{{0x2f, 0x35,},  {0x3f, 0x35,},  {0x00, 0x00,},  {0xF0, 0x35,}},		/* 55  fslash_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 56 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 57  rshift_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 58  lcontrol_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 59 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 60  lalt_key 		*/
	{{0x20, 0x39,},  {0x20, 0x39,},  {0x20, 0x39,},  {0x20, 0x39,}},		/* 61  space_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 62  ralt_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 63 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 64  rcontrol_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 65 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 66 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 67 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 68 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 69 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 70 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 71 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 72 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 73 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 74 					*/
	{{0xe0, 0x52,},  {0xe0, 0x52,},  {0xe0, 0x92,},  {0x00, 0xa2,}},		/* 75  insert_key 	*/
	{{0xe0, 0x53,},  {0xe0, 0x53,},  {0xe0, 0x93,},  {0x00, 0xa3,}},		/* 76  delete_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 77 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 78 					*/
	{{0xe0, 0x4b,},  {0xe0, 0x4b,},  {0xe0, 0x73,},  {0x00, 0x9b,}},		/* 79  left_key 		*/
	{{0xe0, 0x47,},  {0xe0, 0x47,},  {0xe0, 0x77,},  {0x00, 0x97,}},		/* 80  home_key 		*/
	{{0xe0, 0x4f,},  {0xe0, 0x4f,},  {0xe0, 0x75,},  {0x00, 0x9f,}},		/* 81  end_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 82 					*/
	{{0xe0, 0x48,},  {0xe0, 0x48,},  {0xe0, 0x8d,},  {0x00, 0x98,}},		/* 83  up_key 			*/
	{{0xe0, 0x50,},  {0xe0, 0x50,},  {0xe0, 0x91,},  {0x00, 0xa0,}},		/* 84  down_key 		*/
	{{0xe0, 0x49,},  {0xe0, 0x49,},  {0xe0, 0x84,},  {0x00, 0x99,}},		/* 85  pageup_key 	*/
	{{0xe0, 0x51,},  {0xe0, 0x51,},  {0xe0, 0x76,},  {0x00, 0xa1,}},		/* 86  pagedown_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 87 					*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 88 					*/
	{{0xe0, 0x4d,},  {0xe0, 0x4d,},  {0xe0, 0x74,},  {0x00, 0x9d,}},		/* 89  right_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 90  numlock_key 	*/
	{{0x00, 0x47,},  {0x37, 0x47,},  {0x00, 0x77,},  {0x00, 0x00,}},		/* 91  kp7_key 		*/
	{{0x00, 0x4b,},  {0x34, 0x4b,},  {0x00, 0x73,},  {0x00, 0x00,}},		/* 92  kp4_key 		*/
	{{0x00, 0x4f,},  {0x31, 0x4f,},  {0x00, 0x75,},  {0x00, 0x00,}},		/* 93  kp1_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 94 					*/
	{{0x2f, 0xe0,},  {0x2f, 0xe0,},  {0x00, 0x95,},  {0x00, 0xa4,}},		/* 95  kpfslash_key 	*/
	{{0x00, 0x48,},  {0x38, 0x48,},  {0x00, 0x8d,},  {0x00, 0x00,}},		/* 96  kp8_key 		*/
	{{0xf0, 0x4c,},  {0x35, 0x4c,},  {0x00, 0x8f,},  {0x00, 0x00,}},		/* 97  kp5_key 		*/
	{{0x00, 0x50,},  {0x32, 0x50,},  {0x00, 0x91,},  {0x00, 0x00,}},		/* 98  kp2_key 		*/
	{{0x00, 0x52,},  {0x30, 0x52,},  {0x00, 0x92,},  {0x00, 0x00,}},		/* 99  kp0_key 		*/
	{{0x2a, 0x37,},  {0x2a, 0x37,},  {0x00, 0x96,},  {0xF0, 0x37,}},		/* 100 kpstar_key 	*/
	{{0x00, 0x49,},  {0x39, 0x49,},  {0x00, 0x84,},  {0x00, 0x00,}},		/* 101 kp9_key 		*/
	{{0x00, 0x4d,},  {0x36, 0x4d,},  {0x00, 0x74,},  {0x00, 0x00,}},		/* 102 kp6_key 		*/
	{{0x00, 0x51,},  {0x33, 0x51,},  {0x00, 0x76,},  {0x00, 0x00,}},		/* 103 kp3_key 		*/
	{{0x00, 0x53,},  {0x2e, 0x53,},  {0x00, 0x93,},  {0x00, 0x00,}},		/* 104 kpperiod_key 	*/
	{{0x2d, 0x4a,},  {0x2d, 0x4a,},  {0x00, 0x8e,},  {0xF0, 0x4a,}},		/* 105 kpminus_key 	*/
	{{0x2b, 0x4e,},  {0x2b, 0x4e,},  {0x00, 0x90,},  {0xF0, 0x4e,}},		/* 106 kpplus_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 107 					*/
	{{0x0d, 0xe0,},  {0x0d, 0xe0,},  {0x0a, 0xe0,},  {0x00, 0xa6,}},		/* 108 kpenter_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 109 					*/
	{{0x1b, 0x01,},  {0x1b, 0x01,},  {0x1b, 0x01,},  {0xF0, 0x01,}},		/* 110 escape_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 111 					*/
	{{0x00, 0x3b,},  {0x00, 0x54,},  {0x00, 0x5e,},  {0x00, 0x68,}},		/* 112 f1_key 			*/
	{{0x00, 0x3c,},  {0x00, 0x55,},  {0x00, 0x5f,},  {0x00, 0x69,}},		/* 113 f2_key 			*/
	{{0x00, 0x3d,},  {0x00, 0x56,},  {0x00, 0x60,},  {0x00, 0x6a,}},		/* 114 f3_key 			*/
	{{0x00, 0x3e,},  {0x00, 0x57,},  {0x00, 0x61,},  {0x00, 0x6b,}},		/* 115 f4_key 			*/
	{{0x00, 0x3f,},  {0x00, 0x58,},  {0x00, 0x62,},  {0x00, 0x6c,}},		/* 116 f5_key 			*/
	{{0x00, 0x40,},  {0x00, 0x59,},  {0x00, 0x63,},  {0x00, 0x6d,}},		/* 117 f6_key 			*/
	{{0x00, 0x41,},  {0x00, 0x5a,},  {0x00, 0x64,},  {0x00, 0x6e,}},		/* 118 f7_key 			*/
	{{0x00, 0x42,},  {0x00, 0x5b,},  {0x00, 0x65,},  {0x00, 0x6f,}},		/* 119 f8_key 			*/
	{{0x00, 0x43,},  {0x00, 0x5c,},  {0x00, 0x66,},  {0x00, 0x70,}},		/* 120 f9_key 			*/
	{{0x00, 0x44,},  {0x00, 0x5d,},  {0x00, 0x67,},  {0x00, 0x71,}},		/* 121 f10_key 		*/
	{{0x00, 0x85,},  {0x00, 0x87,},  {0x00, 0x89,},  {0x00, 0x8b,}},		/* 122 f11_key 		*/
	{{0x00, 0x86,},  {0x00, 0x88,},  {0x00, 0x8a,},  {0x00, 0x8c,}},		/* 123 f12_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x72,},  {0x00, 0x00,}},		/* 124 print_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 125 scroll_key 	*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 126 pause_key 		*/
	{{0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,},  {0x00, 0x00,}},		/* 127 					*/
	};





/****************************************************************************

	FUNCTION:	noOpRoutine

	PURPOSE:	"Do nothing" routine

	COMMENTS:

****************************************************************************/
void noOpRoutine(void)
{
	return;
}



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\startup.asm ===
;************************************************************************
;									*
;	Copyright (C) 1991 by Trace Center 				*
;									*
;	STARTUP.ASM							*
;									*
;************************************************************************

TITLE	Startup

include	keyboard.inc

		EXTRN	runFrontEnd:near

	PUBLIC cmdLineLen
	PUBLIC intNumber
	PUBLIC functionNumber
	PUBLIC tsrLoaded
	
	PUBLIC parameters
	PUBLIC paramsOffset
	PUBLIC paramsSegment

	PUBLIC originalInt
	PUBLIC orgIntOffset
	PUBLIC orgIntSegment


	PUBLIC accessIntHandler


_TEXT	SEGMENT  WORD PUBLIC 'CODE'
_TEXT	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
c_common segment word public 'BSS'
c_common ends
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP _TEXT, CONST, _DATA, c_common, _BSS

_TEXT	segment
	assume cs:_TEXT
	assume ds:nothing
        assume es:nothing
	assume ss:nothing

display 	MACRO	string
        	mov	dx,OFFSET string
	        mov	ah,9
        	int	21h
	        ENDM



;------------------------------------------------------------------------
	        org 80h
cmdLineLen	label   byte

;------------------------------------------------------------------------
	        org     100h
start:
                jmp     runFrontEnd		


intNumber	db	DEFAULT_INTERRUPT
functionNumber	db	ACCESS_FUNCTION
tsrLoaded       dw      TSR_HERE

parameters	label	dword
paramsOffset	dw	0
paramsSegment	dw	0

originalInt	label	dword
orgIntOffset	dw	0
orgIntSegment	dw	0


;----------------------------------------------------------------------
	PUBLIC accessIntHandler
accessIntHandler	proc	far

		jmp	accessIntHandler10

	PUBLIC programStamp
	PUBLIC pgm_stamp_len
	PUBLIC pgm_stamp_ofs

programStamp	db	'ACCESSv1.00', 0
pgm_stamp_ofs	dw	programStamp-accessIntHandler
pgm_stamp_len	dw	$-programStamp

accessIntHandler10:
		push    ds
                push    cs
                pop     ds
		assume	ds:_TEXT

		cmp	ah, functionNumber	        ; is this a call for an AccessDOS function?
		jne	notAccess		        ; no -- go to original int handler
		cmp	al, TSR_DETECT  	        ; does user want to detect if tsr loaded?
		je	retDetect
		cmp	al, TSR_PARAMS  	        ; does user want address of parameters?
		je	retParams

notAccess:
                pop     ds
                assume  ds:nothing
		jmp	cs:originalInt
                iret

retDetect:
		mov	ax, tsrLoaded		        ; yes, the tsr is loaded
                pop     ds
                assume  ds:nothing
		iret

retParams:
		mov	ax, paramsOffset	        ; return parameter block address
		mov	bx, paramsSegment
                pop     ds
                assume  ds:nothing
		iret

accessIntHandler	endp


_TEXT		ends
	        end	start


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\vars.h ===
/*  VARS.H  */


/*	SERIAL PORT VARIABLES  */


#if defined ALL_LINK
	extern unsigned int skCommPortAddr;
	extern volatile BYTE injectByte;
	extern volatile BYTE forcedInt9Flag;
	extern unsigned int combase;
	extern BYTE fmouse_id;
	extern unsigned int skBaudRate;
	extern BYTE skCommIRQ;
	extern BYTE vector;
	extern BYTE comp_id;
	extern BYTE finject_keys;
	extern BYTE serialKeysOn;
#endif

BYTE skCompId;
BYTE tempSkCompId;
BOOL singleUserSetup;
BOOL skWindowCompatible;
BOOL inSerialKeys;
BOOL inPauseFlag;
BOOL needTimerHelp;
BOOL prevPauseState;
BOOL weInjectedFlag;
BYTE fatalErrorFlag;
BYTE handleFatalError;
/*volatile BYTE mouseDataRcd;*/
unsigned int waitForInt9Timeout;
unsigned int sendSoftHandshakeStatus;


unsigned int timerCount;
functionPtrType injectKeysVector;
/* serial */
struct serialDataType commBuf[COMMBUFLEN];
struct serialDataType *putPosSBuf;
struct serialDataType *getPosSBuf;
unsigned int numCommChars;

unsigned int extendSeg;
BYTE kbFlag;
volatile BYTE kbFlag1;
BYTE kbFlag2;
BYTE altKeypad;
BYTE mouType;
unsigned int mouCommPortAddr;
int byteCount;



/* GIDEI variables */
struct asciiTableType	*asciiTblPtr;
struct aliasTableType	*aliasPtr;
functionPtrType			serVector;
functionPtrType			codeVector;
functionPtrType			cmdVector;
functionPtrType			scanDownTransVector;
functionPtrType			scanUpTransVector;
struct stackType			ptrStack[MAXPOINTERSTACK];		/* holds pointers when BEGIN used */
struct stackType			*ptrStackPtr;						/* pointer into the stack */
BYTE							buf[CODEBUFFERLEN];				/* holds GIDEI codes temporarily */
int							spos;
int							rpos;
volatile outBufferType	dataBlk;								/* global outputBuf item */
outBufferType				outputBuf[OUTPUTBUFLEN];		/* holds keys to type and mouse actions */
volatile outBufferType	*putPosOBuf;
volatile outBufferType	*getPosOBuf;
struct listType			tmpLst;
struct listType			kHold;
struct listType			kLock;
struct kStateType			kState;
BYTE							aliasStr[MAXALIASLEN+5];
BYTE							lastCode;
BYTE							serByte;
BYTE							gCode;
BYTE							passAll;
BYTE							stdErrorFlag;
BYTE							feCount;
BYTE							waitForClear;
BYTE							beginOK;
int							tmpDist;
int							tmpStatus;
int							mouseX;
int							mouseY;
int							mouseState;
int							nullCount;
unsigned int				tempskBaudRate;

extern struct aliasTableType nullTable[];
extern struct aliasTableType gideiAliasTable[];
extern struct aliasTableType commandsAliasTable[];
extern struct aliasTableType kbdAliasTable[];
extern struct aliasTableType kbdModelAliasTable[];
extern struct aliasTableType kbdDescriptionAliasTable[];
extern struct aliasTableType kbdVersionAliasTable[];
extern struct aliasTableType kbdIndicatorAliasTable[];
extern struct aliasTableType mouseAliasTable[];
extern struct aliasTableType genAliasTable[];
extern struct aliasTableType commAliasTable[];
extern struct aliasTableType baudrateAliasTable[];
extern struct aliasTableType mouButtonAliasTable[];
extern struct asciiTableType asciiTable[];
extern struct aliasTableType keyAliasTable[];
extern BYTE okKeyTbl[];
extern BYTE IBMextendedScanCodeSet1[];

extern BYTE capsKeysTbl[];
extern BYTE keyPadKeysTbl[];
extern struct scanTblType scanTbl[];

extern void noOpRoutine(void);


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\copyrigh.inc ===
;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
;M031 - changed copyright to 1991

	DB	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
	DB	"Licensed Material - Property of Microsoft "
        DB      "All rights reserved "

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\kdfdv.asm ===
PAGE    ,132
        TITLE   PC DOS 3.3 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS 3.3 - NLS Support - Keyboard Defintion File
;; (c) Copyright IBM Corp 198?,...
;;
;; This file contains the keyboard tables for Dvorak layout.
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; Author: Yuri Starikov - Microsoft WPG Ireland - Sept. 1992
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
        INCLUDE POSTEQU.INC            ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC DV_LOGIC                ;;
        PUBLIC DV_COMMON_XLAT          ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; DV State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
DV_LOGIC:

   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   IFF  EITHER_ALT,NOT                 ;;
   ANDF EITHER_CTL,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 437 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO NON_DEAD                    ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
NON_DEAD:                              ;;
                                       ;;
   IFKBD G_KB+P12_KB                   ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT               ;;
         IFF  ALT_SHIFT                ;; ALT - case
         ANDF R_ALT_SHIFT,NOT          ;;
            XLATT ALT_CASE             ;;
         ENDIFF                        ;;
      ELSEF                            ;;
         IFF EITHER_ALT,NOT            ;; CTRL - case
            XLATT CTRL_CASE            ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
;;***BD END OF ADDITION
                                       ;;
   IFF  EITHER_ALT,NOT                 ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
          ENDIFF                       ;;
      ENDIFF                           ;;
   ELSEF                               ;;
      IFF EITHER_SHIFT,NOT             ;;
          IFKBD XT_KB+AT_KB      ;;
              IFF  EITHER_CTL          ;;
              ANDF ALT_SHIFT           ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
          ELSEF                        ;;
              IFF EITHER_CTL,NOT       ;;
              ANDF R_ALT_SHIFT         ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
           ENDIFF                      ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
   EXIT_STATE_LOGIC                    ;;
                                       ;;
LOGIC_END:                             ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; DV Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC DV_COMMON_XLAT                 ;;
DV_COMMON_XLAT:                        ;;
                                       ;;
   DW    COMMON_XLAT_END-$             ;; length of section
   DW    -1                            ;; code page
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K2_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K2_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    0                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,225,0                      ;; TEST ENTRY
COM_ALT_K2_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_ALT_K2_END:                        ;;
                                       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB+P12_KB+AT_KB             ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,226,0                      ;; TEST ENTRY
   DB    43,-1,-1                      ;; invalid slash
   DB    41,28,41                      ;; valid slash
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    9                             ;; number of entries
   DB    00CH,"["                      ;; '
   DB    00DH,'{'                      ;; #
   DB    010H,"'"                      ;; #
   DB    011H,','                      ;; #
   DB    012H,'.'                      ;; #
   DB    01AH,'/'                      ;; #
   DB    01BH,'='                      ;; #
   DB    028H,'-'                      ;; #
   DB    02CH,';'                      ;; #
COM_NA_LO_K1_T1_END:                   ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    9                             ;; number of entries
   DB    00CH,"]"                      ;; '
   DB    00DH,'}'                      ;; #
   DB    010H,'"'                      ;; #
   DB    011H,'<'                      ;; #
   DB    012H,'>'                      ;; #
   DB    01AH,'?'                      ;; #
   DB    01BH,'+'                      ;; #
   DB    028H,'_'                      ;; #
   DB    02CH,':'                      ;; #
COM_NA_UP_T1_K1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_LO_END-$           ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
                                       ;;
   DW    CPCOM_A_LO_K1_T01_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    26                            ;; number of entries
   DB    13H, 'p'                           ;;   j
   DB    14H, 'y'                           ;;   l
   DB    15H, 'f'                           ;;   m
   DB    16H, 'g'                           ;;   f
   DB    17H, 'c'                           ;;   p
   DB    18H, 'r'                           ;;   p
   DB    19H, 'l'                           ;;   p
   DB    1EH, 'a'                           ;;   o
   DB    1FH, 'o'                           ;;   r
   DB    20H, 'e'                           ;;   s
   DB    21H, 'u'                           ;;   u
   DB    22H, 'i'                           ;;   y
   DB    23H, 'd'                           ;;   b
   DB    24H, 'h'                           ;;   b
   DB    25H, 't'                           ;;   b
   DB    26H, 'n'                           ;;   b
   DB    27H, 's'                           ;;   b
   DB    2DH, 'q'                           ;;   z
   DB    2EH, 'j'                           ;;   a
   DB    2FH, 'k'                           ;;   e
   DB    30H, 'x'                           ;;   h
   DB    31H, 'b'                           ;;   t
   DB    32H, 'm'                           ;;   d
   DB    33H, 'w'                           ;;   c
   DB    34H, 'v'                           ;;   k
   DB    35H, 'z'                           ;;   k
CPCOM_A_LO_K1_T01_END:                  ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_LO_END:                     ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_UP_END-$           ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CPCOM_A_UP_K1_T01_END-$        ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    26                            ;; number of entries
   DB    13H, 'P'                           ;;   j
   DB    14H, 'Y'                           ;;   l
   DB    15H, 'F'                           ;;   m
   DB    16H, 'G'                           ;;   f
   DB    17H, 'C'                           ;;   p
   DB    18H, 'R'                           ;;   p
   DB    19H, 'L'                           ;;   p
   DB    1EH, 'A'                           ;;   o
   DB    1FH, 'O'                           ;;   r
   DB    20H, 'E'                           ;;   s
   DB    21H, 'U'                           ;;   u
   DB    22H, 'I'                           ;;   y
   DB    23H, 'D'                           ;;   b
   DB    24H, 'H'                           ;;   b
   DB    25H, 'T'                           ;;   b
   DB    26H, 'N'                           ;;   b
   DB    27H, 'S'                           ;;   b
   DB    2DH, 'Q'                           ;;   z
   DB    2EH, 'J'                           ;;   a
   DB    2FH, 'K'                           ;;   e
   DB    30H, 'X'                           ;;   h
   DB    31H, 'B'                           ;;   t
   DB    32H, 'M'                           ;;   d
   DB    33H, 'W'                           ;;   c
   DB    34H, 'V'                           ;;   k
   DB    35H, 'Z'                           ;;   k
CPCOM_A_UP_K1_T01_END:                  ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_UP_END:                     ;;
                                       ;;
   DW     0                            ;; LAST STATE
                                       ;;
COMMON_XLAT_END:                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE     ENDS                          ;;
         END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\dseg.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;---Revised 8-17-84 FOR KBX	(ADDED ADDITIONAL KEYBOARD FLAG - KB_FLAG_3)
;----------------------------------------
;	 0286 INTERRUPT LOCATIONS (READ):
;----------------------------------------
ABS0	SEGMENT AT 0
STG_LOC0		LABEL	BYTE
	ORG 2*4
NMI_PTR 		LABEL	WORD
	ORG 5*4
INT5_PTR		LABEL	WORD
	ORG 8*4
INT_ADDR		LABEL	WORD
INT_PTR 		LABEL	DWORD
	ORG 10H*4
VIDEO_INT		LABEL	WORD
	ORG 13H*4			; NEW FDISK
ORG_VECTOR		LABEL	DWORD
	ORG 18H*4
BASIC_PTR		LABEL	WORD
	ORG 19H*4
BOOT_VEC		LABEL	DWORD
BOOT_VECTOR		LABEL	DWORD
	ORG 1DH*4
PARM_PTR		LABEL	DWORD	; POINTER TO VIDEO PARMS
	ORG 1EH*4
DISK_POINTER		LABEL	DWORD
	ORG 01FH*4
EXT_PTR 		LABEL	DWORD
	ORG 40H*4			; DISKETTE POINTER
DISK_VECTOR		LABEL	DWORD
       ORG 41H*4
HF_TBL_VEC		LABEL	DWORD
	ORG 46H*4
HF1_TBL_VEC		LABEL	DWORD
	ORG 70H*4
SLAVE_INT_PTR		LABEL	DWORD
RTC_INT_VEC		LABEL	DWORD	; REAL TIME CLOCK INT
	ORG 76H*4			; FIXED DISK INTERRUPT VECTOR
HDISK_INT		LABEL	DWORD
	ORG	400H
DATA_AREA		 LABEL BYTE	;ABSOLUTE LOCATION OF DATA SEGMENT
DATA_WORD		 LABEL WORD
	ORG	0500H
MFG_TEST_RTN		 LABEL	FAR
	ORG	7C00H
BOOT_LOCN		 LABEL	FAR
ABS0	ENDS
PAGE
;------------------------------------------------
; STACK -- USED DURING INITIALIZATION ONLY	:
;------------------------------------------------
STACK	SEGMENT AT 30H
	DW	128 DUP(?)
TOS	LABEL	WORD
STACK	ENDS
;----------------------------------------
;	ROM BIOS DATA AREAS		:
;----------------------------------------
DATA	SEGMENT AT 40H
;DATA_BASE	 LABEL	 BYTE
RS232_BASE	DW	4 DUP(?)	; ADDRESSES OF RS232 ADAPTERS
PRINTER_BASE	DW	4 DUP(?)	; ADDRESSES OF PRINTERS
EQUIP_FLAG	DW	1 DUP(?)	; INSTALLED HARDWARE
MFG_TST 	DB	1 DUP(?)	; INITIALIZATION FLAG
MEMORY_SIZE	DW	1 DUP(?)	; MEMORY SIZE IN K BYTES
MFG_ERR_FLAG	DB	1 DUP(?)	; SCRATCHPAD FOR MANUFACTURING
		DB	1 DUP(?)	; ERROR CODES
PAGE
;----------------------------------------
;	KEYBOARD DATA AREAS		:
;----------------------------------------
KB_FLAG 	DB	1 DUP(?)
KB_FLAG_1	DB	1 DUP(?)	; SECOND BYTE OF KEYBOARD STATUS
ALT_INPUT	DB	1 DUP(?)	; STORAGE FOR ALTERNATE KEYPAD ENTRY
BUFFER_HEAD	DW	1 DUP(?)	; POINTER TO HEAD OF KEYBOARD BUFFER
BUFFER_TAIL	DW	1 DUP(?)	; POINTER TO TAIL OF KEYBOARD BUFFER
KB_BUFFER	DW	16 DUP(?)	; ROOM FOR 15 ENTRIES
KB_BUFFER_END	LABEL	WORD

;------ HEAD = TAIL INDICATES THAT THE BUFFER IS EMPTY

;----------------------------------------
;	DISKETTE DATA AREAS		:
;----------------------------------------
SEEK_STATUS	DB	1 DUP(?)	; DRIVE RECALIBRATION STATUS
					; BIT 3-0 = DRIVE 3-0 NEEDS RECAL
					; BEFORE NEXT SEEK IF BIT IS = 0
MOTOR_STATUS	DB	1 DUP(?)	; MOTOR STATUS
					; BIT 3-0 = DRIVE 3-0 IS CURRENTLY
					;   RUNNING
					; BIT 7 = CURRENT OPERATION IS A WRITE,
					;   REQUIRES DELAY
MOTOR_COUNT	DB	1 DUP(?)	; TIME OUT COUNTER FOR DRIVE TURN OFF
DISKETTE_STATUS DB	1 DUP(?)	; RETURN CODE STATUS BYTE
CMD_BLOCK	LABEL	BYTE
HD_ERROR	LABEL	BYTE
NEC_STATUS	DB	7 DUP(?)	; STATUS BYTES FROM NEC
PAGE
;----------------------------------------
;	VIDEO DISPLAY DATA AREA 	:
;----------------------------------------
CRT_MODE	DB	1 DUP(?)	; CURRENT CRT MODE
CRT_COLS	DW	1 DUP(?)	; NUMBER OF COLUMNS ON SCREEN
CRT_LEN 	DW	1 DUP(?)	; LENGTH OF REGEN IN BYTES
CRT_START	DW	1 DUP(?)	; STARTING ADDRESS IN REGEN BUFFER
CURSOR_POSN	DW	8 DUP(?)	; CURSOR FOR EACH OF UP TO 8 PAGES
CURSOR_MODE	DW	1 DUP(?)	; CURRENT CURSOR MODE SETTING
ACTIVE_PAGE	DB	1 DUP(?)	; CURRENT PAGE BEING DISPLAYED
ADDR_6845	DW	1 DUP(?)	; BASE ADDRESS FOR ACTIVE DISPLAY CARD
CRT_MODE_SET	DB	1 DUP(?)	; CURRENT SETTING OF THE 3X8 REGISTER
CRT_PALLETTE	DB	1 DUP(?)	; CURRENT PALLETTE SETTING COLOR CARD
PAGE
;----------------------------------------
;	POST DATA AREA			:
;----------------------------------------
IO_ROM_INIT	DW	1 DUP(?)	; PNTR TO OPTIONAL I/O ROM INIT ROUTINE
IO_ROM_SEG	DW	1 DUP(?)	; POINTER TO IO ROM SEGMENT
INTR_FLAG	DB	1 DUP(?)	; FLAG TO INDICATE AN INTERRUPT HAPPEND
;----------------------------------------
;	TIMER DATA AREA 		:
;----------------------------------------
TIMER_LOW	DW	1 DUP(?)	; LOW WORD OF TIMER COUNT
TIMER_HIGH	DW	1 DUP(?)	; HIGH WORD OF TIMER COUNT
TIMER_OFL	DB	1 DUP(?)	; TIMER HAS ROLLED OVER SINCE LAST READ
;----------------------------------------
;	SYSTEM DATA AREA		:
;----------------------------------------
BIOS_BREAK	DB	1 DUP(?)	; BIT 7=1 IF BREAK KEY HAS BEEN HIT
RESET_FLAG	DW	1 DUP(?)	; WORD=1234H IF KEYBOARD RESET UNDERWAY
PAGE
;----------------------------------------
;	HARD FILE DATA AREAS		:
;----------------------------------------
DISK_STATUS1	DB	1 DUP(?)
HF_NUM		DB	1 DUP(?)
CONTROL_BYTE	DB	1 DUP(?)
PORT_OFF	DB	1 DUP(?)
;------------------------------------------------------
;	PRINTER AND RS232 TIME-OUT VARIABLES	      :
;------------------------------------------------------
PRINT_TIM_OUT	DB	4 DUP(?)
RS232_TIM_OUT	DB	4 DUP(?)
;----------------------------------------
;	ADDITIONAL KEYBOARD DATA AREA	:
;----------------------------------------
BUFFER_START	DW	1 DUP(?)
BUFFER_END	DW	1 DUP(?)
;---------------------------------------
;	ADDITIONAL FLOPPY DATA	       ;
;---------------------------------------
	ORG	8BH
LASTRATE	DB	1 DUP(?)	; LAST DATA RATE SELECTED
PAGE
;---------------------------------------
;	ADDITIONAL HARD FILE DATA      :
;---------------------------------------
	ORG	8CH
HF_STATUS	DB	1 DUP(?)	; STATUS REGISTER
HF_ERROR	DB	1 DUP(?)	; ERROR REGISTER
HF_INT_FLAG	DB	1 DUP(?)	; HARD FILE INTERRUPT FLAG
HF_CNTRL	DB	1 DUP(?)	; COMBO HARD FILE/FLOPPY CARD BIT 0=1
;----------------------------------------
;	ADDITIONAL DISKETTE AREA       :
;----------------------------------------
	ORG	90H
DSK_STATE	LABEL	BYTE
		DB	1 DUP(?)	; DRIVE 0 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 1 MEDIA STATE
		DB	1 DUP(?)	; DRIVE 0 OPERATION START STATE
		DB	1 DUP(?)	; DRIVE 1 OPERATION START STATE
DSK_TRK 	DB	1 DUP(?)	; DRIVE 0 PRESENT CYLINDER
		DB	1 DUP(?)	; DRIVE 1 PRESENT CYLINDER
		DB	1 DUP(?)	; RESERVED
;----------------------------------------				AEV
;	ADDITIONAL KEYBOARD FLAG FOR KBX:				AEV
;----------------------------------------				AEV
	ORG	96H			;				AEV
KB_FLAG_3	DB	1 DUP(?)	;				AEV
;----------------------------------------
;	ADDITIONAL KEYBOARD LED FLAG	:
;----------------------------------------
	ORG	97H
KB_FLAG_2	DB	1 DUP(?)
PAGE
;----------------------------------------
;	REAL TIME CLOCK DATA AREA	:
;----------------------------------------
	ORG	98H
USER_FLAG	DW	1 DUP(?)	; OFFSET ADDR OF USERS WAIT FLAG
USER_FLAG_SEG	DW	1 DUP(?)	; SEG ADDR OF USER WAIT FLAG
RTC_LOW 	DW	1 DUP(?)	; LOW WORD OF USER WAIT FLAG
RTC_HIGH	DW	1 DUP(?)	; HIGH WORD OF USER WAIT FLAG
RTC_WAIT_FLAG	DB	1 DUP(?)	; WAIT ACTIVE FLAG
DATA	ENDS
;----------------------------------------
;	EXTRA DATA AREA 		:
;----------------------------------------
XXDATA	SEGMENT AT 50H
STATUS_BYTE	DB	1 DUP(?)
XXDATA	ENDS
;----------------------------------------
;	VIDEO DISPLAY BUFFER		:
;----------------------------------------
VIDEO_RAM	SEGMENT AT 0B800H
REGEN	LABEL	BYTE
REGENW	LABEL	WORD
	DB	16384 DUP(?)
VIDEO_RAM	ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\kdflh2.asm ===
PAGE    ,132
        TITLE   PC DOS 3.3 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS 5.0 - NLS Support - Keyboard Defintion File
;; (c) Copyright Microsoft Corp 1992...
;;
;; This file contains the keyboard tables for Left single-handed
;; key layout
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; Author:     YSt - MS WPG Ireland September 1992
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
        INCLUDE POSTEQU.INC            ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC LH2_LOGIC                ;;
        PUBLIC LH2_437_XLAT             ;;
        PUBLIC LH2_850_XLAT             ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; LH State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
LH2_LOGIC:

   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   IFF  EITHER_ALT,NOT                 ;;
   ANDF EITHER_CTL,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 437 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO NON_DEAD                    ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
NON_DEAD:                              ;;
                                       ;;
   IFKBD G_KB+P12_KB                   ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT               ;;
         IFF  ALT_SHIFT                ;; ALT - case
         ANDF R_ALT_SHIFT,NOT          ;;
            XLATT ALT_CASE             ;;
         ENDIFF                        ;;
      ELSEF                            ;;
         IFF EITHER_ALT,NOT            ;; CTRL - case
            XLATT CTRL_CASE            ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
;;***BD END OF ADDITION
                                       ;;
   IFF  EITHER_ALT,NOT                 ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
          ENDIFF                       ;;
      ENDIFF                           ;;
   ELSEF                               ;;
      IFF EITHER_SHIFT,NOT             ;;
          IFKBD XT_KB+AT_KB      ;;
              IFF  EITHER_CTL          ;;
              ANDF ALT_SHIFT           ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
          ELSEF                        ;;
              IFF EITHER_CTL,NOT       ;;
              ANDF R_ALT_SHIFT         ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
           ENDIFF                      ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
   EXIT_STATE_LOGIC                    ;;
                                       ;;
LOGIC_END:                             ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; LH Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC LH2_COMMON_XLAT                 ;;
LH2_COMMON_XLAT:                        ;;
                                       ;;
   DW    COMMON_XLAT_END-$             ;; length of section
   DW    -1                            ;; code page
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K2_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K2_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    0                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,225,0                      ;; TEST ENTRY
COM_ALT_K2_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_ALT_K2_END:                        ;;
                                       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB+P12_KB+AT_KB             ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    0                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,226,0                      ;; TEST ENTRY
;   DB    43,-1,-1                      ;; invalid slash
;   DB    41,28,41                      ;; valid slash
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: ANY_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '['                     ;;
   DB    003H, ']'                     ;;
   DB    004H, '/'                     ;;
   DB    00AH, '4'                     ;;
   DB    00BH, '3'                     ;;
   DB    00CH, '2'                     ;;
   DB    00DH, '1'                     ;;
   DB    010H, ';'                     ;;
   DB    018H, '.'                     ;;
   DB    019H, '6'                     ;;
   DB    01AH, '5'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '-'                     ;;
   DB    027H, '8'                     ;;
   DB    028H, '7'                     ;;
   DB    02BH, 05CH
   DB    02CH, 027H                    ;;
   DB    033H, ','                     ;;
   DB    034H, '0'                     ;;
   DB    035H, '9'                     ;;
COM_NA_LO_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K2_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    AT_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K2_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '['                     ;;
   DB    003H, ']'                     ;;
   DB    004H, '/'                     ;;
   DB    00AH, '4'                     ;;
   DB    00BH, '3'                     ;;
   DB    00CH, '2'                     ;;
   DB    00DH, '1'                     ;;
   DB    010H, ';'                     ;;
   DB    018H, '.'                     ;;
   DB    019H, '6'                     ;;
   DB    01AH, '5'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '-'                     ;;
   DB    027H, '8'                     ;;
   DB    028H, '7'                     ;;
   DB    02BH, 05CH
   DB    02CH, 027H                    ;;
   DB    033H, ','                     ;;
   DB    034H, '0'                     ;;
   DB    035H, '9'                     ;;
COM_NA_LO_K2_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K2_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K3_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    XT_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K3_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '['                     ;;
   DB    003H, ']'                     ;;
   DB    004H, '/'                     ;;
   DB    00AH, '4'                     ;;
   DB    00BH, '3'                     ;;
   DB    00CH, '2'                     ;;
   DB    00DH, '1'                     ;;
   DB    010H, ';'                     ;;
   DB    018H, '.'                     ;;
   DB    019H, '6'                     ;;
   DB    01AH, '5'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '-'                     ;;
   DB    027H, '8'                     ;;
   DB    028H, '7'                     ;;
   DB    02BH, 05CH
   DB    02CH, 027H                    ;;
   DB    033H, ','                     ;;
   DB    034H, '0'                     ;;
   DB    035H, '9'                     ;;
COM_NA_LO_K3_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K3_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '{'                     ;;
   DB    003H, '}'                     ;;
   DB    004H, '?'                     ;;
   DB    00AH, '$'                     ;;
   DB    00BH, '#'                     ;;
   DB    00CH, '@'                     ;;
   DB    00DH, '!'                     ;;
   DB    010H, ':'                     ;;
   DB    018H, '>'                     ;;
   DB    019H, '^'                     ;;
   DB    01AH, '%'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '_'                     ;;
   DB    027H, '*'                     ;;
   DB    02CH, '"'                     ;;
   DB    02BH, '|'                    ;;
   DB    033H, '<'                     ;;
   DB    034H, ')'                     ;;
   DB    035H, '('                     ;;
COM_NA_UP_T1_K1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                         ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K2_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    XT_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K2_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '{'                     ;;
   DB    003H, '}'                     ;;
   DB    004H, '?'                     ;;
   DB    00AH, '$'                     ;;
   DB    00BH, '#'                     ;;
   DB    00CH, '@'                     ;;
   DB    00DH, '!'                     ;;
   DB    010H, ':'                     ;;
   DB    018H, '>'                     ;;
   DB    019H, '^'                     ;;
   DB    01AH, '%'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '_'                     ;;
   DB    027H, '*'                     ;;
   DB    02CH, '"'                     ;;
   DB    02BH, '|'                    ;;
   DB    033H, '<'                     ;;
   DB    034H, ')'                     ;;
   DB    035H, '('                     ;;
COM_NA_UP_T1_K2_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K2_END:                         ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K3_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    AT_KB                         ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K3_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    20                            ;; number of entries
   DB    002H, '{'                     ;;
   DB    003H, '}'                     ;;
   DB    004H, '?'                     ;;
   DB    00AH, '$'                     ;;
   DB    00BH, '#'                     ;;
   DB    00CH, '@'                     ;;
   DB    00DH, '!'                     ;;
   DB    010H, ':'                     ;;
   DB    018H, '>'                     ;;
   DB    019H, '^'                     ;;
   DB    01AH, '%'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '_'                     ;;
   DB    027H, '*'                     ;;
   DB    02CH, '"'                     ;;
   DB    02BH, '|'                    ;;
   DB    033H, '<'                     ;;
   DB    034H, ')'                     ;;
   DB    035H, '('                     ;;
COM_NA_UP_T1_K3_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K3_END:                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_LO_END-$            ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
                                       ;;
   DW    CPCOM_A_LO_K1_T01_END-$       ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    25                            ;; Number of entries
   DB    5, 'p'                        ;;   j
   DB    6, 'f'                        ;;   l
   DB    7, 'm'                        ;;   m
   DB    8, 'l'                        ;;   f
   DB    9 , 'j'                       ;;   p
   DB    11H, 'q'                       ;;   q
   DB    12H, 'b'                           ;;   o
   DB    13H, 'y'                           ;;   r
   DB    14H, 'u'                           ;;   s
   DB    15H, 'r'                           ;;   u
   DB    16H, 's'                           ;;   y
   DB    17H, 'o'                           ;;   b
   DB    1FH, 'k'                           ;;   z
   DB    20H, 'c'                           ;;   a
   DB    21H, 'd'                           ;;   e
   DB    22H, 't'                           ;;   h
   DB    23H, 'h'                           ;;   t
   DB    24H, 'e'                           ;;   d
   DB    25H, 'a'                           ;;   c
   DB    27H, 'z'                           ;;   k
   DB    2EH, 'g'                           ;;   x
   DB    2FH, 'v'                           ;;   i
   DB    30H, 'w'                           ;;   n
   DB    31H, 'n'                           ;;   w
   DB    32H, 'i'                           ;;   v
CPCOM_A_LO_K1_T01_END:           ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_LO_END:                      ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_UP_END-$            ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CPCOM_A_UP_K1_T01_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    25                            ;; Number of entries
   DB    5, 'P'                        ;;   j
   DB    6, 'F'                        ;;   l
   DB    7, 'M'                        ;;   m
   DB    8, 'L'                        ;;   f
   DB    9 , 'J'                       ;;   p
   DB    11H, 'Q'                       ;;   q
   DB    12H, 'B'                           ;;   o
   DB    13H, 'Y'                           ;;   r
   DB    14H, 'U'                           ;;   s
   DB    15H, 'R'                           ;;   u
   DB    16H, 'S'                           ;;   y
   DB    17H, 'O'                           ;;   b
   DB    1FH, 'K'                           ;;   z
   DB    20H, 'C'                           ;;   a
   DB    21H, 'D'                           ;;   e
   DB    22H, 'T'                           ;;   h
   DB    23H, 'H'                           ;;   t
   DB    24H, 'E'                           ;;   d
   DB    25H, 'A'                           ;;   c
   DB    27H, 'Z'                           ;;   k
   DB    2EH, 'G'                           ;;   x
   DB    2FH, 'V'                           ;;   i
   DB    30H, 'W'                           ;;   n
   DB    31H, 'N'                           ;;   w
   DB    32H, 'I'                           ;;   v
CPCOM_A_UP_K1_T01_END:           ;;

                                       ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_UP_END:                      ;;
                                       ;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;
                                       ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; LH Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC LH2_437_XLAT                    ;;
LH2_437_XLAT:                           ;;
                                       ;;
   DW     CP437_XLAT_END-$             ;; length of section
   DW     437                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP437_THIRD_K1_END-$            ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP437_THIRD_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    41,0DDH                       ;; Solid vertical bar - graphics block
CP437_THIRD_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP437_THIRD_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW     0                            ;; LAST STATE
                                       ;;
CP437_XLAT_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; LH Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC LH2_850_XLAT                    ;;
LH2_850_XLAT:                           ;;
                                       ;;
   DW     CP850_XLAT_END-$             ;; length of section
   DW     850                          ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_THIRD_K1_END-$            ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_THIRD_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    41,07CH                       ;; Solid vertical bar - |
CP850_THIRD_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP850_THIRD_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE     ENDS                          ;;
         END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\kdfeof.asm ===
;     *   IBM CONFIDENTIAL   *   Jan 9 1990   *



	PAGE	,132
	TITLE	PC DOS TUGBOAT Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; PC DOS TUGBOAT - NLS Support - Keyboard Definition File
;; (c) Copyright IBM Corp 198?,...
;;
;; This file contains the eof marker for the entire table
;; and the keyboard.sys copyright information
;;
;; Linkage Instructions:
;;	Refer to KDF.ASM.
;;
;;
;; Author:     BILL DEVLIN  - IBM Canada Laboratory - May 1986
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
				       ;;
CODE	SEGMENT PUBLIC 'CODE'          ;;
	ASSUME CS:CODE,DS:CODE	       ;;
				       ;;
				       ;;
				       ;;
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; Copyright statement
;;	DB 'KEYBOARD.SYS Version TUGBOAT (C) Copyright IBM Corp. 1986,1987,1988',13,10  ;;
;;	DB 'Authors : Bill Devlin, Nick Savage, Mike Saunders, et al..',13,10
;;	DB 'Development: Toronto,Boca Raton,Basingstoke',13,10

include copyrigh.inc
	;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	DB  1AH 		       ;; EOF
				       ;;
CODE	ENDS			       ;;
	END			       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\kdfnow.asm ===
PAGE    ,132
        TITLE   MS-DOS 5.0 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Definition File
;; (c) Copyright Microsoft Corp 1992
;;
;;           KDFDV.ASM  - US Dvorak
;;           KDFLH2.ASM  - US left single-handed key layout
;;           KDFRH2.ASM  - US right single-handed key layout
;;           Dummy US   - US
;;
;;             Yuri Starikov -Microsoft September 1992
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; File Header
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                     ;;
DB   0FFh,'KEYB   '                  ;; signature
DB   8 DUP(0)                        ;; reserved
DW   0460H                           ;; maximum size of Common Xlat Sect (650)
DW   01F0H                           ;; max size of Specific Xlat Sect (350)
DW   0280H                           ;; max size of State Logic (400)
DW   0                               ;;AC000;reserved
DW   4                               ;;AC000 number of IDs
DW   4                               ;M000     ;;AC000 number of languages
DB   'RH'                            ;;(YST);
DW   OFFSET RH2_LANG_ENT,0           ;;(YST); Right single-handed
DB   'LH'                            ;;(YST);
DW   OFFSET LH2_LANG_ENT,0           ;;(YST); Left single-handed
DB   'DV'                            ;;(YST);
DW   OFFSET DV_LANG_ENT,0           ;;(YST); Left single-handed
DB   'US'                            ;;
DW   OFFSET DUMMY_ENT,0              ;;
DW    987                            ;;(YST)
DW   OFFSET RH2_LANG_ENT,0           ;;(YST)
DW    986                            ;;(YST)
DW   OFFSET LH2_LANG_ENT,0           ;;(YST)
DW    985                            ;;(YST)
DW   OFFSET DV_LANG_ENT,0            ;;(YST)
DW    103                            ;;AN000;
DW   OFFSET DUMMY_ENT,0              ;;AN000;
;                                    ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; Language Entries
;*****************************************************************************
                                         ;;
     EXTRN RH2_LOGIC:FAR                 ;;
     EXTRN RH2_850_XLAT:FAR              ;;
     EXTRN RH2_437_XLAT:FAR              ;;
                                         ;;
  RH2_LANG_ENT:                           ;; language entry for Yugo (Cyrillic)
    DB   'RH'                            ;;
    DW   987                             ;; ID entry
    DW   OFFSET RH2_LOGIC,0               ;; pointer to LANG kb table
    DB   1                               ;; number of ids
    DB   2                               ;; number of code pages
    DW   437                             ;; code page  ; default to 437 -same as country.sys
    DW   OFFSET RH2_437_XLAT,0            ;; table pointer
    DW   850                             ;; code page
    DW   OFFSET RH2_850_XLAT,0            ;; table pointer
                                         ;;
;*****************************************************************************
     EXTRN LH2_LOGIC:FAR                  ;;
     EXTRN LH2_850_XLAT:FAR               ;;
     EXTRN LH2_437_XLAT:FAR              ;;
                                         ;;
  LH2_LANG_ENT:                           ;; language entry for Yugo (Cyrillic)
    DB   'LH'                            ;;
    DW   986                             ;; ID entry
    DW   OFFSET LH2_LOGIC,0               ;; pointer to LANG kb table
    DB   1                               ;; number of ids
    DB   2                               ;; number of code pages
    DW   437                             ;; code page  ; default to 437 -same as country.sys
    DW   OFFSET LH2_437_XLAT,0            ;; table pointer
    DW   850                             ;; code page
    DW   OFFSET LH2_850_XLAT,0            ;; table pointer
                                         ;;
;*****************************************************************************
                                         ;;
     EXTRN DV_LOGIC:FAR                  ;;
     EXTRN DV_COMMON_XLAT:FAR            ;;
                                         ;;
  DV_LANG_ENT:                           ;; language entry for Yugo (Cyrillic)
    DB   'DV'                            ;;
    DW   985                             ;; ID entry
    DW   OFFSET DV_LOGIC,0               ;; pointer to LANG kb table
    DB   1                               ;; number of ids
    DB   2                               ;; number of code pages
    DW   437                             ;; code page  ; default to 437 -same as country.sys
    DW   OFFSET DV_COMMON_XLAT,0            ;; table pointer
    DW   850                             ;; code page
    DW   OFFSET DV_COMMON_XLAT,0            ;; table pointer
                                         ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
DUMMY_ENT:                             ;; language entry
  DB   'XX'                            ;;
  DW   103                             ;;AC000; ID entry
  DW   OFFSET DUMMY_LOGIC,0            ;; pointer to LANG kb table
  DB   1                               ;;AC000; number of ids
  DB   8                               ;;AC000; number of code pages
  DW   437                             ;; code page
  DW   OFFSET DUMMY_XLAT_437,0         ;; table pointer
  DW   850                             ;; code page
  DW   OFFSET DUMMY_XLAT_850,0         ;; table pointer
  DW   852                             ;; code page     [Mihindu 11/30/90]
  DW   OFFSET DUMMY_XLAT_852,0         ;; table pointer
  DW   860                             ;; code page
  DW   OFFSET DUMMY_XLAT_860,0         ;; table pointer
  DW   863                             ;; code page
  DW   OFFSET DUMMY_XLAT_863,0         ;; table pointer
  DW   865                             ;; code page
  DW   OFFSET DUMMY_XLAT_865,0         ;; table pointer
  DW   866                             ;; code page  [YST 3/19/91]
  DW   OFFSET DUMMY_XLAT_866,0         ;; table pointer
  DW   855                             ;; code page  [YST 3/19/91]
  DW   OFFSET DUMMY_XLAT_855,0         ;; table pointer
                                       ;;
DUMMY_LOGIC:                           ;;
   DW  LOGIC_END-$                     ;; length
   DW  0                               ;; special features
   DB  92H,0,0                         ;; EXIT_STATE_LOGIC_COMMAND
LOGIC_END:                             ;;
                                       ;;
DUMMY_XLAT_437:                        ;;
   DW     6                            ;; length of section
   DW     437                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_850:                        ;;
   DW     6                            ;; length of section
   DW     850                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_852:                        ;; [Mihindu 11/30/90]
   DW     6                            ;; length of section
   DW     852                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_860:                        ;;
   DW     6                            ;; length of section
   DW     860                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_865:                        ;;
   DW     6                            ;; length of section
   DW     865                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_863:                        ;;
   DW     6                            ;; length of section
   DW     863                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_866:                        ;;   (YST 3/19/91)
   DW     6                            ;; length of section
   DW     866                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
DUMMY_XLAT_855:                        ;;   (YST 3/19/91)
   DW     6                            ;; length of section
   DW     855                          ;; code page
   DW     0                            ;; LAST STATE
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;*****************************************************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CODE     ENDS                          ;;
         END                           ;;
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\keybmac.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS DOS 3.3 - NLS Support - Keyboard Definition File
;;
;; File Name:  KEYBMAC.INC
;; ----------
;;
;; Author:     Bill Devlin  - IBM Canada Laboratory - May 1986
;; -------     ???????????
;;
;; Description:
;; ------------
;;	 Include file containing macros for the Keyboard Definition File.
;;
;; Change History:
;; ---------------
;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Dead key flags
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
ACUTE		    EQU   80H	       ;; NLS_FLAG_1
GRAVE		    EQU   40H	       ;;
DIARESIS	    EQU   20H	       ;;
CIRCUMFLEX	    EQU   10H	       ;;
CEDILLA 	    EQU   08H	       ;;
TILDE		    EQU   04H	       ;;
				       ;; NLS_FLAG_2 : nothing defined yet
CARON		    EQU   80H
BREVE		    EQU   40H
OVERCIRCLE	    EQU   20H
OGONEK		    EQU   10H
OVERDOT 	    EQU   08H
DOUBLEACUTE	    EQU   04H

				       ;;
				       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State IDs
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;
DEAD_LOWER	    EQU    1	       ;; dead keys on lower shift
DEAD_UPPER	    EQU    2	       ;;
ALPHA_LOWER	    EQU    3	       ;;
ALPHA_UPPER	    EQU    4	       ;;
NON_ALPHA_LOWER     EQU    5	       ;;
NON_ALPHA_UPPER     EQU    6	       ;;
THIRD_SHIFT	    EQU    7	       ;;
ACUTE_LOWER	    EQU    8	       ;;
ACUTE_UPPER	    EQU    9	       ;;
ACUTE_SPACE	    EQU   10	       ;;
GRAVE_LOWER	    EQU   11	       ;;
GRAVE_UPPER	    EQU   12	       ;;
GRAVE_SPACE	    EQU   13	       ;;
DIARESIS_LOWER	    EQU   14	       ;;
DIARESIS_UPPER	    EQU   15	       ;;
DIARESIS_SPACE	    EQU   16	       ;;
CIRCUMFLEX_LOWER    EQU   17	       ;;
CIRCUMFLEX_UPPER    EQU   18	       ;;
CIRCUMFLEX_SPACE    EQU   19	       ;;
CEDILLA_LOWER	    EQU   20	       ;;
CEDILLA_UPPER	    EQU   21	       ;;
CEDILLA_SPACE	    EQU   22	       ;;
CEDILLA_CEDILLA     EQU   23	       ;;
DEAD_THIRD	    EQU   24	       ;;
ACUTE_ACUTE	    EQU   25	       ;;
GRAVE_GRAVE	    EQU   26	       ;;
DIARESIS_DIARESIS   EQU   27	       ;;
CIRCUMFLEX_CIRCUMFLEX EQU 28	       ;;
FOURTH_SHIFT	    EQU   29	       ;;
DEAD_FOURTH	    EQU   30	       ;;
TILDE_LOWER	    EQU   31	       ;;
TILDE_UPPER	    EQU   32	       ;;
TILDE_SPACE	    EQU   33	       ;;
TILDE_TILDE	    EQU   34	       ;;
ALT_CASE	    EQU   35	       ;;
CTRL_CASE	    EQU   36	       ;;
NUMERIC_PAD	    EQU   37	       ;;
DIVIDE_SIGN	    EQU   38	       ;;
BOTLH_CAPS	    EQU   39	       ;;
BOTRH_CAPS	    EQU   40	       ;;
BOTLH_F_CAPS	    EQU   41	       ;;
BOTRH_F_CAPS	    EQU   42	       ;;
				       ;;
;************************************************
; Mihindu 11/30/90 - Added Eastern Europe support
;************************************************
CARON_SPACE	    EQU   43
CARON_LOWER	    EQU   44
CARON_UPPER	    EQU   45
BREVE_SPACE	    EQU   46
BREVE_LOWER	    EQU   47
BREVE_UPPER	    EQU   48
OVERCIRCLE_SPACE    EQU   49
OVERCIRCLE_LOWER    EQU   50
OVERCIRCLE_UPPER    EQU   51
OGONEK_SPACE	    EQU   52
OGONEK_LOWER	    EQU   53
OGONEK_UPPER	    EQU   54
OVERDOT_SPACE	    EQU   55
OVERDOT_LOWER	    EQU   56
OVERDOT_UPPER	    EQU   57
DOUBLEACUTE_SPACE   EQU   58
DOUBLEACUTE_LOWER   EQU   59
DOUBLEACUTE_UPPER   EQU   60

;******************************************************
;  M000 --- new state for KDFJP.ASM (Kermit)	*******
;******************************************************

DBCS_OLD_A	   EQU	 61		; M000 (JP9009)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Logic Macros
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
				       ;;

UNKNOWN = 255

FIND_FLAG MACRO  FLAG_MASK
       IFIDN <FLAG_MASK>,<SCAN_MATCH>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_SHIFT>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CAPS_STATE>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<NUM_STATE>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_CTL>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<EITHER_ALT>
	  FLAG_ID = EXT_KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<LEFT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<RIGHT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<ALT_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<CTL_SHIFT>
	  FLAG_ID = KB_FLAG_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_ALT_SHIFT>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<R_CTL_SHIFT>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
       IFIDN <FLAG_MASK>,<TILDE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<ACUTE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<GRAVE>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<DIARESIS>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CEDILLA>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CIRCUMFLEX>
	  FLAG_ID = NLS_FLAG_1_ID
       ELSE
       IFIDN <FLAG_MASK>,<CARON>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<BREVE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERCIRCLE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OGONEK>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<OVERDOT>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<DOUBLEACUTE>
	  FLAG_ID = NLS_FLAG_2_ID
       ELSE
       IFIDN <FLAG_MASK>,<LC_E0>
	  FLAG_ID = KB_FLAG_3_ID
       ELSE
	  FLAG_ID = UNKNOWN
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
FLAG MACRO  FLAG_MASK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on FLAG MACRO
	  ENDIF
       ELSE
	  DB FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on IFF MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on IFF MACRO
	  ENDIF
       ELSE
	  DB IFF_COMMAND+NOT_BIT+FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
IFKBD MACRO  SYS
       DB IFKBD_COMMAND
       DW SYS
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ANDF MACRO  FLAG_MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on ANDF MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       FIND_FLAG FLAG_MASK
       IF (FLAG_ID EQ UNKNOWN)
	  IF2
	      %OUT Unknown parameter FLAG_MASK on ANDF MACRO
	  ENDIF
       ELSE
	  DB ANDF_COMMAND+NOT_BIT+FLAG_ID
	  DB FLAG_MASK
       ENDIF
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ELSEF  MACRO
       DB  ELSEF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ENDIFF MACRO
       DB  ENDIFF_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
XLATT  MACRO STATE
       DB  XLATT_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
PUT_ERROR_CHAR	MACRO STATE
       DB  PUT_ERROR_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
OPTION MACRO MASK,MASK_TYPE
    MAC_OK = 1
    IFB  <MASK_TYPE>
	 NOT_BIT = 00000000B
    ELSE
	 IFIDN <MASK_TYPE>,<NOT>
	     NOT_BIT = 00001000B
	 ELSE
	     MAC_OK = 0
	     IF2
		 %OUT Unknown parameter MASK_TYPE on OPTION MACRO
	     ENDIF
	 ENDIF
    ENDIF
    IF MAC_OK
       DB  OPTION_COMMAND+NOT_BIT
       DB  MASK
    ENDIF
    ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
SET_FLAG  MACRO STATE
       DB  SET_FLAG_COMMAND
       DB  STATE
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
RESET_NLS  MACRO
       DB  RESET_NLS_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
BEEP   MACRO
       DB  BEEP_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
GOTO	MACRO GOTO_OFFSET
       DB  GOTO_COMMAND
       DW  GOTO_OFFSET-$-2
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_INT_9  MACRO
       DB  GOTO_COMMAND+EXIT_INT_9_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
EXIT_STATE_LOGIC  MACRO
       DB  GOTO_COMMAND+EXIT_STATE_LOGIC_FLAG
       DW  0
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CHECK_FOR_CORE_KEY MACRO
       DB  CHECK_CORE_COMMAND
       ENDM

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\kdfrh2.asm ===
PAGE    ,132
        TITLE   PC DOS 3.3 Keyboard Definition File

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; MS-DOS 5.0 - NLS Support - Keyboard Defintion File
;; (c) Copyright Microsoft Corp 1992.
;;
;; This file contains the keyboard tables for right single-handed key layout.
;;
;; Linkage Instructions:
;;      Refer to KDF.ASM.
;;
;;
;; Author:  Yuri Starikov - Microsoft WPG Ireland - September 1992
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
        INCLUDE KEYBSHAR.INC           ;;
        INCLUDE POSTEQU.INC            ;;
        INCLUDE KEYBMAC.INC            ;;
                                       ;;
        PUBLIC RH2_LOGIC                ;;
        PUBLIC RH2_437_XLAT             ;;
        PUBLIC RH2_850_XLAT             ;;
                                       ;;
CODE    SEGMENT PUBLIC 'CODE'          ;;
        ASSUME CS:CODE,DS:CODE         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Standard translate table options are a liner search table
;; (TYPE_2_TAB) and ASCII entries ONLY (ASCII_ONLY)
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
STANDARD_TABLE      EQU   TYPE_2_TAB+ASCII_ONLY
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; RH State Logic
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
                                       ;;
RH2_LOGIC:

   DW  LOGIC_END-$                     ;; length
                                       ;;
   DW  0                               ;; special features
                                       ;;
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; COMMANDS START HERE
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; OPTIONS:  If we find a scan match in
;; an XLATT or SET_FLAG operation then
;; exit from INT 9.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   OPTION EXIT_IF_FOUND                ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;  Dead key definitions must come before
;;  dead key translations to handle
;;  dead key + dead key.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   IFF  EITHER_ALT,NOT                 ;;
   ANDF EITHER_CTL,NOT                 ;;
      IFF EITHER_SHIFT                 ;;
          SET_FLAG DEAD_UPPER          ;;
      ELSEF                            ;;
          SET_FLAG DEAD_LOWER          ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; ACUTE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
ACUTE_PROC:                            ;;
                                       ;;
   IFF ACUTE,NOT                       ;;
      GOTO DIARESIS_PROC               ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT ACUTE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_LOWER       ;;
            ELSEF                      ;;
               XLATT ACUTE_UPPER       ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT ACUTE_UPPER       ;;
            ELSEF                      ;;
               XLATT ACUTE_LOWER       ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_ACUTE:                         ;;
      PUT_ERROR_CHAR ACUTE_LOWER       ;; If we get here then either the XLATT
      BEEP                             ;; failed or we are ina bad shift state.
      GOTO NON_DEAD                    ;; Either is invalid so BEEP and fall
                                       ;; through to generate the second char.
                                       ;; Note that the dead key flag will be
                                       ;; reset before we get here.
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; DIARESIS ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
DIARESIS_PROC:                         ;;
                                       ;;
   IFF DIARESIS,NOT                    ;;
      GOTO GRAVE_PROC                  ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT DIARESIS_SPACE          ;;  exist for 437 so beep for
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
         IFF EITHER_SHIFT              ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_LOWER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_UPPER    ;;
            ENDIFF                     ;;
         ELSEF                         ;;
            IFF CAPS_STATE             ;;
               XLATT DIARESIS_UPPER    ;;
            ELSEF                      ;;
               XLATT DIARESIS_LOWER    ;;
            ENDIFF                     ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
                                       ;;
INVALID_DIARESIS:                      ;;
      PUT_ERROR_CHAR DIARESIS_SPACE    ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; GRAVE ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
GRAVE_PROC:                            ;;
                                       ;;
   IFF GRAVE,NOT                       ;;
      GOTO CIRCUMFLEX_PROC             ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT GRAVE_SPACE             ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT GRAVE_LOWER        ;;
           ELSEF                       ;;
              XLATT GRAVE_UPPER        ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_GRAVE:                         ;;
      PUT_ERROR_CHAR GRAVE_LOWER       ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CIRCUMFLEX ACCENT TRANSLATIONS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
CIRCUMFLEX_PROC:                       ;;
                                       ;;
   IFF CIRCUMFLEX,NOT                  ;;
      GOTO NON_DEAD                    ;;
      ENDIFF                           ;;
                                       ;;
      RESET_NLS                        ;;
      IFF R_ALT_SHIFT,NOT              ;;
         XLATT CIRCUMFLEX_SPACE        ;;
      ENDIFF                           ;;
      IFF EITHER_CTL,NOT               ;;
      ANDF EITHER_ALT,NOT              ;;
        IFF EITHER_SHIFT               ;;
           IFF CAPS_STATE              ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ELSEF                          ;;
           IFF CAPS_STATE,NOT          ;;
              XLATT CIRCUMFLEX_LOWER   ;;
           ELSEF                       ;;
              XLATT CIRCUMFLEX_UPPER   ;;
           ENDIFF                      ;;
        ENDIFF                         ;;
      ENDIFF                           ;;
                                       ;;
INVALID_CIRCUMFLEX:                    ;;
      PUT_ERROR_CHAR CIRCUMFLEX_LOWER  ;; standalone accent
      BEEP                             ;; Invalid dead key combo.
      GOTO NON_DEAD                    ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Upper, lower and third shifts
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
NON_DEAD:                              ;;
                                       ;;
   IFKBD G_KB+P12_KB                   ;; Avoid accidentally translating
   ANDF LC_E0                          ;;  the "/" on the numeric pad of the
      EXIT_STATE_LOGIC                 ;;   G keyboard
   ENDIFF                              ;;
;;***BD ADDED FOR ALT, CTRL CASES      ;;
      IFF EITHER_CTL,NOT               ;;
         IFF  ALT_SHIFT                ;; ALT - case
         ANDF R_ALT_SHIFT,NOT          ;;
            XLATT ALT_CASE             ;;
         ENDIFF                        ;;
      ELSEF                            ;;
         IFF EITHER_ALT,NOT            ;; CTRL - case
            XLATT CTRL_CASE            ;;
         ENDIFF                        ;;
      ENDIFF                           ;;
;;***BD END OF ADDITION
                                       ;;
   IFF  EITHER_ALT,NOT                 ;; Lower and upper case.  Alphabetic
   ANDF EITHER_CTL,NOT                 ;; keys are affected by CAPS LOCK.
      IFF EITHER_SHIFT                 ;; Numeric keys are not.
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE,NOT            ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_UPPER        ;;
          IFF CAPS_STATE               ;;
              XLATT ALPHA_LOWER        ;;
          ELSEF                        ;;
              XLATT ALPHA_UPPER        ;;
          ENDIFF                       ;;
      ELSEF                            ;;
;;***BD ADDED FOR NUMERIC PAD
          IFF NUM_STATE                ;;
              XLATT NUMERIC_PAD        ;;
          ENDIFF                       ;;
;;***BD END OF ADDITION
          XLATT NON_ALPHA_LOWER        ;;
          IFF CAPS_STATE               ;;
             XLATT ALPHA_UPPER         ;;
          ELSEF                        ;;
             XLATT ALPHA_LOWER         ;;
          ENDIFF                       ;;
      ENDIFF                           ;;
   ELSEF                               ;;
      IFF EITHER_SHIFT,NOT             ;;
          IFKBD XT_KB+AT_KB      ;;
              IFF  EITHER_CTL          ;;
              ANDF ALT_SHIFT           ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
          ELSEF                        ;;
              IFF EITHER_CTL,NOT       ;;
              ANDF R_ALT_SHIFT         ;;
                  XLATT THIRD_SHIFT    ;;
              ENDIFF                   ;;
           ENDIFF                      ;;
      ENDIFF                           ;;
   ENDIFF                              ;;
                                       ;;
   EXIT_STATE_LOGIC                    ;;
                                       ;;
LOGIC_END:                             ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; RH Common Translate Section
;; This section contains translations for the lower 128 characters
;; only since these will never change from code page to code page.
;; In addition the dead key "Set Flag" tables are here since the
;; dead keys are on the same keytops for all code pages.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RH2_COMMON_XLAT                 ;;
RH2_COMMON_XLAT:                        ;;
                                       ;;
   DW    COMMON_XLAT_END-$             ;; length of section
   DW    -1                            ;; code page
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;;***BD - ADDED FOR ALT CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Alt Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_ALT_K2_END-$              ;; length of state section
   DB    ALT_CASE                      ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_ALT_K2_T1_END-$           ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    0                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,225,0                      ;; TEST ENTRY
COM_ALT_K2_T1_END:                     ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_ALT_K2_END:                        ;;
                                       ;;
;;******************************
;;***BD - ADDED FOR CTRL CASE
;;******************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Ctrl Case
;; KEYBOARD TYPES: G_KB+P12_KB+AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_CTRL_K2_END-$             ;; length of state section
   DB    CTRL_CASE                     ;; State ID
   DW    G_KB+P12_KB+AT_KB             ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_CTRL_K2_T1_END-$          ;; Size of xlat table
   DB    TYPE_2_TAB                    ;; xlat options:
   DB    2                             ;; number of entries
;;***BD THIS ENTRY IS A TEST ENTRY
;; DB    53,226,0                      ;; TEST ENTRY
   DB    43,-1,-1                      ;; invalid slash
   DB    41,28,41                      ;; valid slash
COM_CTRL_K2_T1_END:                    ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_CTRL_K2_END:                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K1_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '/'                     ;;
   DB    00CH, '['                     ;;
   DB    00DH, ']'                     ;;
   DB    010H, '5'                     ;;
   DB    011H, '6'                     ;;
   DB    013H, '.'                     ;;
   DB    01AH, ';'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '7'                     ;;
   DB    01FH, '8'                     ;;
   DB    028H, '-'                     ;;
   DB    02CH, '9'                     ;;
   DB    02DH, '0'                     ;;
   DB    02FH, ','                     ;;
   DB    035H, 027H                    ;;
COM_NA_LO_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: AT
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K2_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    AT_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K2_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '/'                     ;;
   DB    00CH, '['                     ;;
   DB    00DH, ']'                     ;;
   DB    010H, '5'                     ;;
   DB    011H, '6'                     ;;
   DB    013H, '.'                     ;;
   DB    01AH, ';'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '7'                     ;;
   DB    01FH, '8'                     ;;
   DB    028H, '-'                     ;;
   DB    02CH, '9'                     ;;
   DB    02DH, '0'                     ;;
   DB    02FH, ','                     ;;
   DB    035H, 027H                    ;;
COM_NA_LO_K2_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K2_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Lower Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_LO_K3_END-$               ;; length of state section
   DB    NON_ALPHA_LOWER               ;; State ID
   DW    XT_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_LO_K3_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '/'                     ;;
   DB    00CH, '['                     ;;
   DB    00DH, ']'                     ;;
   DB    010H, '5'                     ;;
   DB    011H, '6'                     ;;
   DB    013H, '.'                     ;;
   DB    01AH, ';'                     ;;
   DB    01BH, '='                     ;;
   DB    01EH, '7'                     ;;
   DB    01FH, '8'                     ;;
   DB    028H, '-'                     ;;
   DB    02CH, '9'                     ;;
   DB    02DH, '0'                     ;;
   DB    02FH, ','                     ;;
   DB    035H, 027H                    ;;
COM_NA_LO_K3_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_LO_K3_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: G_KB+P12_KB+
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K1_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '?'                     ;;
   DB    00CH, '{'                     ;;
   DB    00DH, '}'                     ;;
   DB    010H, '%'                     ;;
   DB    011H, '^'                     ;;
   DB    013H, '>'                     ;;
   DB    01AH, ':'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '&'                     ;;
   DB    01FH, '*'                     ;;
   DB    028H, '_'                     ;;
   DB    02CH, '('                     ;;
   DB    02DH, ')'                     ;;
   DB    02FH, '<'                     ;;
   DB    035H, '"'                     ;;
COM_NA_UP_T1_K1_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K1_END:                         ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: XT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K2_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    XT_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K2_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '?'                     ;;
   DB    00CH, '{'                     ;;
   DB    00DH, '}'                     ;;
   DB    010H, '%'                     ;;
   DB    011H, '^'                     ;;
   DB    013H, '>'                     ;;
   DB    01AH, ':'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '&'                     ;;
   DB    01FH, '*'                     ;;
   DB    028H, '_'                     ;;
   DB    02CH, '('                     ;;
   DB    02DH, ')'                     ;;
   DB    02FH, '<'                     ;;
   DB    035H, '"'                     ;;
COM_NA_UP_T1_K2_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K2_END:                         ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: Common
;; STATE: Non-Alpha Upper Case
;; KEYBOARD TYPES: AT_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    COM_NA_UP_K3_END-$               ;; length of state section
   DB    NON_ALPHA_UPPER               ;; State ID
   DW    AT_KB                         ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    COM_NA_UP_T1_K3_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    15                            ;; number of entries
   DB    00BH, '?'                     ;;
   DB    00CH, '{'                     ;;
   DB    00DH, '}'                     ;;
   DB    010H, '%'                     ;;
   DB    011H, '^'                     ;;
   DB    013H, '>'                     ;;
   DB    01AH, ':'                     ;;
   DB    01BH, '+'                     ;;
   DB    01EH, '&'                     ;;
   DB    01FH, '*'                     ;;
   DB    028H, '_'                     ;;
   DB    02CH, '('                     ;;
   DB    02DH, ')'                     ;;
   DB    02FH, '<'                     ;;
   DB    035H, '"'                     ;;
COM_NA_UP_T1_K3_END:                      ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
COM_NA_UP_K3_END:                      ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Lower Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_LO_END-$            ;; length of state section
   DB    ALPHA_LOWER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
                                       ;;
   DW    CPCOM_A_LO_K1_T01_END-$       ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    26                            ;; Number of entries
   DB    6, 'j'                        ;;   j
   DB    7, 'l'                        ;;   l
   DB    8, 'm'                        ;;   m
   DB    9, 'f'                        ;;   f
   DB    10, 'p'                       ;;   p
   DB    18, 'q'                       ;;   q
   DB    20, 'o'                           ;;   o
   DB    21, 'r'                           ;;   r
   DB    22, 's'                           ;;   s
   DB    23, 'u'                           ;;   u
   DB    24, 'y'                           ;;   y
   DB    25, 'b'                           ;;   b
   DB    32, 'z'                           ;;   z
   DB    33, 'a'                           ;;   a
   DB    34, 'e'                           ;;   e
   DB    35, 'h'                           ;;   h
   DB    36, 't'                           ;;   t
   DB    37, 'd'                           ;;   d
   DB    38, 'c'                           ;;   c
   DB    39, 'k'                           ;;   k
   DB    46, 'x'                           ;;   x
   DB    48, 'i'                           ;;   i
   DB    49, 'n'                           ;;   n
   DB    50, 'w'                           ;;   w
   DB    51, 'v'                           ;;   v
   DB    52, 'g'                           ;;   g
CPCOM_A_LO_K1_T01_END:           ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_LO_END:                      ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: COMMON
;; STATE: Alpha Upper Case
;; KEYBOARD TYPES: All
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CPCOM_A_K1_UP_END-$            ;; length of state section
   DB    ALPHA_UPPER                   ;; State ID
   DW    ANY_KB                        ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CPCOM_A_UP_K1_T01_END-$         ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    26                            ;; Number of entries
   DB    6, 'J'                        ;;   j
   DB    7, 'L'                        ;;   l
   DB    8, 'M'                        ;;   m
   DB    9, 'F'                        ;;   f
   DB    10, 'P'                       ;;   p
   DB    18, 'Q'                       ;;   q
   DB    20, 'O'                           ;;   o
   DB    21, 'R'                           ;;   r
   DB    22, 'S'                           ;;   s
   DB    23, 'U'                           ;;   u
   DB    24, 'Y'                           ;;   y
   DB    25, 'B'                           ;;   b
   DB    32, 'Z'                           ;;   z
   DB    33, 'A'                           ;;   a
   DB    34, 'E'                           ;;   e
   DB    35, 'H'                           ;;   h
   DB    36, 'T'                           ;;   t
   DB    37, 'D'                           ;;   d
   DB    38, 'C'                           ;;   c
   DB    39, 'K'                           ;;   k
   DB    46, 'X'                           ;;   x
   DB    48, 'I'                           ;;   i
   DB    49, 'N'                           ;;   n
   DB    50, 'W'                           ;;   w
   DB    51, 'V'                           ;;   v
   DB    52, 'G'                           ;;   g
CPCOM_A_UP_K1_T01_END:           ;;

                                       ;;
                                       ;;
   DW    0                             ;; Size of xlat table - null table
                                       ;;
CPCOM_A_K1_UP_END:                      ;;
                                       ;;
   DW    0                             ;; Last State
COMMON_XLAT_END:                       ;;
                                       ;;
                                       ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; RH Specific Translate Section for 437
;; 437 IS COMPLETELY COVERED BY THE COMMON TABLE.
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RH2_437_XLAT                    ;;
RH2_437_XLAT:                           ;;
                                       ;;
   DW     CP437_XLAT_END-$             ;; length of section
   DW     437                          ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP437
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP437_THIRD_K1_END-$            ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP437_THIRD_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    41,0DDH                       ;; Solid vertical bar - graphics block
CP437_THIRD_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP437_THIRD_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW     0                            ;; LAST STATE
                                       ;;
CP437_XLAT_END:                        ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;***************************************
;; RH Specific Translate Section for 850
;;***************************************
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
 PUBLIC RH2_850_XLAT                    ;;
RH2_850_XLAT:                           ;;
                                       ;;
   DW     CP850_XLAT_END-$             ;; length of section
   DW     850                          ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CODE PAGE: CP850
;; STATE: Third Shift
;; KEYBOARD TYPES: G_KB+P12_KB
;; TABLE TYPE: Translate
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                       ;;
   DW    CP850_THIRD_K1_END-$            ;; length of state section
   DB    THIRD_SHIFT                   ;; State ID
   DW    G_KB+P12_KB                   ;; Keyboard Type
   DB    -1,-1                         ;; Buffer entry for error character
                                       ;;
   DW    CP850_THIRD_K1_T1_END-$            ;; Size of xlat table
   DB    STANDARD_TABLE                ;; xlat options:
   DB    1                             ;; number of entries
   DB    41,07CH                       ;; Solid vertical bar - |
CP850_THIRD_K1_T1_END:                      ;;
                                       ;;
   DW    0                             ;; Last xlat table
CP850_THIRD_K1_END:                         ;;
                                       ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
   DW    0                             ;; LAST STATE
                                       ;;
CP850_XLAT_END:                        ;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
CODE     ENDS                          ;;
         END                           ;;

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\postequ.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;
; M024 MD 01/28/91      Added new keyboard commands
;
;----------------------------------------------------------------------------
;               EQUATES                 :
;----------------------------------------------------------------------------
TTEST           EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KY_LOCK         EQU     0               ; CONDITIONAL ASM (TEST2.SRC)
KEY_NUMS        EQU     0               ; CONDITIONAL ASM (KYBD.SRC)
;----------------------------------------------------------------------------
X287            EQU     0F0H            ; MATH PROCESSOR
;----------------------------------------------------------------------------
LOOP_POST       EQU     020H            ; MFG LOOP POST JUMPER
;----------------------------------------------------------------------------
REFRESH_BIT     EQU     010H            ; REFRESH TEST BIT
;----------------------------------------------------------------------------
POST_SS         EQU     0H              ; POST STACK SEGMENT
POST_SP         EQU     8000H           ; POST STACK POINTER
TEMP_STACK_LO   EQU     0FFFFH          ;
TEMP_STACK_HI   EQU     0               ; SET PROTECTED MODE TEMP_SS
                                        ; 0:FFFFH
;----------------------------------------------------------------------------
PORT_A          EQU     60H             ; 8042 KEYBOARD SCAN/DIAG OUTPUTS
PORT_B          EQU     61H             ; 8042 READ WRITE REGISTER
PARITY_ERR      EQU     0C0H            ; RAM/IO CHANNEL PARITY ERROR
RAM_PAR_ON      EQU     11110011B       ; AND THIS VALUE
RAM_PAR_OFF     EQU     00001100B       ; OR THIS VALUE
IO_CHK          EQU     01000000B       ; IO CHECK?
PRTY_CHK        EQU     10000000B       ; PARITY CHECK?

STATUS_PORT     EQU     64H             ;8042 STATUS PORT
OUT_BUF_FULL    EQU     01H             ; 0 = +OUTPUT BUFFER FULL
INPT_BUF_FULL   EQU     02H             ; 1 = +INPUT BUFFER FULL
SYS_FLAG        EQU     04H             ; 2 = -SYSTEM FLAG -POR/-SELF TEST
CMD_DATA        EQU     08H             ; 3 = -COMMAND/+DATA
KYBD_INH        EQU     10H             ; 4 = +KEYBOARD INHIBITED
TRANS_TMOUT     EQU     20H             ; 5 = +TRANSMIT TIMEOUT
RCV_TMOUT       EQU     40H             ; 6 = +RECEIVE TIME OUT
PARITY_EVEN     EQU     80H             ; 7 = +PARITY IS EVEN
SHUT_CMD        EQU     0FEH            ; CAUSE A SHUTDOWN COMMAND
INTR_FACE_CK    EQU     0ABH            ; CHECK 8042 INTERFACE CMD
KYBD_CLK_DATA   EQU     0E0H            ; GET KYBD CLOCK AND DATA CMD
KYBD_CLK        EQU     001H            ; KEYBOARD CLOCK BIT 0
;----------MANUFACTURING PORT------------------------------------------------
MFG_PORT        EQU     80H             ; MANUFACTURING CHECKPOINT PORT
;----------MANUFACTURING BIT DEFINITION FOR MFG_ERR_FLAG+1-------------------
MEM_FAIL        EQU     00000001B      ; STORAGE TEST FAILED (ERROR 20X)
PRO_FAIL        EQU     00000010B      ; VIRTUAL MODE TEST FAILED (ERROR 104)
LMCS_FAIL       EQU     00000100B      ; LOW MEG CHIP SELECT FAILED (ERROR 109)
KYCLK_FAIL      EQU     00001000B      ; KEYBOARD CLOCK TEST FAILED (ERROR 304)
KY_SYS_FAIL     EQU     00010000B      ; KEYBOARD OR SYSTEM FAILED (ERROR 303)
KYBD_FAIL       EQU     00100000B      ; KEYBOARD FAILED (ERROR 301)
DSK_FAIL        EQU     01000000B      ; DISKETTE TEST FAILED (ERROR 601)
KEY_FAIL        EQU     10000000B      ; KEYBOARD LOCKED (ERROR 302)
;----------8042 INPUT PORT BIT DEFINITION------------------------------------
BASE_RAM        EQU     10H             ;BASE R/W MEMORY
MFG_JMP         EQU     20H             ;LOOP POST JUMPER
DSP_JMP         EQU     40H             ;DISPLAY TYPE JUMPER
KEY_BD_INHIB    EQU     80H             ;KEYBOARD INHIBIT SWITCH
;----------8042 RAM DEFINITION-----------------------------------------------
INH_KEYBOARD    EQU     10H             ;BYTE 0 BIT 4 OF 8042 RAM
;-------------- COMMANDS ----------------------------------------------------
READ_8042_RAM   EQU     20H             ; BITS 0-4 = ADDRESS (20-3F)
WRITE_8042_RAM  EQU     60H             ;
SELF_8042_TEST  EQU     0AAH            ; 8042 SELF TEST
READ_8042_INPUT EQU     0C0H            ; READ 8042 INPUT PORT
ENA_KBD         EQU     0AEH            ; ENABLE KEYBOARD COMMAND
DIS_KBD         EQU     0ADH            ; DISABLE KEYBOARD COMMAND
ENABLE_BIT20    EQU     0DFH            ; ENABLE ADDR LINE BIT 20
DISABLE_BIT20   EQU     0DDH            ; DISABLE ADDR LINE BIT 20
ENABLE_AUX      EQU     0A8H            ; ENABLE AUX DEVICE COMMAND    ;M024
DISABLE_AUX     EQU     0A7H            ; DISABLE AUX DEVICE COMMAND   ;M024
;-------------- KEYBOARD/LED COMMANDS --------------------------------------
KB_MENU         EQU     0F1H            ; SELECT MENU COMMAND
KB_TYPA_RD      EQU     0F3H            ; SET TYPAMATIC RATE/DELAY         RWV 10-07-85
KB_ENABLE       EQU     0F4H            ; KEYBOARD ENABLE
KB_MAKE_BREAK   EQU     0F7H            ; TYPAMATIC
KB_ECHO         EQU     0FEH            ; ECHO COMMAND
KB_RESET        EQU     0FFH            ; SELF DIAGNOSTIC COMMAND
LED_CMD         EQU     0EDH            ; LED WRITE COMMAND
;--------------- KEYBOARD RESPONSE -----------------------------------------
KB_OK           EQU     0AAH            ; RESPONSE FROM SELF DIAG
KB_ACK          EQU     0FAH            ; ACKNOWLEDGE FROM TRANSMISSION
KB_OVER_RUN     EQU     0FFH            ; OVER RUN
KB_RESEND       EQU     0FEH            ; RESEND REQUEST
KB_BREAK        EQU     0F0H            ; KEYBOARD BREAK CODE
;-------------- CMOS EQUATES -------------------------------------------------
CMOS_PORT       EQU     070H            ; IO ADDRESS OF CMOS PORT
CLK_UP          EQU     08AH            ; CLOCK UPDATE STATUS
CMOS_ALARM      EQU     08BH            ;
CMOS_BEGIN      EQU     090H            ;
CMOS_END        EQU     0ADH            ;
SHUT_DOWN       EQU     08FH            ; SHUTDOWN OFFSET
BATTERY_COND_STATUS EQU 08DH            ; BATTERY STATUS
M_SIZE_HI       EQU     0B1H            ; IO MEMORY SIZE HIGH BYTE (POST)
M_SIZE_LO       EQU     0B0H            ; IO MEMORY SIZE LO BYTE   (POST)
M1_SIZE_HI      EQU     096H            ; 0->640K CONFIG MEMORY SIZE (SETUP)
M1_SIZE_LO      EQU     095H            ;   LOW BYTE (SETUP)
M2_SIZE_HI      EQU     098H            ; 640K->UP CONFIG MEMORY SIZE (SETUP)
M2_SIZE_LO      EQU     097H            ;   LOW BYTE (SETUP)
C_EQUIP         EQU     094H            ; CMOS EQUIPMENT FLAG
HD_FILE_TYPE    EQU     092H            ; HARD FILE TYPE BYTE
PAGE
;--------------- CMOS DIAG_STATUS ERROR FLAGS--------------------------------
DIAG_STATUS     EQU     08EH            ; CMOS ADDRESS OF DIAG_STATUS
BAD_BAT         EQU     080H            ; DEAD BATTERY
BAD_CKSUM       EQU     040H            ; CHECKSUM ERROR
BAD_CONFIG      EQU     020H            ; MINIMUM CONFIG USED INSTEAD OF CMOS
W_MEM_SIZE      EQU     010H            ; MEMORY SIZE NOT EQUAL TO CONFIG
HF_FAIL         EQU     008H            ; HARD FILE FAILURE ON INIT
CMOS_CLK_FAIL   EQU     004H            ; CMOS CLK NOT UPDATING OR NOT VALID
;--------------- CMOS INFORMATION FLAGS--------------------------------------
INFO_STATUS     EQU     0B3H            ; CMOS ADDRESS OF INFO BYTE
M640K           EQU     080H            ; 512K -> 640K CARD INSTALLED
NEW_INST        EQU     040H            ; FLAG USED BY CMOS SETUP UTILITY
HF_BOOT         EQU     020H            ; BOOT HARD FILE FLAG
;--------------- INTERRUPT EQUATES ------------------------------------------
INTA00          EQU     20H             ; 8259 PORT
INTA01          EQU     21H             ; 8259 PORT
EOI             EQU     20H
INTB00          EQU     0A0H            ; 2ND 8259
INTB01          EQU     0A1H            ;
INT_TYPE        EQU     070H            ; START OF 8259 INTERRUPT TABLE LOCATION
INT_VIDEO       EQU     010H            ; VIDEO VECTOR
;---------------------------------------------------------------------------
TIMER           EQU     40H
TIM_CTL         EQU     43H             ; 8253 TIMER CONTROL PORT ADDR
TIMER0          EQU     40H             ; 8253 TIMER/CNTER 0 PORT ADDR
TMINT           EQU     01              ; TIMER 0 INTR RECVD MASK
;--------------------------------------------------------------------------
DMA08           EQU     08              ; DMA STATUS REG PORT ADDR
DMA             EQU     00              ; DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA18           EQU     0D0H            ; 2ND DMA STATUS PORT ADDR
DMA1            EQU     0C0H            ; 2ND DMA CH.0 ADDR. REG PORT ADDR
;--------------------------------------------------------------------------
DMA_PAGE        EQU     81H             ; START OF DMA PAGE REGISTERS
LAST_DMA_PAGE   EQU     8FH             ; LAST DMA PAGE REGISTER
;--------------------------------------------------------------------------
MAX_PERIOD      EQU     540H
MIN_PERIOD      EQU     410H
KBD_IN          EQU     60H             ; KEYBOARD DATA IN ADDR PORT
KBDINT          EQU     02              ; KEYBOARD INTR MASK
KB_DATA         EQU     60H             ; KEYBOARD SCAN CODE PORT
KB_CTL          EQU     61H             ; CONTROL BITS FOR KEYBOARD SENSE DATA
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG
INS_STATE       EQU     80H             ; INSERT STATE IS ACTIVE
CAPS_STATE      EQU     40H             ; CAPS LOCK STATE HAS BEEN TOGGLED
NUM_STATE       EQU     20H             ; NUM LOCK STATE HAS BEEN TOGGLED
SCROLL_STATE    EQU     10H             ; SCROLL LOCK STATE HAS BEEN TOGGLED
ALT_SHIFT       EQU     08H             ; ALTERNATE SHIFT KEY DEPRESSED
CTL_SHIFT       EQU     04H             ; CONTROL SHIFT KEY DEPRESSED
LEFT_SHIFT      EQU     02H             ; LEFT SHIFT KEY DEPRESSED
RIGHT_SHIFT     EQU     01H             ; RIGHT SHIFT KEY DEPRESSED
;----- SHIFT FLAG EQUATES WITHIN KB_FLAG_1
INS_SHIFT       EQU     80H             ; INSERT KEY IS DEPRESSED
CAPS_SHIFT      EQU     40H             ; CAPS LOCK KEY IS DEPRESSED
NUM_SHIFT       EQU     20H             ; NUM LOCK KEY IS DEPRESSED
SCROLL_SHIFT    EQU     10H             ; SCROLL LOCK KEY IS DEPRESSED
HOLD_STATE      EQU     08H             ; SUSPEND KEY HAS BEEN TOGGLED
SYS_SHIFT       EQU     04H             ; SYSTEM KEY DEPRESSED AND HELD
L_ALT_SHIFT     EQU     02H             ; LEFT ALT KEY DOWN                RWV 8-28-85
L_CTL_SHIFT     EQU     01H             ; LEFT CTL KEY DOWN                RWV 8-28-85
;---------------FLAGS WITHIN KB_FLAG_2
KB_ERR          EQU     80H             ; KEYBOARD TRANSMIT ERROR FLAG
KB_PR_LED       EQU     40H             ; MODE INDICATOR UPDATE
KB_FE           EQU     20H             ; RESEND RECEIVED FLAG
KB_FA           EQU     10H             ; ACK RECEIVED
CIRCUS_SYSTEM   EQU     08H             ; CIRCUS SYSTEM INDICATOR
KB_LEDS         EQU     07H             ; KEYBOARD LED STATE BITS
;                       04H             ; CAPS LOCK INDICATOR
;                       02H             ; NUM LOCK INDICATOR
;                       01H             ; SCROLL LOCK INDICATOR
;---------------FLAGS WITHIN KB_FLAG_3
RD_ID           EQU     80H             ; DOING A READ ID (MUST BE BIT0)   AEV
LC_AB           EQU     40H             ; LAST CHAR WAS FIRST ID CHAR      AEV
SET_NUM_LK      EQU     20H             ; FORCE NUM LOCK IF RD ID & KBX    AEV
KBX             EQU     10H             ; ENHANCED KEYBOARD INSTALLED      RWV 7-18-85
R_ALT_SHIFT     EQU     08H             ; RIGHT ALT KEY DOWN               RWV 7-18-85
GRAPH_ON        EQU     08H             ; ALT GRAPHICS KEY DOWN (WT ONLY)  AEV
R_CTL_SHIFT     EQU     04H             ; RIGHT CTL KEY DOWN               RWV 7-18-85
LC_E0           EQU     02H             ; LAST CODE WAS THE E0 HIDDEN CODE RWV 7-18-85
LC_E1           EQU     01H             ; LAST CODE WAS THE E1 HIDDEN CODE RWV 7-18-85
;----- SCAN CODE EQUATES FOR THE KEYBOARD
NUM_KEY         EQU     69              ; SCAN CODE FOR NUMBER LOCK
SCROLL_KEY      EQU     70              ; SCAN CODE FOR SCROLL LOCK
ALT_KEY         EQU     56              ; SCAN CODE FOR ALTERNATE KEY
CTL_KEY         EQU     29              ; SCAN CODE FOR CONTROL KEY
CAPS_KEY        EQU     58              ; SCAN CODE FOR SHIFT LOCK
LEFT_KEY        EQU     42              ; SCAN CODE FOR LEFT SHIFT
RIGHT_KEY       EQU     54              ; SCAN CODE FOR RIGHT SHIFT
INS_KEY         EQU     82              ; SCAN CODE FOR INSERT KEY
DEL_KEY         EQU     83              ; SCAN CODE FOR DELETE KEY
SYS_KEY         EQU     84              ; SCAN CODE FOR SYSTEM KEY
;-------------- ENHANCED KEYBOARD EQUATES
ID_1            EQU     0ABH            ; 1ST ID CHAR FOR KBX
ID_2            EQU     041H            ; 2ND ID CHAR FOR KBX              AEV
ID_2A           EQU     054H            ; ALTERNATE 2ND ID CHAR FOR KBX    RWV 8-16-85
F11_M           EQU     87              ; F11 KEY MAKE
F12_M           EQU     88              ; F12 KEY MAKE
MC_E0           EQU     224             ; GENERAL MARKER CODE
MC_E1           EQU     225             ; PAUSE KEY MARKER CODE

;-------------- DISKETTE EQUATES
INT_FLAG        EQU     080H            ; INTERRUPT OCCURRENCE FLAG
MOTOR_WAIT      EQU     37              ; 2 SECS OF COUNTS FOR MOTOR TURN OFF
TIME_OUT        EQU     80H             ; ATTACHMENT FAILED TO RESPOND
BAD_SEEK        EQU     40H             ; SEEK OPERATION FAILED
BAD_NEC         EQU     20H             ; NEC CONTROLLER HAS FAILED
BAD_CRC         EQU     10H             ; BAD CRC ON DISKETTE READ
DMA_BOUNDARY    EQU     09H             ; ATTEMPT TO DMA ACROSS 64K BOUNDARY
BAD_DMA         EQU     08H             ; DMA OVERRUN ON OPERATION
MEDIA_CHANGE    EQU     06H             ; MEDIA REMOVED ON DUAL ATTACH CARD
RECORD_NOT_FND  EQU     04H             ; REQUESTED SECTOR NOT FOUND
WRITE_PROTECT   EQU     03H             ; WRITE ATTEMPTED ON WRITE PROT DISK
BAD_ADDR_MARK   EQU     02H             ; ADDRESS MARK NOT FOUND
BAD_CMD         EQU     01H             ; BAD COMMAND PASSED TO DISKETTE I/O

XRATE           EQU     02H             ; 250KBS DATA TRANSFER RATE
DUAL            EQU     01H             ; DUAL ATTACH CARD PRESENT FLAG

DSK_CHG         EQU     080H            ; DISKETTE CHANGE FLAG MASK BIT
STATE_MSK       EQU     007H            ; USED TO STRIP OFF STATE OF MEDIA
REV_STATE       EQU     0F8H            ; USED AS MASK FOR STATE BITS
DETERMINED      EQU     010H            ; SET STATE DETERMINED IN STATE BITS
TRAN_MSK        EQU     03H             ; ISOLATE SHIFTED TRANSFER RATE BITS
DOUBLE_STEP     EQU     020H            ; MASK TO TURN ON DOUBLE STEPPING
MOTOR_MSK       EQU     0F0H            ; MASK TO CLEAR MOTOR ON BITS
MAX_DRV         EQU     002H            ; MAX NUMBER OF DRIVES
;HOME            EQU     010H            ; TRACK 0 MASK
SENSE_DRV_ST    EQU     004H            ; SENSE DRIVE STATUS COMMAND
ONE             EQU     001H            ; SEEK ONE TRACK
TRK_SLAP        EQU     030H            ; CRASH STOP (48 TPI DRIVES)
QUIET_SEEK      EQU     00AH            ; SEEK TO TRACK 10
HD12_SETTLE     EQU     015D            ; 1.2 M HEAD SETTLE TIME
HD320_SETTLE    EQU     020D            ; 320 K HEAD SETTLE TIME
WRITE_OP        EQU     080H            ; WRITE OPERATION FLAG
DD_MASK         EQU     010H            ; MASK TO INDICATE DRIVE IS 80 TRACKS
PAGE
;------ DISK CHANGE LINE EQUATES
NOCHGLN         EQU     001H            ; NO DISK CHANGE LINE AVAILABLE
CHGLN           EQU     002H            ; DISK CHANGE LINE AVAILABLE
;------ MEDIA/DRIVE STATE INDICATORS
M326D326        EQU     093H            ; STATE MACHINE - 320/360 MEDIA/DRIVE
M326D12         EQU     074H            ; STATE MACHINE - 320/360 MEDIA,1.2DRIVE
M12D12          EQU     015H            ; STATE MACHINE - 1.2 MEDIA/DRIVE
POA_DUAL        EQU     061H            ; 300K DATA TRANSFER RATE & STATE 1
POA_START       EQU     080H            ; 250K DATA TRANSFER RATE & STATE 0
TRK_80          EQU     008H            ; DISKETTE DRIVE HAS 80 TRACKS
;------ CMOS NON-VOLATILE RAM EQUATES
CMOSDSB_ADDR    EQU     00EH            ; DISKETTE STATUS BYTE ADDRESS
CADR_PRT        EQU     070H            ; CMOS ADDRESS PORT ADDRESS
CDATA_PRT       EQU     071H            ; CMOS DATA PORT ADDRESS
CMOS_GOOD       EQU     0C0H            ; BATTERY AND CHECKSUM INDICATOR
CMOSDSK_BYTE    EQU     010H            ; DISKETTE BYTE ADDRESS
LOWNIB          EQU     00FH            ; ISOLATE LOW NIBBLE IN REGISTER MASK
INVALID_DRV     EQU     002H            ; FIRST INVALID DISKETTE TYPE
;----------------------------------------
;       TIMER DATA AREA                 :
;----------------------------------------
; COUNTS_SEC    EQU     18
; COUNTS_MIN    EQU     1092
; COUNTS_HOUR   EQU     65543
; COUNTS_DAY    EQU     1573040 = 1800B0H
PAGE

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\access\dvorak\keybshar.inc ===
.XLIST

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; (C) Copyright Microsoft Corp. 1987-1991
;; MS-DOS 5.00 - NLS Support - KEYB Command
;;
;; File Name:  KEYBSHAR.INC
;; ----------
;;
;; Description:
;; ------------
;;	 Include file containing structure definitions Shared Data Area
;;	 for the Shared Data Area.
;;	 The Shared Data Area contains data which is required by
;;	 both the resident and transient KEYB code.  The Shared
;;	 Data Area is allocated in the KEYBI2F file and will be
;;	 resident following initial installation.
;;
;; Change History:
;; ---------------
;;
;; ;jwg  ; - Feb 1990 For 4.03.
;; ;AN007; -	       Add Patriot/Sebring determination code for HOT Replug
;;			so that INT 9 handler can alter keyboard Scan Code set.
;; ;M030		Merged IBM (Kermit - JP), KEYBOARD.SYS and KEYB.COM
;;			  versions of this file into one.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; SHARED_DATA_STR defines the initial fixed length portion of the
;; Shared Data Area.
;; Tables are loaded beginning at TABLE_AREA in the following order:
;;  State Logic
;;  Common Translate Section
;;  Specific Translate Sections for
;;   each code page
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;; SPECIAL_FEATURES equates:
TYPEWRITER_CAPS_LK  EQU    8000H	;; typewriter style caps lock
					;;
JR_HOT_KEY_1_2	equ	4000h		;; M030 Merged back for kdfcf.asm
JR_KB		equ	8000h		;; M030 Merged back for kdfcf.asm
					;; Some useful scan codes:
F1_SCAN     EQU   59			;; F1
F2_SCAN     EQU   60			;; F2
					;;
					;;	SYSTEM_FLAG / Hardware equates:
					;;   INT 16h and remote support
EXT_16		EQU	8000H		;; extended INT 16h support is there
EXT_122 	EQU	4000H		;; extended INT 16h for 122 is there
;		EQU	2000H		;;  unused
PC_NET		EQU	1000H		;; flag PC Net is installed
					;;   System type/hardware support flags
PC_81		EQU	0800H		;; flag for Original PC
PC_XT		EQU	0400H		;; code for PC, PC/XT, PORTABLE
PC_LAP		EQU	0200H		;; code for Convertiable (p-12)
PC_PAL		EQU	0080H		;; code for Model 30 (PALACE)
PC_AT		EQU	0040H		;; code for PC-AT  with 8042
PC_386		EQU	0020H		;; code for PS/2's with 8042 (WRANGLER)
PS_8042 	EQU	0010H		;; 8042 is a Patriot/Sebring type array;AN007;jwg
					;;  or system set translate OFF (SCS=01)
SECURITY_ACTIVE	EQU	0008h	; M030	;; Server password mode is active
;				; M030	;;  This bit becomes off from on when
;				; M030	;;  correct password is entered JP9010
					;;
					;; HOT_KEY_FLAG EQUATES:
US_MODE     EQU   0			;;  hot key is active => US
LANG_MODE   EQU   0FFH			;;  hot key is inactive
					;;
					;; -----------------------------------
SHARED_DATA_STR     STRUC		;; SHARED DATA AREA
					;;
OLD_INT_9	    DD	  0		;; saved int 9 vector
OLD_INT_2F	    DD	  0		;; saved int 2F vector
		    dd    0		;; reserved
KEYB_TYPE	    DW	  0		;; type of keyboard
SYSTEM_FLAG	    DW	  0		;; system configuration flags
TABLE_OK	    DB	  0		;; flag to INT 9 that table is built
		    db    5 dup (0)	;; reserved
					;;
					;; Table copy begins here:
ACTIVE_LANGUAGE     DB	  'US'          ;; language code
INVOKED_CP_TABLE    DW	  437		;; ptr to table for invoked code page
INVOKED_KBD_ID	    DW	  0		;; WGR invoked keyboard id.	       ;AN000
ACTIVE_XLAT_PTR     DW	  -1		;; ptr to active Specific Translate Sect
FIRST_XLAT_PTR	    DW	  -1		;; ptr to first Specific Translate Sect
RESIDENT_END	    DW	  0ffffh	;; offset of last byte in resident mem
LOGIC_PTR	    DW	  -1		;; ptr to State Logic
COMMON_XLAT_PTR     DW	  -1		;; ptr to Common Translate Section
SPECIAL_FEATURES    DW	  ?		;; special Features
TABLE_OVERFLOW	    DB	  0		;; overflow flag for table rebuild
HOT_KEY_ON_SCAN     DB	  ?		;; scan codes to use with ALT+CTRL
HOT_KEY_OFF_SCAN    DB	  ?		;;  to turn hot key on and off
		    DB	  4 DUP(0)	;; reserved
TABLE_AREA	    DB	  ?		;; tables loaded here:
					;;  State Logic
					;;  Common Translate Section
					;;  Specific Translate Sections for
					;;   each code page
SHARED_DATA_STR     ENDS		;;
					;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State Logic equates.
;; Contains equates for our NLS Flags and for the State Logic
;; commands.
;; State Logic command macros are defined in KEYBMAC.INC
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_LOGIC_STR STRUC			;;
					;;
SL_LOGIC_LEN	DW   ?			;; length of state logic
SL_SPECIAL_FEATURES   DW   ?		;;
SL_LOGIC_CMDS	DB   0			;; state logic commands begin here
					;;
STATE_LOGIC_STR ENDS			;;
					;;
					;;
NUM_BIOS_FLAGS	    EQU   4		;;
NUM_NLS_FLAGS	    EQU   2		;; '+1' below is the EXT_KB_FLAG
NUM_FLAGS	    EQU   NUM_BIOS_FLAGS+NUM_NLS_FLAGS+1
					;;
					;;
EITHER_SHIFT	    EQU   80H		;; EXT_KB_FLAG : our own shift state
EITHER_CTL	    EQU   40H		;;  flags
EITHER_ALT	    EQU   20H		;;
SCAN_MATCH	    EQU   08H		;; set if scan code found in XLATT
					;; or SET_FLAG searches
					;;
					;;
KB_FLAG_ID	    EQU   0		;; Flag ID's as coded in IFF and ANDF
KB_FLAG_1_ID	    EQU   1		;;  commands
KB_FLAG_2_ID	    EQU   2		;;
KB_FLAG_3_ID	    EQU   3		;;
EXT_KB_FLAG_ID	    EQU   4		;;
NLS_FLAG_1_ID	    EQU   5		;;
NLS_FLAG_2_ID	    EQU   6		;;
					;;
COMMAND_BITS	    EQU   0F0H		;; Mask to isolate command code
SUB_CMD_BITS	    EQU   0FH		;; mask to isolate sub command code
NOT_TEST	    EQU   08H		;; NOT bit in IFF, ANDF
COMMAND_SHIFT	    EQU   4		;; shift amount for command code
FLAG_ID_BITS	    EQU   07H		;; mask to isolate flag id in IFF, ANDF
NUM_COMMANDS	    EQU   0CH		;; number of commands
					;;
IFF_COMMAND	    EQU   00H		;;
ANDF_COMMAND	    EQU   10H		;;
ELSEF_COMMAND	    EQU   20H		;;
ENDIFF_COMMAND	    EQU   30H		;;
XLATT_COMMAND	    EQU   40H		;;
OPTION_COMMAND	    EQU   50H		;;
SET_FLAG_COMMAND    EQU   60H		;;
PUT_ERROR_COMMAND   EQU   70H		;;
IFKBD_COMMAND	    EQU   80H		;;
GOTO_COMMAND	    EQU   90H		;;
BEEP_COMMAND	    EQU   0A0H		;;
RESET_NLS_COMMAND   EQU   0B0H		;;
CHECK_CORE_COMMAND  EQU   0C0H		;;
					;;
					;;
EXIT_INT_9_FLAG 	EQU  01H	;; Special forms of GOTO.  These
EXIT_STATE_LOGIC_FLAG	EQU  02H	;;  values are in the right nibble
					;;   of the GOTO command.
					;;
					;; PROCESSING OPTIONS:
EXIT_IF_FOUND	    EQU   80H		;; exit INT 9 if a translation
					;;  match is found
					;;
ANY_KB		     EQU   0FFFFH	;;
XT_KB		     EQU   4000H	;;
AT_KB		     EQU   2000H	;;
G_KB		     EQU   1000H	;;
P_KB		     EQU   0800H	;;
P12_KB		     EQU   0400H	;;
DBCS_OLD_A_KB	     EQU   0080H ; M030	;; JP9009
DBCS_OLD_P_KB	     EQU   0040H ; M030	;; JP9009
DBCS_OLD_G_KB	     EQU   0020H ; M030	;; JP9009
DBCS_OLD_KB	     EQU   00C0H ; M030	;; JP9009
DBCS_KB		     EQU   0020H ; M030	;; JP9009
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table Sections.  Both the Specific and Common
;; Translate Sections are formatted as follows.
;;
;; The Specific Translate Sections are chained together using the
;; XS_NEXT_SECT_PTR field (-1 if last section).
;; Translate Sections contains multiple States.
;; A State contains the translate tables for a single
;; shift state (IE lower case, upper case ....)
;; Each State may contain multiple translate tables.
;;
;; The Translate Section layout is defined using several STRUCs.
;; These STRUCs are allocated in the Shared Data Area as follows:
;;
;;	 XLAT_SECT_STR		  ; header info for the section
;;	    STATE_STR		  ; header for state #1
;;	      XLAT_STR		  ;   first translate tab for state #1
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      XLAT_STR		  ;   second translate tab
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	    STATE_STR		  ; header for state #2
;;	      XLAT_STR
;;	      XLAT_TYPE_1_STR or XLAT_TYPE_2_STR
;;	      ...
;;	   ...
;;
;; A State may contain a "Set_Flag" table instead of translate tables.
;; These tables are used to set the NLS flags instead of generating
;; ASCII codes (for example: to remember dead key states).
;; There can be only on Set_Flag table per state.
;; The Set_Flag table layout is defined in the SET_FLAG_STR STRUC.
;;
;; So some states will contain translate tables (to generate ASCII codes)
;; and some states will contain a Set_Flag table (to record dead key
;; status).
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
XLAT_SECT_STR	    STRUC		;;
					;;
XS_NEXT_SECT_PTR       DW    ?		;; Pointer to next Specific Translate
					;;  Section
XS_CP_ID	       DW    ?		;; code page id
XS_FIRST_STATE	       DB    ?		;;
					;;
XLAT_SECT_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; State structure.
;; The last State is a null State containing only the
;; XS_STATE_LEN field with a value of 0.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
STATE_STR	    STRUC		;;
					;;
XS_STATE_LEN	 DW    ?		;; length of state section
XS_STATE_ID	 DB    ?		;; State ID
XS_KBD_TYPE	 DW    ?		;; Keyboard Type
XS_ERROR_CHAR	 DW    ?		;; Buffer entry for error character
XS_FIRST_TAB	 DB    ?		;;
					;;
STATE_STR	    ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Translate Table structures.
;; There may be many translate tables in a State.  The last
;; table is a null table containing only the XLAT_TAB_SIZE field with
;; a value of 0.
;; The xlate table can be in one of two forms:
;;    Type 1 = Table contains buffer entries only.
;;	       Scan code is used as an index into xlat table
;;    Type 2 = Table contains pairs of SCAN/BUFFER_ENTRY.
;;	       Table must be searched for matching scan.
;; Type 1 is the default.  Type 2 tables should be identified by setting
;; the TYPE_2_TAB bit in XLAT_OPTIONS.
;; Buffer entries default to 2-bytes per entry.
;; Optionally the table may contain ASCII codes only
;; (1-byte entries).  This is specified by setting the ASCII_ONLY bit
;; in XLAT_OPTIONS.  2-byte buffer entries are coded ASCII,SCAN.
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
					;; Translate options:
ASCII_ONLY	    EQU   80H		;; Only ASCII codes listed - use
					;;  incoming scan for buffer entry
TYPE_2_TAB	    EQU   40H		;; search xlat table for matching scan
ZERO_SCAN	    EQU   20H		;; set the scan half of the buffer
					;;  entry to 0
					;;
NULL_ASCII_CODE     EQU   -1		;;
					;;
DEFAULT_TAB_2_ENT_SZ   EQU   3		;;
ASC_ONLY_TAB_2_ENT_SZ  EQU   2		;;
					;;
					;;
XLAT_STR	    STRUC		;;
					;;
XLAT_TAB_SIZE	    DW	  ?		;; Size in bytes of this table -
					;;  includes this field, options etc.
XLAT_OPTIONS	    DB	  ?		;; xlat options
					;; XLAT TABLE IS HERE
XLAT_STR	    ENDS		;;
					;;
XLAT_TYPE_1_STR     STRUC		;; use scan code as index into table
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_SCAN_LO	    DB	  ?		;; Scan code
XLAT_SCAN_HI	    DB	  ?		;;  range
XLAT_1_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_1_STR     ENDS		;;
					;;
XLAT_TYPE_2_STR     STRUC		;; search table for scan
		    DB TYPE XLAT_STR DUP(?)   ;; filler
XLAT_NUM	    DB	  ?		;; number of scans
XLAT_SCAN	    DB	  ?		;; Scan code
XLAT_2_BUF_ENTRY    DB	  ?		;; The table itself
XLAT_TYPE_2_STR     ENDS		;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Set_Flag Tables.
;; State Sections immediately following the LAST_ENTRYs.
;; Dead key definitions.  If the scan matches then
;; set the bit in NLS_FLAGs indicated in DK_MASK
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
					;;
SF_ENT_SZ     EQU   3			;; size of entry
					;;
SET_FLAG_STR	    STRUC		;;
					;;
SF_NUM		    DB	  0		;; Number of entries
SF_SCAN_CODE	    DB	  0		;; scan code
SF_FLAG_ID	    DB	  0		;; flag id
SF_FLAG_MASK	    DB	  0		;; flag mask
					;;
SET_FLAG_STR	    ENDS		;;
					;;
					;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
.LIST

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\config.inc ===
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1981-1991
;       All Rights Reserved.
;
;       Internal CONFIG.SYS constants, structures, etc.
;

CONFIG_BEGIN        =   '['
CONFIG_BREAK        =   'C'
CONFIG_BUFFERS      =   'B'
CONFIG_COMMENT      =   'Y'
CONFIG_COUNTRY      =   'Q'
CONFIG_DEVICE       =   'D'
CONFIG_DEVICEHIGH   =   'U'
CONFIG_DOS          =   'H'
CONFIG_DRIVPARM     =   'P'
CONFIG_FCBS         =   'X'
CONFIG_FILES        =   'F'
CONFIG_INCLUDE      =   'J'
CONFIG_INSTALL      =   'I'
CONFIG_INSTALLHIGH  =   'W'
CONFIG_LASTDRIVE    =   'L'
CONFIG_MENUCOLOR    =   'R'
CONFIG_MENUDEFAULT  =   'A'
CONFIG_MENUITEM     =   'E'
CONFIG_MULTITRACK   =   'M'
CONFIG_NUMLOCK      =   'N'
CONFIG_REM          =   '0'
CONFIG_SEMICOLON    =   ';'
CONFIG_SET          =   'V'
CONFIG_SHELL        =   'S'
CONFIG_STACKS       =   'K'
CONFIG_SUBMENU      =   'O'
CONFIG_SWITCHES     =   '1'

CONFIG_UNKNOWN      =   'Z'

CONFIG_OPTION_QUERY =   80h
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\devmark.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
;structure, equtes for devmark for mem command.

devmark struc
devmark_id	  db	  0
devmark_seg	  dw	  0
devmark_size	  dw	  0
devmark_dum	  db	  3 dup (?)
devmark_filename  db	  8 dup (' ')
devmark ends

devmark_stk	equ	'S'
devmark_device	equ	'D'
devmark_ifs	equ	'I'
devmark_buf	equ	'B'
devmark_cds	equ	'L' ;lastdrive
devmark_files	equ	'F'
devmark_fcbs	equ	'X'
devmark_inst	equ	'T' ;used for sysinit base for install= command.
devmark_ems_stub equ	'E'

setbrkdone	equ	00000001b
for_devmark	equ	00000010b
not_for_devmark equ	11111101b

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\inc.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
TITLE	FILE - Listing of DOS .INC files

include dosseg.inc

CODE	SEGMENT
	ASSUME	SS:DOSGroup,CS:DOSGroup

include dossym.inc
include devsym.inc

include arena.inc
include biostruc.inc
include bootform.inc
include bpb.inc
include copyrigh.inc
include cpmfcb.inc
include cputype.inc
include curdir.inc
include devmark.inc
include doscntry.inc
include dpb.inc
include ea.inc
include exe.inc
include filemode.inc
include find.inc
include intnat.inc
include ioctl.inc
include mi.inc
include msbds.inc
include msdskpr.inc
include msequ.inc
include msgroup.inc
include mult.inc
include pdb.inc
include sf.inc
include smifssym.inc
include syscall.inc
include sysvar.inc
include vector.inc
include version.inc

CODE ENDS
END


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\biosseg.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
; BIOSSEG.INC
;
; This file defines the segment structure of the BIOS.
; It should be included at the beginning of each source file.
; All further segment declarations in the file can then be done by just
; by specifying the segment name, with no attribute, class, or align type.


datagrp	group	Bios_Data,Bios_Data_Init


IFNDEF ROMDOS

Bios_Data	segment	word public 'Bios_Data'
Bios_Data	ends

Bios_Data_Init	segment word public 'Bios_Data_Init'
Bios_Data_Init	ends

Filler		segment para public 'Filler'
Filler		ends

Bios_Code	segment word public 'Bios_Code'
Bios_Code	ends

Filler2		segment para public 'Filler2'
Filler2		ends

SysInitSeg	segment word public 'system_init'
SysInitSeg	ends



ELSE

; different segment order for ROMDOS

Bios_Data	segment	word public 'Bios_Data'
Bios_Data	ends

Bios_Data_Init	segment word public 'Bios_Data_Init'
Bios_Data_Init	ends

Filler		segment para public 'Filler'
Filler		ends

SysInitSeg	segment word public 'system_init'
SysInitSeg	ends

Filler2		segment para public 'Filler2'
Filler2		ends

Bios_Code	segment word public 'Bios_Code'
Bios_Code	ends



ENDIF


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\apmequ.inc ===
;**************************************************************
;*  APMEQU.INC - Include file for APM 
;*
;*  Microsoft Confidential
;*  Copyright (C) Microsoft Corporation 1991
;*  All Rights Reserved.
;*
;*  Revision History:
;*  ----------------
;*  08/1/91  NSM	Created
;*
;**************************************************************
;
;*************************************************************
; APM function codes 
;*************************************************************
;
APM_INSTALLCHK_FUNC	equ	5300h
;
APM_CONNECT_FUNC	equ	5301h	; real mode connect
APM_DISCONNECT_FUNC	equ	5304h
;
APM_CPUIDLE_FUNC	equ	5305h
APM_CPUBUSY_FUNC	equ	5306h
APM_SETPWSTATE_FUNC	equ	5307h	; set power state
APM_ENABLE_DISABLE_FUNC	equ	5308h
APM_REST_DEFLT_FUNC	equ	5309h	; restore power-on defaults
APM_GETPWSTATE_FUNC	equ	530ah	; get power state	
APM_GETPMEVENT_FUNC	equ	530bh


;*************************************************************
; values for APM device ids 
;*************************************************************
;
; SYSTEM clas
APM_SYSTEM_BIOS	equ	0000h
APM_SYSTEM_DEV	equ	0001h
APM_SYSTEM_CPU	equ	0002h
;display class
APM_DISPLAY_ALL	equ	0100h
; parallel ports
APM_PARALLEL_ALL	equ	0200h
; SERIAL ports
APM_SERIAL_ALL	equ	0300h
;
; global ID ; set containing all power managed devices
APM_ALL_DEVICES	equ	0ffffh
;
;*************************************************************
; sub-function codes for some of the above functions
;*************************************************************

; values for ENABLE_DISABLE_FUNC
APM_ENABLE_FUNC	equ	1
APM_DISABLE_FUNC	equ	0

;*************************************************************

; return values of some APM functions:

;*************************************************************

APM_SIGNATURE	equ	"PM"		; M003: APM signature is:
					; BH = 'P' and BL = 'M'
;
; PM events 
;
APM_STANDBY_REQ	equ	01
APM_SUSPEND_REQ	equ	02
APM_NORM_RESUME	equ	03
APM_CRIT_RESUME	equ	04
APM_BATT_LOW	equ	05


; APM_FLAGS masks (returned by APM detect call)
APM_SLOW_CLOCK	equ	0100B	; bit 2  = 1 if CPU_IDLE slows processor clock
APM_PWMGMT_DISABLED	equ	1000b	; bit3 = 1 if power mgmt. disabled
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\biostruc.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
; rom bios call packet structures

;*******************************
;system service call ( int 15h )
;*******************************
;function ah = 0c0h, return system configuration
;for pc and pcjr on return:
;	(ah)	= 80h
;	(cy)	= 1
;for pcxt, pc portable and pcat on return:
;	(ah)	= 86h
;	(cy)	= 1
;for all others:
;	(ah)	= 0
;	(cy)	= 0
;	(es:bx) = pointer to system descriptor vector in ros
; system descriptor :
;	dw	xxxx		length of descriptor in bytes,
;				minimum length = 8
;	db	xx		model byte
;				0ffh	= pc
;				0feh	= pc/xt, portable
;				0fdh	= pc/jr
;				0fch	= pc/at, 6mhz pc/at,
;					  6mhz pc/at running coprocessor(?),
;					  ps/2 model 50, 50 z
;				0fah	= ps/2 model 25, 30
;				0f9h	= pc convertible
;				0f8h	= ps/2 model 80
;				0f7h	= nova
;				0e0 thru 0efh = reserved
;
;	db	xx		secondary model byte
;				000h	= pc1
;				000h	= pc/xt, portable
;				000h	= pc/jr
;				000h	= pc/at
;				001h	= 6mhz pc/at
;				003h	= 6mhz pc/at running coprocessor(?)
;				004h	= ps/2 model 50, 50z
;				001h	= ps/2 model 25
;				000h	= pc convertible
;				000h	= ps/2 model 80
;				000h	= nova
;
;	db	xx		bios revision level
;				00 for first release, subsequent release
;				of code with same model byte and
;				secondary model byte require revison level
;				to increase by one.
;
;	db	xx		feature information byte 1
;				x0000000 = 1, bios use dma channel 3
;					 = 0, dma channel 3 not used
;
;				0x000000 = 1, 2nd interrupt chip present
;					 = 0, 2nd interrupt chip not present
;
;				00x00000 = 1, real time clock present
;					 = 0, real time clock not present
;
;				000x0000 = 1, keyboard escape sequence(int15h)
;						called in keyboard interrupt
;						(int 09h).
;					 = 0, keyboard escape sequence not
;						called.
;				0000xxxx reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;
;	db	xx		feature information byte 2 - reserved
;

bios_system_descriptor	struc
bios_sd_leng		dw	?
bios_sd_modelbyte	db	?
bios_sd_scnd_modelbyte	db	?
			db	?
bios_sd_featurebyte1	db	?
			db   4 dup (?)
bios_system_descriptor ends

;featurebyte1	bit map equates
dmachannel3		equ 10000000b
scndintcontroller	equ 01000000b
realtimeclock		equ 00100000b
keyescapeseq		equ 00010000b
;
;model byte
mdl_pc1 	equ	0ffh
mdl_xt		equ	0feh
mdl_jr		equ	0fdh
mdl_at		equ	0fch
mdl_convert	equ	0f9h

mdl_ps2_30	equ	0fah
mdl_ps2_80	equ	0f8h

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\lpc.asm ===
PAGE    ,132
        TITLE   'Power Control Transient Portion'

;-----------------------------------------------------------------------------
;       Power control transient module for POWER.EXE
;
;       This file contains the transient code used to turn power
;       monitoring on and off from the command line.
;
;       Microsoft Confidential
;       Copyright (C) 1991 Microsoft Corporation 
;       All Rights Reserved.
;
; This code is bound to the device driver image of POWER.EXE.  This
; transient program can be used to turn power control on and off.
; POWER has the following options:
;
;       POWER [ADV | STD |OFF |SOUND |/?]
;               ADV   - Monitors applications and devices
;               STD   - Monitors devices only
;		OFF   - turns off all pw. management
;               SOUND - activate speaker during idle (debug version only) - toggle
;               /? - print help message
;
; MODIFICATIONS:
;	M004	9/5/91	NSM	power status from APM in BL reg. was trashed
;				and so we were skipping call to get and print
;				APM stats. Fixed by storing status and
;				using it whenever we need to look at current
;				POWER status
;	M007	09/11/91 SMR	B#2669. Registered POWER's 2f channels
;					in mult.inc
;	M009	09/11/91 SMR	Build non-debug version.
;
;  	M010	09/12/91 SMR	PWR_API returns 0 in AX instead of no carry flag
;				in case of no error
;	M011	09/17/91 NSM	PWR_API returns the version no in AX for the
;				install_chk call and so we shouldn't chk for
;				AX==0 for install-chk call.
;	M087	09/23/91 NSM	Install_chk returns 504d in BX and not 4d50
;				B#2756
;
;	M089	09/25/91 NSM	UI changes.	
;
;	M092	10/18/91 NSM	B#2872(5.1) Clear out BH
;				(correction for a typo: xor was entered as or)
;-----------------------------------------------------------------------------

Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

Trans_Stack     segment para stack 'STACK'
        db      512 dup (?)
Trans_Stack     ends

break		macro		; satisfy mult.inc & pdb.inc		; M009
		endm							; M009

include		mult.inc				; M007
include         power.inc
include         pdb.inc

; DOS calls used
EXIT            equ     4Ch
OUT_STRING      equ     09h
OUT_CHAR        equ     02h

Trans_Data      segment
include         powermsg.inc

psp             dw      0,0             ; stores our PSP address 

digit_buf       db      8 dup (0)       ; stores chars generated by get_dec

idle_data	IDLE_INFO	<>

pow_status	db	0		; M004 ; to store current POWER
					; enabled/disabled state

Trans_Data      ends

Trans_Code      segment
        assume  cs:Trans_Code, ds:nothing, es:nothing

        extrn   get_dec:near, uldiv:near, lmul:near        
        
start:
        public  start
        mov     ax,Trans_Data
        mov     ds,ax                   ; set up data segment
        assume  ds:Trans_Data

        mov     [psp]+2,es              ; save our PSP address for later
        
; look at the command line and determine what we are supposed to be
; doing.  

        les     bx,dword ptr [psp]      ; recover our PSP address
        lea     di,es:[bx].PDB_TAIL
        cmp     es:[bx].PDB_TAIL,0      ; is there a command line?
	je	not_help		; no tail; go display stats
look_at_tail:
	inc	di			; skip the first blank in tail

clear_spaces:
        cmp     es:byte ptr [bx+di],' ' ; scan past any spaces
        jne     get_command_option      ; not a space, load it and check it
        inc     di
        jmp     short clear_spaces      ; assume we will stop on CR terminator

get_command_option:
        mov     ax,es:word ptr [bx+di]  ; get start of command line,
        cmp     ax,'?/'                 ; looks like /?
	jne	not_help
	jmp	display_help

not_help:

; We've established this is not /?.  Now check for other options        
; before proceeding, detect the presence of POWER by power detect call

	push	bx
	mov	ax,(MultPWR_API*256)+00h; POWER detect mult.call ; M007
	int	2fh
	cmp	ax,(MultPWR_API*256)+00h; MultAPI code unchanged ? ; M011
	jnz	chk_signature		; M011
to_open_fail:
	jmp	open_failed
chk_signature:
	cmp	bx,504dh		; M087 signature correct ?
	jne	to_open_fail

IFDEF	DEBUG
	push	di
        lea     dx,rev_msg      	; Display current rev. no & date
        mov     ah,OUT_STRING		;
        int     21h                     
	pop	di
ENDIF
	pop	bx

        mov     ax,es:word ptr [bx+di]  ; get start of command line,

        cmp     al,13                   ; is it the CR terminator?
        je      display_info            ; yes, just go display status
	cmp	al,0			; no tail at all
	je	display_info		; just display status

        or      ax,2020h                ; map to lower case -- this is a
                                        ; command line, so don't need lang.
                                        ; independence
; M089 BEGIN - UI changes

        cmp     ax,'da'                 ; turning on?
        je      turn_on_all
	cmp	ax,'ts'			; Standard ?
	je	turn_on_FW
        cmp     ax,'fo'                 ; looks like OFF?
        je      turn_off                ; 

; M089 END

IFDEF      DEBUG           ; only active in debug version
        cmp     ax,'os'                 ; looks like SOUND?
        jne     bad_command             ; none of the above, parameter error

; User requests we toggle control of speaker on at idle
	mov	ax,(MultPWR_API*256)+02h; change allocation strategy ; M007
	mov	bl,80h			; special value for SOUND toggle
	int	2fh
        jmp     short display_info      ; go show current state

bad_command:

ENDIF

; User provided an invalid command line

        lea     dx,bad_command_msg      ; scold the user
        jmp     err_exit

turn_on_all:        ; User requested power control be activated
	mov	bl,3			; set both F/W and S/W
;
change_pw_state:			; issue mult.int to turn on/off PW mgmt.
	mov	bh,1			; set  power state
	mov	al,I2F_PW_GET_SET_PWSTATE
	mov	ah,MultPWR_API		; M007
	int	2fh
        jmp     short display_info

turn_on_FW:
	mov	bl,2			; turn on only F/W
	jmp	short change_pw_state
	

turn_off:       ; User requests power control be deactivated
	xor	bl,bl		; turn off all pw mgmt
	jmp	short change_pw_state
	
        
display_info:   ; Print current state and idle stats
	mov	al,I2F_PW_GET_SET_PWSTATE
	mov	ah,MultPWR_API		; M007
	mov	bx,0			; get pw state
	int	2fh
	or	ax, ax			; M010
	jz	chk_status		; M010
	jmp	stats_failed		; error in get pw state ? just quit
chk_status:
	mov	[pow_status],bl		; M004
        lea     dx,power_stat1_msg      ; Display current POWER status
        mov     ah,OUT_STRING		; Whether "ON/OFF/NOAPP"
        int     21h                     

	or	bl,bl			; all pow.mgmt off ?
        lea     dx,power_off_msg         ; assume power control is off
	jz	got_msg			
	cmp	bl,2
	lea	dx,power_allon_msg
	jne	got_msg
	lea	dx,power_noid_msg
got_msg:
        mov     ah,OUT_STRING		
        int     21h                     
	lea	dx,power_stat2_msg	; complete the above stat msg
        mov     ah,OUT_STRING		
        int     21h                     

; Compute percentage of time idle if idle detection is on
	test	[pow_status],1		;M004; is idle detection on ?
	jz	Print_APM_Stats
        lea     dx,cpu_idle_msg1
        mov     ah,OUT_STRING
        int     21h

	lea	si,idle_data
	mov	cx,size IDLE_INFO
	mov	al,I2F_PW_GET_STATS
	mov	ah,MultPWR_API		; M007
	mov	bx,PW_GET_IDLE_STATS	; get only idle detection stats
	int	2fh			; get stats
	or	ax, ax			; M010
	jnz	stats_failed		; M010

	lea	bx,idle_data
        push    word ptr [bx].CPU_IDLE_TIME+2
        push    word ptr [bx].CPU_IDLE_TIME   ; get total idle time
        xor     ax,ax
        push    ax
        mov     ax,100
        push    ax
        call    lmul                    ; returns result in DX:AX
        add     sp,8
        push    word ptr [bx].CPU_ON_TIME+2
        push    word ptr [bx].CPU_ON_TIME
        push    dx
        push    ax
        call    uldiv                   ; returns result in DX:AX
        add     sp,8

	call	calc_and_print_no
        
        lea     dx,cpu_idle_msg2
        mov     ah,OUT_STRING
        int     21h

Print_APM_Stats:
IFDEF	INCL_APM
	test	[pow_status],2		;M004; is APM enabled ?
	jz	good_exit		; no, all stats display over
	call	Display_APM_Stats
ENDIF
	

good_exit:      ; And exit

        xor     al,al
        mov     ah,EXIT
        int     21h


; Help message display

display_help:
        lea     dx,help_text
        mov     ah,OUT_STRING
        int     21h
        jmp     short good_exit


; Various error exits

open_failed:
        
        lea     dx,open_failed_msg
        jmp     short err_exit

stats_failed:
        lea     dx,stats_failed_msg
err_exit:
        mov     ah,OUT_STRING
        int     21h                     ; display error message
        mov     ah,EXIT
        mov     al,1                    ; signal error on exit 
        int     21h                     

; END OF Main (of transient POWER.EXE)

calc_and_print_no	proc	near
;dx:ax = no to print
;
        lea     di,digit_buf
        call    get_dec                 ; convert result to ASCII

        mov     ah,OUT_CHAR
        lea     bx,digit_buf

next_digit:
        mov     dl,[bx]                 ; reached end of string?
        or      dl,dl
        jz      capn_end              ; yes, go wrap up
        int     21h                     ; print the character
        inc     bx                      ; point to next char in string
        jmp     short next_digit
capn_end:
	ret

calc_and_print_no	endp

IFDEF	INCL_APM

batt_stat_table	label	word
	dw	battery_high
	dw	battery_low
	dw	battery_critical
	dw	battery_charging

;***************************************** Display_APM_Stats
; display APM statistics (ACLine status, Battery status and battery life)
;

Display_APM_Stats	proc	near
	mov	ax,530ah		; get power status
	mov	bx,1
	int	15h			;
	jc	APM_stats_End
	push	cx
	push	bx
	cmp	bh,-1
	je	go_chk_batt_stat
        lea     dx,ACLine_Stat1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	push	bx
        lea     dx,AC_Offline_str
	or	bh,bh
	je	go_print_acstat
	lea	dx,AC_Online_str
go_print_acstat:
        mov     ah,OUT_STRING
        int     21h
        lea     dx,ACLine_Stat2
        mov     ah,OUT_STRING
        int     21h

go_chk_batt_stat:
	pop	bx
	cmp	bl,-1
	je	go_print_batt_life
	xor	bh,bh		; M092
	push	bx
	lea	dx,battery_status1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	shl	bx,1		; word offset
	mov	dx,cs:batt_stat_table[bx]
        mov     ah,OUT_STRING
        int     21h

	lea	dx,battery_status2
        mov     ah,OUT_STRING
        int     21h

go_print_batt_life:
	pop	cx
	cmp	cl,-1
	je	APM_stats_End
	mov	ax,cx
	xor	ah,ah
	push	ax
	lea	dx,battery_life_str1
        mov     ah,OUT_STRING
        int     21h
	pop	ax
	xor	dx,dx
	call	calc_and_print_no
	lea	dx,battery_life_str2
        mov     ah,OUT_STRING
        int     21h
APM_stats_END:
	ret

Display_APM_Stats	endp

ENDIF

Trans_Code      ends

        end     start
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msbio1.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	msbio1.asm - Bios_Data definition and device driver entry/exit

;
;----------------------------------------------------------------------------
;
; Modification history
;
; M001 : BIOS used to local enable a20 before calling original int 13 fn
;        and local disable a20 after the int 13 call. This created some
;        problems with disk caching programs which do lazy reads (PC-Kwik)
;	 Now BIOS turns a20 on if it is off and leaves it on after the
;	 int 13 call
;
; M028 : Added INT 10 to the list of interrupt vectors to be restored
;	 at INT 19 time.
;
; M033 : BIOS was setting the EOT in DPT to its desired value and then
;	 wrongly resetting it to 9 after it job. Now it saves the EOT
;	 before setting & resets it to the old value.
;
; M036 : Added VDISK header clearing code at INT 19 & CTRL ALT DEL
;
; M041 : Saving & restoring A20 status for all transitions from HMA
;	 to Lomem & vice versa in INT 13 handler. For PCKWIK
;
; M058 : Bug #4925. Changed Orig13 offset to 70:b4 so that people like CMS,
;	ProComm who patch it directly will work.
;
; M059 : Bug #5002. Treat rollover byte as a count instead of a flag, if
;			t_switch is not set.
;
;
; M064 : Bug #5070. Ensure that A20 is enabled before entering Device driver
;		entry point in HMA. And do not try to preserve A20 status
;		across INT 13 calls (support norton cache).
;
;
; M073 : Add far code pointers in power.asm to seg_reinit list.
;
; M084 : Remove IOCTL support for built-in POWER$ 
;
; M097 : B#2958. Define endfloppy label after ROMDRIVE & POWER code, so that we
;	  do not overwrite ROMDRIVE and POWER on a harddiskless system
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define BIOS segments

	include	devsym.inc
	include	msequ.inc
	include	bpb.inc
	include	bootform.inc
	include	msbds.inc

;SR;
; Assembly conditional for stack switching
;
STACKSW		equ	1

Bios_Data	segment

	assume	cs:Bios_Data
	public	BData_start
BData_start:


	assume	ds:nothing,es:nothing

	public	hdrv_pat
hdrv_pat label	word			; patched by msinit
	assume	cs:Bios_Data

	extrn	init:near		; this is in msinit

	jmp	init			; go to initialization code


;	define some stuff that is also used by msdos.sys from an include file

In_Bios	=	0ffffh	; define flag for msbdata.inc
	include	msbdata.inc


	public	inHMA,xms
inHMA	db	0		; flag indicates we're running from HMA
xms	dd	0		; entry point to xms if above is true

	align	2
;M058;	public orig13
;M058;orig13	dd	?

	public	ptrsav
ptrsav	dd	0

	public	auxbuf
auxbuf	db	0,0,0,0   	;set of 1 byte buffers for com 1,2,3, and 4
	public	zeroseg
zeroseg dw	0		; easy way to load segment registers with zero

	public	i13_ds,prevoper,number_of_sec	; M030
i13_ds		dw	?	; M030 ds register for int13 call through
prevoper	dw	?	; holds int 13 request (i.e. register ax).
number_of_sec	db	?	; holds number of secs. to read on an ecc error
	public	auxnum
auxnum	dw	0			;which aux device was requested


	public	res_dev_list

res_dev_list	label	byte
	p_attr	=	chardev+outtilbusy+dev320+IOQUERY
; **	p_attr	=	chardev+outtilbusy+dev320

	sysdev <auxdev2,8013h,strategy,con_entry,'CON     '>
auxdev2 sysdev <prndev2,8000h,strategy,aux0_entry,'AUX     '>
prndev2 sysdev <timdev,p_attr,strategy,prn0_entry,'PRN     '>
timdev	sysdev <dskdev,8008h,strategy,tim_entry,'CLOCK$  '>
dskdev	dd	com1dev
	dw	842h + IOQUERY		; 00001001 01000010
; **	dw	842h			; 32 bit sector calculation
	dw	strategy,dsk_entry

	public	drvmax
	public	step_drv
	public	fhave96
	public	single
	public	fhavek09
	public	fsetowner

drvmax		db	4
step_drv	db     -2		; last drive accessed
fhave96 	db	0		; flag to indicate presence of
					;   96tpi support
single		db	0		; used to detect single drive systems
fhavek09	db	0		; indicates if this is a k09 or not
					;  used by console driver.
fsetowner	db	?		; =1 if we are setting the owner of a
					;  drive. (examined by checksingle).

com1dev sysdev <lpt1dev,8000h,strategy,aux0_entry,'COM1    '>
lpt1dev sysdev <lpt2dev,p_attr,strategy,prn1_entry,"LPT1    ">

IFDEF	ROMDOS
;
;ROM DOS BIOS has an additional six bytes of variables before this
;point, so Orig13 has been repositioned yet again.  -DBO
;
;M058; Start of changes
; Orig13 needs to be at offset 0b4h for the CMS floppy driver to work.
;These guys patch Orig13 with their own int 13h hook and so this offset
;cannot change for them to work. Even ProComm does this.
;
	db	15 dup (?)	; to make Orig13 offset 0B4h

IF2
	  .errnz (OFFSET Orig13 - 0b4h) ; Orig13 offset must be 0b4h
ENDIF

	public orig13
orig13	dd	?

;
;M058; End of changes
;
ENDIF	;ROMDOS

lpt2dev sysdev <lpt3dev,p_attr,strategy,prn2_entry,"LPT2    ">

IFNDEF	ROMDOS
;
;M058; Start of changes
; Orig13 needs to be at offset 0b4h for the CMS floppy driver to work.
;These guys patch Orig13 with their own int 13h hook and so this offset
;cannot change for them to work. Even ProComm does this.
;
	db	3 dup (?)	; to make Orig13 offset 0B4h

IF2
	  .errnz (OFFSET Orig13 - 0b4h) ; Orig13 offset must be 0b4h
ENDIF

	public orig13
orig13	dd	?

;
;M058; End of changes
;
ENDIF	;NOT ROMDOS

lpt3dev sysdev <com2dev,p_attr,strategy,prn3_entry,"LPT3    ">
com2dev sysdev <com3dev,8000h,strategy,aux1_entry,"COM2    ">
com3dev sysdev <com4dev,8000h,strategy,aux2_entry,"COM3    ">


;	define a label for the device (if any) which immediately
;	  follows com4

IFDEF	POWER
after_com4	equ	powerdev
ELSE
IFDEF	ROMDRIVE
	extrn	rdrive:near
after_com4	equ	rdrive
ELSE
after_com4	equ	0ffffh
ENDIF
ENDIF

com4dev dw	after_com4,Bios_Data,8000h,strategy,aux3_entry
	db	"COM4    "

IFDEF	POWER
powerdev	label	word

IFDEF	ROMDRIVE
	extrn	rdrive:near
	dw	rdrive
ELSE
	dw	0ffffh		; end of chain
ENDIF

		dw	Bios_Data, 8000h, strategy, power_entry		;M084
	db	"POWER$  "

ENDIF

		public	RomVectors
RomVectors	label	byte
	public	Old10, Old13, Old15, Old19, Old1B	; M028
	db	10h					; M028
Old10	dd	(?)					; M028
	db	13h
Old13	dd	(?)
	db	15h
Old15	dd	(?)
	db	19h
Old19	dd	(?)
	db	1bh
Old1B	dd	(?)
EndRomVectors	equ	$
		public	NUMROMVECTORS
NUMROMVECTORS	equ	((EndRomVectors - RomVectors)/5)

	public	start_bds
	public	accesscount
	public	tim_drv
	public	medbyt

start_bds dd      bds1			;start of bds linked list.
accesscount	db	0		; number of times media check called
tim_drv 	db	-1		; time when last disk i/o performed
medbyt		db	?

	public	wrtverify
	public	rflag
	public	seccnt
	public	dsktnum
	public	motorstartup,settlecurrent,settleslow
	public	save_eot		; M033
	public	save_head_sttl
	public	eot

wrtverify	label word
rflag		db	romread 	;2 for read, 3 for write
verify		db	0		;1 if verify after write
seccnt		dw	0
		db	00		; M011 -- pad where hardnum was
dsktnum 	db	1		;number of diskette drives
motorstartup	db	?		; value from table
settlecurrent	db	?		; value from table
settleslow	db	?		; slow settle value

nextspeed	db	?		; value of speed to be used
save_head_sttl	db	?		;used by read_sector routine
save_eot	db	?		; saved eot from the default DPT M033

eot		db	9

	public	dpt
	public	cursec,curhd,curtrk,spsav
	public	formt_eot,hdnum,trknum,gap_patch
	public	errin
	public	lsterr

dpt		dd	?

;	keep the next two items contiguous - see ioctl_block for reason

cursec		db	0		;current sector
curhd		db	0		;current head
curtrk		dw	0		;current track
spsav		dw	0		;save the stack pointer

;	the following are used for ioctl function calls

formt_eot	db	8		    ; eot used for format
hdnum		db	0		    ; head number
trknum		dw	0		    ; track being manipulated
gap_patch	db	50h		    ; format gap patched into dpt

;	disk errors returned from the ibm rom

errin	db	0cch			; write fault error
	db	80h			;no response
	db	40h			;seek failure
	db	10h			;bad crc
	db	8			;dma overrun
	db	6			; media change
	db	4			;sector not found
	db	3			;write attempt to write-protect disk
lsterr	db	0			;all other errors

;	returned error codes corresponding to above

	public errout
errout	db	10			; write fault error
	db	2			;no response
	db	6			;seek failure
	db	4			;bad crc
	db	4			;dma overrun
	db	15			; invalid media change
	db	8			;sector not found
	db	0			;write attempt on write-protect disk
	db	12			;general error
	public numerr
numerr	=	errout-errin

;-------------------------------------------------------------
;
;   read in boot sector here,  read done in readboot.
;   also read sector for dma check for hard disk.
;
;	This buffer is word aligned because certain AMI BIOSs	; M061
;	have a bug in them which causes the byte after the	; M061
;	buffer to be trashed on floppy reads to odd-byte	; M061
;	boundaries.  Although no general effort is made to	; M061
;	enforce this in the bigger picture, this one small	; M061
;	sacrifice makes that system more-or-less work.		; M061

	align	2		; M061

	public	disksector

disksector		db	size EXT_IBMBOOT_HEADER dup (?)
			db	512-($-disksector) dup (?)

;*********************************************************************
;	"bds" contains information for each drive in the system.
;	various values are patched whenever actions are performed.
;	sectors/alloc. unit in bpb initially set to -1 to signify that
;	the bpb has not been filled. link also set to -1 to signify end
;	of list. # of cylinders in maxparms initialized to -1 to indicate
;	that the parameters have not been set.
;
bds_str struc
	dw	?		; dword link to next structure
	dw	?
	db	0		; int 13 drive number
	db	0		; logical drive letter

xfdrv	dw	512		; physical sector size in bytes
	db	-1		; sectors/allocation unit
	dw	1		; reserved sectors for dos
	db	2		; no of allocation tables
	dw	64		; number of directory entries
	dw	9*40		; number sectors (at 512 bytes each)
	db	0		; media descriptor, initially 0
	dw	2		; number of fat sectors
	dw	9		; sector limit
	dw	1		; head limit
	dw	0		; hidden sector count (low word)
	dw	0		; hidden sector (high)
	dw	0		; number sectors (low)
	dw	0		; number sectors (high)
	db	0		;  true => large fats
	dw	0		; open ref. count
	db	3		; form factor
	dw	20h		; various flags
	dw	40		; number of cylinders

;	recommended bps for this drive

	dw	512		; bytes per sector
	db	1		; sectors/alloc unit
	dw	1		; reserved sectors for dos
	db	2		; number of allocation tables
	dw	0e0h		; number directory entries
	dw	9*40		; number 512 byte sectors
	db	0f0h		; media descriptor, initially 0f0h
	dw	2		; number of fat sectors
	dw	9		; sector limit
	dw	2		; head limit
	dw	0		; hidden sector count(low)
	dw	0		; hidden sector count(high)
	dw	0		; number sectors(low)
	dw	0		; number sectors(high)
	db	6 dup (?)

	db	-1		; last track accessed on this drive
	dw	-1		; keep these two contiguous (?)
	dw	-1
	db	"NO NAME    ",0	; volume id for this disk
	dd	0		; current volume serial from boot record
	db	"FAT12   ",0	; current file system id from boot record
bds_str ends

bds1	bds_str <bds2,seg Bios_Data>
bds2	bds_str <bds3,seg Bios_Data>
bds3	bds_str <bds4,seg Bios_Data>
bds4	bds_str <-1,seg Bios_Data>

	public	fdrive1
	public	fdrive2
	public	fdrive3
	public	fdrive4

fdrive1 equ	bds1.xfdrv
fdrive2 equ	bds2.xfdrv
fdrive3 equ	bds3.xfdrv
fdrive4 equ	bds4.xfdrv


bpbtype struc
spf	db	?
spt	db	?
cdire	db	?
csec	dw	?
spau	db	?
chead	db	?
bpbtype ends
	public sm92
sm92	bpbtype <3,9,70h,2*9*80,2,2>

	public	keyrd_func
	public	keysts_func

; moved altah to inc\msbdata.inc so it could go in instance table in DOS

keyrd_func	db	0	; default is conventional keyboard read
keysts_func	db	1	; default is conventional keyboard status check.

	public printdev
printdev	db	0		; index into above array

; the following variable can be modified via ioctl sub-function 16. in this
; way, the wait can be set to suit the speed of the particular printer being
; used. one for each printer device.

	public wait_count
wait_count	dw	4 dup (50h)	; array of retry counts for printer

		public daycnt, t_switch			; M059
daycnt		dw	0
t_switch	db	0	; flag to indicate whther to use old	; M059
				; way of updating daycnt or not		; M059

; variables for real time clock setting
	public	havecmosclock
havecmosclock	db	0	;set by msinit
	public	base_century
base_century	db	19
	public	base_year
base_year	db	80
	public	month_tab
month_tab	db	31,28,31,30,31,30,31,31,30,31,30,31

; the following are indirect far call addresses. the
;procedures are defined in msinit for relocation.  msinit will reset these
;adress when the relocation is done.

	extrn	bin_to_bcd:far
	extrn	daycnt_to_day:far
	public	bintobcd
	public	daycnttoday

bintobcd	dd	bin_to_bcd	;points to bin_to_bcd proc in msinit
daycnttoday	dd	daycnt_to_day	;points to daycnt_to_day in msinit


;	this stuff is related to the msdisk.asm module

	public	set_id_flag
set_id_flag	db	0	; if 1, getbp routine will set the
				;vol_serial and filesys_id in bds table
				;from the media boot record, if it is > dos 4.00
				;formatted one. then set_id_flag will be set to 2
				;to signal that volume_label is set from the extended
				;boot record and do not set it from the root
				;directory as done in set_volume_id routine.
				;for the old version, vol_serial
				;will be set to -1, and filesys_id will be set
				;to "fat12   " if it is a floppy.

	public	fat_12_id
fat_12_id  db  "FAT12   ",0	;  default system id for floppy.
	public	fat_16_id
fat_16_id  db  "FAT16   ",0
	public	vol_no_name
vol_no_name db "NO NAME    ",0
	public	temp_h
temp_h		dw	0		; temporary for 32 bit calculation.

	public	start_sec_h
start_sec_h	dw	0		; starting sector number high word.
					;used as an input to diskio subroutine.
	public	saved_word
saved_word	dw	0		;  tempory saving place for a word.

	public	multrk_flag
multrk_flag	dw	0
	public ec35_flag
ec35_flag	db	0		; flags for electrically compatible 3.5 inch disk drives
	public	vretry_cnt
vretry_cnt	dw	0
	public	soft_ecc_cnt
soft_ecc_cnt	dw	0
	public	multitrk_format_flag
multitrk_format_flag	db	0	;testing. if 1, then multi track format request
	public	xfer_seg
xfer_seg	dw	0		; temp for transfer segment

;	variables for msdioctl.asm module

; tracktable contains a 4-tuples (c,h,r,n) for each sector in a track
; c = cylinder number,h = head number,r = sector id,n = bytes per sector
;	n	bytes per sector
;      ---	----------------
;	0	      128
;	1	      256
;	2	      512
;	3	     1024
;
	public	max_sectors_curr_sup
max_sectors_curr_sup	equ	63	; current maximum sec/trk that
					; we support (was 40 in dos 3.2)
	public	sectorspertrack
sectorspertrack dw	36
	public	tracktable
tracktable	db	0,0,1,2
		db	0,0,2,2
		db	0,0,3,2
		db	0,0,4,2
		db	0,0,5,2
		db	0,0,6,2
		db	0,0,7,2
		db	0,0,8,2
		db	0,0,9,2
		db	0,0,10,2
		db	0,0,11,2
		db	0,0,12,2
		db	0,0,13,2
		db	0,0,14,2
		db	0,0,15,2
		db	0,0,16,2
		db	0,0,17,2
		db	0,0,18,2
		db	0,0,19,2
		db	0,0,20,2
		db	0,0,21,2
		db	0,0,22,2
		db	0,0,23,2
		db	0,0,24,2
		db	0,0,25,2
		db	0,0,26,2
		db	0,0,27,2
		db	0,0,28,2
		db	0,0,29,2
		db	0,0,30,2
		db	0,0,31,2
		db	0,0,32,2
		db	0,0,33,2
		db	0,0,34,2
		db	0,0,35,2
		db	0,0,36,2
		db	4*max_sectors_curr_sup - ($ - tracktable) dup (0)

; this is a real ugly place to put this
; it should really go in the bds

	public	mediatype
mediatype		db	0

	public	media_set_for_format	; also used by msint13 and msdisk

media_set_for_format	db	0	; 1 if we have done an int 13 set media
					; type for format call
	public	had_format_error
had_format_error	db	0	; 1 if the previous format operation
					; failed.

; temp disk base table. it holds the the current dpt which is then replaced by
; the one passed by "new roms" before we perform a format operation. the old
; dpt is restored in restoreolddpt. the first entry (disk_specify_1) is -1 if
; this table does not contain the previously saved dpt.

	public	tempdpt
tempdpt 	dd	-1


	public	model_byte
model_byte db	0ffh			; model byte set at init time
	public	secondary_model_byte
secondary_model_byte db 0

	public	int19sem
int19sem db	0			; indicate that all int 19
					; initialization is complete

;	we assume the following remain contiguous and their order doesn't change
i19_lst:
	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	public	int19old&aa
		db	aa&h	; store the number as a byte
int19old&aa	dd	-1	;orignal hardware int. vectors for int 19h.
	endm

num_i19 =	((offset $) - (offset i19_lst))/5

	public	dskdrvs
dskdrvs dw	fdrive1
	dw	fdrive2
	dw	fdrive3
	dw	fdrive4
;M011 -- made all hard drive stuff variable
	dw	22 dup (?)		; up to 26 drives for mini disks

;variables for dynamic relocatable modules
;these should be stay resident.

	public	int6c_ret_addr
int6c_ret_addr	dd	?		; return address from int 6c for p12 machine

;
;   data structures for real-time date and time
;
	public	bin_date_time
	public	month_table
	public	daycnt2
	public	feb29

bin_date_time:
	db	0		; century (19 or 20) or hours (0-23)
	db	0		; year in century (0...99) or minutes (0-59)
	db	0		; month in year (1...12) or seconds (0-59)
	db	0		; day in month (1...31)

month_table:
	dw	0		; january
	dw	31		; february
	dw	59
	dw	90
	dw	120
	dw	151
	dw	181
	dw	212
	dw	243
	dw	273
	dw	304
	dw	334		; december
daycnt2 dw	0000		; temp for count of days since 1-1-80
feb29	db	0		; february 29 in a leap year flag


;************************************************************************
;*									*
;*	entry points into Bios_Code routines.  The segment values	*
;*	  are plugged in by seg_reinit.					*
;*									*
;************************************************************************

	public	cdev
cdev	dd	chardev_entry
	public	ttticks
ttticks	dd	time_to_ticks
bcode_i2f dd	i2f_handler
i13x	dd	i13z
;BEGIN M073
IFDEF	POWER
	extrn	Check_and_Init_APM:far
	public	Check_and_Init_APM_Ptr
Check_and_Init_APM_Ptr dd Bios_Code:Check_and_Init_APM
	extrn	P_UpdFromCMOS:far		;M074
	public	P_UpdFromCMOS_Ptr		;M074
P_UpdFromCMOS_Ptr dd Bios_Code:P_UpdFromCMOS	;M074
ENDIF	;POWER
;END M073
end_BC_entries:

;************************************************************************
;*									*
;*	cbreak - break key handling - simply set altah=3 and iret	*
;*									*
;************************************************************************

	public	cbreak
cbreak	proc	near
	assume	ds:nothing,es:nothing

	mov	altah,3		;indicate break key set

	public	intret		; general purpose iret in the Bios_Data seg
intret:
	iret
cbreak	endp

;************************************************************************
;*									*
;*	strategy - store es:bx (device driver request packet)		*
;*		     away at [ptrsav] for next driver function call	*
;*									*
;************************************************************************

	public	strategy
strategy proc	far
	assume	ds:nothing,es:nothing

	mov	word ptr cs:[ptrsav],bx
	mov	word ptr cs:[ptrsav+2],es
	ret
strategy endp

;************************************************************************
;*									*
;*	device driver entry points.  these are the initial		*
;*	  'interrupt' hooks out of the device driver chain.		*
;*	  in the case of our resident drivers, they'll just		*
;*	  stick a fake return address on the stack which		*
;*	  points to dispatch tables and possibly some unit		*
;*	  numbers, and then call through a common entry point		*
;*	  which can take care of a20 switching				*
;*									*
;************************************************************************

con_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry	; call into code segment handler
	dw	con_table

con_entry endp

;--------------------------------------------------------------------

prn0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,0		; device numbers

prn0_entry endp

;--------------------------------------------------------------------

prn1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	0,1

prn1_entry endp

;--------------------------------------------------------------------

prn2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	1,2

prn2_entry endp

;--------------------------------------------------------------------

prn3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	prn_table
	db	2,3

prn3_entry endp

;--------------------------------------------------------------------

aux0_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	0

aux0_entry endp

;--------------------------------------------------------------------

aux1_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	1

aux1_entry endp

;--------------------------------------------------------------------

aux2_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	2

aux2_entry endp

;--------------------------------------------------------------------

aux3_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	aux_table
	db	3

aux3_entry endp

;--------------------------------------------------------------------

tim_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	tim_table

tim_entry endp

;--------------------------------------------------------------------

	public	dsk_entry	; this entry point is called from msbio2

dsk_entry proc	near
	assume	ds:nothing,es:nothing

	call	cdev_entry
	dw	dsktbl

dsk_entry endp

;--------------------------------------------------------------------

IFDEF	POWER

power_entry	proc	near
	assume	ds:nothing, es:nothing

	call	cdev_entry
	dw	power_table

power_entry	endp

ENDIF

;************************************************************************
;*									*
;*	Ensure A20 is enabled before jumping into code in HMA.		*
;*	This code assumes that if Segment of Device request packet is	*
;*	DOS DATA segment then the Device request came from DOS & that	*
;*	A20 is already on.						*
;*									*
;************************************************************************

cdev_entry proc	near
	assume	ds:nothing,es:nothing
;
; M064 - BEGIN
;
	cmp	inHMA, 0
	je	ce_enter_codeseg; optimized for DOS in HMA

	push	ax
	mov	ax, DosDataSg
	cmp	word ptr [ptrsav+2], ax
	pop	ax
	jne	not_from_dos	; jump is coded this way to fall thru
				;	in 99.99% of the cases
ce_enter_codeseg:
	jmp	cdev
not_from_dos:
	call	EnsureA20On
;
; M064 - END
;
	jmp	short ce_enter_codeseg
cdev_entry endp

;************************************************************************
;*									*
;*	outchr - this is our int 29h handler.  it writes the		*
;*	   character in al on the display using int 10h ttywrite	*
;*									*
;************************************************************************

	public	outchr
outchr	proc	far
	assume	ds:nothing,es:nothing

	push	ax
	push	si
	push	di
	push	bp
	push	bx
	mov	ah,0eh		; set command to write a character
	mov	bx,7		; set foreground color
	int	10h		; call rom-bios
	pop	bx
	pop	bp
	pop	di
	pop	si
	pop	ax
	iret
outchr	endp

;************************************************************************
;*									*
;*	block13 - our int13 hooker					*
;*									*
;************************************************************************

;
; M064 - BEGIN : Removed for Norton cache
;
; A20WasOff is used to save & restore A20 status between transition from
; HMA into LOW mem & vice versa. This will remain initialized to zero
; in DOS=LOW case
;
; A20WasOff	db	0	; M041
;
; M064 - END
;

	public	block13
block13	proc	far
	assume	ds:nothing,es:nothing

	cmp	inHMA,0
	jz	skipa20		; M041

;	mov	A20WasOff, 0	; M041 Assume A20 ON	M064
	call	IsA20off	; M041 A20 Off?
	jnz	skipa20		; M041
;	mov	A20WasOff, 0ffh	; M041 Yes		M064
	call	EnableA20	; assure a20 enabled		;M001
skipa20:
	mov	i13_ds,ds	; M030 -- save caller's ds for call-through
	pushf			; fake interrupt
	call	i13x		; call through Bios_Code entry table
	mov	ds,i13_ds	; M030 -- get called-thru ds

;	pushf			; M041			M064
;	cmp	A20WasOff, 0	; M041			M064
;	jz	@f		; M041			M064
;	call	DisableA20	; M041			M064
;@@:				; M041			M064
;	popf			; M041			M064

	ret	2
block13	endp

;	M030 -- begin added routine

	public	call_orig13

;	the int13 hook calls back here to call-through to the ROM
;	this is necessary because some people have extended their
;	 ROM BIOSs to use ds as a parameter/result register and
;	 our int13 hook relies heavily on ds to access Bios_Data


call_orig13	proc	far

;	pushf				; M041			M064
;	cmp	A20WasOff, 0		; M041 Was A20 off ?	M064
;	je	@f			; M041 No, go ahead	M064
;	call	DisableA20		; M041 Yes, turn A20 off M064
;@@:					; M041			M064
;	popf				; M041			M064

	assume	ds:Bios_Data
	mov	ds,i13_ds		; get caller's ds register
	assume	ds:nothing
	pushf				; simulate an int13
	call	orig13
	mov	i13_ds,ds
	push	cs
	pop	ds			; restore ds -> Bios_Data before return

	pushf				; M041
	cmp	inHMA, 0		; M041
	jz	@f			; M041
;	mov	A20WasOff, 0h		; M041 Assume A20 is ON	M064
	call	IsA20Off		; M041 Is A20 off ?
	jnz	@f			; M041 No, go ahead
;	mov	A20WasOff, 0ffh		; M041 Yes		M064
	call	EnableA20		; M041
@@:					; M041
	popf				; M041

	ret

call_orig13	endp

;	M030 -- end added routine

; M001 - BEGIN

;************************************************************************
;*									*
;*	EnsureA20On - ensure that a20 is enabled if we're running	*
;*	  in the HMA before interrupt entry points into Bios_Code	*
;*									*
;************************************************************************

HiMem	label	dword
	dw	90h
	dw	0ffffh

LoMem	label	dword
	dw	80h
	dw	0h

EnsureA20On	proc near
	assume	ds:nothing,es:nothing
	call	IsA20Off
	jz	ea_enable
	ret

EnableA20	proc	near	; M041
ea_enable:
	push	ax
	push	bx
	mov	ah,5		; localenablea20
	call	xms
	pop	bx
	pop	ax
bie_done:
	ret
EnableA20	endp		; M041

EnsureA20On	endp
;
; M001 - END

; M041 : BEGIN 
;
;----------------------------------------------------------------------------
;
; procedure : IsA20Off
;
;----------------------------------------------------------------------------
;
IsA20Off	proc	near
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, HiMem
		les	di, LoMem
		mov	cx, 8
		rep	cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		ret
IsA20Off	endp

;
;----------------------------------------------------------------------------
;
; procedure : DisableA20
;
;----------------------------------------------------------------------------
;
DisableA20	proc	near
		push	ax
		push	bx
		mov	ah,6		; localdisable a20
		call	xms
		pop	bx
		pop	ax
		ret
DisableA20	endp

; M041 : END

;************************************************************************
;*									*
;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
;*	  interrupt vectors before resuming the original int19 code	*
;*									*
;************************************************************************


	public	int19
int19	proc	far
	assume	ds:nothing,es:nothing

	push	cs
	pop	ds
	assume	ds:Bios_Data

	mov	es,zeroseg

	mov	cx, NUMROMVECTORS	; no. of rom vectors to be restored
	mov	si, offset RomVectors	; point to list of saved vectors
next_int:
	lodsb				; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int * 4
	mov	di, ax
	lodsw
	stosw
	lodsw
	stosw				; install the saved vector
	loop	next_int

	cmp	byte ptr int19sem,0	; don't do the others unless we
	jz	doint19			; set our initialization complete flag

;	stacks code has changed these hardware interrupt vectors
;	stkinit in sysinit1 will initialize int19holdxx values.

	mov	si,offset i19_lst
	mov	cx,num_i19

i19_restore_loop:
	lodsb			; get interrupt number
	cbw			; assume < 128
	mov	di,ax		; save interrupt number
	lodsw			; get original vector offset
	mov	bx,ax		; save it
	lodsw			; get original vector segment
	cmp	bx,-1		; check for 0ffffh (unlikely segment)
	jz	i19_restor_1	;opt no need to check selector too 
	cmp	ax,-1		;opt 0ffffh is unlikely offset
	jz	i19_restor_1

	add	di,di
	add	di,di
	xchg	ax,bx
	stosw
	xchg	ax,bx
	stosw			; put the vector back

i19_restor_1:
	loop	i19_restore_loop

doint19:
;
; M036 - BEGIN
;
	cmp	inHMA, 0	; Is dos running from HMA
	je	SkipVDisk
	call	EraseVDiskHead	; Then erase our VDISK header at 1MB boundary
				;  Some m/c's (AST 386 & HP QS/16 do not
				;  clear the memory above 1MB during a warm
				;  boot.
SkipVDisk:
;
; M036 - END
;
	int	19h
int19	endp
;
; M036 - BEGIN
;
;
;----------------------------------------------------------------------------
;
; procedure : int15
;
;		Int15 handler for recognizing ctrl-alt-del seq
;		If it recognizes ctrl-alt-del and if DOS was
;		is running high, it Erases the VDISK header
;		present at 1MB boundary
;
;----------------------------------------------------------------------------
;
DELKEY		equ	53h
ROMDATASEG	equ	40h
KBFLAG		equ	17h
CTRLSTATE	equ	04h
ALTSTATE	equ	08h

	public	Int15
Int15	proc	far
	assume	ds:nothing
	cmp	ax, (4fh shl 8) + DELKEY	; del keystroke ?
	je	@f
	jmp	dword ptr Old15			
@@:
	push	ds
	push	ax
	mov	ax, ROMDATASEG
	mov	ds, ax
	mov	al, byte ptr ds:[KBFLAG]
	and	al, (CTRLSTATE or ALTSTATE)
	cmp	al, (CTRLSTATE or ALTSTATE)	; is ctrl-alt active?
	jne	@f

	push	cs
	pop	ds
	assume	ds:Bios_Data
	cmp	inHMA, 0			; is DOS running from HMA
	je	@f
	call	EraseVDiskHead
@@:
	pop	ax
	pop	ds
	assume	ds:nothing
	stc
	jmp	dword ptr Old15
Int15	endp
;
;----------------------------------------------------------------------------
;
; procedure : EraseVDiskHead
;
;		Erases the VDisk Header present in the 1MB boundary
;
;----------------------------------------------------------------------------
;
EraseVDiskHead	proc	near
	push	ax
	push	cx
	push	di
	push	es
	call	EnsureA20On
	mov	ax, 0ffffh	; HMA seg
	mov	es, ax
	mov	di, 10h		; point to VDISK header
	mov	cx, 10h		; size of vdisk header
	xor	ax, ax
	rep	stosw		; clear it
	pop	es
	pop	di
	pop	cx
	pop	ax
	ret
EraseVDiskHead	endp
;
; M036 - END
;
;
;************************************************************************
;*									*
;*	the int2f handler chains up to Bios_Code through here.		*
;*	  it returns through one of the three functions that follow.	*
;*	  notice that we'll assume we're being entered from DOS, so	*
;*	  that we're guaranteed to be A20 enabled if needed		*
;*									*
;************************************************************************

int_2f	proc	far
	assume	ds:nothing,es:nothing
	jmp	bcode_i2f
int_2f	endp


;	re-enter here to transition out of hma mode and jmp to dsk_entry
;	   note:  is it really necessary to transiton out and then back
;	   in?  It's not as if this is a really speed critical function.
;	   might as well do whatever's most compact.

	public	i2f_dskentry
i2f_dskentry proc far
	jmp	dsk_entry
i2f_dskentry endp


;************************************************************************
;*									*
;*	re_init - called back by sysinit after a bunch of stuff		*
;*		is done.  presently does nothing.  affects no		*
;*		registers!						*
;*									*
;************************************************************************

	public	re_init
re_init proc	far
	assume	ds:nothing,es:nothing
	ret
re_init endp


;SR; WIN386 support
; WIN386 instance data structure
;
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.
;

public	Win386_SI, SI_Version, SI_Next

Win386_SI	label	byte		; Startup Info for Win386
SI_Version	db	3, 0		; for Win386 3.0
SI_Next		dd	?		; pointer to next info structure
		dd	0		; a field we don't need
		dd	0		; another field we don't need
SI_Instance	dw	Instance_Table, Bios_Data ; far pointer to instance table

;
; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
; areas.  Note that the address and size of the hardware stacks must
; be calculated and inserted at boot time.
;
Instance_Table	label	dword
	dw	00H, 50H		; print screen status...
	dw	02			; ...2 bytes
	dw	0Eh, 50H		; ROM Basic data...
	dw	14H			; ...14H bytes
	dw	ALTAH, Bios_Data	; a con device buffer...
	dw	01			; ... 1 byte
IF STACKSW
public NextStack
NextStack	label dword

;	NOTE:  If stacks are disabled by STACKS=0,0, the following
;		instance items WILL NOT be filled in by SYSINIT.
;		That's just fine as long as these are the last items
;		in the instance list since the first item is initialized
;		to 0000 at load time.

	dw	0, 0		; pointer to next stack to be used...
	dw	02			; ...2 bytes
; The next item in the instance table must be filled in at sysinit time
public IT_StackLoc, IT_StackSize
IT_StackLoc	dd	?		; location of hardware stacks
IT_StackSize	dw	?		; size of hardware stacks
ENDIF
	dd	0			; terminate the instance table

;SR;
; Flag to indicate whether Win386 is running or not
;
public	IsWin386
IsWin386		db	0

;
;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about 
;30 bytes, we might as well put it in BIOS_DATA
;
PUBLIC	V86_Crit_SetFocus

V86_Crit_SetFocus	PROC	FAR

			push	di
			push	es
			push	bx
			push	ax

			xor	di,di
			mov	es,di
			mov	bx,0015h	;Device ID of DOSMGR device
			mov	ax,1684h	;Get API entry point
			int	2fh
			mov	ax,es
			or	ax,di		
			jz	Skip
;
;Here, es:di is address of API routine. Set up stack frame to simulate a call
;
			push	cs		;push return segment
			mov	ax,OFFSET Skip
			push	ax		;push return offset
			push	es
			push	di		;API far call address
			mov	ax,1		;SetFocus function number
			retf			;do the call
Skip:
			pop	ax
			pop	bx
			pop	es
			pop	di
			ret
V86_Crit_SetFocus	ENDP



;
;End WIN386 support
;

		public	FreeHMAPtr
		public	MoveDOSIntoHMA
FreeHMAPtr	dw	-1
MoveDOSIntoHMA	dd	sysinitseg:FTryToMovDOSHi


;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block. 
;Right now, this is the only data being communicated. It can be expanded 
;later to add more stuff
;
		public	SysinitPresent
SysinitPresent	db	0

IFNDEF	ROMDOS						; M097

; this will be the end of the BIOS data if no hard disks are in system
; in DISK based DOS

	public	endfloppy
endfloppy label byte

ENDIF ; NOT ROMDOS					; M097

Bios_Data ends

;
; Possibly disposable BIOS data
; This data follows the regular BIOS data, and is part of the same group.
;

Bios_Data_Init	segment

; M097 : begin

IFDEF	ROMDOS

; this will be the end of the BIOS data if no hard disks are in system
; in ROMDOS

	public	endfloppy
endfloppy label byte

ENDIF ; ROMDOS

; M097 : end

;	M011 -- begin changed section

;	this stuff is only used for changeline support

	public	nul_vid
	public	tmp_vid
nul_vid db  "NO NAME    ",0	; null volume id
tmp_vid db  "NO NAME    ",0	; vid scratch buffer

	public	end96tpi
end96tpi label	byte

	public	harddrv
harddrv db	80h			;physical drive number of first hardfile
;*********************************************************************
;memory allocation for bdss
;*********************************************************************

	public bdss
bdss	BDS_STRUC (2+max_mini_dsk_num) dup (<>)	;currently max. 25

;M011 -- end of changed section

Bios_Data_Init	ends


;	okay.  so much for Bios_Data.  Now let's put our device driver
;	  entry stuff up into Bios_Code.

Bios_Code	segment
	assume	cs:Bios_Code

; ORG a bit past zero to leave room for running in HMA...

	org	30h
	public	BCode_start
BCode_start:

;	device driver entry point tables

	extrn	dsktbl:near
	extrn	con_table:near
	extrn	tim_table:near
	extrn	prn_table:near
	extrn	aux_table:near

IFDEF POWER
	extrn	power_table:near
ENDIF

	extrn	i2f_handler:far
	extrn	time_to_ticks:far
	extrn	i13z:far

	public	Bios_Data_Word
Bios_Data_Word	dw	Bios_Data

;************************************************************************
;*									*
;*	seg_reinit is called with ax = our new code segment value,	*
;*	  trashes di, cx, es						*
;*									*
;*	cas -- should be made disposable!				*
;*									*
;************************************************************************

	public	seg_reinit
seg_reinit	proc	far
	assume	ds:nothing,es:nothing

	mov	es,Bios_Data_Word
	assume	es:Bios_Data
	mov	di,2+offset cdev
	mov	cx,((offset end_BC_entries) - (offset cdev))/4

seg_reinit_1:
	stosw				; modify Bios_Code entry points
	inc	di
	inc	di
	loop	seg_reinit_1
	ret
seg_reinit	endp

;************************************************************************
;*									*
;*	chardev_entry - main device driver dispatch routine		*
;*	   called with a dummy parameter block on the stack		*
;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
;*									*
;*	will eventually take care of doing the transitions in		*
;*	   out of Bios_Code						*
;*									*
;************************************************************************

chardev_entry	proc	far
	assume	ds:nothing,es:nothing

	push	si
	push	ax
	push	cx
	push	dx
	push	di
	push	bp
	push	ds
	push	es
	push	bx
	mov	bp,sp			; point to stack frame
	mov	si,18[bp]		; get return address (dispatch table)
	mov	ds,Bios_Data_Word	;  load ds: -> Bios_Data
	assume	ds:Bios_Data
	mov	ax,word ptr 2[si]	; get the device number if present
	mov	byte ptr [auxnum],al
	mov	byte ptr [printdev],ah
	mov	si,word ptr [si]	; point to the device dispatch table

	les	bx,[ptrsav]		;get pointer to i/o packet

	mov	al,byte ptr es:[bx].unit	;al = unit code
	mov	ah,byte ptr es:[bx].media	;ah = media descrip
	mov	cx,word ptr es:[bx].count	;cx = count
	mov	dx,word ptr es:[bx].start	;dx = start sector

	cmp	si,offset dsktbl
	jnz	no_sector32_mapping


;*********************************************************************
;
;	Special case for 32-bit start sector number:
;	   if (si==dsktbl) /* if this is a disk device call */
;	      set high 16 bits of secnum to 0
;	      if (secnum == 0xffff) fetch 32 bit sector number
;
;	pass high word of sector number in start_sec_h, low word in dx
;
; note: start_l and start_h are the offsets within the io_request packet
;	  which contain the low and hi words of the 32 bit start sector if
;	  it has been used.
;
; note:remember not to destroy the registers which have been set up before


	mov	start_sec_h,0		; initialize to 0
	cmp	dx,-1
	jnz	no_sector32_mapping

	mov	dx,es:[bx].start_h	; 32 bits dsk req
	mov	start_sec_h,dx		; start_sec_h = packet.start_h
	mov	dx,es:[bx].start_l	; dx = packet.start_l

no_sector32_mapping:
	xchg	di,ax
	mov	al,byte ptr es:[bx].cmd
	cmp	al,cs:[si]
	jae	command_error

	cbw				; note that al <= 15 means ok
	shl	ax,1

	add	si,ax
	xchg	ax,di

	les	di,dword ptr es:[bx].trans

	cld				; ***** always clear direction
	call	cs:word ptr [si+1] 	;go do command
	assume	ds:nothing

	jc	already_got_ah_status	; if function returned status, don't
	mov	ah,1			;  load with normal completion

already_got_ah_status:
	mov	ds,Bios_Data_Word	; cas///// note: shouldn't be needed!
	assume	ds:Bios_Data
	lds	bx,[ptrsav]
	assume	ds:nothing
	mov	word ptr [bx].status,ax ;mark operation complete

	pop	bx
	pop	es
	pop	ds
	pop	bp
	pop	di
	pop	dx
	pop	cx
	pop	ax
	pop	si
	add	sp,2		; get rid of fake return address

chardev_entry endp		; fall through into bc_retf

	public	bc_retf
bc_retf	proc	far
	assume	ds:nothing,es:nothing

	ret

bc_retf	endp


command_error:
	call	bc_cmderr
	jmp	short already_got_ah_status

;
;----------------------------------------------------------------------------
; The following piece of hack is for supporting CP/M compatibility
; Basically at offset 5 we have a far call into 0:c0. But this does not call
; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
; high.
;----------------------------------------------------------------------------
;
	dw	?	; pad to bring offset to 0d0h
if2
	if ( offset off_d0 - 0d0h )
		%out CP/M compatibilty broken!!!
		%out Please re-pos hack to ffff:d0
	endif
endif

	public	off_d0
off_d0	db	5 dup (?)	; 5 bytes from 0:c0 will be copied onto here
				;  which is the CP/M call 5 entry point
	.errnz (offset off_d0 - 0d0h)


;----------------------------------------------------------
;
;	exit - all routines return through this path
;

	public	bc_cmderr
bc_cmderr:
	mov	al,3			;unknown command error

;	now zero the count field by subtracting its current value,
;	  which is still in cx, from itself.


;	subtract the number of i/o's NOT YET COMPLETED from total
;	  in order to return the number actually complete


	public	bc_err_cnt
bc_err_cnt:
	assume	ds:Bios_Data
	les	bx,[ptrsav]
	assume	es:nothing
	sub	es:word ptr [bx].count,cx;# of successful i/o's
	mov	ah,81h			;mark error return
	stc				; indicate abnormal end
	ret

Bios_Code	ends


;	the last real segment is sysinitseg

sysinitseg	segment
	assume	cs:sysinitseg
	extrn	FTryToMovDOSHi:far
	public	SI_start
SI_start:
sysinitseg	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msdskpr.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
; the following structure defines the disk parameter table
; pointed to by interrupt vector 1eh (location 0:78h)

disk_parms	struc
disk_specify_1	db	?
disk_specify_2	db	?
disk_motor_wait db	?	; wait till motor off
disk_sector_siz db	?	; bytes/sector (2 = 512)
disk_eot	db	?	; sectors per track (max)
disk_rw_gap	db	?	; read write gap
disk_dtl	db	?
disk_formt_gap	db	?	; format gap length
disk_fill	db	?	; format fill byte
disk_head_sttl	db	?	; head settle time (msec)
disk_motor_strt db	?	; motor start delay
disk_parms	ends

romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msend.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160

;	Define end labels for each segment in
;	   IO.SYS.  Make the segments paragraph aligned
;	   to save the trouble of rounding up at run-time.
;
;	also defines a special segment called dos_load_seg which is
;	  used to figure out where to load MSDOS (after sysinit)

Bios_Data	segment	para public 'Bios_Data'
	assume	cs:Bios_Data
	public	BData_end
BData_end:
Bios_Data	ends

Bios_Code	segment para public 'Bios_Code'
	assume	cs:Bios_Code
	public	BCode_end
BCode_end:
Bios_Code	ends

sysinitseg	segment para public 'system_init'
	assume	cs:sysinitseg
	public	SI_end
SI_end:
sysinitseg	ends

dos_load_seg	segment para public 'dos_load_seg'
dos_load_seg	ends

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msdisk.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	msdisk - bios
;
;----------------------------------------------------------------------------
;
; M033 : BIOS was setting the EOT in DPT to its desired value and then
;	 wrongly resetting it to 9 after it job. Now it saves the EOT
;	 before setting & resets it to the old value.
;
; M039 : Do not count error 6 in retry count while reading from floppy.
;
; M052 : Resolved the confusion of media byte F9. BIOS used to default to 1.2M
;	 drive if formfactor was != ffsmall & mediabyte = f9.
;
; M00x : Setting 'lstdrv' properly at Setown ioctl call. Earlier it used
;		to set lstdrv to -1 on a setown call which got qbasic confused
;		Now the lstdrv update is done inside checksingle
;
; M059 : Bug #5002. Treat rollover byte as a count instead of a flag, if
;			t_switch is not set.
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define bios segment structure
	
	include msequ.inc
	include msdskpr.inc
	include	bpb.inc
	include	bootform.inc
	include	msbds.inc

	include msgroup.inc	; define Bios_Data segment

	include dossym.inc

;	Most of the disk routines keep es:[di] set up pointing to the
;	  currently selected bds.  This is often assumed to be the standard
;	  operating environment and in some cases may not be mentioned in
;	  the subroutine headers where it will be assumed.

	extrn	numerr:abs

;data

	extrn	ptrsav:dword
	extrn	zeroseg:word
	extrn	daycnt:word
	extrn	auxnum:word
	extrn	tim_drv:byte
	extrn	accesscount:byte
	extrn	sm92:byte
	extrn	disksector:byte
	extrn	disksector:byte
	extrn	step_drv:byte
	extrn	start_bds:dword
	extrn	wrtverify:word
	extrn	fsetowner:byte
	extrn	single:byte
	extrn	rflag:byte
	extrn	medbyt:byte
	extrn	spsav:word
	extrn	seccnt:word
	extrn	dpt:dword
	extrn	cursec:byte,curhd:byte
	extrn	curtrk:word
	extrn	eot:byte
	extrn	motorstartup:byte,settlecurrent:byte,settleslow:byte
	extrn	save_eot:byte				; M033
	extrn	curhd:byte
	extrn	lsterr:byte
	extrn	errin:byte,errout:byte
	extrn	prevoper:word
	extrn	orig13:dword
	extrn	number_of_sec:byte
	extrn	fhave96:byte
	extrn	save_head_sttl:byte
	extrn	model_byte:byte
	extrn	secondary_model_byte:byte

;	the following is in msdioctl.asm

	extrn	media_set_for_format:byte


	extrn	set_id_flag:byte
	extrn	fat_12_id:byte
	extrn	fat_16_id:byte
	extrn	vol_no_name:byte
	extrn	temp_h:word
	extrn	start_sec_h:word
	extrn	saved_word:word
	extrn	multrk_flag:word
	extrn	ec35_flag:byte
	extrn	vretry_cnt:word
	extrn	soft_ecc_cnt:word
	extrn	multitrk_format_flag:byte
	extrn	xfer_seg:word

;-----------------------------------------------------------------
;	disk interface routines
;
; device attribute bits:
;	bit 6 - get/set map for logical drives and generic ioctl.
;

maxerr		=	5
MAX_HD_FMT_ERR	=	2

lstdrv	=	504h

; some floppies do not have changeline.  as a result, media-check would
; normally return i-don't-know, the dos would continually reread the fat, and
; discard cached data.	we optimize this by implementing a logical door-
; latch:  it is physically impossible to change a disk in under 2 seconds.  we
; retain the time of the last successful disk operation and compare it with
; the current time during media-check.	if < 2 seconds and at least 1 timer
; tick has passed, the we say no change.  if > 2 seconds then we say i-
; don't-know.  finally, since we cannot trust the timer to be always
; available, we record the number of media checks that have occurred when no
; apparent time has elapsed.  while this number is < a given threshold, we say
; no change.  when it exceeds that threshold, we say i-don't-know and reset
; the counter to 0.  when we store the time of last successful access, if we
; see that time has passed too, we reset the counter.
;
accessmax	=	5
;
; due to various bogosities, we need to continually adjust what the head
; settle time is.  the following algorithm is used:
;
;   get the current head settle value.
;   if it is 0, then
;	set slow = 15
;   else
;	set slow = value
;   ...
;*********************************************
;************ old algorithm ******************
;*   if we are seeking and writing then
;*	 use slow
;*   else
;*	 use fast
;*********************************************
;*********** ibm's requested logic ***********
;   if we are seeking and writing and not on an at then
;	use slow
;   else
;	use fast
;   ...
;   restore current head settle value
;
;
;---------------------------------------
multrk_on	equ	10000000b	;user spcified mutitrack=on, or system turns
					; it on after handling config.sys file as a
					; default value, if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.


; close data segment, open Bios_Code segment

	tocode

;--------------------------------------------------------------
;
;	command jump table
;
	extrn	bc_cmderr:near
	extrn	bc_err_cnt:near

	extrn	Bios_Data_Word:word

	extrn	dsk_init:near
	extrn	do_generic_ioctl:near
	extrn	ioctl_getown:near
	extrn	ioctl_setown:near

	extrn	mediacheck:near
	extrn	haschange:near
	extrn	media_set_vid:near
	extrn	hidensity:near
	extrn	checklatchio:near
	extrn	checkio:near
	extrn	set_volume_id:near
	extrn	swpdsk:near
	extrn	resetchanged:near
	extrn	resetdisk:near
	extrn	ioctl_support_query:near
	extrn	GetTickCnt:near		; M059

	PUBLIC	Has1,Has720K		; M052

	public	dsktbl
dsktbl	label	byte
	db	((dtbl_siz-1)/2)	; this is the size of the table
	dw	dsk_init
	dw	media_chk
	dw	get_bpb
	dw	bc_cmderr
	dw	dsk_read
	dw	x_bus_exit
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	dsk_writ
	dw	dsk_writv
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	bc_cmderr

	dw	dsk_open
	dw	dsk_close
	dw	dsk_rem
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	do_generic_ioctl
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	ret_carry_clear
	dw	ioctl_getown
	dw	ioctl_setown
	dw	ioctl_support_query
dtbl_siz	=	(offset $)-(offset dsktbl)


; ==========================================================================
; setdrive scans through the data structure of bdss, and returns a pointer to
; the one that belongs to the drive specified. carry is set if none eists for
; the drive.  Pointer is returned in es:[di]
;
;  AL contains the logical drive number.
;
; ==========================================================================

	PUBLIC	SetDrive
SetDrive PROC NEAR
	ASSUME	DS:Bios_Data, ES:NOTHING

	les	di,[start_bds]		; Point es:di to first bds

X_Scan_Loop:
	cmp	es:[di].bds_drivelet,al
	je	X_SetDrv

	les	DI,ES:[DI].bds_link	; Go to next bds
	cmp	DI,-1
	jnz	X_Scan_Loop

	stc

X_SetDrv:
	ret

SetDrive endp


; ==========================================================================
; if id is f9, have a 96tpi disk else
; if bit 2 is 0 then media is not removable and could not have changed
;  otherwise if within 2 secs of last disk operation media could not
;    have changed, otherwise dont know if media has changed
;
; ==========================================================================

Media_Chk PROC	NEAR
	ASSUME	DS:Bios_Data

	call	SetDrive

		; For non-removable disks only return changed if changed by
		; format, otherwise return 'not changed'.

	mov	SI,1					; assume no change
	TESTB	ES:[DI].BDS_Flags,fCHANGED_BY_FORMAT
	jz	WeAreNotFakingIt

	and	ES:[DI].BDS_Flags,NOT fCHANGED_BY_FORMAT ; reset flag

		; If media has been changed by format, we must ask the ROM.
		; Cannot rely on the 2 second time check.

	mov	[Tim_Drv],-1		; Ensure that we ask the rom if media
					; has changed
	TESTB	ES:[DI].BDS_Flags,fNON_REMOVABLE
	jz	WeHaveaFloppy

	mov	SI,-1			; Indicate media changed
	jmp	SHORT Media_Done

		; We need to return 'not changed' if we have a hard file.

WeAreNotFakingIt:
	TESTB	ES:[DI].BDS_Flags,fNON_REMOVABLE
	jnz	Media_Done

wehaveafloppy:
	xor	SI,SI			; Presume "I don't know"

		; If we have a floppy with changeline support, we ask the ROM
		; to determine if media has changed. We do not perform the
		; 2 second check for these drives.

	cmp	fHave96,0		; Do we have changeline support?
	jz	mChk_NoChangeLine	; Brif not

	call	MediaCheck		; Call into removable routine
	jc	Err_Exitj		;

	call	HasChange		;
	jnz	Media_Done		;

mChk_NoChangeLine:

		; If we come here, we have a floppy with no changeline support

	mov	SI,1			; Presume no change
	mov	AL,[Tim_Drv]		; Last drive accessed
	cmp	AL,ES:[DI].BDS_DriveNum ; Is drive of last access the same?
	jnz	Media_Unk		; No, then "i don't know"

		; Check to see if this drv has been accessed in last 2 seconds.

	call	Check_Time_Of_Access	; Sets si correctly
	jmp	SHORT Media_Done

Media_Unk:
	dec	SI			; Return "I don't know"

		; SI now contains the correct value for media change.
		; Clean up the left overs

Media_Done:
	push	ES			; Save bds
	les	BX,[PtrSav]		; Get original packet

	ASSUME	ES:NOTHING

	mov	WORD PTR ES:[BX].Trans,SI
	pop	ES			; Restore bds
	or	SI,SI
	jns	VolIdOk

	cmp	fHave96,0
	jz	mChk1_NoChangeLine	; Brif no changeline support

	call	Media_Set_vId		; We no longer care about bds pointer

mChk1_NoChangeLine:
	mov	[tim_drv],-1		; Make sure we ask rom for media check

volidok:
ret_carry_clear:
	clc
	ret

err_exitj:
	call	maperror		; guaranteed to set carry
ret81:
	mov	ah,81h			; return error status
	ret				; return with carry set
media_chk	endp


; ==========================================================================
; perform a check on the time passed since the last access for this physicel
; drive.
; we are accessing the same drive.  if the time of last successful access was
; less than 2 seconds ago, then we may presume that the disk was not changed.
; returns in si:
;	0 - if time of last access was >= 2 seconds
;	1 - if time was < 2 seconds (i.e no media change assumed)
; registers affected ax,cx,dx, flags.
;
;	assume es:di -> bds, ds->Bios_Data
; ==========================================================================

	PUBLIC	Check_Time_Of_Access
Check_Time_Of_Access PROC NEAR
	ASSUME	DS:Bios_Data, ES:NOTHING

	mov	si,1			; presume no change.

	call	GetTickCnt		; M059 does INT 1A ah=0 & updates daycnt

					; compute elapsed time
	mov	ax,es:[di].bds_tim_lo	; get stored time
	sub	dx,ax
	mov	ax,es:[di].bds_tim_hi
	sbb	cx,ax
					; cx:dx is the elapsed time
	jnz	timecheck_unk		; cx <> 0 => > 1 hour
	or	dx,dx			; time must pass
	jnz	timepassed		; yes, examine max value

		; no noticeable time has passed. we cannot trust the counter
		; to be always available as there are bogus programs that go
		; and reprogram the thing. we keep a count of the number of
		; media checks that we've seen that do not have any time passing
		; if we exceed a give threshold, we give up on the timer.

	inc	byte ptr accesscount
	cmp	byte ptr accesscount,accessmax
	jb	timecheck_ret		; if count is less than threshold, ok

	dec	byte ptr accesscount	; don't let the count wrap
	jmp	short timecheck_unk	; "i don't know" if media changed

timepassed:				; 18.2 tics per second.
	cmp	dx,18 * 2		; min elapsed time?
	jbe	timecheck_ret		; yes, presume no change

		; everything indicates that we do not know what has happened.

timecheck_unk:
	dec	si			 ; presume i don't know

timecheck_ret:
	ret

Check_Time_Of_Access ENDP

; ==========================================================================

Err_Exitj2:
	jmp Err_Exitj

; ==========================================================================
;
; Build a valid bpb for the disk in the drive.
;
; ==========================================================================

Get_Bpb PROC	NEAR
	ASSUME	DS:Bios_Data, ES:NOTHING


	mov	ah,byte ptr es:[di]	;get fat id byte read by dos
	call	setdrive		; get the correct bds for the drive
	TESTB	es:[di].bds_flags,fnon_removable
	jnz	already_gotbpb		; no need to build for fixed disks

		; let's set the default value for volid,vol_serial,
		; filesys_id in bds table

	call	clear_ids
	mov	[set_id_flag],1		; indicate to set system id in bds
	call	getbp			; build a bpb if necessary.
	jc	ret81			; return ah=81, carry set if error

	cmp	[set_id_flag],2		; already, volume_label set from boot
	mov	[set_id_flag],0		;  record to bds table?
	je	already_gotbpb		;   do not set it again from root dir.
					; otherwise, conventional boot record.
	cmp	fhave96,0		; do we have changeline support?
	jz	already_gotbpb		; brif not

	call	set_volume_id

already_gotbpb:
	add	di,BDS_BPB		; return the bpb from the current bds

get_bpb	endp				; fall into setptrsav, es:di -> result


; ==========================================================================
;SR;
; Setptrsav is also jumped to from dsk_init (msbio2.asm). In both cases, the
;pointer to be returned is in es:di. We were incorrectly returning ds:di.
;Note that this works in most cases because most pointers are in Bios_Data.
;It fails, for instance, when we install an external drive using driver.sys
;because then the BDS segment is no longer Bios_Data. 
;NB: It is fine to corrupt cx because this is not a return value and anyway
;this returns to Chardev_entry (msbio1.asm) where all registers are 
;restored before returning to the caller.
;
; ==========================================================================

	PUBLIC	SetPtrSav
SetPtrSav	proc	near		; return point for dsk_init
	ASSUME	DS:Bios_Data

	mov	cx,es			;save es
	les	bx,[ptrsav]
	assume	es:nothing
	mov	es:[bx].media,ah
	mov	es:[bx].count,di
	mov	es:[bx].count+2,cx
	clc
	ret

setptrsav endp

; ==========================================================================
; clear ids in bds table. only applied for floppies.
;input:  es:di -> bds table
;	assumes ds: -> Bios_Data
;output: volid set to "NO NAME    "
;	 vol_serial set to 0.
;	 filesys_id set to "FAT12   " or "FAT16   "
;	   depending on the flag fatsize in bds.
;
;	trashes si, cx
; ==========================================================================

	public	clear_ids
clear_ids	proc near
	assume	ds:Bios_Data,es:nothing
	push	di

	xor	cx,cx				; no serial number
	mov	word ptr es:[di].bds_vol_serial,cx
	mov	word ptr es:[di].bds_vol_serial+2,cx

		; BUGBUG - there's a lot in common here and with
		; mov_media_ids.. see if we can save some space by
		; merging them... jgl

	mov	cx,size EXT_BOOT_VOL_LABEL	; =11
	mov	si,offset vol_no_name
	add	di,bds_volid			; points to volid field
	rep	movsb

	TESTB	es:[di].bds_fatsiz,fbig
	mov	si,offset fat_16_id		; big fat
	jnz	ci_bigfat			; small fat
	mov	si,offset fat_12_id

ci_bigfat:
	mov	cx,size EXT_SYSTEM_ID		; =8
	add	di,bds_filesys_id-bds_volid-size EXT_BOOT_VOL_LABEL ; filesys_id field
	rep	movsb
	pop	di				; restore bds pointer
	ret

clear_ids	endp


; ==========================================================================
;	getbp - return bpb from the drive specified by the bds.
;	    if the return_fake_bpb flag is set, then it does nothing.
;	    note that we never come here for fixed disks.
;	    for all other cases,
;	      - it reads boot sector to pull out the bpb
;	      - if no valid bpb is found, it then reads the fat sector,
;		to get the fat id byte to build the bpb from there.
;
;   inputs:	es:di point to correct bds.
;
;   outputs:	fills in bpb in current bds if valid bpb or fat id on disk.
;		carry set, and al=7 if invalid disk.
;		carry set and error code in al if other error.
;		if failed to recognize the boot record, then will set the
;		set_id_flag to 0.
;		this routine will only work for a floppy diskette.
;		     for a fixed disk, it will just return.
;
;	****** Note:  getbp is a clone of getbp which uses the newer
;	  segment definitions.  It should be migrated towards.
;	   now es:di has the bds, ds: has Bios_Data
; ==========================================================================

	PUBLIC GetBP
GetBp	PROC	NEAR
	ASSUME	DS:Bios_Data, ES:NOTHING

		; if returning fake bpb then return bpb as is.

	TESTB	es:[di].bds_flags,<return_fake_bpb or fnon_removable>
	jz	getbp1
	jmp	getret_exit

getbp1:
	push	cx
	push	dx
	push	bx

		;
		; attempt to read in boot sector and determine bpb.
		; we assume that the 2.x and greater dos disks all have a valid boot sector.

	call	readbootsec
	jc	getbp_err_ret_brdg	; carry set if there was error.

	or	bx,bx			; bx is 0 if boot sector is valid.
	jnz	dofatbpb

	call	movbpb			; move bpb into registers.
	jmp	short has1

getbp_err_ret_brdg:
	jmp getbp_err_ret

		; we have a 1.x diskette. In this case read in the fat ID byte
		; and fill in bpb from there.

dofatbpb:
	call	readfat 		; puts media descriptor byte in ah
	jc	getbp_err_ret_brdg

	cmp	fhave96,0		; changeline support available?
	jz	bpb_nochangeline	; brif not

	call	hidensity		; may not return!  May add sp,2 and
					; jump to has1!!!!!! or has720K
bpb_nochangeline:
					; test for a valid 3.5" medium
	cmp	es:[di].bds_formfactor,ffsmall
	jnz	is_floppy
	cmp	ah,0f9h 		; is it a valid fat id byte for 3.5" ?
	jnz	got_unknown_medium
Has720K:				; M052
	mov	bx,offset sm92		; pointer to correct bpb

		; es points to segment of bds. the following should be modified
		; to get spf,csec,spau,spt correctly. it had been wrong if
		; driver.sys is loaded since the bds is inside the driver.sys.

	mov	al,[bx.spf]
	mov	cx,[bx.csec]
	mov	dx,word ptr [bx.spau]
	mov	bx,word ptr [bx.spt]
	jmp	short has1

is_floppy:				; must be a 5.25" floppy if we come here
	cmp	ah,0f8h			; valid media??  (0f8h-0ffh)
	jb	got_unknown_medium

	mov	al,1			;set number of fat sectors
	mov	bx,64*256+8		;set dir entries and sector max
	mov	cx,40*8 		;set size of drive
	mov	dx,01*256+1		;set head limit and sec/all unit
	test	ah,00000010b		;test for 8 or 9 sector
	jnz	has8			;nz = has 8 sectors

	inc	al			;inc number of fat sectors
	inc	bl			;inc sector max
	add	cx,40			;increase size

has8:
	test	ah,00000001b		;test for 1 or 2 heads
	jz	has1			;z = 1 head

	add	cx,cx			;double size of disk
	mov	bh,112			;increase number of directory entries
	inc	dh			;inc sec/all unit
	inc	dl			;inc head limit

Has1	LABEL	NEAR
	ASSUME	DS:Bios_Data, ES:NOTHING

	mov	es:[di].BDS_BPB.BPB_SECTORSPERCLUSTER,dh
	mov	byte ptr es:[di].BDS_BPB.BPB_ROOTENTRIES,bh
	mov	es:[di].BDS_BPB.BPB_TOTALSECTORS,cx
	mov	es:[di].BDS_BPB.BPB_MEDIADESCRIPTOR,ah
	mov	byte ptr es:[di].BDS_BPB.BPB_SECTORSPERFAT,al
	mov	byte ptr es:[di].BDS_BPB.BPB_SECTORSPERTRACK,bl
	mov	byte ptr es:[di].BDS_BPB.BPB_HEADS,dl

		; the BDS_BPB.BPB_HIDDENSECTORS+2 field and the
		; BDS_BPB.BPB_BIGTOTALSECTORS field need to be set
		; to 0 since this code is for floppies

	mov	word ptr es:[di].BDS_BPB.BPB_HIDDENSECTORS+2,0
	mov	word ptr es:[di].BDS_BPB.BPB_HIDDENSECTORS,0
	mov	word ptr es:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2,0

getret:
	pop	bx
	pop	dx
	pop	cx

getret_exit:
	ret

getbp_err_ret:
		; before doing anything else, set set_id_flag to 0.
	mov	set_id_flag,0
	call	maperror
	jmp	short getret

		; we have a 3.5" diskette for which we cannot build a bpb.
		; we do not assume any type of bpb for this medium.

got_unknown_medium:
	mov	set_id_flag,0
	mov	al,error_unknown_media
	stc
	jmp	short getret

getbp	endp

; ==========================================================================

bpbtype struc
spf	db	?
spt	db	?
cdire	db	?
csec	dw	?
spau	db	?
chead	db	?
bpbtype ends


; ==========================================================================
; read in the boot sector. set carry if error in reading sector.
; bx is set to 1 if the boot sector is invalid, otherwise it is 0.
;
;	assumes es:di -> bds, ds-> Bios_Data
; ==========================================================================

readbootsec proc near
	assume	ds:Bios_Data,es:nothing
	mov	dh,0			   ;head 0
	mov	cx,0001		   	;cylinder 0, sector 1
	call	read_sector
	jc	err_ret

	xor	bx,bx			    ; assume valid boot sector.

		; put a sanity check for the boot sector in here to detect
		; boot sectors that do not have valid bpbs. we examine the
		; first two bytes - they must contain a long jump (69h) or a
		; short jump (ebh) followed by a nop (90h), or a short jump
		; (e9h). if this test is passed, we further check by examining
		; the signature at the end of the boot sector for the word
		; aa55h. if the signature is not present, we examine the media
		; descriptor byte to see if it is valid. for dos 3.3, this
		; logic is modified a little bit. we are not going to check
		; signature. instead we are going to sanity check the media
		; byte in bpb regardless of the validity of signature. this is
		; to save the already developed commercial products that have
		; good jump instruction and signature but with the false bpb
		; informations
; that will crash the diskette drive operation. (for example, symphony diskette).

	 cmp	byte ptr [disksector],069h	; is it a direct jump?
	 je	check_bpb_mediabyte		; don't need to find a nop
	 cmp	byte ptr [disksector],0e9h	; dos 2.0 jump?
	 je	check_bpb_mediabyte		; no need for nop
	 cmp	byte ptr [disksector],0ebh	; how about a short jump.
	 jne	invalidbootsec
	 cmp	byte ptr [disksector]+2,090h	; is next one a nop?
	 jne	invalidbootsec

; check for non-ibm disks which do not have the signature aa55 at the
; end of the boot sector, but still have a valid boot sector. this is done
; by examining the media descriptor in the boot sector.

check_bpb_mediabyte:

	mov	al,disksector.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR
	 and	 al,0f0h
	 cmp	 al,0f0h		; allow for strange media
	 jnz	 invalidbootsec

; there were some (apparently a lot of them) diskettes that had been formatted
; under dos 3.1 and earlier versions which have invalid bpbs in their boot
; sectors. these are specifically diskettes that were formatted in drives
; with one head, or whose side 0 was bad. these contain bpbs in the boot
; sector that have the sec/clus field set to 2 instead of 1, as is standard
; in dos. in order to support them, we have to introduce a "hack" that will
; help our build bpb routine to recognise these specific cases, and to
; set up out copy of the bpb accordingly.
; we do this by checking to see if the boot sector is off a diskette that
; is single-sided and is a pre-dos 3.20 diskette. if it is, we set the
; sec/clus field to 1. if not, we carry on as normal.

checksinglesided:
	mov	al,disksector.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR
	cmp	al, 0f0h	; is it one of the new diskette type?
	je	gooddsk		; new disks are supported only after 3.2

	test	al,0001h	; is low bit set? - indicates double sided
	jnz	gooddsk

	cmp	word ptr [disksector+8],"." shl 8 + "3"
	jnz	mustbeearlier
	cmp	byte ptr [disksector+10],"2"
	jae	gooddsk

; we must have a pre-3.20 diskette. set the sec/clus field to 1

mustbeearlier:
	mov	disksector.EXT_BOOT_BPB.BPB_SECTORSPERCLUSTER,1
	jmp	short gooddsk

invalidbootsec:
	 inc	 bx			    ; indicate that boot sector invalid
gooddsk:				    ; carry already reset
	 clc
	 ret

err_ret:
;					; carry is already set on entry here
	 ret
readbootsec endp

; moves the bpb read from the boot sector into registers for use by
; getbp routine at has1
;
; if the set_id_flag is 1, and if an extended boot record, then set volume
; serial number, volume label, file system id in bds according to
; the boot record.  after that, this routine will set the set_id_flag to 2
; to signal that volume label is set already from the extended boot record
; (so, don't set it again by calling "set_volume_id" routine which uses
; the volume label in the root directory.)

movbpb	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dh,byte ptr disksector.EXT_BOOT_BPB.BPB_SECTORSPERCLUSTER ;sectors per unit
	mov	bh,byte ptr disksector.EXT_BOOT_BPB.BPB_ROOTENTRIES ;number of directory entries
	mov	cx,word ptr disksector.EXT_BOOT_BPB.BPB_TOTALSECTORS ;size of drive
	mov	ah,byte ptr disksector.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR ;media descriptor
	mov	al,byte ptr disksector.EXT_BOOT_BPB.BPB_SECTORSPERFAT ;number of fat sectors
	mov	bl,byte ptr disksector.EXT_BOOT_BPB.BPB_SECTORSPERTRACK ;sectors per track
	mov	dl,byte ptr disksector.EXT_BOOT_BPB.BPB_HEADS ;number of heads

	cmp	[set_id_flag],1	     ; called by get_bpb?
	jne	movbpb_ret

	call	mov_media_ids
	jc	movbpb_conv		     ; conventional boot record?
	mov	[set_id_flag],2	     ; signals that volume id is set.
movbpb_conv:
	cmp	fhave96,1
	jne	movbpb_ret
	call	resetchanged		     ; reset flags in bds to not fchanged.
movbpb_ret:
	clc
	ret
movbpb	endp


	public	mov_media_ids
mov_media_ids	proc	near
	assume	ds:Bios_Data,es:nothing

;copy the boot_serial number, volume id, and filesystem id from the
;***extended boot record*** in ds:disksector to the bds table pointed
;by es:di.

;in.) es:di -> bds
;     ds:disksector = valid extended boot record.
;out.) vol_serial, bds_volid and bds_system_id in bds are set according to
;      the boot record information.
;     carry flag set if not an extended bpb.
;     all registers saved except the flag.

	cmp	disksector.EXT_BOOT_SIG,ext_boot_signature ; = 41
	jne	mmi_not_ext
	push	cx
	mov	cx,word ptr disksector.EXT_BOOT_SERIAL
	mov	word ptr es:[di].bds_vol_serial,cx
	mov	cx,word ptr disksector.EXT_BOOT_SERIAL+2
	mov	word ptr es:[di].bds_vol_serial+2,cx

	push	di
	push	si

	mov	cx,size EXT_BOOT_VOL_LABEL
	mov	si,offset disksector.EXT_BOOT_VOL_LABEL
	add	di,bds_volid
	rep	movsb
	mov	cx,size EXT_SYSTEM_ID	;  =8
	mov	si,offset disksector.EXT_SYSTEM_ID
	add	di,bds_filesys_id-bds_volid-size EXT_BOOT_VOL_LABEL
	rep	movsb

	pop	si
	pop	di
	pop	cx
	clc
	ret
mmi_not_ext:
	stc
	ret
mov_media_ids	endp


; read in the fat sector and get the media byte from it.
; input : es:di -> bds
; output:
;	  carry set if an error occurs, ax contains error code.
;	  otherwise, ah contains media byte on exit

readfat proc	near
	assume	ds:Bios_Data,es:nothing
	mov	dh,0			; head 0
	mov	cx,0002 		; cylinder 0, sector 2
	call	read_sector		; ds:bx points to fat sector
	jc	bad_fat_ret
	mov	ah,[bx]			; media byte
bad_fat_ret:
	ret
readfat endp

; read a single sector into the temp buffer.
; perform three retries in case of error.
;   inputs:	es:[di].bds_drivenum has physical drive to use
;		cx has sector and cylinder
;		dh has head
;		es:di has bds
;		ds has Bios_Data
;
;   outputs:	carry clear
;		    Bios_Data:bx point to sector
;		       (note: some callers assume location of buffer)
;
;		carry set
;		    ax has rom error code
;
; register bp is preserved.

	public read_sector
read_sector proc near
	assume	ds:Bios_Data,es:nothing

	push	bp
	mov	bp,3			; make 3 attempts
	mov	dl,es:[di].bds_drivenum
	mov	bx,offset disksector	; get es:bx to point to buffer
rd_ret:
	push	es
	push	ds
	pop	es			; dma address = Bios_Data
	mov	ax,201h 		; number of sectors to 1 (al=1)
	int	13h			; call rom-bios disk routines
	pop	es			; restore bds pointer
	jnc	okret2

rd_rty:
	call	again			; reset disk, decrement bp, preserve ax
	jz	err_rd_ret

	TESTB	es:[di].bds_flags,fnon_removable
	jnz	rd_ret

	cmp	[media_set_for_format],0
	jne	rd_skip1_dpt

	push	ax
	push	ds		; for retry, set the head settle time to 0fh

	lds	si,dpt
	assume	ds:nothing
	mov	al,ds:[si].disk_head_sttl
	mov	byte ptr ds:[si].disk_head_sttl,normsettle
	pop	ds
	assume	ds:Bios_Data
	mov	[save_head_sttl],al
	pop	ax
rd_skip1_dpt:
					; set cmd to read (ah=2) and
	push	es
	push	ds			; dma = Bios_Data
	pop	es
	mov	ax,201h 		; num of sectors to 1 (al=1)
	int	13h			; call rom-bios disk routines
	pop	es

	pushf
	cmp	[media_set_for_format],0
	jne	rd_skip2_dpt

	push	ax
	mov	al,[save_head_sttl]
	push	ds
	lds	si,dpt
	assume	ds:nothing
	mov	byte ptr ds:[si].disk_head_sttl,al
	pop	ds
	assume	ds:Bios_Data
	pop	ax

rd_skip2_dpt:
	popf
	jnc	okret2
	jmp	rd_rty

err_rd_ret:
	mov	dl,-1		; make sure we ask rom if media has changed
	stc			; return error

; update information pertaining to last drive accessed, time of access, last
; track accessed in that drive.

okret2:
	mov	[step_drv],dl	; set up for head settle logic in disk.
	mov	[tim_drv],dl 	;save drive last accessed
	mov	es:[di].bds_track,ch ; save last track accessed on this drive
	pushf			; preserve flags in case error occurred
	call	set_tim
	popf			; restore flags
	pop	bp
	ret
read_sector endp

;--------------------------------------------------------------------

;	disk open/close routines

	public	dsk_open
dsk_open proc	near
	assume	ds:Bios_Data,es:nothing

	cmp	fhave96,0
	jz	dsk_open_exit		; done if no changeline support

; al is logical drive

	call	setdrive		;get bds for drive
	inc	es:[di].bds_opcnt
dsk_open_exit:
	clc
	ret

dsk_open	endp

;--------------------------------------------------------------------


	public	dsk_close
dsk_close proc	near
	assume	ds:Bios_Data,es:nothing

	cmp	fhave96,0		; done if no changeline support
	jz	exitjx

; al is logical drive

	call	setdrive		;get bds for drive
	cmp	es:[di].bds_opcnt,0
	jz	exitjx			; watch out for wrap
	dec	es:[di].bds_opcnt
exitjx:
	clc
	ret

dsk_close endp

;-----------------------------------------------------------
;
;		disk removable routine
;

dsk_rem proc	near
	assume	ds:Bios_Data,es:nothing

; al is unit #

	call	setdrive		; get bds for this drive
	TESTB	es:[di].bds_flags,fnon_removable
	jnz	non_rem
	clc
	ret

non_rem:
x_bus_exit:
	mov	ah,3			; return busy status
	stc
dsk_ret:
	ret
dsk_rem endp

;-----------------------------------------------------------
;
;		disk i/o routines
;

dsk_writv proc	near
	assume	ds:Bios_Data,es:nothing

	mov	[wrtverify],103h
	jmp	short dsk_cl

dsk_writ:
	assume	ds:Bios_Data,es:nothing

	mov	[wrtverify],romwrite

dsk_cl:
	call	diskio
dsk_io:
	jnc	dsk_ret			; normal completion, no carry!
	jmp	bc_err_cnt
dsk_writv endp

dsk_read proc	near
	assume	ds:Bios_Data,es:nothing

	call	diskrd
	jmp	dsk_io
dsk_read endp

; miscellaneous odd jump routines.  moved out of mainline for speed.

; if we have a system where we have virtual drives, we need to prompt the
; user to place the correct disk in the drive.
;
;	assume es:di -> bds, ds:->Bios_Data

checksingle proc near

	public checksingle
	assume	ds:Bios_Data,es:nothing

	push	ax
	push	bx
	mov	bx,es:[di].bds_flags

; if hard drive, cannot change disk.
; if current owner of physical drive, no need to change diskette.

	test	bl,fnon_removable or fi_own_physical
	jnz	singleret
	test	bl,fi_am_mult		 ; is there a drive sharing this
					 ;   physical drive?
	jz	singleret

; look for the previous owner of this physical drive and reset its ownership
; flag.

	mov	al,es:[di].bds_drivenum	; get physical drive number
	push	es			; preserve pointer to current bds
	push	di

	les	di,[start_bds]		; get first bds
scan_list:
	cmp	es:[di].bds_drivenum,al
	jnz	scan_skip		; nope.  Not our drive.  Try next bds.

	mov	bl,fi_own_physical	; test ownership flag
	test	bl,byte ptr es:[di].bds_flags
	jz	scan_skip		; he doesn't own it either.  continue

check_own:
	xor	byte ptr es:[di].bds_flags,bl ; reset ownership flag

	pop	di			; restore pointer to current bds
	pop	es

	or	byte ptr es:[di].bds_flags,bl	; set ownership flag

; we examine the fsetowner flag. if it is set, then we are using the code in
; checksingle to just set the owner of a drive. we must not issue the prompt
; in this case.

	cmp	byte ptr [fsetowner],1
;
; M00x - BEGIN
;
	jnz	not_fsetowner

	cmp	es:[di].bds_drivenum, 0		; are we handling drive
						;  number 0 ?
	jne	singleret

	mov	al, es:[di].bds_drivelet	; get the DOs drive letter
	push	ES
	mov	ES,ZeroSeg
	mov	BYTE PTR ES:[lstdrv],al 	; & set up sdsb
	pop	ES				; restore bds pointer
	jmp	short singleret
;
; M00x - END
;

; to support "backward" compatibility with ibm's "single drive status byte"
; we now check to see if we are in a single drive system and the application
; has "cleverly" diddled the sdsb
not_fsetowner:
	cmp	[single],2		    ; if (single_drive_system)
	jne	ignore_sdsb

	push	ax
	mov	al,es:[di].bds_drivelet	    ;	  if (curr_drv == req_drv)
	mov	ah,al
	push	es
	mov	es,zeroseg
	xchg	al,es:byte ptr lstdrv	    ;	     then swap(curr_drv,req_drv)
	pop	es
	cmp	ah,al			    ;	     else
	pop	ax			    ;		  swap(curr_drv,req_drv)
	je	singleret		    ;		  issue swap_dsk_msg

ignore_sdsb:


	call	swpdsk			    ;  ask user for correct disk
	jmp	short singleret

scan_skip:
	les	di,es:[di].bds_link 		; go to next bds
	cmp	di,-1			; end of list?
	jnz	scan_list		; continue until hit end of list

single_err_ret:
	stc
	pop	di			    ; restore current bds
	pop	es
singleret:
	pop	bx
	pop	ax
	ret

checksingle endp

baddrive:
	mov	al,8			;sector not found
	jmp	short baddrive_ret

unformatteddrive:
	mov	al,7			;unknown media
baddrive_ret:
	stc
ioret:
	ret

;------------------------------------------------------------
;
;	disk i/o handler
;
;	al = drive number (0-6)
;	ah = media descriptor
;	cx = sector count
;	dx = first sector (low)
;	[start_sec_h] = first sector (high)  32 bit calculation.
;	ds = cs
;	es:di = transfer address
;	[rflag]=operation (2=read, 3=write)
;	[verify]=1 for verify after write
;
;	if successful carry flag = 0
;	  else cf=1 and al contains error code


;--------------------------------------------------------------

	public	diskrd
diskrd	proc	near
	assume	ds:Bios_Data,es:nothing


	mov	[rflag],romread

diskrd	endp				; fall into diskio

;--------------------------------------------------------------

	public	diskio
diskio	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	bx,di			; es:bx = transfer address
	mov	xfer_seg,es		; save transfer segment
	call	setdrive		; map logical and physical
	mov	al,es:[di].BDS_BPB.BPB_MEDIADESCRIPTOR
	mov	medbyt,al		; preserve media byte for drive for use
					; in determining media change.
	jcxz	ioret

;	see if the media is formatted or not by checking the flags field in
;	in the bds.  if it is unformatted we cannot allow i/o, so we should
;	go to the error exit at label unformatteddrive.

	TESTB	es:[di].bds_flags,unformatted_media
	jnz	unformatteddrive

	mov	[seccnt],cx		;save sector count
	mov	[spsav],sp		; save sp

; ensure that we are trying to access valid sectors on the drive

	mov	ax,dx			; save dx to ax
	xor	si,si
	add	dx,cx
	adc	si,0
	cmp	es:[di].BDS_BPB.BPB_TOTALSECTORS,0 ; > 32 bit sector ?
	je	sanity32

	cmp	si,0
	jne	baddrive
	cmp	dx,es:[di].BDS_BPB.BPB_TOTALSECTORS
	ja	baddrive
	jmp	short sanityok

sanity32:
	add	si,[start_sec_h]
	cmp	si,word ptr es:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2
	jb	sanityok
	ja	baddrive
	cmp	dx,word ptr es:[di].BDS_BPB.BPB_BIGTOTALSECTORS
	ja	baddrive

sanityok:
	mov	dx,[start_sec_h]
	add	ax,word ptr es:[di].BDS_BPB.BPB_HIDDENSECTORS
	adc	dx,word ptr es:[di].BDS_BPB.BPB_HIDDENSECTORS+2

; now dx;ax have the physical first sector.
;since the following procedures is going to destroy ax, let's
;save it temporarily to saved_word.

	mov	[saved_word],ax		; save the sector number (low)

; set up pointer to disk base table in [dpt]. we cannot assume that iosetup
; will do it because we will skip the set up stuff with hard disks.

	push	es
	mov	es,zeroseg
	les	si,dword ptr es:[dskadr]; current disk parm table
	mov	word ptr dpt,si
	mov	word ptr dpt+2,es
	pop	es			; restore bds

	TESTB	es:[di].bds_flags,fnon_removable
	jnz	skip_setup

	call	checksingle

; check to see if we have previously noted a change line.  the routine
; returns if everything is ok.	otherwise, it pops off the stack and returns
; the proper error code.

	cmp	fhave96,0		; do we have changeline support?
	jz	diskio_nochangeline	; brif not
	call	checklatchio		; will do a sneaky pop stack return
;					;  if a disk error occurs
diskio_nochangeline:
	call	iosetup		; set up tables and variables for i/o


; now the settle values are correct for the following code

skip_setup:

; 32 bit sector calculation.
; dx;[saved_word] = starting sector number.

	mov	ax,dx
	xor	dx,dx
	div	es:[di].BDS_BPB.BPB_SECTORSPERTRACK	;divide by sec per track
	mov	[temp_h],ax
	mov	ax,[saved_word]		; restore the lower word
	div	es:[di].BDS_BPB.BPB_SECTORSPERTRACK

;now, [temp_h],ax = track #, dx = sector

	inc	dl			;sector number is 1 based.
	mov	[cursec],dl		;save current sector
	mov	cx,es:[di].BDS_BPB.BPB_HEADS ;get number of heads

	push	ax
	xor	dx,dx			;divide tracks by heads per cylinder
	mov	ax,[temp_h]
	div	cx
	mov	[temp_h],ax
	pop	ax
	div	cx

;now, [temp_h],ax = cyliner #, dx = head

	cmp	[temp_h],0
	ja	baddrive_brdg
	cmp	ax,1024 		; 2**10 currently maxium for track #.
	ja	baddrive_brdg

	mov	[curhd],dl		;save current head
	mov	[curtrk],ax		;save current track

; we are now set up for the i/o.  normally, we consider the dma boundary
; violations here.  not true.  we perform the operation as if everything is
; symmetric; let the int 13 handler worry about the dma violations.

	mov	ax,[seccnt]
	call	block
	call	done			; cas - call/ret
	ret

baddrive_brdg: jmp baddrive

diskio	endp

;--------------------------------------------------------------

; set the drive-last-accessed flag for diskette only.  we know that the hard
; disk will not be removed.
; es:di -> current bds.
; ds -> Bios_Data
; ax,cx,si are destroyed.

	public	iosetup
iosetup proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,es:[di].bds_drivenum
	mov	[tim_drv],al 		; save drive letter

; determine proper head settle values

	cmp	[media_set_for_format],0
	jne	skip_dpt_setting

	mov	al,[eot]		; fetch up eot before changing ds
	push	ds			; save bios_data
	lds	si,dword ptr [dpt]	; get pointer to disk base table
	assume	ds:nothing
	mov	[si].disk_eot,al	; bump for us
	mov	al,[si].disk_motor_strt ; preserve old motor start time
	mov	ah, [si].disk_eot	; M033
	pop	ds
	assume	ds:Bios_Data
	mov	motorstartup,al
	mov	save_eot, ah		; M033

; for 3.5" drives, both external as well as on the k09, we need to set the
; motor start time to 4. this checking for every i/o is going to affect
; performance across the board, but is necessary!!

	push	ds			; save Bios_Data
	lds	si,dword ptr [dpt]	; get pointer to disk base table
	assume	ds:nothing
	cmp	es:[di].bds_formfactor,ffsmall
	jnz	motor_start_ok

	mov	al,4
	xchg	al,[si].disk_motor_strt
motor_start_ok:

; ds:si now points to disk parameter table.  get current settle and set fast
; settle

	xor	al,al
	inc	al			; ibm wants fast settle to be 1
	xchg	al,[si].disk_head_sttl	; get settle and set up for fast
	pop	ds
	assume	ds:Bios_Data
	mov	settlecurrent,al
	mov	al,normsettle		; someone has diddled the settle
gotslowsettle:
	mov	settleslow,al
skip_dpt_setting:
	ret
iosetup	endp

; set time of last access, and reset default values in the dpt.
;
;	  note:  trashes (at least) si

	public	done
done	proc	near
	assume	ds:Bios_Data,es:nothing
	TESTB	es:[di].bds_flags,fnon_removable
	jnz	ddbx			; do not set for non-removable media

	call	set_tim 		; set time of last access for drive
	FALLTHRU DiddleBack

done	endp

; restore head settle and eot values
;
;	note: trashes (at least) si

diddleback proc	near
	assume	ds:Bios_Data,es:nothing	; es:di -> bds
	pushf					;save flag
	cmp	[media_set_for_format],0
	jnz	nodiddleback

	push	ax
	push	es			; save bds pointer
	les	si,dpt

	mov	al, save_eot		; M033
	mov	es:[si].disk_eot, al	; M033

	mov	al,settlecurrent
	mov	ah,motorstartup
	mov	es:[si].disk_head_sttl,al
	mov	es:[si].disk_sector_siz,2
	mov	es:[si].disk_motor_strt,ah
	pop	es			; restore bds pointer
	pop	ax
nodiddleback:
	popf				;restore flag
ddbx:	ret
diddleback endp


;read the number of sectors specified in ax, handling track boundaries
;es:di -> bds for this drive

block	proc	near
	assume	ds:Bios_Data,es:nothing
	or	ax,ax			;see if any sectors to read
	jz	ddbx

;fixed disk will not be restricted to the track-by-track basis.

	TESTB	es:[di].bds_flags,fnon_removable  ;fixed disk?
	jz	block_floppy

;	check to see if multi track operation is allowed.  if not
;	we have to go to the block_floppy below to break up the operation.

	TESTB	multrk_flag,multrk_on
	jz	block_floppy

	call	disk
	xor	ax,ax
	ret

block_floppy:

; read at most 1 track worth.  perform minimization at sector / track

	mov	cl,byte ptr es:[di].BDS_BPB.BPB_SECTORSPERTRACK
	inc	cl
	sub	cl,cursec		; add segment override
	xor	ch,ch
	cmp	ax,cx
	jae	gotmin
	mov	cx,ax
gotmin:

; ax is the requested number of sectors to read
; cx is the number that we can do on this track

	push	ax
	push	cx
	mov	ax,cx			; al is number of sectors to read
	call	disk
	pop	cx
	pop	ax

; cx is the number of sectors just transferred

	sub	ax,cx			; reduce sectors-remaining by last i/o
	shl	cl,1
	add	bh,cl			; adjust transfer address
	jmp	block
block	endp

dskerr_brdg: jmp dskerr


;perform disk i/o with retries
; al = number of sectors (1-8, all on one track)
; es:di point to drive parameters
; xfer_seg:bx = transfer address (must not cross a 64k physical boundary)
; [rflag] = 2 if read, 3 if write
; [verify] = 0 for normal, 1 for verify after write

	public	disk
disk	proc	near
	assume	ds:Bios_Data,es:nothing

					; Check for hard disk format and
					; if TRUE then set max error count
					; to 2

	mov	bp,maxerr		; set up retry count
	TESTB	es:[di].bds_flags,fnon_removable ; Is this a fixed disk?
	jz	GetRdWrInd
	cmp	ah,romverify		; Is this a track verify?
	jz	GetRdWrInd
	mov	BP,MAX_HD_FMT_ERR 	; This is verify so only 1 retry

GetRdWrInd:
	mov	vretry_cnt,bp		;verify op. retry cnt for write-verify.
	mov	soft_ecc_cnt,bp		;soft ecc error retry count.
	mov	ah,rflag		;get read/write indicator

retry:
	push	ax

	mov	dx,[curtrk]		;load current cylinder

	TESTB	es:[di].bds_flags,fnon_removable ;fixed disk?
	jz	disk_not_mini		;no, skip this.

	cmp	es:[di].bdsm_ismini,1	;is this a mini disk?
	jnz	disk_not_mini		;no. continue to next.
	add	dx,es:[di].bdsm_hidden_trks ;else add hidden trks.
disk_not_mini:
	ror	dh,1
	ror	dh,1

	or	dh,[cursec]
	mov	cx,dx
	xchg	ch,cl			; cl = sector, ch = cylinder
	mov	dh,byte ptr [curhd]	; load current head number and
	mov	dl,es:[di].bds_drivenum	; physical drive number
	cmp	es:[di].bds_formfactor,ffhardfile
	jz	do_fast 		; hard files use fast speed

; if we have [step_drv] set to -1, we use the slow settle time.
; this helps when we have just done a resed disk operation and the head has
; been moved to another cylinder - the problem crops up with 3.5" drives.

	cmp	[step_drv],-1
	jz	do_writej
	cmp	ah,romread
	je	do_fast
	cmp	ah,romverify
	je	do_fast
do_writej:

; reads always fast, unless we have just done a disk reset operation

	jmp	short do_write		; reads always fast

do_fast:
	call	fastspeed		; change settle mode
testerr:
	jc	dskerr_brdg

; set drive and track of last access

	mov	[step_drv],dl		;  set drive
	mov	es:[di].bds_track,ch		;  save track
no_set:
	cmp	wrtverify,103h		; check for write and verify
	jz	doverify
noverify:
	pop	ax

;	check the flags word in the bds to see if the drive is non removable
;	if not we needn't do anything special
;	if it is a hard disk then check to see if multi-track operation
;	is specified.  if specified we don't have to calculate for the next
;	track since we are already done.  so we can go to the exit of this
;	routine.

	TESTB	es:[di].bds_flags,fnon_removable
	jz	its_removable

	TESTB	multrk_flag,multrk_on
	jnz	disk_ret

its_removable:
	and	cl,03fh 		; eliminate cylinder bits from sector
	xor	ah,ah
	sub	[seccnt],ax		; reduce count of sectors to go
	add	cl,al			; next sector
	mov	[cursec],cl
	cmp	cl,byte ptr es:[di].BDS_BPB.BPB_SECTORSPERTRACK ; see if sector/track limit reached
	jbe	disk_ret
nexttrack:
	mov	[cursec],1		; start with first sector of next track
	mov	dh,[curhd]
	inc	dh
	cmp	dh,byte ptr es:[di].BDS_BPB.BPB_HEADS
	jb	noxor
	xor	dh,dh
	inc	[curtrk]		;next track
noxor:
	mov	[curhd],dh
disk_ret:
	clc
	ret
disk	endp

; the request is for write.  determine if we are talking about the same
; track and drive.  if so, use the fast speed.

do_write proc	near
	assume	ds:Bios_Data,es:nothing
	cmp	dl,[step_drv]
	jnz	do_norm 		;  we have changed drives

	cmp	ch,es:[di].bds_track
	jz	do_fast 		; we are still on the same track

do_norm:
	call	normspeed
	jmp	short testerr		; test for error
do_write endp

; we have a verify request also.  get state info and go verify

doverify proc	near
	assume	ds:Bios_Data,es:nothing
	pop	ax			; restore sector count
	push	ax
	mov	ah,romverify		; request verify
	call	fastspeed		; change settle mode
	jnc	noverify

;	check the error returned in ah to see if it is a soft ecc error.
;	if it is not we needn't do anything special.  if it is a soft
;	ecc error then decrement the soft_ecc_cnt error retry count. if
;	this retry count becomes 0 then we just  ignore the error and go to
;	no_verify but if we can still try then we call the routine to reset
;	the disk and go to dskerr1 to retry the operation.

	cmp	ah,11h			;soft ecc error ?
	jnz	not_softecc_err
	dec	soft_ecc_cnt
	jz	noverify		;no more retry

	call	resetdisk		;reset disk
	jmp	short dskerr1		;retry


not_softecc_err:			;other error.
	call	resetdisk
	dec	vretry_cnt
	jmp	short dskerr0
doverify endp

; need to special case the change-line error ah=06h.  if we get this, we
; need to return it.

dskerr	proc	near
	assume	ds:Bios_Data,es:nothing
	cmp	fhave96,0		; do we have changeline support?
	jz	dskerr_nochangeline	; brif not
	call	checkio 		;|
dskerr_nochangeline:

	cmp	multitrk_format_flag,1	;multi trk format request?
	jne	dochkagain

	mov	bp,1			;no more retry.
	mov	multitrk_format_flag,0	;clear the flag.

dochkagain:
	call	again
dskerr0:
	jz	harderr

	TESTB	es:[di].bds_flags,fnon_removable
	jnz	skip_timeout_chk

	cmp	ah,80h			;timeout?
	jz	harderr

skip_timeout_chk:
	cmp	ah,0cch 		;write fault error?
	jz	write_fault_err 	; then, don't retry.

	mov	soft_ecc_cnt,maxerr	;set soft_ecc_cnt back to maxerr
dskerr1:
	pop	ax			;restore sector count
	jmp	retry

write_fault_err:
	mov	bp,1			;just retry only once for write fault error.
	jmp	dskerr1

dskerr	endp			; fall into harderr

;--------------------------------------------------------------------

	public	harderr
harderr	proc	near
	assume	ds:Bios_Data,es:nothing

	call	maperror

harderr	endp				; fall into harderr2

;--------------------------------------------------------------------

;	entry point for routines that call maperror themselves

	public	harderr2
harderr2 proc	near
	assume	ds:Bios_Data,es:nothing

	mov	[tim_drv],-1 		;force a media check through rom
	mov	cx,seccnt		;get count of sectors to go
	mov	sp,[spsav]		;recover entry stack pointer

; since we are performing a non-local goto, restore the disk parameters

	jmp	diddleback

harderr2 endp

;--------------------------------------------------------------------

; change settle value from settlecurrent to whatever is appropriate
; note that this routine is never called for a fixed disk.

normspeed proc	near
	assume	ds:Bios_Data,es:nothing

	cmp	[media_set_for_format],0
	jne	fastspeed

	push	es
	push	ax
	mov	al,settleslow
	les	si,dpt			; current disk parm table
	mov	es:[si].disk_head_sttl,al
	pop	ax
	pop	es

	call	fastspeed

	push	es
	les	si,dpt
	mov	es:[si].disk_head_sttl,1	; 1 is fast settle value
	pop	es
	ret
normspeed endp

fastspeed proc	near
	assume	ds:Bios_Data,es:nothing

; if the drive has been marked as too big (i.e. starting sector of the
; partition is > 16 bits, then always return drive not ready.

	TESTB	es:[di].bds_fatsiz,ftoobig
	jnz	notready

	push	es
	mov	es,xfer_seg
	int	13h
	mov	xfer_seg,es
	pop	es
	ret

notready:
	stc
	mov	ah,80h
	ret
fastspeed endp


; map error returned by rom in ah into corresponding code to be returned to
; dos in al.  trashes di.  guaranteed to set carry.


maperror proc	near
	public	maperror
	assume	ds:Bios_Data,es:nothing

	push	cx			; save cx
	push	es			; preserve es
	push	ds			; set es=Bios_Data
	pop	es

	mov	al,ah			;put error code in al
	mov	[lsterr],al		;terminate list with error code
	mov	cx,numerr		;number of possible error conditions
	mov	di,offset errin 	;point to error conditions
	repne	scasb
	mov	al,[di + numerr - 1] ;get translation

	pop	es			; restore caller's es
	pop	cx			; restore cx
	stc				;flag error condition
	ret
maperror endp

; set the time of last access for this drive. this is done only for removable
; media.  es:di -> bds

set_tim proc	near
	assume	ds:Bios_Data,es:nothing

	push	ax

	call	GetTickCnt		; M059 Does INT 1A ah=0 & updates daycnt

; we have the new time. if we see that the time has passed, then we reset
; the threshold counter...

	cmp	dx,es:[di].bds_tim_lo
	jnz	setaccess
	cmp	cx,es:[di].bds_tim_hi
	jz	done_set

setaccess:
	mov	byte ptr [accesscount],0
	mov	es:[di].bds_tim_lo,dx 	    	;save it
	mov	es:[di].bds_tim_hi,cx
done_set:
	clc
	pop	ax
	ret
set_tim endp

; this routine is called if an error occurs while formatting or verifying.
; it resets the drive,and decrements the retry count.
; on entry - ds:di - points to bds for the drive
;	     bp    - contains retry count
; on exit    flags indicate result of decrementing retry count

again	proc	near
	call	resetdisk
	cmp	ah, 6			; M039
	je	dont_dec_retry_count	; If it is a media change error M039
					;  do not decrement retry count
	dec	bp			; decrement retry count
	ret
dont_dec_retry_count:			;		M039
	or	ah, ah			; return NZ	M039
	ret				;		M039
again	endp


Bios_Code ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msequ.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */

ftoobig 	equ	80h
fbig		equ	40h
romstatus	equ	1
romread 	equ	2
romwrite	equ	3
romverify	equ	4
romformat	equ	5


rsinit	=	0a3h	;rs232 initialization
			;9600 baud:no parity:1 stop:8 bit word

lf	=	10	;line feed
cr	=	13	;carriage return
backsp	=	8	;backspace
brkadr	=	1bh * 4	;006c	1bh break vector address
timadr	=	1ch * 4	;0070	1ch timer interrupt
dskadr	=	1eh * 4	;address of ptr to disk parameters
sec9	=	522h	;address of disk parameters
headsettle=	sec9+9	;address of head settle time
normsettle=	15	;normal head settle
speedsettle=	0	;speed up settle time
initspot=	534h	;ibm wants 4 zeros here
akport	=	20h
eoi	=	20h

cmdlen	=	0	;length of this command
unit	=	1	;sub unit specifier
cmd	=	2	;command code
status	=	3	;status
media	=	13	;media descriptor
trans	=	14	;transfer address
count	=	18	;count of blocks or characters
start	=	20	;first block to transfer
extra	=	22	;usually a pointer to vol id for error 15
start_l =	26	; extended start sector (low)
start_h =	28	; extended start sector (high)


chrout	=	29h
maxerr	=	5
lstdrv	=	504h

bootbias	=	200h
notbusystatus	=	10000000b	; not busy
ackstatus	=	01000000b	; acknowledge (for what?)
nopaperstatus	=	00100000b	; no more paper
selectedstatus	=	00010000b	; the printer said it was selected
ioerrstatus	=	00001000b	; some kinda error
reserved	=	00000110b	; nops
timeoutstatus	=	00000001b	; time out.
error_unknown_media = 7			; for use in build bpb call


; Boot options flags for ROMDOS

ifdef ROMDOS

BF_NoConfig	=	00000001b	; No config.sys processing
BF_DefaultMask	=	00000110b	; Bits to indicate default drive:
BF_DefFloppy	=	00000000b	; 	First floppy drive (00)
BF_DefHard	=	00000010b 	;	First hard drive   (80)
BF_DefROM	=	00000100b	;	ROM drive          (7F)

endif



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msgroup.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */

tocode	macro
Bios_Data	ends
Bios_Code	segment
	assume	cs:Bios_Code
	endm

todata	macro
Bios_Code	ends
Bios_Data	segment
	assume	cs:Bios_Data
	endm

;align the segment on word boundary to allow for even alignment of data

Bios_Data	segment
	assume	cs:Bios_Data


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msbio2.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title msbio2 - bios
;
;----------------------------------------------------------------------------
;
; M052 : Resolved the confusion of media byte F9. BIOS used to default to 1.2M
;	 drive if formfactor was != ffsmall & mediabyte = f9.
;
;----------------------------------------------------------------------------
;
	include version.inc	; set build flags
	include biosseg.inc	; define segment structure

	include msequ.inc
	include	bpb.inc
	include	msbds.inc
	include	bootform.inc

;	include	mult.inc
multMULT	equ	4ah
multMULTSWPDSK	equ	0
;


;***	define where the rom routines are actually located
;	   in the buggy old AT BIOS that we might need to
;	   install a special level of int13 handler for


rom	segment at 0f000h

	org	2e1eh
romcommand	label	far

	org	2e7fh
romwait		label	far

	org	2ee2h
romwait_drq	label	far

	org	2ef8h
romcheck_status	label	far

	org	2f69h
romcheck_dma	label	far

	org	2f8eh
romget_vec	label	far

	org	0ff65h	; far return in rom
romfret		label	far

rom	ends

	include msgroup.inc	; define Bios_Data segment

;	Most of the disk routines keep es:[di] set up pointing to the
;	  currently selected bds.  This is often assumed to be the standard
;	  operating environment and in some cases may not be mentioned in
;	  the subroutine headers where it will be assumed.



	extrn	eot:byte
	extrn	fhave96:byte
	extrn	old13:dword

	extrn	ptrsav:dword
	extrn	start_bds:dword
	extrn	fdrive1:word
	extrn	fdrive2:word
	extrn	fdrive3:word
	extrn	fdrive4:word
	extrn	tim_drv:byte
	extrn	medbyt:byte
	extrn	drvmax:byte
	extrn	disksector:byte

	extrn	dskdrvs:word


;   data structures for real-time date and time

	extrn	bin_date_time:byte
	extrn	month_table:word
	extrn	daycnt2:word
	extrn	feb29:byte

	extrn	nul_vid:byte
	extrn	tmp_vid:byte
;SR;
; WIN386 presence flag
;
	extrn	IsWin386:byte
;
; WIN386 routine to set focus to VM
;
	extrn	V86_Crit_SetFocus:far


; CODE segment declarations...

	tocode

	extrn	Bios_Data_Word:word
	extrn	con_flush:near
	extrn	setptrsav:near
	extrn	harderr:near
	extrn	harderr2:near
	extrn	maperror:near
	extrn	getbp:near
	extrn	checksingle:near
	extrn	check_time_of_access:near
	extrn	has1:near
	extrn	Has720K:near		; M052
	extrn	read_sector:near


	public	dsk_init
dsk_init proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah,byte ptr drvmax
	mov	di,offset dskdrvs
	push	ds			; pass result in es:di
	pop	es
	jmp	setptrsav
dsk_init endp


; install_bes installs a bds at location ds:di into the current linked list of
; bds maintained by this device driver. it places the bds at the end of the
; list.  Trashes (at least) ax, bx, di, si

	public	install_bds
install_bds	proc	near
	assume	ds:Bios_Data,es:nothing

	push	ds			; save Bios_Data segment
	mov	si,offset start_bds	; beginning of chain

;	ds:si now points to link to first bds
;	  assume bds list is non-empty

loop_next_bds:
	lds	si,[si].bds_link		; fetch next bds
	mov	al,es:[di].bds_drivenum	; does this one share a physical
	cmp	[si].bds_drivenum,al	;  drive with new one?
	jnz	next_bds

	mov	bl,fi_am_mult		; set both of them to i_am_mult if so
	or	byte ptr es:[di].bds_flags,bl
	or	byte ptr [si].bds_flags,bl
	and	byte ptr es:[di].bds_flags,not fi_own_physical ; we don't own it

	mov	bl,byte ptr [si].bds_flags	; determine if changeline available
	and	bl,fchangeline
	or	byte ptr es:[di].bds_flags,bl

next_bds:
	cmp	word ptr [si].bds_link,-1	; are we at end of list?
	jnz	loop_next_bds

	mov	word ptr [si].bds_link+2,es ; install bds
	mov	word ptr [si].bds_link,di
	mov	word ptr es:[di].bds_link,-1	; set next pointer to null
	pop	ds			; restore Bios_Data

;	**** If the new drive has a higher EOT value, we must alter the
;	     'eot' variable appropriately.

	mov	al,byte ptr es:[di].BDS_RBPB.BPB_SECTORSPERTRACK
	cmp	al,eot
	jbe	eot_ok
	mov	eot,al
eot_ok:
	ret

install_bds endp

;-------------------------------------------------
;
;  ask to swap the disk in drive a:
;	es:di -> bds
;	ds -> Bios_Data
;
	public	swpdsk
swpdsk	proc	near
	assume	ds:Bios_Data,es:nothing

;SR;
; Set focus to the VM within which this message is to be issued
;
	test	[IsWin386],1	;Is win386 present?
	jz	no_win386	;no, skip SetFocus

	call	V86_Crit_SetFocus	;set focus to the correct VM

no_win386:
	push	cx
	push	dx			; save what we use

	mov	dl, es:[di].bds_drivelet; get the drive letter
;
; WARNING : next two instructions assume that if the new disk is for drive B
;           then existing dsk is drive A & vice versa
;
	mov	dh, dl
	xor	dh, 1
	sub	cx, cx			; nobody has handled swap disk
	mov	ax, (multMULT shl 8) or multMULTSWPDSK
					; broad cast code for swap disk
	int	2fh			; Braodcast it
	inc	cx			; cx == -1 ?
	jz	swpdsk9			; somebody has handled it

;using a different drive in a one drive system so request the user change disks

	add	dl,"A"
IFNDEF ROMDOS				; M095 Can't write to ROM locations
	mov	cs:drvlet,dl
ENDIF					; M095
	mov	si,offset sngmsg	; cs:si -> message
	push	bx
	
	lods	cs:byte ptr [si]	;get the next character of the message
wrmsg_loop:
	int	29h

IFDEF ROMDOS				; M095 Begin
	cmp	SI, OFFSET drvlet	; Set the flags for latter
	lods	cs:byte ptr [si]	; Get next character
	jne	@f			; IF not drive letter keep this char
	mov	AL,DL			; ELSE use driver letter from DL
@@:
ELSE
	lods	cs:byte ptr [si]
ENDIF					; M095 End
	or	al,al
	jnz	wrmsg_loop

	call	con_flush		; flush out keyboard queue
	xor	ah,ah			; set command to read character
	int	16h			; call rom-bios
	pop	bx
swpdsk9:
	pop	dx
	pop	cx
	ret
swpdsk	endp

	include msbio.cl2

; input : es:di points to current bds for drive.
; return : zero set if no open files
;	   zero reset if open files

chkopcnt proc near
	assume	ds:Bios_Data,es:nothing

	cmp	es:[di].bds_opcnt,0
	ret

chkopcnt endp


; at media check time, we need to really get down and check what the change is.
; this is guaranteed to be expensive.
;
;	es:di -> bds, ds -> Bios_Data

	public mediacheck
mediacheck proc near
	assume	ds:Bios_Data,es:nothing

	call	checksingle		; make sure correct disk is in place
	xor	si,si
	call	haschange
	jz	mediaret

	call	checkromchange
	jnz	mediadovolid

	push	ax
	push	dx

	mov	dl,es:[di].bds_drivenum	; set logical drive number
	mov	ah,16h 			; get changeline status
	int	13h			; call rom diskette routine

	pop	dx
	pop	ax
	jc	mediadovolid
	mov	si,1			; signal no change

; there are some drives with changeline that "lose" the changeline indication
; if a different drive is accessed after the current one. in order to avoid
; missing a media change, we return an "i don't know" to dos if the changeline
; is not active and we are accessing a different drive from the last one.
; if we are accessing the same drive, then we can safely rely on the changeline
; status.

	mov	bl,[tim_drv] 		; get last drive accessed
	cmp	es:[di].bds_drivenum,bl
	jz	mediaret

; do the 2 second twiddle. if time >= 2 seconds, do a volid check.
; otherwise return "i don't know" (strictly speaking, we should return a
; "not changed" here since the 2 second test said no change.)

	push	ax
	push	cx
	push	dx

	call	check_time_of_access

	pop	dx
	pop	cx
	pop	ax

	or	si,si
	jz	mediadovolid		; check_time says ">= 2 secs passed"

	xor	si,si			; return "i don't know"

mediaret:
	ret

; somehow the media was changed.  look at vid to see. we do not look at fat
; because this may be different since we only set medbyt when doing a read
; or write.

mediadovolid:
	call	getbp		       ; build a new bpb in current bds
	jc	mediaret

	call	check_vid
	jnc	mediaret

	jmp	maperror		; fix up al for return to dos
mediacheck endp

; simple, quick check of latched change.  if no indication, then return
; otherwise do expensive check.  if the expensive test fails, pop off the
; return and set al = 15 (for invalid media change) which will be returned to
; dos.
;
; for dos 3.3, this will work only for the drive that has changeline.


;	call with es:di -> bds, ds -> Bios_Data
;	***** warning:  this routine will return one level up on the stack
;			if an error occurs!

	public checklatchio
checklatchio proc near
	assume	ds:Bios_Data,es:nothing

; if returning fake bpb then assume the disk has not changed

	call	chkopcnt
	jz	checkret	; done if zero

; check for past rom indications.  if no rom change indicated, then return ok.

	call	checkromchange
	jz	checkret		; no change

; we now see that a change line has been seen in the past.  let's do the
; expensive verification.

	call	getbp			; build bpb in current bds
	jc	ret_no_error_map	; getbp has already called maperror

	call	check_vid
	jc	checklatchret		; disk error trying to read in.

	or	si,si			; is changed for sure?
	jns	checkret

	call	returnvid
checklatchret:
	call	maperror		; fix up al for return to dos
ret_no_error_map:
	stc
	pop	si			; pop off return address
checkret:
	ret

checklatchio endp

; check the fat and the vid.  return in di -1 or 0.  return with carry set
; only if there was a disk error.  return that error code in ax.
;
;	called with es:di -> bds, ds -> Bios_Data

checkfatvid proc near
	assume	ds:Bios_Data,es:nothing

	call	fat_check
	or	si,si
	js	changed_drv

;	the fat was the same.  fall into check_vid and check volume id.

checkfatvid endp			; fall into check_vid

;now with the extended boot record, the logic should be enhanced.
;
;if it is the extended boot record, then we check the volume serial
;number instead of volume id. if it is different, then set si to -1.
;
;if it is same, then si= 1 (no change).
;
;if it is not the extended boot record, then just follows the old
;logic. dos 4.00 will check if the # of fat in the boot record bpb
;is not 0.  if it is 0 then it must be non_fat based system and
;should have already covered by extended boot structure checking.
;so, we will return "i don't know" by setting si to 0.
;
;this routine assume the newest valid boot record is in cs:[disksector].
;(this will be gauranteed by a successful getbp call right before this
;routine.)
;
;	called with es:di -> bds, ds -> bds

check_vid proc	near
	assume	ds:Bios_Data,es:nothing

;	check the disksector.EXT_BOOT_SIG variable for the extended
;	   boot signature.  if it is set then go to do the extended
;	   id check otherwise continue with code below

	cmp	disksector.EXT_BOOT_SIG,ext_boot_signature
	jz	do_ext_check_id

	call	haschange
	jz	checkret

	xor	si,si				; assume i don't know.
	cmp	disksector.EXT_BOOT_BPB.BPB_NUMBEROFFATS,0 ; don't read vol id
	je	checkfatret			; from the directory if not
						; fat system
	call	read_volume_id
	jc	checkfatret

	call	check_volume_id
	mov	si,-1				; definitely changed
	jnz	changed_drv
	inc	si				; not changed

vid_no_changed:
	call	resetchanged
	clc
checkfatret:
	ret

changed_drv:
	clc				; cas -- return no error
	mov	[tim_drv],-1 		; ensure that we ask rom for media
	ret				; check next time round


; extended id check

do_ext_check_id:
	push	ax

;**************************************************************
;	the code to check extended id is basically a check to see if the
;	volume serial number is still the same.  the volume serial number
;	previously read is in cs:disksector.EXT_BOOT_SERIAL
;	ds:di points to the bds of the
;	drive under consideration.  the bds has fields containing the
;	high and low words of the volume serial number of the media in the
;	drive.	compare these fields to the fields mentioned above.  if these
;	fields do not match the media has changed and so we should jump
;	to the code starting at ext_changed else return "i don't know" status
;	in the register used for the changeline status and continue executing
;	the code given below.  for temporary storage use the register which
;	has been saved and restored around this block.
;
;	bds fields in inc\msbds.inc

	mov	ax,word ptr disksector.EXT_BOOT_SERIAL
	cmp	ax,word ptr es:[di].bds_vol_serial
	jnz	ext_changed
	mov	ax,word ptr disksector.EXT_BOOT_SERIAL+2
	cmp	ax,word ptr es:[di].bds_vol_serial+2
	jnz	ext_changed
	xor	si,si			; don't know

	pop	ax
	jmp	vid_no_changed		;reset the flag

ext_changed:				; serial number is different!
	pop	ax
	mov	si,-1			; disk changed!
	clc				; clear carry. only si is meaningful here.
	jmp	changed_drv

check_vid endp

; at i/o time, we detected the error.  now we need to determine whether the
; media was truly changed or not.  we return normally if media change unknown.
; and we pop off the call and jmp to harderr if we see an error.
;
;	es:di -> bds

	public	checkio
checkio	proc	near
	assume	ds:Bios_Data,es:nothing

	cmp	ah,06
	jnz	checkfatret
	call	chkopcnt
	jz	checkfatret		; no open files

	call	getbp			; build up a new bpb in current bds

	jc	no_error_map		; getbp has already called maperror

	call	checkfatvid
	jc	checkioret		; disk error trying to read in.
	or	si,si			; is changed for sure?
	js	checkioerr		; yes changed

ignorechange:
	inc	bp			; allow a retry
	ret

checkioerr:
	call	returnvid
checkioret:
	stc				; make sure carry gets passed through
	jmp	harderr

no_error_map:
	jmp	harderr2
checkio	endp

; return vid sets up the vid for a return to dos.
;	es:di -> bds, returns pointer in packet to bds_volid
;	  **** trashes si! ****

returnvid proc	near
	assume	ds:Bios_Data,es:nothing

	mov	si,extra		; offset into pointer to return value
	call	vid_into_packet
	mov	ah,6			; invalid media change
	stc
	ret

returnvid endp

; moves the pointer to the volid for the drive into the original request packet
; no attempt is made to preserve registers.
;
;	assumes es:di -> bds
;	  **trashes si**

	public media_set_vid
media_set_vid proc near
	assume	ds:Bios_Data,es:nothing

	mov	si,trans+1		; return the value here in packet

media_set_vid	endp			; fall into vid_into_packet


;	return pointer to vid in bds at es:di in packet[si]

vid_into_packet proc near
	assume	ds:Bios_Data,es:nothing

	push	ds			; save Bios_Data
	lds	bx,[ptrsav]
	assume	ds:nothing
	add	di,bds_volid
	mov	[bx.si],di
	sub	di,bds_volid		; restore bds
	mov	[bx.si.2],es
	pop	ds			; restore Bios_Data
	assume	ds:Bios_Data
	ret

vid_into_packet endp


;   hidensity - examine a drive/media descriptor to set the media type.  if
;   the media descriptor is not f9 (not 96tpi or 3 1/2), we return and let the
;   caller do the rest.  otherwise, we pop off the return and jump to the tail
;   of getbp. for 3.5" media, we just return.
;
;   inputs:	es:di point to correct bds for this drive
;		ah has media byte
;
;   outputs:	carry clear
;		    no registers modified
;		carry set
;		    al = sectors/fat
;		    bh = number of root directory entries
;		    bl = sectors per track
;		    cx = number of sectors
;		    dh = sectors per allocation unit
;		    dl = number of heads
;
	public hidensity
hidensity proc near
	assume	ds:Bios_Data,es:nothing

; check for correct drive

	test	es:[di].bds_flags,fchangeline	; is it special?
	jz	dofloppy		; no, do normal floppy test

; we have a media byte that is pretty complex.	examine drive information
; table to see what kind it is.

	cmp	es:[di].bds_formfactor,ffsmall ;  is it single-media?
	jz	dofloppy		; yes, use fatid...

; 96 tpi drive

	cmp	ah,0f9h
	jnz	dofloppy

;
;------ If formfactor of drive = ffother or ff288 it has to be ; M052
;------ a 720K diskette					       ; M052
;
	cmp	es:[di].bds_formfactor,ffother	; M052
	je	Is720k				; M052

	cmp	es:[di].bds_formfactor,ff288	; M052
	je	Is720k				; M052

	mov	al,7			; seven sectors / fat
	mov	bx,224*256+0fh		; 224 root dir entries & 0f sector max
	mov	cx,80*15*2		; 80 tracks, 15 sectors/track, 2 sides
	mov	dx,01*256+2		; sectors/allocation unit & head max
	add	sp,2			; pop off return address
	jmp	has1			; return to tail of getbp
Is720K:					;			 M052
	add	sp,2			; pop off return address M052
	jmp	Has720K			; return to 720K code	 M052
dofloppy:
	ret

hidensity endp

; set_changed_dl - sets flag bits according to bits set in bx.
;		   essentially used to indicate changeline, or format.
;
;   inputs:	dl contains physical drive number
;		bx contains bits to set in the flag field in the bdss
;   outputs:	none
;   registers modified: flags
;
;	called from int13 hooker.  Must preserve ALL registers!!!
;
; in the virtual drive system we *must* flag the other drives as being changed

	public	set_changed_dl
set_changed_dl proc near
	assume	ds:Bios_Data,es:nothing

	push	es		    ; save current bds
	push	di

	les	di,[start_bds]

;	note:  we assume that the list is non-empty

scan_bds:
	cmp	es:[di].bds_drivenum,dl
	jnz	get_next_bds

; someone may complain, but this *always* must be done when a disk change is
; noted.  there are *no* other compromising circumstances.

	or	es:[di].bds_flags,bx		; signal change on other drive

get_next_bds:
	les	di,es:[di].bds_link		; go to next bds
	cmp	di,-1
	jnz	scan_bds		; loop unless we hit end of chain

skipset:
	pop	di			; restore registers
	pop	es
	ret

set_changed_dl endp


; checkromchange - see if external program has diddled rom change line.
;
;   inputs:	es:di points to current bds.
;   outputs:	zero set - no change
;		zero reset - change
;   registers modified: none

checkromchange proc near
	assume	ds:Bios_Data,es:nothing

	test	es:[di].bds_flags,fchanged
	ret

checkromchange	endp

; resetchanged - restore value of change line
;
;   inputs:	es:di points to current bds
;   outputs:	none
;   registers modified: none

	public	resetchanged
resetchanged proc near
	assume	ds:Bios_Data,es:nothing

	and	es:[di].bds_flags,not fchanged
	ret

resetchanged endp

; haschange - see if drive can supply change line
;
;   inputs:	es:di points to current bds
;   outputs:	zero set - no change line available
;		zero reset - change line available
;   registers modified: none

	public	haschange
haschange proc near
	assume	ds:Bios_Data,es:nothing

	test	es:[di].bds_flags,fchangeline
	ret

haschange	endp


;-------------------------------------------------------------------------
;
;	   set_volume_id       -	main routine, calls other routines.
;	   read_volume_id      -	read the volume id and tells if it has
;					   been changed.
;	   transfer_volume_id  -	copy the volume id from tmp to special
;					   drive.
;	   check_volume_id     -	compare volume id in tmp area with one
;					   expected for drive.
;	   fat_check	       -	see of the fatid has changed in the
;					   specified drive.

;-------------------------------------------------------------------------

; set_volume_id
;   if drive has changeline support, read in and set the volume_id
; and the last fat_id byte.  if no change line support then do nothing.
;
;   on entry:
;	es:di points to the bds for this disk.
;	ah contains media byte
;
;   on exit:
;	carry clear:
;	   successful call
;	carry set
;	   error and ax has error code
;

	public set_volume_id
set_volume_id	proc	near
	assume	ds:Bios_Data,es:nothing

	push	dx			; save registers
	push	ax
	call	haschange		; does drive have changeline support?
	jz	setvret 		; no, get out

	call	read_volume_id		; read the volume id
	jc	seterr			; if error go to error routine

	call	transfer_volume_id	; copy the volume id to special drive
	call	resetchanged		; restore value of change line

setvret:				; set volume return
	clc				; no error, clear carry flag
	pop	ax			; restore registers
	pop	dx
	ret

seterr:
	pop	dx			; pop stack but don't overwrite ax
	pop	dx			; restore dx
	ret

set_volume_id	endp

root_sec	dw	?	;root sector #


; read_volume_id read the volume id and tells if it has been changed.
;
;   on entry:
;	es:di points to current bds for drive.
;
;   on exit:
;	carry clear
;	    si = 1  no change
;	    si = 0  ?
;	    si = -1 change
;
;	carry set:
;	    error and ax has error code.

read_volume_id proc near
	assume	ds:Bios_Data,es:nothing

	push	dx			; preserve registers
	push	cx
	push	bx
	push	ax

	push	es			; stack the bds last
	push	di

	push	ds			; point es to Bios_Data
	pop	es

	mov	di,offset tmp_vid
	mov	si,offset nul_vid
	mov	cx,VOLID_SIZ
	rep	movsb			; initialize tmp_vid to null vi_id

	pop	di			; restore current bds
	pop	es

	mov	al,es:[di].BDS_BPB.BPB_NUMBEROFFATS    	; # of fats
	mov	cx,es:[di].BDS_BPB.BPB_SECTORSPERFAT 	; sectors / fat
	mul	cl			; size taken by fats
	add	ax,es:[di].BDS_BPB.BPB_RESERVEDSECTORS  ; add on reserved sectors

					; ax is now sector # (0 based)
	mov	[root_sec],ax		; set initial value
	mov	ax,es:[di].BDS_BPB.BPB_ROOTENTRIES ; # root dir entries
	mov	cl,4			; 16 entries/sector
	shr	ax,cl			; divide by 16
	mov	cx,ax			; cx is # of sectors to scan

next_sec:
	push	cx			; save outer loop counter
	mov	ax,[root_sec]		; get sector #
	mov	cx,es:[di].BDS_BPB.BPB_SECTORSPERTRACK	; sectors / track
	xor	dx,dx
	div	cx

;	set up registers for call to read_sector

	inc	dx		; dx= sectors into track, ax= track count from 0
	mov	cl,dl		; sector to read
	xor	dx,dx
	div	es:[di].BDS_BPB.BPB_HEADS ; # heads on this disc
	mov	dh,dl		; head number
	mov	ch,al		; track #

	call	read_sector	; get first sector of the root directory,

				; ds:bx -> directory sector
	jc	readviderr	; error on read

	mov	cx,16		; # of dir entries in a block of root
	mov	al,08h		; volume label bit

fvid_loop:
	cmp	byte ptr [bx],0		; end of dir?
	jz	no_vid		; yes, no vol id
	cmp	byte ptr [bx],0e5h	; empty entry?
	jz	ent_loop	; yes, skip
	test	[bx+11],al	; is volume label bit set in fcb?
	jnz	found_vid	; jmp yes
ent_loop:
	add	bx,32		;add length of directory entry
	loop	fvid_loop

	pop	cx		; outer loop
	inc	[root_sec]	; next sector
	loop	next_sec	; continue
notfound:
	xor	si,si
	jmp	short fvid_ret

found_vid:
	pop	cx		; clean stack of outer loop counter
	mov	si,bx		; point to volume_id
	push	es		; preserve currnet bds
	push	di
	push	ds
	pop	es		; point es to Bios_Data
	mov	di,offset tmp_vid ; dest of volume_id
	mov	cx,VOLID_SIZ -1 ; length of string minus nul
	rep	movsb		; mov volume label to tmp_vid
	xor	al,al
	stosb			; null terminate
	xor	si,si
	pop	di		; restore current bds
	pop	es
fvid_ret:
	pop	ax
	clc
rvidret:
	pop	bx		; restore register
	pop	cx
	pop	dx
	ret

no_vid:
	pop	cx		; clean stack of outer loop counter
	jmp	notfound	; not found

readviderr:
	pop	si		; trash the outer loop counter
	pop	si		; caller's ax, return our error code instead
	jmp	rvidret

read_volume_id endp


;   transfer_volume_id - copy the volume id from tmp to special drive
;
;   inputs:	es:di has current bds
;   outputs:	bds for drive has volume id from tmp

transfer_volume_id proc near
	assume	ds:Bios_Data,es:nothing

	push	di		; preserve bds
	push	si
	push	cx

	mov	si,offset tmp_vid   ; source
	add	di,bds_volid
	mov	cx,VOLID_SIZ

	cld
	rep	movsb		; transfer

	pop	cx
	pop	si
	pop	di		; restore current bds
	ret

transfer_volume_id endp

;   check_volume_id - compare volume id in tmp area with one expected for
;	drive
;
;   inputs:	es:di has current bds for drive
;   outputs:	zero true means it matched

check_volume_id proc near
	assume	ds:Bios_Data,es:nothing

	push	di
	push	cx

	mov	si,offset tmp_vid
	add	di,bds_volid
	mov	cx,VOLID_SIZ

	cld
	repz	cmpsb			; are the 2 volume_ids the same?

	pop	cx
	pop	di			; restore current bds
	ret

check_volume_id	endp

;   fat_check - see of the fatid has changed in the specified drive.
;	      - uses the fat id obtained from the boot sector.
;
;   inputs:	medbyt is expected fat id
;		es:di points to current bds
;
;   output:	si = -1 if fat id different,
;		si = 0 otherwise
;
;   no other registers changed.

fat_check proc	near
	assume	ds:Bios_Data,es:nothing

	push	ax
	xor	si,si			 ; say fat id's are same.
	mov	al,medbyt
	cmp	al,es:[di].BDS_BPB.BPB_MEDIADESCRIPTOR 	; compare it with the bds medbyte
	jz	okret1			; carry clear
	dec	si
okret1:
	pop	ax
	ret

fat_check endp


	public end96tpi_code
end96tpi_code label byte

Bios_Code	ends

;	title:	disk

;		there is a bug in some versions of ibm's at rom bios.
;		interrupts are not disabled during read operations.
;
;	use:	this program should be chained in line with the disk
;		interupt 13h, it intercepts read calls to the hard disk
;		and handles them appropriately.  for other functions it
;		passes controll to old13, which should contain the
;		address of the at rom disk routine. the entry point for
;		this program is ibm_disk_io.
;

	.286c		;use 80286 non-protected mode

bioseg		= 040h		;segment for rom bios data

bad_disk 	= 01

hf_port 	= 01f0h
hf_reg_port 	= 03f6h

;*	offsets into fixed disk parameter table

fdp_precomp	= 5
fdp_control 	= 8

data	segment at bioseg	;rom bios data segment

	org 42h
cmd_block	db 6 dup (?)

;*	offsets into cmd_block for registers

pre_comp = 0	;write pre-compensation
sec_cnt	 = 1	;sector count
sec_num	 = 2	;sector number
cyl_low	 = 3	;cylinder number, low part
cyl_high = 4	;cylinder number, high part
drv_head = 5	;drive/head (bit 7 = ecc mode, bit 5 = 512 byte sectors, 
		;            bit 4 = drive number, bits 3-0 have head number)
cmd_reg  = 6	;command register


	org 074h

disk_status1 	db ?
hf_num		db ?
control_byte	db ?

data	ends

;
; Possibly disposable data, goes at end of data group
;


Bios_Data_Init	segment

	extrn	old13:dword		;link to at bios int 13h

public	ibm_disk_io	

	assume cs:datagrp
	assume ds:data


;***	ibm_disk_io - main routine, fixes at rom bug
;
;	entry:	(ah) = function, 02 or 0a for read.
;		(dl) = drive number (80h or 81h).
;		(dh) = head number.
;		(ch) = cylinder number.
;		(cl) = sector number (high 2 bits has cylinder number).
;		(al) = number of sectors.
;		(es:bx) = address of read buffer.
;		for more on register contents see rom bios listing.
;		stack set up for return by an iret.
;
;	exit:	(ah) = status of current operation.
;		(cy) = 1 if failed, 0 if successful.
;		for other register contents see rom bios listing.
;
;	uses:	
;
;
;	warning: uses old13 vector for non-read calls.
;		does direct calls to the at rom.
;		does segment arithmatic.
;
;	effects: performs disk i/o operation.

ibm_disk_io proc far
	assume	ds:data,es:nothing

	cmp	dl,80h
	jb	atd1		;pass through floppy disk calls.
	cmp	ah,02
	je	atd2		;intercept call 02 (read sectors).
	cmp	ah,0ah
	je	atd2		;and call 0ah (read long).

atd1:
	jmp	old13		;use rom int 13h handler.

atd2:
	push	bx
	push	cx
	push	dx
	push	di
	push	ds
	push	es
	push	ax

	mov	ax,bioseg	;establish bios segment addressing.
	mov	ds,ax

	mov	disk_status1,0	;initially no error code.
	and	dl,7fh		;mask to hard disk number
	cmp	dl,hf_num
	jb	atd3		;disk number in range

	mov	disk_status1,bad_disk
	jmp	short atd4	;disk number out of range error, return

atd3:
	push	bx
	mov	ax,es		;make es:bx to seg:000x form.
	shr	bx,4
	add	ax,bx
	mov	es,ax
	pop	bx
	and	bx,000fh
	push	cs
	call	check_dma
	jc	atd4		;abort if dma across segment boundary

	pop	ax		;restore ax register for setcmd
	push	ax
	call	setcmd		;set up command block for disk op
	mov	dx,hf_reg_port
	out	dx,al		;write out command modifier
	call	docmd		;carry out command
atd4:

;---------------------------------------------------
;  new code - let logical or clear carry and then set carry if ah!=0
;	       and save a couple bytes while were at it.

	pop	ax
	mov	ah,disk_status1	;on return ah has error code
	or	ah,ah
	jz	atd5		;carry set if error

	stc

atd5:
	pop	es
	pop	ds
	pop	di
	pop	dx
	pop	cx
	pop	bx
	ret	2		;far return, dropping flags

ibm_disk_io endp

;***	setcmd - set up cmd_block for the disk operation
;
;	entry:	(ds) = bios data segment.
;		(es:bx) in seg:000x form.
;		other registers as in int 13h call
;	
;	exit:	cmd_block set up for disk read call.
;		control_byte set up for disk operation.
;		(al) = control byte modifier
;
;
;	sets the fields of cmd_block using the register contents
;	and the contents of the disk parameter block for the given drive.
;
;	warning: (ax) destroyed.
;		does direct calls to the at rom.

setcmd	proc near
	assume	ds:data,es:nothing

	mov	cmd_block[sec_cnt],al
	mov	cmd_block[cmd_reg],020h ;assume function 02
	cmp	ah,2
	je	setc1			;cmd_reg = 20h if function 02 (read)

	mov  cmd_block[cmd_reg],022h	;cmd_reg = 22h if function 0a (" long)

setc1:					;no longer need value in ax
	mov	al,cl
	and	al,03fh			;mask to sector number
	mov	cmd_block[sec_num],al
	mov	cmd_block[cyl_low],ch
	mov	al,cl
	shr	al,6			;get two high bits of cylender number
	mov	cmd_block[cyl_high],al
	mov	ax,dx
	shl	al,4			;drive number
	and	ah,0fh
	or	al,ah			;head number
	or	al,0a0h			;set ecc and 512 bytes per sector
	mov	cmd_block[drv_head],al

	push	es			;get_vec destroys es:bx
	push	bx
	push	cs
	call	get_vec
	mov	ax,es:fdp_precomp[bx]	;write pre-comp from disk parameters
	shr	ax,2
	mov	cmd_block[pre_comp],al	;only use low part
	mov	al,es:fdp_control[bx]	;control byte modifier
	pop	bx
	pop	es
	mov	ah,control_byte
	and	ah,0c0h			;keep disable retry bits
	or	ah,al
	mov	control_byte,ah
	ret
setcmd	endp	


;***	docmd - carry out read operation to at hard disk
;
;	entry:	(es:bx) = address for read in data.
;		cmd_block set up for disk read.
;
;	exit:	buffer at (es:bx) contains data read.
;		disk_status1 set to error code (0 if success).
;
;	
;
;	warning: (ax), (bl), (cx), (dx), (di) destroyed.
;		no check is made for dma boundary overrun.
;
;	effects: programs disk controller.
;		performs disk input.

docmd	proc	near
	assume	ds:data,es:nothing

	mov	di,bx		;(es:di) = data buffer addr.
	push	cs
	call	command
	jnz	doc3
doc1:
	push	cs
	call	waitt		;wait for controller to complete read
	jnz	doc3
	mov	cx,100h		;256 words per sector
	mov	dx,hf_port
	cld			;string op goes up
	cli			;disable interrupts (bug was forgetting this)

;	M062 -- some of these old machines have intermittent failures
;		when the read is done at full speed.  Instead of using
;		a string rep instruction, we'll use a loop.  There is
;		a slight performance hit, but it only affects these
;		very old machines with an exact date code match, and
;		it makes said machines more reliable
;
;M062	repz	insw		;read in sector

rsct_loop:			; M062
	insw			; M062 read in sector
	loop	rsct_loop	; M062

  	sti
	test	cmd_block[cmd_reg],02
	jz	doc2		;no ecc bytes to read.
	push	cs
	call	wait_drq
	jc	doc3
	mov	cx,4		;4 bytes of ecc
	mov	dx,hf_port
	cli
	repz	insb		;read in ecc
  	sti
doc2:
	push	cs
	call	check_status
	jnz	doc3		;operation failed
	dec	cmd_block[sec_cnt]
	jnz	doc1		;loop while more sectors to read
doc3:
	ret
docmd	endp


;***	get_vec - get pointer to hard disk parameters.
;
;	entry:	(dl) = low bit has hard disk number (0 or 1).
;
;	exit:	(es:bx) = address of disk parameters table.
;
;	uses:	ax for segment computation.
;
;	loads es:bx from interrupt table in low memory, vector 46h (disk 0)
;	or 70h (disk 1).
;	
;	warning: (ax) destroyed.
;		this does a direct call to the at rom.

get_vec	proc	near
	assume	ds:data,es:nothing

	push	offset romfret
	jmp	romget_vec
get_vec endp


;***	command - send contents of cmd_block to disk controller.
;
;	entry:	control_byte 
;		cmd_block - set up with values for hard disk controller.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr for no error.
;
;
;	warning: (ax), (cx), (dx) destroyed.
;		does a direct call to the at rom.
;
;	effects: programs disk controller.
;
command	proc	near
	assume	ds:data,es:nothing

	push	offset romfret
	jmp	romcommand
command endp


;***	waitt - wait for disk interrupt
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr if no error.
;
;
;	warning: (ax), (bl), (cx) destroyed.
;		does a direct call to the at rom.
;		
;	effects: calls int 15h, function 9000h.

waitt	proc	near
	assume	ds:data,es:nothing

	push   offset romfret
	jmp	romwait
waitt	endp


;***	wait_drq - wait for data request.
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		cy if error, nc if no error.
;
;	warning: (al), (cx), (dx) destroyed.
;		does a direct call to the at rom.

wait_drq proc	near
	assume	ds:data,es:nothing

	push	offset romfret
	jmp	romwait_drq
wait_drq endp


;***	check_status - check hard disk status.
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr if no error.
;
;
;	warning: (ax), (cx), (dx) destroyed.
;		does a direct call to the at rom.

check_status proc near
	assume	ds:data,es:nothing

	push	offset romfret
	jmp	romcheck_status
check_status endp


;***	check_dma - check for dma overrun 64k segment.
;
;	entry:	(es:bx) = addr. of memory buffer in seg:000x form.
;		cmd_block set up for operation.
;
;	exit:	disk_status1 - error code.
;		cy if error, nc if no error.
;
;	warning: does a direct call to the at rom.

check_dma proc near
	assume	ds:data,es:nothing

	push	offset romfret
	jmp	romcheck_dma
check_dma endp

; the following label defines the end of the at rom patch.  this is used at
; configuration time.
;
; warning!!! this code will be dynamically relocated by msinit.

	public	endatrom
endatrom label	byte

;	M015 -- begin changes
;
;	Certain old COMPAQ '286 machines have a bug in their ROM BIOS.
;	  When Int13 is done with AH > 15h and DL >= 80h, they trash
;	  the byte at DS:74h, assuming that DS points to ROM_DATA.
;	  If our init code detects this error, it will install this
;	  special Int13 hook through the same mechanism that was set
;	  up for the IBM patch above.  This code is also dynamically
;	  relocated by MSINIT.

	public	compaq_disk_io

compaq_disk_io	proc	far
	assume	cs:datagrp
	assume	ds:nothing,es:nothing

	cmp	ah,15h
	ja	mebbe_hookit	; only deal with functions > 15h
no_hookit:
	jmp	old13		; branch to ROM routine

mebbe_hookit:
	cmp	dl,80h
	jb	no_hookit	; bug is only on hardfile references

	push	ds
	push	ax
	mov	ax,40h
	mov	ds,ax
	pop	ax

	pushf			; simulate int13
	call	old13
	pop	ds
	retf	2

	public	end_compaq_i13hook
end_compaq_i13hook:

compaq_disk_io	endp


;	M015 -- end changes

Bios_Data_Init	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\mschar.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	mschar - character and clock devices
;
;----------------------------------------------------------------------------
;
; M013 : printer driver recognizes a special return value from MODE's
;	 INT 17 handler and does not do a retry operation. This is used
;	 to break out of tight loops in case mode was installed with the
;	 'R' option. This involves change in MODE also (Tag # M001)
;
; M026 : Putting back the buggy 4.01 code in auxin. (Time out bug)
;
; M044 : Isolating NOPRINTER bits from error before cmp it with NOPRINTER
;
; M059 : Bug #5002. Treat rollover byte as a count instead of a flag, if
;			t_switch is not set.
;
;----------------------------------------------------------------------------
;

	.xlist

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include msequ.inc
	include	devsym.inc
	include	bpb.inc
	include	ioctl.inc

break	macro
	endm

	include error.inc
	.list

	include msgroup.inc	; define Bios_Data segment


	extrn	ptrsav:dword

	extrn	fhavek09:byte
	extrn	altah:byte
	extrn	keyrd_func:byte
	extrn	keysts_func:byte

	extrn	auxnum:word
	extrn	auxbuf:byte

	extrn	wait_count:word
	extrn	printdev:byte


; daycnt is the number of days since 1-1-80.
; each time the clock is read it is necessary to check if another day has
; passed.  the rom only returns the day rollover once so if it is missed
; the time will be off by a day.

	extrn	daycnt:word
	extrn	t_switch:byte
	extrn	havecmosclock:byte
	extrn	base_century:byte
	extrn	base_year:byte
	extrn	month_tab:byte

	extrn	ttticks:dword
	extrn	bintobcd:dword		; far indirect calls to routines
	extrn	daycnttoday:dword	;  installed by msinit for cmos clock


; close Bios_Data and open Bios_Code segment

	tocode

	extrn	bc_cmderr:near
	extrn	bc_err_cnt:near

MODE_CTRLBRK	equ	0ffh		; M013

;************************************************************************
;*									*
;*	device driver dispatch tables					*
;*									*
;*	each table starts with a byte which lists the number of		*
;*	legal functions, followed by that number of words.  Each	*
;*	word represents an offset of a routine in Bios_Code which	*
;*	handles the function.  The functions are terminated with	*
;*	a near return.  If carry is reset, a 'done' code is returned	*
;*	to the caller.  If carry is set, the ah/al registers are	*
;*	returned as abnormal completion status.  Notice that ds		*
;*	is assumed to point to the Bios_Data segment throughout.	*
;*									*
;************************************************************************

	public	con_table
con_table:
	db	(((offset con_table_end) - (offset con_table) - 1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	con_read	; 04
	dw	con_rdnd	; 05
	dw	bc_exvec	; 06
	dw	con_flush	; 07
	dw	con_writ	; 08
	dw	con_writ	; 09
	dw	bc_exvec	; 0a
con_table_end:

	public	prn_table
prn_table	label	byte
	db	(((offset prn_table_end) - (offset prn_table) -1)/2)
	dw	bc_exvec	; 00 init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	prn_input	; 04 indicate zero chars read
	dw	z_bus_exit	; 05 read non-destructive
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	prn_writ	; 08
	dw	prn_writ	; 09
	dw	prn_stat	; 0a
	dw	bc_exvec	; 0b
	dw	bc_exvec	; 0c
	dw	bc_exvec	; 0d
	dw	bc_exvec	; 0e
	dw	bc_exvec	; 0f
	dw	prn_tilbusy	; 10
	dw	bc_exvec	; 11
	dw	bc_exvec	; 12
	dw	prn_genioctl	; 13
	dw	bc_exvec	; 14
	dw	bc_exvec	; 15
	dw	bc_exvec	; 16
	dw	bc_exvec	; 17
	dw	bc_exvec	; 18
	dw	prn_ioctl_query	; 19
prn_table_end:



	public	aux_table
aux_table	label	byte
	db	(((offset aux_table_end) - (offset aux_table) -1)/2)

	dw	bc_exvec	; 00 - init
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	aux_read	; 04 - read
	dw	aux_rdnd	; 05 - read non-destructive
	dw	bc_exvec	; 06
	dw	aux_flsh	; 07
	dw	aux_writ	; 08
	dw	aux_writ	; 09
	dw	aux_wrst	; 0a
aux_table_end:


	public	tim_table
tim_table	label	byte
	db	(((offset tim_table_end) - (offset tim_table) -1)/2)
	dw	bc_exvec	; 00
	dw	bc_exvec	; 01
	dw	bc_exvec	; 02
	dw	bc_cmderr	; 03
	dw	tim_read	; 04
	dw	z_bus_exit	; 05
	dw	bc_exvec	; 06
	dw	bc_exvec	; 07
	dw	tim_writ	; 08
	dw	tim_writ	; 09
tim_table_end:

;************************************************************************
;*									*
;*	con_read - read cx bytes from keyboard into buffer at es:di	*
;*									*
;************************************************************************

con_read proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	con_exit

con_loop:
	call	chrin		;get char in al
	stosb			;store char at es:di
	loop	con_loop

con_exit:
	clc
	ret
con_read endp

;************************************************************************
;*									*
;*	chrin - input single char from keyboard into al			*
;*									*
;*	  we are going to issue extended keyboard function, if		*
;*	  supported.  the returning value of the extended keystroke	*
;*	  of the extended keyboard function uses 0e0h in al		*
;*	  instead of 00 as in the conventional keyboard function.	*
;*	  this creates a conflict when the user entered real		*
;*	  greek alpha charater (= 0e0h) to  distinguish the extended	*
;*	  keystroke and the greek alpha.  this case will be handled	*
;*	  in the following manner:					*
;*									*
;*	      ah = 16h							*
;*	      int 16h							*
;*	      if al == 0, then extended code (in ah)			*
;*	      else if al == 0e0h, then					*
;*	      if ah <> 0, then extended code (in ah)			*
;*		else greek_alpha character.				*
;*									*
;*	also, for compatibility reason, if an extended code is		*
;*	  detected, then we are going to change the value in al		*
;*	  from 0e0h to 00h.						*
;*									*
;************************************************************************


chrin	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah,keyrd_func		; set by msinit. 0 or 10h
	xor	al,al
	xchg	al,altah		;get character & zero altah

	or	al,al
	jnz	keyret

	int	16h			; do rom bios keyrd function

alt10:
	or	ax,ax			;check for non-key after break
	jz	chrin

	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	alt_ext_chk

	mov	al,16
	jmp	short keyret

alt_ext_chk:

;**************************************************************
;  if operation was extended function (i.e. keyrd_func != 0) then
;    if character read was 0e0h then
;      if extended byte was zero (i.e. ah == 0) then
;	 goto keyret
;      else
;	 set al to zero
;	 goto alt_save
;      endif
;    endif
;  endif

	cmp	byte ptr keyrd_func,0
	jz	not_ext
	cmp	al,0e0h
	jnz	not_ext

	or	ah,ah
	jz	keyret
ifdef	DBCS
ifdef   KOREA                           ; Keyl  1990/11/5
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange1           ; do not modify any value.
        cmp     ah, 0f2h
        jbe     not_ext
EngCodeRange1:
endif	; KOREA
endif	; DBCS
	xor	al,al
	jmp	short alt_save

not_ext:

	or	al,al			;special case?
	jnz	keyret

alt_save:
	mov	altah,ah		;store special key
keyret:
	ret
chrin	endp

;************************************************************************
;*									*
;*	con_rdnd - keyboard non destructive read, no wait		*
;*									*
;*	pc-convertible-type machine: if bit 10 is set by the dos	*
;*	in the status word of the request packet, and there is no	*
;*	character in the input buffer, the driver issues a system	*
;*	wait request to the rom. on return from the rom, it returns	*
;*	a 'char-not-found' to the dos.					*
;*									*
;************************************************************************

con_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,[altah]
	or	al,al
	jnz	rdexit

	mov	ah,keysts_func		; keyboard i/o interrupt - get
	int	16h			;  keystroke status (keysts_func)
	jnz	gotchr

	cmp	fhavek09,0
	jz	z_bus_exit		; return with busy status if not k09

	les	bx,[ptrsav]
	assume	es:nothing
	test	es:[bx].status,0400h	; system wait enabled?
	jz	z_bus_exit		;  return with busy status if not

;	need to wait for ibm response to request for code
;	on how to use the system wait call.

	mov	ax,4100h		; wait on an external event
	xor	bl,bl			; M055; wait for any event
	int	15h			; call rom for system wait

z_bus_exit:
	stc
	mov	ah,3			; indicate busy status
	ret

gotchr:
	or	ax,ax
	jnz	notbrk			;check for null after break

	mov	ah,keyrd_func		; issue keyboard read function
	int	16h
	jmp	con_rdnd		;and get a real status

notbrk:
	cmp	ax,7200h		;check for ctrl-prtsc
	jnz	rd_ext_chk

	mov	al,'P' and 1fh		; return control p
	jmp	short rdexit

rd_ext_chk:
	cmp	keyrd_func,0		; extended keyboard function?
	jz	rdexit			; no. normal exit.

	cmp	al,0e0h 		; extended key value or greek alpha?
	jne	rdexit

ifdef	DBCS
ifdef   KOREA
        cmp     ah, 0f0h                ; If hangeul code range then
        jb      EngCodeRange            ; do not modify any value.
        cmp     ah, 0f2h
        jbe     rdexit                  ; Keyl 90/11/5
EngCodeRange:
endif	; KOREA
endif	; DBCS

	cmp	ah,0			; scan code exist?
	jz	rdexit			; yes. greek alpha char.
	mov	al,0			; no. extended key stroke.
					;  change it for compatibility

rdexit:
	les	bx,[ptrsav]
	assume	es:nothing
	mov	es:[bx].media,al	; *** return keyboard character here

bc_exvec:
	clc				; indicate normal termination
	ret

con_rdnd endp

;************************************************************************
;*									*
;*	con_write - console write routine				*
;*									*
;*	entry:	es:di -> buffer						*
;*		cx    =  count						*
;*									*
;************************************************************************

con_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	bc_exvec

con_lp:
	mov	al,es:[di]		;get char
	inc	di
	int	chrout			;output char
	loop	con_lp			;repeat until all through

cc_ret:
	clc
	ret
con_writ	endp

;************************************************************************
;*									*
;*	con_flush - flush out keyboard queue				*
;*									*
;************************************************************************

	public	con_flush	; called from msbio2.asm for floppy swapping
con_flush proc	near
	assume	ds:Bios_Data,es:nothing


	mov	[altah],0		;clear out holding buffer

;	while (charavail()) charread();

flloop:
	mov	ah,1			; command code for check status
	int	16h			; call rom-bios keyboard routine
	jz	cc_ret			; return carry clear if none

	xor	ah,ah			; if zf is nof set, get character
	int	16h			; call rom-bios to get character
	jmp	flloop

con_flush endp

;************************************************************************
;*									*
;*	some equates for rom bios printer i/o				*
;*									*
;************************************************************************

; ibm rom status bits (i don't trust them, neither should you)
; warning!!!  the ibm rom does not return just one bit.  it returns a
; whole slew of bits, only one of which is correct.


notbusystatus	=   10000000b		; not busy
nopaperstatus	=   00100000b		; no more paper
prnselected	=   00010000b		; printer selected
ioerrstatus	=   00001000b		; some kinda error
timeoutstatus	=   00000001b		; time out.

noprinter	=   00110000b		; no printer attached

;************************************************************************
;*									*
;*	prn_input - return with no error but zero chars read		*
;*									*
;*	enter with cx = number of characters requested			*
;*									*
;************************************************************************

prn_input proc	near
	assume	ds:Bios_Data,es:nothing

	call	bc_err_cnt	; reset count to zero (sub reqpkt.count,cx)
	clc			;  but return with carry reset for no error
	ret

prn_input endp

;************************************************************************
;*									*
;*	prn_writ - write cx bytes from es:di to printer device		*
;*									*
;*	auxnum has printer number					*
;*									*
;************************************************************************

prn_writ proc	near
	assume	ds:Bios_Data,es:nothing

	jcxz	prn_done		;no chars to output

prn_loop:
	mov	bx,2			;retry count

prn_out:
	call	prnstat 		; get status
	jnz	TestPrnError		; error

	mov	al,es:[di]		; get character to print
	xor	ah,ah
	call	prnop			; print to printer
	jz	prn_con			; no error - continue

	cmp	ah, MODE_CTRLBRK	; M013
	jne	@f			; M013
	mov	al, error_I24_gen_failure ; M013
	mov	altah, 0		; M013
	jmp	short pmessg		; M013
@@:
	test	ah,timeoutstatus
	jz	prn_con			; not time out - continue

TestPrnError:
	dec	bx			;retry until count is exhausted.
	jnz	prn_out

pmessg:
	jmp	bc_err_cnt		; return with error

; next character

prn_con:
	inc	di			;point to next char and continue
	loop	prn_loop

prn_done:
	clc
	ret
prn_writ	endp

;************************************************************************
;*									*
;*	prn_stat - device driver entry to return printer status		*
;*									*
;************************************************************************

prn_stat proc	near

	call	prnstat 		;device in dx
	jnz	pmessg			; other errors were found
	test	ah,notbusystatus
	jnz	prn_done		;no error. exit
	jmp	z_bus_exit		; return busy status
prn_stat endp

;************************************************************************
;*									*
;*	prnstat - utilty function to call ROM BIOS to check		*
;*		 printer status.  Return meaningful error code		*
;*									*
;************************************************************************

prnstat proc	near
	assume	ds:Bios_Data,es:nothing

	mov	ah, 2			; set command for get status
prnstat	endp				; fall into prnop

;************************************************************************
;*									*
;*	prnop - call ROM BIOS printer function in ah			*
;*		return zero true if no error				*
;*		return zero false if error, al = error code		*
;*									*
;************************************************************************

prnop	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dx,[auxnum]		; get printer number
	int	17h			; call rom-bios printer routine

		; This check was added to see if this is a case of no
		; printer being installed. This tests checks to be sure
		; the error is noprinter (30h)

	push	ax			; M044
	and	ah, noprinter		; M044
	cmp	AH,noprinter		; Chk for no printer
	pop	ax			; M044

	jne	NextTest 
	and	AH,NOT nopaperstatus
	or	AH,ioerrstatus

; examine the status bits to see if an error occurred.	unfortunately, several
; of the bits are set so we have to pick and choose.  we must be extremely
; careful about breaking basic.

NextTest:
	test	ah,(ioerrstatus+nopaperstatus) ; i/o error?
	jz	checknotready		; no, try not ready

; at this point, we know we have an error.  the converse is not true.

	mov	al,error_I24_out_of_paper
					; first, assume out of paper
	test	ah,nopaperstatus	; out of paper set?
	jnz	ret1			; yes, error is set
	inc	al			; return al=10 (i/o error)
ret1:
	ret				; return with error

checknotready:
	mov	al,2			; assume not-ready
	test	ah,timeoutstatus	; is time-out set?
	ret				; if nz then error, else ok
prnop endp

;************************************************************************
;*									*
;*	prn_tilbusy - output until busy.  Used by print spooler.	*
;*		     this entry point should never block waiting for	*
;*		     device to come ready.				*
;*									*
;*	inputs:	cx = count, es:di -> buffer				*
;*	outputs: set the number of bytes transferred in the		*
;*		 device driver request packet				*
;*									*
;************************************************************************

prn_tilbusy proc near

	mov	si,di			; everything is set for lodsb

prn_tilbloop:
	push	cx

	push	bx
	xor	bh,bh
	mov	bl,[printdev]
	shl	bx,1
	mov	cx,wait_count[bx]	; wait count times to come ready
	pop	bx

prn_getstat:
	call	prnstat 		; get status
	jnz	prn_bperr		; error
	test	ah,10000000b		; ready yet?
	loopz	prn_getstat		; no, go for more

	pop	cx			; get original count
	jz	prn_berr		; still not ready => done

	lods	es:byte ptr [si]
	xor	ah,ah
	call	prnop
	jnz	prn_berr		; error

	loop	prn_tilbloop		; go for more

	clc				; normal no-error return
	ret				;   from device driver

prn_bperr:
	pop	cx			; restore transfer count from stack

prn_berr:
	jmp	bc_err_cnt
prn_tilbusy endp

;************************************************************************
;*									*
;*	prn_genioctl - get/set printer retry count			*
;*									*
;************************************************************************

prn_genioctl proc near
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jz	prnfunc_ok

prnfuncerr:
	jmp	bc_cmderr

prnfunc_ok:
	mov	al,es:[di].minorfunction
	les	di,es:[di].genericioctl_packet
	xor	bh,bh
	mov	bl,[printdev]		; get index into retry counts
	shl	bx,1
	mov	cx,wait_count[bx]	; pull out retry count for device

	cmp	al,get_retry_count
	jz	prngetcount

	cmp	al,set_retry_count
	jnz	prnfuncerr

	mov	cx,es:[di].rc_count
prngetcount:
	mov	wait_count[bx],cx	; place "new" retry count
	mov	es:[di].rc_count,cx	; return current retry count
	clc
	ret
prn_genioctl endp

;************************************************************************
;*									*
;*  prn_ioctl_query							*
;*									*
;*  Added for 5.00							*
;************************************************************************

prn_ioctl_query PROC NEAR
	assume	ds:Bios_Data,es:nothing

	les	di,[ptrsav]
	cmp	es:[di].majorfunction,ioc_pc
	jne	prn_query_err

	mov	al,es:[di].minorfunction
	cmp	al,get_retry_count
	je	IOCtlSupported
	cmp	al,set_retry_count
	jne	prn_query_err

IOCtlSupported:
	clc
	ret

prn_query_err:
	stc
	jmp	BC_CmdErr

prn_ioctl_query ENDP

;************************************************************************
;*									*
;*	aux port driver code -- "aux" == "com1"				*
;*									*
;*	the device driver entry/dispatch code sets up auxnum to		*
;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
;*									*
;************************************************************************

;	values in ah, requesting function of int 14h in rom bios

auxfunc_send	 equ	1	;transmit
auxfunc_receive  equ	2	;read
auxfunc_status	 equ	3	;request status

;	error flags, reported by int 14h, reported in ah:

flag_data_ready  equ	01h	;data ready
flag_overrun	 equ	02h	;overrun error
flag_parity	 equ	04h	;parity error
flag_frame	 equ	08h	;framing error
flag_break	 equ	10h	;break detect
flag_tranhol_emp equ	20h	;transmit holding register empty
flag_timeout	 equ	80h	;timeout

;	these flags reported in al:

flag_cts	 equ	10h	;clear to send
flag_dsr	 equ	20h	;data set ready
flag_rec_sig	 equ	80h	;receive line signal detect

;************************************************************************
;*									*
;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
;*		   at es:di						*
;*									*
;************************************************************************

aux_read proc near
	assume	ds:Bios_Data,es:nothing

	jcxz	exvec2		; if no characters, get out

	call	getbx		; put address of auxbuf in bx
	xor	al,al		; clear al register
	xchg	al,[bx] 	; get character , if any, from
				;   buffer and clear buffer
	or	al,al		; if al is nonzero there was a
				;   character in the buffer
	jnz	aux2		; if so skip first auxin call

aux1:
	call	auxin		; get character from port
;		^^^^^ 		  won't return if error
aux2:
	stosb			; store character
	loop	aux1		; if more characters, go around again

exvec2:
	clc			; all done, successful exit
	ret

aux_read endp

;************************************************************************
;*									*
;*	auxin - call rom bios to read character from aux port		*
;*		if error occurs, map the error and return one		*
;*		level up to device driver exit code, setting		*
;*		the number of bytes transferred appropriately		*
;*									*
;************************************************************************

;
; M026 - BEGIN
;
auxin	proc	near
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable 
				; if timeout (bit 7) is set
	test	ah, flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp

IFDEF	COMMENTEDOUT
auxin	proc	near
	push	cx
	mov	cx, 20		; number of retries on time out errors
@@:
	mov	ah,auxfunc_receive
	call	auxop		;check for frame, parity, or overrun errors
	 			;warning: these error bits are unpredictable 
				; if timeout (bit 7) is set
	test	ah, flag_timeout
	jz	no_timeout
	loop	@b
no_timeout:
	pop	cx
	test	ah, flag_timeout or flag_frame or flag_parity or flag_overrun
	jnz	arbad		; skip if any error bits set
	ret			; normal completion, ah=stat, al=char

;	error getting character

arbad:
	pop	ax		; remove return address (near call)
	xor	al,al
	or	al,flag_rec_sig or flag_dsr or flag_cts
	jmp	bc_err_cnt

auxin	endp
ENDIF

;
; M026 - END
;
;************************************************************************
;*									*
;*	aux_rdnd - non-destructive aux port read			*
;*									*
;************************************************************************

aux_rdnd proc	near
	assume	ds:Bios_Data,es:nothing

	call	getbx		; have bx point to auxbuf
	mov	al,[bx] 	; copy contents of buffer to al
	or	al,al		; if al is non-zero (char in buffer)
	jnz	auxrdx		;   then return character

	call	auxstat 	;   if not, get status of aux device
	test	ah,flag_data_ready ; test data ready
	jz	auxbus		;   then device is busy (not ready)

	test	al,flag_dsr	;test data set ready
	jz	auxbus		;   then device is busy (not ready)

	call	auxin		;   else aux is ready, get character
	mov	[bx],al 	; save character in buffer

auxrdx:
	jmp	rdexit		; return al in [packet.media]

auxbus:
	jmp	z_bus_exit	; return busy status
aux_rdnd endp

;************************************************************************
;*									*
;*	aux_wrst - return aux port write status				*
;*									*
;************************************************************************

aux_wrst proc	near
	assume	ds:Bios_Data,es:nothing

	call	auxstat 	; get status of aux in ax
	test	al,flag_dsr	; test data set ready
	jz	auxbus		;   then device is busy (not ready)
	test	ah,flag_tranhol_emp ;test transmit hold reg empty
	jz	auxbus		;   then device is busy (not ready)
	clc
	ret
aux_wrst endp

;************************************************************************
;*									*
;*	auxstat - call rom bios to determine aux port status		*
;*									*
;*	exit:	ax = status						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxstat	proc near
	mov	ah,auxfunc_status
auxstat endp			; fall into auxop

;************************************************************************
;*									*
;*	auxop - perform rom-biox aux port interrupt			*
;*									*
;*	entry:	ah = int 14h function number				*
;*	exit:	ax = results						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxop	proc	near
				;ah=function code
				;0=init, 1=send, 2=receive, 3=status
	mov	dx,[auxnum]	; get port number
	int	14h		; call rom-bios for status
	ret
auxop	endp

;************************************************************************
;*									*
;*	aux_flsh - flush aux input buffer - set contents of		*
;*		   auxbuf [auxnum] to zero				*
;*									*
;*	cas - shouldn't this code call the rom bios input function	*
;*	      repeatedly until it isn't ready?  to flush out any	*
;*	      pending serial input queue if there's a tsr like MODE	*
;*	      which is providing interrupt-buffering of aux port?	*
;*									*
;************************************************************************

aux_flsh proc	near
	call	getbx		; get bx to point to auxbuf
	mov	byte ptr [bx],0 ; zero out buffer
	clc			; all done, successful return
	ret
aux_flsh endp

;************************************************************************
;*									*
;*	aux_writ - write to aux device					*
;*									*
;************************************************************************

aux_writ proc	near
	assume	ds:Bios_Data 	; set by aux device driver entry routine
	jcxz	exvec2		; if cx is zero, no characters
				;   to be written, jump to exit
aux_loop:
	mov	al,es:[di]	; get character to be written
	inc	di		; move di pointer to next character
	mov	ah,auxfunc_send ;value=1, indicates a write
	call	auxop		;send character over aux port

	test	ah,flag_timeout ;check for error
	jz	awok		;   then no error
	mov	al,10		;   else indicate write fault
	jmp	bc_err_cnt 	; call error routines

				; if cx is non-zero, still more
awok:
	loop	aux_loop	; more characrter to print
	clc			; all done, successful return
	ret
aux_writ endp

;************************************************************************
;*									*
;*	getbx - return bx -> single byte input buffer for		*
;*		selected aux port ([auxnum])				*
;*									*
;************************************************************************

getbx	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	bx,[auxnum]
	add	bx,offset auxbuf
	ret
getbx	endp


;----------------------------------------------------------------
;								:
;		    clock device driver 			:
;								:
;								:
;   this file contains the clock device driver. 		:
;								:
;   the routines in this files are:				:
;								:
;	routine 		function			:
;	------- 		--------			:
;	tim_writ		set the current time		:
;	tim_read		read the current time		:
;	time_to_ticks		convert time to corresponding	:
;				  number of clock ticks 	:
;								:
; the clock ticks at the rate of:				:
;								:
;	1193180/65536 ticks/second (about 18.2 ticks per second):
; see each routine for information on the use.			:
;								:
;----------------------------------------------------------------


; convert time to ticks
; input : time in cx and dx
; ticks returned in cx:dx

	public	time_to_ticks
time_to_ticks proc far

; first convert from hour,min,sec,hund. to
; total number of 100th of seconds

	mov	al,60
	mul	ch		;hours to minutes
	mov	ch,0
	add	ax,cx		;total minutes
	mov	cx,6000 	;60*100
	mov	bx,dx		;get out of the way of the multiply
	mul	cx		;convert to 1/100 sec
	mov	cx,ax
	mov	al,100
	mul	bh		;convert seconds to 1/100 sec
	add	cx,ax		;combine seconds with hours and min.
	adc	dx,0		;ripple carry
	mov	bh,0
	add	cx,bx		;combine 1/100 sec
	adc	dx,0

;	dx:cx is time in 1/100 sec

	xchg	ax,dx
	xchg	ax,cx		;now time is in cx:ax
	mov	bx,59659
	mul	bx		;multiply low half
	xchg	dx,cx
	xchg	ax,dx		;cx->ax, ax->dx, dx->cx
	mul	bx		;multiply high half
	add	ax,cx		;combine overlapping products
	adc	dx,0
	xchg	ax,dx		;ax:dx=time*59659
	mov	bx,5
	div	bl		;divide high half by 5
	mov	cl,al
	mov	ch,0
	mov	al,ah		;remainder of divide-by-5
	cbw
	xchg	ax,dx		;use it to extend low half
	div	bx		;divde low half by 5
	mov	dx,ax
				; cx:dx is now number of ticks in time
	ret
time_to_ticks endp

;--------------------------------------------------------------------
;
; tim_writ sets the current time
;
; on entry es:[di] has the current time:
;
;	number of days since 1-1-80	(word)
;	minutes (0-59)			(byte)
;	hours (0-23)			(byte)
;	hundredths of seconds (0-99)	(byte)
;	seconds (0-59)			(byte)
;
; each number has been checked for the correct range.
;

IFDEF	POWER		; Power management driver has it's own version of
			; this routine. ;M074

	extrn	tim_writ:near

ELSE

;	NOTE:  Any changes in this routine probably require corresponding
;	changes in the version that is built with the power manager driver.
;	See ptime.asm.

tim_writ proc	near
	assume	ds:Bios_Data
	mov	ax,word ptr es:[di]
	push	ax		;daycnt. we need to set this at the very
				;  end to avoid tick windows.
	cmp	havecmosclock, 0
	je	no_cmos_1
	mov	al,es:[di+3]		;get binary hours
	call	bintobcd		;convert to bcd
	mov	ch,al			;ch = bcd hours
	mov	al,es:[di+2]		;get binary minutes
	call	bintobcd		;convert to bcd
	mov	cl,al			;cl = bcd minutes
	mov	al,es:[di+5]		;get binary seconds
	call	bintobcd		;convert to bcd
	mov	dh,al			;dh = bcd seconds
	mov	dl,0			;dl = 0 (st) or 1 (dst)
	cli				;turn off timer
	mov	ah,03h			;set rtc time
	int	1ah			;call rom bios clock routine
	sti

no_cmos_1:
	mov	cx,word ptr es:[di+2]
	mov	dx,word ptr es:[di+4]
	call	ttticks		; convert time to ticks
				;cx:dx now has time in ticks
	cli			; turn off timer
	mov	ah, 1		; command is set time in clock
	int	1ah		; call rom-bios clock routines
	pop	[daycnt]
	sti

	cmp	havecmosclock, 0
	je	no_cmos_2

	call	daycnttoday	; convert to bcd format
	cli			; turn off timer
	mov	ah,05h		; set rtc date
	int	1ah		; call rom-bios clock routines
	sti

no_cmos_2:
	clc
	ret
tim_writ endp

ENDIF	; POWER

;
; gettime reads date and time
; and returns the following information:

;	es:[di]  =count of days since 1-1-80
;	es:[di+2]=hours
;	es:[di+3]=minutes
;	es:[di+4]=seconds
;	es:[di+5]=hundredths of seconds

IFDEF	POWER		; Power management driver has it's own version of
			; this routine. ;M074

	extrn	tim_read:near

ELSE

;	NOTE:  Any changes in this routine probably require corresponding
;	changes in the version that is built with the power manager driver.
;	See ptime.asm.

tim_read proc	near

	call	GetTickCnt	; M059 does INT 1A with ah=0 & updates daycnt
	mov	si,[daycnt]

; we now need to convert the time in tick to the time in 100th of
; seconds.  the relation between tick and seconds is:
;
;		 65536 seconds
;	       ----------------
;		1,193,180 tick
;
; to get to 100th of second we need to multiply by 100. the equation is:
;
;	ticks from clock  * 65536 * 100
;      ---------------------------------  = time in 100th of seconds
;		1,193,180
;
; fortunately this fromula simplifies to:
;
;	ticks from clock * 5 * 65,536
;      --------------------------------- = time in 100th of seconds
;		59,659
;
; the calculation is done by first multipling tick by 5. next we divide by
; 59,659.  in this division we multiply by 65,536 by shifting the dividend
; my 16 bits to the left.
;
; start with ticks in cx:dx
; multiply by 5

	mov	ax,cx
	mov	bx,dx
	shl	dx,1
	rcl	cx,1		;times 2
	shl	dx,1
	rcl	cx,1		;times 4
	add	dx,bx
	adc	ax,cx		;times 5
	xchg	ax,dx		
	

; now have ticks * 5 in dx:ax
; we now need to multiply by 65,536 and divide by 59659 d.

	mov	cx,59659	; get divisor
	div	cx
				; dx now has remainder
				; ax has high word of final quotient
	mov	bx,ax		; put high work if safe place
	xor	ax,ax		; this is the multiply by 65536
	div	cx		; bx:ax now has time in 100th of seconds


;rounding based on the remainder may be added here
;the result in bx:ax is time in 1/100 second.

	mov	dx,bx
	mov	cx,200		;extract 1/100's

;division by 200 is necessary to ensure no overflow--max result
;is number of seconds in a day/2 = 43200.

	div	cx
	cmp	dl,100		;remainder over 100?
	jb	noadj
	sub	dl,100		;keep 1/100's less than 100
noadj:
	cmc			;if we subtracted 100, carry is now set
	mov	bl,dl		;save 1/100's

;to compensate for dividing by 200 instead of 100, we now multiply
;by two, shifting a one in if the remainder had exceeded 100.

	rcl	ax,1
	mov	dl,0
	rcl	dx,1
	mov	cx,60		;divide out seconds
	div	cx
	mov	bh,dl		;save the seconds
	div	cl		;break into hours and minutes
	xchg	al,ah

;time is now in ax:bx (hours, minutes, seconds, 1/100 sec)

	push	ax
	mov	ax,si		; daycnt
	stosw
	pop	ax
	stosw
	mov	ax,bx
	stosw
	clc
	ret

tim_read endp

ENDIF	; POWER

; M059 - BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : GetTickCnt
;
;		Returns the tick count in CX:DX. Takes care of DayCnt in case
;		of rollover [except when power management driver is in use]. 
;		Uses the following logic for updating Daycnt
;
;		if ( rollover ) {
;			if ( t_switch )
;				daycnt++ ;
;			else
;				daycnt += rollover ;
;		}
;
; USES : AX
;
; RETURNS : CX:DX - tick count
; MODIFIES : daycnt
;
;----------------------------------------------------------------------------
;
	public	GetTickCnt

GetTickCnt	proc

	xor	ah, ah
	int	1ah

IFNDEF	POWER		; Power management driver keeps track of rollover.

	cmp	t_switch, 0		; use old method ?
	jne	inc_case		; yes

;
;------ new method assumes that INT 1a returns roll over count and not flag.
;
	xor	ah, ah			; new method
	add	daycnt, ax
	ret

inc_case:
;
;------ old method assumes that INT 1a returns rollover flag
;
	or	al, al
	jz	no_rollover
	inc	daycnt
no_rollover:

ENDIF	; POWER

	ret

GetTickCnt	endp

; M059 - END

Bios_Code	ends
	end



=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msdioctl.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,132

	TITLE	Disk Ioctl functions


	include version.inc	; set build flags
	include	biosseg.inc	; define bios segment structure

	INCLUDE devsym.inc
	INCLUDE bpb.inc
	INCLUDE ioctl.inc
	INCLUDE bootform.inc
	INCLUDE msdskpr.inc
	INCLUDE msequ.inc
	INCLUDE msbds.inc

	INCLUDE msgroup.inc		; Establish Bios_Data segment


DSK_TIMEOUT_ERR 	EQU	80h	; Time out error (no media present).
DSK_CHANGELINE_ERR	EQU	6h	; Change line error
DSK_ILLEGAL_COMBINATION EQU	0ch	; Return code of ah=18h function.
MULTI_TRK_ON		EQU	10000000b ; User spcified mutitrack=on,
					  ; or system turns
;
;----------------------------------------------------------------------------
;
; M00x : Setting 'lstdrv' properly at Setown ioctl call. Earlier it used
;		to set lstdrv to -1 on a setown call which got qbasic confused
;		Now the lstdrv update is done inside checksingle
;
; M060 : Bug # 5065. Added retries for INT 13 ah=18h call in case of errors
;
; M066 : B#5833. Modification M060 was required only for Toshiba machines
;		and the problem on Toshiba machines will be solved by the
;		'setmedia' driver. So the retry for ah=18 call is not
;		required. Also because of the retry & disk reset, format
;		becomes slow on IBM external floppy disk drives which does
;		not support the set_media_type call.
;
;----------------------------------------------------------------------------
;

; ==========================================================================
;	Most of the disk routines keep ES:[DI] set up pointing to the
;	  currently selected bds.  This is often assumed to be the standard
;	  operating environment and in some cases may not be mentioned in
;	  the subroutine headers where it will be assumed.
;
;	Most of the ioctl routines use DS:[BX] as a pointer to their
;	  request packet for at least part of their life.
; ==========================================================================


	EXTRN	ZeroSeg:WORD
	EXTRN	PtrSav:DWORD

	EXTRN	Xfer_Seg:WORD
	EXTRN	MultiTrk_Format_Flag:BYTE
	EXTRN	Multrk_Flag:WORD
	EXTRN	Start_Sec_H:WORD

	EXTRN	Dpt:DWORD
	EXTRN	fHave96:BYTE

	EXTRN	Formt_EOT:BYTE
	EXTRN	HdNum:BYTE
	EXTRN	TrkNum:WORD
	EXTRN	Gap_Patch:BYTE
	EXTRN	rFlag:BYTE
	EXTRN	CurTrk:WORD
	EXTRN	CurSec:BYTE
	EXTRN	CurHd:BYTE

	EXTRN	SpSav:WORD
	EXTRN	SecCnt:WORD
	EXTRN	Eot:BYTE
	EXTRN	Step_Drv:BYTE
	EXTRN	Start_Bds:DWORD
	EXTRN	fSetOwner:BYTE
	EXTRN	Tim_Drv:BYTE
	EXTRN	DiskSector:BYTE

		; These are some special variables defined for us

;**	EXTRN	Max_Sectors_Curr_Sup:abs
	EXTRN	SectorsPerTrack:WORD
	EXTRN	TrackTable:BYTE
	EXTRN	MediaType:BYTE
	EXTRN	Media_Set_For_Format:BYTE
	EXTRN	Had_Format_Error:BYTE
	EXTRN	TempDpt:DWORD

; ==========================================================================

; close data, open Bios_Code segment

	ToCode

	EXTRN	CheckSingle:NEAR
	EXTRN	GetBP:NEAR
	EXTRN	MapError:NEAR
	EXTRN	HasChange:NEAR
	EXTRN	DiskIO:NEAR
	EXTRN	Done:NEAR
	EXTRN	Mov_Media_Ids:NEAR
	EXTRN	Disk:NEAR
	EXTRN	IoSetup:NEAR
	EXTRN	Set_Changed_DL:NEAR
	EXTRN	SetDrive:NEAR
	EXTRN	BC_CmdErr:NEAR
	EXTRN	Bios_Data_WORD:WORD

; ==========================================================================
;
; NOTE: GetAccessFlag/SetAccessFlag is unpublished function.
;
;      This function is intended to give the user to control the
;      bds table flags of unformatted_media bit.
;      GetAccessFlag will show the status -
;	 a_DiskAccess_Control.dac_access_flag = 0 disk i/o not allowed
;						1 disk i/o allowed
;      SetAccessFlag will set/reset the unformatted_media bit in flags -
;	 a_DiskAccess_Control.dac_access_flag = 0 allow disk i/o
;						1 disallow disk i/o
; ==========================================================================

			; generic ioctl dispatch tables

IoReadJumpTable db	8			;maximum number (zero based)
		dw	GetDeviceParameters	;60h
		dw	ReadTrack		;61h
		dw	VerifyTrack		;62h
		dw	Cmd_Error_Proc		;overlapped with os2 subfunction
		dw	Cmd_Error_Proc
		dw	Cmd_Error_Proc
		dw	GetMediaId		;66h
		dw	GetAccessFlag		;67h unpublished function
		dw	SenseMediaType		;68

IoWriteJumpTable db	7
		dw	SetDeviceParameters	;40h
		dw	WriteTrack		;41h
		dw	FormatTrack		;42h
		dw	Cmd_Error_Proc
		dw	Cmd_Error_Proc
		dw	Cmd_Error_Proc
		dw	SetMediaId		;46h
		dw	SetAccessFlag		;47h unpublished function

; ==========================================================================
; IOC_DC_Table
;
; This table contains all of the valid generic IOCtl Minor codes for
; major function 08 to be used by the Ioctl_Support_Query function.
; Added for 5.00
; ==========================================================================

IOC_DC_Table  LABEL BYTE

	db	GET_DEVICE_PARAMETERS	; 60H
	db	SET_DEVICE_PARAMETERS	; 40H
	db	READ_TRACK		; 61H
	db	WRITE_TRACK		; 41H
	db	VERIFY_TRACK		; 62H
	db	FORMAT_TRACK		; 42H
	db	GET_MEDIA_ID		; 66h changed from 63h
	db	SET_MEDIA_ID		; 46h changed from 43h
	db	GET_ACCESS_FLAG 	; 67h Unpublished func changed frm 64h
	db	SET_ACCESS_FLAG 	; 47h Unpublished func changed frm 44h
	db	SENSE_MEDIA_TYPE	; 68 Added in 5.00

IOC_DC_TABLE_LEN EQU $ - OFFSET IOC_DC_Table


; ==========================================================================
; Do_Generic_IOCtl:	perform generic ioctl request
;
;    input:	AL contains logical drive
;
;	functions are dispatched through a call. On return, carry indicates
;	error code in al.  Note::bES:b& ds undefined on return from
;	subfunctions.
;
; ==========================================================================

	PUBLIC	Do_Generic_IOCtl
Do_Generic_IOCtl PROC	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	call	SetDrive		; ES:DI Points to bds for drive.

	push	ES
	les	BX,[PtrSav]		; ES:BX Points to request header.
	cmp	ES:[BX].MajorFunction,RAWIO
	mov	AL,ES:[BX].MinorFunction
	pop	ES
	jne	IoctlFuncErr

		; cas note:  Could do the above two blocks in reverse order.
		; Would have to preserve al for SetDrive

	mov	SI,OFFSET IoReadJumpTable
	test	AL,GEN_IOCTL_FN_TST		; test of req. function
	jnz	NotGenericWrite			; function is a read.

	mov	SI,OFFSET IoWriteJumpTable

NotGenericWrite:
	and	AL,NOT GEN_IOCTL_FN_TST		; get rid of read/write bit
	sub	AL,40h				; offset for base function
	cmp	AL,CS:[SI]
	ja	IoctlFuncErr

	cbw
	shl	AX,1
	inc	SI
	add	SI,AX
	call	CS:[SI]

	mov	DS,Bios_Data_Word	; Exit code now assumes this
	ASSUME	DS:Bios_Data

	mov	AH,81h			; Return this status in case of carry
	ret				; Pass carry flag through to exit code

		; Cmd_Error_Proc is called as a proceedure and also use
		; as a fall through from above

Cmd_Error_Proc:
	ASSUME	DS:Bios_Data
	pop	DX			; Clear up stack

IoctlFuncErr:
	ASSUME	DS:Bios_Data
	jmp	BC_CmdErr

Do_Generic_IOCtl ENDP

; ==========================================================================
;**	GetDeviceParameters:
;
;	GetDeviceParameters implements the generic ioctl function:
;	majorcode=RAWIO, minorcode=GetDeviceParameters (60h)
;
;	ENTRY	(ES:di) = BDS for drive
;		PtrSav = long pointer to request header
;	EXIT	??? BUGBUG
;	USES	??? BUGBUG
; ==========================================================================


GetDeviceParameters PROC NEAR
	ASSUME	DS:Bios_Data,ES:NOTHING

		; Copy info from bds to the device parameters packet

	lds	BX,[PtrSav]		; DS:BX points to request header.
	ASSUME	DS:NOTHING
	lds	BX,[BX].GenericIOCtl_Packet	; (DS:BX) = return buffer

	mov	AL,ES:[DI].BDS_FormFactor
	mov	[BX].DP_DeviceType,AL
	mov	AX,ES:[DI].BDS_Flags
	and	AX,fNon_Removable + fChangeLine ; Mask off other bits
	mov	[BX].DP_DeviceAttributes,AX
	mov	AX,ES:[DI].BDS_cCyln
	mov	[BX].DP_Cylinders,AX

	xor	AL,AL			; Set media type to default
	mov	[BX].DP_MediaType,AL

		; copy recommended bpb

	lea	SI,ES:[DI].BDS_RBPB
	test	[BX].dp_specialfunctions,build_device_bpb
	jz	UseBpbPresent

		; get the correct disk in the drive

	push	DS			; Save request packet segment
	mov	DS,Bios_Data_Word	; Point back to Bios_Data
	ASSUME	DS:Bios_Data

	call	CheckSingle
	call	GetBP			; Build the bpb from scratch

	pop	DS			; Restore request packet segment
	ASSUME	DS:NOTHING

	jc	GetParmRet

	lea	SI,ES:[DI].BDS_BPB	; Use this subfield of bds instead

UseBpbPresent:
	lea	DI,[BX].DP_BPB		; This is where the result goes
					; BUGBUG - why use "small" version? jgl
	mov	CX,SIZE A_BPB - 6	; For now use 'small' bpb

		; Shoot! Our segments are backwards for a copy!
		; Damn!	Reverse 'em!

	push	DS
	push	ES
	pop	DS
	pop	ES
	rep	movsb
	clc

GetParmRet:
	ret
GetDeviceParameters ENDP

; ==========================================================================
; SetDeviceParameters:
;
; input: ES:di points to bds for drive
; ==========================================================================

SetDeviceParameters PROC NEAR

	ASSUME	DS:Bios_Data
	lds	BX,[PtrSav]		; DS:BX points to request header.

	ASSUME	DS:NOTHING
	lds	BX,DS:[BX].GenericIOCtl_Packet

		; Make sure the fCHANGED_BY_FORMAT flag gets set to kick
		; Dos into looking at the BPB

	or	ES:[DI].BDS_Flags,fCHANGED_BY_FORMAT or fCHANGED
	test	[BX].dp_specialfunctions,only_set_tracklayout
	jnz	setTrackTable

		; Copy info from the device parameters packet to bds

	mov	AL,[BX].DP_DeviceType
	mov	ES:[DI].BDS_FormFactor,AL

	mov	AX,[BX].DP_Cylinders
	mov	ES:[DI].BDS_cCyln,AX

		; If change line is not loaded then ignore changeling flag

	mov	AX,[BX].DP_DeviceAttributes
	push	DS			; Save packet segment
	mov	DS,Bios_Data_Word
	ASSUME	DS:Bios_Data
	cmp	[fHave96],0		; Do we have changeline support?
	pop	DS
	ASSUME	DS:NOTHING
	jnz	HaveChange
	and	AX,NOT fChangeLine

		; Ignore all bits except non_removable and changeline
HaveChange:
	and	AX,fNon_Removable or fChangeLine
	mov	CX,ES:[DI].BDS_Flags
	and	CX,NOT(fNon_Removable OR fChangeLine OR Good_TrackLayOut OR UNFORMATTED_MEDIA)
	or	AX,CX
	mov	ES:[DI].BDS_Flags,AX

	mov	AL,[BX].DP_MediaType	; Set media type
	push	DS			; Save packet segment
	mov	DS,Bios_Data_Word
	ASSUME	DS:Bios_Data
	mov	MediaType,AL
	pop	DS			; Restore packet segment
	ASSUME	DS:NOTHING

		; The media changed (maybe) so we will have to do a set dasd
		; the next time we format a track

	or	ES:[DI].BDS_Flags,SET_DASD_TRUE

	push	DI			; Save bds pointer

		; Figure out what we are supposed to do with the bpb
		; were we asked to install a fake bpb?

	test	[BX].DP_SpecialFunctions,INSTALL_FAKE_BPB
	jnz	SHORT InstallFakeBpb

		; were we returning a fake bpb when asked to build a bpb?

	test	ES:[DI].BDS_Flags,RETURN_FAKE_BPB
	jz	SHORT InstallRecommendedBpb

		; we were returning a fake bpb but we can stop now

	and	ES:[DI].BDS_Flags,NOT RETURN_FAKE_BPB

InstallRecommendedBpb:
	mov	CX,SIZE A_BPB
	lea	DI,ES:[DI].BDS_RBPB
	jmp	SHORT CopyTheBpb

InstallFakeBpb:
	or	ES:[DI].BDS_Flags,RETURN_FAKE_BPB ; problem reported by whs.
					; BUGBUG - why use "small" version? jgl
	mov	CX,SIZE A_BPB - 6	; move 'smaller' bpb
	lea	DI,ES:[DI].BDS_BPB

CopyTheBpb:
	lea	SI,[BX].DP_BPB
	rep	movsb

Donewithbpbstuff:
	push	DS			; Save packet segment
	mov	DS,Bios_Data_Word	; Setup for ds -> Bios_Data

	ASSUME	DS:Bios_Data
	call	RestoreOldDpt		; Restore the old Dpt from TempDpt
	pop	DS			; Restore packet segment
	pop	DI			; Restore bds pointer

setTrackTable:				; Set up track table (if neccessary)
	mov	CX,[BX].DP_TrackTableEntries
	push	DS			; Save packet segment
	mov	DS,Bios_Data_Word

	ASSUME	DS:Bios_Data
	mov	SectorsPerTrack,CX
	pop	DS			; Restore packet segment

	ASSUME	DS:NOTHING
	and	ES:[DI].BDS_Flags,NOT Good_TrackLayOut
	test	[BX].DP_SpecialFunctions,TrackLayOut_Is_Good
	jz	UglyTrackLayOut

	or	ES:[DI].BDS_Flags,Good_TrackLayOut

UglyTrackLayOut:
	cmp	CX,MAX_SECTORS_IN_TRACK
	ja	TooManyPerTrack
	jcxz	SectorInfoSaved

	mov	DI,OFFSET TrackTable
	lea	SI,[BX].DP_SectorTable
	mov	ES,Bios_Data_Word	; Trash our bds pointer

StoreSectorInfo:
	inc	DI			; Skip over cylinder
	inc	DI			; Skip over head
	lodsw				; Get sector id
	stosb				; Copy it
	lodsw				; Get sector size
	call	SectSizeToSectIndex
	stosb				; Store sector SIZE index
	loop	StoreSectorInfo

SectorInfoSaved:
	clc
	ret

TooManyPerTrack:
	mov	AL,0ch
	stc
	ret

SetDeviceParameters ENDP


; ==========================================================================
; FormatTrack:
; if specialfunction byte is 1,then this is a status call to see if there is
; rom support for the combination of sec/trk and # of cyln,and if the
; combination is legal. if specialfunction byte is 0,then format the track.
;
; input: ES:di points to bds for drive
;
; output:
;	for status call:
;	specialfunction byte set to:
;		0 - rom support + legal combination
;		1 - no rom support
;		2 - illegal combination
;		3 - no media present
;	carry cleared.
;
;	for format track:
;		carry set if error
;
; ==========================================================================

FormatTrack PROC NEAR

	ASSUME	DS:Bios_Data
	lds	BX,[PtrSav]		; ES:BX points to request header.

	ASSUME	DS:NOTHING
	lds	BX,DS:[BX].GenericIOCtl_Packet
	test	[BX].DP_SpecialFunctions,STATUS_FOR_FORMAT
	jz	DoFormatTrack

	push	DS			; Save packet
	mov	DS,Bios_Data_Word	; Point to Bios_Data

	ASSUME	DS:Bios_Data
	call	SetMediaForFormat	; Also moves current Dpt to TempDpt
	pop	DS			; Restore packet

	ASSUME	DS:NOTHING
	mov	[BX].DP_SpecialFunctions,AL
	clc
	ret

DoFormatTrack:
	cmp	ES:[DI].BDS_FormFactor,DEV_HARDDISK
	jne	DoFormatDiskette

	mov	DS,Bios_Data_Word	; Setup ds-> Bios_Data for verify
	jmp	VerifyTrack

DoFormatDiskette:
	mov	CX,[BX].FP_Head
	mov	DX,[BX].FP_Cylinder	; Load cylinder & head from pkt
	test	[BX].FP_SpecialFunctions, DO_FAST_FORMAT ; Fast format request?
	mov	DS,Bios_Data_Word	; Done with pkt seg, get to Bios_Data

	ASSUME	DS:Bios_Data
	jz	DoFormatDiskette_1	; Go ahead if not multi-trk

	jmp	VerifyTrack_Err 	; Error, same as VerifyTrack_Err

DoFormatDiskette_1:
	call	SetMediaForFormat	; Also moves current Dpt to TempDpt
	cmp	AL,1		;	; ROM support for sec/trk,# trks comb?
	jz	NeedToSetDasd		; Old rom.

	cmp	AL,3			; Time out error?
	jnz	NoSetDasd		; No,fine.(at this point,don't care
					; about the illegal combination.)
	jmp	SHORT FormatFailed

NeedToSetDasd:
	push	DX
	call	SetDasd 		; AH=17h,int 13h
	pop	DX

NoSetDasd:
	call	CheckSingle		; Do any needed diskette swapping
	mov	AX,DX			; Get track from packet
	mov	[TrkNum],AX
	mov	BYTE PTR [HdNum],CL	; Store head from packet
	mov	AH,CL
	mov	BX,OFFSET TrackTable

	mov	CX,SectorsPerTrack

StoreCylinderHead:
	mov	[BX],AX 		; Store into TrackTable
	add	BX,4			; Skip to next sector field
	loop	StoreCylinderHead
	mov	CX,MaxErr		; Set up retry count

FormatRetry:
	push	CX
	mov	BX,OFFSET TrackTable
	mov	AL,BYTE PTR SectorsPerTrack
	mov	AH,RomFormat
	mov	Xfer_Seg,DS
	call	ToRom
	pop	CX
	jc	FormatError

		; Now verify the sectors just formatted.
		; NOTE: because of bug in some BIOSes we have to
		; set ES:BX to 00:00

	push	CX
	push	bx

	xor	bx,bx
	mov	Xfer_seg,bx
	mov	AL,BYTE PTR SectorsPerTrack
	mov	AH,RomVerify
	mov	CL,1
	call	ToRom

	pop	bx
	pop	CX
	jnc	FormatOk

FormatError:
	call	ResetDisk
	mov	[Had_Format_Error],1

	push	AX
	push	CX
	push	DX

	call	SetMediaForFormat
	cmp	AL,1
	jnz	WhileErr

	call	SetDasd

WhileErr:
	pop	DX
	pop	CX
	pop	AX
	loop	FormatRetry

FormatFailed:
	mov	[Had_Format_Error],1	; Set the format error flag.
	cmp	AH,DSK_CHANGELINE_ERR	; =06h. convert change line
	jne	DoMapIt 		; Error to time out error.

	mov	AH,DSK_TIMEOUT_ERR	; =80h

DoMapIt:
	jmp	MapError

FormatOk:
	mov	[Had_Format_Error],0	;reset the format error flag.
	ret

FormatTrack ENDP			; fall into VerifyTrack

; ==========================================================================
;
; VerifyTrack:
;
; input: ES:di points to bds for drive
; ==========================================================================

VerifyTrack PROC NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	push	DS			; Save Bios_Data
	lds	BX,[PtrSav]		; DS:BX points to request header.

	ASSUME	DS:NOTHING
	lds	BX,[BX].GenericIOCtl_Packet

		; Come here with DS:[BX] -> packet, ES:[DI] -> bds

	mov	CX,[BX].VP_Cylinder	; get some stuff cuz ds will be moved
	mov	AX,[BX].VP_Head
	mov	DX,[BX].FP_TrackCount	; & number of tracks to verify
	mov	BL,[BX].FP_SpecialFunctions ; Get option flag word

	pop	DS			; Restore DS -> Bios_Data
	ASSUME	DS:Bios_Data

	mov	rFlag,romverify
	mov	[CurTrk],CX
	mov	[CurHd],AL		; **** ASSUME heads < 256
	mov	CX,[SectorsPerTrack]	;cl = sectors/track

		; Check specialfunctions to see if DO_FAST_FORMAT has been
		; specified if not we should go to the normal track verification
		; routine. If fast format has been specified we should get the
		; number of tracks to be verified and check it to see if it is
		; > 255. If it is then it is an error and we should go to
		; VerifyTrack_Err. If not multiply the number of tracks by the
		; sectors per track to get the total number of sectors to be
		; verified. This should also be lESs than equal to 255
		; otherwise we go to same error exit. If everything is okay
		; we initalise cx to the total sectors. use ax as a temporary
		; register.

	test	BL,DO_FAST_FORMAT	; Special function requESted?
	jz	NormVerifyTrack

	mov	AX,DX			; Get ax = number of trks to verify
	or	AH,AH
	jnz	VerifyTrack_Err 	; #tracks > 255
	mul	CL
	or	AH,AH			; #sectors > 255
	jnz	VerifyTrack_Err
	mov	CX,AX			; #sectors to verify
					; set the multi track request flag
	test	ES:[DI].BDS_Flags,fNon_Removable ; Hard disk?
	jz	NormVerifyTrack

	test	Multrk_Flag,MULTI_TRK_ON ; Multitrack operation = on?
	jz	NormVerifyTrack

	mov	MultiTrk_Format_Flag,1	; Then set the flag

NormVerifyTrack:
	xor	AX,AX			; 1st sector
				; Use 0:0 as the transfer address for verify
	xor	BX,BX
	mov	Xfer_Seg,BX		; Set transfer segment to zero, too
	call	TrackIo
	mov	MultiTrk_Format_Flag,0	; Reset the flag.
	ret

VerifyTrack_Err:
	mov	AH,1
	jmp	MapError

VerifyTrack ENDP

; ==========================================================================
;
; ReadTrack:
;
; input: ES:di points to bds for drive
;
; ==========================================================================

ReadTrack	proc	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	mov	rFlag,ROMREAD
	jmp	SHORT readWriteTrack

ReadTrack	ENDP


; ==========================================================================
;
; WriteTrack:
;
; input: ES:di points to bds for drive
;
; ==========================================================================

WriteTrack	proc	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	mov	rFlag,ROMWRITE

WriteTrack	ENDP			; Fall into readWriteTrack

; ==========================================================================
;
; readWriteTrack:
;
; input:
;    ES:di points to bds for drive
;    rFlag - 2 for read,3 for write
;
; ==========================================================================

ReadWriteTrack PROC NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

		; save bds pointer segment so we can use it to access
		; our packet. Notice that this is not the standard register
		; assignment for accessing packets

	push	ES
	les	BX,[PtrSav]			; ES:BX -> to request header.
	les	BX,ES:[BX].GenericIOCtl_Packet
	mov	AX,ES:[BX].TrWp_Cylinder
	mov	[CurTrk],AX
	mov	AX,ES:[BX].TrWp_Head
	mov	[CurHd],AL			; Assume heads < 256!!!
	mov	AX,ES:[BX].TrWp_FirstSector
	mov	CX,ES:[BX].TrWp_SectorsToReadWrite
	les	BX,ES:[BX].TrWp_TransferAddress ; Get transfer address

		; we just trashed our packet address, but we no longer care

	mov	Xfer_Seg,es			; Pass transfer segment
	pop	ES				; Restore bds segment
ReadWriteTrack ENDP				; Fall into TrackIo


; ==========================================================================
;
; TrackIo:
;    performs track read/write/verify
;
;   input:
;      rFlag	- 2 = read
;		  3 = write
;		  4 = verify
;      AX	- Index into track table of first sector to io
;      CX	- Number of sectors to io
;      Xfer_Seg:BX - Transfer address
;      ES:DI	- Pointer to bds
;      CurTrk	- Current cylinder
;      CurHd	- Current head
;
; ==========================================================================

TrackIo PROC NEAR
					; Procedure `disk' will pop stack to
	mov	SpSav,sp		; SpSav and return if error
	call	CheckSingle		; Ensure correct disk is in drv
	cmp	[Media_Set_For_Format],1 ; See if we have already set disk
	jz	Dptalreadyset		; base table

	push	AX			; set up tables and variables for i/o
	push	CX
	call	IoSetup
	pop	CX
	pop	AX

Dptalreadyset:				; Point si at the table entry of the
	mov	SI,OFFSET TrackTable	; first sector to be io'd
	shl	AX,1
	shl	AX,1
	add	SI,AX

		; WE WANT:
		; CX to be the number of times we have to loop
		; DX to be the number of sectors we read on each iteration

	mov	DX,1
	test	ES:[DI].BDS_Flags,Good_TrackLayOut
	jz	ionextsector

	xchg	DX,CX			; HEY! We can read all secs in one blow

IoNextSector:
	push	CX
	push	DX

	inc	SI			; Skip over the cylinder and head in
	inc	SI			; the track table

	lodsb				; Get sector ID from track table
	mov	[CurSec],AL

		;assumptions for a fixed disk multi-track disk i/o
		; 1). In the input CX (# of sectors to go) to TrackIo,only CL
		;     is valid.
		; 2). Sector size should be set to 512 bytes.
		; 3). Good track layout.

	test	ES:[DI].BDS_Flags,fNon_Removable ; Fixed disk?
	jz	IoRemovable			; No
	test	Multrk_Flag,MULTI_TRK_ON	; Allow multi-track operation?
	jz	IoRemovable			; No,don't do that.

	mov	[SecCnt],DX			; # of sectors to i/o
	mov	AX,DX
	call	Disk

	pop	DX
	pop	CX
	clc
	ret

IoRemovable:
	lodsb				; Get sector size index from track
	push	AX			; table and save it

					; Patch sector size in Dpt
	push	SI
	push	DS			; Save Bios_Data

	push	AX			; Preserve whatever might be in ah
	mov	AH,[Eot]		; Fetch Eot while ds-> Bios_Data
	lds	SI,Dpt
	ASSUME	DS:NOTHING
	mov	BYTE PTR [SI].disk_sector_siz,AL
	mov	[SI].disk_Eot,AH	; Set up the max number of sec/track
	pop	AX			; Restore whatever was in ah
	pop	DS			; Restore Bios_Data
	ASSUME	DS:Bios_Data
	mov	AL,DL
	mov	[SecCnt],AX		; Set up the count of sectors to i/o
	call	Disk

	pop	si			; Advance buffer pointer by adding
	pop	ax			; sector size
	call	SectorSizeIndexToSectorSize
	add	BX,AX
	pop	DX
	pop	CX
	loop	IoNextSector

	cmp	[Media_Set_For_Format],1
	je	NoNeedDone

	call	Done			; set time of last access,and reset

NoNeedDone:
	clc				; entries in Dpt.
	ret

TrackIo ENDP

; ==========================================================================
;
; The sector size in bytes needs to be converted to an index value for the ibm
; rom. (0=>128,1=>256,2=>512,3=>1024). It is assumed that only these values
; are permissible.
;
; On Input   AX contains sector size in bytes
; On Output  AL Contains index
; All other registers preserved
;
; ==========================================================================

SectSizeToSectIndex PROC NEAR

	ASSUME	DS:NOTHING,ES:NOTHING

	cmp	AH,2			; examine upper byte only
	ja	OneK
	mov	AL,AH			; value in AH is the index!
	ret
OneK:
	mov	AL,3
	ret

SectSizeToSectIndex ENDP

; ==========================================================================
;
; ==========================================================================

SectorSizeIndexToSectorSize PROC NEAR
	mov	CL,AL
	mov	AX,128
	shl	AX,CL
	ret
SectorSizeIndexToSectorSize ENDP


; ==========================================================================
;
; SetDASD
;
; Set up the rom for formatting.
; we have to tell the rom bios what type of disk is in the drive.
;
; On Input   - ES:di - Points to bds
;
; ==========================================================================

SetDasd	proc	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	cmp	[Had_Format_Error],1	; See if we've previously set dasd type
	je	DoSetDasd

	test	ES:[DI].BDS_Flags,SET_DASD_TRUE
	jz	DasdHasBeenSet

	and	ES:[DI].BDS_Flags,NOT SET_DASD_TRUE

DoSetDasd:
	mov	[Had_Format_Error],0	; Reset it
	mov	[Gap_Patch],50h 	; Format gap for 48tpi disks
	mov	AL,4
	cmp	ES:[DI].BDS_FormFactor,DEV_3INCH720KB
	jz	DoSet

	cmp	ES:[DI].BDS_FormFactor,DEV_5INCH96TPI
	jz	GotBig

	mov	AL,1			; 160/320k in a 160/320k drive
	jmp	SHORT DoSet

GotBig:
	mov	AL,2			; 160/320k in a 1.2 meg drive
	cmp	[MediaType],0
	jne	DoSet

	mov	AL,3			; 1.2meg in a 1.2meg drive
	mov	[Gap_Patch],54h

DoSet:
	push	DS			; Preserve caller's DS, si
	push	SI

		; Get the disk parameter table address (DWORD address) from the
		; location 0:[dskadr] and fix the head settle time in this to
		; be 0fh.

	mov	DS,ZeroSeg		; Point to interrupt vectors
	ASSUME	DS:NOTHING

	lds	SI,DWORD PTR DS:[DskAdr]
	mov	DS:[SI].Disk_Head_Sttl,0fh
	pop	SI
	pop	DS			; Restore caller's DS, si

	ASSUME	DS:Bios_Data
	mov	AH,17h			; Set command to set dasd type
	mov	DL,ES:[DI].BDS_DriveNum ; Set drive number
	int	13h			; Call rom-bios

DasdHasBeenSet:
	mov	AH,BYTE PTR ES:[DI].BDS_BPB.BPB_SECTORSPERTRACK
	mov	[Formt_EOT],AH
	ret

SetDasd	ENDP

; ==========================================================================
;
; Set Media Type for Format
; Performs the int 13 with ah = 18h to see if the medium described in the
; BPB area in the BDS can be handled by the rom.
; On Input, ES:DI -> current BDS.
; The status of the operation is returned in AL
;
;	- 0 - if the support is available,and the combination is valid.
;	- 1 - no rom support
;	- 2 - illegal combination
;	- 3 - no media present (rom support exists but cannot determine now)
;
; Flags also may be altered. All other registers preserved.
; If the call to rom returns no error,then the current Dpt is "replaced" by
; the one returned by the rom. This is Done by changing the pointer in [Dpt]
; to the one returned. the original pointer to the disk base table is stored
; in TempDpt, until it is restored.
;
; ==========================================================================

SetMediaForFormat PROC NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	push	CX
	push	DX

		; If we have a format error, then do not change Dpt, TempDpt.
		; but we need to call int 13h, ah=18h again.

	cmp	[Had_Format_Error],1
	je	SkipSaveDskAdr

	xor	AL,AL			; If already done return 0
	cmp	[Media_Set_For_Format],1
	jnz	DoSetMediaForFormat

	jmp	SetMediaRet		; Media already set

DoSetMediaForFormat:
	push	ES			; Preserve caller's ES, si
	push	SI
	mov	ES,ZeroSeg		; Point to interrupt vectors
	les	SI,DWORD PTR ES:[DskAdr] ; Get pointer to disk base table
	mov	WORD PTR [Dpt],SI
	mov	WORD PTR [Dpt+2],es	; Save pointer to table

		; Initialize the head settle time to 0fh. See the offsets
		; given in dskprm.inc.

	mov	ES:[SI].Disk_Head_Sttl,0fh
	pop	SI			; Restore caller's ES, si
	pop	ES

SkipSaveDskAdr:
	mov	CX,ES:[DI].BDS_cCyln	; Get number of cylinders
	dec	CX			; Cylinder must be zero based
	and	CH,03h			; Blank out unnecessary bits
	ror	CH,1			; Put in int form
	ror	CH,1
	xchg	CH,CL
	or	CL,BYTE PTR ES:[DI].BDS_BPB.BPB_SECTORSPERTRACK ;get number of sectors
	mov	DL,ES:[DI].BDS_DriveNum ; Get drive number

	push	ES			; CAS - really need to save 'em all?
	push	DS
	push	SI
	push	DI

	mov	AH,18h			; Set media for format	M066
	int	13h			; Call rom bios		M066
	jc	FormaStatErr		;			M066

COMMENT ^
	mov	si, MaxErr		; retry count		M060
next_18:				;			M060
	mov	AH,18h			; Set media for format	M060
	int	13h			; Call rom bios		M060
	jnc	@f			;			M060
	dec	si			;			M060
	jz	FormaStatErr		;			M060
	xor	ah, ah			;			M060
	int	13h			;			M060
	jmp	next_18			;			M060

		; ES:DI points to a disk base table for this combination
		; for this drive.
@@:					;			M060
ENDCOMMENT ^

	cmp	[Had_Format_Error],1	; Did we have a format error?
	je	skip_disk_base_setting

	push	ES			; Save segment returned by the rom

	mov	ES,ZeroSeg		; Point to interrupt vector segment
	les	SI,DWORD PTR ES:[DskAdr] ; Get current disk base table

	mov	WORD PTR [TempDpt],SI
	mov	WORD PTR [TempDpt+2],es ; Save it

		; CAS -- didn't used to reload ES -> ZeroSeg here.
		; Seemed like a bug

	mov	ES,ZeroSeg
	mov	WORD PTR ES:[DskAdr],DI
	pop	WORD PTR ES:[DskAdr+2]	; replace with one returned by rom
	mov	[Media_Set_For_Format],1

skip_disk_base_setting:
	xor	AL,AL			; Legal combination + rom support code
	mov	[Had_Format_Error],AL	; Reset the flag
	jmp	SHORT PopStatRet

FormaStatErr:
	cmp	AH,DSK_ILLEGAL_COMBINATION ; Illegal combination = 0ch
	je	FormatStatIllegalComb
	cmp	AH,DSK_TIMEOUT_ERR	; 80h
	je	FormatStatTimeOut

	mov	AL,1			; Function not supported.
	jmp	SHORT PopStatRet

FormatStatIllegalComb:			; Function supported,but
	mov	AL,2			; Illegal sect/trk,trk combination.
	jmp	SHORT PopStatRet

FormatStatTimeOut:			; Function supported,but
	mov	AL,3			; Media not present.

PopStatRet:
	pop	DI			; Restore caller's DS ES DI SI
	pop	SI
	pop	DS
	pop	ES

SetMediaRet:
	pop	DX
	pop	CX
	ret

SetMediaForFormat ENDP

	ASSUME	DS:NOTHING,ES:NOTHING

; ==========================================================================
;
; RESET THE DRIVE
;
; we also set [Step_Drv] to -1 to force the main disk routine to use the
; slow head settle time for the next operation. this is because the reset
; operation moves the head to cylinder 0,so we need to do a seek the next
; time around - there is a problem with 3.5" drives in that the head does
; not settle down in time,even for read operations!!
;
; ==========================================================================

	PUBLIC ResetDisk
ResetDisk proc	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	push	AX
	cmp	[Media_Set_For_Format],1; Reset while formatting?
	jne	ResetDisk_cont		; Then verify operation in "fmt & vrfy"
	mov	[Had_Format_Error],1	; Might have failed.

ResetDisk_cont: 			; So signals that we had a format error

	xor	AH,AH			; Set command to reset disk
	int	13h			; Call the rom-bios
	mov	[Step_Drv],-1		; Zap up the speed
	pop	AX
	ret

ResetDisk ENDP

; ==========================================================================
;
; This routine sets up the drive parameter table with the values needed for
; format,does an int 13. values in Dpt are restored after a verify is done.
;
; on entry  -	ES:DI - points to bds for the drive
;		Xfer_Seg:BX - points to trkbuf
;		AL    - number of sectors
;		AH    - int 13 function code
;		CL    - sector number for verify
;		DS    - Bios_Data
;
; ON EXIT   -	DS,DI,ES,BX remain unchanged.
;		AX and flags are the results of the int 13
;
; ==========================================================================

ToRom	proc	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING
	push	BX
	push	SI

		; Compaq bug fix - check whether we are using new ROM
		; functionality to set up format, not merely if it exists.
		; This was formerly a check against [new_rom]

	test	[Media_Set_For_Format],1
	jnz	GotValidDpt

	push	AX
	push	ES			; Save bds segment

	cmp	ES:[DI].BDS_FormFactor,ffsmall	; is it a 3.5" drive?
	pushf				; Save the result for when ES: is busy
	mov	ES,ZeroSeg
	les	SI,DWORD PTR ES:[DskAdr] ; Get pointer to disk base table
	mov	WORD PTR [Dpt],SI
	mov	WORD PTR [Dpt+2],es	; Save pointer to table
	mov	AL,[Formt_EOT]
	mov	ES:[SI].disk_eot,AL
	mov	AL,[Gap_Patch]
	mov	ES:[SI].Disk_Formt_Gap,AL ; Important for format
	mov	ES:[SI].Disk_Head_Sttl,15 ; Assume we are doing a seek operation

				; Set up motor start correctly for 3.5" drives
	popf			; Get result of earlier cmp
	jnz	MotorStrtOK

	mov	ES:[SI].Disk_Motor_Strt,4

MotorStrtOK:
	pop	ES			; Restore bds segment
	pop	AX

GotValidDpt:
	mov	DX,[TrkNum]		; Set track number
	mov	CH,DL			; Set low 8 bits in ch
	mov	DL,ES:[DI].BDS_DriveNum ; Set drive number
	mov	DH,[HdNum]		; Set head number
	push	ES			; Save bds segment
	mov	ES,Xfer_Seg
	int	13h			; Call the rom-bios  routines
	pop	ES			; Restore bds segment

	pop	SI
	pop	BX
	ret
ToRom	ENDP

; ==========================================================================
;
; get the owner of the physical drive represented by the logical drive in al.
; the assumption is that we **always** keep track of the owner of a drive!!
; if this is not the case, the system may hang, just following the linked list.
;
; ==========================================================================

	PUBLIC	IOCtl_GetOwn
IOCtl_GetOwn proc	NEAR

	ASSUME	DS:Bios_Data

	call	SetDrive
	mov	AL,ES:[DI].BDS_DriveNum 	; Get physical drive number
	les	DI,[Start_Bds]			; Get start of bds chain

OwnLoop:
	cmp	ES:[DI].BDS_DriveNum,AL
	jne	GetNextBDS

	test	ES:[DI].BDS_Flags,FI_Own_Physical
	jnz	ExitOwn

GetNextBDS:
	les	DI,ES:[DI].BDS_Link
	jmp	OwnLoop

IOCtl_GetOwn ENDP

; ==========================================================================
;
; set the ownership of the physical drive represented by the logical drive in
; al to al.
;
; ==========================================================================

	PUBLIC IOCtl_SetOwn
IOCtl_SetOwn PROC	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	call	SetDrive
	mov	BYTE PTR [fSetOwner],1		; set flag for CheckSingle to
						; look at.
	call	CheckSingle			; set ownership of drive
	mov	BYTE PTR [fSetOwner],0		; reset flag

; M00x - BEGIN
;	push	ES
;	mov	ES,ZeroSeg
;	mov	BYTE PTR ES:[lstdrv],-1 	; set up sdsb as well
;	pop	ES				; restore bds pointer
; M00x - END

IOCtl_SetOwn ENDP				; fall into ExitOwn

; ==========================================================================
;
; if there is only one logical drive assigned to this physical drive, return
; 0 to user to indicate this.  Enter with ES:di -> the owner's bds.
;
; ==========================================================================

ExitOwn PROC	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	xor	CL,CL
	test	ES:[DI].BDS_Flags,FI_Am_Mult
	jz	ExitNoMult

	mov	CL,ES:[DI].BDS_DriveLet ; Get logical drive number
	inc	cl			; Get it 1-based

ExitNoMult:
	lds	BX,[PtrSav]

	ASSUME	DS:NOTHING
	mov	DS:[BX].unit,CL
	clc				; Exit normal termination
	ret

ExitOwn ENDP

; ==========================================================================
;
; moves the old Dpt that had been saved in TempDpt back to Dpt. this is done
; only if the first byte of TempDpt is not -1.
; all registers (including flags) are preserved.
;
; ==========================================================================

RestoreOldDpt PROC NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

		; if we have already restored the disk base table earlier,
		; do not do it again.

	push	AX
	xor	AL,AL

	mov	[Had_Format_Error],AL		; Reset flag and get current
	xchg	[Media_Set_For_Format],AL	; flag setting
	or	AL,AL
	jz	DontRestore

	push	SI
	push	DS
	push	ES
	lds	SI,[TempDpt]

	ASSUME	DS:NOTHING
	mov	ES,Bios_Data_Word		; CAS -- bleeeech!

	ASSUME	ES:Bios_Data
	mov	ES,ZeroSeg
	mov	WORD PTR ES:[DskAdr],SI
	mov	WORD PTR ES:[DskAdr+2],DS
	pop	ES
	pop	DS

	ASSUME	DS:Bios_Data
	pop	si

DontRestore:
	pop	ax
	clc					; Clear carry
	ret

RestoreOldDpt ENDP

; ==========================================================================
;	get media id
; ==========================================================================
;
; FUNCTION: get the volume label,the system id and the serial number from
;	    the media that has the extended boot record.
;	    for the conventional media,this routine will return "unknown
;	    media type" error to dos.
;
; INPUT :   ES:di -> bds table for this drive.
;
; OUTPUT:   the request packet filled with the information,if not carry.
;	    if carry set,then al contains the device driver error number
;	    that will be returned to dos.
;	    register DS,DX,AX,CX,DI,SI destroyed.
;
; SUBROUTINES TO BE CALLED:
;	BootIo:NEAR
;
; LOGIC:
;	to recognize the extended boot record,this logic will actually
;	access the boot sector even if it is a hard disk.
;	note:the valid extended bpb is recognized by looking at the mediabyte
;	field of bpb and the extended boot signature.
;
; {
;	get logical drive number from bds table;
;	rFlag = read operation;
;	BootIo;		 /*get the media boot record into the buffer
;	if (no error) then
;	     if (extended boot record) then
;		{ set volume label,volume serial number and system id
;		  of the request packet to those of the boot record;
;		};
;	     else		  /*not an extended bpb */
;		{ set register al to "unknown media.." error code;
;		  set carry bit;
;		};
;	else
;	     ret;		/*already error code is set in the register al
;
; ==========================================================================

GetMediaId	PROC	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	call	ChangeLineChk

	mov	AL,ES:[DI].BDS_DriveLet ; Logical drive number
	mov	rFlag,ROMREAD		; Read operation
	call	BootIo			; Read boot sector into DiskSector
	jc	IOCtl_If1

	cmp	DiskSector.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR,0f0h
	jb	IOCtl_If2		; brif not valid (0f0h - 0ffh)

	cmp	DiskSector.EXT_BOOT_SIG,ext_boot_signature ; =29h
	jnz	IOCtl_If2		; Extended boot record

	les	DI,[PtrSav]		; ES:di points to request header.
	les	DI,ES:[BX].GenericIOCtl_Packet
	mov	SI,OFFSET DiskSector.EXT_BOOT_SERIAL
	add	DI,mi_serial
	mov	CX,SIZE EXT_BOOT_SERIAL+SIZE EXT_BOOT_VOL_LABEL+SIZE EXT_SYSTEM_ID
	rep	movsb			; Move frm Bios_Data into request packet
	clc
	ret

IOCtl_If2:
	mov	AL,Error_UnKnown_Media	; =7
	stc
IOCtl_If1:
	ret
GetMediaId	ENDP

; ==========================================================================
;  set media id
; ==========================================================================

; function: set the volume label, the system id and the serial number of
;	    the media that has the extended boot record.
;	    for the conventional media, this routine will return "unknown
;	    media.." error to dos.
;	    this routine will also set the corresponding informations in
;	    the bds table.
;
; input :   ES:di -> bds table for this drive.
;
; output:   the extended boot record in the media will be set according to
;	    the request packet.
;	    if carry set, then al contains the device driver error number
;	    that will be returned to dos.
;
; subroutines to be called:
;	BootIo:NEAR
;
; logic:
;
;
; {
;	get drive_number from bds;
;	rFlag = "read operation";
;	BootIo;
;	if (no error) then
;	     if (extended boot record) then
;		{ set volume label,volume serial number and system id
;		  of the boot record to those of the request packet;
;		  rFlag = "write operation";
;		  get drive number from bds;
;		  BootIo;	  /*write it back*/
;		};
;	     else		  /*not an extended bpb */
;		{ set register al to "unknown media.." error code;
;		  set carry bit;
;		  ret;	 /*return back to caller */
;		};
;	else
;	     ret;		 /*already error code is set */
;
; ==========================================================================

SetMediaId	PROC	NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	call	ChangeLineChk
	mov	AL,ES:[DI].BDS_DriveLet ; Logical drive number
	mov	DL,AL			; Save it for the time being.
	mov	rFlag,ROMREAD		; Read operation
	push	DX			; Save drive number
	call	BootIo			; Read boot sec to Bios_Data:DiskSector
	pop	DX			; Restore drive number
	jc	IOCtl_If6

					; Valid? (0f0h-0ffh?)
	cmp	DiskSector.EXT_BOOT_BPB.BPB_MEDIADESCRIPTOR,0f0h
	jb	IOCtl_If7		; Brif not

	cmp	DiskSector.EXT_BOOT_SIG,ext_boot_signature ; =41 (=29h)
	jnz	IOCtl_If7		; Extended boot record

	push	ES			; Save BDS pointer
	push	DI
	push	DS			; Point ES To boot record
	pop	ES

	mov	DI,OFFSET DiskSector.EXT_BOOT_SERIAL
	lds	SI,[PtrSav]		; DS:si points to request header.
	ASSUME	DS:NOTHING
	lds	SI,DS:[SI].GenericIOCtl_Packet
	add	SI,mi_serial
	mov	CX,SIZE EXT_BOOT_SERIAL+SIZE EXT_BOOT_VOL_LABEL+SIZE EXT_SYSTEM_ID
	rep	movsb

	push	ES			; point ds back to Bios_Data
	pop	DS

		;	if	dhigh ; cas - only disable for binary compare

	ASSUME	DS:Bios_Data

		;	endif

	pop	DI			;restore bds pointer
	pop	ES
	call	Mov_Media_Ids		; update the bds media id info.
	mov	AL,DL			; set drive number for BootIo
	mov	rFlag,ROMWRITE
	call	BootIo			; write it back.
	mov	[Tim_Drv],-1		; make sure chk_media check the driver
	ret				; return with error code from BootIo

IOCtl_If7:
	mov	AL,Error_UnKnown_Media	; =7
	stc

IOCtl_If6:
	ret

SetMediaId	ENDP

; ==========================================================================
;	BootIo
; ==========================================================================
;
; function: read/write the boot record into boot sector.
;
; input :
;	    al=logical drive number
;	    rFlag = operation (read/write)
;
; output:   for read operation,the boot record of the drive specified in bds
;	    be read into the DiskSector buffer.
;	    for write operation,the DiskSector buffer image will be written
;	    to the drive specified in bds.
;	    if carry set,then al contains the device driver error number
;	    that will be returned to dos.
;	    AX,CX,DX register destroyed.
;	    if carry set,then al will contain the error code from DiskIO.
;
; subroutines to be called:
;	DiskIO:NEAR
;
; logic:
;
; {
;	first_sector = 0;	 /*logical sector 0 is the boot sector */
;	sectorcount = 1;	 /*read 1 sector only */
;	buffer = DiskSector;	 /*read it into the DiskSector buffer */
;	call DiskIO (rFlag,drive_number,first_sector,sectorcount,buffer);
; }
; ==========================================================================

BootIo	PROC	NEAR

	ASSUME	DS:Bios_Data

	push	ES
	push	DI
	push	BX
	push	DS
	pop	ES			; Point ES: to Bios_Data

		; Call DiskIO to read/write the boot sec. The parameters which
		; need to be initialized for this subroutine out here are
		; - Transfer address to Bios_Data:DiskSector
		; - Low sector needs to be initalized to 0. this is a reg. param
		; - Hi sector in [Start_Sec_H] needs to be initialised to 0.
		; - Number of sectors <-- 1

	mov	DI,OFFSET DiskSector	; ES:di -> transfer address
	xor	DX,DX			; First sector (h) -> 0
	mov	[Start_Sec_H],DX		; Start sector (h) -> 0
	mov	CX,1			; One sector
	call	DiskIO

	pop	BX
	pop	DI
	pop	ES
	ret
BootIo	ENDP


; ==========================================================================
;	ChangeLineChk
; ==========================================================================
;
; when the user calls get/set media id call before dos establishes the media
; by calling "media_chk",the change line activity of the drive is going to be
; lost.	this routine will check the change line activity and will save the
; history in the flags.
;
; FUNCTION: check the change line error activity
;
; INPUT :  ES:di -> bds table.
;
; OUTPUT:   flag in bds table will be updated if change line occurs.
;
; SUBROUTINES TO BE CALLED:
;	Set_Changed_DL
;
; ==========================================================================

ChangeLineChk	PROC	NEAR

	ASSUME	DS:Bios_Data

	mov	DL,ES:[DI].BDS_DriveNum
	or	DL,DL				; Fixed disk?
	js	ChanngeLnChkRet			; Yes, skip it.

	test	ES:[DI].BDS_Flags,RETURN_FAKE_BPB ;Don't do it duing format.
	jnz	ChanngeLnChkRet

	cmp	[fHave96],1			; This rom support change line?
	jne	ChanngeLnChkRet
	call	HasChange			; This drive support change line?
	jz	ChanngeLnChkRet			; Do nothing

		; Execute the rom disk interrupt to check changeline activity.

	mov	AH,16h
	int	13h
	jnc	ChanngeLnChkRet			; No change line activity?

	push	bx
	mov	BX,fCHANGED			; Update flag in BDS for this
	call	Set_Changed_DL			; physical drive
	pop	bx

ChanngeLnChkRet:
	ret

ChangeLineChk	ENDP

; ==========================================================================
;	GetAccessFlag
; ==========================================================================
;
; FUNCTION: get the status of UNFORMATTED_MEDIA bit of flags in bds table
;
; INPUT :
;	    ES:di -> bds table
;
; OUTPUT:   a_DiskAccess_Control.dac_access_flag = 0 if disk i/o not allowed.
;						 = 1 if disk i/o allowed.
; ==========================================================================

GetAccessFlag	PROC

	ASSUME	DS:Bios_Data,ES:NOTHING
	lds	BX,[PtrSav]		; DS:BX points to request header.

	ASSUME	DS:NOTHING
	lds	BX,DS:[BX].GenericIOCtl_Packet

	mov	AL,0			; Assume result is unformatted
	test	ES:[DI].BDS_Flags,UNFORMATTED_MEDIA ; Is it unformtted media?
	jnz	GafDone			; Done if unformatted
	inc	al			; Return true for formatted

GafDone:
	mov	[BX].dac_access_flag,AL
	ret

GetAccessFlag	ENDP

; ==========================================================================
;	SetAccessFlag
; ==========================================================================
;
; function: set/reset the UNFORMATTED_MEDIA bit of flags in bds table
;
; input :
;	    ES:di -> bds table
;
; output:   unformtted_media bit modified according to the user request
; ==========================================================================

SetAccessFlag	PROC

	ASSUME	DS:Bios_Data

	lds	BX,[PtrSav]		; ES:BX points to request header.
	lds	BX,DS:[BX].GenericIOCtl_Packet
	and	ES:[DI].BDS_Flags,NOT UNFORMATTED_MEDIA
	cmp	[BX].DAC_Access_Flag,0
	jne	saf_Done
	or	ES:[DI].BDS_Flags,UNFORMATTED_MEDIA

saf_Done:
	ret

SetAccessFlag	ENDP

; ==========================================================================
; Ioctl_Support_Query
; ==========================================================================
;
; New device command which was added in DOS 5.00 to allow a query of a 
; specific specific GENERIC IOCtl to see if it is supported. Bit 7 in the
; device attributes specifies if this function is supported.
;
; ==========================================================================

	PUBLIC Ioctl_Support_Query
Ioctl_Support_Query PROC NEAR

	ASSUME	DS:Bios_Data,ES:NOTHING

	push	ES
	les	BX,[PtrSav]		; ES:BX Points to request header.
	mov	AX,WORD PTR ES:[BX].MajorFunction ; AL == Major, AH == Minor

	cmp	AL,IOC_DC		; See if major code is 8
	jne	NoSupport

	push	CS			; ES == Code segment
	pop	ES

	ASSUME	ES:Bios_Code

	mov	CX,IOC_DC_TABLE_LEN
	mov	DI,OFFSET IOC_DC_Table	; ES:DI -> Major table
	xchg	AL,AH			; Put minor code in AL
	repne	scasb			; Scan for minor code in AL
	jne	NoSupport		; Was it found

	mov	AX,100h			; Signal ioctl is supported
	jmp	SHORT IoctlSupExit

IoctlSupExit:
	pop	ES
	clc
	ret

NoSupport:
	pop	ES
	jmp	BC_CmdErr

Ioctl_Support_Query ENDP


; ==========================================================================
;	GetMediaSenseStatus
; ==========================================================================
;
; FUNCTION: Will return the type of diskette media in the specified DOS
;	    diskette drive and whether the media is the default type
;	    for that drive. (default type means the max size for that
;	    drive)
;
; INPUT :   ES:DI -> BDS table
; OUTPUT:   If carry clear
;	    DS:BX -> Updated IOCtlPacket
;
;			 Special Function at offset 0:
;				0	- Media detected is not default type
;				1	- Media detected is default type
;
;			 Device Type at offset 1:
;				2       - 720K 3.5" 80 tracks
;				7	- 1.44M 3.5" 80 tracks
;				9	- 2.88M 3.5" 80 tracks
;
; Error Codes returned in AX if carry set:
;
; 8102 - Drive not ready	- No disk is in the drive.
; 8107 - Unknown media type	- Drive doesn't support this function or
;				  the media is really unkown, any error
;				  other than "media not present"
; 
; ==========================================================================

SenseMediaType PROC

	ASSUME	DS:Bios_Data,ES:NOTHING
	lds	BX,[PtrSav]		; DS:BX points to request header.

	ASSUME	DS:NOTHING
	lds	BX,DS:[BX].GenericIOCtl_Packet
	mov	WORD PTR DS:[BX],00	; Initialize the 2 packet bytes

	mov	DL,ES:[DI].BDS_DriveNum	; Get int 13h drive number from BDS
	xor	DH,DH			; DX == physical drive number
	mov	AH,20h			; Get Media Type function
	int	13h			; If no carry media type in AL
	jc	MediaSenseErr		; ELSE error code in AH

	inc	BYTE PTR DS:[BX]	; Signal media type is default (bit 1)

DetermineMediaType:	
	dec	AL
	cmp	AL,2			; Chk for 720K ie: (3-1) = 2
	je	GotMediaType

	add	AL,4
	cmp	AL,7			; Chk for 1.44M  ie: (4-1+4) = 7
	je	GotMediaType

	cmp	AL,9			; Chk for 2.88M  ie: (6-1+4) =  9
	jne	UnknownMediaType	; Just didn't recognize media type

GotMediaType:
	mov	DS:[BX+1],AL		; Save the return value
	clc				; Signal success
	ret
	
		; We come here if carry was set after the int 13h call.
		; Before we process the error we need to see if it was
		; a real error or just that the media type is not the
		; default for the type of drive but was readily identified.

MediaSenseErr:
	cmp	AH,32h			; See if not default media erro
	je	DetermineMediaType	; Not really an error

	mov	AL,2			; Now assume drive not ready
	cmp	AH,31h			; See if media was present
	je	SenseErrExit		; Return drive not ready

UnknownMediaType:
	mov	AL,7			; Just don't know the media type

SenseErrExit:
	mov	AH,81h			; Signal error return
	stc
	ret

SenseMediaType ENDP

; ==========================================================================

Bios_Code	ends

	end




=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msinit.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	msinit for BIOS
;
;----------------------------------------------------------------------------
;
; M010 : IFDEFd the usage of Extended Keynboard read functions (10h &11h)
;        To support LOTUS Metro.
;
; M021 : Fix for AT&T 6300 WGS ROM BIOS bug
;
; M036 : Added VDISK header clearing code at INT 19 & CTRL ALT DEL
;
; M043 SR 10/17/90	Added special code which checks for IBM machines and
;			boots only on them. Code is activated only if the
;			flag IBM_VERSION is defined at assembly time.
;
; M048 : bin_to_bcd & bcd_to_bin using aam & aad
;
; M068 : B#6271. Added missed out RPL support.
;
; M083 : Take out bios' INT 6C hook if POWER is built into BIOS.
;
;----------------------------------------------------------------------------
;

EXTENDEDKEY	equ	1	; use extended keyboard functions

	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include	msdskpr.inc
	include dossym.inc
	include	bpb.inc
	include	bootform.inc
	include	dosmac.inc
	include biostruc.inc
	include	msbds.inc

	include	mult.inc	; M068


;	the following segment follows sysinit.  It is used to define
;	  the location to load MSDOS.SYS into.

dos_load_seg	segment	para public 'dos_load_seg'
dos_load_seg	ends


	include msgroup.inc	; establish Bios_Data segment


;	Note:  Most of the disk routines keep a pointer to the current bds
;	   in es:[di] or ds:[di].  The newer routines (in the resident code)
;	   use es:[di] consistently, because they assume that ds: points to
;	   Bios_Data.  The macros "mapnew" and "unmapnew" are used for
;	   switching back and forth when calling subroutines with the new
;	   mapping.

mapnew	macro
	push	es		; save whatever's in es
	push	ds		; copy bds to es:di
	pop	es
	push	cs		; copy Bios_Data to ds
	pop	ds
	endm

unmapnew	macro
	push	es		; copy bds back to ds:di
	pop	ds
	pop	es		; pop whatever was in es
	endm

;=======================================================
;=======================================================
;M011 -- eliminated hardnum,hdsktab,bdsh,bdsx,endtwohard,endonehard
;M011 -- changed bdsms -> bdss
	extrn	hdrv_pat:word
	extrn	orig13:dword
	extrn	RomVectors:dword
	extrn	NUMROMVECTORS:abs
	extrn	harddrv:byte
	extrn	drvmax:byte
	extrn	dskdrvs:word
	extrn	eot:byte
	extrn	fhave96:byte
	extrn	daycnt:word
	extrn	res_dev_list:word
	extrn	dsktnum:byte
	extrn	start_bds:dword
	extrn	fhavek09:byte
	extrn	single:byte
	extrn	bdss:byte		;for mini disk
	extrn	havecmosclock:byte	;set by msinit. used by msclock.asm
	extrn	bintobcd:dword		;set by msinit. used by mschar.asm
	extrn	daycnttoday:dword	;set by msinit. used by mschar.asm
	extrn	old13:dword
	extrn	temp_h:word		; for 32 bit calculation. msdisk
	extrn	start_sec_h:word
	extrn	keyrd_func:byte 	; for mscon. defined in msdata.
	extrn	keysts_func:byte	; for mscon. defined in msdata.
	extrn	disksector:byte
	extrn	fat_12_id:byte
	extrn	fat_16_id:byte
	extrn	vol_no_name:byte
	extrn	motorstartup:byte
	extrn	model_byte:byte
	extrn	secondary_model_byte:byte

IFNDEF	POWER				; M083
	extrn	int6c_ret_addr:dword	; return address from int 6c
ENDIF ;	NOT POWER			; M083

	extrn	bin_date_time:byte
	extrn	month_table:word
	extrn	daycnt2:word
	extrn	feb29:byte
	extrn	ttticks:dword		;indirect intra-segment call address

	extrn	dosdatasg:word

ifdef ROMDOS
	extrn	BIOS_Res:word		; seg addr of bios code ROM
	extrn	BootFlags:word		; boot options
endif

	extrn	errout:near
	extrn	block13:far
	extrn	Int15:far		; M036
	extrn	int19:far
	extrn	intret:near
	extrn	cbreak:near
	extrn	outchr:near
	extrn	errin:near
	extrn	outchr:near

sysinitseg segment 
	assume	cs:sysinitseg
	extrn	current_dos_location:word
	extrn	device_list:dword
	extrn	memory_size:word
	extrn	default_drive:byte
	extrn	buffers:word
	extrn	sysinit:far
	extrn	temp_bcode_seg:word
	extrn	seg_reinit_ptr:dword
        extrn   toomanydrivesflag:byte          ; M029
        extrn   StartMsg:byte
sysinitseg ends

	assume	cs:datagrp

;	end of disk modules for configuration

	extrn	end96tpi:byte
	extrn	endfloppy:byte

;	ibm fixed up at rom

	extrn	ibm_disk_io:far
	extrn	endatrom:byte

;	M015 -- begin additions

;	compaq fixed up rom

	extrn	compaq_disk_io:far
	extrn	end_compaq_i13hook:byte

;	M015 -- end additions

;	equates for cmos.
									  
;----------------------------------------				  
;	cmos equates for this system	:				  
;------------------------------------------------------------------------------- 
cmos_port	equ	070h		; i/o address of cmos address port	 
cmos_data	equ	071h		; i/o address of cmos data port 	 
nmi		equ	10000000b	; disable nmi interrupts mask - 	 
					;  high bit of cmos location address	 
										 
;---------- cmos table location address's ## ----------------------------------- 
cmos_reg_a	equ	00ah		; status register a   '----------------- 
cmos_reg_b	equ	00bh		; status register b  alarm		 
cmos_shut_down	equ	00fh		; shutdown status command byte		 


;cmos clock setting support routines used by msclock.
;
; warning!!! this code will be dynamically relocated by msinit.

	extrn	base_century:byte
	extrn	base_year:byte
	extrn	month_tab:byte


; close data, open Bios_Code segment

	tocode

	extrn	bc_retf:near		; actually should be declared in
					;   Bios_Code segment
	extrn	setdrive:near
	extrn	diskrd:near
	extrn	getbp:near
	extrn	mov_media_ids:near
	extrn	clear_ids:near
Bios_Code ends


Bios_Data_Init segment
	assume	cs:datagrp

	public	daycnt_to_day	; for real time clock support
daycnt_to_day	proc	far	; for real time clock support

;entry: [daycnt] = number of days since 1-1-80
;
;return: ch - centry in bcd
;	 cl - year in bcd
;	 dh - month in bcd
;	 dl - day in bcd

	push	[daycnt]		;save daycnt
	cmp	daycnt,(365*20+(20/4))	;# of days from 1-1-1980 to 1-1-2000
	jae	century20

	mov	base_century,19
	mov	base_year,80
	jmp	short years

century20:				;20th century
	mov	base_century,20
	mov	base_year,0
	sub	daycnt,(365*20+(20/4))	;adjust daycnt
years:
	xor	dx,dx
	mov	ax,daycnt
	mov	bx,(366+365*3)		;# of days in a leap year block
	div	bx			;ax = # of leap block, dx = daycnt
	mov	daycnt,dx		;save daycnt left

	mov	bl,4
	mul	bl			;ax = # of years. less than 100 years!
	add	base_year,al		;so, ah = 0. adjust year accordingly.
	inc	daycnt			;set daycnt to 1 base
	cmp	daycnt,366		;the daycnt here is the remainder of the leap year block.
	jbe	leapyear		;so, it should within 366+355+355+355 days.
	inc	base_year		;first if daycnt <= 366, then leap year
	sub	daycnt,366		;else daycnt--, base_year++;
					;and the next three years are regular years.
	mov	cx,3
regularyear:
	cmp	daycnt,365		;for(i=1; i>3 or daycnt <=365;i++)
	jbe	yeardone		;{if (daycnt > 365)
	inc	base_year		;  { daycnt -= 365
	sub	daycnt,365		;  }
	loop	regularyear		;}

;	should never fall through loop

leapyear:
	mov	byte ptr month_tab+1,29 ;leap year. change the month table.
yeardone:
	xor	bx,bx
	xor	dx,dx
	mov	ax,daycnt
	mov	si,offset month_tab
	mov	cx,12
months:
	inc	bl
	mov	dl,byte ptr ds:[si]	;compare daycnt for each month until fits
	cmp	ax,dx			;dh=0.
	jbe	month_done

	inc	si			;next month
	sub	ax,dx			;adjust daycnt
	loop	months

;	should never fall through loop

month_done:
	mov	byte ptr month_tab+1,28 ;restore month table value
	mov	dl,bl
	mov	dh,base_year
	mov	cl,base_century 	;now, al=day, dl=month,dh=year,cl=century
	call	bintobcd		;oh my!!! to save 15 bytes, bin_to_bcd proc
					;was relocated seperately from daycnt_to_day proc.
	xchg	dl,al			;dl = bcd day, al = month
	call	bintobcd

	xchg	dh,al			;dh = bcd month, al = year
	call	bintobcd

	xchg	cl,al			;cl = bcd year, al = century
	call	bintobcd

	mov	ch,al			;ch = bcd century
	pop	[daycnt]		;restore original value
	ret
daycnt_to_day	endp

enddaycnttoday label	byte

	public	bin_to_bcd
bin_to_bcd	proc	far		;for real time clock support

;convert a binary input in al (less than 63h or 99 decimal)
;into a bcd value in al.  ah destroyed.

	push	cx

	aam				; M048
	mov	cl, 4			; M048
	shl	ah, cl			; M048
	or	al, ah			; M048

;M048	xor	ah,ah
;M048	mov	cl,10
;M048	div	cl		;al - high digit for bcd, ah - low digit for bcd
;M048	mov	cl,4
;M048	shl	al,cl		;mov the high digit to high nibble
;M048	or	al,ah

	pop	cx
	ret
bin_to_bcd	endp

endcmosclockset label byte		; end of cmos clock support routines

IFNDEF	POWER				; M083
	align	2			; cas -- trash aligns!

; the k09 requires the routines for reading the clock because of the suspend/
; resume facility. the system clock needs to be reset after resume.

	assume	es:nothing

; the following routine is executed at resume time when the system
; powered on after suspension. it reads the real time clock and
; resets the system time and date, and then irets.

; warning!!! this code will be dynamically relocated by msinit.

int6c	proc	far
	push	cs
	pop	ds

	assume ds:datagrp

	pop	word ptr int6c_ret_addr ; pop off return address
	pop	word ptr int6c_ret_addr+2
	popf
	call	read_real_date		; get the date from the clock
	cli
	mov	ds:daycnt,si		; update dos copy of date
	sti
	call	read_real_time		; get the time from the rtc
	cli

	mov	ah,01h			; command to set the time
	int	1ah			; call rom-bios time routine

	sti
	jmp	int6c_ret_addr		; long jump

int6c	endp


;************************************************************************
;
;   read_real_date reads real-time clock for date and returns the number
;   of days elapsed since 1-1-80 in si
;
read_real_date proc near
	assume	ds:datagrp,es:nothing

	push	ax
	push	cx
	push	dx

	xor	ah,ah			; throw away clock roll over
	int	1ah

	pop	dx
	pop	cx
	pop	ax			; cas - bad code!

	push	ax
	push	bx
	push	cx
	push	dx

	mov	cs:daycnt2,1	; real time clock error flag (+1 day)
	mov	ah,4		; read date function code
	int	1ah		; read real-time clock
	jnc	read_ok 	; jmp success
	jmp	r_d_ret 	; jmp error

read_ok:			; ******* get bcd values in binary *****
	mov	byte ptr bin_date_time+0,ch  ; store as hex value
	mov	byte ptr bin_date_time+1,cl  ; ...
	mov	byte ptr bin_date_time+2,dh  ; ...
	mov	byte ptr bin_date_time+3,dl  ; ...

	mov	cs:daycnt2,2	; read of r-t clock successful
	call	bcd_verify	; verify bcd values in range
	jc	r_d_ret 	; jmp some value out of range
	mov	cs:daycnt2,3	; read of r-t clock successful
	call	date_verify	; verify date values in range
	jc	r_d_ret 	; jmp some value out of range
	mov	cs:daycnt2,0	; verify successful
	call	in_bin		; convert date to binary
				; ******* years since 1-1-80 *********
	mov	al,byte ptr bin_date_time+1  ; get years into century
	cbw				     ;
	cmp	byte ptr bin_date_time+0,20  ; 20th century?
	jnz	century_19		     ; jmp no
	add	ax,100		; add in a century
century_19:			;
	sub	ax,80		; subtract off 1-1-80
	mov	cl,4		; leap year every 4
	div	cl		; al= # leap year blocks, ah= remainder
	mov	bl,ah		; save odd years
	cbw			; zero ah
	mov	cx,366+3*365	; # of days in leap year blocks
	mul	cx		; dx:ax is result
	mov	cs:daycnt2,ax	; save count of days
	mov	al,bl		; get odd years count
	cbw			;
	or	ax,ax		; is ax= 0?
	jz	leap_year	; jmp if none
	mov	cx,365		; days in year
	mul	cx		; dx:ax is result
	add	cs:daycnt2,ax	; add on days in odd years
	jmp	short leap_adjustment ; account for leap year
leap_year:			; possibly account for a leap day
	cmp	byte ptr bin_date_time+2,2 ; is month february
	jbe	no_leap_adjustment ; jan or feb. no leap day yet.
leap_adjustment:		; account for leap day
	inc	cs:daycnt2
no_leap_adjustment:		; ******* get days of month *******
	mov	cl,byte ptr bin_date_time+3
	xor	ch,ch
	dec	cx		; because of offset from day 1, not day 0
	add	cs:daycnt2,cx	 ; ******* get days in months preceeing *****
	mov	cl,byte ptr bin_date_time+2   ; get month
	xor	ch,ch
	dec	cx		; january starts at offset 0
	shl	cx,1		; word offset
	mov	si,offset month_table	; beginning of month_table
	add	si,cx		; point into month table
	mov	ax,word ptr [si]; get # days in previous months
	add	cs:daycnt2,ax
r_d_ret:
	mov	si,cs:daycnt2	 ; result in si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

r_t_retj:
	xor	cx,cx
	xor	dx,dx
	jmp	short r_t_ret

read_real_date endp

;--------------------------------------------------------------------

; read_real_time reads the time from the rtc. on exit, it has the number of
; ticks (at 18.2 ticks per sec.) in cx:dx.

read_real_time proc near
	assume	ds:datagrp,es:nothing	; cas -- is this correct????

	mov	ah,2
	int	1ah
	jc	r_t_retj

oktime:
	mov	byte ptr bin_date_time,ch	; hours
	mov	byte ptr bin_date_time+1,cl	; minutes
	mov	byte ptr bin_date_time+2,dh	; seconds
	mov	byte ptr bin_date_time+3,0	; unused for time

	call	bcd_verify
	jc	r_t_retj
	call	time_verify
	jc	r_t_retj

	call	in_bin
	mov	ch,byte ptr bin_date_time
	mov	cl,byte ptr bin_date_time+1
	mov	dh,byte ptr bin_date_time+2
	mov	dl,byte ptr bin_date_time+3

; get time in ticks in cx:dx

	call	ttticks			; note:  indirect far call
r_t_ret:
	ret

read_real_time endp

;--------------------------------------------------------------------

;   in_bin converts bin_date_time values from bcd to bin

in_bin	proc	near
	assume	ds:datagrp,es:nothing

	mov	al,byte ptr bin_date_time+0  ; century or hours
	call	bcd_to_bin
	mov	byte ptr bin_date_time+0,al

	mov	al,byte ptr bin_date_time+1  ; years or minutes
	call	bcd_to_bin
	mov	byte ptr bin_date_time+1,al

	mov	al,byte ptr bin_date_time+2  ; months or seconds
	call	bcd_to_bin
	mov	byte ptr bin_date_time+2,al

	mov	al,byte ptr bin_date_time+3  ; days (not used for time)
	call	bcd_to_bin
	mov	byte ptr bin_date_time+3,al

	ret

in_bin	endp

;--------------------------------------------------------------------

;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
;   a binary representation in al
;   ah is destroyed

bcd_to_bin proc	near
	assume	ds:nothing,es:nothing

	mov	ah, al		; M048
	and	al, 0fh		; M048
	mov	cl, 4		; M048
	shr	ah, cl		; M048
	aad			; M048
	ret

;	  subtract hi nibble * 6

;M048	mov	ah,al
;M048	and	ah,0f0h 	; isolate the high nibble
;M048	shr	ah,1		; get ah=hi nibble*8
;M048	shr	ah,1		; get ah=hi nibble*4
;M048	sub	al,ah		; subtract hi nibble * 4
;M048	shr	ah,1		; get ah=hi nibble*2
;M048	sub	al,ah		; subtract hi nibble * 2
;M048	ret

bcd_to_bin endp

;--------------------------------------------------------------------

;   date_verify loosely checks bcd date values to be in range in bin_date_time

date_verify proc near
	assume	ds:datagrp,es:nothing

	cmp	byte ptr bin_date_time+0,20h  ; century check
	ja	date_error		      ;	error
	jz	century_20		      ; jmp in 20th century

	cmp	byte ptr bin_date_time+0,19h  ; century check
	jb	date_error		      ;  error
	cmp	byte ptr bin_date_time+1,80h  ; year check
	jb	date_error		      ;  error

century_20:
	cmp	byte ptr bin_date_time+1,99h  ; year check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+2,12h  ; month check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+2,00h  ; month check
	jbe	date_error		      ;  error
	cmp	byte ptr bin_date_time+3,31h  ; day check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+3,00h  ; day check
	jbe	date_error		      ;  error
	clc				      ; set success flag
	ret
date_error:
	stc				      ; set error flag
	ret

date_verify endp

;--------------------------------------------------------------------

; time_verify very loosely checks bcd date values to be in range in bin_date_time

time_verify proc near
	assume	ds:datagrp,es:nothing

	cmp	byte ptr bin_date_time+0,24h
	ja	time_error
	cmp	byte ptr bin_date_time+1,59h
	ja	time_error
	cmp	byte ptr bin_date_time+2,59h
	ja	time_error

	clc
	ret

time_error:
	stc
	ret

time_verify endp

;--------------------------------------------------------------------

;   bcd_verify checks values in bin_date_time to be valid
;   bcd numerals.  carry set if any nibble out of range

bcd_verify proc near
	assume	ds:datagrp,es:nothing

	mov	cx,4		; 4 bytes to check
	mov	bx,offset bin_date_time
bv_loop:
	mov	al,[bx] 	; get a bcd number (0..99)
	mov	ah,al
	and	ax,0f00fh	; 10's place in high ah, 1's in al
	cmp	al,10		; is 1's place in range?
	ja	bv_error	; jmp out of range

	shr	ah,1		; swap nibbles
	shr	ah,1
	shr	ah,1
	shr	ah,1
	and	ah,0fh		; get rid of any erroneous bits
	cmp	ah,10		; is 10's place in range
	ja	bv_error	; jmp out of range

	inc	bx		; next byte
	dec	cx
	jnz	bv_loop

	clc			; set success flag
	ret

bv_error:
	stc			; set error flag
	ret

bcd_verify endp

;--------------------------------------------------------------------

;  the real time clock structures were moved to msbio2.asm

endk09	label	byte

ENDIF ; NOT POWER		; M083

;*********************************************************
;	system initialization
;
;	the entry conditions are established by the bootstrap
;	loader and are considered unknown. the following jobs
;	will be performed by this module:
;
;	1.	all device initialization is performed
;
;	2.	a local stack is set up and ds:si are set
;		to point to an initialization table. then
;		an inter-segment call is made to the first
;		byte of the dos
;
;	3.	once the dos returns from this call the ds
;		register has been set up to point to the start
;		of free memory. the initialization will then
;		load the command program into this area
;		beginning at 100 hex and transfer control to
;		this program.
;
;********************************************************



; drvfat must be the first location of freeable space!

	align	2
drvfat	dw	0000			;drive and fat id of dos
bios_l dw	0000			;first sector of data (low word)
bios_h dw	0000			;first sector of data (high word)
doscnt	dw	0000			;how many sectors to read
fbigfat db	0			; flags for drive

fatloc		dw	?		; seg addr of fat sector
init_bootseg	dw	?		; seg addr of buffer for reading boot record
rom_drv_num	db	80h		; rom drv number
md_sectorsize	dw 512			; used by get_fat_sector proc.
temp_cluster	dw 0			; used by get_fat_sector proc.
last_fat_secnum dw -1			; used by get_fat_sector proc.

; the following two bytes are used to save the info returned by int 13, ah = 8
; call to determine drive parameters.

num_heads db	2			; number of heads returned by rom
sec_trk   db	9			; sec/trk returned by rom
num_cyln  db	40			; number of cylinders returned by rom

fakefloppydrv db      0 		; if 1, then no diskette drives in the system.

bootbias  =	200h
boot_addr =	7c00h

	align	2
disktable dw	512,  0100h,  64,0
	dw	2048, 0201h, 112,0
	dw	8192, 0402h, 256,0
	dw	32680,0803h, 512,0	;warning !!! old values
	dw	65535,1004h,1024,0



; default disktable under the assumption of total fat size <= 128 kb, and
;	the maxium size of fat entry = 16 bit.

disktable2  dw	 0, 32680, 0803h, 512, 0	;for compatibility.
	    dw	4h, 0000h, 0402h, 512, fbig	;covers upto 134 mb media.
	    dw	8h, 0000h, 0803h, 512, fbig	;	upto 268 mb
	    dw 10h, 0000h, 1004h, 512, fbig	;	upto 536 mb
	    dw 20h, 0000h, 2005h, 512, fbig	;	upto 1072 mb
	    dw 40h, 0000h, 4006h, 512, fbig	;	upto 2144 mb
	    dw 80h, 0000h, 8007h, 512, fbig	;	upto 4288 mb...

;******************************************************
;variables for mini disk initialization
;******************************************************

;M011 -- begin changed section

rom_minidisk_num db	0		; temp variable for phys unit
hnum		db	0		; real number of hardfiles
last_dskdrv_table dw	offset dskdrvs	; index into dskdrv table
end_of_bdss	dw	bdss		;offset value of the ending address
					;of bds table. needed to figure out
					;the dosdatasg address.
mini_hdlim	dw	0
mini_seclim	dw	0

;M011 -- end changed section

;end of mini disk init variables *********************


bios_date db	'01/10/84',0		;used for checking at rom bios date.
bdate_l	=	(offset $)-(offset bios_date)

; the following are the recommended bpbs for the media that we know of so
; far.

bpbx	struc
	dw	512
	db	?
	dw	1
	db	2
	dw	?
	dw	?
	db	?
	dw	?
	dw	?
	dw	2
	dw	0
	dw	0		; hidden sector high
	dd	0		; extended total sectors
bpbx	ends

	align	2
bpb48t	bpbx	<,2,,,112,2*9*40,0fdh,2,9>	; 48 tpi diskettes
	align	2
bpb96t	bpbx	<,1,,,224,2*15*80,0f9h,7,15>	; 96 tpi diskettes
	align	2
bpb35	bpbx	<,2,,,70h,2*9*80,0f9h,3,9>	; 3.5" diskettes
	align	2							; m037
bpb288	bpbx	<,2,,,240,2*36*80,0f0h,9,36>	; 2.88MB diskettes	; m037
	align	2
bpbtable dw	offset datagrp:bpb48t	; 48tpi drives
	dw	offset datagrp:bpb96t;	; 96tpi drives
	dw	offset datagrp:bpb35	; 3.5" drives
	dw	offset datagrp:bpb35	; unused 8" diskette	DUMMY m037
	dw	offset datagrp:bpb35	; unused 8" diskette 	DUMMY m037
	dw	offset datagrp:bpb35	; used for hard disk	DUMMY m037
	dw	offset datagrp:bpb35	; used for tape drive	DUMMY m037
	dw	offset datagrp:bpb35	; FFOTHER		DUMMY m037
	dw	offset datagrp:bpb35	; ERIMO			DUMMY m037
	dw	offset datagrp:bpb288	; 2.88MB drive		      m037

;	entry point to call utility functions in Bios_Code.  At this time,
;	  we aren't doing any A20 switching.  During MSINIT time Bios_Code
;	  will not yet be moved to its final resting place, so we know
;	  it'll be low.
;
;	to use this function, do a "push cs" and load bp with the offset of
;	  the function you want to call in Bios_Code.  This routine will
;	  push the address of a retf in Bios_Code onto the stack which
;	  will get executed when the utility function finishes.  It will
;	  then transfer control to Bios_Code:bp using a couple of pushes
;	  and a retf

	extrn	cdev:dword

addr_of_bcretf	dw	bc_retf

call_bios_code proc near
	assume	ds:nothing, es:nothing

	push	addr_of_bcretf		; set up near return to far return
ifndef ROMDOS
	push	word ptr [cdev].2	; push Bios_Code segment
else
	push	BIOS_Res		; addr of ROM code segment
endif
	push	bp			; save offset of utility function

	retf				; far jump to BIOS code

call_bios_code endp


flp_drvs	db	0


;===========================================================================
;
; entry from boot sector.  the register contents are:
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector on disk.
;   ax = first data sector (high)
;   di = sectors/fat for the boot media.
;
	public	init
init	proc	near
	assume	ds:nothing,es:nothing

;
;M043; Begin changes
; This code has been added for IBM. It checks for IBM hardware and refuses
;to boot if the machine is not a true-blue IBM.
;

IF	0
ifdef 	IBM_VERSION

COPYR_LEN	equ	31

	push	ax
	push	bx
	push	cx
	push	di

	mov	ax,0fac0h
	mov	es,ax			; es = ROM Copyright segment
	mov	di,09bh		; es:di points at copyright
	push	cs
	pop	ds
	mov	si,offset datagrp:CopyrightIBM	; ds:si = copyright string
	mov	cx,COPYR_LEN		; length of string
	cld
	repz	cmpsb
	jz	isIBM			; copyright compared, IBM

;
;Check for IBM Basic Lite
;
 	mov	ah,22h
	int	15h
	jc	NotIBM			; not an IBM machine

	or	ah,ah
	jz	isIBM			; is an IBM Basic Lite

NotIBM:
	mov	si,offset datagrp:IBMBootFailMsg	;
	mov	bx,7			; setup display page
shIBMmsg:
	lodsb
	or	al,al
	jz	IBMstall		; done with message, stall

	mov	ah,14
	int	10h			; write teletype
	jmp	short shIBMmsg

IBMstall:
	jmp	short IBMstall		;hang 

CopyrightIBM	db	'The IBM Personal Computer Basic'

	include msbio.cl8		; the boot fail message

isIBM:					; IBM machine, continue init
	pop	di
	pop	cx
	pop	bx
	pop	ax

endif
ENDIF

;
;M043; End changes
;

	cli
	push	ax
	xor	ax,ax
	mov	ds,ax
	pop	ax

IFDEF	ROMDOS
;
;	If we are booting ROMDOS ax will contain a segment address
;	of a ROM BLOCK whcih has a proper signature and check sum.
;	Word at 70:0 needs to be initialized to this segment address
;	to satisfy Windows 3.0 enhanced mode.
;
	mov	word ptr ds:[700h], ax
ENDIF

; msload will check the extended boot record and set ax, bx accordingly.

;	msload passes a 32 bit sector number hi word in ax and low in bx
;	save this in cs:bios_h and cs:bios_l. this is for the start of
;	data sector of the bios.

	mov	cs:bios_h,ax
	mov	cs:bios_l,bx

; with the following information from msload, we don't need the
;     boot sector any more.-> this will solve the problem of 29 kb size
;     limitation of msbio.com file.
;
;

; Save a peck of interrupt vectors...

	push	cs
	pop	es			; cannot use cs override for stos

	push	cx
	push	di
;
;   This is the best point to display the "Starting MS-DOS..." message,
;   and it's also the earliest (MSLOAD doesn't count, because that's a
;   separable module! -JTP)
;
        push    ds
        mov     ax,sysinitseg
        mov     ds,ax
        mov     SI,OFFSET sysinitseg:StartMsg
@@:     lodsb
	or	AL,AL
        jz      @F
        mov     AH,0Eh
        mov     BX,0007h                ; "normal" attribute and page
	int	10h			; video write
        jmp     @B
@@:     pop     ds

	mov	cx, NUMROMVECTORS     	; no. of rom vectors to be saved
	mov	si, offset RomVectors	; point to list of int vectors
next_int:				
	lods	byte ptr cs:[si]	; get int number
	cbw				; assume < 128
	shl	ax, 1
	shl	ax, 1			; int no * 4
	mov	di, ax
	xchg	si, di
	lodsw
	stosw
	lodsw
	stosw				; save the vector
	xchg	si, di
	loop	next_int
	pop	di
	pop	cx

;   we need to save int13 in two places in case we are running on an at.
; on ats we install the ibm supplied rom_bios patch which hooks
; int13 ahead of orig13.  since int19 must unhook int13 to point to the
; rom int13 routine, we must have that rom address also stored away.

	mov	ax, word ptr Old13	; save old13 in orig13 also
	mov	word ptr Orig13, ax
	mov	ax, word ptr Old13+2
	mov	word ptr Orig13+2, ax

; set up int 13 for new action

	mov	word ptr ds:[13h*4],offset block13
	mov	ds:[13h*4+2],cs

; set up int 15 for new action				; M036

	mov	word ptr ds:[15h*4],offset Int15	; M036
	mov	ds:[15h*4+2],cs				; M036



; set up int 19 for new action

	mov	word ptr ds:[19h*4],offset int19
	mov	ds:[19h*4+2],cs

	sti
	int	11h			;get equipment status

; we have to support a system that does not have any diskette
;drives but only hardfiles.  this system will ipl from the hardfile.
;if the equipment flag bit 0 is 1, then the system has diskette drive(s).
;otherwise, the system has only hardfiles.
;
;important thing is that still, for compatibility reason, the drive letter
;for the hardfiles start from "c".  so, we still need to allocate dummy bds
;drive a and drive b.	at sysinit time, we are going to set cds table entry
;of dpb pointer for these drives to 0, so any user attempt to access this
;drives will get "invalid drive letter ..." message.  we are going to
;establish "fakefloppydrv" flag.  ***sysinit module should call int 11h to
;determine whether there are any diskette drivers in the system or not.!!!***

;	check the register returned by the equipment determination interrupt
;	we have to handle the case of no diskettes in the system by faking
;	two dummy drives.
;
;	if the register indicates that we do have floppy drives we don't need
;	to do anything special.
;
;	if the register indicates that we don't have any floppy drives then
;	what we need to do is set the fakefloppydrv variable, change the
;	register to say that we do have floppy drives and then go to execute
;	the code which starts at notsingle.  this is because we can skip the
;	code given below which tries to find if there are one or two drives
;	since we already know about this.


	if	ibmcopyright

;************************************************************************
; p????
;
; the following fix for lloyds of london does work correctly but it
; causes a regression in the ripl machine. machines with no ipl
; diskette will have ax bit 0 = 0. the cds structure is stomped on
; later to insure that a: is a invalid drive. this is where ripl fails.
; it wants the a: drive to be valid because it intercepts requests
; to the drive and returns info from it's memory image. but, if ibmbio
; finds no ipl drive, it tells ibmdos never to request anything from
; that drive.
;
; for the meantime, we will take out the support for lloyds of london
; by setting up a false condition. (ie. ax=1).
; (they have a special build, dos 3.31 to use). architecture needs to
; get the ripl machine to set bit 0 to say that there is in fact an
; virtual ipl diskette.
;
; the next 4 lines of code should be removed when the ripl people have
; gotten their act together. the unique identifier is used in case in
; the future, we want to dynamically patch ibmbio to work on the lloyds
; machine. the program could be written to scan for:
;
;	ebh,03h,52h,50h,53h,0dh,01h
;	 "jmp"	"R" "P" "S"  or  1
;
; and dynamically change the 0dh,01h to 90h,90h. note: that this string
; must be changed twice in ibmbio.com.
;************************************************************************

	jmp    short set_bit		; jmup over db
	db     "RPS"			; unique identifier

set_bit:
	or     ax,1			; turn on the ipl bit
;************************************************************************

	endif


	test	ax,1			; floppy drives present ?
	jnz	normalfloppydrv 	;yes.
;
; Some ROM BIOSs lie that there are no floppy drives. Lets find out
; whether it is an old ROM BIOS or a new one
;
; WARNING !!!
;
; This sequence of code is present in SYSINIT1.ASM also. Any modification
; here will require an equivalent modification in SYSINIT1.ASM also
;
	push	ax
	push	bx
	push	cx
	push	dx
	push	di
	push	es
	
	mov	ah, 8			; get disk parameters
	mov	dl, 0			; of drive 0.
	int	13h

	jc	@f

	mov	flp_drvs, dl
@@:
	pop	es
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	jc	normalfloppydrv		; if error it is an old ROM BIOS
					;  so, lets assume that ROM BIOS lied

	cmp	flp_drvs, 0		; number of drvs == 0?
	jz	@f
	mov	al, flp_drvs
	dec	al			; make it zero based
	jmp	short got_num_flp_drvs
@@:
	mov	fakefloppydrv,1 	;we don't have any floppy drives.
	mov	ax,1			;after setting fakefloppydrv flag, we
	jmp	short settwodrive	; well then set it for two drives!

normalfloppydrv:			;yes, bit 0 is 1. there exist floppy drives.
	rol	al,1			;put bits 6 & 7 into bits 0 & 1
	rol	al,1
got_num_flp_drvs:
	and	ax,3			;only look at bits 0 & 1
	jnz	notsingle		;zero means single drive system
	inc	ax			;pretend it's a two drive system

settwodrive:				; set this to two fakedrives
	inc	cs:single		;remember this

notsingle:
	inc	ax			;ax has number of drives, 2-4
					;is also 0 indexed boot drive if we
					;  booted off hard file
	mov	cl,al			;ch is fat id, cl # floppies

; determine whether we booted from floppy or hard disk...

ifndef ROMDOS

	test	dl,80h			;boot from floppy ?
	jnz	gothrd			;no.

else

	mov	dx, [BootFlags]		; get boot flags
	and	dx, BF_DefaultMask	; mask off default drive indicator
	cmp	dx, BF_DefFloppy	; is it floppy disk?
	jne	gothrd			; no.

endif

	xor	ax,ax			;indicate boot from drive a
gothrd:

;   ax = 0-based drive we booted from
;   bios_l, bios_h set.
;   cl = number of floppies including fake one
;   ch = media byte

	xor	dx,dx
	cli
	mov	ss,dx
	mov	sp,700h 		;local stack
	sti
	assume	ss:nothing

	push	cx			;save number of floppies and media byte
	mov	ah,ch			;save fat id to ah
	push	ax			;save boot drive number, and media byte

; let model_byte, secondary_model_byte be set here!!!

	mov	ah,0c0h 		; return system environment
	int	15h			; call rom-bios routine

	jc	no_rom_system_conf	; just use model_byte
	cmp	ah,0			; double check
	jne	no_rom_system_conf

	mov	al,es:[bx.bios_sd_modelbyte] ;get the model byte
	mov	[model_byte],al
	mov	al,es:[bx.bios_sd_scnd_modelbyte] ;secondary model byte
	mov	[secondary_model_byte],al
	jmp	short turn_timer_on

no_rom_system_conf:
	mov	si,0ffffh
	mov	es,si
	mov	al,es:[0eh]		; get model byte
	mov	model_byte,al		; save model byte

turn_timer_on:
	mov	al,eoi
	out	akport,al		;turn on the timer

;	some olivetti m24 machines have an 8530 serial communications
;	  chip installed at io address 50h and 52h.  if we're running
;	  on one of those, we must inhibit the normal aux port initialization

	cmp	model_byte,0		; next to last byte in rom bios
	jnz	not_olivetti_m24	; skip for all other machines

;	now we know we're on an m24.  read the configuration switch to
;	  see if we think we have an 8530 chip.

	in	al,66h
	test	al,20h			; is 8530 installed?
	jz	not_olivetti_m24	;  we're done if not

;	now double check to make sure the device is really there

	mov	al,0fh
	out	50h,al
	in	al,50h
	test	al,1			; this test was copied from olivetti
	jz	skip_aux_port_init	; take this branch if 8530 installed

not_olivetti_m24:

	mov	al,3		; init com4
	call	aux_init
	mov	al,2		; init com3
	call	aux_init
	mov	al,1		; init com2
	call	aux_init
	xor	al,al		; init com1
	call	aux_init

skip_aux_port_init:
	mov	al,2		; init lpt3
	call	print_init
	mov	al,1		; init lpt2
	call	print_init
	xor	al,al		; init lpt1
	call	print_init

	xor	dx,dx
	mov	ds,dx		; to initialize print screen vector
	mov	es,dx

	xor	ax,ax
	mov	di,initspot
	stosw			; init four bytes to 0
	stosw

	mov	ax,cs		; fetch segment

	mov	ds:word ptr brkadr,offset cbreak ;break entry point
	mov	ds:brkadr+2,ax		;vector for break

	mov	ds:word ptr chrout*4,offset outchr
	mov	ds:word ptr chrout*4+2,ax

	mov	di,4
	mov	bx,offset intret	;will initialize rest of interrupts
	xchg	ax,bx
	stosw				;location 4
	xchg	ax,bx
	stosw				;int 1	;location 6
	add	di,4
	xchg	ax,bx
	stosw				;location 12
	xchg	ax,bx
	stosw				;int 3	;location 14
	xchg	ax,bx
	stosw				;location 16
	xchg	ax,bx
	stosw				;int 4	;location 18

	mov	ds:word ptr 500h,dx	;set print screen & break =0
	mov	ds:word ptr lstdrv,dx	;clean out last drive spec


;	we need to initalize the cs:motorstartup variable from the disk
;	parameter table at sec9.  the offsets in this table are defined in
;	the disk_parms struc in msdskprm.inc.  2 locs

	mov	al,ds:sec9 + disk_motor_strt
	mov	cs:motorstartup,al
	cmp	model_byte,0fdh 	; is this an old rom?
	jb	no_diddle		; no

	mov	word ptr ds:(sec9 + disk_head_sttl),0200h+normsettle
					; set head settle and motor start
					; on pc-1 pc-2 pc-xt hal0

	mov	ds:(sec9 + disk_specify_1),0dfh
					; set 1st specify byte
					; on pc-1 pc-2 pc-xt hal0
no_diddle:
	int	12h			;get memory size--1k blocks in ax
	mov	cl,6
	shl	ax,cl			;convert to 16-byte blocks(segment no.)
	pop	cx			; retreive boot drive number, and fat id (pushed long ago)
	mov	drvfat,cx		;save drive to load dos, and fat id

	push	ax			; save real top of memory

;M068 - BEGIN
;
;------ Check if an RPL program is present at TOM and do not tromp over it
;
	push	ds
	push	bx			; pushes not required but since this
					;  happens to be a last minute change
					;  & since it is only init code.

	xor	bx, bx
	mov	ds, bx
	mov	bx, ds:[2fh*4]
	mov	ds, ds:[2fh*4+2]
	cmp	word ptr ds:[bx+3], 'PR'
	jne	SkipRPL
	cmp	byte ptr ds:[bx+5], 'L'
	jne	SkipRPL

	mov	dx, ax			; get TOM into DX
	mov	ax, (multMULT shl 8) + multMULTRPLTOM
	int	2fh			; Get new TOM from any RPL
	mov	ax, dx
SkipRPL:

	pop	bx
	pop	ds
;
;M068 - END
;


ifndef ROMDOS
	sub	ax,64			; room for fatloc segment. (1 kb buffer)
	mov	fatloc,ax		; location to read fat
endif
	sub	ax,64			;room for boot record buffer segment (1 kb)
	mov	init_bootseg,ax
	pop	ax			; get back real top of memory for
					; sysinitseg

	mov	dx,sysinitseg
	mov	ds,dx

	assume	ds:sysinitseg

; set pointer to resident device driver chain

	mov	word ptr device_list,offset res_dev_list
	mov	word ptr device_list+2,cs

	mov	memory_size,ax
	inc	cl
	mov	default_drive,cl	;save default drive spec

ifndef ROMDOS
	mov	current_dos_location,dos_load_seg ; will load MSDOS here
else
	mov	ax, cs:DosDataSg	; get location of dos (set by rom-load)
	mov	current_dos_location, ax ; set current dos location
	mov	ax, cs:BIOS_Res		; get location of BIOS code
	mov	temp_bcode_seg, ax	; set current BIOS code location

	; have to call seg_reinit (in Bios_Code) to patch up pointer
	; in Bios_Data to Bios_Code.  can't do INT 13 until this is done!
	; this call takes Bios_Code segment in CX

	call	[seg_reinit_ptr]	; call seg_reinit in Bios_Code

	; note: this call trashes ES, DI, CX
endif

; important: some old ibm hardware generates spurious int f's due to bogus
; printer cards.  we initialize this value to point to an iret only if

; 1) the original segment points to storage inside valid ram.

; 2) the original segment is 0f000:xxxx


	mov	ax,sysinitseg		; ES is sysinitseg
	mov	es,ax

	xor	ax,ax			; ax := segment for int 15
	mov	ds,ax			; DS is int vector segment

	assume	es:sysinitseg, ds:nothing

	mov	ax,word ptr ds:(0fh*4+2)

	cmp	ax,es:memory_size	; condition 1
	jna	resetintf

	cmp	ax,0f000h		; condition 2
	jne	keepintf

resetintf:
	mov	word ptr ds:[0fh*4],offset intret
	mov	word ptr ds:[0fh*4+2],cs
keepintf:

; end important

ifdef	EXTENDEDKEY

; we will check if the system has ibm extended keyboard by
; looking at a byte at 40:96.  if bit 4 is set, then extended key board
; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
; for the extended keyboard function. use cx as the temporary register.

	xor	cx,cx
	mov	ds,cx
	assume	ds:nothing
	mov	cl,ds:0496h			; get keyboard flag
	test	cl,00010000b
	jz	org_key				; orginal keyboard
	mov	byte ptr keyrd_func,10h		; extended keyboard
	mov	byte ptr keysts_func,11h	; change for extended keyboard functions
org_key:

endif

;**************************************************************
;	will initialize the number of drives
;	after the equipment call (int 11h) bits 6&7 will tell
;	the indications are as follows:
;
;	bits	7	6	drives
;		0	0	1
;		0	1	2
;		1	0	3
;		1	1	4
;**************************************************************

	push	cs
	pop	ds
	push	cs
	pop	es

	assume	ds:datagrp, es:datagrp

IFDEF	POWER		; If power management device driver is part of
			; of BIOS, initialize clock through it.  ;M074

	extrn	clock_init:far
	call	clock_init	; initialize power management clock ;M074
	mov	havecmosclock,1	; assume cmos clock

ELSE	; NOT POWER

	call	cmos_clock_read ; if cmos clock exists,
				;then set the system time according to that.
				;also, reset the cmos clock rate.
ENDIF	; NOT POWER

ifndef	ROMDOS
	mov	hdrv_pat,offset harddrv ;set up pointer to harddrv
					; in case of ROMDOS it is already
					; initialized to a ROM segment.
endif

	pop	ax		;number of floppies and fat id (pushed long ago)
	xor	ah,ah		; chuck fat id byte
;M011	mov	hardnum,al	; remember which drive is hard disk
	mov	drvmax,al	;and set initial number of drives

	mov	dsktnum,al	; and set initial number of drives

	shl	ax,1		;two bytes per address

;M011 -- begin changed section

	add	[last_dskdrv_table],ax

;M011 -- end changed section

;  The following code is to support dual hard disk controllers on
;  Compaq systems ('mode 2').
;
;  Here we attempt to setup INT 13h, mode 2
;  We must execute this code before any INT 13h to fixed disks

	push	ds
	mov	ax,0f000h		; point to ROM BIOS
	mov	ds,ax

	cmp	word ptr ds:[0ffeah],'OC'	; look for COMPAQ
	jnz	skip_mode2
	cmp	word ptr ds:[0ffech],'PM'
	jnz	skip_mode2
	cmp	word ptr ds:[0ffeeh],'QA'
	jnz	skip_mode2

	mov	ax,0E400h	;return advanced system info
	int	15h		;Q: function supported?
	jc	skip_mode2	; N: skip setting mode 2
	or	bx,00040h	; Y: enable mode 2
	mov	ax,0E480h	;    set advanced system info
	int	15h
skip_mode2:
	pop	ds

	mov	dl,80h		; tell rom bios to look at hard drives
	mov	ah,8h		; set command to get drive parameter
	int	13h		; call rom-bios to get number of drives
	jc	enddrv		;carry indicates old rom, so no hardfile

;M011 -- deleted garbage about treating first two drives as
;	special case

	mov	hnum,dl		; save number of hard drives

enddrv:

; scan the list of drives to determine their type.  we have three flavors of
; diskette drives:
;
;   48tpi drives    we do nothing special for them
;   96tpi drives    mark the fact that they have changeline support.
;   3.5"  drives    mark changeline support and small.
;
; the following code uses registers for certain values:
;
;   dl - physical drive
;   ds:di - points to current bds
;   cx - flag bits for bds
;   dh - form factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)

	xor	dl,dl			; start out with drive 0.
	push	cs
	pop	ds
	assume	ds:datagrp

	mov	eot,9
	mov	di,offset start_bds

; check if the system has no physical diskette drives.
; if it is, then we don't have to set bds tables.  but since we
; pretend that we have 2 floppies, we are going to reserve two
; bds tables for the fake drive a, and b. and set the end of link
; pointer.

;*********************************************************
;	check to see if we are faking floppy drives.  if not we don't
;	do anything special.  if we are faking floppy drives we need
;	to set aside two bdss for the two fake floppy drives.  we
;	don't need to initalise any fields though. so starting at start_bds
;	use the link field in the bds structure to go to the second bds
;	in the list and initalise it's link field to -1 to set the end of
;	the list.  then jump to the routine at dohard to allocate/initialise
;	the bds for harddrives.

	cmp	fakefloppydrv,1
	jnz	loop_drive		; system has floppy

	mov	di,word ptr ds:[di].bds_link	; di <- first bds link
	mov	di,word ptr ds:[di].bds_link	; di <- second bds link
	mov	word ptr ds:[di].bds_link,-1	; set end of link
	jmp	dohard			; allocate/initialise bds for harddrives
loop_drive:
	cmp	dl,drvmax
	jb	got_more
	jmp	done_drives
got_more:
	xor	cx,cx			; zero all flags
	mov	di,word ptr ds:[di].bds_link	; get next bds
	mov	dh,ff48tpi		; set form factor to 48 tpi
	mov	num_cyln,40		; 40 tracks per side

	push	ds
	push	di
	push	dx
	push	cx
	push	es

	mov	ah,8			;get drive parameters
	int	13h			;call rom-bios
	jc	noparmsfromrom		; got an old rom

; if cmos is bad, it gives es,ax,bx,cx,dh,di=0. cy=0.
;in this case, we are going to put bogus informations to bds table.
;we are going to set ch=39,cl=9,dh=1 to avoid divide overflow when
;they are calculated at the later time.  this is just for the diagnostic
;diskette which need msbio,msdos to boot up before it sets cmos.
;this should only happen with drive b.

	cmp	ch,0			; if ch=0, then cl,dh=0 too.
	jne	pfr_ok

	mov	ch,39			; rom gave wrong info.
	mov	cl,9			; let's default to 360k.
	mov	dh,1

pfr_ok:
	inc	dh			; make number of heads 1-based
	inc	ch			; make number of cylinders 1-based
	mov	num_heads,dh		; save parms returned by rom
	and	cl,00111111b		; extract sectors/track
	mov	sec_trk,cl
	mov	num_cyln,ch		; assume less than 256 cylinders!!

; make sure that eot contains the max number of sec/trk in system of floppies

	cmp	cl,eot			; may set carry
	jbe	eot_ok
	mov	eot,cl
eot_ok:
	pop	es
	pop	cx
	pop	dx
	pop	di
	pop	ds

; check for changeline support on drive

	mov	ah,15h 		; set command to get dasd type
	int	13h			; call rom-bios
	jc	changeline_done

	cmp	ah,02			; check for presence of changeline
	jne	changeline_done

; we have a drive with change line support.

	or	cl,fchangeline		; signal type
	mov	fhave96,1		; remember that we have 96tpi disks

; we now try to set up the form factor for the types of media that we know
; and can recognise. for the rest, we set the form factor as "other".

changeline_done:

; 40 cylinders and 9 or less sec/trk, treat as 48 tpi medium.

	cmp	num_cyln,40
	jnz	try_80

	cmp	sec_trk,9
	jbe	nextdrive

gotother:
	mov	dh,ffother		; we have a "strange" medium
	jmp	short nextdrive

; 80 cylinders and 9 sectors/track => 720 kb device
; 80 cylinders and 15 sec/trk => 96 tpi medium

try_80:
	cmp	num_cyln,80
	jnz	gotother

	mov	dh, ff288		; assume 2.88 MB drive	m037
	cmp	sec_trk, 36		; is it ?		m037
	je	nextdrive		; yeah, go update	m037
	
	cmp	sec_trk,15
	jz	got96

	cmp	sec_trk,9
	jnz	gotother

	mov	dh,ffsmall
	jmp	short nextdrive

got96:
	mov	dh,ff96tpi
	jmp	short nextdrive

; we have an old rom, so we either have a 48tpi or 96tpi drive. if the drive
; has changeline, we assume it is a 96tpi, otherwise we treat it as a 48tpi.

noparmsfromrom:
	pop	es
	pop	cx
	pop	dx
	pop	di
	pop	ds

	mov	ah,15h			; set command to get dasd type
	int	13h			; call rom-bios

	jc	nextdrive
	cmp	ah,2			; is there changeline?
	jnz	nextdrive

	or	cl,fchangeline
	mov	fhave96,1		; remember that we have 96tpi drives
	mov	num_cyln,80
	mov	dh,ff96tpi
	mov	al,15			; set eot if necessary
	cmp	al,eot
	jbe	eot_ok2
	mov	eot,al
eot_ok2:

nextdrive:
	or	cl,fi_own_physical	; set this true for all drives
	mov	bh,dl			;save int13 drive number

; we need to do special things if we have a single drive system and are setting
; up a logical drive. it needs to have the same int13 drive number as its
; counterpart, but the next drive letter. also reset ownership flag.
; we detect the presence of this situation by examining the flag single for the
; value 2.

	cmp	single,2
	jnz	not_special
	dec	bh			; int13 drive number same for logical drive
	xor	cl,fi_own_physical	; reset ownership flag for logical drive
not_special:

; the values that we put in for BDS_RBPB.BPB_HEADS and
;  BDS_RBPB.BPB_SECTORSPERTRACK will only remain if the
;  form factor is of type "ffother".

	xor	ax,ax
	mov	al,num_heads
	mov	ds:[di].BDS_RBPB.BPB_HEADS,ax
	mov	al,sec_trk
	mov	ds:[di].BDS_RBPB.BPB_SECTORSPERTRACK,ax
	mov	ds:[di].bds_flags,cx
	mov	ds:[di].bds_formfactor,dh
	mov	ds:[di].bds_drivelet,dl
	mov	ds:[di].bds_drivenum,bh
	mov	bl,byte ptr num_cyln
	mov	byte ptr ds:[di].bds_ccyln,bl	; only the l.s. byte is set here
	cmp	single,1		; special case for single drive system
	jnz	no_single

	mov	single,2		; don't lose info that we have single system
	or	cx,fi_am_mult
	or	ds:[di].bds_flags,cx
	mov	di,word ptr ds:[di].bds_link	; move to next bds in list
	inc	dl
	jmp	short nextdrive 	; use same info for bds a previous

no_single:
	inc	dl
	jmp	loop_drive

done_drives:
	mov	word ptr ds:[di].bds_link,-1	; set link to null

; set up all the hard drives in the system

dohard:

;M011 -- begin changed section

	mov	dh,hnum
	or	dh,dh			; done if no hardfiles

	jz	static_configure	; M038

	mov	dl,80h

dohard1:
	push	dx

	mov	di,end_of_bdss
	mov	bl,drvmax
	mov	bh,0			; first primary partition (or active)
	call	sethard
	jc	hardfile_err

	call	dmax_check		; M029  error if already 26 drives
	jnc	hardfile_err		; M029

;M038	lea	bx,[di].BDS_BPB
;M038	mov	si,[last_dskdrv_table]
;M038	mov	word ptr [si],bx
;M038	add	[last_dskdrv_table],2

	call	xinstall_bds		; M038 insert new bds into linked list

;M038	inc	drvmax
;M038
;M038	add	end_of_bdss,size BDS_STRUC

hardfile_err:
	pop	dx
	inc	dl			; next hard drive
	dec	dh
	jnz	dohard1


;M011 -- end changed section


; end of physical drive initialization.
; *** do not change the position of the following statement.
; *** domini routine will use [drvmax] value for the start of the logical
; *** drive number of mini disk(s).

	call	domini			;for setting up mini disks, if found


;M018 -- begin added section

	mov	dh,hnum		; we already know this is >0

	mov	dl,80h

dohardx1:
	mov	bh,1			; do all subsequent primary partitions

dohardx2:
	push	dx
	push	bx
	mov	di,end_of_bdss
	mov	bl,drvmax
	call	sethard
	jc	dohardx4		; move to next hardfile if error

	call	dmax_check		; M029 -- make sure <=26 drives
	jnc	dohardx4		; M029 -- skip if error

;M038	lea	bx,[di].BDS_BPB
;M038	mov	si,[last_dskdrv_table]
;M038	mov	word ptr [si],bx
;M038	add	[last_dskdrv_table],2

	call	xinstall_bds		; M038 insert new bds into linked list

;M038	inc	drvmax
;M038	add	end_of_bdss,size BDS_STRUC

	pop	bx			; get partition number
	pop	dx			; restore physical drive counts
	inc	bh
	jmp	dohardx2		; keep looping until we fail

dohardx4:
	pop	bx			; unjunk partition number from stack
	pop	dx			; restore physical drive counts

	inc	dl			; next hard drive
	dec	dh
	jnz	dohardx1

;M018 -- end changed section

;******************************************************************************
; if more than 2 diskette drives on the system, then it is necessary to remap
; the bds chain to adjust the logical drive num (driver letter) with greater
; than two diskette drives
;
; new scheme:	if more than 2 disktte drives, first map the bds structure
;		as usuall and then rescan the bds chain to adjust the  drive
;		letters.  to do this, scan for disk drives and assign logical
;		drive number starting from 2 and then rescan diskette drives
;		and assign next to the last logical drive number of last disk
;		drive to the 3rd and 4th diskette drives.
;******************************************************************************

	cmp	dsktnum,2	; >2 diskette drives
	jbe	no_remap	; no - no need for remapping

	call	remap		; remap bds chain to adjust driver letters

no_remap:

	assume	es:nothing

; end of drive initialization.

; we now decide, based on the configurations available so far, what
;code or data we need to keep as a stay resident code.	the following table
;shows the configurations under consideration.	they are listed in the order
;of their current position memory.
;
;configuration will be done in two ways:
;
;first, we are going to set "static configuration".  static configuration will
;consider from basic configuration to endof96tpi configuration.  the result
;of static configuration will be the address the dynamic configuration will
;use to start with.
;
;secondly, "dynamic cofiguration" will be performed.  dynamic configuration
;involves possible relocation of code or data.	dynamic configuration routine
;will take care of bdsm tables and at rom fix module thru k09 suspend/resume
;code individually.  after these operation, [dosdatasg] will be set.
;this will be the place sysinit routine will relocate msdos module for good.

;M011 -- begin changed section

;
;   1.	 basic configuration for msbio (endfloppy)
;   2.   end96tpi	; a system that supports "change line error"
;   3.	 end of bdss	; end of bdss for hard disks
;   4.	 endatrom	;some of at rom fix module.
;   5.	 endcmosclockset;supporting program for cmos clock write.
;   6.	 endk09 	;k09 cmos clock module to handle suspend/resume operation.
;


static_configure:

	mov	di,end_of_bdss
	cmp	di,offset bdss		; did we allocate any hard drive bdss?
	jnz	dynamic_configure	; that's the end, then

	mov	di,offset end96tpi	; keep everything up to end96tpi
	cmp	fhave96,0		;is change line support there?
	jnz	dynamic_configure	;yes.

	mov	di,offset endfloppy

dynamic_configure:
	push	cs
	pop	es			;es -> datagrp
	assume	es:datagrp
	cld				;clear direction

;M011 -- end changed section

	cmp	model_byte,0fch		;at ?
	jnz	checkcompaqbug		; M015
	cmp	hnum,0			;no hard file?
	jz	checkcompaqbug		; M015

	xchg	ax,di			; save allocation pointer in ax
	mov	si,0f000h
	mov	es,si			;es -> bios segment
	assume	es:nothing

	mov	si,offset datagrp:bios_date ; only patch rom with this date
	mov	di,0fff5h		;  rom bios string is at f000:fff5
	mov	cx,bdate_l
	repz	cmpsb			; check for date + zero on end
	xchg	ax,di			; restore allocation pointer

;	M015 -- begin changes

	jnz	checkcompaqbug

;	install at rom fix

	mov	cx,offset datagrp:endatrom
	mov	si,offset datagrp:ibm_disk_io
	jmp	short install_int13_patch

;	M065 -- begin changes
;
;	On certain systems with Western Digital disk controllers, the
;	following detection scheme caused an unpredictable and serious
;	failure.  In particular, they've implemented a nonstandard
;	Int13(ah=16h) which reconfigures the hard drive, depending on
;	what happens to be at es:[bx] and other memory locations indexed
;	off of it.
;
;	Compaq was unable to tell us exactly which kind of systems have
;	the bug, except that they guarantee that the bug was fixed in
;	ROM BIOSs dated 08/04/86 and later.  We'll check for the COMPAQ
;	string, and then look for date codes before 08/04/86 to decide
;	when to install the hook.

checkcompaqbug:
	mov	ax,0f000h		; point to ROM BIOS
	mov	es,ax

	cmp	es:word ptr [0ffeah],'OC'	; look for COMPAQ
	jnz	not_compaq_patch
	cmp	es:word ptr [0ffech],'PM'
	jnz	not_compaq_patch
	cmp	es:word ptr [0ffeeh],'QA'
	jnz	not_compaq_patch

;	We're running on a COMPAQ.  Now look at the date code.

	mov	ax,es:word ptr [0fffbh]	; get year
	xchg	ah,al
	cmp	ax,'86'			; is it 86?
	ja	not_compaq_patch
	jb	do_compaq_patch

	mov	ax,es:word ptr [0fff5h]	; get month
	xchg	ah,al
	cmp	ax,'08'			; is it 08?
	ja	not_compaq_patch
	jb	do_compaq_patch

	mov	ax,es:word ptr [0fff8h]	; get day
	xchg	ah,al
	cmp	ax,'04'			; is it 04?
	jae	not_compaq_patch	; 08/04/86 or later needs no patch

do_compaq_patch:

;	M065 -- end additions

;M065	
;M065	;	on some Compaq '286 systems there's a ROM BIOS bug.  When an
;M065	;	  int13 is executed with ah>15h and dl>=80h, the byte at
;M065	;	  DS:74h is trashed.  If we detect that bug in the ROM, insert
;M065	;	  an int13 hook which always points ds->ROM DATA AREA on those
;M065	;	  calls.
;M065	
;M065	checkcompaqbug:
;M065	
;M065		push	ds
;M065		mov	ds,init_bootseg		; point to our scratch buffer
;M065		assume	ds:nothing
;M065	
;M065		mov	ds:byte ptr 74h,0ffh	; stick a known value at 74h
;M065		mov	ah,16h			; check disk change
;M065		mov	dl,80h			; on any hard disk
;M065	
;M065	;	we can't just do a straight int 13 here or the damn bug will
;M065	;	 trash something in our Bios Data, since our int13 hook
;M065	;	 has ds->bios_data when it calls the ROM.
;M065	
;M065		xor	si, si			; AT&T 6300 WGS goofs it up
;M065						;  if si != 0			M021
;M065	
;M065		pushf				; simulate int 13
;M065		call	orig13			; call directly into the ROM
;M065	
;M065		cmp	ds:byte ptr 74h,0ffh	; if it changed in error, COMPAQ bug
;M065		pop	ds
;M065		assume	ds:datagrp
;M065		jz	checkcmosclock		; brif no ROM BIOS bug
;M065	

;	insert patch for COMPAQ rom

	mov	cx,offset datagrp:end_compaq_i13hook
	mov	si,offset datagrp:compaq_disk_io

install_int13_patch:
	push	cs
	pop	es			;set es to datagrp seg

	mov	word ptr orig13,di
	mov	word ptr orig13+2,cs	;set new rom bios int 13 vector
	sub	cx,si			;size of rom fix module
	rep	movsb			;relocate it

;	M015 -- end changes

not_compaq_patch:			; M065
checkcmosclock:
	push	cs
	pop	es
	assume	es:datagrp
	cmp	havecmosclock,1 		;cmos clock exists?
	jne	checkk09
	mov	word ptr daycnttoday,di		;set the address for mschar
	mov	cx,offset enddaycnttoday - offset daycnt_to_day
	mov	si,offset datagrp:daycnt_to_day
	rep	movsb

	mov	word ptr bintobcd,di		;set the address for msclock
;						; let original segment stay
	mov	cx,offset endcmosclockset - offset bin_to_bcd
	mov	si,offset datagrp:bin_to_bcd
	rep	movsb


checkk09:
	push	di			;save di??

;M055 - begin
	mov	ax,4101h		; wait for bh=es:[di]
	mov	bl,1			; wait for 1 clock tick
	mov	bh,byte ptr es:[di]
	stc				; Assume we will fail
	int	15h
;M055 - end

	pop	di
	jc	configdone

	mov	fhavek09,1		; remember we have a k09 type

IFNDEF	POWER				; M083
	push	ds			; preserve pointer to datagrp
	xor	ax,ax
	mov	ds,ax			; point DS to interrupt vectors
	assume	ds:nothing
	mov	word ptr ds:[4 * 6ch],di ; new int 6ch handler
	mov	ds:[4 * 6ch +2],cs
	pop	ds			; restore pointer to datagrp
	assume	ds:datagrp

	mov	si,offset datagrp:int6c
	mov	cx,(offset endk09 - offset int6c) ; size of k09 routine
	rep	movsb

;     set up config stuff for sysinit

ENDIF ; NOT POWER			; M083

configdone:				;di is final ending address of msbio.

IFDEF   ROMDOS
IFDEF   ROMDRIVE
;
;------ If ROMDRIVE is built in, check whether ROMDRIVE should be the default
;	drive. If so update 'default_drive' to the ROMDRIVE so that sysinit
;	will set default drive to ROMDRIVE
;
	mov	ax, sysinitseg
	mov	ds, ax
	assume	ds:sysinitseg
	mov	ax, BootFlags
	and	ax, BF_DefaultMask
	cmp	ax, BF_DefROM
	jne	NotRomDrive
	cmp	drvmax, 26
	jae	NotRomDrive
	mov	al, drvmax
	inc	al
	mov	default_drive, al
NotRomDrive:

ENDIF   ; ROMDRIVE
ENDIF   ; ROMDOS


	push	cs
	pop	ds
	assume	ds:datagrp

	add	di,15			; round to paragraph
	shr	di,1
	shr	di,1
	shr	di,1
	shr	di,1
	add	di,datagrp
	mov	[dosdatasg],di		; where the dos data segment will be

	mov	ax,drvfat		; get drive and fat id
	mov	bp,offset setdrive
	push	cs			; simulate far call
	call	call_bios_code		; get bds for drive

	mov	bp,offset getbp		; ensure valid bpb is present
	push	cs			; simulate far call
	call	call_bios_code

;	resort to funky old segment definitions for now

	push	es			; copy bds to ds:di
	pop	ds
	assume	ds:nothing

;	the following read of es:0000 was spurious anyway.  Should look into it.

;	hmmmmmm.  j.k. took out a call to getfat right here a while
;	  back.  Apparently it was what actually setup es: for the following
;	cas----

	xor	di,di
	mov	al,es:[di]		;get fat id byte
	mov	byte ptr drvfat+1,al	;save fat byte
	mov	ax,drvfat

;	cas -- why do a SECOND setdrive here????

	mapnew
	mov	bp,offset setdrive
	push	cs			; simulate far call
	call	call_bios_code		;get correct bds for this drive
	unmapnew


; Now we load in the MSDOS.SYS file, if this is not ROMDOS
ifndef ROMDOS
	
	mov	bx,ds:[di].BDS_BPB.BPB_BYTESPERSECTOR
	mov	cs:md_sectorsize,bx	;used by get_fat_sector proc.
	mov	bl,ds:[di].bds_fatsiz		; get size of fat on media
	mov	fbigfat,bl
	mov	cl,ds:[di].BDS_BPB.BPB_SECTORSPERCLUSTER	;get sectors/cluster

;	32 bit calculation

	mov	ax,word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS	;get number of hidden sectors (low)
	sub	bios_l,ax		;subtract hidden sectors since we
					; need a logical sector number that will
					; be used by getclus(diskrd procedure)
	mov	ax,word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS+2	;subtract upper 16 bits of sector num
	sbb	bios_h,ax

	xor	ch,ch			;cx = sectors/cluster

;	the boot program has left the directory at 0:500

	push	ds
	xor	di,di
	mov	ds,di			; es:di points to load location
	mov	bx,ds:word ptr [53ah]	;   clus=*53a;
	pop	ds

loadit:
	mov	ax,sysinitseg
	mov	es,ax
	assume	es:sysinitseg
	mov	es,current_dos_location
	assume	es:nothing

	call	getclus 		; read cluster at ES:DI (DI is updated)

iseof:
	test	fbigfat,fbig
	jnz	eofbig
	cmp	bx,0ff7h
	jmp	short iseofx
eofbig:
	cmp	bx,0fff7h
iseofx:
	jb	loadit			; keep loading until cluster = eof

endif	; end of non-ROMDOS conditional

	call	setdrvparms

	jmp	sysinit

init	endp

;==========================================================================
;
; Following are subroutines to support resident device driver initialization
;
;M011 -- note:  deleted setup_bdsms and reset_bdsms here

;

;	M035 -- begin changed section

;******************************************************************************
; module name: remap
;
; descriptive name: all the code for himem that could be separated from msbio
;
; function:  remap the bds chain to adjusted logical drive numbers (drive
;	     letters if more than two diskette drives on the system.
;
;     scheme:  if more than 2 disktte drives, first map the bds structure
;	       as usual and then rescan the bds chain to adjust the  drive
;	       letters.  to do this, scan for disk drives and assign logica
;	       drive number starting from 2 and then rescan diskette drives
;	       and assign next to the last logical drive number of last disk
;	       drive to the 3rd and 4th diskette drives.

; input:       none
; exit:	drive letters have been remapped in bds chain
; exit error:	none
; called from: msinit
;
; notes:  this function  will be called only if more than 2 diskettes are
;	  found in the system
;	  this function assumes that there are no more than 26 drives assigned
;	    this is guaranteed by the code that creates bdss for partitions
;	  this function assumes that the first entries in the chain are
;	   floppy drives, and all the rest are hard drives
;	  will alter the boot drive if necessary to reflect remapping
;
;******************************************************************************

remap	proc	near

	mov	di,word ptr start_bds	   ; get first bds

; search for 1st fixed disk physical drive num

drive_loop:
	cmp	ds:[di].bds_drivenum,80h ; first hard disk??
	je	fdrv_found		 ; yes - continue

	mov	di,word ptr ds:[di].bds_link ; get next bds, assume segment
	cmp	di,-1			; last bds?
	jnz	drive_loop		; loop if not

	jmp	short rmap_exit		; yes- no hard drive on system

;------------------------------------------------------------------------------
;first disk drive bds, now change the logical drive num to 2 and the subsequent
;logical drive nums to 3, 4, 5 etc.
;------------------------------------------------------------------------------

fdrv_found:
	mov	al,2			; start with logical drv num=2
fdrv_loop:
	mov	ds:[di].bds_drivelet,al ; found ??
	mov	di,word ptr ds:[di].bds_link	; ds:di--> next bds
	inc	al			; set num for next drive

	cmp	di,-1			; last hard drive ??
	jne	fdrv_loop		; no - assign more disk drives

;------------------------------------------------------------------------------
; now, rescan and find bds of 3rd floppy drive and assign next drive letter
; in al to 3rd. if the current drive letter is past z, then do not allocate
; any more.
;------------------------------------------------------------------------------


	mov   di,word ptr start_bds	   ; get first bds
	mov   di,word ptr ds:[di].bds_link ; ds:di-->bds2
	mov   ah,dsktnum		   ; get number of floppies to remap
	sub   ah,2			   ; adjust for a: & b:

remap_loop1:
	mov   di,word ptr ds:[di].bds_link ; ds:di -> bds to change
	mov   ds:[di].bds_drivelet,al      ; set new num to next floppy

	inc   al			; new number for next floppy
	dec   ah			; count down extra floppies
	jnz   remap_loop1		; and loop until we got 'em all

;	now we've got to adjust the boot drive if we reassigned it

	mov	al,byte ptr drvfat
	cmp	al,2			; is it a: or b:
	jb	rmap_exit

	sub	al,dsktnum		; is it one of the other floppies?
	jb	remap_boot_flop		;  brif so

;	we've got to remap the boot hard drive
;	  subtract the number of EXTRA floppies from it

	add	al,2			; bootdrv -= (dsktnum-2)
	jmp	short remap_change_boot_drv

;	we've got to remap the boot floppy.
;	  add the number of hard drive partitions to it

remap_boot_flop:
	add	al,drvmax		; bootdrv += (drvmax-dsktnum)

remap_change_boot_drv:
	mov	byte ptr drvfat,al	; alter msdos.sys load drive
	inc	al

	push	ds
	mov	di,sysinitseg
	mov	ds,di
	assume	ds:sysinitseg
	mov	default_drive,al	; pass it to sysinit as well
	pop	ds
	assume	ds:datagrp

rmap_exit:
	ret

remap	endp

;	M035 -- end changes


;**************************
;
; getboot - get the boot sector for a hard disk
;
; Reads the boot sector from a specified drive into a buffer at the top
; of memory.
;
; dl = int13 drive number to read boot sector for

getboot proc	near
	mov	ax,cs:init_bootseg	; prepare to load es
	mov	es,ax			; load es segment register
	assume	es:nothing
	mov	bx,bootbias		; load bx, es:bx is where sector goes
	mov	ax,0201h		; command to read & num sec. to 1
	xor	dh,dh			; head number zero
	mov	cx,0001h		; cylinder zero and sector one
	int	13h			; call rom bios
	jc	erret

	cmp	word ptr es:[bootbias+1feh],0aa55h ; dave litton magic word?
	jz	norm_ret
erret:
	stc
norm_ret:
	ret
getboot endp


;***************************************************************************
;   sethard - generate bpb for a variable sized hard file.  ibm has a
;   partitioned hard file; we must read physical sector 0 to determine where
;   our own logical sectors start.  we also read in our boot sector to
;   determine version number
;
;   inputs:	dl is rom drive number (80...)  M018
;		bh is partition number (0....)  M018
;		ds:di points to bds
;   outputs:	carry clear -> bpb is filled in
;		carry set   -> bpb is left uninitialized due to error
;	trashes (at least) si, cx
;	MUST PRESERVE ES:!!!!		; M011
;***************************************************************************


sethard proc	near
	assume	ds:datagrp,es:nothing

	push	di
	push	bx
	push	ds
	push	es		; M011
	mov	ds:[di].bds_drivelet,bl
	mov	ds:[di].bds_drivenum,dl
	or	ds:byte ptr [di].bds_flags,fnon_removable ; M011
	mov	ds:[di].bds_formfactor,ffhardfile
	mov	fbigfat,0		; assume 12 bit fat
	mov	dh,bh			; M018 - partition number
	push	dx
	mov	ah,8			; set command to get drive parameters
	int	13h			; call rom-bios disk routine

; dh is number of heads-1
; dl is number of hard disks attached
; low 6 bits of cl is sectors/track
; high 2 bits of cl with ch are max # of cylinders

	inc	dh			; get number of heads
	mov	byte ptr ds:[di].BDS_BPB.BPB_HEADS,dh
	pop	dx

	jc	setret			; error if no hard disk

	and	cl,3fh			; extract number of sectors/track
	mov	byte ptr ds:[di].BDS_BPB.BPB_SECTORSPERTRACK,cl
	push	dx			; M018 -- save partition number
	call	getboot 		;   if (getboot ())
	assume	es:nothing
	pop	dx			; M018 -- restore partition number
	jc	setret			;	return -1;
	mov	bx,1c2h+bootbias	;   p = &boot[0x1c2];

;	M018 -- begin changed section

;	The first 'active' partition is 00, the second is 01....
;	  then the remainder of the 'primary' but non-active partitions

act_part:
	test	BYTE PTR es:[bx - 4],80h  ;AN016;is the partition active?
	jz	not_act
	cmp	byte ptr es:[bx],1	; reject if partitiontype != 1, 4 or 6
	jz	got_good_act
	cmp	byte ptr es:[bx],4
	jz	got_good_act
	cmp	byte ptr es:[bx],6
	jnz	not_act			; reject!
got_good_act:
	or	dh,dh			; is this our target partition #?
	jz	set2			; WE GOT THE ONE WANTED!!
	dec	dh			; count down
not_act:
	add	bx,16			;AN016;next entry
	cmp	bx,202H + BOOTBIAS	;AN016;last entry done?
	jnz	act_part		;AN016;no,process next entry

;	Now scan the non-active partitions

	mov	bx,1c2h + BOOTBIAS	;AN016;restore original value of bx

get_primary:
	test	byte ptr es:[bx - 4],80h ; we've already scanned
	jnz	not_prim		; the ACTIVE ones
	cmp	byte ptr es:[bx],1	; see if partitiontype == 1, 4 or 6
	jz	got_prim
	cmp	byte ptr es:[bx],4
	jz	got_prim
	cmp	byte ptr es:[bx],6
	jnz	not_prim

got_prim:
	or	dh,dh			; is this our target partition?
	jz	set2
	dec	dh

not_prim:
	add	bx,16
	cmp	bx,202h+bootbias
	jnz	get_primary		; loop till we've gone through table

setret:
	stc				; error return
	jmp	ret_hard

;	M018 -- this concludes the changes.

;  until we get the real logical boot record and get the bpb,
;  BDS_BPB.BPB_BIGTOTALSECTORS will be used instead of BDS_BPB.BPB_TOTALSECTORS for the
;  convenience of the computation.
;
;  at the end of this procedure, if a bpb information is gotten from
;  the valid boot record, then we are going to use those bpb information
;  without change.
;
;  otherwise, if (hidden sectors + total sectors) <= a word, then
;  we will move BDS_BPB.BPB_BIGTOTALSECTORS (low) to BDS_BPB.BPB_TOTALSECTORS and zero out
;  BDS_BPB.BPB_BIGTOTALSECTORS entry to make
;  it a conventional bpb format.

set2:
	mov	cs:rom_drv_num, dl	; save the rom bios drive number we are handling now.

	mov	ax,word ptr es:[bx+4]	;hidden sectors
	mov	dx,word ptr es:[bx+6]

;  decrement the sector count by 1 to make it zero based. exactly 64k
;   sectors should be allowed

	sub	ax,1
	sbb	dx,0

	add	ax,word ptr es:[bx+8]	;sectors in partition
	adc	dx,word ptr es:[bx+10]
	jnc	okdrive
	or	fbigfat,ftoobig
okdrive:
	mov	ax,word ptr es:[bx+4]

	mov	word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS,ax	;   BPB_HIDDENSECTORS = p->partitionbegin;
	mov	ax,word ptr es:[bx+6]
	mov	word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS+2,ax

	mov	dx,word ptr es:[bx+10]	; # of sectors (high)
	mov	ax,word ptr es:[bx+8]	;# of sectors (low)
	mov	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2,dx
	mov	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS,ax ;   bpb->maxsec = p->partitionlength;
	cmp	dx,0
	ja	okdrive_cont

	cmp	ax,64			;   if (p->partitionlength < 64)
	jb	setret			;	return -1;

okdrive_cont:
	mov	dx,word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS+2
	mov	ax,word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS	; boot sector number - for mini disk,;j.k.
	xor	bx,bx			;usually equal to the # of sec/trk.  ;j.k.
	mov	bl,byte ptr ds:[di].BDS_BPB.BPB_SECTORSPERTRACK
	push	ax
	mov	ax,dx
	xor	dx,dx
	div	bx
	mov	cs:[temp_h],ax
	pop	ax
	div	bx			;(sectors)dx;ax / (BDS_BPB.BPB_SECTORSPERTRACK)bx =(track) temp_h;ax + (sector)dx
	mov	cl,dl			; cl is sector number;j.k.assume sector number < 255.
	inc	cl			; sectors are 1 based

	xor	bx,bx
	mov	bl,byte ptr ds:[di].BDS_BPB.BPB_HEADS
	push	ax
	xor	dx,dx
	mov	ax,cs:[temp_h]
	div	bx
	mov	cs:[temp_h],ax
	pop	ax
	div	bx			; dl is head, ax is cylinder
	cmp	cs:[temp_h],0
	ja	setret_brdg		; exceeds the limit of int 13h
	cmp	ax,1024
	ja	setret_brdg		; exceeds the limit of int 13h

; dl is head.
; ax is cylinder
; cl is sector number (assume less than 2**6 = 64 for int 13h)

;*** for mini disks ***
	cmp	ds:[di].bdsm_ismini,1 		;check for mini disk
	jnz	oknotmini		;not mini disk.
	add	ax,ds:[di].bdsm_hidden_trks	;set the physical track number
oknotmini:
;*** end of added logic for mini disk

	ror	ah,1			; move high two bits of cyl to high
	ror	ah,1			; two bits of upper byte
	and	ah,0c0h 		; turn off remainder of bits
	or	cl,ah			; move two bits to correct spot
	mov	ch,al			; ch is cylinder

; cl is sector + 2 high bits of cylinder
; ch is low 8 bits of cylinder
; dl is head
; rom_drv_num is drive

	mov	dh,dl			; dh is head
	mov	dl,cs:rom_drv_num	; set the drive number

; cl is sector + 2 high bits of cylinder
; ch is low 8 bits of cylinder
; dh is head
; dl is drive

; for convenience, we are going to read the logical boot sector
;   into cs:disksector area.

;  read in boot sector using bios disk interrupt.  the buffer where it
;  is to be read in is cs:disksector.

	push	cs
	pop	es
	mov	bx,offset disksector
	mov	ax,201h		; read, one sector
	int	13h

; cs:disksec contains the boot sector.	in theory, (ha ha) the bpb in this thing
; is correct.  we can, therefore, suck out all the relevant statistics on the
; media if we recognize the version number.

	mov	bx,offset disksector

	push	bx			; save changed regs
	push	ax

	cmp	byte ptr cs:[bx],0e9h	; is it a near jump?
	je	check_1_ok		; no,
	cmp	byte ptr cs:[bx],0ebh	;   is it a short jump?
	jne	invalid_boot_record	;   no, invalid boot record
	cmp	byte ptr cs:[bx+2],090h ;   yes, is the next one a nop?
	jne	invalid_boot_record	;     no, invalid boot record

check_1_ok:				; yes, jmup instruction ok.
					; now check some fields in
					;  the boot record bpb
	mov	bx,offset disksector.EXT_BOOT_BPB ; point to the bpb
					;  in the boot record

					; get the mediadescriptor byte
	mov	al,byte ptr cs:[bx].bpb_mediadescriptor

	and	al,0f0h 		; mask off low nibble
	cmp	al,0f0h 		; is high nibble = 0fh?
	jne	invalid_boot_record	;   no, invalid boot record

	cmp	cs:[bx].bpb_bytespersector,512	; M042
	jnz	invalid_boot_record	; M042 invalidate non 512 byte sectors

check_2_ok:				; yes, mediadescriptor ok.
					; now make sure that
					;     the sectorspercluster
					;	is a power of 2

					; get the sectorspercluster

	mov	al,byte ptr cs:[bx].bpb_sectorspercluster

	or	al,al			; is it zero?
	jz	invalid_boot_record	;   yes, invalid boot record

;	M032 begin

ck_power_of_two:
	shr	al,1			; shift until first bit emerges
	jnc	ck_power_of_two

	jz	valid_boot_record	; if no bits left, then proceed ok

;	M032 end

invalid_boot_record:			; for invalid boot record
	pop	ax			; restore registers
	pop	bx			;
	jmp	unknown 		; jump to invalid boot record
					; unformatted or illegal media.

valid_boot_record:			; for valid boot record
	pop	ax			; restore registers
	pop	bx			;

; signature found.  Now check version.

	cmp	word ptr cs:[bx+8],"." shl 8 + "2"
	jnz	try5
	cmp	byte ptr cs:[bx+10],"0"
	jnz	try5

	jmp	short copybpb

setret_brdg:
	jmp	setret

;M042 unknownj:
;M042	jmp	unknown 		;unformatted or illegal media.

unknown3_0_j:				;legally formatted media,
	jmp	unknown3_0		; although, content might be bad.

try5:
	call	cover_fdisk_bug

; see if it is an os2 signature

	cmp	word ptr cs:[bx+8],'.' shl 8 + '0'	; M053
	jne	no_os2					; M053
	mov	al,byte ptr cs:[bx+7]			; M053
	sub	al,'1'					; M053
	and	al,0feh					; M053
	jz	copybpb		; accept either '1' or '2' ; M053

; M053	cmp	word ptr cs:[bx+7],"0" shl 8 + "1"
; M053	jne	no_os2
; M053	cmp	byte ptr cs:[bx+9],"."
; M053	je	copybpb
	jmp	unknown

; no os2 signature, this is to check for real dos versions

no_os2:
	cmp	word ptr cs:[bx+8],"." shl 8 + "3"
	jb	unknown3_0_j		; must be 2.1 boot record. do not trust it, but still legal.
	jnz	copybpb 		; honor os2 boot record, or dos 4.0 version
	cmp	byte ptr cs:[bx+10],"1"	;do not trust 3.0 boot record. but still legal
	jb	unknown3_0_j		; if version >= 3.1, then o.k.

copybpb:

;	we have a valid boot sector. use the bpb in it to build the
;	bpb in bios. it is assumed that only
;		BDS_BPB.BPB_SECTORSPERCLUSTER
;		BDS_BPB.BPB_ROOTENTRIES, and
;		BDS_BPB.BPB_SECTORSPERFAT
;	need to be set (all other values in already). fbigfat
;	is also set.

;if it is non fat based system, then just copy the bpb from the boot sector
;into the bpb in bds table, and also set the boot serial number, volume id,
;and system id according to the boot record.
;for the non_fat system, don't need to set the other value. so just
;do goodret.

	cmp	cs:disksector.EXT_BOOT_SIG, ext_boot_signature
	jne	copybpb_fat		; conventional fat system
	cmp	cs:disksector.EXT_BOOT_BPB.BPB_NUMBEROFFATS,0	; if (# of fat <> 0) then
	jne	copybpb_fat		;   a fat system.

; non fat based media.

	push	di			; sav reg.
	push	ds

	push	ds
	pop	es			; now es:di -> bds
	push	cs
	pop	ds			; ds = cs

	mov	si,offset disksector.EXT_BOOT_BPB ; ds:si -> bpb in boot
	add	di,BDS_BPB.BPB_BYTESPERSECTOR	; es:di -> bpb in bds

;	M034 -- begin additions

;       just for completeness, we'll make sure that total_sectors and
;         big_total_sectors aren't both zero.  I've seen examples of
;         this on DOS 3.30 boot records.  I don't know exactly how it
;         got that way.  If it occurs, then use the values from the
;         partition table.

        cmp     cs:[si].BPB_TOTALSECTORS,0      ; is total_sectors nonzero?
        jnz     already_nonz                    ; done if so, use it
        cmp     cs:[si].BPB_BIGTOTALSECTORS,0   ; how 'bout big_total?
        jnz     already_nonz                    ; we're okay if any are != 0
        cmp     cs:[si].BPB_BIGTOTALSECTORS+2,0
        jnz     already_nonz

;       now let's copy the values from the partition table (now in the BDS)
;         into the BPB in the boot sector buffer, before they get copied
;         back.

        mov     ax,ds:[di.BPB_TOTALSECTORS]     ; get value from part table
        mov     cs:[si].BPB_TOTALSECTORS,ax     ; store it into bpb buffer
        mov     ax,ds:[di.BPB_BIGTOTALSECTORS]  ; get value from part table
        mov     cs:[si].BPB_BIGTOTALSECTORS,ax  ; store it into bpb buffer
        mov     ax,ds:[di.BPB_BIGTOTALSECTORS+2] ; get value from part table
        mov     cs:[si].BPB_BIGTOTALSECTORS+2,ax ; store it into bpb buffer

already_nonz:

;	end M034 additions

	mov	cx,size A_BPB - 6	; ****** Use SMALL version!

	rep	movsb

	pop	ds			; restore reg.
	pop	di
	mapnew
	mov	bp,offset mov_media_ids	; set volume id, systemid, serial.
	push	cs			; simulate far call
	call	call_bios_code
	unmapnew
	jmp	goodret

copybpb_fat:				;  fat system

;	M034 -- begin changes


;       ****** cas ---
;          IBM DOS 3.30 doesn't seem to mind that the TOTAL_SECTORS and
;          BIG_TOTAL_SECTORS field in the boot sector are 0000.  This
;          happens with some frequency -- perhaps through some OS/2 setup
;          program.  We haven't actually been COPYING the TOTAL_SECTORS
;          from the boot sector into the DPB anyway, we've just been using
;          it for calculating the fat size.  Pretty scary, huh?  For now,
;          we'll go ahead and copy it into the DPB, except in the case
;          that it equals zero, in which case we just use the values in
;          the DPB from the partition table.

	mov	si,offset disksector.EXT_BOOT_BPB ; M040  cs:si -> bpb in boot
	xor	dx,dx
        mov     ax,cs:[si.BPB_TOTALSECTORS]     ; get totsec from boot sec
        or      ax,ax
        jnz     copy_totsec                     ; if non zero, use that

        mov     ax,cs:[si.BPB_BIGTOTALSECTORS]  ; get the big version
        mov     dx,cs:[si.BPB_BIGTOTALSECTORS+2]
        mov     cx,dx
        or      cx,ax                           ; see if it is a big zero
        jz      totsec_already_set              ; screw it.  it was bogus.

copy_totsec:
	mov	ds:[di.BDS_BPB.BPB_BIGTOTALSECTORS],ax   ; M040 make DPB match
	mov	ds:[di.BDS_BPB.BPB_BIGTOTALSECTORS+2],dx ; M040 boot sec

totsec_already_set:

;	M034 -- end changes

;M034	xor	dx,dx
;M040	mov	si,offset disksector.EXT_BOOT_BPB ;  cs:bx -> bpb in boot
;M034	mov	ax,cs:[si.BPB_TOTALSECTORS]	;  total sectors
;M034	or	ax,ax			; double word sector number?
;M034	jnz	fat_big_small		;  no. conventional bpb.

;M034	mov	ax,word ptr cs:[si.BPB_BIGTOTALSECTORS] ; use double word
;M034	mov	dx,word ptr cs:[si.BPB_BIGTOTALSECTORS+2]
	mov	ax,word ptr ds:[di.BDS_BPB.BPB_BIGTOTALSECTORS]
	mov	dx,word ptr ds:[di.BDS_BPB.BPB_BIGTOTALSECTORS+2]


fat_big_small:				 ; determine fat entry size.

;at this moment dx;ax = total sector number

;
;Do not assume 1 reserved sector. Update the reserved sector field in BDS 
;from the BPB on the disk
;
	mov	bx,cs:[SI.BPB_RESERVEDSECTORS]		;AN017;get #reserved_sectors from BPB
	mov	ds:[di].BDS_BPB.BPB_RESERVEDSECTORS,bx	;AN017;update BDS field
	sub	ax,bx					;AN017;
	sbb	dx,0					;AN017;update the count

;	sub	ax,1					;AN017; subtrack # reserved (always 1)
;	sbb	dx,0					;AN017;

	mov	bx,cs:[si.BPB_SECTORSPERFAT]	;  bx = sectors/fat
	mov	ds:[di].BDS_BPB.BPB_SECTORSPERFAT,bx 	;  set in bds bpb
	shl	bx,1			; always 2 fats
	sub	ax,bx			; sub # fat sectors
	sbb	dx,0
	mov	bx,cs:[si.BPB_ROOTENTRIES]	;  # root entries
	mov	ds:[di].BDS_BPB.BPB_ROOTENTRIES,bx		;  set in bds bpb

	mov	cl,4
	shr	bx,cl			;  div by 16 ents/sector
	sub	ax,bx			;  sub # dir sectors
	sbb	dx,0
					; dx;ax now contains the # of data sectors
	xor	cx,cx
	mov	cl,cs:[si.BPB_SECTORSPERCLUSTER]	; sectors per cluster
	mov	ds:[di].BDS_BPB.BPB_SECTORSPERCLUSTER,cl	; set in bios bpb
	push	ax
	mov	ax,dx
	xor	dx,dx
	div	cx			; cx = sectors per cluster
	mov	cs:[temp_h],ax
	pop	ax
	div	cx			;  [temp_h];ax now contains the # clusters.
	cmp	cs:[temp_h],0
	ja	toobig_ret		;  too big cluster number

	cmp	ax,4096-10		; is this 16-bit fat?
	jb	copymediaid		; no, small fat
	or	fbigfat,fbig		; 16 bit fat

copymediaid:
	mapnew
	mov	bp,offset mov_media_ids	; copy filesys_id, volume label,
	push	cs			; simulate far call
	call	call_bios_code
	unmapnew
					;and volume serial to bds table, if extended
					;boot record.
	jmp	massage_bpb		; now final check for bpb info. and return.

toobig_ret:
	or	cs:fbigfat,ftoobig
	jmp	goodret 		; still drive letter is assigned
					; but useless. to big for
					; current pc dos fat file system
unknown:
	or	ds:[di].bds_flags, unformatted_media ; M042
					; Set unformatted media flag.

;  the boot signature may not be recognizable,
;     but we should try and read it anyway.

unknown3_0:				;skip setting unformatted_media bit
	mov	dx,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2
	mov	ax,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS
	mov	si,offset datagrp:disktable2
scan:

	cmp	dx,word ptr cs:[si]
	jb	gotparm
	ja	scan_next
	cmp	ax,word ptr cs:[si+2]
	jbe	gotparm
scan_next:
	add	si,5 * 2
	jmp	scan			;  covers upto 512 mb media
gotparm:
	mov	cl,byte ptr [si+8]	;  fat size for fbigfat flag
	or	fbigfat,cl
	mov	cx,word ptr cs:[si+4]
	mov	dx,word ptr cs:[si+6]

;	dx = number of dir entries,
;	ch = number of sectors per cluster
;	cl = log base 2 of ch

;	now calculate size of fat table


	mov	ds:[di].BDS_BPB.BPB_ROOTENTRIES,dx	;save number of dir entries

;now, cx = BDS_BPB.BPB_SECTORSPERCLUSTER|clusshift
;    ds:[di].BDS_BPB.BPB_ROOTENTRIES = number of directory entries.

	mov	dx,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2
	mov	ax,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS
	mov	byte ptr ds:[di].BDS_BPB.BPB_SECTORSPERCLUSTER,ch ;save sectors per cluster
	test	fbigfat,fbig		;   if (fbigfat)
	jnz	dobig			;	goto dobig;

;   we don't need to change "small fat" logic since it is gauranteed
;   that double word total sector will not use 12 bit fat (unless
;   it's sectors/cluster >= 16 which will never be in this case.)
;   so in this case we assume dx = 0 !!!.

	xor	bx,bx
	mov	bl,ch
	dec	bx
	add	bx,ax			; dx=0
	shr	bx,cl			; bx = 1+(bpb->maxsec+BDS_BPB.BPB_SECTORSPERCLUSTER-1)/
	inc	bx			; BDS_BPB.BPB_SECTORSPERCLUSTER
	and	bl,11111110b		; bx &= ~1; (=number of clusters)
	mov	si,bx
	shr	bx,1
	add	bx,si
	add	bx,511			; bx += 511 + bx/2
	shr	bh,1			; bh >>= 1; (=bx/512)
	mov	byte ptr ds:[di].BDS_BPB.BPB_SECTORSPERFAT,bh ;save number of fat sectors
	jmp	short massage_bpb

dobig:
; for bigfat we do need to extend this logic to 32 bit sector calculation.

	mov	cl,4			; 16 (2^4) directory entries per sector
	push	dx			; save total sectors (high)
	mov	dx,ds:[di].BDS_BPB.BPB_ROOTENTRIES
	shr	dx,cl			; cseBDS_BPB.BPB_ROOTENTRIES = BDS_BPB.BPB_ROOTENTRIES / 16;
	sub	ax,dx			; dx;ax -= cseBDS_BPB.BPB_ROOTENTRIES; dx;ax -= csecreserved;
	pop	dx
	sbb	dx,0
	sub	ax,1			; dx;ax = t - r - d
	sbb	dx,0			;
	mov	bl,2
	mov	bh,ds:[di].BDS_BPB.BPB_SECTORSPERCLUSTER	; bx = 256 * BDS_BPB.BPB_SECTORSPERCLUSTER + 2

;	i don't understand why to add bx here!!!

	add	ax,bx			; ax = t-r-d+256*spc+2
	adc	dx,0
	sub	ax,1			; ax = t-r-d+256*spc+1
	sbb	dx,0

;     assuming dx in the table will never be bigger than bx.

	div	bx			; BDS_BPB.BPB_SECTORSPERFAT = ceil((total-dir-res)/
					;		 (256*BDS_BPB.BPB_SECTORSPERCLUSTER+2));
	mov	ds:[di].BDS_BPB.BPB_SECTORSPERFAT,ax ; number of fat sectors

; now, set the default filesys_id, volume label, serial number

	mov	bl,fbigfat
	mov	ds:[di].bds_fatsiz,bl		; set size of fat on media

	push	ds			; save bds pointer
	push	ds
	pop	es			; pass to subroutine in es
	push	cs			; set ds to datagrp
	pop	ds
	mov	bp,offset clear_ids
	push	cs			; simulate far call
	call	call_bios_code
	pop	ds			; restore bds pointer

;   at this point, in bpb of bds table, BDS_BPB.BPB_BIGTOTALSECTORS which is
;   set according to the partition information. we are going to
;   see if (hidden sectors + total sectors) > a word.  if it is true,
;   then no change.  otherwise, BDS_BPB.BPB_BIGTOTALSECTORS will be moved
;   to BDS_BPB.BPB_TOTALSECTORS and BDS_BPB.BPB_BIGTOTALSECTORS will be set to 0.
;   we don't do this for the bpb information from the boot record. we
;   are not going to change the bpb information from the boot record

massage_bpb:
	mov	dx,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2
	mov	ax,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS

	cmp	dx,0			; double word total sector?
	ja	goodret 		; don't have to change it.
	cmp	word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS+2,0
	ja	goodret 		; don't have to change it.
	add	ax,word ptr ds:[di].BDS_BPB.BPB_HIDDENSECTORS
	jc	goodret 		; bigger than a word boundary

	mov	ax,word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS
	mov	ds:[di].BDS_BPB.BPB_TOTALSECTORS,ax
	mov	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS,0

goodret:
	mov	bl,fbigfat
	mov	ds:[di].bds_fatsiz,bl		; set size of fat on media
	clc
ret_hard:
	pop	es				; M011
	pop	ds
	pop	bx
	pop	di
	ret

sethard endp

cover_fdisk_bug 	proc

;fdisk of pc dos 3.3 and below, os2 1.0 has a bug.  the maximum number of
;sector that can be handled by pc dos 3.3 ibmbio should be 0ffffh.
;instead, sometimes fdisk use 10000h to calculate the maximum number.
;so, we are going to check that if BPB_TOTALSECTORS + hidden sector = 10000h
;then subtract 1 from BPB_TOTALSECTORS.

	push	ax
	push	dx
	push	si
	cmp	cs:disksector.EXT_BOOT_SIG,ext_boot_signature
	je	cfb_retit		;if extended bpb, then >= pc dos 4.00

	cmp	word ptr cs:[bx+7],"0" shl 8 + "1" ; os2 1.0 ? = ibm 10.0
	jne	cfb_chk_BPB_TOTALSECTORS
	cmp	byte ptr cs:[bx+10],"0"
	jne	cfb_retit

cfb_chk_BPB_TOTALSECTORS:
	mov	si,offset disksector.EXT_BOOT_BPB
	cmp	cs:[si.BPB_TOTALSECTORS],0	;just to make sure.
	je	cfb_retit

	mov	ax,cs:[si.BPB_TOTALSECTORS]
	add	ax,word ptr cs:[si.BPB_HIDDENSECTORS]
	jnc	cfb_retit

;M031	xor	ax,ax			;if carry set and ax=0?
	jnz	cfb_retit		; M031 -- zero reflects ax from add

;	M031 -- result of add was 10000h

	dec	cs:[si.BPB_TOTALSECTORS]		; then decrease BPB_TOTALSECTORS by 1.
;M034	dec	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS
	sub	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS,1	; M034
	sbb	word ptr ds:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2,0 ; M034


cfb_retit:
	pop	si
	pop	dx
	pop	ax
	ret

cover_fdisk_bug endp


;****************************
;
; setdrvparms sets up the recommended bpb in each bds in the system based on
; the form factor. it is assumed that the bpbs for the various form factors
; are present in the bpbtable. for hard files, the recommended bpb is the same
; as the bpb on the drive.

; no attempt is made to preserve registers since we are going to jump to
; sysinit straight after this routine.

word2	dw	2		; word constants for mul/div
word3	dw	3
word512	dw	512

setdrvparms proc near
	xor	bx,bx
	les	di,[start_bds] 		; get first bds in list

next_bds:
	push	es
	push	di			; preserve pointer to bds
	mov	bl,es:[di].bds_formfactor
	cmp	bl,ffhardfile
	jnz	nothardff

	xor	dx,dx
	mov	ax,es:[di].BDS_BPB.BPB_TOTALSECTORS
	or	ax,ax
	jnz	get_ccyl

	mov	dx,word ptr es:[di].BDS_BPB.BPB_BIGTOTALSECTORS+2	; use double word sector number
	mov	ax,word ptr es:[di].BDS_BPB.BPB_BIGTOTALSECTORS
get_ccyl:
	push	dx
	push	ax
	mov	ax,word ptr es:[di].BDS_BPB.BPB_HEADS
	mul	word ptr es:[di].BDS_BPB.BPB_SECTORSPERTRACK ;assume sectorsp per cyl. < 64k.
	mov	cx,ax			; cx has # sectors per cylinder
	pop	ax
	pop	dx			; restore BDS_BPB.BPB_TOTALSECTORS.

	push	ax
	mov	ax,dx
	xor	dx,dx
	div	cx
	mov	cs:[temp_h],ax		; ax be 0 here.
	pop	ax

	div	cx			; div #sec by sec/cyl to get # cyl.
	or	dx,dx
	jz	no_cyl_rnd		; came out even
	inc	ax			; round up
no_cyl_rnd:
	mov	es:[di].bds_ccyln,ax
	push	es
	pop	ds
	lea	si,[di].BDS_BPB.BPB_BYTESPERSECTOR	; ds:si -> bpb for hard file
	jmp	short set_recbpb

nothardff:

; we don't use the extended bpb for a floppy.

	push	cs
	pop	ds
	assume	ds:datagrp

;	if fake floppy drive variable is set then we don't have to handle this
;	bds.  we can just go and deal with the next bds at label go_to_next_bds.

	cmp	cs:fakefloppydrv,1
	jz	go_to_next_bds

	cmp	bl,ffother		; special case "other" type of medium
	jnz	not_process_other

process_other:
	xor	dx,dx
	mov	ax,ds:[di].bds_ccyln
	mul	ds:[di].BDS_RBPB.BPB_HEADS
	mul	ds:[di].BDS_RBPB.BPB_SECTORSPERTRACK
	mov	ds:[di].BDS_RBPB.BPB_TOTALSECTORS,ax 	; have the total number of sectors
	dec	ax

	mov	dl, 1
again:
	cmp	ax, 4096-10
	jb	@f
	shr	ax, 1
	shl	dl, 1
	jmp	again
@@:
	cmp	dl, 1				; is it a small disk
	je	@f				; yes, 224 root entries is enuf
	mov	ds:[di].BDS_RBPB.BPB_ROOTENTRIES, 240
@@:
	mov	ds:[di].BDS_RBPB.BPB_SECTORSPERCLUSTER, dl

;	logic to get the sectors/fat area.
;	fat entry is assumed to be 1.5 bytes!!!

	mul	cs:word3
	div	cs:word2
	xor	dx,dx
	div	cs:word512
	inc	ax

no_round_up:
	mov	ds:[di].BDS_RBPB.BPB_SECTORSPERFAT,ax
	jmp	short go_to_next_bds

not_process_other:
	shl	bx,1			; bx is word index into table of bpbs
	mov	si,offset datagrp:bpbtable
	mov	si,word ptr [si+bx]	; get address of bpb

set_recbpb:
	lea	di,ds:[di].BDS_RBPB	; es:di -> recbpb
	mov	cx,size bpbx
	rep	movsb			; move (size bpbx) bytes

go_to_next_bds:
	pop	di
	pop	es			; restore pointer to bds
	les	di,es:[di].bds_link
	cmp	di,-1
	jz	got_end_of_bds_chain
	jmp	next_bds
got_end_of_bds_chain:
	ret


setdrvparms endp


;--------------------------------------------------------------------

; al = device number

print_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax			; get printer port number into dx
	mov	ah,1			;initalize printer port
	int	17h			;call rom-bios routine
	ret

print_init endp

;--------------------------------------------------------------------

aux_init proc	near
	assume	ds:nothing,es:nothing

	cbw
	mov	dx,ax
	mov	al,rsinit		;2400,n,1,8 (msequ.inc)
	mov	ah,0			;initalize aux port
	int	14h			;call rom-bios routine
	ret

aux_init endp

;--------------------------------------------------------------------

; domini **********************************************************************
;
;mini disk initialization routine. called right after dohard
;modified for >2 hardfile support
;
; **cs=ds=es=datagrp
;
; **domini will search for every extended partition in the system, and
;   initialize it.
;
; **bdsm stands for bds table for mini disk and located right after the label
;   end96tpi.  end_of_bdsm will have the offset value of the ending
;   address of bdsm table.
;
; **bdsm is the same as usual bds structure except that tim_lo, tim_hi entries
;   are overlapped and used to identify mini disk and the number of hidden_trks.
;   right now, they are called as ismini, hidden_trks respectively.
;
; **domini will use the same routine in sethard routine after label set2 to
;   save coding.
;
; **drvmax determined in dohard routine will be used for the next
;   available logical mini disk drive number.
;
;M011 -- begin changed section
;
; input: drvmax, dskdrvs
;
; output: minidisk installed. bdsm table established and installed to bds.
;	  end_of_bdsm - ending offset address of bdsm.
;
;
; called modules:
;		  getboot
;		  find_mini_partition (new), xinstall_bds (new), M038

;		  setmini (new, it will use set2 routine)
;
; variables used: end_of_bdsm
;		  rom_minidisk_num
;		  mini_hdlim, mini_seclim
;		  BDS_STRUC, start_bds
;
;******************************************************************************

domini	proc	near
	assume	ds:datagrp,es:datagrp

	mov	dh,hnum			; get number of hardfiles
	cmp	dh,0
	jz	dominiret		;no hard file? then exit.

	mov	dl,80h			; start with hardfile 80h

domini_loop:
	push	dx			; save hard drive number, count
	mov	rom_minidisk_num,dl

	mov	ah,8h			;get drive parameters
	int	13h			;call rom-bios
	inc	dh			;get # of heads (convert it to 1 based)
	xor	ax,ax
	mov	al,dh
	mov	mini_hdlim,ax		;save it.
	and	cl,3fh			;get # of sectors/track
	mov	al,cl
	mov	mini_seclim,ax		;and save it.

	push	es			; preserve es
	mov	dl,rom_minidisk_num
	call	getboot 		;read master boot record into 7c0:bootbias
	assume	es:nothing
	jc	domininext
	call	find_mini_partition
domininext:
	pop	es
	assume	es:datagrp

	pop	dx
	inc	dl			; next hard file
	dec	dh
	jnz	domini_loop

dominiret:
	ret

domini	endp

;--------------------------------------------------------------------

;find_mini_partition tries to find every extended partition on a disk.
;at entry:	di -> bdsm entry
;		es:bx -> 07c0:bootbias - master boot record
;		rom_minidisk_num  - rom drive number
;		drvmax - logical drive number
;		mini_hdlim, mini_seclim
;
;called routine: setmini which uses set2 (in sethard routine)
;variables & equates used from original bios - flags, fnon_removable, fbigfat

find_mini_partition proc near
	assume	ds:datagrp,es:nothing

	add	bx,1c2h			;bx -> system id.

fmpnext:
	cmp	byte ptr es:[bx],5	; 5 = extended partition id.
	jz	fmpgot
	add	bx,16			; for next entry
	cmp	bx,202h+bootbias
	jnz	fmpnext
	jmp	short fmpret		; M038 not found extended partition

fmpgot: 				;found my partition.

	call	dmax_check		; M029 -- check for drvmax already 26
	jnc	fmpret			; M038, M029 -- done if too many

	mov	di,[end_of_bdss]	; get next free bds
	mov	ds:[di].bdsm_ismini,1
	or	ds:[di].bds_flags,fnon_removable
	mov	ds:[di].bds_formfactor,ffhardfile
	mov	fbigfat,0		;assume 12 bit fat.

	mov	ax,mini_hdlim
	mov	ds:[di].BDS_BPB.BPB_HEADS,ax
	mov	ax,mini_seclim
	mov	ds:[di].BDS_BPB.BPB_SECTORSPERTRACK,ax
	mov	al,rom_minidisk_num
	mov	ds:[di].bds_drivenum,al	;set physical number
	mov	al,drvmax
	mov	ds:[di].bds_drivelet,al	;set logical number

	cmp	word ptr es:[bx+10],0
	ja	fmpgot_cont
	cmp	word ptr es:[bx+8],64	;**with current bpb, only lower word
					; is meaningful.
	jb	fmpret			;should be bigger than 64 sectors at least
fmpgot_cont:

	sub	bx,4			;let bx point to the start of the entry
	mov	dh,byte ptr es:[bx+2]
	and	dh,11000000b		;get higher bits of cyl
	rol	dh,1
	rol	dh,1
	mov	dl,byte ptr es:[bx+3]	;cyl byte
	mov	ds:[di].bdsm_hidden_trks,dx	;set hidden trks

;** now, read the volume boot record into bootbias.

	mov	cx,es:[bx+2]		;cylinder,cylinder/sector
	mov	dh,es:[bx+1]		;head
	mov	dl,rom_minidisk_num	;drive
	mov	bx,bootbias		;buffer offset
	mov	ax,201h 		;read, 1 sector
	int	13h			;call rom-bios routine
	jc	fmpret			;cannot continue.

	mov	bx,1c2h+bootbias
	push	es			; addressability to next minidisk
	call	setmini 		; install a mini disk. bx value saved.
	pop	es
	jc	fmpnextchain

;M038	add	[end_of_bdss],size BDS_STRUC

	call	xinstall_bds		; M038 -- install the bdsm into table

;M038	inc	drvmax			; increase the logical drive for next
;M038
;M038	push	bx			; now, set the dskdrvs pointer to bpb info.
;M038	mov	bx,[last_dskdrv_table]
;M038	lea	si,ds:[di].BDS_BPB.BPB_BYTESPERSECTOR	; points to bpb of bdsm
;M038	mov	[bx],si
;M038	add	bx,2
;M038	mov	[last_dskdrv_table],bx
;M038	pop	bx


fmpnextchain: jmp fmpnext		;let's find out if we have any chained partition

fmpret:
	ret

find_mini_partition endp

;--------------------------------------------------------------------

setmini	proc	near
	assume	ds:datagrp,es:nothing

	push	di
	push	bx
	push	ds
	push	es			; M011 - match stack for standard exit

;	M019 -- begin changes

setmini_1:
	cmp	byte ptr es:[bx],1
	jz	setmini_2

	cmp	byte ptr es:[bx],4
	jz	setmini_2

	cmp	byte ptr es:[bx],6
	jz	setmini_2

	add	bx,16
	cmp	bx,202h+bootbias
	jnz	setmini_1

	stc
	pop	es
	pop	ds
	pop	bx
	pop	di	
	ret

setmini_2:
	jmp	set2			; branch into middle of sethard

;	M019 -- end changes

setmini	endp

;M011 -- end changed section

;M029 -- begin additions
;
;	dmax_check --- call this when we want to install a new drive.
;			it checks for drvmax < 26 to see if there is
;			a drive letter left.
;
;		drvmax < 26 : carry SET!
;		drvmax >=26 : carry RESET!, error flag set for message later
;				trash ax
;
dmax_check	proc	near
	cmp	drvmax,26		; already have max?
	jc	dmax_ok			; return with carry if okay

	push	es
	mov	ax,SYSINITSEG
	mov	es,ax
	mov	byte ptr es:[toomanydrivesflag],1 ; set message flag
	pop	es

;	note:  carry still clear!!!

dmax_ok:
	ret

dmax_check	endp

;	M029 -- end additions

;	M038 -- begin additions

;--------------------------------------------------------------------
;	link next bds (at ds:di) into the chain.  assume that the
;	  chain is entirely within ds == datagrp.  also update drvmax,
;	  dskdrv_table, and end_of_bdss.


xinstall_bds proc near
	assume	ds:datagrp,es:nothing

	push	si
	push	bx

	mov	si,word ptr [start_bds]	; get first bds

xinstall_bds_1:
	cmp	word ptr [si].bds_link,-1 ; is this the last one?
	jz	xinstall_bds_2		; skip ahead if so
	mov	si,word ptr [si].bds_link ; chain through list
	jmp	xinstall_bds_1

xinstall_bds_2:
	mov	word ptr [si].bds_link,di
	mov	word ptr [si].bds_link+2,ds
	mov	word ptr [di].bds_link,-1	;make sure it is a null ptr.
	mov	word ptr [di].bds_link+2,ds	; might as well plug segment
						;  into final bds in chain
	lea	bx,[di].BDS_BPB
	mov	si,[last_dskdrv_table]
	mov	word ptr [si],bx
	add	[last_dskdrv_table],2

	inc	drvmax

	add	end_of_bdss,size BDS_STRUC
	pop	bx
	pop	si
	ret

xinstall_bds endp

;	M038 -- end additions

;--------------------------------------------------------------------

;**end of mini disk initialization**

;--------------------------------------------------------------------

IFNDEF	POWER		; CMOS clock is initialized by power management
			; device driver, if present.  ;M074

cmos_clock_read proc	near
	assume	ds:datagrp,es:datagrp

; in order to determine if there is a clock present in the system, the following
; needs to be done.

	push	ax
	push	cx
	push	dx
	push	bp

	xor	bp,bp
loop_clock:
	xor	cx,cx
	xor	dx,dx
	mov	ah,2			;read real time clock
	int	1ah			;call rom-bios routine
	cmp	cx,0			; cas - arrrrgh!
	jnz	clock_present

	cmp	dx,0
	jnz	clock_present

	cmp	bp,1			; read again after a slight delay, in case clock
	jz	no_readdate		; was at zero setting.

	inc	bp			; only perform delay once.
	mov	cx,4000h
delay:
	loop	delay
	jmp	loop_clock

clock_present:
	mov	cs:havecmosclock,1	; set the flag for cmos clock
	call	cmosck			; reset cmos clock rate that may be
					;possibly destroyed by cp dos and post routine did not
					;restore that.
	push	si
	call	read_real_date		; read real-time clock for date

	cli
	mov	daycnt,si		; set system date
	sti
	pop	si

no_readdate:
	pop	bp
	pop	dx
	pop	cx
	pop	ax
	ret

cmos_clock_read endp

; the following code is written by jack gulley in engineering group.
; cp dos is changing cmos clock rate for its own purposes and if the
; use cold boot the system to use pc dos while running cp dos, the cmos
; clock rate are still slow which slow down disk operations of pc dos
; which uses cmos clock.  pc dos is put this code in msinit to fix this
; problem at the request of cp dos.
;
; the program is modified to be run on msinit. equates are defined in cmosequ.inc.
; this program will be called by cmos_clock_read procedure.
;
;  the following code cmosck is used to insure that the cmos has not
;	had its rate controls left in an invalid state on older at's.
;
;	it checks for an at model byte "fc" with a submodel type of
;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate
;	bits in case post has not done it.  this initilization routine
;	is only needed once when dos loads.  it should be run as soon
;	as possible to prevent slow diskette access.
;
;	this code exposes one to dos clearing cmos setup done by a
;	resident program that hides and re-boots the system.

cmosck	proc	near			; check and reset rtc rate bits
	assume	ds:nothing,es:nothing

;model byte and submodel byte were already determined in msinit.

	push	ax
	cmp	cs:model_byte,0fch	;check for pc-at model byte
					; exit if not "fc" for a pc-at
	jne	cmosck9 		; exit if not an at model

	cmp	cs:secondary_model_byte,06h  ; is it 06 for the industral at
	je	cmosck4 		; go reset cmos periodic rate if 06
	cmp	cs:secondary_model_byte,04h  ; is it 00, 01, 02, or 03
	jnb	cmosck9 		; exit if problem fixed by post
					; also,secondary_model_byte = 0 when ah=0c0h, int 15h failed.
cmosck4:				;	reset the cmos periodic rate
					;  model=fc submodel=00,01,02,03 or 06

	mov	al,cmos_reg_a or nmi	;nmi disabled on return
	mov	ah,00100110b		;set divider & rate selection
	call	cmos_write

					; clear set,pie,aie,uie and sqwe
	mov	al,cmos_reg_b or nmi	;nmi disabled on return
	call	cmos_read
	and	al,00000111b		;clear set,pie,aie,uie,sqwe
	mov	ah,al
	mov	al,cmos_reg_b		;nmi enabled on return
	call	cmos_write


cmosck9:				; exit routine
	pop	ax
	ret				; return to caller
					;  flags modifyied
cmosck	endp


;--- cmos_read -----------------------------------------------------------------
;		read byte from cmos system clock configuration table	       :
;									       :
; input: (al)=	cmos table address to be read				       :
;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
;		bits 6-0 = address of table location to read		       :
;									       :
; output: (al)	value at location (al) moved into (al).  if bit 7 of (al) was  :
;		on then nmi left disabled.  during the cmos read both nmi and  :
;		normal interrupts are disabled to protect cmos data integrity. :
;		the cmos address register is pointed to a default value and    :
;		the interrupt flag restored to the entry state on return.      :
;		only the (al) register and the nmi state is changed.	       :
;-------------------------------------------------------------------------------

cmos_read	proc	near		; read location (al) into (al)
	assume	es:nothing,ds:nothing

	pushf				; save interrupt enable status and flags
	cli
	push	bx
	push	ax			;save user nmi state
	or	al,nmi			;disable nmi for us
	out	cmos_port,al
	nop				;undocumented delay needed
	in	al,cmos_data		;get data value

;	set nmi state to user specified

	mov	bx,ax			;save data value
	pop	ax			;get user nmi
	and	al,nmi
	or	al,cmos_shut_down
	out	cmos_port,al
	nop
	in	al,cmos_data

	mov	ax,bx			;data value
	pop	bx

	push	cs			; *place datagrp segment in stack and
	call	cmos_popf		; *handle popf for b- level 80286
	ret				; return with flags restored

cmos_read	endp

cmos_popf	proc	near		; popf for level b- parts
	iret				; return far and restore flags

cmos_popf	endp

;--- cmos_write ----------------------------------------------------------------
;		write byte to cmos system clock configuration table	       :
;									       :
; input: (al)=	cmos table address to be written to			       :
;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
;		bits 6-0 = address of table location to write		       :
;	 (ah)=	new value to be placed in the addressed table location	       :
;									       :
; output:	value in (ah) placed in location (al) with nmi left disabled   :
;		if bit 7 of (al) is on.  during the cmos update both nmi and   :
;		normal interrupts are disabled to protect cmos data integrity. :
;		the cmos address register is pointed to a default value and    :
;		the interrupt flag restored to the entry state on return.      :
;		only the cmos location and the nmi state is changed.	       :
;-------------------------------------------------------------------------------

cmos_write	proc	near		; write (ah) to location (al)
	assume	es:nothing,ds:nothing
	pushf				; save interrupt enable status and flags
	push	ax			; save work register values

	cli
	push	ax			; save user nmi state
	or	al,nmi			; disable nmi for us
	out	cmos_port,al
	nop
	mov	al,ah
	out	cmos_data,al		; write data

;   set nmi state to user specified

	pop	ax			; get user nmi
	and	al,nmi
	or	al,cmos_shut_down
	out	cmos_port,al
	nop
	in	al,cmos_data

	pop	ax			; restore work registers
	push	cs			; *place datagrp segment in stack and
	call	cmos_popf		; *handle popf for b- level 80286
	ret

cmos_write	endp

ENDIF	; NOT POWER


;==========================================================================
;
; The following routines provide support for reading in the file MSDOS.SYS.
;
; Thus, they are not needed for ROMDOS
;

ifndef ROMDOS

;*******************************
;
; GetClus, read in a cluster at a specified address
;
;  bx = cluster to read
;  cx = sectors per cluster
;  es:di = load location
;
getclus proc	near
	push	cx
	push	di
	mov	doscnt,cx	      ;save number of sectors to read
	mov	ax,bx
	dec	ax
	dec	ax
	mul	cx			;convert to logical sector

; now dx;ax = matching logical sector number starting from the data sector.
;	add the bios start sector to the sector number in dx:ax.  the bios
;	start sector number is in bios_h:bios_l

	add	ax,cs:bios_l
	adc	dx,cs:bios_h

; now dx;ax = first logical sector to read

getcl1:

;	   si = bx, bx = next allocation unit
;		get the fat entry at bx

unpack:
	push	ds
	push	ax			;save first logical sector (low)
	push	bx
	mov	si,fatloc
	mov	ds,si			;ds -> fatloc segment
	mov	si,bx

	test	cs:fbigfat,fbig 	;16 bit fat?
	jnz	unpack16

	shr	si,1			;12 bit fat. si=si/2
	add	si,bx			; si = clus + clus/2

	push	dx			; M054
	xor	dx,dx			; M054 12 bit fat has <16 bit offset
	call	get_fat_sector		; offset of fat entry in bx
	pop	dx			; M054

	mov	ax,[bx]			;save it into ax
	jne	even_odd		;if not a splitted fat, check even-odd.

	mov	al,byte ptr [bx]	;splitted fat.
	mov	byte ptr cs:temp_cluster,al
	inc	si
	push	dx			; M054
	xor	dx,dx			; M054 12 bit fat has <16 bit offset
	call	get_fat_sector
	pop	dx			; M054

	mov	al,byte ptr ds:[0]
	mov	byte ptr cs:temp_cluster+1, al
	mov	ax,cs:temp_cluster
even_odd:
	pop	bx			;restore old fat entry value
	push	bx			;save it right away.
	shr	bx,1			;was it even or odd?
	jnc	havclus 		;it was even.

	shr	ax,1			;odd. massage fat value and keep
	shr	ax,1			;the highest 12 bits.
	shr	ax,1
	shr	ax,1

havclus:
	mov	bx,ax			; now bx = new fat entry.
	and	bx,0fffh		; keep low 12 bits.
	jmp	short unpackx

unpack16:				;16 bit fat.
	push	dx			; M054
	xor	dx,dx			; M054 extend to 32 bit offset
	shl	si,1			;get the offset value.
	adc	dx,0			; M054 32 bit
	call	get_fat_sector
	pop	dx			; M054

	mov	bx,[bx]		; now bx = new fat entry.
unpackx:
	pop	si			;retore old bx value into si
	pop	ax			;restore logical sector (low)
	pop	ds

	sub	si,bx
	cmp	si,-1			;one apart?
	jnz	getcl2

	add	doscnt,cx
	jmp	getcl1

getcl2:
	push	bx
	push	dx			; sector to read (high)
	push	ax			; sector to read (low)
	mov	ax,drvfat		;get drive and fat spec
	mov	cx,doscnt
	pop	dx			; sector to read for diskrd (low)
	pop	cs:[start_sec_h]	; sector to read for diskrd (high)

	push	ds			; save whatever we might have had in ds
	push	cs			; point ds at datagrp
	pop	ds

	push	cs			; simulate far call
	mov	bp,offset diskrd
	call	call_bios_code		;read the clusters

;	hmmmmm.  Error checking?????

	pop	ds			; restore our ds

	pop	bx

	pop	di
	mov	ax,doscnt		;get number of sectors read
	xchg	ah,al			;multiply by 256
	shl	ax,1			;times 2 equal 512
	add	di,ax			;update load location
	pop	cx			;restore sectors/cluster
	ret

getclus endp

get_fat_sector	proc	near

;function: find and read the corresponding fat sector into ds:0
;
;in). dx:si - offset value (starting from fat entry 0) of fat entry to find. M054
;     ds - fatloc segment
;     cs:drvfat - logical drive number, fat id
;     cs:md_sectorsize
;     cs:last_fat_secnum - last fat sector number read in.
;
;out). corresponding fat sector read in.
;      bx = offset value from fatlog segment.
;      other registera saved.
;      zero flag set if the fat entry is splitted, i.e., wehn 12 bit fat entry
;      starts at the last byte of the fat sector. in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value. (this will only happen with the 12 bit fat.)

	push	ax
	push	cx
;M054	push	dx
	push	di
	push	si
	push	es
	push	ds

;M054	xor	dx,dx
	mov	ax,si			; M054 dx:ax == offset
	mov	cx,cs:md_sectorsize		; =512 bytes
	div	cx				; ax=sector number, dx = offset

	PUBLIC TEST3
TEST3:
	nop


;AN017 Get rid of the assumption that there is only one reserved sector
;
	push	es
	push	ds				;AN017;
	push	di				;AN017;
	push	ax				;AN017;


	push	cs
	pop	ds
	assume	ds:datagrp

	mov	ax,cs:DRVFAT			;AN017;get drive # and FAT id

	mov	bp,offset setdrive
	push	cs				;5.00 simulate far call
	call	call_bios_code			;5.00 get bds for drive

;	call	setdrive			;5.00; AN017;get the BDS for the drive

	pop	ax				;AN017;
	add	ax,ES:[DI.BDS_BPB.BPB_RESERVEDSECTORS] ;AN017;add #reserved_sectors
	pop	di				;AN017;
	pop	ds				;AN017;
	pop	es

;	inc	ax				;AN017; make ax to relative logical sector number

	cmp	ax,cs:last_fat_secnum		;  by adding reserved sector number.
	je	gfs_split_chk			; don't need to read it again.

	mov	cs:last_fat_secnum,ax		; update last_fat_secnum
	push	dx				; save offset value.
	mov	cs:[start_sec_h],0		; prepare to read the fat sector
	mov	dx,ax				; start_sec_h is always 0 for fat sector.
	mov	cx,1				; 1 sector to read
	mov	ax,cs:drvfat
	push	ds
	pop	es
	xor	di,di				; es:di -> fatloc segment:0

	push	ds			; save whatever we had in ds
	push	cs			; point ds to datagrp for diskio
	pop	ds
	push	cs			; simulate far call
	mov	bp,offset diskrd
	call	call_bios_code		; cross your finger.
	pop	ds			; restore our old ds

	pop	dx				; restore offset value.
	mov	cx,cs:md_sectorsize

gfs_split_chk:
	dec	cx				;if offset points to the
	cmp	dx,cx				;last byte of this sector, then splitted entry.
	mov	bx,dx				;set bx to dx

	pop	ds
	pop	es
	pop	si
	pop	di
;M054	pop	dx
	pop	cx
	pop	ax
	ret
get_fat_sector	endp

endif	; end of non-ROMDOS-only code to load MSDOS.SYS M054 (comment change)


Bios_Data_Init	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\rom8k.inc ===
db	0EBH,01DH,090H,052H,044H,056H,020H,031H
	db	02EH,032H,030H,000H,002H,001H,001H,000H
	db	001H,040H,000H,010H,000H,0F8H,001H,000H
	db	001H,000H,001H,000H,000H,000H,008H,0EBH
	db	0FEH,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	041H,041H,041H,041H,041H,041H,041H,041H
	db	0E6H,003H,047H,090H,000H,000H,000H,000H
	db	000H,000H,000H,000H,0FFH,0FFH,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,02EH
	db	089H,01EH,0ACH,000H,02EH,08CH,006H,0AEH
	db	000H,0CBH,056H,050H,051H,052H,057H,055H
	db	01EH,006H,053H,02EH,0C5H,01EH,0ACH,000H
	db	08BH,04FH,012H,08BH,057H,014H,08AH,047H
	db	002H,02EH,08AH,026H,00BH,000H,03AH,0C4H
	db	077H,00FH,0BEH,00CH,000H,098H,003H,0F0H
	db	003H,0F0H,0C4H,07FH,00EH,00EH,01FH,0FFH
	db	024H,0B0H,003H,0EBH,00AH,02EH,0C5H,01EH
	db	0ACH,000H,0C7H,047H,012H,000H,000H,0B4H
	db	081H,0EBH,002H,0B4H,001H,02EH,0C5H,01EH
	db	0ACH,000H,089H,047H,003H,05BH,007H,01FH
	db	05DH,05FH,05AH,059H,058H,05EH,0CBH,0C5H
	db	01EH,0ACH,000H,0C6H,047H,00EH,001H,0EBH
	db	0E2H,0C5H,01EH,0ACH,000H,0C7H,047H,012H
	db	037H,000H,08CH,04FH,014H,0EBH,0D4H,0B8H
	db	000H,003H,0EBH,0D1H,032H,0FFH,0E8H,00EH
	db	000H,072H,002H,0EBH,0C6H,0EBH,0B6H,0B7H
	db	001H,0EBH,0F3H,0B0H,008H,0F9H,0C3H,03BH
	db	016H,03FH,000H,073H,0F6H,08BH,0C2H,003H
	db	0C1H,03BH,006H,03FH,000H,077H,0ECH,08BH
	db	0C1H,08AH,00EH,04AH,000H,0D3H,0E0H,073H
	db	003H,0B8H,000H,080H,08BH,0C8H,08BH,0C2H
	db	0F7H,026H,037H,000H,0EBH,004H,010H,030H
	db	000H,000H,003H,006H,082H,001H,013H,016H
	db	084H,001H,051H,0B9H,010H,000H,0F7H,0F1H
	db	059H,00AH,0FFH,074H,00CH,006H,01FH,08BH
	db	0F7H,08EH,0C0H,08BH,0FAH,0F3H,0A5H,0F8H
	db	0C3H,08EH,0D8H,08BH,0F2H,0EBH,0F6H,056H
	db	057H,050H,053H,051H,052H,01EH,006H,00EH
	db	01FH,0A1H,082H,001H,08BH,016H,084H,001H
	db	02DH,000H,004H,083H,0DAH,000H,0B9H,010H
	db	000H,0F7H,0F1H,08EH,0D8H,08BH,0F2H,08BH
	db	0FEH,083H,0C7H,040H,0B9H,05FH,000H,0F7H
	db	005H,001H,000H,074H,014H,0F7H,005H,002H
	db	000H,074H,009H,083H,07DH,002H,001H,075H
	db	003H,083H,025H,0FDH,083H,0C7H,00AH,0E2H
	db	0E6H,007H,01FH,05AH,059H,05BH,058H,05FH
	db	05EH,0C3H,052H,041H,04DH,044H,072H,069H
	db	076H,065H,020H,069H,073H,020H,061H,020H
	db	074H,072H,061H,064H,065H,06DH,061H,072H
	db	06BH,020H,06FH,066H,020H,04DH,069H,063H
	db	072H,06FH,073H,06FH,066H,074H,020H,043H
	db	06FH,072H,070H,06FH,072H,061H,074H,069H
	db	06FH,06EH,02EH,054H,068H,069H,073H,020H
	db	0F8H,0FFH,0FFH,0FFH,0FFH,0FFH,005H,060H
	db	000H,007H,080H,000H,009H,0F0H,0FFH,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	04DH,053H,02DH,052H,04FH,04DH,044H,052H
	db	049H,056H,045H,008H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	05BH,016H,000H,000H,000H,000H,000H,000H
	db	043H,04FH,04EH,046H,049H,047H,020H,020H
	db	053H,059H,053H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,069H,05DH
	db	033H,017H,002H,000H,016H,000H,000H,000H
	db	041H,055H,054H,04FH,045H,058H,045H,043H
	db	042H,041H,054H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,077H,05DH
	db	033H,017H,003H,000H,031H,000H,000H,000H
	db	052H,04FH,04DH,052H,044H,020H,020H,020H
	db	041H,053H,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,031H,066H
	db	02DH,017H,004H,000H,0D6H,00BH,000H,000H
	db	0E5H,04FH,04DH,052H,044H,04CH,04FH,020H
	db	041H,053H,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0A1H,05DH
	db	033H,017H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	066H,069H,06CH,065H,073H,03DH,033H,030H
	db	00DH,00AH,062H,075H,066H,066H,065H,072H
	db	073H,03DH,031H,035H,00DH,00AH,01BH,088H
	db	02FH,017H,00CH,004H,000H,000H,000H,000H
	db	02EH,02EH,020H,020H,020H,020H,020H,020H
	db	020H,020H,020H,010H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,01BH,088H
	db	02FH,017H,000H,000H,000H,000H,000H,000H
	db	049H,04DH,047H,045H,054H,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0E7H,05BH
	db	032H,017H,00DH,004H,06CH,028H,000H,000H
	db	046H,04FH,04FH,020H,020H,020H,020H,020H
	db	042H,041H,052H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,05AH,05DH
	db	032H,017H,013H,004H,000H,000H,001H,000H
	db	046H,04FH,04FH,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,073H,05DH
	db	032H,017H,0C5H,019H,000H,000H,001H,000H
	db	048H,049H,04DH,045H,04DH,020H,020H,020H
	db	053H,059H,053H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,020H,00AH
	db	033H,017H,087H,059H,060H,02DH,000H,000H
	db	04DH,045H,053H,053H,041H,047H,045H,053H
	db	049H,04EH,043H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,048H,088H
	db	032H,017H,0E4H,073H,07EH,000H,000H,000H
	db	052H,04FH,04DH,045H,058H,043H,04CH,020H
	db	04FH,042H,04AH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,04BH,088H
	db	032H,017H,0E5H,073H,02CH,003H,000H,000H
	db	052H,04FH,04DH,045H,058H,043H,04CH,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,074H,088H
	db	032H,017H,0E9H,073H,0B8H,004H,000H,000H
	db	052H,04FH,04DH,045H,058H,043H,04CH,020H
	db	04DH,041H,050H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,074H,088H
	db	032H,017H,0E8H,073H,054H,001H,000H,000H
	db	052H,04FH,04DH,045H,058H,043H,04CH,020H
	db	041H,053H,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0B2H,088H
	db	032H,017H,0EAH,073H,081H,01CH,000H,000H
	db	052H,020H,020H,020H,020H,020H,020H,020H
	db	04FH,042H,04AH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,08BH
	db	032H,017H,0FDH,072H,025H,001H,000H,000H
	db	052H,020H,020H,020H,020H,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,002H,08BH
	db	032H,017H,0DEH,073H,073H,003H,000H,000H
	db	052H,020H,020H,020H,020H,020H,020H,020H
	db	041H,053H,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0FDH,08AH
	db	032H,017H,088H,059H,093H,00AH,000H,000H
	db	052H,04FH,04DH,038H,04BH,020H,020H,020H
	db	020H,020H,020H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,013H,05DH
	db	033H,017H,0E6H,073H,000H,020H,000H,000H
	db	052H,04FH,04DH,038H,04BH,020H,020H,020H
	db	049H,04EH,043H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,02BH,05DH
	db	033H,017H,0FBH,073H,000H,0B4H,000H,000H
	db	040H,065H,063H,068H,06FH,020H,06FH,066H
	db	066H,00DH,00AH,070H,061H,074H,068H,03DH
	db	063H,03AH,05CH,03BH,063H,03AH,05CH,062H
	db	069H,06EH,03BH,063H,03AH,05CH,064H,06FH
	db	073H,03BH,00DH,00AH,070H,072H,06FH,06DH
	db	070H,074H,020H,024H,070H,024H,067H,00DH
	db	00AH,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,0F2H,054H,0F1H,05BH,000H,000H
	db	0E5H,045H,054H,056H,045H,052H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,095H,063H,0E7H,02EH,000H,000H
	db	0E5H,04EH,053H,049H,020H,020H,020H,020H
	db	053H,059H,053H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,09BH,063H,045H,023H,000H,000H
	db	0E5H,045H,04CH,045H,043H,054H,020H,020H
	db	044H,041H,054H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,001H,000H
	db	087H,012H,0A0H,063H,0D7H,059H,000H,000H
	db	0E5H,045H,042H,055H,047H,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,0ACH,063H,09AH,050H,000H,000H
	db	0E5H,04DH,04DH,033H,038H,036H,020H,020H
	db	033H,039H,030H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,0E0H,02CH
	db	062H,015H,0B7H,063H,04AH,04AH,001H,000H
	db	0E5H,04FH,053H,04BH,045H,059H,020H,020H
	db	043H,04FH,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,077H,073H,0FBH,016H,000H,000H
	db	0E5H,044H,04CH,049H,04EH,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,07AH,073H,062H,031H,000H,000H
	db	0E5H,04DH,04DH,033H,038H,036H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,081H,073H,05EH,066H,001H,000H
	db	0E5H,04DH,04DH,033H,038H,036H,020H,020H
	db	033H,033H,036H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,09DH,01CH
	db	029H,015H,0B7H,073H,045H,042H,001H,000H
	db	0E5H,041H,053H,054H,04FH,050H,045H,04EH
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,0E1H,073H,012H,02FH,000H,000H
	db	0E5H,044H,049H,053H,04BH,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,0E7H,073H,088H,0DFH,000H,000H
	db	0E5H,045H,04DH,020H,020H,020H,020H,020H
	db	045H,058H,045H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,003H,074H,08AH,09BH,000H,000H
	db	0E5H,049H,052H,052H,04FH,052H,020H,020H
	db	043H,04FH,04DH,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,020H,074H,0F9H,046H,000H,000H
	db	0E5H,041H,04DH,044H,052H,049H,056H,045H
	db	053H,059H,053H,020H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,028H
	db	089H,016H,029H,074H,0F1H,016H,000H,000H
	db	009H,070H,061H,067H,065H,009H,02CH,031H
	db	033H,032H,00DH,00AH,009H,074H,069H,074H
	db	06CH,065H,009H,052H,06FH,06DH,044H,072H
	db	069H,076H,065H,020H,070H,068H,079H,073H
	db	069H,063H,061H,06CH,020H,052H,04FH,04DH
	db	020H,061H,063H,063H,065H,073H,073H,020H
	db	072H,06FH,075H,074H,069H,06EH,065H,00DH
	db	00AH,00DH,00AH,03BH,009H,054H,068H,069H
	db	073H,020H,069H,073H,020H,061H,06EH,020H
	db	065H,078H,074H,065H,06EH,064H,065H,064H
	db	02DH,06DH,065H,06DH,06FH,072H,079H,020H
	db	063H,061H,070H,061H,062H,06CH,065H,020H
	db	076H,065H,072H,073H,069H,06FH,06EH,020H
	db	077H,068H,069H,063H,068H,020H,075H,073H
	db	065H,073H,020H,074H,068H,065H,00DH,00AH
	db	03BH,009H,020H,020H,052H,04FH,04DH,020H
	db	042H,049H,04FH,053H,027H,073H,020H,049H
	db	06EH,074H,031H,035H,028H,061H,068H,03DH
	db	038H,037H,068H,029H,020H,062H,06CH,06FH
	db	063H,06BH,020H,06DH,06FH,076H,065H,020H
	db	066H,075H,06EH,063H,074H,069H,06FH,06EH
	db	02EH,00DH,00AH,03BH,009H,04EH,06FH,074H
	db	065H,03AH,020H,020H,054H,068H,069H,073H
	db	020H,06DH,06FH,064H,075H,06CH,065H,020H
	db	061H,073H,073H,075H,06DH,065H,073H,020H
	db	06CH,06FH,077H,020H,031H,036H,04DH,065H
	db	067H,020H,06DH,061H,070H,070H,069H,06EH
	db	067H,020H,028H,032H,038H,036H,020H,073H
	db	070H,061H,063H,065H,020H,06FH,06EH,06CH
	db	079H,029H,00DH,00AH,00DH,00AH,03BH,00DH
	db	00AH,03BH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,00DH,00AH
	db	03BH,00DH,00AH,03BH,020H,04DH,030H,037H
	db	031H,020H,03AH,020H,04DH,061H,064H,065H
	db	020H,052H,04FH,04DH,044H,052H,049H,056H
	db	045H,042H,041H,053H,045H,05FH,04CH,04FH
	db	020H,065H,071H,075H,061H,074H,065H,064H
	db	020H,074H,06FH,020H,030H,030H,030H,030H
	db	020H,069H,06EH,073H,074H,065H,061H,064H
	db	020H,06FH,066H,020H,030H,030H,020H,066H
	db	06FH,072H,020H,06DH,06FH,072H,065H,00DH
	db	00AH,03BH,009H,020H,072H,065H,061H,064H
	db	061H,062H,069H,06CH,069H,074H,079H,00DH
	db	00AH,03BH,00DH,00AH,03BH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,02DH,02DH,02DH,02DH,02DH,02DH,02DH
	db	02DH,00DH,00AH,03BH,00DH,00AH,03BH,052H
	db	04FH,04DH,043H,04FH,044H,045H,009H,053H
	db	045H,047H,04DH,045H,04EH,054H,009H,062H
	db	079H,074H,065H,020H,070H,075H,062H,06CH
	db	069H,063H,00DH,00AH,03BH,009H,061H,073H
	db	073H,075H,06DH,065H,009H,063H,073H,03AH
	db	052H,04FH,04DH,043H,04FH,044H,045H,00DH
	db	00AH,009H,02EH,078H,06CH,069H,073H,074H
	db	00DH,00AH,009H,069H,06EH,063H,06CH,075H
	db	064H,065H,009H,062H,069H,06FH,073H,073H
	db	065H,067H,02EH,069H,06EH,063H,00DH,00AH
	db	009H,069H,06EH,063H,06CH,075H,064H,065H
	db	009H,06DH,073H,067H,072H,06FH,075H,070H
	db	02EH,069H,06EH,063H,00DH,00AH,009H,02EH
	db	06CH,069H,073H,074H,00DH,00AH,009H,061H
	db	073H,073H,075H,06DH,065H,009H,063H,073H
	db	03AH,062H,069H,06FH,073H,05FH,064H,061H
	db	074H,061H,00DH,00AH,00DH,00AH,049H,046H
	db	04EH,044H,045H,046H,009H,046H,041H,04BH
	db	045H,052H,04FH,04DH,00DH,00AH,00DH,00AH
	db	052H,04FH,04DH,044H,052H,049H,056H,045H
	db	042H,041H,053H,045H,05FH,04CH,04FH,009H
	db	065H,071H,075H,009H,030H,030H,030H,030H
	db	068H,009H,009H,009H,03BH,020H,04DH,030H
	db	037H,031H,00DH,00AH,052H,04FH,04DH,044H
	db	052H,049H,056H,045H,042H,041H,053H,045H
	db	05FH,048H,049H,009H,065H,071H,075H,009H
	db	030H,062H,030H,068H,00DH,00AH,00DH,00AH
	db	045H,04CH,053H,045H,00DH,00AH,00DH,00AH
	db	052H,04FH,04DH,044H,052H,049H,056H,045H
	db	042H,041H,053H,045H,05FH,04CH,04FH,009H
	db	065H,071H,075H,009H,030H,00DH,00AH,052H
	db	04FH,04DH,044H,052H,049H,056H,045H,042H
	db	041H,053H,045H,05FH,048H,049H,009H,065H
	db	071H,075H,009H,030H,00DH,00AH,00DH,00AH
	db	045H,04EH,044H,049H,046H,020H,03BH,020H
	db	046H,041H,04BH,045H,052H,04FH,04DH,00DH
	db	00AH,00DH,00AH,009H,070H,075H,062H,06CH
	db	069H,063H,009H,078H,066H,065H,072H,05FH
	db	066H,072H,06FH,06DH,05FH,072H,06FH,06DH
	db	00DH,00AH,00DH,00AH,03BH,009H,045H,06EH
	db	074H,072H,079H,03AH,00DH,00AH,03BH,009H
	db	020H,020H,020H,020H,020H,020H,020H,064H
	db	078H,03AH,062H,078H,020H,020H,02DH,020H
	db	033H,032H,020H,062H,069H,074H,020H,052H
	db	04FH,04DH,020H,06FH,066H,066H,073H,065H
	db	074H,020H,06FH,066H,020H,074H,072H,061H
	db	06EH,073H,066H,065H,072H,020H,062H,06CH
	db	06FH,063H,06BH,00DH,00AH,03BH,009H,020H
	db	020H,020H,020H,020H,020H,020H,065H,073H
	db	03AH,064H,069H,020H,020H,02DH,020H,072H
	db	065H,061H,06CH,020H,06DH,06FH,064H,065H
	db	020H,061H,064H,064H,072H,065H,073H,073H
	db	020H,077H,068H,065H,072H,065H,020H,069H
	db	074H,020H,073H,068H,06FH,075H,06CH,064H
	db	020H,067H,06FH,00DH,00AH,03BH,009H,020H
	db	020H,020H,020H,020H,020H,020H,063H,078H
	db	020H,020H,020H,020H,020H,02DH,020H,063H
	db	06FH,075H,06EH,074H,020H,069H,06EH,020H
	db	062H,079H,074H,065H,073H,02CH,020H,067H
	db	075H,061H,072H,061H,06EH,074H,065H,065H
	db	064H,020H,074H,06FH,020H,068H,061H,076H
	db	065H,020H,061H,074H,020H,06CH,065H,061H
	db	073H,074H,020H,032H,020H,07AH,065H,072H
	db	06FH,020H,06CH,073H,062H,073H,00DH,00AH
	db	03BH,009H,009H,020H,020H,020H,020H,020H
	db	020H,020H,020H,020H,06EH,06FH,074H,065H
	db	03AH,020H,020H,074H,072H,061H,06EH,073H
	db	066H,065H,072H,020H,06CH,065H,06EH,067H
	db	074H,068H,020H,03DH,03DH,020H,030H,030H
	db	020H,06DH,065H,061H,06EH,073H,020H,036H
	db	034H,04BH,00DH,00AH,03BH,00DH,00AH,00DH
	db	00AH,03BH,009H,045H,058H,049H,054H,03AH
	db	00DH,00AH,03BH,009H,020H,020H,020H,020H
	db	049H,066H,020H,065H,072H,072H,06FH,072H
	db	020H,064H,065H,074H,065H,063H,074H,065H
	db	064H,00DH,00AH,03BH,009H,009H,043H,061H
	db	072H,072H,079H,020H,053H,065H,074H,00DH
	db	00AH,03BH,009H,009H,020H,020H,020H,061H
	db	06CH,020H,03DH,03DH,020H,065H,072H,072H
	db	06FH,072H,020H,063H,06FH,064H,065H,020H
	db	038H,020H,028H,073H,065H,063H,074H,06FH
	db	072H,020H,06EH,06FH,074H,020H,066H,06FH
	db	075H,06EH,064H,029H,00DH,00AH,00DH,00AH
	db	067H,064H,074H,073H,009H,064H,077H,009H
	db	030H,02CH,030H,02CH,030H,02CH,030H,009H
	db	009H,03BH,020H,067H,064H,074H,020H,030H
	db	020H,03DH,03DH,020H,064H,075H,06DH,06DH
	db	079H,00DH,00AH,009H,064H,077H,009H,030H
	db	02CH,030H,02CH,030H,02CH,030H,009H,009H
	db	03BH,020H,067H,064H,074H,020H,031H,020H
	db	03DH,03DH,020H,047H,044H,054H,020H,073H
	db	065H,067H,020H,028H,049H,06EH,074H,031H
	db	035H,020H,066H,069H,06CH,06CH,073H,020H
	db	069H,06EH,029H,00DH,00AH,00DH,00AH,009H
	db	064H,077H,009H,030H,066H,066H,066H,066H
	db	068H,009H,009H,03BH,020H,067H,064H,074H
	db	020H,032H,020H,06CH,069H,06DH,069H,074H
	db	020H,03DH,020H,036H,035H,035H,033H,035H
	db	00DH,00AH,073H,072H,063H,05FH,06CH,06FH
	db	077H,009H,064H,077H,009H,030H,009H,009H
	db	03BH,020H,067H,064H,074H,020H,032H,020H
	db	06CH,06FH,077H,020H,031H,036H,020H,062H
	db	069H,074H,073H,00DH,00AH,073H,072H,063H
	db	05FH,068H,069H,009H,064H,062H,009H,030H
	db	00DH,00AH,009H,064H,062H,009H,039H,033H
	db	068H,02CH,030H,02CH,030H,009H,009H,03BH
	db	020H,067H,064H,074H,020H,032H,020H,061H
	db	063H,063H,065H,073H,073H,020H,072H,069H
	db	067H,068H,074H,073H,020H,026H,020H,072H
	db	065H,073H,065H,072H,076H,065H,064H,00DH
	db	00AH,00DH,00AH,009H,064H,077H,009H,030H
	db	066H,066H,066H,066H,068H,009H,009H,03BH
	db	020H,067H,064H,074H,020H,033H,020H,06CH
	db	069H,06DH,069H,074H,020H,03DH,020H,036H
	db	035H,035H,033H,035H,00DH,00AH,064H,073H
	db	074H,05FH,06CH,06FH,077H,009H,064H,077H
	db	009H,030H,009H,009H,03BH,020H,067H,064H
	db	074H,020H,033H,020H,06CH,06FH,077H,020H
	db	031H,036H,020H,062H,069H,074H,073H,00DH
	db	00AH,064H,073H,074H,05FH,068H,069H,009H
	db	064H,062H,009H,030H,00DH,00AH,009H,064H
	db	062H,009H,039H,033H,068H,02CH,030H,02CH
	db	030H,009H,009H,03BH,020H,067H,064H,074H
	db	020H,033H,020H,061H,063H,063H,065H,073H
	db	073H,020H,072H,069H,067H,068H,074H,073H
	db	020H,026H,020H,072H,065H,073H,065H,072H
	db	076H,065H,064H,00DH,00AH,00DH,00AH,009H
	db	064H,077H,009H,030H,02CH,030H,02CH,030H
	db	02CH,030H,009H,009H,03BH,020H,067H,064H
	db	074H,020H,034H,020H,03DH,03DH,020H,052H
	db	04FH,04DH,020H,042H,049H,04FH,053H,020H
	db	043H,04FH,044H,045H,020H,028H,049H,06EH
	db	074H,031H,035H,020H,066H,069H,06CH,06CH
	db	073H,020H,069H,06EH,029H,00DH,00AH,009H
	db	064H,077H,009H,030H,02CH,030H,02CH,030H
	db	02CH,030H,009H,009H,03BH,020H,067H,064H
	db	074H,020H,035H,020H,03DH,03DH,020H,073H
	db	074H,061H,063H,06BH,020H,028H,049H,06EH
	db	074H,031H,035H,020H,066H,069H,06CH,06CH
	db	073H,020H,069H,06EH,029H,00DH,00AH,00DH
	db	00AH,072H,06FH,06DH,062H,061H,073H,065H
	db	05FH,06CH,06FH,077H,009H,064H,077H,009H
	db	052H,04FH,04DH,044H,052H,049H,056H,045H
	db	042H,041H,053H,045H,05FH,04CH,04FH,009H
	db	03BH,020H,070H,06FH,069H,06EH,074H,020H
	db	074H,06FH,020H,066H,075H,06CH,06CH,020H
	db	052H,04FH,04DH,020H,061H,064H,064H,072H
	db	065H,073H,073H,00DH,00AH,072H,06FH,06DH
	db	062H,061H,073H,065H,05FH,068H,069H,067H
	db	068H,009H,064H,077H,009H,052H,04FH,04DH
	db	044H,052H,049H,056H,045H,042H,041H,053H
	db	045H,05FH,048H,049H,009H,03BH,020H,061H
	db	073H,020H,06CH,069H,06EH,065H,061H,072H
	db	020H,061H,064H,064H,072H,065H,073H,073H
	db	00DH,00AH,00DH,00AH,078H,066H,065H,072H
	db	05FH,066H,072H,06FH,06DH,05FH,072H,06FH
	db	06DH,03AH,00DH,00AH,009H,061H,064H,064H
	db	009H,062H,078H,02CH,072H,06FH,06DH,062H
	db	061H,073H,065H,05FH,06CH,06FH,077H,009H
	db	03BH,020H,061H,064H,064H,020H,069H,06EH
	db	020H,052H,04FH,04DH,020H,062H,061H,073H
	db	065H,020H,06CH,069H,06EH,065H,061H,072H
	db	020H,061H,064H,064H,072H,065H,073H,073H
	db	00DH,00AH,009H,061H,064H,063H,009H,064H
	db	078H,02CH,072H,06FH,06DH,062H,061H,073H
	db	065H,05FH,068H,069H,067H,068H,00DH,00AH
	db	00DH,00AH,049H,046H,044H,045H,046H,009H
	db	046H,041H,04BH,045H,052H,04FH,04DH,00DH
	db	00AH,00DH,00AH,03BH,009H,02AH,02AH,02AH
	db	02AH,020H,020H,046H,06FH,072H,020H,064H
	db	065H,062H,075H,067H,020H,070H,075H,072H
	db	070H,06FH,073H,065H,073H,02CH,020H,077H
	db	065H,027H,06CH,06CH,020H,061H,06CH,073H
	db	06FH,020H,061H,064H,064H,020H,069H,06EH
	db	020H,074H,068H,065H,020H,06FH,066H,066H
	db	073H,065H,074H,020H,074H,06FH,00DH,00AH
	db	03BH,009H,009H,074H,068H,065H,020H,070H
	db	068H,06FH,06EH,079H,020H,052H,04FH,04DH
	db	020H,069H,06DH,061H,067H,065H,020H,077H
	db	065H,020H,06CH,06FH,061H,064H,020H,061H
	db	073H,020H,070H,061H,072H,074H,020H,06FH
	db	066H,020H,075H,073H,02EH,020H,020H,057H
	db	068H,065H,06EH,00DH,00AH,03BH,009H,009H
	db	070H,068H,079H,073H,069H,063H,061H,06CH
	db	020H,052H,04FH,04DH,020H,068H,061H,072H
	db	064H,077H,061H,072H,065H,020H,062H,065H
	db	063H,06FH,06DH,065H,073H,020H,061H,076H
	db	061H,069H,06CH,061H,062H,06CH,065H,02CH
	db	020H,074H,068H,065H,020H,066H,06FH,06CH
	db	06CH,06FH,077H,069H,06EH,067H,00DH,00AH
	db	03BH,009H,009H,063H,061H,06EH,020H,062H
	db	065H,020H,064H,065H,06CH,065H,074H,065H
	db	064H,02EH,00DH,00AH,00DH,00AH,009H,061H
	db	064H,064H,009H,062H,078H,02CH,06FH,066H
	db	066H,073H,065H,074H,020H,072H,06FH,06DH
	db	05FH,069H,06DH,061H,067H,065H,00DH,00AH
	db	009H,061H,064H,063H,009H,064H,078H,02CH
	db	030H,00DH,00AH,009H,06DH,06FH,076H,009H
	db	061H,078H,02CH,063H,073H,00DH,00AH,009H
	db	072H,06FH,06CH,009H,061H,078H,02CH,031H
	db	00DH,00AH,009H,072H,06FH,06CH,009H,061H
	db	078H,02CH,031H,00DH,00AH,009H,072H,06FH
	db	06CH,009H,061H,078H,02CH,031H,00DH,00AH
	db	009H,072H,06FH,06CH,009H,061H,078H,02CH
	db	031H,00DH,00AH,009H,070H,075H,073H,068H
	db	009H,061H,078H,00DH,00AH,009H,061H,06EH
	db	064H,009H,061H,078H,02CH,030H,066H,066H
	db	066H,030H,068H,00DH,00AH,009H,061H,064H
	db	064H,009H,061H,078H,02CH,062H,078H,00DH
	db	00AH,009H,06DH,06FH,076H,009H,073H,072H
	db	063H,05FH,06CH,06FH,077H,02CH,061H,078H
	db	009H,009H,03BH,020H,073H,061H,076H,065H
	db	020H,06CH,06FH,077H,020H,031H,036H,020H
	db	062H,069H,074H,073H,020H,06FH,066H,020H
	db	073H,06FH,075H,072H,063H,065H,00DH,00AH
	db	009H,070H,06FH,070H,009H,061H,078H,00DH
	db	00AH,009H,061H,064H,063H,009H,061H,06CH
	db	02CH,064H,06CH,00DH,00AH,009H,061H,06EH
	db	064H,009H,061H,06CH,02CH,030H,066H,068H
	db	009H,009H,03BH,020H,06CH,069H,06DH,069H
	db	074H,020H,074H,06FH,020H,06CH,06FH,077H
	db	020H,06DH,065H,067H,020H,066H,06FH,072H
	db	020H,073H,069H,06DH,075H,06CH,061H,074H
	db	069H,06FH,06EH,00DH,00AH,009H,06DH,06FH
	db	076H,009H,073H,072H,063H,05FH,068H,069H
	db	02CH,061H,06CH,00DH,00AH,00DH,00AH,03BH
	db	009H,02AH,074H,068H,069H,073H,020H,069H
	db	073H,020H,074H,068H,065H,020H,065H,06EH
	db	064H,020H,06FH,066H,020H,074H,068H,065H
	db	020H,064H,065H,062H,075H,067H,020H,073H
	db	069H,06DH,075H,06CH,061H,074H,069H,06FH
	db	06EH,020H,063H,06FH,064H,065H,02AH,00DH
	db	00AH,00DH,00AH,045H,04CH,053H,045H,00DH
	db	00AH,009H,06DH,06FH,076H,009H,073H,072H
	db	063H,05FH,06CH,06FH,077H,02CH,020H,062H
	db	078H,00DH,00AH,009H,06DH,06FH,076H,009H
	db	073H,072H,063H,05FH,068H,069H,02CH,020H
	db	064H,06CH,00DH,00AH,00DH,00AH,045H,04EH
	db	044H,049H,046H,020H,03BH,020H,046H,041H
	db	04BH,045H,052H,04FH,04DH,00DH,00AH,00DH
	db	00AH,03BH,009H,04EH,06FH,077H,020H,063H
	db	061H,06CH,063H,075H,06CH,061H,074H,065H
	db	020H,061H,06EH,064H,020H,073H,074H,06FH
	db	072H,065H,020H,074H,068H,065H,020H,064H
	db	065H,073H,074H,069H,06EH,061H,074H,069H
	db	06FH,06EH,020H,061H,064H,064H,072H,065H
	db	073H,073H,00DH,00AH,00DH,00AH,009H,06DH
	db	06FH,076H,009H,061H,078H,02CH,065H,073H
	db	00DH,00AH,009H,072H,06FH,06CH,009H,061H
	db	078H,02CH,031H,00DH,00AH,009H,072H,06FH
	db	06CH,009H,061H,078H,02CH,031H,00DH,00AH
	db	009H,072H,06FH,06CH,009H,061H,078H,02CH
	db	031H,00DH,00AH,009H,072H,06FH,06CH,009H
	db	061H,078H,02CH,031H,00DH,00AH,009H,070H
	db	075H,073H,068H,009H,061H,078H,00DH,00AH
	db	009H,061H,06EH,064H,009H,061H,078H,02CH
	db	030H,066H,066H,066H,030H,068H,00DH,00AH
	db	009H,061H,064H,064H,009H,061H,078H,02CH
	db	064H,069H,00DH,00AH,009H,06DH,06FH,076H
	db	009H,064H,073H,074H,05FH,06CH,06FH,077H
	db	02CH,061H,078H,00DH,00AH,009H,070H,06FH
	db	070H,009H,061H,078H,00DH,00AH,009H,061H
	db	064H,063H,009H,061H,06CH,02CH,030H,00DH
	db	00AH,009H,061H,06EH,064H,009H,061H,06CH
	db	02CH,030H,066H,068H,00DH,00AH,009H,06DH
	db	06FH,076H,009H,064H,073H,074H,05FH,068H
	db	069H,02CH,061H,06CH,00DH,00AH,00DH,00AH
	db	009H,070H,075H,073H,068H,009H,065H,073H
	db	00DH,00AH,009H,070H,075H,073H,068H,009H
	db	073H,069H,00DH,00AH,009H,06DH,06FH,076H
	db	009H,073H,069H,02CH,06FH,066H,066H,073H
	db	065H,074H,020H,067H,064H,074H,073H,00DH
	db	00AH,009H,070H,075H,073H,068H,009H,063H
	db	073H,00DH,00AH,009H,070H,06FH,070H,009H
	db	065H,073H,00DH,00AH,009H,073H,068H,072H
	db	009H,063H,078H,02CH,031H,009H,009H,009H
	db	03BH,020H,063H,06FH,06EH,076H,065H,072H
	db	074H,020H,063H,06FH,075H,06EH,074H,020H
	db	074H,06FH,020H,077H,06FH,072H,064H,073H
	db	00DH,00AH,009H,06AH,06EH,07AH,009H,06EH
	db	06FH,074H,05FH,036H,034H,06BH,00DH,00AH
	db	009H,06FH,072H,009H,063H,068H,02CH,038H
	db	030H,068H,009H,009H,009H,03BH,020H,066H
	db	06FH,072H,063H,065H,020H,036H,034H,06BH
	db	020H,074H,06FH,020H,062H,065H,020H,033H
	db	032H,04BH,020H,077H,06FH,072H,064H,073H
	db	02CH,020H,06EH,06FH,074H,020H,07AH,065H
	db	072H,06FH,00DH,00AH,06EH,06FH,074H,05FH
	db	036H,034H,06BH,03AH,00DH,00AH,009H,06DH
	db	06FH,076H,009H,061H,068H,02CH,038H,037H
	db	068H,00DH,00AH,009H,069H,06EH,074H,009H
	db	031H,035H,068H,00DH,00AH,009H,070H,06FH
	db	070H,009H,073H,069H,00DH,00AH,009H,070H
	db	06FH,070H,009H,065H,073H,00DH,00AH,009H
	db	06DH,06FH,076H,009H,061H,06CH,02CH,030H
	db	00DH,00AH,009H,06AH,06EH,063H,009H,06EH
	db	06FH,05FH,064H,069H,073H,06BH,05FH,065H
	db	072H,072H,06FH,072H,00DH,00AH,009H,06DH
	db	06FH,076H,009H,061H,06CH,02CH,038H,009H
	db	009H,009H,03BH,020H,061H,06CH,06CH,020H
	db	065H,072H,072H,06FH,072H,073H,020H,061H
	db	072H,065H,020H,074H,079H,070H,065H,020H
	db	038H,00DH,00AH,06EH,06FH,05FH,064H,069H
	db	073H,06BH,05FH,065H,072H,072H,06FH,072H
	db	03AH,00DH,00AH,009H,072H,065H,074H,00DH
	db	00AH,00DH,00AH,049H,046H,044H,045H,046H
	db	009H,046H,041H,04BH,045H,052H,04FH,04DH
	db	00DH,00AH,072H,06FH,06DH,05FH,069H,06DH
	db	061H,067H,065H,03AH,00DH,00AH,009H,069H
	db	06EH,063H,06CH,075H,064H,065H,009H,072H
	db	06FH,06DH,038H,06BH,02EH,069H,06EH,063H
	db	00DH,00AH,045H,04EH,044H,049H,046H,020H
	db	03BH,020H,046H,041H,04BH,045H,052H,04FH
	db	04DH,00DH,00AH,00DH,00AH,062H,069H,06FH
	db	073H,05FH,064H,061H,074H,061H,009H,045H
	db	04EH,044H,053H,00DH,00AH,009H,065H,06EH
	db	064H,00DH,00AH,01AH,00DH,00AH,0B2H,083H
	db	02BH,013H,02AH,07FH,065H,066H,000H,000H
	db	048H,045H,04CH,050H,020H,020H,020H,020H
	db	043H,042H,020H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,084H,005H
	db	021H,013H,037H,07FH,07DH,02BH,000H,000H
	db	0B9H,000H,004H,0F7H,0F1H,03BH,006H,0DFH
	db	004H,074H,005H,0C6H,006H,0E4H,004H,002H
	db	0F8H,0C3H,000H,000H,000H,000H,050H,052H
	db	02EH,08BH,016H,066H,004H,0B4H,047H,0CDH
	db	067H,00AH,0E4H,074H,018H,080H,0FCH,082H
	db	074H,0EEH,05AH,05AH,0B0H,002H,080H,0FCH
	db	08CH,074H,007H,080H,0FCH,08DH,077H,002H
	db	0B0H,00CH,0F9H,0EBH,003H,0F8H,05AH,058H
	db	073H,001H,0C3H,051H,0B9H,000H,040H,0F7H
	db	0F1H,08BH,0F2H,08BH,0D0H,059H,053H,051H
	db	08BH,0C7H,005H,001H,000H,0D1H,0D8H,049H
	db	003H,0C1H,0D1H,0E8H,0D1H,0E8H,0D1H,0E8H
	db	08CH,0C3H,003H,0C3H,02BH,006H,084H,001H
	db	072H,018H,0B9H,004H,000H,08BH,0EFH,0D3H
	db	0EDH,003H,0EBH,02BH,02EH,084H,001H,072H
	db	006H,081H,0FDH,000H,010H,073H,003H,0E9H
	db	0C6H,000H,059H,05BH,033H,0EDH,053H,08BH
	db	0C2H,08BH,0DEH,0D1H,0EBH,051H,003H,0D9H
	db	08BH,0D3H,081H,0E2H,0FFH,01FH,0B1H,00DH
	db	0D3H,0EBH,00BH,0D2H,074H,001H,043H,08BH
	db	0CBH,08BH,0D8H,083H,0F9H,004H,076H,007H
	db	08BH,0EAH,049H,058H,02BH,0C2H,050H,08BH
	db	016H,066H,004H,0B8H,000H,044H,050H,058H
	db	050H,053H,052H,0CDH,067H,05AH,05BH,00AH
	db	0E4H,075H,06EH,043H,058H,0FEH,0C0H,050H
	db	0E2H,0EDH,058H,059H,058H,050H,00AH,0E4H
	db	074H,00DH,006H,057H,08BH,0FEH,05EH,01FH
	db	02EH,08EH,006H,084H,001H,0EBH,004H,08EH
	db	01EH,084H,001H,0F3H,0A5H,00BH,0EDH,075H
	db	024H,058H,0F8H,050H,09CH,02EH,08BH,016H
	db	066H,004H,0B4H,048H,0CDH,067H,00AH,0E4H
	db	074H,010H,080H,0FCH,082H,074H,0EEH,080H
	db	0FCH,08EH,074H,006H,05AH,05AH,0B0H,00CH
	db	0F9H,0C3H,09DH,058H,0C3H,02EH,08BH,016H
	db	066H,004H,0B8H,000H,044H,053H,052H,0CDH
	db	067H,05AH,05BH,00AH,0E4H,075H,01CH,058H
	db	050H,00AH,0E4H,074H,004H,033H,0FFH,0EBH
	db	002H,033H,0F6H,08BH,0CDH,0F3H,0A5H,0EBH
	db	0B8H,080H,0FCH,082H,074H,081H,083H,0C4H
	db	006H,0EBH,008H,080H,0FCH,082H,074H,0D2H
	db	083H,0C4H,002H,0B0H,002H,0F9H,0EBH,0A3H
	db	032H,0C0H,08BH,01EH,084H,001H,081H,0FDH
	db	000H,010H,073H,006H,081H,0FDH,000H,004H
	db	073H,006H,0B0H,003H,081H,0C3H,000H,00CH
	db	081H,0C5H,000H,008H,08BH,0CDH,08EH,0DBH
	db	05DH,05BH,051H,033H,0C9H,081H,0FDH,000H
	db	040H,076H,007H,08BH,0CDH,0BDH,000H,040H
	db	02BH,0CDH,051H,053H,052H,0B9H,000H,040H
	db	02BH,0CEH,0D1H,0E9H,03BH,0CDH,072H,002H
	db	08BH,0CDH,00AH,0FFH,074H,008H,01EH,006H
	db	056H,08BH,0F7H,05FH,01FH,007H,0FCH,02BH
	db	0E9H,08BH,0DAH,0B4H,044H,02EH,08BH,016H
	db	066H,004H,050H,058H,050H,053H,052H,0CDH
	db	067H,05AH,05BH,00AH,0E4H,074H,00BH,080H
	db	0FCH,082H,074H,0EFH,058H,0B0H,002H,0F9H
	db	0EBH,002H,0F8H,058H,073H,007H,083H,0C4H
	db	006H,0F9H,0E9H,0D5H,000H,0F3H,0A5H,00BH
	db	0EDH,074H,01AH,05AH,05BH,042H,053H,052H
	db	0B9H,000H,020H,03BH,0CDH,076H,002H,08BH
	db	0CDH,00AH,0FFH,075H,004H,033H,0F6H,0EBH
	db	0B6H,033H,0FFH,0EBH,0B2H,05AH,05BH,05DH
	db	058H,00BH,0EDH,075H,003H,0E9H,0A9H,000H
	db	050H,033H,0C9H,051H,0F8H,052H,050H,09CH
	db	02EH,08BH,016H,066H,004H,0B4H,048H,0CDH
	db	067H,00AH,0E4H,074H,011H,080H,0FCH,082H
	db	074H,0EEH,080H,0FCH,08EH,074H,007H,05AH
	db	05AH,0B0H,00CH,0F9H,0EBH,002H,09DH,058H
	db	05AH,073H,004H,083H,0C4H,004H,0C3H,050H
	db	052H,02EH,08BH,016H,066H,004H,0B4H,047H
	db	0CDH,067H,00AH,0E4H,074H,018H,080H,0FCH
	db	082H,074H,0EEH,05AH,05AH,0B0H,002H,080H
	db	0FCH,08CH,074H,007H,080H,0FCH,08DH,077H
	db	002H,0B0H,00CH,0F9H,0EBH,003H,0F8H,05AH
	db	058H,073H,004H,083H,0C4H,004H,0C3H,02EH
	db	08BH,00EH,084H,001H,03DH,000H,004H,072H
	db	009H,03DH,000H,010H,073H,004H,033H,0C0H
	db	0EBH,006H,0B0H,003H,081H,0C1H,000H,00CH
	db	00AH,0FFH,075H,01BH,08EH,0D9H,0B9H,000H
	db	040H,03BH,0F1H,076H,003H,042H,033H,0F6H
	db	02BH,0CEH,0D1H,0E9H,053H,052H,03BH,0CDH
	db	076H,002H,08BH,0CDH,0E9H,010H,0FFH,08EH
	db	0C1H,0B9H,000H,040H,03BH,0F9H,072H,003H
	db	033H,0FFH,042H,02BH,0CFH,0D1H,0E9H,0EBH
	db	0E3H,0F8H,050H,09CH,02EH,08BH,016H,066H
	db	004H,0B4H,048H,0CDH,067H,00AH,0E4H,074H
	db	011H,080H,0FCH,082H,074H,0EEH,080H,0FCH
	db	08EH,074H,007H,05AH,05AH,0B0H,00CH,0F9H
	db	0EBH,002H,09DH,058H,0C3H,000H,000H,050H
	db	052H,02EH,08BH,016H,066H,004H,0B4H,045H
	db	0CDH,067H,080H,0FCH,082H,074H,0F2H,05AH
	db	058H,0C3H,098H,08FH,000H,000H,00EH,007H
	db	0BEH,073H,00FH,0BFH,082H,001H,0B9H,0E6H
	db	002H,0F3H,0A4H,0BEH,09CH,00FH,0BFH,08DH
	db	004H,0B9H,051H,000H,0F3H,0A4H,081H,03EH
	db	0EEH,004H,000H,005H,072H,00CH,006H,0C4H
	db	01EH,0ACH,000H,026H,08BH,047H,010H,007H
	db	0EBH,006H,0CDH,012H,0B1H,006H,0D3H,0E0H
	db	08BH,0D8H,0A3H,0D2H,00EH,00EH,01FH,0FEH
	db	006H,0F0H,004H,0C6H,006H,0E4H,004H,002H
	db	0B8H,06AH,004H,005H,00FH,000H,0B1H,004H
	db	0D3H,0E8H,08CH,0CAH,003H,0C2H,050H,0B9H
	db	010H,000H,0F7H,0E1H,0A3H,082H,001H,089H
	db	016H,084H,001H,058H,08BH,016H,0DFH,004H
	db	0F7H,0C2H,000H,0FCH,075H,008H,0B1H,006H
	db	0D3H,0E2H,003H,0C2H,073H,002H,0EBH,021H
	db	08BH,016H,0D2H,00EH,081H,03EH,0EEH,004H
	db	000H,005H,073H,004H,081H,0EAH,000H,00CH
	db	072H,00FH,03BH,0C2H,077H,00BH,0C7H,006H
	db	0E8H,004H,000H,000H,0A3H,0EAH,004H,0F8H
	db	0C3H,0BAH,0ACH,015H,0E8H,087H,0F5H,00EH
	db	01FH,0F9H,0C3H,000H,000H,000H,000H,003H
	db	006H,082H,001H,013H,016H,084H,001H,051H
	db	0B9H,010H,000H,0F7H,0F1H,059H,00AH,0FFH
	db	074H,00CH,006H,01FH,08BH,0F7H,08EH,0C0H
	db	08BH,0FAH,0F3H,0A5H,0F8H,0C3H,08EH,0D8H
	db	08BH,0F2H,0EBH,0F6H,056H,057H,050H,053H
	db	051H,052H,01EH,006H,00EH,01FH,0A1H,082H
	db	001H,08BH,016H,084H,001H,02DH,000H,004H
	db	083H,0DAH,000H,0B9H,010H,000H,0F7H,0F1H
	db	08EH,0D8H,08BH,0F2H,08BH,0FEH,083H,0C7H
	db	040H,0B9H,05FH,000H,0F7H,005H,001H,000H
	db	074H,014H,0F7H,005H,002H,000H,074H,009H
	db	083H,07DH,002H,001H,075H,003H,083H,025H
	db	0FDH,083H,0C7H,00AH,0E2H,0E6H,007H,01FH
	db	05AH,059H,05BH,058H,05FH,05EH,0C3H,052H
	db	041H,04DH,044H,072H,069H,076H,065H,020H
	db	069H,073H,020H,061H,020H,074H,072H,061H
	db	064H,065H,06DH,061H,072H,06BH,020H,06FH
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\ptime.asm ===
;
;------------------------------------------------------------------------------
;M074 - ptime.asm added, containing clock/time routines for power.asm.
;
;   09/11/91  SMR	M077: B#2669. Registered POWER's 2f channels in mult.inc
;
;   09/25/91  NSM	M090: B#2729. Try to update our time from CMOS under 
;			WIN ENH mode once in 1024 I1c ticks. 
;			(approx. once in a minute)
;			This update happens only if DOS calls us for time and
;			does not exactly happen once in a minute.
;
;			(this is changed to 20 secs from 1 minute)
;
;  11/26/91   NSM	M101: We lose date sometimes under windows. To fix this
;			do Int 1a's to get tick count instead of looking at 40:
;			6ch and if we get rollover, then go & update date 
;			and time from CMOS.
;------------------------------------------------------------------------------
;
;

	.xlist

	include version.inc     ; set build flags

IFDEF   POWER			; generate code only if power management
				; is enabled

IFNDEF  POWERALONE              ; segment declarations for resident version

	include biosseg.inc     ; establish bios segment structure

ELSE                            ; segment declarations for standalonde version

.SEQ
Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

; following segment definitions used by transient part of code

ENDIF

	include msequ.inc
	include devsym.inc
	include bpb.inc
	include ioctl.inc
	include	mult.inc		; M077
	include power.inc

IFDEF INCL_APM
	include	apmequ.inc		; M001
ENDIF

break   macro
	endm

	include error.inc
	.list
	

	include msgroup.inc     ; define Bios_Data segment

	extrn	month_table:word

IFDEF   POWERALONE                      ; standalone device driver version
Bios_Res        dw      Bios_Code       ; Our code segment address
ELSE                                    ; resident BIOS version
	extrn   Bios_Res:word           ; Code segment address supplied externally
	extrn	ttticks:dword		; far ptr to time_to_ticks routine
	extrn	bintobcd:dword		; ptr to bin_to_bcd routine

IFDEF	INCL_APM
	extrn	Check_and_Init_APM_Ptr:dword	; ptr to APM init routine
ENDIF	;INCL_APM

	extrn	P_UpdFromCMOS_Ptr:dword	; ptr to CMOS clock read	; M081

ENDIF	;NOT POWERALONE

	extrn	daycnt:word	; extrns for both resident and stand-alone
	extrn	daycnt2:word	; versions
	extrn	base_century:byte
	extrn	base_year:byte
	extrn	month_tab:byte
	extrn	bin_date_time:byte
	extrn	CMOSUpdFlg:byte
	extrn	CMOSPollCount:word

	tocode
IFDEF	POWERALONE			; stand alone version

Bios_Data_Word  dw      Bios_Data               ; Our data segment

bintobcd	proc	near	;for real time clock support

;convert a binary input in al (less than 63h or 99 decimal)
;into a bcd value in al.  ah destroyed.

	push	cx

	aam				; M048
	mov	cl, 4			; M048
	shl	ah, cl			; M048
	or	al, ah			; M048

	pop	cx
	ret

bintobcd	endp

ELSE				; resident version
	extrn	Bios_Data_word:word

ENDIF

	public	tim_read
	public	tim_writ
;--------------------------------------------------------------------
;
; tim_writ sets the current time
;
; on entry es:[di] has the current time:
;
;	number of days since 1-1-80	(word)
;	minutes (0-59)			(byte)
;	hours (0-23)			(byte)
;	hundredths of seconds (0-99)	(byte)
;	seconds (0-59)			(byte)
;
; each number has been checked for the correct range.
;
tim_writ proc	near
	assume	ds:Bios_Data
	mov	ax,word ptr es:[di]
	push	ax		;daycnt. we need to set this at the very
				;  end to avoid tick windows.

;	Set hardware clock time.

	mov	al,es:[di+3]		;get binary hours
	call	bintobcd		;convert to bcd
	mov	ch,al			;ch = bcd hours
	mov	al,es:[di+2]		;get binary minutes
	call	bintobcd		;convert to bcd
	mov	cl,al			;cl = bcd minutes
	mov	al,es:[di+5]		;get binary seconds
	call	bintobcd		;convert to bcd
	mov	dh,al			;dh = bcd seconds
	mov	dl,0			;dl = 0 (st) or 1 (dst)
	cli				;turn off timer
	mov	ah,03h			;set rtc time
	int	1ah			;call rom bios clock routine
	sti

	mov	cx,word ptr es:[di+2]
	mov	dx,word ptr es:[di+4]
IFDEF POWERALONE
	call	time_to_ticks			
ELSE
	call	ttticks
ENDIF
				;cx:dx now has time in ticks
	cli			; turn off timer
	mov	ah, 1		; command is set time in clock
	int	1ah		; call rom-bios clock routines
	pop	[daycnt]
	sti

	call	daycnttoday	; convert to bcd format
	cli			; turn off timer
	mov	ah,05h		; set rtc date
	int	1ah		; call rom-bios clock routines
	sti

	clc
	ret
tim_writ endp

;
; gettime reads date and time
; and returns the following information:

;	es:[di]  =count of days since 1-1-80
;	es:[di+2]=hours
;	es:[di+3]=minutes
;	es:[di+4]=seconds
;	es:[di+5]=hundredths of seconds

tim_read proc	near

; M090 BEGIN - See if we have to update our time from CMOS before 
; returning date and time to caller.

	cmp	[CMOSUpdFlg],0		; M090 do we need to update from CMOS
	je	tr_NoCMOSUpdate		; 

tr_CMOSUpd:				; M101
IFDEF	POWERALONE			; M081
	call	far ptr P_UpdFromCMOS
ELSE
	call    P_UpdFromCMOS_ptr   	; M074 update our date and time
					; from CMOS RTC
ENDIF
	mov	[CMOSPollCount],MAXCMOSPOLLCOUNT
	mov	[CMOSUpdFlg],0		; 
; M090 END

tr_NoCMOSUpdate:
; M101	- BEGIN - get tick count through 1a instead of looking at 40:6ch
; and check for rollover
	mov	ax,0			; get tick count
	int	1ah			; cx:dx = tick count	
	or	al,al			; al != 0 if midnight passed	
	jnz	tr_CMOSUpd		; rollover; update date and time
; M101	- END
	mov	si,[daycnt]

; we now need to convert the time in tick to the time in 100th of
; seconds.  the relation between tick and seconds is:
;
;		 65536 seconds
;	       ----------------
;		1,193,180 tick
;
; to get to 100th of second we need to multiply by 100. the equation is:
;
;	ticks from clock  * 65536 * 100
;      ---------------------------------  = time in 100th of seconds
;		1,193,180
;
; fortunately this fromula simplifies to:
;
;	ticks from clock * 5 * 65,536
;      --------------------------------- = time in 100th of seconds
;		59,659
;
; the calculation is done by first multipling tick by 5. next we divide by
; 59,659.  in this division we multiply by 65,536 by shifting the dividend
; my 16 bits to the left.
;
; start with ticks in cx:dx
; multiply by 5

	mov	ax,cx
	mov	bx,dx
	shl	dx,1
	rcl	cx,1		;times 2
	shl	dx,1
	rcl	cx,1		;times 4
	add	dx,bx
	adc	ax,cx		;times 5
	xchg	ax,dx		
	

; now have ticks * 5 in dx:ax
; we now need to multiply by 65,536 and divide by 59659 d.

	mov	cx,59659	; get divisor
	div	cx
				; dx now has remainder
				; ax has high word of final quotient
	mov	bx,ax		; put high work if safe place
	xor	ax,ax		; this is the multiply by 65536
	div	cx		; bx:ax now has time in 100th of seconds


;rounding based on the remainder may be added here
;the result in bx:ax is time in 1/100 second.

	mov	dx,bx
	mov	cx,200		;extract 1/100's

;division by 200 is necessary to ensure no overflow--max result
;is number of seconds in a day/2 = 43200.

	div	cx
	cmp	dl,100		;remainder over 100?
	jb	noadj
	sub	dl,100		;keep 1/100's less than 100
noadj:
	cmc			;if we subtracted 100, carry is now set
	mov	bl,dl		;save 1/100's

;to compensate for dividing by 200 instead of 100, we now multiply
;by two, shifting a one in if the remainder had exceeded 100.

	rcl	ax,1
	mov	dl,0
	rcl	dx,1
	mov	cx,60		;divide out seconds
	div	cx
	mov	bh,dl		;save the seconds
	div	cl		;break into hours and minutes
	xchg	al,ah

;time is now in ax:bx (hours, minutes, seconds, 1/100 sec)

	push	ax
	mov	ax,si		; daycnt
	stosw
	pop	ax
	stosw
	mov	ax,bx
	stosw
	clc
	ret

tim_read endp

	assume	es:nothing

; the following routine is executed at resume time when the system
; powered on after suspension. it reads the real time clock and
; resets the system time and date
;
; This can be patched to be the INT6C vector so that this can be
; used by other people to update DOS time from CMOS (after taking
; care for IRET)

	public	P_UpdFromCMOS
P_UpdFromCMOS	proc	far

	assume	ds:nothing
	push	ds
	mov	ds,cs:Bios_Data_Word
	assume ds:Bios_Data

	call	read_real_date		; get the date from the clock
PUFC_UpdDate:				; M101
	mov	ds:daycnt,si		; update our copy of date
	call	read_real_time		; get the time from the rtc
	cli
	mov	ah,01h			; command to set the time
	int	1ah			; call rom-bios time routine
	sti
; M101 BEGIN - check back to see if date changed when we were reading the
; time; if so, update date and time all over again ( Paranoid?)
	call	read_real_date		; get the date from the clock

; BUGBUG- nagara - Store the ret.value of date from int 1a in this
; procedure read_real_date so that at the end we don't really have to
; call read_real_date again; we just need to call int 1a and compare the
; date registers against the stored values of these registers.

	cmp	si,ds:daycnt		; is the date changed ?
	jne	PUFC_UpdDate		; yes, go back and set the new date
; M101 END
	pop	ds
	ret	

P_UpdFromCMOS	endp


;************************************************************************
;
;   read_real_date reads real-time clock for date and returns the number
;   of days elapsed since 1-1-80 in si
;
read_real_date proc near
	assume	ds:Bios_Data,es:nothing

	push	ax
	push	cx
	push	dx

	xor	ah,ah			; throw away clock roll over
	int	1ah

	pop	dx
	pop	cx
	pop	ax			; cas - bad code!

	push	ax
	push	bx
	push	cx
	push	dx

	mov	daycnt2,1	; real time clock error flag (+1 day)
	mov	ah,4		; read date function code
	int	1ah		; read real-time clock
	jnc	read_ok 	; jmp success
	jmp	r_d_ret 	; jmp error

read_ok:			; ******* get bcd values in binary *****
	mov	word ptr bin_date_time+0,cx  ; store as hex value
	mov	word ptr bin_date_time+2,dx  ; ...

	mov	daycnt2,2	; read of r-t clock successful
	call	bcd_verify	; verify bcd values in range
	jc	r_d_ret 	; jmp some value out of range
	mov	daycnt2,3	; read of r-t clock successful
	call	date_verify	; verify date values in range
	jc	r_d_ret 	; jmp some value out of range
	mov	daycnt2,0	; verify successful
	call	in_bin		; convert date to binary
				; ******* years since 1-1-80 *********
	mov	al,byte ptr bin_date_time    ; get years into century
	cbw				     ;
	cmp	byte ptr bin_date_time+1,20  ; 20th century?
	jnz	century_19		     ; jmp no
	add	ax,100		; add in a century
century_19:			;
	sub	ax,80		; subtract off 1-1-80
	mov	cl,4		; leap year every 4
	div	cl		; al= # leap year blocks, ah= remainder
	mov	bl,ah		; save odd years
	cbw			; zero ah
	mov	cx,366+3*365	; # of days in leap year blocks
	mul	cx		; dx:ax is result
	mov	daycnt2,ax	; save count of days
	mov	al,bl		; get odd years count
	cbw			;
	or	ax,ax		; is ax= 0?
	jz	leap_year	; jmp if none
	mov	cx,365		; days in year
	mul	cx		; dx:ax is result
	add	daycnt2,ax	; add on days in odd years
	jmp	short leap_adjustment ; account for leap year
leap_year:			; possibly account for a leap day
	cmp	byte ptr bin_date_time+3,2 ; is month february
	jbe	no_leap_adjustment ; jan or feb. no leap day yet.
leap_adjustment:		; account for leap day
	inc	daycnt2
no_leap_adjustment:		; ******* get days of month *******
	mov	cl,byte ptr bin_date_time+2
	xor	ch,ch
	dec	cx		; because of offset from day 1, not day 0
	add	daycnt2,cx	 ; ******* get days in months preceeing *****
	mov	cl,byte ptr bin_date_time+3   ; get month
	xor	ch,ch
	dec	cx		; january starts at offset 0
	shl	cx,1		; word offset
	mov	si,offset month_table	; beginning of month_table
	add	si,cx		; point into month table
	mov	ax,word ptr [si]; get # days in previous months
	add	daycnt2,ax
r_d_ret:
	mov	si,daycnt2	 ; result in si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret

r_t_retj:
	xor	cx,cx
	xor	dx,dx
	jmp	short r_t_ret

read_real_date endp

;--------------------------------------------------------------------

; read_real_time reads the time from the rtc. on exit, it has the number of
; ticks (at 18.2 ticks per sec.) in cx:dx.

read_real_time proc near
	assume	ds:Bios_Data,es:nothing	

	mov	ah,2
	int	1ah
	jc	r_t_retj

oktime:
	mov	word ptr bin_date_time,cx	; hours + minutes
	mov	byte ptr bin_date_time+3,dh	; seconds
	mov	byte ptr bin_date_time+2,0	; unused for time

	call	bcd_verify
	jc	r_t_retj
	call	time_verify
	jc	r_t_retj

	call	in_bin
	mov	cx,word ptr bin_date_time
	mov	dx,word ptr bin_date_time+2

; get time in ticks in cx:dx

IFDEF POWERALONE
	call	time_to_ticks			
ELSE
	call	ttticks
ENDIF
r_t_ret:
	ret

read_real_time endp

;--------------------------------------------------------------------

;   in_bin converts bin_date_time values from bcd to bin

in_bin	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	al,byte ptr bin_date_time+0  ; years or minutes 
	call	bcd_to_bin
	mov	byte ptr bin_date_time+0,al

	mov	al,byte ptr bin_date_time+1  ;century or hours
	call	bcd_to_bin
	mov	byte ptr bin_date_time+1,al

	mov	al,byte ptr bin_date_time+2  ; days (not used for time)
	call	bcd_to_bin
	mov	byte ptr bin_date_time+2,al

	mov	al,byte ptr bin_date_time+3  ; months or seconds
	call	bcd_to_bin
	mov	byte ptr bin_date_time+3,al

	ret

in_bin	endp

;--------------------------------------------------------------------

;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
;   a binary representation in al
;   ah is destroyed

bcd_to_bin proc	near
	assume	ds:nothing,es:nothing

	mov	ah, al		; M048
	and	al, 0fh		; M048
	mov	cl, 4		; M048
	shr	ah, cl		; M048
	aad			; M048
	ret

bcd_to_bin endp

;--------------------------------------------------------------------

;   date_verify loosely checks bcd date values to be in range in bin_date_time

date_verify proc near
	assume	ds:Bios_Data,es:nothing

	cmp	byte ptr bin_date_time+1,20h  ; century check
	ja	date_error		      ;	error
	jz	century_20		      ; jmp in 20th century

	cmp	byte ptr bin_date_time+1,19h  ; century check
	jb	date_error		      ;  error
	cmp	byte ptr bin_date_time+0,80h  ; year check
	jb	date_error		      ;  error

century_20:
	cmp	byte ptr bin_date_time+0,99h  ; year check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+3,12h  ; month check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+3,00h  ; month check
	jbe	date_error		      ;  error
	cmp	byte ptr bin_date_time+2,31h  ; day check
	ja	date_error		      ;  error
	cmp	byte ptr bin_date_time+2,00h  ; day check
	jbe	date_error		      ;  error
	clc				      ; set success flag
	ret
date_error:
	stc				      ; set error flag
	ret

date_verify endp

;--------------------------------------------------------------------

; time_verify very loosely checks bcd date values to be in range in bin_date_time

time_verify proc near
	assume	ds:Bios_Data,es:nothing

	cmp	byte ptr bin_date_time+1,24h
	ja	time_error
	cmp	byte ptr bin_date_time+0,59h
	ja	time_error
	cmp	byte ptr bin_date_time+3,59h
	ja	time_error

	clc
	ret

time_error:
	stc
	ret

time_verify endp

;--------------------------------------------------------------------

;   bcd_verify checks values in bin_date_time to be valid
;   bcd numerals.  carry set if any nibble out of range

bcd_verify proc near
	assume	ds:Bios_Data,es:nothing

	mov	cx,4		; 4 bytes to check
	mov	bx,offset bin_date_time
bv_loop:
	mov	al,[bx] 	; get a bcd number (0..99)
	mov	ah,al
	and	ax,0f00fh	; 10's place in high ah, 1's in al
	cmp	al,10		; is 1's place in range?
	ja	bv_error	; jmp out of range

	shr	ah,1		; swap nibbles
	shr	ah,1
	shr	ah,1
	shr	ah,1
	and	ah,0fh		; get rid of any erroneous bits
	cmp	ah,10		; is 10's place in range
	ja	bv_error	; jmp out of range

	inc	bx		; next byte
	dec	cx
	jnz	bv_loop

	clc			; set success flag
	ret

bv_error:
	stc			; set error flag
	ret

bcd_verify endp

;--------------------------------------------------------------------
daycnttoday	proc	near	; for real time clock support

;entry: [daycnt] = number of days since 1-1-80
;
;return: ch - centry in bcd
;	 cl - year in bcd
;	 dh - month in bcd
;	 dl - day in bcd

	push	di
	mov	di,daycnt
	cmp	di,(365*20+(20/4))	;# of days from 1-1-1980 to 1-1-2000
	jae	century20

	mov	base_century,19
	mov	base_year,80
	jmp	short years

century20:				;20th century
	mov	base_century,20
	mov	base_year,0
	sub	di,(365*20+(20/4))	;adjust daycnt
years:
	xor	dx,dx
	mov	ax,di
	mov	bx,(366+365*3)		;# of days in a leap year block
	div	bx			;ax = # of leap block, dx = daycnt
	mov	di,dx			;save daycnt left

	mov	bl,4
	mul	bl			;ax = # of years. less than 100 years!
	add	base_year,al		;so, ah = 0. adjust year accordingly.
	inc	di			;set daycnt to 1 base
	cmp	di,366			;the daycnt here is the remainder of the leap year block.
	jbe	leapyear		;so, it should within 366+355+355+355 days.
	inc	base_year		;first if daycnt <= 366, then leap year
	sub	di,366			;else daycnt--, base_year++;
					;and the next three years are regular years.
	mov	cx,3
regularyear:
	cmp	di,365			;for(i=1; i>3 or daycnt <=365;i++)
	jbe	yeardone		;{if (daycnt > 365)
	inc	base_year		;  { daycnt -= 365
	sub	di,365			;  }
	loop	regularyear		;}

;	should never fall through loop

leapyear:
	mov	byte ptr month_tab+1,29 ;leap year. change the month table.
yeardone:
	xor	bx,bx
	xor	dx,dx
	mov	ax,di
	mov	si,offset month_tab
	mov	cx,12
months:
	inc	bl
	mov	dl,byte ptr ds:[si]	;compare daycnt for each month until fits
	cmp	ax,dx			;dh=0.
	jbe	month_done

	inc	si			;next month
	sub	ax,dx			;adjust daycnt
	loop	months

;	should never fall through loop

month_done:
	mov	byte ptr month_tab+1,28 ;restore month table value
	mov	dl,bl
	mov	dh,base_year
	mov	cl,base_century 	;now, al=day, dl=month,dh=year,cl=century
	call	bintobcd		;oh my!!! to save 15 bytes, bin_to_bcd proc
					;was relocated seperately from daycnt_to_day proc.
	xchg	dl,al			;dl = bcd day, al = month
	call	bintobcd

	xchg	dh,al			;dh = bcd month, al = year
	call	bintobcd

	xchg	cl,al			;cl = bcd year, al = century
	call	bintobcd

	mov	ch,al			;ch = bcd century
	pop	di			;restore original value
	ret
daycnttoday	endp

IFDEF	POWERALONE		; needed only for standalone version
				; for resident version use the one in 
				; mschar.asm
;--------------------------------------------------------------------
; convert time to ticks
; input : time in cx and dx
; ticks returned in cx:dx

time_to_ticks proc near

; first convert from hour,min,sec,hund. to
; total number of 100th of seconds

	mov	al,60
	mul	ch		;hours to minutes
	mov	ch,0
	add	ax,cx		;total minutes
	mov	cx,6000 	;60*100
	mov	bx,dx		;get out of the way of the multiply
	mul	cx		;convert to 1/100 sec
	mov	cx,ax
	mov	al,100
	mul	bh		;convert seconds to 1/100 sec
	add	cx,ax		;combine seconds with hours and min.
	adc	dx,0		;ripple carry
	mov	bh,0
	add	cx,bx		;combine 1/100 sec
	adc	dx,0

;	dx:cx is time in 1/100 sec

	xchg	ax,dx
	xchg	ax,cx		;now time is in cx:ax
	mov	bx,59659
	mul	bx		;multiply low half
	xchg	dx,cx
	xchg	ax,dx		;cx->ax, ax->dx, dx->cx
	mul	bx		;multiply high half
	add	ax,cx		;combine overlapping products
	adc	dx,0
	xchg	ax,dx		;ax:dx=time*59659
	mov	bx,5
	div	bl		;divide high half by 5
	mov	cl,al
	mov	ch,0
	mov	al,ah		;remainder of divide-by-5
	cbw
	xchg	ax,dx		;use it to extend low half
	div	bx		;divde low half by 5
	mov	dx,ax
				; cx:dx is now number of ticks in time
	ret
time_to_ticks endp
ENDIF
Bios_Code	ends
ENDIF
	END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msint13.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	MS-DOS BIOS Int 13 & int 2f handler


	include version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

	include	msequ.inc
	include	biostruc.inc
	include	bpb.inc
	include	msbds.inc

	include	msgroup.inc	; establish Bios_Data segment

multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2

;SR;
; Include file for WIN386 support
;
	include win386.inc


;	Most of the disk routines keep es:[di] set up pointing to the
;	  currently selected bds.  This is often assumed to be the standard
;	  operating environment and in some cases may not be mentioned in
;	  the subroutine headers where it will be assumed.

	extrn	call_orig13:far		; M030
	extrn	prevoper:word
	extrn	secondary_model_byte:byte
	extrn	orig13:dword
	extrn	start_bds:dword
	extrn	fhave96:byte
	extrn	ec35_flag:byte
	extrn	model_byte:byte
	extrn	number_of_sec:byte
	extrn	disksector:byte
	extrn	old13:dword
	extrn	media_set_for_format:byte

	extrn	i2f_dskentry:far

	extrn	ptrsav:dword
	extrn	SysinitPresent:byte
	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword

;SR; 
;New variables for Win386 support
;
	extrn	IsWin386:byte
	extrn	Win386_SI:byte
	extrn	SI_Next:dword


; close data, open Bios_code segment

	tocode

	extrn	Bios_Data_Word:word
	extrn	set_changed_dl:near
	extrn	install_bds:near

;	int 2f function 13h allows the user to change the orig13 int_13 vector
;	after booting.	this allows testing and implementation of custom int_13
;	handlers, without giving up ms-dos error recovery
;	entry:	ds:dx	== addr. of new int_13 handler
;		es:bx	== addr. of new int_13 vector used by warm boot (int19)
;	exit:	orig13	== address of new int_13 handler
;		ds:dx	== old orig13 value
;		es:bx	== old old13  value
;
; int 2f handler for external block drivers to communicate with the internal
; block driver in msdisk. the multiplex number chosen is 8. the handler
; sets up the pointer to the request packet in [ptrsav] and then jumps to
; dsk_entry, the entry point for all disk requests.
;
; on exit from this driver, we will return to the external driver
; that issued this int 2f, and can then remove the flags from the stack.
; this scheme allows us to have a small external device driver, and makes
; the maintainance of the various drivers (driver and msbio) much easier,
; since we only need to make changes in one place (most of the time).
;
;   ax=800h - check for installed handler - reserved
;   ax=801h - install the bds into the linked list
;   ax=802h - dos request
;   ax=803h - return bds table starting pointer in ds:di
;	   (ems device driver hooks int 13h to handle 16kb dma overrun
;	    problem.  bds table is going to be used to get head/sector
;	    informations without calling generic ioctl get device parm call.)

	public	i2f_handler
i2f_handler proc far
	assume	ds:nothing,es:nothing

	cmp	ah,13h
	jz	int2f_replace_int13
	cmp	ah,8
	jz	mine

;
;Check for WIN386 startup and return the BIOS instance data
;
	cmp	ah,MULTWIN386
	jz	win386call

	cmp	ah, multMULT
	jne	@f
	jmp	handle_multmult
@@:
	iret

int2f_replace_int13:
	push	ax			; free up a register for caller's ds
	mov	ax,ds			;  then we can use ds: -> Bios_Data
	mov	ds,Bios_Data_Word
	assume	ds:Bios_Data

	push	word ptr [orig13]	;   save old value of old13 and
	push	word ptr [orig13 + 2]	;   orig13 so that we can
	push	word ptr [old13]	;   return them to caller
	push	word ptr [old13 + 2]

	mov	word ptr [orig13],dx	;   orig13 := addr. of new int_13
	mov	word ptr [orig13+2],ax
	mov	word ptr [old13],bx	;    old13 := addr. of new boot_13
	mov	word ptr [old13+2],es

	pop	es			;    es:bx := old old13 vector
	pop	bx
	pop	ds			;    ds:dx := old orig13 vector
	assume	ds:nothing
	pop	dx
	pop	ax			; restore caller's ax

i2f_iret:
	iret


mine:
	assume	ds:nothing
	cmp	al,0f8h 		; iret on reserved functions
	jae	i2f_iret
	or	al,al			; a get installed state request?
	jnz	disp_func
	mov	al,0ffh
	jmp	i2f_iret

disp_func:
	cmp	al,1			; request for installing bds?
	jz	do_subfun_01
	cmp	al,3			; get bds vector?
	jz	do_get_bds_vector

; set up pointer to request packet

	push	ds
	mov	ds,Bios_Data_Word	; ds: -> Bios_Data
	assume	ds:Bios_Data

	mov	word ptr [ptrsav],bx	;otherwise dos function.
	mov	word ptr [ptrsav+2],es
	pop	ds
	assume	ds:nothing
	jmp	i2f_dskentry		; NOTE:  jump to a FAR function, not an
;					;  IRET type function.  Callers of
;					;  this int2f subfunction will have
;					;  to be careful to do a popf

do_subfun_01:
	assume	ds:nothing
	push	es			; save caller's ds, es
	push	ds

	push	ds			; put his argument into es
	pop	es

	mov	ds,Bios_Data_Word	; point ds: -> Bios_Data
	assume	ds:Bios_Data

	call	install_bds

	pop	ds			; restore caller's registers
	assume	ds:nothing
	pop	es
	jmp	i2f_iret


do_get_bds_vector:			; al=3
	assume	ds:nothing
	mov	ds,Bios_Data_Word
	assume	ds:Bios_Data

	lds	di,[start_bds]
	assume	ds:nothing
ii2f_iret:
	jmp	i2f_iret

;
;WIN386 startup stuff is done here. If starting up we set our WIN386 present
;flag and return instance data. If exiting, we reset the WIN386 present flag
;NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:
	push	ds
	mov	ds,cs:Bios_Data_Word
	assume	ds:Bios_Data

	cmp	al, Win386_Init		; is it win386 initializing?
	je	Win386Init
	cmp	al, Win386_Exit		; is it win386 exiting?
	jne	win_iret		; if not, continue int2f chain

Win386Exit:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue
	and	[IsWin386], 0		; indicate that win386 is not present
	jmp	short win_iret

Win386Init:
	test	dx, 1			; is it win386 or win286 dos extender?
	jnz	win_iret		; if not win386, then continue

	or	[IsWin386], 1		; Indicate WIN386 present
	mov	word ptr [SI_Next], bx	; Hook our structure into chain
	mov	word ptr [SI_Next + 2], es
	mov	bx, offset Win386_SI	; point ES:BX to Win386_SI
	push	ds
	pop	es

win_iret:
	pop	ds
	assume 	ds:nothing
	jmp	short i2f_iret		;return back up the chain

handle_multmult:
	cmp	al, multMULTGETHMAPTR
	jne	try_2

	push	ds
	call	HMAPtr			; get offset of free HMA
	mov	bx, 0ffffh
	mov	es, bx			; seg of HMA
	mov	bx, di
	not	bx
	or	bx, bx
	jz	@f
	inc	bx
@@:
	pop	ds
	jmp	ii2f_iret
try_2:
	cmp	al, multMULTALLOCHMA
	jne	try_3

	push	ds
	mov	di, 0ffffh		; assume not enough space
	mov	es, di
	call	HMAPtr			; get offset of free HMA
	assume	ds:Bios_Data
	cmp	di, 0ffffh
	je	InsuffHMA		
	neg	di			; free space in HMA
	cmp	bx, di
	jbe	@f
	mov	di, 0ffffh
	jmp	short InsuffHMA
@@:
	mov	di, FreeHMAPtr
	add	bx, 15
	and	bx, 0fff0h
	add	FreeHMAPtr, bx		; update the free pointer
	jnz	InsuffHMA
	mov	FreeHMAPtr, 0ffffh	; no more HMA if we have wrapped
InsuffHMA:
	pop	ds
	assume	ds:nothing
	jmp	ii2f_iret
try_3:
	jmp	ii2f_iret
i2f_handler endp

;
;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;		Gets the offset of the free HMA area ( with respect to
;							seg ffff )
;		If DOS has not moved high, tries to move DOS high.
;		In the course of doing this, it will allocate all the HMA
;		and set the FreeHMAPtr to past the end of the BIOS and 
;		DOS code.  The call to MoveDOSIntoHMA (which is a pointer)
;		enters the routine in sysinit1 called FTryToMoveDOSHi.
;
;	RETURNS : offset of free HMA in DI
;		  BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------
;
HMAPtr	proc	near
	mov	ds, Bios_Data_Word
	assume	ds:Bios_Data
	mov	di, FreeHMAPtr
	cmp	di, 0ffffh
	jne	@f
	cmp	SysinitPresent, 0
	je	@f
	call	MoveDOSIntoHMA
	mov	di, FreeHMAPtr
@@:
	ret
HMAPtr	endp


;	move a 512 byte sector from ds:si to es:di, do not trash cx
;	  but go ahead and update direction flag, si, & di

move_sector proc near
	assume	ds:nothing,es:nothing

;	M014 -- begin changes
;
;	The 80386 microprocessor considers an access to WORD 0FFFFH in
;	  any segment to be a fault.  Theoretically, this could be handled
;	  by the fault handler and the behavior of an 8086 could be emulated
;	  by wrapping the high byte to offset 0000h.  This would be a lot
;	  of work and was, indeed, blown off by the Win386 guys.  COMPAQ
;	  also handles the fault incorrectly in their ROM BIOS for real
;	  mode.  Their fault handler was only designed to deal with one
;	  special case which occurred in a magazine benchmark, but didn't
;	  handle the general case worth beans.
;
;	Simply changing this code to do a byte loop would work okay but
;	  would involve a general case performance hit.  Therefore, we'll
;	  check for either source or destination offsets being within one
;	  sector of the end of their segments and only in that case fall
;	  back to a byte move.

	cld
	push	cx
	mov	cx,512/2		; number of words in a sector

	cmp	si,0fe00h
	ja	movsec_bytes
	cmp	di,0fe00h
	ja	movsec_bytes

	rep	movsw
	pop	cx
	ret

movsec_bytes:
	shl	cx,1			; get number of bytes
	rep	movsb
	pop	cx
	ret

;	M014 -- end changes

move_sector endp



; check_wrap is a routine that adjusts the starting sector, starting head
; and starting cylinder for an int 13 request that requests i/o of a lot
; of sectors. it only does this for fixed disks. it is used in the sections
; of code that handle ecc errors and dma errors. it is necessary, because
; ordinarily the rom would take care of wraps around heads and cylinders,
; but we break down a request when we get an ecc or dma error into several
; i/o of one or more sectors. in this case, we may already be beyond the
; number of sectors on a track on the medium, and the request would fail.
;
; input conditions:
;	all registers set up for an int 13 request.
;
; output:
;	dh - contains starting head number for request
;	cx - contains starting sector and cylinder numbers
;	(the above may or may not have been changed, and are 0-based)
;	all other registers preserved.

check_wrap proc	near
	assume	ds:Bios_Data,es:nothing

	push	ax
	push	bx
	push	es
	push	di

	call	find_bds		; get pointer to bds for drive in dl
	jc	no_wrap 		;  finished if DOS doesn't use it

	test	es:[di].bds_flags,fnon_removable
	jz	no_wrap 		; no wrapping for removable media

	mov	bx,es:[di].BDS_BPB.BPB_SECTORSPERTRACK
	mov	ax,cx
	and	ax,3fh			; extract sector number
	cmp	ax,bx			; are we going to wrap?
	jbe	no_wrap
	div	bl			; ah=new sector #, al=# of head wraps

; we need to be careful here. if the new sector # is 0, then we are on the
; last sector on that track.

	or	ah,ah
	jnz	not_on_bound

	mov	ah,bl			; set sector=BDS_BPB.BPB_SECTORSPERTRACK if on boundary
	dec	al			; also decrement # of head wraps

not_on_bound:
	and	cl,0c0h 		; zero out sector #
	or	cl,ah			; or in new sector #
	xor	ah,ah			; ax = # of head wraps
	inc	ax
	add	al,dh			; add in starting head #
	adc	ah,0			; catch any carry
	cmp	ax,es:[di].BDS_BPB.BPB_HEADS		; are we going to wrap around a head?
	jbe	no_wrap_head		; do not lose new head number!!

	push	dx			; preserve drive number and head number
	xor	dx,dx
	mov	bx,es:[di].BDS_BPB.BPB_HEADS
	div	bx			; dx=new head #, ax=# of cylinder wraps

; careful here! if new head # is 0, then we are on the last head.

	or	dx,dx
	jnz	no_head_bound
	mov	dx,bx			; on boundary. set to BDS_BPB.BPB_HEADS

; if we had some cylinder wraps, we need to reduce them by one!!

	or	ax,ax
	jz	no_head_bound
	dec	ax			; reduce number of cylinder wraps
no_head_bound:
	mov	bh,dl			; bh has new head number
	pop	dx			; restore drive number and head number
	dec	bh			; get it 0-based
	mov	dh,bh			; set up new head number in dh
	mov	bh,cl
	and	bh,3fh			; preserve sector number
	mov	bl,6
	xchg	cl,bl
	shr	bl,cl			; get ms cylinder bits to ls end
	add	ch,al			; add in cylinder wrap
	adc	bl,ah			; add in high byte
	shl	bl,cl			; move up to ms end
	xchg	bl,cl			; restore cylinder bits into cl
	or	cl,bh			; or in sector number

no_wrap:
	clc
	pop	di
	pop	es
	pop	bx
	pop	ax
	ret

no_wrap_head:
	mov	dh,al			; do not lose new head number
	dec	dh			; get it 0-based
	jmp	short no_wrap
check_wrap	endp

;	this is a special version of the bds lookup code which is
;	  based on physical drives rather than the usual logical drives
;	  carry is set if the physical drive in dl is found, es:di -> its bds
;	  otherwise carry is clear
;
;	guaranteed to trash no registers except es:di


find_bds proc	near
	assume	ds:Bios_Data,es:nothing

	les	di,[start_bds]		; point es:di to first bds

fbds_1:
	cmp	es:[di].bds_drivenum,dl
	je	fbds_2

	les	di,es:[di].bds_link	; go to next bds
	cmp	di,-1
	jnz	fbds_1

	stc
fbds_2:
	ret

find_bds endp


doint	proc	near
	assume	ds:Bios_Data,es:nothing

	mov	dl,byte ptr [bp.olddx]		; get physical drive number
	xor	ah,ah
	or	al,al
	jz	dointdone			; if zero sectors, return ax=0

	mov	ah,byte ptr [bp.oldax+1]	; get request code
	push	[bp.oldf]
	popf					; M030
	call	call_orig13			; M030

; M030	call	orig13

	pushf
	pop	[bp.oldf]

dointdone:
	ret

doint	endp


; this is the true int 13 handler.  we parse the request to see if there is
; a dma violation.  if so, depending on the function, we:
;   read/write	break the request into three pieces and move the middle one
;	into our internal buffer.
;
;   format	copy the format table into the buffer
;   verify	point the transfer address into the buffer
;
; this is the biggest bogosity of all.	the ibm controller does not handle
; operations that cross physical 64k boundaries.  in these cases, we copy
; the offending sector into the buffer below and do the i/o from there.

int13frame  struc
oldbp	dw  ?
oldax	dw  ?
oldbx	dw  ?
oldcx	dw  ?
olddx	dw  ?
oldds	dw  ?	; now we save caller's ds, too
olddd	dd  ?
oldf	dw  ?
int13frame  ends


;   entry conditions:
;	ah = function
;	al = number of sectors
;	es:bx = dma address
;	cx = packed track and sector
;	dx = head and drive
;   output conditions:
;	no dma violation.

;	use extreme caution when working with this code.  In general,
;	  all registers are hot at all times.
;
;	question:  does this code handle cases where dma errors
;	  occur during ecc retries, and where ecc errors occur during
;	  dma breakdowns????  Hmmmmm.
;

dtype_array	dd	00400090h	; 40:90 is drive type array

;	stick some special stuff out of mainline


;	we know we're doing a format command.  if we have changeline
;	  support, then flag some special changed stuff and set changed
;	  by format bit for all logical drives using this physical drive

format_special_stuff:
	assume	ds:Bios_Data,es:nothing

	cmp	fhave96,0		; do we have changeline support?
	jz	format_special_stuff_done ; brif not

	push	bx
	mov	bx,fchanged_by_format+fchanged
	call	set_changed_dl		; indicate that media changed by format
	pop	bx
	jmp	short format_special_stuff_done

;	we know we've got ec35's on the system.  Now see if we're doing
;	  a floppy.  If so, create a mask and see if this particular
;	  drive is an ec35.  If so, set dtype_array[drive]=93h

ec35_special_stuff:
	assume	ds:Bios_Data,es:nothing
	test	dl,dl			; floppy or hard disk?
	js	ec35_special_stuff_done	; if hard drive, we're done

	push	ax			; see if this PARTICULAR drive is ec35
	push	cx
	mov	cl,dl			; turn drive number into bit map:
	mov	al,1			;   assume drive 0
	shl	al,cl			;   shift over correct number of times
	test	al,ec35_flag 		; electrically compatible 3.5 incher?
	pop	cx
	pop	ax
	jz	ec35_special_stuff_done	; done if this floppy is not an ec35

	push	bx			; free up a far pointer (es:bx)
	push	es

	les	bx,[dtype_array]
	add	bl,dl
	adc	bh,0			; find entry for this drive
	mov	byte ptr es:[bx],93h	; establish drive type as:
					;  (360k disk in 360k drive,
	pop	es			;  no double-stepping,
	pop	bx			;  250 kbs transfer rate)
	jmp	short ec35_special_stuff_done

; ps2_30 machine has some problem with ah=8h(read drive parm), int 13h.
;this function does not reset the common buses after the execution.
;to solve this problem, when we detect ah=8h, then we will save the result and
;will issue ah=1 (read status) call to reset the buses.


ps2_special_stuff:
	assume	ds:Bios_Data,es:nothing
	cmp	[prevoper],8		; read driver parm ?
	jz	ps2_30_problem
	cmp	prevoper,15h		; apparently function 15h fails, too
	jnz	ps2_special_stuff_done	; it isn't one of the problem functions

ps2_30_problem: 			; ps2_30 = ps2 model 30.
	push	ax			; preserve ax result from int13
	mov	ah,1			; read status call resets the bus
; M030	pushf				; simulate int 13h
; M030	call	orig13			; as a side effect
	call	call_orig13		; M030
	pop	ax			; restore results of initial int13
	jmp	short ps2_special_stuff_done

;	here is the actual int13 handler

	public i13z
i13z proc	far
	assume	ds:nothing,es:nothing

;	cas -- inefficient!  could push ds and load ds-> Bios_Data before
;	  vectoring up here from Bios_Data

	push	ds			; save caller's ds register first thing
	mov	ds,Bios_Data_Word	; and set up our own ds -> Bios_Data
	assume	ds:Bios_Data

; let the operation proceed.  if there is a dma violation, then we do things.

	mov	[prevoper],ax		; save request
	cmp	ah,romformat
	jz	format_special_stuff	; go do special stuff for format
format_special_stuff_done:

	cmp	ec35_flag,0		; any electrically compat 3.5 inchers?
	jnz	ec35_special_stuff	; go handle it out of line if so
ec35_special_stuff_done:

; M030	pushf				; simulate int 13h
; M030	call	orig13

	call	call_orig13		; M030

	pushf				; save result flags
	cmp	[model_byte],mdl_ps2_30 ; is this a ps2/30?
	jz	ps2_special_stuff	;  exit mainline to address special
ps2_special_stuff_done:			;   ps2/30 problem if so
	popf

	jc	goterr13		; error on original orig13 call-thru?
ret_from_i13:
	pop	ds
	ret	2			; restore ds & iret w/flags

;	most of our code exits through here.  If carry isn't set, then
;	  just do a simple exit.  Else doublecheck that we aren't getting
;	  a changeline error.

i13ret_ck_chglinerr:
	jnc	ret_from_i13		; done if not an error termination

i13_ret_error:
	cmp	ah,06h			; did i see a change event?
	jnz	int13b			; skip if wrong error

	or	dl,dl			; is this for the hard disk?
	js	int13b			; yes, ignore

	cmp	fhave96,0
	jz	int13b			; just in case ROM returned this
					;  error even though it told us it
					;  never would
	push	bx
	mov	bx,fchanged
	call	set_changed_dl
	pop	bx
int13b:
	stc				; now return the error
	jmp	ret_from_i13

; some kind of error occurred.	see if it is dma violation

goterr13:
	cmp	ah,09h			; dma error?
	jz	gotdmaerr		; M046
goterr13_xxxx:				; M046
	cmp	ah,11h			; ecc error?
	jnz	i13_ret_error		; other error.	just return back.

;M046 chk_validmedia_err13:

;M008 start --- removed check for bds for this physical drive.  Sometimes
;		(like when we're FDISK'ing a virgin partition and the buffer
;		is on a DMA boundary), we can just go ahead without having
;		a BDS for the drive, since we'll always read one sector at
;		a time in that case anyway.  Fixing bug 335.
;
;					;if find_bds fails, then just
;	push	es			;    return back to int 13h caller,
;	push	di			;      without performing ecc, dma
;	call	find_bds		;	error handling.
;	pop	di
;	pop	es
;	jc	i13_ret_error
;
;M008 end
;
; test of bit pattern 08h let other errors be passed as dma errors
;
;M046	cmp	ah,09h			; dma error code
;M046	jz	gotdmaerr
;
;	M046 -- the following comments no longer apply.  ECC correction
;	        is performed on all machines.
;
; soft ecc bug is only applied to pc1 and pc-xt. so, we will enforce
;this ecc error handler for them.   also, since cmc hardfiles in pc at also
;generate a lot of unnecessary ecc errors, we will still cover pc ats as
;it is done in the earlier version of msbio.
;during format/verify operation, we are going to consider any soft ecc as a
;hard error.
;
;	see if the machine we are operating on is a pc, xt or at by checking
;	the model byte.  the soft ecc bug is only on these machines and if
;	the machine we are operating on is not one of these three then we
;	needn't do anything special.  if we are operating one these however
;	we check to see if the error occured during format by checking
;	media_set_for_format.  if it did occur during format we cannot do
;	anything but if not during format then check to see if the error
;	returned in ah is the soft_ecc error and if so go to ok11 since
;	the error can be ignored.

	cmp	[media_set_for_format],1 ; formatting?
	je	i13_ret_error

;M046	cmp	[model_byte],0feh	; pc or xt?
;M046	jae	go_chk_ecc
;M046	cmp	[model_byte],0fbh	; xt?
;M046	je	go_chk_ecc
;M046	cmp	[model_byte],0fch
;M046	jne	i13_ret_error
;M046	cmp	[secondary_model_byte],2 ; at?
;M046	ja	i13_ret_error		; return to the caller
;
; we have an error status 11h.	this indicates an ecc-corrected error.	note
; that this indicates that the data is probably correct but not certainly
; correct. the roms on pc-1s and pc_xts have a 'bug' in that if an ecc error
; occurs for a multi-sector read, only the sectors up to the one where the
; error occurred are read in. we have no way of knowing how many were read in
; this case, so we redo the operation, reading one sector at a time. if we
; get an ecc error on reading one sector, we ignore the error because the
; sector has been read in.


;	M046 -- begin additions

	cmp	byte ptr [prevoper].1,romread	; ECC correction only applies to reads
	jnz	i13_ret_error

;	M046 -- end additions

;M046 go_chk_ecc:
	xor	ah,ah
; M030	pushf
; M030	call	orig13		;reset. don't care about the result
	call	call_orig13	; M030 reset.  don't care about the result

	mov	ax,[prevoper]
	xor	ah,ah		; return code = no error
	cmp	al,1			; if request for one sector, assume ok
	jz	ret_from_i13		; return with carry clear

	push	bx
	push	cx
	push	dx
	mov	[number_of_sec],al

loop_ecc:
;M046	mov	ah,byte ptr [prevoper].1
;M046	mov	al,1			; request for one sector only
	mov	ax,201h			; M046 read one sector

; we do reads one sector at a time. this ensures that we will eventually
; finish the request since ecc errors on one sector do read in that sector.
;
; we need to put in some "intelligence" into the ecc handler to handle reads
; that attempt to read more sectors than are available on a particular
; track.
;
; we call check_wrap to set up the sector #, head # and cylinder # for
; this request.
;
; at this point, all registers are set up for the call to orig13, except
; that there may be a starting sector number that is bigger than the number
; of sectors on a track.
;
	call	check_wrap		; get correct parameters for int 13
; M030	pushf				; simulate int instruction
; M030	call	orig13
	call	call_orig13		; M030
	jnc	ok11_op

	cmp	ah,9			; M046  DMA error during ECC read?
	jz	handle_dma_during_ecc	; M046

	cmp	ah,11h			; only allow ecc errors
	jnz	ok11_exit_err		; other error?

	mov	ah,0			; ecc error. reset the system again.
; M030	pushf				; simulate int 13h
; M030	call	orig13
;	call	call_orig13		; M030 simulate int 13h
	xor	ax,ax			; clear the error code so that if this
					; was the last sector, no error code 
					; will be returned for the corrected 
					; read. (clear carry too.)
ok11_op:
	dec	[number_of_sec]
	jz	ok11_exit		; all done?
	inc	cl			; advance sector number
	inc	bh			; add 200h to address
	inc	bh
	jmp	loop_ecc

;	locate error returns centrally


ok11_exit_err:
	stc				; set carry bit again.
ok11_exit:
	pop	dx
	pop	cx
	pop	bx
	jmp	i13ret_ck_chglinerr

;	M046 begin additions

handle_dma_during_ecc:

;	do the single sector read again, this time into our temporary
;	   buffer, which is guaranteed not to have a DMA error, then
;	   move the data to its proper location and proceed

	push	es
	push	bx
	mov	bx,offset disksector
	push	ds
	pop	es			; point es:bx to buffer
	mov	ax,201h			; read one sector
	call	call_orig13
	pop	bx
	pop	es
	jnc	handle_dma_during_ecc_noerr
	cmp	ah,11h
	jnz	ok11_exit_err		; if anything but ecc error, bomb out

;	now we're kosher.  Copy the data to where it belongs and resume
;	  the ECC looping code.

handle_dma_during_ecc_noerr:
	push	si
	push	di
	mov	di,bx
	mov	si,offset disksector
	call	move_sector
	pop	di
	pop	si
	jmp	ok11_op

;	M046 end additions

; we truly have a dma violation.  restore register ax and retry the
; operation as best we can.

gotdmaerr:
	mov	ax,[prevoper]
	sti
	cmp	ah,romread		; save user flags
	jb	i13_done_dmaerr		; just pass dma error thru for
					;   functions we don't handle

	cmp	ah,romverify
	jz	intverify

	cmp	ah,romformat
	jz	intformat
	ja	i13_done_dmaerr

; we are doing a read/write call.  check for dma problems

;	******** set up stack frame here!!! ********

	push	dx
	push	cx
	push	bx
	push	ax
	push	bp
	mov	bp,sp
	mov	dx,es			; check for 64k boundary error

	shl	dx,1
	shl	dx,1
	shl	dx,1
	shl	dx,1			; segment converted to absolute address

	add	dx,bx			; combine with offset
	add	dx,511			; simulate a transfer

; if carry is set, then we are within 512 bytes of the end of the segment.
; we skip the first transfer and perform the remaining buffering and transfer

	jnc	no_skip_first
	jmp	bufferx			; restore dh=head & do buffer

;	M046 -- also moved a few things around to make relative branches
;	   reach where possible.

; dx is the physical 16 bits of start of transfer (+511).  compute remaining
; sectors in segment.

no_skip_first:
	shr	dh,1			; dh = number of sectors before address
	mov	ah,128			; ah = max number of sectors in segment
	sub	ah,dh

; ah is now the number of sectors that we can successfully write in this
; segment.  if this number is above or equal to the requested number, then we
; continue the operation as normal.  otherwise, we break it into pieces.
;
;	wait a sec.  this is goofy.  the whole reason we got here in the
;	  first place is because we got a dma error.  so it's impossible
;	  for the whole block to fit, unless the dma error was returned
;	  in error.

	cmp	ah,al			; can we fit it in?
	jb	doblock 		; no, perform blocking.

;	yes, the request fits.  let it happen.

	mov	dh,byte ptr [bp.olddx+1]	; set up head number
	call	doint
	jmp	bad13			; and return from this place

i13_done_dmaerr:
	mov	ah,9			; pass dma error thru to caller
	stc
	jmp	ret_from_i13		; return with error, we know it's not
					;  a changeline error

; verify the given sectors.  place the buffer pointer into our space.

intverify:
	push	es			; save caller's dma address
	push	bx

	push	ds			; es:bx -> Bios_Data:disksector
	pop	es
dosimple:
	mov	bx,offset disksector	; do the i/o from Bios_Data:disksector
; M030	pushf				;  cas -- it doesn't matter anyway?
; M030	call	orig13

	call	call_orig13		; M030
	pop	bx
	pop	es

	jmp	i13ret_ck_chglinerr

; format operation.  copy the parameter table into Bios_Data:disksector

intformat:
	push	es
	push	bx

	push	si
	push	di
	push	ds

;	point ds to the caller's dma buffer, es to Bios_Data
;	  in other words, swap (ds, es)

	push	es
	push	ds
	pop	es
	pop	ds
	assume	ds:nothing
	mov	si,bx
	mov	di,offset disksector

	call	move_sector		; user's data into Bios_Data:disksector

	pop	ds
	assume	ds:Bios_Data
	pop	di
	pop	si			; do the i/o from
	jmp	dosimple		;   Bios_Data:disksector



; we can't fit the request into the entire block.  perform the operation on
; the first block.
;
; doblock is modified to correctly handle multi-sector disk i/o.
; old doblock had added the number of sectors i/oed (ah in old doblock) after
; the doint call to cl.  observing only the lower 6 bits of cl(=max. 64) can
; represent a starting sector, if ah was big, then cl would be clobbered.
; by the way, we still are going to use cl for this purpose since checkwrap
; routine will use it as an input.  to prevent cl from being clobbered, a
; safe number of sectors should be calculated like "63 - # of sectors/track".
; doblock will handle the first block of requested sectors within the
; boundary of this safe value.

doblock:

;try to get the # of sectors/track from bds via rom drive number.
;for any mini disks installed, here we have to pray that they have the
;same # of sector/track as the main dos partition disk drive.
;
	mov	dx,word ptr [bp.olddx]	;get head #, drive #

	push	cx			; prepare a temporary register

	push	es			; save user's transfer segment
	push	di			;ah - # of sectors before dma boundary
					;al - requested # of sectors for i/o.
	call	find_bds		; get bds pointer for this disk.
	mov	cx,es:[di].BDS_BPB.BPB_SECTORSPERTRACK		; fetch up # sectors/trk
	test	es:[di].bds_flags,fnon_removable ;don't have to worry about floppies.
	pop	di
	pop	es			; restore original es/di

	mov	al,ah			; set al=ah for floppies
	jz	doblockflop		;they are track by track operation.

	mov	ah,63			; ah = 63-secpt (# safe sectors??)
	sub	ah,cl			;al - # of sectors before dma boundary
doblockflop:
	pop	cx

doblockcontinue:
	cmp	ah,al			;if safe_# >= #_of_sectors_to_go_before dma,
	jae	doblocklast		;then #_of_sectors_to_go as it is for doint.

	push	ax			;save ah, al
	mov	al,ah			;otherwise, set al to ah to operate.
	jmp	short doblockdoint	;doint will set ah to a proper function
					; in [bp.oldax]

doblocklast:
	mov	ah,al
	push	ax			;save ah
doblockdoint:				;let ah = al = # of sectors for this shot
	call	doint
	jc	bad13			;something happened, bye!

	pop	ax
	sub	byte ptr [bp.oldax],ah	;decrement by the successful operation
	add	cl,ah			;advance sector #. safety gauranteed.
	add	bh,ah			;advance dma address
	add	bh,ah			;twice for 512 byte sectors.
	cmp	ah,al			;check the previous value
	je	buffer			;if #_of_sectors_to_go < safe_#,
					; then we are done already.

	sub	al,ah			;otherwise, #_sector_to_go = #_of_sector_to_go - safe_#
	call	check_wrap		;get new cx, dh for the next operation.
	jmp	short doblockcontinue	;handles next sectors left.


bufferx:
	mov	dh,byte ptr [bp.olddx+1] ; set up head number
buffer:
	push	bx
	mov	ah,byte ptr [bp.oldax+1]
	cmp	ah,romwrite
	jnz	doread

; copy the offending sector into local buffer

	push	es
	push	ds
	push	si
	push	di

	push	ds			; exchange segment registers
	push	es
	pop	ds
	assume	ds:nothing
	pop	es
	assume	es:Bios_Data

	mov	di,offset disksector	; where to move
	push	di			; save it
	mov	si,bx			; source
	call	move_sector		; move sector into local buffer
	pop	bx			; new transfer address (es:bx =
					;    Bios_Data:diskbuffer)
	pop	di			; restore caller's di & si
	pop	si
	pop	ds			; restore Bios_Data
	assume	ds:Bios_Data
	mov	al,1

; see if we are wrapping around a track or head

	mov	dl,byte ptr [bp.olddx]	; get drive number
	call	check_wrap		; sets up registers if wrap-around

;   ah is function
;   al is 1 for single sector transfer
;   es:bx is local transfer addres
;   cx is track/sector number
;   dx is head/drive number
;   si,di unchanged

	call	doint
	pop	es			; restore caller's dma segment
	assume	es:nothing
	jc	bad13			; go clean up
	jmp	short dotail

; reading a sector.  do int first, then move things around

doread:
	push	es
	push	bx
	push	ds			; es = Bios_Code
	pop	es

	mov	bx,offset disksector
	mov	al,1

; see if our request will wrap a track or head boundary

	mov	dl,byte ptr [bp.olddx]	; get drive number
	call	check_wrap		; sets up registers if wrap-around

;   ah = function
;   al = 1 for single sector
;   es:bx points to local buffer
;   cx, dx are track/sector, head/drive

	call	doint

	pop	bx			; restore caller's dma address
	pop	es
	assume	es:nothing

	jc	bad13			; error => clean up

	push	si
	push	di

	mov	di,bx
	mov	si,offset disksector
	call	move_sector

	pop	di
	pop	si

; note the fact that we've done 1 more sector

dotail:
	pop	bx			; retrieve new dma area
	add	bh,2			; advance over sector
	inc	cx
	mov	al,byte ptr [bp.oldax]
	clc
	dec	al
	jz	bad13			; no more i/o

; see if we wrap around a track or head boundary with starting sector
; we already have the correct head number to pass to check_wrap

	mov	dl,byte ptr [bp.olddx]	; get drive number
	call	check_wrap		; sets up registers if wrap-around
	call	doint

; we are done.	ax has the final code; we throw away what we got before

;	M046  -- okay gang.  Now we've either terminated our DMA loop,
;		   or we've finished.  If carry is set now, our only
;		   hope for salvation is that it was a read operation
;		   and the error code is ECC error.  In that case, we'll
;		   just pop the registers and go do the old ECC thing.
;		   When the DMA error that got us here in the first
;		   place occurs, it'll handle it.

bad13:
	mov	sp,bp
	pop	bp
	pop	bx			; throw away old ax result
	pop	bx
	pop	cx
	pop	dx

	jc	xgoterr13_xxxx		; M046 go handle ECC errors
	jmp	ret_from_i13		; M046 non-error exit

xgoterr13_xxxx:
	jmp	goterr13_xxxx		; M046

handle_ecc_during_dma:
i13z endp


Bios_Code	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power.asm ===
PAGE    ,132
;**************************************************************
;*  POWER.SYS - MSDOS 5.0 IDLE DETECTION DEVICE DRIVER
;*
;*  Microsoft Confidential
;*  Copyright (C) Microsoft Corporation 1991
;*  All Rights Reserved.
;*
;*  Revision History
;*  90/7/19  [BR]       Completed beta DRIVER V0.30
;*  04/29/91 SR         Modified to make it ROMmable. Separated CODE,
;*                      DATA & INIT segments.
;*  06/03/91 MD         Merged standalone and resident versions,
;*                      support idle checking on INT 2F Idle
;*  07/01/91 JRCB       Changed STANDALONE to POWERALONE to remove confusion
;*                      with ROMDRIVE variable of same name.
;*  08/12/91  NSM       added APM support (M001)
;*
;*  08/21/91  NSM       M002: Removed the comment marks in Int14 hook
;                       (bug #    : printing slowed when POWER is present)
;                       Added a call to CPU_BUSY after resume
;
;   08/29/91  NSM       M003: removed rest of IOCTL support
;               
;   09/05/91  NSM       M004: Bug# 2587 
;                       Moved CheckV86 calls only for DOING HLT and not
;                       for OEM_IDLE or for APM_IDLE (2587)
;                       Also fixed the problem with multiple resumes.
;                       If we get a resume without a initial suspend notifi.
;                       then we ignore this resume command now.
;                       Bug#2574 Count CPU_IDLE time at Int 1c
;
;   09/08/91  DBO       M005: Straighten out far calls in BIOS-resident
;                       driver:
;                        Do_APM_Enable_Disable  -- make near
;                        Check_and_Init_APM     -- list in seg_reinit
;                        time_to_ticks          -- reference via ttticks 
;                                                  (already in seg_reinit)
;                        Do_APM_Connect         -- make near
;
;   09/11/91  NSM/DBO   M074: Replace clock driver functions, so we can manage
;                       manage system date & time updates after resume events.
;
;   09/11/91  SMR       M075: B#2670. Get Idle Algorithm was trashing IDLE_FLG
;
;   09/11/91  SMR       M076: B#2668. Statistics were not being copied if the
;                       user buffer is bigger than the required size.
;
;   09/11/91  SMR       M077: B#2669. Registered POWER's 2f channels in mult.inc
;
;   09/11/91  SMR       M078: Use HLT even if the processor is in V86 mode
;
;   09/11/91  SMR       M079: PWR_API returns 0 in AX instead of no carry flag
;                               in case of no error
;
;   09/11/91  DBO       M080: Power management clock hooks int 6C for
;                       resume events.
;
;   09/12/91  SMR       Call P_UpdFromCMOS directly if power is standalone
;
;   09/12/91  SMR       Load ES:DI before dispatching a CLOCK$ call.
;
;   09/17/91  NSM       M084: Don't zero out AX for version check int 2f call
;
;   09/19/91  SMR       M085: Return break address from clock driver init also
;
;   09/19/91  SMR       M086: Save/Restore SI in get/Set statistics calls
;
;   09/23/91  NSM       M087: Change signature to 504DH
;
;   09/25/91  NSM       M088: (B# 2730) Hang in GET_APM_STAT - missing "push si"
;
;   09/25/91  NSM       M089: I2F service routine changes related to UI change.
;                       (definition of POWER STD needed some extra code)
;
;   09/25/91  NSM       M090: CLOCK driver related changes to take care of
;                       WIN 3 ENH mode eating up I1Cs.  Soln. is to update our
;                       time from CMOS once in 1024 I1c ticks. Do this only 
;                       when win enh mode starts up and discontinue once win
;                       ends. (Bug# 2729)
;
;   09/25/91  NSM       M091: Also update our time from CMOS when POWER STD
;                       is selected on an APM machine. 
;
;   10/25/91  NSM       M093: CX reg is getting trashed while making suspend
;                       standby APM call in Int1C.
;                       While changing APM_MAX_POLLCOUNT, we should update
;                       the current APMPoll Counter also (APM_POLL_COUNT).
;
;   10/29/91  NSM       M094: AX and BL regs were getting trashed in some of
;                       the INT 2f service routines.
;
;   11/05/91  NSM       M096: Eat the rollover flag in Int 1C before command
;                       gets it.
;
;   11/19/91  SMR	M098: Load power into UMB automatically
;
;   11/26/91 SMR	M099: Remember PSP of 2f instead of maintaining a
;			flag in the app's PSP
;
;   11/26/91 SMR	M100: Instance the PSPOf2fApp variable
;
;   11/27/91 SMR	M102: Reverse the order of instancing
;			Do definite idle on INT 2a ah=84
;
;   12/03/91 NSM	M103: Check for POWER OFF before doing IDLEs.
;
;   12/03/91 SMR	M104: Do APM Command line settings only in the
;				second copy of POWER if moved into UMB
;
;   12/04/91 SMR	M105: Fake out arena header & sub-arena header
;				so that MEM.EXE will see POWER properly.
;
;   12/06/91 NSM	M106: Change the averaging algorithm while adapting
;			 Instead of using a running avg, collect 16 samples
;			 at a time, find avg on them, and use that new avg
; 			 for the next 16 samples  and so on till end of adapt.
;
;   12/06/91 SMR	M107: Issue int 1A to clear BIOS rollover flag
;
;   12/10/91 NSM	M108: Put APM related I2F service code within IFDEF
;			INCL_APM directives
;
;**************************************************************

	TITLE   POWER$ IDLE DETECTION V1.0

	.xlist

	include version.inc     ; M004 set build flags

break   macro                   ; satisfy mult.inc
	endm

	include mult.inc        ; get our int 2f function equates       ; M077
	include	win386.inc	; NSM2
	include	devmark.inc

IFDEF   POWER

IFNDEF  POWERALONE              ; segment declarations for resident version

	include biosseg.inc     ; establish bios segment structure

ELSE                            ; segment declarations for standalonde version

.SEQ

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Trans_Code      segment word public 'CODE'
		extrn	ParseCmdLine:far
Trans_Code      ends

Trans_Data      segment word public 'DATA'
		extrn	BadDOSMsg:byte
		extrn	PW_Low:byte, PW_Mode:byte, PW_Savings_Value:word ; M104
IFDEF	DEBUG
		extrn	PW_Debug:byte					 ; M104
ENDIF

Trans_Data      ends

ENDIF


	include msequ.inc
	include devsym.inc
	include bpb.inc
	include ioctl.inc
	include power.inc

IFDEF	POWERALONE			; M098
	include	umb.inc			; M098
	include	syscall.inc		; M098
ENDIF ; POWERALONE			; M098


IFDEF INCL_APM
	include apmequ.inc              ; M001
ENDIF

break   macro
	endm

	include error.inc
	.list

	include msgroup.inc     ; define Bios_Data segment

IFDEF   POWERALONE                      ; standalone device driver version
Bios_Res        dw      Bios_Code       ; Our code segment address
ELSE                                    ; resident BIOS version
	extrn   Bios_Res:word           ; Code segment address supplied externally
	extrn   ttticks:dword           ; far ptr to time_to_ticks routine
	extrn   P_UpdFromCMOS_Ptr:dword ; ptr to CMOS clock read        ; M081
IFDEF   INCL_APM
	extrn   Check_and_Init_APM_Ptr:dword    ; ptr to APM init routine
ENDIF   ;INCL_APM
ENDIF   ;NOT POWERALONE
;
; PUBLIC declaration for DATA
;
public  RHPTR, KYC, I28, CONTROL, INFO, MSW
public  IDLTIC, TOTTIC, SPDUP, SPDUP_DLY, SPDUP_CNT    ; M004
public  I2F_VEC, I28_TMR0, I28_VEC, KYC_TMR0, IN_KYC 
public  I16_VEC, SWITCH_CNT, I9_COUNT, I9_VEC, I10_VEC, I13_VEC
public  I14_VEC, I17_VEC, I21_VEC,I25_VEC,I26_VEC,I2A_VEC, I08_VEC

; PUBLIC declarations for APM related Data
;
IFDEF INCL_APM                                  ; M001
public  fAPM_PRESENT,APM_FLAGS,APM_VER,APM_POLL_COUNT,fAPM_CONNECT
public  APM_MAX_POLLCOUNT,fAPM_STATE,APM_RESUME_COUNT
ENDIF

RHPTR   dd 0

; DEBUG Macro
; Prints the argument (dispchar) on screen
; 
dbg_printchar   macro dispchar
IFDEF   DEBUG
	push    ax
	mov     ah,0eh
	mov     al,dispchar
	int     10h
	pop     ax      
ENDIF
endm

POWER_DATA label byte
;
; Period Info structure for Keyboard (KYC) and Int 28 (I28)
; This holds the values for BASE,NOISE, AVG, SPREAD etc.
; (look at power.inc for PERIOD_INFO structure
;
; BUGBUG - Nagara  - PERIOD_INFO structure has changed and the following
; lines do not reflect that. These lines should have been:
; 	KYC	PERIOD_INFO	<0,0,0,0,0,20,20,0,0,0>
;	I28 PERIOD_INFO <0,0,0,0,0,100,20,0,0,0>
; Luckily the current def., though wrong, will not cause any problems

KYC     PERIOD_INFO     < 0, 0,20, 20, 0, 0, 0>   ; default values for base and
I28     PERIOD_INFO     < 0, 0,100, 20, 0, 0, 0>  ; noise are (random)conservative

; BUGBUG END

; CONTROL holds constant/tunable parameters for (mainly) int 16/int 28 idle
; detection strategies.
;
CONTROL CONTROL_INFO    < 00011111b, 8*2, 31*1024, 4,  40, 0,  1,   8,    0>  
                                                                ; M078
;                       idle_flg, sw_dly,thres,ad_dl,mx,sp_dl,ramp,sp_mx,386flg
;
; INFO holds the idle detection statistics such as no of i16 idles detected etc.
INFO    IDLE_INFO       < 0, 0, 0, 0, 0, 0, 0>

ErrSampleCount  dw      0	; no of errors encountered so far in adapt cycle

MSW		dw	0	; store machine status word
				; used by ChkV86 procedure
				; bit 0 = 1 indicates protected mode

IDLTIC		dw	0	; M004 used as a flag that says CPU was idle 
				; in the last (I08) tick period

TOTTIC		dw	0	; running total of halt time	; counted in Int8
				; in 1/1.19 MHZ increments 65536=55ms

;
; ACTIVITY MONITOR DATA
;
SPDUP		dw	0	; Activity indicator; 1=> active =>avoid halting
SPDUP_DLY	dw	0	; MAX DELAY set by activity monitor
SPDUP_CNT	dw	0	; incremented via INT 08

;
; M100 - begin
;

; Data to track Int2F aware apps.
; Instance data structure for instancing PSPOf2fApp
;
Pwr_InstData	label	byte
 Pwr_SIVersion	dw	3	; ignored 
 Pwr_SINextDev	dd	0	; ptr to next Instance packet
 Pwr_SIVirtDev	dd	0	; ignored
 Pwr_SIRefData	dd	0	; ignored
 Pwr_SIInstData	dw	offset Bios_Data:Pwr_SITable, Bios_Data
				; pointer to instance table

Pwr_SITable	label	byte
Inst_PSPOf2fApp	dw	offset Bios_Data:PSPOf2fApp, Bios_Data
		dw	2	; 2 bytes
Inst_End	dd	0

;
; M100 - end
;

PSPOf2fApp	dw	0	; PSP of the current 2f-1680 App	; M099
PSPsegment	dw	(?)	; JAH3 - Dos DATA seg  used to	
				; access Current PSP

; Data to store prev. vectors of interrupts we hook
; At startup these hold our ISRs for corresponding ints, and exchanged with
; the previous ISR addresses at Device init time
;
I2F_VEC dw I2F_IDLE, 0          ; holds next pointer in chain

; BUGBUG - Nagara - I2F_TMR0 is not used at all and can be deleted
I2F_TMR0        dw   0          ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD
		dw   2          ;+2, Counts number of times PC
				;    timer has Overflowed
;BUGBUG END

I2A_VEC dw I2A_IDLE, 0          ; holds next pointer in chain

; I28_TMR0 is used to store TMR0 readings whenever Int 28 occurs.
I28_TMR0        dw 0         ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD
		dw 2            ;+2, Counts number of times PC
				;    timer has Overflowed

I28_VEC dw I28_IDLE, 0

KYC_TMR0        dw 0            ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD	for Int 16s
		dw 2            ;+2, Counts number of times PC
				;    timer has Overflowed


IN_KYC  dw 0                    ; flags re-entry of key board check

I16_VEC dw I16_IDLE, 0          ; stores next key routine in chain

; SWITCH_CNT keeps track of when to switch idle detect method (whether int16
; or int 28)
SWITCH_CNT      dw 0                    
					

I08_VEC dw Pwr_i08_isr,0	; our Int 8 ISR ; NSM5

I9_COUNT        dw 2            ; for every key press more
				; a minimum of 2 INT 9's occur

; Application activity monitor interrupts

I9_VEC          dw I9_APP,0

I10_VEC dw I10_APP,0

I13_VEC dw I13_APP,0

I14_VEC dw I14_APP,0

I17_VEC dw I17_APP,0

I21_VEC dw I21_APP,0

I25_VEC dw I25_APP,0

I26_VEC dw I26_APP,0

; Our hook for Int 6c- update system date and time
I6C_VEC dw I6C_RESUME, 0        ;M080

;------------------------------------------------------------------------
; APM SPECIFIC DATA
;
IFDEF   INCL_APM                ; M001

fAPM_PRESENT    db      0	; set to 1 if APM present
fAPM_CONNECT    db      0 	; set to 1 if we are connected
APM_MAX_POLLCOUNT       dw      50 ; interval bet PM event polls (in tmr tics)
APM_FLAGS       dw      0	; flags returned by APM detect call
APM_VER         dw      0	; APM BIOS ver returned by APM detect call
APM_POLL_COUNT  dw      50	; interval bet PM event polls (in tmr tics)
				; counter for APM polling ; counted in int 8 time

fAPM_STATE      db      0       ; 0 if APM disabled and 1 if APM enabled

APM_RESUME_COUNT        dw      0   ; counter for no of resumes from last
				; APM enable

ENDIF                   ;INCL_APM
;-------------------------------------------------------------------
; DATA for CLOCK$ driver

	PUBLIC  CMOSUpdFlg      ; M090
	PUBLIC  CMOSPollCount   ; M090

CMOSUpdFlg      db      0       ; M090 set to 1 if we need to update from CMOS
				; set when we see a rollover in BDA (40:70h) or periodically
				; in POWER STD mode in an APM machine
CMOSPollCount   dw      MAXCMOSPOLLCOUNT        ; M090
				; counted at int 8 time and used in POWER STD mode to update
				; system date and time periodically
CMOSFlg         db      0       ; M091 bit 0 set to 1 in POWER STD mode on APM 
				; machines

;-------------------------------------------------------------------
; BASE LINE calculation data for Int 16 idle detection

BaseLineRef   dw      0		; counters for counting no of i16s we can get
				; through in about 4 secs  (done at each
				; exec)
BaseLineOvf	dw	0	; also used to store previous calculated 
				;  BaseLineRef

; SMR7	- Baseline Max calculation
		public	BL_Samples
BL_NUMSAMPLES	equ	9		; no of samples collected at EXEC time
BL_Samples	dw	BL_NUMSAMPLES dup ('SM') ; data to hold i16 samples
BL_EndSamples	label	byte
; SMR7 END


;-------------------------------------------------------------------
; CLOCK$ driver DATA

IFDEF   POWERALONE              ; needed only for standalone version
	public  daycnt		; no of days from 1-1-80 (ABS)
daycnt  dw      0
	public  daycnt2
daycnt2 dw      0		; used as a temp while calculating daycnt
	public  base_century
base_century    db      19
	public  base_year
base_year       db      80
	public  month_tab
month_tab       db      31,28,31,30,31,30,31,31,30,31,30,31

	public  bin_date_time
bin_date_time:
	db      0               ; year in century (0...99) or minutes (0-59)
	db      0               ; century (19 or 20) or hours (0-23)
	db      0               ; day in month (1...31)
	db      0               ; month in year (1...12) or seconds (0-59)

	public  month_table

month_table:			; no of days in year upto this month
	dw      0               ; january
	dw      31              ; february
	dw      59              ; march
	dw      90              ; april
	dw      120             ; may
	dw      151             ; june
	dw      181             ; july
	dw      212             ; august
	dw      243             ; september
	dw      273             ; october
	dw      304             ; november
	dw      334             ; december

ELSE                            ; for resident version
	extrn   bin_date_time:byte
	extrn   month_table:word
	extrn   daycnt:word
	extrn   daycnt2:word

ENDIF                   ; POWERALONE

;-------------------------------------------------------------------
; Used by Int 21 application activity monitor to filter those sysem calls
; that should not inhibit idles and those calls that have to be special cased
;
; 1 byte for each int 21 api from functions 0 thro 5fh
; an entry of 0ffh means ignore this api for false idle monitoring
; 0 -> this api means the system is busy (NOT idle) 
; any other number -> special cases
i21_table	label	near
	db	0,   0,   0,   0,   0,   0,   5,   0	; fns 0-7
	db	0,   0,   0,0ffh,   0,   0,   0,   0	; fns 8-0f
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 10-17
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 18-1f
	db	0,   0,   0,   0,   0,0ffh,   0,   0	; fns 20-27
	db	0,   0,0ffh,   0,0ffh,   0,   0,   0	; fns 28-2f
	db	0,   0,   0,   0,   0,0ffh,   0,   0	; fns 30-37
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 38-3f
	db	0,   0,   0,   0,043h,   0,   0,   0	; fns 40-47
	db	0,   0,   0,04ah,   0,   0,   0,   0	; fns 48-4f
	db   0ffh,0ffh,   0,   0,   0,   0,   0,   0	; fns 50-57
	db	0,   0,   0,   0,   0,   0,   0,05eh	; fns 58-5f
MAX_I21_ENTRY	equ 5fh
;
;-------------------------------------------------------------------
;
; MISCELLANEOUS FLAGS and TABLES
;

POWER_STATUS    db      1       ; default ;bit 0 -  S/W pw.mgmt always enabled
				; bit 1 - Take control of APM/FIRMWARE  mgmt 
				; (or get connected to APM)
				; M001
				; M089 If bit1 is set, We are connected to APM
				; but not neccessarily enabled APM
				; (look at fAPM_State)
;NSM1 BEGIN
; NSM9 BEGIN	- 8 sets of savings modes with 6 being the default
Savings_Mode	dw	6	; 3 = MIN savings
				; 6 = Reg savings (default)
				; 7 = Max savings

; Savings_Table used for NOISE/PSPREAD ratio calculation for the 8 levels of
; savings mode
;
Savings_Table	label	byte
;	bit	7 6 5 4 3   2    1    0
;			       12.5  25  50%  for NOISE/SPREAD RATIO
	db	4		; 12.5 %  saving  mode 1
	db	2		; 25 %		- mode 2
	db	6		; 37.5 % 	- mode 3
	db	1		; 50% 		- mode 4
	db	5		; 62.5% 	- mode 5 - MIN
	db	3		; 75%		- mode 6 - REG
	db	7		; 87.5% 	- mode 7 - MAX
	db	0		; 100% 		- mode 8  - special case
;
; Table used to calculate BaseLineRef for the current level of savings mode
; from the BaseLineMax value calculated at EXEC time.
;
BaseLine_Table	label	byte
; 	Bit	7 6   5   4       3     2    1   0	
;		    .03  .063    .125  .25  .5  1
; for levels upto 6, the calculated value from this table is substracted from
; BaseLineMax, whereas from level 6, it is added
;
	db	0	; dummy ; to make this 1-based 
	db	1ch	; for mode 1 - 45% of baseline freq
	db	2	; mode 2 - 40% of baseline freq ( or 1/2 of current max)
	db	12h	; mode 3 - approx 35% of baseline
	db	1ah	; mode 4 - approx 30% of baseline    - MIN 
	db	16h	; mode 5 - approx of 25% of baseline 
	db	0	; mode 6 - 20% of baseline	     - REG (+from here)
	db	2	; mode 7 - 12% of baseline	     - MAX
	db	1	; mode 8 - 10% of baseline	; special case
;	
; NSM9 END
;NSM1 END
	
NoBaseLineCalc	db	0	; = 1-> no baseline calc at EXEC time ; NSM2
				; set by WIN enh.mode startup call
				; BaseLineMax is not calculated if this is set

;-------------------------------------------------------------------
; Ptrs to previous ISRs for each of the interrupts we hook.
; these have to be in Data seg for ROMDOS. 
;
Pwr_i2f_next    dw      Pwr_i2f_lab
		dw      Bios_Data
Pwr_i2f_lab:
	pop     ds
	jmp     dword ptr cs:I2f_Vec

;
; M102 - begin
;
Pwr_call_i2f    dw      Pwr_calli2f_lab
		dw      Bios_Data

Pwr_calli2f_ret dw      Calli2fret
		dw      0

Pwr_calli2f_lab:
	pop     ds

	pushf
	call    dword ptr I2f_Vec

	push    ds
	jmp     dword ptr Pwr_calli2f_ret
;
; M102 - end
;
Pwr_i2a_next    dw      Pwr_i2a_lab
		dw      Bios_Data

Pwr_i2a_lab:
	pop     ds
	jmp     dword ptr cs:I2a_Vec

IFDEF  POWERALONE
Pwr_i28_next    dw      Pwr_i28_lab
		dw      Bios_Data
Pwr_i28_lab:
	pop     ds
	jmp     dword ptr cs:i28_Vec
ENDIF

Pwr_i16_next    dw      Pwr_i16_lab
		dw      Bios_Data
Pwr_i16_lab:
	pop     ds
	jmp     dword ptr cs:I16_Vec

Pwr_call_i16    dw      Pwr_calli16_lab
		dw      Bios_Data

Pwr_calli16_ret dw      Calli16ret
		dw      0

Pwr_calli16_lab:
	pop     ds

	pushf
	call    dword ptr I16_Vec

	push    ds
	jmp     dword ptr Pwr_calli16_ret

kb_call_i16	dw	kb_calli16_lab
		dw	Bios_Data
kb_calli16_ret	dw	kbChkRet
		dw	0

kb_calli16_lab:
	pushf
	call	dword ptr I16_Vec
	jmp	dword ptr kb_calli16_ret

Pwr_i9_next     dw      Pwr_i9_lab
		dw      Bios_Data
Pwr_i9_lab:
	pop     ds
	jmp     dword ptr cs:I9_Vec

Pwr_i10_next    dw      Pwr_i10_lab
		dw      Bios_Data
Pwr_i10_lab:
	pop     ds
	jmp     dword ptr cs:I10_Vec

Pwr_i13_next    dw      Pwr_i13_lab
		dw      Bios_Data
Pwr_i13_lab:
	pop     ds
	jmp     dword ptr cs:I13_Vec

Pwr_i14_next    dw      Pwr_i14_lab
		dw      Bios_Data
Pwr_i14_lab:
	pop     ds
	jmp     dword ptr cs:I14_Vec

Pwr_i17_next    dw      Pwr_i17_lab
		dw      Bios_Data
Pwr_i17_lab:
	pop     ds
	jmp     dword ptr cs:I17_Vec

Pwr_i21_next    dw      Pwr_i21_lab
		dw      Bios_Data
Pwr_i21_lab:
	pop     ds
	jmp     dword ptr cs:I21_Vec

Pwr_i25_next    dw      Pwr_i25_lab
		dw      Bios_Data
Pwr_i25_lab:
	pop     ds
	jmp     dword ptr cs:I25_Vec

Pwr_i26_next    dw      Pwr_i26_lab
		dw      Bios_Data
Pwr_i26_lab:
	pop     ds
	jmp     dword ptr cs:I26_Vec

Pwr_i6c_next    dw      Pwr_i6c_lab     ;M080
		dw      Bios_Data       ;M080
Pwr_i6c_lab:                            ;M080
	pop     ds                      ;M080
	jmp     dword ptr cs:I6c_Vec    ;M080

; NSM5 BEGIN - i08 hook
; This is the main interrupt used by POWER to do the following:
;	used for time outs on idle interrupts
;	used for counting idle statistics
;	used for polling for / Broadcasting PM event
;	used for periodically update date&time in POWER STD mode
;	used for switching between I16 and I28
;
IN_I08	db	0			; flag  to avoid  I08 reentrancy
;
I08_IdleControl_ptr	label	word
	dw	I08_IdleControl
	dw	0			; needs to be filled in

Pwr_i08_isr	proc	far

	pushf	
	call	dword ptr cs:I08_Vec
	call	dword ptr cs:I08_IdleControl_ptr
	iret

Pwr_i08_isr	endp
;
; NSM5 END

; JAH2 ====================================================================
; JAH2	- Need to keep our own stack when calculating baseline on int 21 exec
;	and while polling APM for PM event and broadcasting it.

Old_SS		dw	0		; JAH2
Old_SP		dw	0		; JAH2

StackInUse	db	0		; JAH2

I21_Stack	dw	STACK_WORDS dup ('TS') ; JAH2
	EVEN				; JAH2
StackTop	LABEL	WORD		; JAH2

; JAH2	- End
; JAH2 ====================================================================
; NSM4 ===================================================================
; NSM4 address of INDOS flag
INDOS_Offset	dw	0		; INDOS flag set while we use 
INDOS_Seg	dw	0		; different stack  to avoid task 
					; swapping
; NSM4 END ===============================================================

End_Data        label   near

	tocode                  ;Bios_Code segment starts

IFDEF   POWERALONE              ; device header needed here only for
				; standalone version - in MSBIO1 for resident
	assume  ds:nothing

	org 0
DEV_HDR dd CDEV_HDR             ; address of next driver in chain
	dw 8000H                ; character device      ; M003
	dw JDEV_STRATEGY	; DOS entry points to driver
	dw JDEV_INTERRUPT
	db 'POWER$  '           ; driver name

CDEV_HDR        dd      -1      ; address of next dev hdr in chain
	dw      8008h           ; CLOCK device (& character)
	dw      JDEV_STRATEGY
	dw      JCDEV_INTERRUPT
	db      'CLOCK$  '      ; driver name

;
; M098 - begin
;
StratPtr	dw	offset DEV_STRATEGY
		dw	BIOS_CODE
PwrIntPtr	dw	offset DEV_INTERRUPT
		dw	BIOS_CODE
ClkIntPtr	dw	offset CDEV_INTERRUPT
		dw	BIOS_CODE

JDEV_STRATEGY:
		jmp	dword ptr StratPtr
JDEV_INTERRUPT:
		jmp	dword ptr PwrIntPtr
JCDEV_INTERRUPT:
		jmp	dword ptr ClkIntPtr

ENDOFSTUB	label	byte

BreakAddr	dw	offset bios_data:end_data
		dw	bios_data

		public	SecondCopy
SecondCopy	db	0		; 1 => second copy of POWER just loaded
				; in UMB, and so no need to display messages
;
; M098 - end
;
;*************** DOS DEVICE REQUEST DEFINITIONS **************

; void DEV_STRATEGY( ES:BX.DOS_REQUEST_HEADER)
; purpose:   Store DOS REQUEST HEADER (ES:BX) for
;            DEV_INTERRUPT routine

DEV_STRATEGY proc far
	push    ds
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	mov     word ptr [RHPTR]+0,bx
	mov     word ptr [RHPTR]+2,es
	pop     ds
	assume  ds:nothing
	ret
DEV_STRATEGY endp

; void DEV_INTERRUPT( [REQHDR].DOS_REQUEST_HEADER)
; purpose:   Executes DOS request; only one fuction is  ; M003
;               supportted by this driver: INIT         ; M003
; for POWER$ driver

DEV_INTERRUPT proc far

	push    ax
	push    dx
	push    bx
	push	cx
	push    es
	push    ds

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	les     bx,[RHPTR]
	cmp     es:[bx].RH_B_CMD,DEVINIT        ; DEVICE INIT?
	jne     dstxxx

;
; M00x
;
	call	far ptr Banner			; Put up our signon Banner
	call	far ptr ChkDOSVer_DispErr	; Check for DOS version

	
	jae	di_continue			; run on DOS 5.0 and above


	mov	word ptr es:[bx].RH_D_BREAKPTR+0, 0
	mov	word ptr es:[bx].RH_D_BREAKPTR+2, cs
	mov	BreakAddr+0, 0
	mov	BreakAddr+2, cs
di_continue:
	call	far ptr DoCmdLine	; process CONFIG switches
	jnz	StayHere		; /low not specified ?

;
; M098 - begin
;
	call	far ptr UMBInit		; try loading ourselves in UMB
	jc	StayHere		; no UMB space ?
	mov	StratPtr+2, ax
	mov	PwrIntPtr+2, ax
	mov	ClkIntPtr+2, ax

	mov	word ptr es:[bx].RH_D_BREAKPTR+0, offset ENDOFSTUB
	mov	word ptr es:[bx].RH_D_BREAKPTR+2, cs

	mov	ax, 0100h			; DONE!
	jmp	short dstex0
StayHere:
; cannot load in UMB or /LOW specified; init our driver and ret
; M098 - end
;
	call    far ptr Power_Init	
	jmp     short dstex0

dstxxx: mov     ax,STERR+03H            ; RETURN DEVICE ERROR,
					; ILLEGAL COMMAND
dstex0: les     bx,[RHPTR]
	mov     es:[bx].RH_W_STATUS,ax
	pop     ds
	assume  ds:nothing
	pop     es
	pop	cx
	pop     bx
	pop     dx
	pop     ax
	ret
DEV_INTERRUPT endp

Bios_Data_Word  dw      Bios_Data               ; Our data segment

;*************** CLOCK$ DEVICE DRIVER STRAT/INT **************
	extrn   tim_read:near
	extrn   tim_writ:near

	extrn   P_UpdFromCMOS:far               ; M081

	public  tim_table

; dispatch table for CLOCK$ driver
;
tim_table       label   byte
	db      (((offset tim_table_end) - (offset tim_table) -1)/2)
	dw      Normal_exit     ; 00    init
	dw      Normal_exit     ; 01
	dw      Normal_exit     ; 02
	dw      Cldev_cmderr    ; 03
	dw      tim_read        ; 04
	dw      Cldev_BusyErr   ; 05
	dw      Normal_exit     ; 06
	dw      Normal_exit     ; 07
	dw      tim_writ        ; 08
	dw      tim_writ        ; 09
tim_table_end:


CDEV_INTERRUPT  proc    far
	assume  cs:Bios_Code,ds:nothing
	push    si
	push    ax
	push    bx
	push    cx
	push    dx
	push    di
	push    ds
	push    es

	lea     si,tim_table

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	
	les     bx,[RHPTR]
	mov     al,es:[bx].RH_B_CMD             ; al = cmd
	cmp     al,cs:[si]
	jae     Cldev_cmd_error
	or      al,al                   ; is it init call
	jz      Cldev_Init

	cbw                             ; note that al <= 15 means ok
	shl     ax,1

	add     si,ax

	les     di, es:[bx].trans       ; M082
	cld                             ; ***** always clear direction
	call    cs:word ptr [si+1]      ;go do command
	assume  ds:nothing
	jc      Cldev_set_stat          ; if function returned status, don't
Cldev_Success:
	mov     ax,100h                 ;  load with normal completion

Cldev_set_stat:
	mov     ds,Bios_Data_Word       ; cas///// note: shouldn't be needed!
	assume  ds:Bios_Data
	les     bx,[RHPTR]
	mov     word ptr es:[bx].status,ax ;mark operation complete

	pop     es
	pop     ds
	pop     di
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	pop     si
	ret

Cldev_cmd_error:
	mov     ax,STERR+03H            ; RETURN DEVICE ERROR,
					; ILLEGAL COMMAND
	jmp     short Cldev_set_stat

Cldev_Init:

IFDEF	POWERALONE
	call	far ptr ChkDOSVer
	jb	Cldev_skipinit		; run on DOS 5.0 and above
ENDIF

	call    far ptr Clock_Init

IFDEF   POWERALONE                      ; M085
	; Return DEVICE DRIVER end address
Cldev_skipinit:
	les     bx,[RHPTR]
	mov     word ptr es:[bx].RH_D_BREAKPTR+0,offset Bios_Data:End_Data
	mov     word ptr es:[bx].RH_D_BREAKPTR+2,ds
;
; M098 - begin
;
	push	ds
	mov	ax, bios_code
	mov	ds, ax
	assume	ds:bios_code
	mov	ax, BreakAddr
	mov     word ptr es:[bx].RH_D_BREAKPTR+0,ax
	mov	ax, BreakAddr+2
	mov     word ptr es:[bx].RH_D_BREAKPTR+2,ax
	pop	ds
	assume	ds:bios_data
;
; M098 - end
;
ENDIF                                   ; M085
	jmp     short Cldev_Success

CDEV_INTERRUPT  endp

Cldev_cmderr    proc    near
	mov     al,3            ; unknown command error
	mov     ah,81h          ; error return
Cldev_Ret:
	stc                     ; indicate abnormal end
	ret

Cldev_BusyErr   label   near
	mov     ah,3            ; indicate busy status
	jmp     short Cldev_Ret

Cldev_cmderr    endp

ELSE                                            ; resident driver version

	extrn   Bios_Data_Word:word             ; supplied externally

	public  power_table
power_table:
	db      (((offset power_table_end) - (offset power_table) - 1) / 2)
	dw      Normal_exit
	dw      Normal_exit
	dw      Normal_exit
; M003 : BEGIN ; remove ioctl support
;       dw      Power_ioctl_read
	dw      Normal_exit
; M003 : END

power_table_end:


ENDIF                                           ; resident driver version

Normal_exit      proc    near

	clc
	ret

Normal_exit      endp

;******************** INT 2F ISR routine for POWER services *************
;  Entry: AL = function code
;       0       Install check
;       
;               EXIT:
;               BX = 504dH (PM) signature if installed  /* M087 */
;
;       1       GET/(Enable/Disable) Power management
;               BH = 0  -> get POWER enabled status
;                  = 1 -> ENABLE DISABLE POWER
;                  BL:bit 0 =T enable Idle detection
;                           =F disable Idle detection
;                  BL:bit 1 =T enable FW/APM 
;                           =F disable FW/APM
;               EXIT:
;                  BH = Prev. Power status (bit 0 & 1 as defined above)
;                  BL = Current power status
;                  CY set if function failed
;
;       2       Get/Set Idle Detection Alg
;               BH = 0 -> Get Current idle detection alg.       
;                  = 1 -> set Current alg.
;                    BL:bit 0 -> T - KeyBoard idle (Int 16 )
;                       bit 1 -> T - Dos Yield (int 28)
;                       bit 2 -> T - App Idle (int 2f 1680)
;                       bit 3 -> T - DOS idle  (int 2a)
;			bit 15 -> T - (DEBUG ONLY) toggle SOUND
;                    BL = 0 -> disable all strategies
;		     BL = 0ffh -> enable all strategies
;               EXIT:
;                       BL = current alg if Get_ALG
;
;	03	Get/Set POWER savings level
;		BL = 0 -> get power savings level
;		    1-8 -> Set power savings level
;		EXIT:
;			BL = current savings level
;
;       80      Get/Set Idle Detection Tuning parameters
;               BX = 0 -> get 
;               else Set
;               CX = size of buffer 
;               DS:SI -> ptr to buffer
;       81      Get Statistics
;               CX = size of buffer
;               DS:SI -> ptr to buffer
;
;       82      Get/Set APM polling count
;               BX = 0 -> get APM polling count
;               else new polling count to be set
;               EXIT:
;                       BL = new polling count
;
;	8F	Get/Set current BaseLineRef
;		ENTRY:
;			BX = 0 -> get BaseLineRef
;			    else Set BaseLineRef
;		EXIT:
;			BX = current BaseLineRef
;			CX = Previous calculated BaseLineRef
;
; M001: Created - NSM
;
Pwr_Services    proc    near

; use a jump table to switch to appropriate services depending on AL value
	push    ds
	push	di
	lea	di,PS_JmpTable
PS_ChkNxtCmd:
	cmp	byte ptr cs:[di],0ffh	; end of table ?
	je	PS_Inv_fn
	cmp	al,cs:[di]
	je	PS_CmdFound
	inc	di
	inc	di
	inc	di
	jmp	PS_ChkNxtCmd
PS_CmdFound:
	inc	di
	jmp	word ptr cs:[di]
	
PS_JmpTable	label	near
; Service jmp table 
; Format:	db	Function no
;		dw	offset of service entry point for this function
;	a value of 0ffh for function no denotes end of jump table
;
	db	0
	dw	PS_Install_Chk
	db	1
	dw	PS_GetSet_PWState
	db	2
	dw	PS_Select_Alg
	db	3
	dw	PS_GetSet_Savings
	db	80h
	dw	PS_Parm_Tune
	db	81h
	dw	PS_Get_Stats
IFDEF	INCL_APM			; M108 APM specific service
	db	82h
	dw	PS_APM_PollCount
ENDIF					; M108 END
	db	8fh
	dw	PS_GetSet_BaseLine
	db	0ffh			; end of table
;
;
PS_Inv_fn:
	mov     ax,ERROR_PM_FUNCTION_NOT_SUPPORTED
PS_FRet:
	stc
	jmp     PS_Ret


;
; FUNCTION 0 - POWER install check call
;
PS_Install_Chk:
	mov     bx,504dH                ; "PM"  ;M087
	mov     ah,POW_MAJ_VERSION      ; M084 major version no
	mov     al,POW_MIN_VERSION      ; M084
	clc                             ; M084
	jmp     PS_Ret                  ; M084

;
; FUNCTION 2 - Get/set Idle detection strategy
;
PS_Select_Alg:
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data

IFDEF DEBUG
	cmp     bl,80h          ; SOUND toggle
	je      PS_Toggle_Sound
ENDIF
	or      bh,bh           ; get current algorithm ?
	je      PS_Get_Alg
				; no, set alg.
	cmp	bl,0ffh		; all bits set ?
	je	PS_Alg_OK
	test    bl,ALG_RESERVED_BITS	; invalid bits set ?
	jz	PS_Alg_OK
	jmp     PS_Inv_Parm_Err
;
PS_Alg_OK:
	and	bl,NOT ALG_RESERVED_BITS
	xor     bh,bh
	and	[CONTROL].IDLE_FLG,ALG_RESERVED_BITS ; clear current strategey
					; except SOUND bit
	or      [CONTROL].IDLE_FLG,bx
	and	bl,(DOSYIELD_ACTIVE + KYC_ACTIVE)
	and	[CONTROL].IDLE_FLG, NOT AUTO_ACTIVE	; turn off AUTO 
	cmp	bl,DOSYIELD_ACTIVE + KYC_ACTIVE
	jne	PS_Get_Alg		; set AUTO bit if both I16 & I28
	or	[CONTROL].IDLE_FLG,AUTO_ACTIVE	; selected

; M094 - Fall through to return the current algorithm in BL

PS_Get_Alg:
	mov     bx,[CONTROL].IDLE_FLG   
	and     bx,NOT ALG_RESERVED_BITS
	test	[CONTROL].IDLE_FLG,AUTO_ACTIVE	
	jz	PS_SRet			; if AUTO, then say both I16 & I28 are
	or	bx,(KYC_ACTIVE+DOSYIELD_ACTIVE)	; enabled
	jmp     short PS_SRet

IFDEF DEBUG                     ;Toggle sound only for DEBUG VERSION
PS_Toggle_Sound:
	xor     [CONTROL].IDLE_FLG,SOUND_ACTIVE ; toggle the sound flag
	jmp     short PS_SRet
ENDIF

; FUNCTION 82 - get set APM poll count
;
IFDEF	INCL_APM			; M108 APM specific service
PS_APM_PollCount:                               ; 7 change APM poll count
	call    Do_APM_GetSet_PollCount
	jmp     short PS_SRet 

ENDIF					; M108 END
	assume  ds:nothing
;
; FUNCTION 80 - GET/SET tuning parameters (CONTROL)
;
PS_Parm_Tune:                           ; 4 Tune various POWER.SYS parameters
	cmp     cx, size CONTROL_INFO - SWITCH_DLY
	jb      PS_Buff_Ovf_Err
	push    si                      ; M086
	push    di
	push    es
	mov     es,Bios_Data_Word
	assume  es:Bios_Data
	lea     di,[CONTROL].SWITCH_DLY
	assume  es:nothing
	or      bx,bx                   ; get parm or set parm ?
	jnz     PS_DoCopy               ; if set parm 
	mov     bx,-1
PS_Exch_ESDS_SIDI:
	push    es
	push    ds
	pop     es
	pop     ds
	xchg    si,di
	or              bx,bx
	jz      PS_EndCopy
PS_DoCopy:
	rep     movsb                   ; transfer data
	inc     bx
	jz      PS_Exch_ESDS_SIDI
PS_EndCopy:
	pop     es
	pop     di
	pop     si                      ; M086
	jmp     short PS_SRet

; FUNCTION 81 - Get IDLE Statistics
;
PS_Get_Stats:

IFDEF INCL_APM
	cmp     bx,PW_GET_APM_STATS     ;                               ; M076
	ja      PS_Inv_Parm_Err         ; invalid info level ?
	je      PS_Get_APM_Stats        ; APM statistics (resume count ) ?
ELSE
	or      bx,bx                   ; only Idle detection stats will be
	jnz     PS_Inv_Parm_Err         ; returned
ENDIF
	cmp     cx,size IDLE_INFO       ; No, Idle detection statistics
	jb      PS_Buff_Ovf_Err         ; Buffer not sufficient         ; M076
	push    si                      ; M086
	push    di
	lea             di,     INFO
PS_Transf_Stats:
	push    es
	mov     es,Bios_Data_Word
	assume  es:Bios_Data
	assume  es:nothing
	mov     bx,-1                   ; get stats ; there is no set stats
	jmp     short PS_Exch_ESDS_SIDI

IFDEF   INCL_APM

PS_Get_APM_Stats:
	cmp     cx, APM_STATS_STRUC_SIZE
	jb      PS_Buff_Ovf_Err         ; Buffer not sufficient         ; M076
	push    si                      ; M088
	push    di
	lea     di,APM_RESUME_COUNT
	jmp     short PS_Transf_Stats

ENDIF   ; of IFDEF INCL_APM

PS_Inv_Parm_Err:
	mov     ax,ERROR_PM_INVALID_PARAMETER
	stc
	jmp     short PS_Ret

PS_SRet: xor    ax,ax                   ; M084 : Clear CY and  put
					; 0 in AX to mean no error
PS_Ret:
	pop	di
	pop     ds
	ret

; FUNCTION 3 - Get/Set POWER Savings level
;NSM1 BEGIN
PS_GetSet_Savings:
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	test    [POWER_STATUS],SW_IDLE_ACTIVE
	jz	PS_Inv_Parm_Err
	or	bx,bx
	jz	PS_Get_Savings
	cmp	bx,MAX_SAVINGS_VALUE
	ja	PS_Inv_Parm_Err
	mov	[Savings_Mode],bx
	call	SetSavingsValues
PS_Get_Savings:
	mov	bx,[Savings_Mode]
	jmp	short PS_SRet

PS_Buff_Ovf_Err:
	mov     ax,ERROR_PM_BUFFER_TOO_SMALL
	jmp     PS_FRet

; FUNCTION 1 - Get/Set POWER state
;
PS_GetSet_PWState:
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	or      bh,bh           ; get power state ?
	call    GetPowStatus    ; M089 : old state in AL
	mov     bh,al           ; get old status
	mov     ax,0            ; M084 : Assume no error 
	jz      PS_APM_Ret      ; M084 
	test    bl,PWSTATE_RESERVED_BITS
	jnz     PS_Inv_Parm_Err
	push    bx              ; save old status on stack
; set power status
	test    bl,1            ; check for POWER.SYS/EXE enable
	jnz     PS_Enable_Power
; disable POWER.SYS
	test    POWER_STATUS,SW_IDLE_ACTIVE
	jz      PS_Test_APM_Bit         ; already disabled
;
	and     POWER_STATUS,NOT(SW_IDLE_ACTIVE)     ; turn off S/W PM
	jmp     short PS_Test_APM_Bit
PS_Enable_Power:
	test    POWER_STATUS,SW_IDLE_ACTIVE
	jnz     PS_Test_APM_Bit         ; already enabled
	or      POWER_STATUS,SW_IDLE_ACTIVE          ; turn on S/W PM
;
PS_Test_APM_Bit:
;
IFDEF   INCL_APM
	call    Do_APM_Control
ENDIF
;
	pop     bx                      ; get back old status
;
; M084: NSM
; At this point :
; CY set if error 
;       AX = error code
; NC -> AX = 0
;
PS_APM_Ret:
	push    ax                      ; M089  BEGIN
	call    GetPowStatus            ; status in al
	mov     bl,al                   ; return with current status
	pop     ax                      ; M089  END
	jmp     PS_Ret

; FUNCTION 8F - get/set BaseLineRef
PS_GetSet_BaseLine:
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data
	or	bx,bx			; get base line ?
	je	PS_GetBaseLine
	mov	[BaseLineRef],bx
	mov	[KYC].BASE,bx		; also change our current Kbd base
					; for immediate effect
;
PS_GetBaseLine:
	mov	bx,[BaseLineRef]
	mov	cx,[BaseLineOvf]
	jmp	PS_SRet

Pwr_Services    endp

; FAR call for PWR_SERVICES procedure - used for init time settings
;
FPwr_Services	proc	far
	call	Pwr_Services
	ret
FPwr_Services	endp

;****************************** GetPowStatus **********
; Get the current power status
; Entry: none
; Exit:  AL:Bit 0 - 1 if S/W PowMgmt enabled
;           Bit 1 - 1 if H/W PowMgmt enabled
; Regs: AX
; M089: Created
; NOTE: we have no way of knowing whether we are in STD mode or not
; The only way we can find that out is by looking at our flags to see 
; if APM was in enabled state last time when we were connected to it
; and IF we are not connected to APM at present. This is the reason
; for this procedure's existence. 
;******************************************************************
GetPowStatus    proc    near
	pushf
	mov     al,POWER_STATUS
	test    al,FW_IDLE_ACTIVE           ; test for H/W enabled state
	jnz     GPS_Ret			
; H/W not connected state; let us see if it is atleast enabled from what
; we know of before last disconnect.
IFDEF   INCL_APM
	test    fAPM_STATE,1            
	jz      @f
	or      al,2            ; H/W pow.mgmt enabled - POWER STD mode
@f:
ENDIF                   ; IFDEF INCL_APM
GPS_Ret:
	popf
	ret
GetPowStatus    endp

IFDEF   INCL_APM
;****************************** Do_APM_GetSet_PollCount **********
; INT 2F subfunction service procedure 
; To get/set the APM pollcount
; Entry: BX = 0 -> get APM poll count
;               otherwise, New poll count to be set
; Exit:  BX = new APM Poll count
; Regs: BX,DS,Flags
;******************************************************************
Do_APM_GetSet_PollCount Proc    NEAR

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	or      bx,bx
	jz      DAPC_Get_PollCount
	mov     [APM_MAX_POLLCOUNT],bx		; ref.counter
	mov     [APM_POLL_COUNT],bx             ; M093 current counter
	jmp     short DAPC_Ret 
DAPC_Get_PollCount:
	mov     bx,APM_MAX_POLLCOUNT
DAPC_Ret:
	ret

Do_APM_GetSet_PollCount endp

;****************************** Do_APM_Control *********************
; INT 2F subfunction service procedure 
; To (enable-connect to)/(disable-disconnect from) APM
; Entry:  BL = 3 -> connect and enable APM              ; M089
;         BL = 2 -> stay disconnected but enable it if needed
;         BL = 1 or 0 -> disconnect and disable
;
; Exit:  CY if operation failed
;               ax = error code
;        ELSE AX = 0
;
;       (POWER_STATUS flags updated properly
;        fAPM_STATE also updated)
;       APM_RESUME_COUNT initialised to zero if enable successful
;
; Regs: ax,bx,cx,dx
;******************************************************************

Do_APM_Control  proc    near

	cmp     bl,2            ; check for F/w PM bit enable
	jae     DACt_Enable_APM

; M089 BEGIN
; With the new definition of POWER STD, we need to enable APM but not
; connected to it (and sometime disable APM but we would not have been
; connected to it for doing it). Enable/disable can only be done if we
; are connected to APM and so We first connect to APM to enable/disable
; APM and depending on the requested state, we disconnect from APM
;
; Disconnect and disable APM
	and     [CMOSFlg],NOT(1)        ; M091 reset STD mode+APM bit in CMOSFlg
	test    POWER_STATUS,FW_IDLE_ACTIVE     ; are we  connected already ?
	jnz     DACt_Dis_con_able       ; yes, just disable and disconnect
; we are not connected ; so go connect to it first, enable it
; and then disable it!

IFDEF POWERALONE
	call    far ptr Check_and_Init_APM ; M003: always check for APM presence
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF
; M089 END
DACt_Dis_con_able:
	test    fAPM_PRESENT,1          ; M003:no need to do anything if APM not
	jz      DACt_End                ; M003:present
; disable APM
	mov     cx,APM_DISABLE_FUNC
	call    Do_APM_Enable_Disable   ; disable APM ;M005
	jc      DACt_End
	mov     fAPM_STATE,0            ; flag APM disabled state
	call    Do_APM_DisConnect
	and     POWER_STATUS,NOT (FW_IDLE_ACTIVE)            
	jmp     short DACt_End
DACt_Enable_APM:
	push    bx                      ; save the desired state (input)

;M089 BEGIN
	test    POWER_STATUS,FW_IDLE_ACTIVE
	jz      DACt_Connect            ; Go connect and enable
	test    fAPM_STATE,1            ; are we also enabled ?
	jnz     DACt_ChkForDiscon       ; yes, go see if we have to disconnect
	mov     cx,APM_ENABLE_FUNC
	call    Do_APM_Enable_Disable   ; enable APM 
	mov     fAPM_STATE,1            ; flag APM enabled state

DACt_Connect:
;M005 BEGIN - for resident driver call Check_and_Init_APM through pointer

IFDEF POWERALONE
	call    far ptr Check_and_Init_APM ; M003: always check for APM presence
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF ; POWERALONE

;M005 END

	jnc     DACt_ChkForDiscon       ;  before connecting to it
	jz      DACt_APM_ConnErr        ; ignore if APM not present
	clc

DACt_ChkForDiscon:
	pop     bx                      ; get back requested APM state
	and     [CMOSFlg],NOT(1)        ; assume not stdmode+apm
	cmp     bl,3                    ; both S/W and F/W pwmgmt ON ?
	je      DACt_End                ; Yes, all done

; User requested APM be ON but we should stay disconnected (POWER STD)

	call    Do_APM_DisConnect
	and     POWER_STATUS,NOT (FW_IDLE_ACTIVE)            
	test    fAPM_PRESENT,1          ; M091
	jz      DACt_End                ; M091
	or      [CMOSFlg],1             ; M091 set POWER_STDMODE+APM
	mov     [CMOSPollCount],MAXCMOSPOLLCOUNT ; M091
; M089 END

DACt_End: xor   ax,ax                   ; M094  - ax=0 -> no error
DACt_Ret:
	ret

DACt_APM_ConnErr:
	pop     bx
	mov     ax,ERROR_PM_ALREADY_CONNECTED   ; put valid error code here
	stc
	jmp     short DACt_Ret

Do_APM_Control  endp

ENDIF
;********************** TIMER TIC READ ROUTINE *******************
;********************** OEM EXTENDABLE ***************************
; ax = READ_TMR0( void)
; purpose: to return tic stored in timer0
;
; M0FF:
; OEMs NOTE:
; This procedure should always return a count between 64k and 1
; This code assumes the existence of 8253 chip only and does not care for
; the double countdown in mode 3. The algorithm in Chk_delay will take care
; of that problem to quite some extent.
;
; There is an alternate code for 8254 chip included here (within IFDEFs).
; Using this code, if the machine has 8254, will result in accurate timings.
;
; Further CAVEAT: WIN 3.0 does not support the readback command used in the
; 8254 code here and so POWER will not work properly if 8254 code is used 
; with win 3.0 even if the machine has an 8254.
;
; DOS usually uses mode 3 in both 8253/54. ( mode 2 counts the MAXCOUNT
; just once whereas mode counts it twice in a tic period). But in 8254,
; we can get half cycle we are in, in mode 3 whereas we can't get that
; info in 8253.   

PUBLIC Read_tmr0
Read_tmr0 proc near
	assume  ds:nothing, es:nothing

IFNDEF	_8254
;
; 8253 code

	cli
	mov     al,0
	out     43h,al
	jmp     $+2
	in      al,40h
	jmp     $+2
	mov     ah,al
	in      al,40h
	sti
	xchg    ah,al
	ret
ELSE				; 8254 specific code
	push    bx
	mov     al,0c2h         ; read mode as well as count of tmr0
	cli
	out     43h,al
	jmp     $+2

	in      al,40h		; status byte
				; bit 7 -> first half cycle
				; bit 1-3 -> mode 
	mov     bl,al		; save status in bl&bh
	mov     bh,al
	jmp	$+2

	in      al,40h		; low byte of count
	jmp     $+2
	mov     ah,al

	in      al,40h		; high byte of count
	sti
	xchg    ah,al		; ax = current tmr count

	and     bl,0eh          ; mask everything but mode bits 
	cmp     bl,6            ; mode 3 ?
	jne     rt_ret		; if mode 2 no need for adjustments
	shr     ax,1            ; halve for mode 3 cycle 1
	test    bh,80h          ; is this cycle 2 ?
	jz      rt_ret		; yes, the count is already correct 
	add     ax,8000h        ; first cycle, so add 32k to the count
rt_ret:
	pop     bx
	ret
ENDIF

Read_tmr0 endp

; ******************************* SOUND routines **********************
IFDEF DEBUG                  ; only use this code on test version

START_SOUND proc

	mov     al,0
	out     42h,al
	jmp     $+2
	mov     al,50h
	out     42h,al

	mov     al,3
	in      al,61h
	jmp     $+2
	or      al,3
	out     61h,al
	ret

START_SOUND endp

END_SOUND proc
	in      al,61h
	jmp     $+2
	and     al,not 3
	out     61h,al
	ret
END_SOUND endp

ENDIF                                   ; IFDEF DEBUG

; *****************************************************

; Z.flag CheckV86()
; return - NZ, if 386 V86 or protected  mode
;	   ZR  if real mode
; OEMS: NOTE:
; the flag CV86FLG in CONTROL data controls checking 86 mode.
; This procedure is just there so that we can avoid executing a CPU HLT in
; protected mode, if the protected mode software does not support HLT properly.
; Most DOS extenders/EMS and protected mode software supports HLT instruction
; and so, the default is : WE DON'T CHECK for Protected mode for doing HLTs.
; 

PUBLIC CheckV86
CheckV86 proc near
	assume  ds:Bios_Data, es:nothing

	test    [CONTROL].CV86FLG,1     ; Avoid  test
	jz      cv8ret                  ; if bit cleared

	test    [CONTROL].CV86FLG,2             ; is it a 386?
	jz      cv8all                  ; don't know yet ...
cv8386:
	.386p
	smsw    [MSW]

	.8086
	test    [MSW],1                 ; check for protected mode
	ret                             ; NZ, yes

cv8all: push    ax                      ; run through all proccesors

	push    sp                      ; below 286?
	pop     ax
	cmp     sp,ax
	jne     cv8ex0                  ; yes, disable check

	pushf                           ; check TS
	pop     ax                      ; should be zero for 286
	or      ax,4000h                ; try setting TS high
	push    ax
	popf
	pushf
	pop     ax                      ; restore TS

	test    ax,4000h                ; did it remain 0?
	jz      cv8ex0                  ; yes, 286

	pop     ax
	or      [CONTROL].CV86FLG,2     ; Set 386 bit to save time
	jmp     short cv8386

cv8ex0: xor     ax,ax                   ; We don't have to test again
	mov     [CONTROL].CV86FLG,ax    ; return ZF
	pop     ax

cv8ret: ret
CheckV86 endp

;***************** DO_IDLE_DOS ****************
; BUGBUG - nagara - this procedure is never called and can safely be
; removed  for POWER version 1.0. (note that there is a reference to this
; procedure in power_init procedure at the end of this file)
;
PUBLIC Do_idle_dos
Do_idle_dos proc far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data
	call    DO_IDLE
	pop     ds
	assume  ds:nothing
	ret

Do_idle_dos endp

; ***************************  DO_IDLE ***************************
; ************************ OEM EXTENDABLE ************************
;
; CY.flag DO_IDLE()
; purpose: To put CPU in a low power state via a halt or
;          OEM supplied OEM_IDLE routine.
; passed:  control.IDLE_FLG - enables/disables DO_IDLE
; return:  Carry Set, if IDLE was executed
;
; EntryPoints: I2fIdleEntry
; PseudoCode:
;	Do_idle:
;		if (I2f_aware app) ret;
;	I2fIdleEntry:
;		if (Idle_detection disabled) ret;
;		if (activity detected)
;			ret;
;		if (int flags disbled) ret;
;		update idle statistics counter;
;		if (SOUND-ACTIVE)
;			start sound;
;		set IDLTIC flag;
;		if (APM enabled)
;			call APM_CPU_IDLE
;		else
;			if (OEM_EXTENDED)
;				call OEM_EXTENSION
;			else
;				if (not protected mode)		\\ checkV86
;				do CPU_HLT
;		// end of idle
;		if (SOUND_ACTIVE)
;			end sound;
;		ret.

PUBLIC Do_idle
Do_idle proc near
	assume  ds:Bios_Data, es:nothing

; JAH3 Start - If app supports IDLE only idle on int 2f idle entry point below


	push	ax			; M099
	push	ds
	mov	ds,PSPsegment		; DS:BX --> Current PSP in Dosdata
	assume	ds:nothing
	mov	ax,WORD PTR ds:[CUR_PSP_OFFSET]	; ax -> current app's PSP M099
	pop	ds			; M099
	assume	ds:Bios_Data
	cmp	ax, PSPOf2fApp		; M099
	pop	ax			; M099

	je	didex1			; Idle aware app so don't idle

	PUBLIC I2fIdleEntry
I2fIdleEntry:				; Entry point from int 2fh handler

; M103 - BEGIN - (code moved from do_idle entry)
; Check for POWER OFF. If IDLE DETECTION is disabled, we should not do idles.

	test    POWER_STATUS,SW_IDLE_ACTIVE ; do this only if IDLE_DETECT enabled
	jnz     didbgn
didex1: clc                             ; idle failed  to execute
	ret

didbgn:
; M103 END
	push    ax

	; if activity has been detected DO_IDLE will be avoided
	; for a period measured in timer interrupts

	cmp     [SPDUP],0               ; is system speed up?
	je      did1ot

	mov     ax,[SPDUP_DLY]          ; check if enough time
did3ot: cmp     [SPDUP_CNT],ax          ; has passed to return
	jae     did2ot                  ; to normal idle

didxxx: pop     ax
	jmp     short didex1

did2ot: mov     [SPDUP],0
	mov     [SPDUP_DLY],0

did1ot: in      al,21h                  ; get interrupt mask
	test    al,3h                   ; make sure timer and
	jnz     didxxx                  ; keyboard aren't masked 

	add     word ptr [INFO].IDLE_TOT,1
	adc     word ptr [INFO].IDLE_TOT+2,0


IFDEF DEBUG

	test    [CONTROL].IDLE_FLG,SOUND_ACTIVE
	jz      did0ot

	call    START_SOUND

ENDIF                                   ; IFDEF DEBUG

did0ot: mov     [IDLTIC],1              ; set IDLE flag ; M004

didhlt:

IFDEF INCL_APM
; Note that we should also see if we are connected to APM or not. But it is not
; needed because fAPM_STATE will be 1 for only STD mode or ADV mode.
; And we will come here only for ADV mode, and SW_IDLE_DETECTION_ONLY cases
; in the second case, we should disabled APM and so fAPM_STATE will be 0
;
	cmp     fAPM_STATE,0            ; is APM present and enabled ?
	je      didNoAPM
	call    Do_APM_Idle
	jmp     short didResume
didNoAPM:
ENDIF   ; for IFDEF INCL_APM

IFDEF OEM_EXTENSION
	call    OEM_IDLE
ELSE
	call    CheckV86                ; M004 AVOID HLT IN V86
	jnz     didNoHlt
	sti                             ; interrupts must be enabled
	hlt                             ; or system will halt ...
didNoHlt:
ENDIF

didResume:

didot2: 
IFDEF DEBUG        
	test    [CONTROL].IDLE_FLG,SOUND_ACTIVE
	jz      didex0

	call    END_SOUND
ENDIF                                    ; IFDEF DEBUG

didex0: pop     ax
	stc                             ; CY.set halt executed
	ret
DO_IDLE endp

;********************* APM functions ***********************************

IFDEF INCL_APM

;********************* APM IDLE routine ********************************
; Called by Do_Idle procedure when APM BIOS is present
; 
; Psuedocode:
;       call APM_IDLE API
;       if (clock changes for CPU_IDLE API) {
;               call CPU_BUSY API
;       }
;
; Entry: nothing
; exit: nothing
;
;***********************************************************************
; Do_APM_CPUBUSY        Entry Point             (M002 addition)
;       Calls APM CPUBUSY API to return CPU to full speed after a resume
;               or a CPU_IDLE
; Entry: none
; Exit: none
;***********************************************************************
 
Do_APM_Idle     Proc    near

	push    bx
	mov     ax,APM_CPUIDLE_FUNC
	int     15h             ; make CPU_IDLE API call
	pop     bx
;
Do_APM_CPUBUSY  label   near            ; M002; added this entry point
;
; Check if we need to make a CPU_BUSY call 
	test    APM_FLAGS,APM_SLOW_CLOCK        ; does CPU_IDLE slows clock ?
	jz      dai_End

; need to make CPU_BUSY call
	push    bx
	mov     ax,APM_CPUBUSY_FUNC
	int     15h             ; make CPU_BUSY call to speedup CPU
	pop     bx
dai_End:
	ret

Do_APM_Idle     endp

;********************* Do_APM_Connect **********************************
; Purpose: to connect to APM BIOS as the coop.process (real mode only)
; Entry: none
; exit: CY      - connect failed
;               ax = error code
;       NC      - connection succeeded
;***********************************************************************

Do_APM_Connect  proc    near            ;M005

	test    fAPM_PRESENT,1          ; Do this only if APM is present
	jz      DAC_End
	mov     ax,APM_CONNECT_FUNC
	mov     bx,APM_SYSTEM_BIOS
	int     15h
	jc      DAC_End
	mov     fAPM_CONNECT,1
DAC_End:
	ret
Do_APM_Connect  endp

;********************* Do_APM_Disconnect **********************************
; Purpose: to disconnect from APM BIOS 
; Entry: none
; exit: CY      - Disconnect failed (can this ever happen ?)
;               ax = error code
;       NC      - disconnect succeeded
;***********************************************************************

Do_APM_Disconnect       proc    near

	test    fAPM_CONNECT,1          ; disconnect only if WE are 
	jz      DAD_End                 ; connected     
	mov     ax,APM_DISCONNECT_FUNC
	mov     bx,APM_SYSTEM_BIOS
	int     15h
	jc      DAD_End
	mov     fAPM_CONNECT,0
DAD_End:
	ret
Do_APM_Disconnect       endp
;********************* Do_APM_Enable_Disable **********************************
; Purpose: to enable/disable all power management 
;
; Entry: CX = APM_DO_DISABLE -> disable all power management
;           = APM_DO_ENABLE  -> enable all power management
;
; exit: CY      - function unsuccessful
;               ax = error code
;       NC      - function succeeded
;***********************************************************************


Do_APM_Enable_Disable   proc    near    ;M005

	mov     ax,APM_ENABLE_DISABLE_FUNC
	mov     bx,APM_ALL_DEVICES
	int     15h
	jnc     DAED_Ret
	mov     ax,ERROR_PM_NOT_CONNECTED
DAED_Ret:
	ret

Do_APM_Enable_Disable   endp


ENDIF           ; for IFDEF INCL_APM 

;********************* General Idle Check Routine **********************
; GUTS of INT16/INT28 IDLE DETECTION CODE
;
; purpose: called by INT 28 and 16 interrupt handlers
;       This is the common routine which checks elapsed time between
;       interrupts in order to adjust idle signaling.
;
;       Entry : SI = base address of PERIOD_INFO structure for this interrupt
;               DI = address of total delay accumulator for this interrupt
;               BX = address of time accumulator for this interrupt
;               DS = our data segment
;       Exit  : nothing
;
;	REGS USED: AX,CX,FLAGS
;
; 	(Look at the POWER.EXE documentatiion for a complete alg. description
;	and pseudocode).


public Chk_Delay
Chk_Delay       proc
	assume  ds:Bios_Data, es:nothing
;entry point for I28 idle checking
	xor	cx,cx

; entry point for i16 idle checking
; for i16: cx = 1

Chk_i16idle	label	near
;
	test    [POWER_STATUS],SW_IDLE_ACTIVE  ; is idle detection on ?
	jz      cd_Ret			;
;
; if we see a timer tic bet last int and this int, we probably waited too
; long (or we cannot accurately calculate the time between them)
	push    ax
	cmp     word ptr [bx]+2,1      ; waited too long?
	jae	cd_ClrTmr		;NSM3 yes, do a recount

cd_readtime:
	call    READ_TMR0               ; read return time (in AX)
	sub     [bx],ax			; NSM3
	jc	cd_ClrTmr		; Go recount on overflow

; check for a very high value of time interval
;
cd_1: 	mov     ax,[si].BASE            ; is TIC >= BASE+THRESHOLD?
	add     ax,[CONTROL].THRESHOLD
	jnc     cd_2
	mov     ax,0FFFFh

cd_2:
	cmp     [bx],ax
	jae     cd_transf_period        ; yes, ignore reading   
;
; branch off for adapt/idle cycles
;
	cmp     word ptr [si].ADAPT,0   ; are we in adapt cycle ?
	jne     cd_doAvg		; yes go do avg.

; IDLE CYCLE:
; we are in idle cycle. check to see if we are within allowed limites for
; idle
	mov     ax,[si].BASE            ; is TIC <= BASE+NOISE?
	add     ax,[si].NOISE
	cmp     [bx],ax
	ja      cd_adapt                 ; no, go for adapt
;
;BUGBUG: we are only checking for upper limit and do not check for lower limit
; Checking lower limits will help us avoid some aliasing problems with the 8253
; timer reading code. (nagara dec/91)

; idle cycle processing

cd_doidle:
	call    DO_IDLE
	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	mov     word ptr [bx]+2,0       ; avoid speed up error

cd_transf_period:
	mov	ax,[bx]			; take current interval and store it
	mov     [si].PERIOD,ax		; as PERIOD
cd_ClrTmr:
	call    ClearTimer              ; do APP_speedup if needed, clear 
					; timer accumulator for this int.
	pop     ax

cd_Ret:
	ret



; ADAPT CYCLE PROCESSING:
;
; try calculating avg.
; [bx] = current period
; [si].PERIOD = avg so far
; if the current period is not within 50% of prev. avg we check to see if
; we can ignore this period for avg and go for next one. If we have seen 
; a no of such high(or low) values in the cycle so far, then start adapt
; cycle all over again

cd_doAvg:
	mov     ax,[CONTROL].ADAPT_DLY
	cmp     [si].DELAY,ax           ; is delay over?
	jae	cd_end_adapt		; yes, go cmp our avg with baselineref
	mov	ax,[si].PERIOD
	push	ax
	add	ax,[si].PSPREAD		; ax = Higher limit for spread
	cmp	ax,[bx]			; is current period more than spread 
        pop	ax			; above our prev. period/avg
	jb	cd_throw_sample
	sub	ax,[si].PSPREAD		; ax =  lower limit for spread
	cmp	ax,[bx]			; 
	ja	cd_throw_sample		; if current period < lower spread limit
					; then throw sample
;IFDEF OLDVERSION
;	mov	ax,[bx]			; get current period
;	add	ax,[si].PERIOD		; add previous period
;	jnc	cd_4
;
;current avg + period is >64k. 
; no point in trying to find an avg with these figures. go take new avg
;
;	mov	ax,[BaseLineRef]
;	jmp	short cd_5
;
;cd_4: 	shr	ax,1
;
;cd_5:	mov	[bx],ax
;ELSE
;
; M106 - BEGIN  - collect 16 sample timings and do avg on them ; use this avg
; for the next 16 samples. 
	mov	ax,[bx]			; get current period
	add	[si].ACC_COUNTER,ax	; add it to accumulated value
	adc	[si].ACC_HI,0
	inc	[si].SAMPLE_COUNT
	cmp	[si].SAMPLE_COUNT,MAX_SAMPLES_PER_AVG	
	jb	cd_ClrTmr
	push	dx
	mov	dx,[si].ACC_HI
	mov	ax,[si].ACC_COUNTER
	shr	dx,1
	rcr	ax,1			; /2
	shr	dx,1
	rcr	ax,1			; /4
	shr	ax,1			; /8
	shr	ax,1			; /16
	add	ax,[si].PERIOD		; add previous avg
	shr	ax,1			; / 2
	pop	dx
;ENDIF
; M106 END

cd_SetNewAvg:
	mov     [si].PERIOD,ax
	call	CalcNewSpread
	mov	[si].PSPREAD,ax
; M106 BEGIN - initialise the time accumulation counters for avg.
;IFDEF OLDVERSION
;ELSE
	mov	[si].ACC_COUNTER,0
	mov	[si].ACC_HI,0
	mov	[si].SAMPLE_COUNT,0
;ENDIF
; M106 END
	jmp	short cd_ClrTmr        	; go for next int


; START ADAPT_CYCLE:
; we are above the allowed idle limits; go for adapt cycles

cd_adapt:
	mov     word ptr [si].ADAPT,1   ; start measuring increase
	mov     word ptr [si].DELAY,0
	mov	[ErrSampleCount],0
	mov	ax,[bx]
	jmp     short cd_SetNewAvg

cd_end_adapt:
	mov     word ptr [si].ADAPT,0
	mov     ax,[si].PERIOD             ; for next compare ...
	jcxz	cd_setbase		; for i28 and i2f, no baseline ref.
	cmp	ax,[BaseLineRef]	; for i16, have a max limit for period
	jbe	cd_setbase		; 
	mov	ax,[BaseLineRef]
	mov	[si].BASE,ax		; go up to the max.allowed base
	call	CalcNewNoise
	mov	[si].NOISE,ax
	jmp	cd_transf_period

; Count the errors while in adapt cycle; if the error count exceeded the
; max allowed value, start the adap cycle all over again with the last error
; interval as the new AVG
;
cd_throw_sample:
	inc	[ErrSampleCount]	
	mov	ax,[ErrSampleCount]
	cmp	ax,[CONTROL].MAXERRSAMPLE
	ja	cd_adapt		; go try adapting again
	jmp	cd_ClrTmr

cd_setbase:
	mov     [si].BASE,ax
	call	CalcNewNoise
	mov	[si].NOISE,ax		; noise = some % of base depending on
					; current savings mode
	jmp	cd_doidle
	
Chk_Delay       endp


;*************** Timer clear and app speedup adjustment
;       Helper routine for Chk_Delay.  Called independently
;       by I16_IDLE when it detects a key waiting.  Calls APP_SPDUP
;       if required, and clears out timer overflow
;
;       Entry : BX = address of timer accumulator for this interrupt
;       Exit  : nothing
;       Uses AX -- caller must preserve

public  ClearTimer
ClearTimer         proc
	assume  ds:Bios_Data
	cmp     word ptr [bx]+2,3	; BUGBUG - nagara; this code is
				; strange; it looks for 3 timer tics ?
	jb      ct_0
	call    APP_SPDUP               ; speedup proportional
					; to delay...
ct_0:
	mov     word ptr [bx]+2,0       ; clear key timer
	call    READ_TMR0		; read current timer value and
	mov     [bx],ax			; store it 
	cmp     word ptr [bx]+2,0
	jne     ct_0

	ret

ClearTimer         endp


;********************* APPLICATION IDLE CHECK *******************
; purpose: check application idle (INT 2F Function 1680H)
;          if interrupt is detected than DO_IDLE should be called
;          the interrupt should be absorbed.
; PseudoCode:
;	if (win enh mode startup)
;		set flag to avoid BaseLineRef calculation at EXEC time
;	if (TaskSwapper startup or Win Enh mode startup)
;	( call previous int 2f guy
;	  store the prev. inst.data ptr
;	  pass back our inst data ptr
;	  iret
;	}
;	if (win enh mode end)
;		reset flag to start BaseLineRef calc at EXEC time
;	if (idle interrupt) {
;		if (idle detection/i2f strategy disabled) chain to next guy;
;		remember current PSP as I2f_Aware app
;		call do_idle;
;		iret
;	}
;	if (POWER API call)
;		service the API call;
;		iret
;	else
;		chain to next i2f guy
;	

PUBLIC I2f_idle
I2f_idle proc   far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds, Bios_Data_Word
	assume  ds:Bios_Data
;
	cmp	ax, 4b05h		; TaskSwapper startup ?	M100
	je	Instance_pwr		; M100
;
	cmp	ax,(MultWin386 * 256 + Win386_Init)	; NSM2
	je	I2fWinEnhStart				;NSM2
	cmp	ax,(MultWin386 * 256 + Win386_Exit)	;NSM2
	je	I2fWinEnhEnd				;NSM2
;
	cmp     ax,1680h                ; Any app idles?
	jne     i2F_chk_ours            ; check for a service call to us

; JAH3 Set PSPOf2fApp to the current app's PSP

	test    [POWER_STATUS],SW_IDLE_ACTIVE	;Make sure idle_detect is on
	jz	i2Fnxt			; Power is off so just chain
	test    [CONTROL].IDLE_FLG,APP_ACTIVE ; Make sure power is on
	jz	i2Fnxt			; Power is off so just chain


	push	ax			; M099
	push	ds
	mov	ds,PSPsegment		; DS --> Current PSP in Dosdata
	assume	ds:nothing
	mov	ax,WORD PTR ds:[CUR_PSP_OFFSET] ; ax -> current app's PSP M099
	pop	ds
	assume	ds:Bios_Data
	mov	PSPOf2fApp, ax		; M099
	pop	ax

; JAH3 end 

; load up registers and call do_idle
	push    di
	lea     di,[INFO].APP_TOT

; JAH	call    DO_IDLE			
	call	I2fIdleEntry		; JAH Use new idle entry point

	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0

I2FIdleCleanup:				; JAH New label
	pop	di
	pop	ds
	iret

i2Fnxt: 
	jmp     dword ptr pwr_i2f_next

i2f_chk_ours:
	cmp     ah, MultPWR_API         ; is this a call for one of our ; M077
	jne     i2fnxt                  ; services ?
	pop     ds                      ; restore original vector
	call    Pwr_Services            ; one of our services
	iret                            ; no propagation

; If Win Enh mode starts  we don't need to recalc our baseline anymore
; just set a flag so that we avoid baseline calc oper at exec time
i2fWinEnhStart:
	test	dx,WIN286STDMODE	; is this a standard mode win ?
	jnz	i2fnxt			; yes, don't worry about it
; enhanced mode: set win3Flg	
	inc	[NoBaselineCalc]
	jmp	short Instance_Pwr	; M100
i2fWinEnhEnd:
	dec	[NoBaselineCalc]
	jmp	i2fnxt
;
; M100 - begin
;
Instance_Pwr:
	jmp	dword ptr Pwr_call_i2f		; M102
Calli2fRet:					; M102
	mov     ds,Bios_Data_Word               ;reinit DS to Bios_Data M102
	assume  ds:Bios_Data

	mov	word ptr Pwr_SINextDev+0, bx
	mov	word ptr Pwr_SINextDev+2, es
	mov	bx, offset Bios_Data:Pwr_InstData
	push	ds
	pop	es

	pop	ds
	iret

;
; M100 - end
;
I2f_idle endp

;************************ I28_IDLE *********************

PUBLIC I28_idle
I28_idle proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	inc     [I28].PCOUNT

	test    [CONTROL].IDLE_FLG,DOSYIELD_ACTIVE
	jz      i28ret

		; load up registers and call general delay checker
	push	cx
	push    bx
	push    si
	push    di
	lea     bx,I28_TMR0
	lea     si,I28
	lea     di,[INFO].DOS_TOT
	call    Chk_Delay
	pop     di
	pop     si
	pop     bx
	pop	cx

i28ret:

IFDEF   POWERALONE                      ; chain to next
	jmp     dword ptr pwr_i28_next
ELSE
	pop     ds
	assume  ds:nothing
	iret                            ; don't need to chain if BIOS resident
ENDIF

I28_idle endp

;********************* Shell idle check ******************************
; purpose: check idle 
;          if interrupt is detected than DO_IDLE should be called
;          the interrupt should be absorbed.
; CAVEAT: This interrupt should never be used, is version bound and subject
; to change in future versions.

PUBLIC I2A_idle
I2A_idle proc   far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds, Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,84h                  
	jne     i2Anxt            	; check for a service call to us

; load up registers and call do idle
	test    [CONTROL].IDLE_FLG,DOSIDLE_ACTIVE ; Make sure power is on
	jz	i2Anxt			; Power is off so just chain
	push    di
	lea     di,[INFO].SHELL_TOT
;;	call    DO_IDLE			; M102

	call	I2fIdleEntry		; M102

	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	pop	di
	pop	ds
	iret

i2Anxt: 
	jmp     dword ptr pwr_i2a_next

I2A_idle endp
;************************ I16_IDLE *********************
; Our Int16 handler
; PseudoCode:
;	if (reentering) jmp to prev.handler;
;	if (fn NOT keyboard_poll calls or
;		NOT blocked get key calls)
;		jmp to prev.handler
;	if (fn == keyboard poll call) {
;		call the prev. handler
;		if key_waiting, ret to caller.
;		call chk_delay for possible idles;
;		ret to caller.
;	}
;	if (fn == blocked get key call) {
;		while (no key_hit)
;			call do_idle	// directly trigger idles
;	}
;		

PUBLIC I16_IDLE
I16_IDLE proc far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data


	cmp     [IN_KYC],0		; reentering ?
	jne     kybxxx

; check for keyboard poll calls
	cmp     ah,01h
	je      kbpchk
	cmp     ah,11h
	je      kbpchk
;
; check for Blocked get_key calls
	or	ah,ah
	jz	kbChkIdle
	cmp	ah,10h
	jz	kbChkIdle
kybxxx: 
	jmp     dword ptr pwr_i16_next	; chain to prev handler

kybClrTmr:
        push    ax
        push    bx
        lea     bx,KYC_TMR0
        call    ClearTimer
        pop     bx
        pop     ax
        jmp     short kybxxx


kbpchk: inc     [KYC].PCOUNT
	test    [CONTROL].IDLE_FLG,KYC_ACTIVE
	jz      kybClrTmr

	mov     [IN_KYC],1              ; ONLY ALLOW ONE RE-ENTRY

	jmp     dword ptr pwr_call_i16  ;call old int 16h handler
;
;We return to the label below after calling the previous int 16h handler
;
calli16ret:
	mov     ds,Bios_Data_Word               ;reinit DS to Bios_Data
	assume  ds:Bios_Data

	pushf
	push    bx
	lea     bx,KYC_TMR0

		; if a key is ready, just clear out our timer and
		; return.  If no key is ready, go through the full
		; delay check.  Here we check the flags returned
		; by the INT 16 handler we called.
       
	jz      i16_ChkDelay

		; Just clear the timer
	push    ax
	call    ClearTimer
	pop     ax
	jmp     short kbpret

i16_ChkDelay:
		; load up registers and call delay check
	push	cx
	push    si
	push    di
	lea     si,KYC
	lea     di,[INFO].KEY_TOT
	mov	cx,1
	call    Chk_i16idle
	pop     di
	pop     si
	pop	cx

kbpret: 
	pop     bx
	popf

	mov     [IN_KYC],0              ; can start up again

	pop     ds
	assume  ds:nothing
	ret	2		

; Blocked get_key calls
; see if key is available ; if not, just do idle directly
;
kbChkIdle:
	assume  ds:Bios_Data
; see if there is a key available
	inc	ah			; make it to fn 1 or 11
kbChkKey:
	push	ax			; save function no (1 or 11h)
	jmp     dword ptr kb_call_i16  ;call old int 16h handler
kbChkRet:
	pop	ax			; get back orig. polling fn no
	jz	kbDoIdle		; no key available
	dec	ah			; get back original get key fn(0 or 10)
	jmp	kybxxx			; go get the key
; no key available do idle
kbDoIdle:
	push	ax
	push    bx
	push    di
	lea     bx,KYC_TMR0
	lea     di,[INFO].KEY_TOT
;	call    DO_IDLE
	call	I2fIdleEntry		; JAH4
	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	mov     word ptr [bx]+2,0       ; avoid speed up error
	call    ClearTimer
	pop	di
	pop	bx
	pop	ax
	jmp	short kbChkKey		; go look for key

I16_IDLE endp


;************************ I08_IdleControl *********************
; POWER's main Timing/CONTROL interrupt
; PseudoCode:
;	check for rollover flag
;	if (rollover)
;		set our local date_update flag
;		do an int 1a to eat the rollover flag // in case?
;	if (time_update_counter is 0)
;		set our local date_update_flag 	// if in POWER STD mode
;	if (SW idle detection enabled)
;	{
;		update Timer counters for i16,i28
;		update idle statistics counters
;		if (AUTO active && time_to_switch strategies)
;			check i16 , i28 counts for the last period
;			enable the int that has the max count and
;			  disable the other one.
;
;	}
;	if (FW idle detection enabled)		// APM enabled
;	{
;		if (time to poll APM) {
;			increment INDOS flag
;			switch stacks to our local stack
;			call Do_APM_POLL  // poll APM for a pm event
;					// if there is, broadcast it
;					// and take necessary action 
;			switch back to old stack
;			decrement INDOS flag
;		}
;	}
;	RET;
;	

PUBLIC I08_IdleControl
I08_IdleControl proc	far
	assume  ds:nothing, es:nothing

	push    ds
	push    ax
	mov     ax,BIOSDATASEG          ; M092 check rollover flag in BIOS
	mov     ds,ax                   ; M092
	xor     al,al                   ; M096
	xchg    al,ds:[ROLLOVERFLG]     ; M096 get Bios rollover flg and 
					;   reset it
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

;
; M107 - begin
;
	or	al, al
	jz	i08Skip1a
	or      [CMOSUpdFlg],al         ; M092 set update flag if rollover
	push	cx
	push	dx
	xor	ah, ah
	int	1ah
	pop	dx
	pop	cx
i08Skip1a:
;
; M107 - end
;
	dec     [CMOSPollCount]         ; M090
	jz      i08SetCMOSFlg           ; M090

i08NoTmUpdate:
	inc     [SPDUP_CNT]             ; speedup delay

	test    [POWER_STATUS],SW_IDLE_ACTIVE        ; is idle detection on ?
	jz      i08_to_end

	inc     [KYC_TMR0]+2            ; timer over flow
	inc     [KYC].DELAY             ; adjust delay

	inc     [I28_TMR0]+2            ; timer over flow
	inc     [I28].DELAY             ; adjust delay


	add     word ptr [INFO].CPU_ON_TIME,1
	adc     word ptr [INFO].CPU_ON_TIME+2,0

	xor     ax,ax                   ; M004  BEGIN
	xchg    [IDLTIC],ax             ; If we were idle during the last
	add     word ptr [INFO].CPU_IDLE_TIME,ax        ; tick period, let's
	adc     word ptr [INFO].CPU_IDLE_TIME+2,0       ; count it
					; M004 END

	test    [CONTROL].IDLE_FLG,AUTO_ACTIVE  ; no AUTO adjust
i08_to_end:
	jz      i08xxx

i08ot1: inc     [SWITCH_CNT]            ; time to switch methods?
	mov     ax,[CONTROL].SWITCH_DLY
	cmp     [SWITCH_CNT],ax
	jb      i08xxx                  ; not yet ...

i08ot2: mov     [SWITCH_CNT],0
	mov     ax,[I28].PCOUNT         ; If( KYC.COUNT < I28.COUNT)
	cmp     ax,[KYC].PCOUNT         ; occurs in windows ...
	ja      i08dos

		; keyboard count is higher than INT 28 count
		; keyboard is highest count, it wins

	cmp     [KYC].PCOUNT,0          ; avoid thrashing
	je      i08xxx
	mov     ax,KYC_ACTIVE
	jmp     short i08set

i08SetCMOSFlg:
	mov     al,[CMOSFlg]            ; M090 ; need to update from CMOS
	or	[CMOSUpdFlg],al         ; M090 ; only if POWER STD mode in APM 
	mov	ax,MAXCMOSPOLLCOUNT	; machines
	mov	[CMOSPollCount],ax	; start counting again
	jmp     i08NoTmUpdate

i08dos:         ; INT 28 count higher than keyboard count
		; INT 28 count is highest, it wins
	or      ax,ax                   ; don't bother if count is 0
	jz      i08xxx
	mov     ax,DOSYIELD_ACTIVE

i08set: and     [CONTROL].IDLE_FLG,NOT ( DOSYIELD_ACTIVE+KYC_ACTIVE)
	or      [CONTROL].IDLE_FLG,ax

i08skp: xor     ax,ax                   ;reset for next round
	mov     [KYC].PCOUNT,ax
	mov     [I28].PCOUNT,ax

i08xxx: 
	test    [POWER_STATUS],FW_IDLE_ACTIVE        ; M089 is F/W mgmt on ?
	jz      i08ret                ; M089 No need to poll APM in POWER
					; STD mode
IFDEF INCL_APM
; now check to see if we need to call APM for a PMEVENT 
	cmp     fAPM_STATE,0            ; is APM enabled ?
	je      i08ret
	dec     APM_POLL_COUNT
	jnz     i08ret
;
; NSM5 - BEGIN
	mov     ax,[APM_MAX_POLLCOUNT]  ; first reset the counter
	mov     APM_POLL_COUNT,ax

; time to poll APM for a PM Event
; First check to see if we are reentering our code
; if so, just quit; 
; else, change stacks and poll APM
;
	cli
	cmp	StackInUse,0		; See if called recursively
	jne	i08ret
;
; change stacks
;
	inc	StackInUse		; Show stack is being used
	mov	Old_SS,SS		; Save old SS:SP in bios data area
	mov	Old_SP,SP

	mov	SS,Bios_Data_Word
	mov	SP,OFFSET StackTop
;
; NSM4 - set indos flag so that we won't be swapped while doing our
; baseline calculation
	push	ds
	push	si			; NSM4
	mov	si,[INDOS_Offset]
	mov	ds,[INDOS_Seg]
	assume ds:nothing
	inc	byte ptr ds:[si]
	pop	si
	pop	ds
	assume	ds:Bios_Data
; NSM4 -END
	sti
;
	call	DoAPMPoll		; poll APM for an event,broadcast it etc
;
	cli			
; NSM4 - reset indos flag ; we are safe now and can be swapped out
	push	ds
	push	si
	mov	si,[INDOS_Offset]
	mov	ds,[INDOS_Seg]
	assume ds:nothing
	dec	byte ptr ds:[si]
	pop	si
	pop	ds
	assume	ds:Bios_Data
; NSM4 -END
; restore stack
	mov	SS,Old_SS	; Get entry stack from bios data area
	mov	SP,Old_SP
	mov	StackInUse,0	; Clear value to show not being used.

; NSM5 -END
;
ENDIF					; ifdef INCL_APM
i08ret:
	pop     ax
	pop	ds
	ret

I08_IdleControl endp

; ******************************** DoAPMPoll ***********************
; Poll APM for a PM event
; If there is an event broadcast it
; if the event == request for suspend/stand-by
;	look for rejection by an app
;	if no rejection, call APM back to switch to req. mode.
; if event == resume
;	Update system date and time from CMOS
;
IFDEF INCL_APM

DoAPMPoll	proc	near

; time to poll APM for any PM Event

	push    bx
;
DAPPoll:
	mov     ax,APM_GETPMEVENT_FUNC
	int     15h
	jc      DAP_End                 ; no events -> no work to do 
;
; BX = PM Event
;       1 = stand-by request
;       2 = suspend request
;       3 = normal resume
;       4 = crit. resume
;       5 = battery low
	cmp     bx,APM_NORM_RESUME
	je      DAP_Set_time
	cmp     bx,APM_CRIT_RESUME
	jne     DAP_broadcast

DAP_Set_time:
	INC     APM_RESUME_COUNT
	call    Do_APM_CPUBUSY          ; M002 bring CPU to full speed
	mov     [CMOSUpdFlg],1          ; M090

DAP_broadcast:
	mov     ax,I2F_APM_BROADCAST
	int     2fh                     ; broadcast the pm events to other
					; apps
; BUGBUG: Warning: the function codes for APM BIOS GetPMEvent and 
; the multiplex API broadcast functions are assumed to be the same
	cmp     bl,APM_NORM_RESUME      ; was it a stand-by/suspend request
	jae     DAP_End                 ; if not, nothing else to do
;
; this was an APM request for system stand-by/suspend
; if no apps/tsrs objected to this request, let us call the APM to suspend/
; stand-by
	or      bh,bh
	jnz     DAP_End                 ; somebody objected ? if so quit
	push    cx                      ; M093
	mov     cx,bx                   ; required power mode in CX
	mov     bx,APM_SYSTEM_DEV       ; full system
	mov     ax,APM_SETPWSTATE_FUNC
	int     15h
	pop     cx                      ; M093
IFDEF DEBUG
	jnc     DAP_dbg_Success
	dbg_printchar   'f'             ; CY for a set power state call
DAP_dbg_Success:
ENDIF                                   ; IFDEF DEBUG
; Resumed from a suspend/stand-by; we should get a resume notification
; from APM so that we can go and update the date and time 
	jmp     DAPPoll                 ; go back and poll APM for
					; a resume notification event
;
DAP_End:pop     bx
	ret

DoAPMPoll	endp
ENDIF

;************* I6C_RESUME *****************************
;
; On interrupts 6C, update system date and time from the hardware
; clock.  Int 6C is one way a system may signal a resume event.
; Entire routine is part of modification M080.

I6C_Resume      proc

	assume  ds:nothing,es:nothing

	push    ds
	mov     ds,cs:Bios_Data_Word
	assume ds:Bios_Data

;       Bugbug -- need to sti?
;       Bugbug -- enough stack space?

	push    ax
	push    bx
	push    cx
	push    dx
	push    si
	push    di

IFDEF   POWERALONE                      ; M081
	call    far ptr P_UpdFromCMOS
ELSE
	call    P_UpdFromCMOS_ptr       ; M074 update our date and time
					; from CMOS RTC
ENDIF

	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	pop     ax

	jmp     dword ptr pwr_i6c_next

I6C_Resume      endp

;************* APPLICATION ACTIVITY MONITORS ***********
; ISRs for the application activity monitor interrupts that we hook and
; related procedures
;
;************************** APP_SPDUP *******************************
; called by all our activity monitoring interrupt handlers
; SPEED UP by setting DOIdle delay count relitive to TIMER interrupts
; that have occurred between polling interrupt ...
; ** REQUIRES TESTING -- At this point APP_SPDUP tends to inhibit idle

PUBLIC APP_SPDUP
App_Spdup proc near
	assume  ds:Bios_Data, es:nothing

	push    ax
	mov     ax,[SPDUP_DLY]          ; machine speed dependent
	add     ax,[CONTROL].SPDUP_RAMP
	cmp     ax,[CONTROL].SPDUP_MAX  ; machine speed dependent
	jb      asdot3
	mov     ax,[CONTROL].SPDUP_MAX
asdot3: mov     [SPDUP],1               ; indicate activity
	mov     [SPDUP_DLY],ax
	mov     [SPDUP_CNT],0
	pop     ax
asdex0: ret

App_Spdup endp

;
; Hardware Keyboard interrupt - called for each key press twice
;
I9_App  proc    
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	dec     [I9_COUNT]
	jnz     i9ex0
	mov     [I9_COUNT],2
	call    APP_SPDUP
i9ex0:  
	jmp     dword ptr Pwr_i9_next

I9_App  endp

; BIOS screen I/O interrupt
I10_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,04h                          ; avoid cursor set
	jb      i10ex0                          ; calls
	call    APP_SPDUP
i10ex0: 
	jmp     dword ptr Pwr_i10_next

I10_App         endp

;
; DISK I/O BIOS interrupt
;
I13_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i13_next

I13_App         endp

;
; Communication I/O BIOS interrupt
;
I14_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,3                            ; avoid status calls
	je      i14ex0
	call    APP_SPDUP                       ; M002
i14ex0: 
	jmp     dword ptr Pwr_i14_next

I14_App         endp

; Printer I/O BIOS interrupt
;
I17_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,2                            ; avoid status calls
	je      i17ex0
	call    APP_SPDUP
i17ex0: 
	jmp     dword ptr Pwr_i17_next

I17_App         endp

;
; DOS system calls 
;
I21_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	push	ax

; upper bound check
	cmp	ah,MAX_I21_ENTRY	; anything above speeds up
	ja	i21SpdUp

; get action from the lookup table 
	push	bx
	mov	bx,offset i21_table		; look up table for APIs
	xchg	ah,al			; get function code  in al
	xlat
	pop	bx
	or	al,al			; a busy call ?
	jz	i21SpdUp
	inc	al			; idle calls ?
	jz	i21ex0

; special cases
	cmp	ax,644h			; ioctl get input status call ?
	je	i21ex0

	cmp	al,4bh			; is it an exec call ?
	je	i21GetNewBL		; go get a new base line for int 16s

	cmp	ax,505fh		; is it network assign call ?
	je	i21ex0			; ignore it

; only one special case remains now - the direct console io (fn 6) now
; if dl = ff it is an input call and otherwise output call

	cmp	dl,0ffh			; Direct console input ?
	je	i21ex0

; fall through for other special cases - should be changed if we add
; other special cases
i21SpdUp:
	call    APP_SPDUP
i21ex0: 
	pop	ax
	jmp     dword ptr Pwr_i21_next
	
i21GetNewBL:
; Reset I2f Apps's PSP so that the child is not marked as an INT 2f aware App
	mov	PSPOf2fApp, 0		; M099
;
; IF we are within Win ENH mode, no need to adjust BaseLine again
;
	cmp	[NoBaseLineCalc],0	; NSM2 do we need to recalc baselinemax?
	jne	i21SpdUp		; NSM2 no, just do SpeedUp
;
	call	GetNewBaseLine
	jmp	short i21SpdUp
	
I21_App         endp

; ABSOLUTE DISK READ/WRITE interrupts
;
I25_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i25_next

I25_App         endp

I26_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i26_next

I26_App         endp

; ****************************** GetNewBaseLine ***************************
; Called at each exec time  (except within win enh mode)
; calculates BaseLineRef for Int 16 idles by:
;	pumping 9 int16s in a tight loop
;	throwing the first and last 2 int16 intervals
;	throwing the highest and lowest 2 int16 intervals
;	and adding up the remaining five int16 intervals
;	using this added value as the New BaseLineRef.
; 
; NOTE: stack is switched to our local stack and INDOS flag is set during
;	this operation so that task swapper may not swap us out and to
;	avoid stack overruns in case of certain apps.
;
	PUBLIC GetNewBaseLine		; JAH2 - made public for debugging
GetNewBaseLine	proc	near

		; JAH2 - Setup new stack to fix problems with small exec stack


	pushf
	push	si			; NSM4
	cli
	cmp	StackInUse,0		; See if called recursively
	je	SetupStack
	jmp	NewBaseLineExit		; Stack is being used so don't recalc
SetupStack:
	inc	StackInUse		; Show stack is being used
	mov	Old_SS,SS		; Save old SS:SP in bios data area
	mov	Old_SP,SP

	mov	SS,Bios_Data_Word
	mov	SP,OFFSET StackTop
; NSM4 - set indos flag so that we won't be swapped while doing our
; baseline calculation
	push	ds
	mov	si,[INDOS_Offset]
	mov	ds,[INDOS_Seg]
	assume ds:nothing
	inc	byte ptr ds:[si]
	pop	ds
	assume	ds:Bios_Data
; NSM4 -END
	sti
		; JAH2 - End change
; SMR7 BEGIN - BaseLine calculation based on a few samples
;
; Save all regs we use
;
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di

	mov	si, offset BL_Samples
	push	si
	xor	di, di				; Cumulative sum=0
;
; Pump in INT 16s and till we get 9 samples
;  & accumulate the total period for 9 samples in DI
;

	mov	ah, 1
	int	16h
	mov	bx, [KYC_TMR0]			; Our INT 16 handler would
						;  have read TMR0
bl_loop1:
	mov	ah, 1
	int	16h
	sub	bx, [KYC_TMR0]			; Get period for this sample
	jc	bl_ThrowSample			; ignore it in case of overflow
	mov	[si], bx			; else stow it away
	add	di, bx				;  and it to the total
	inc	si				; bump to next sample
	inc	si
bl_ThrowSample:
	mov	bx, [KYC_TMR0]			; remember current time stamp
	cmp	si, offset BL_EndSamples	; have we got 9 samples ?
	jb	bl_loop1			; no, try again
;
;
; Throw off the 2 highest & lowest samples and sum up the rest 5
;
; always ax,bx contain the highest 2 values so far (such that ax < bx)
;  & cx,dx contain the lowest 2 values so far (such that cx > dx)
; si contains the ptr to the current element
;	   	
;
	pop	si

	xor	ax, ax				; 2 MAXs = 0
	mov	bx, ax
	mov	cx, ax
	dec	cx
	mov	dx, cx				; 2 MINs = ffffh
	push	di				; save the total
bl_loop2:
	mov	di, [si]			; get sample

	cmp	ax, di				; > lo Max ?
	jae	bl_1				; no, chk against hi max
	mov	ax, di				; yes, update least max
	jmp	short bl_2
bl_1:
	cmp	bx, di				; > hi max ?
	jae	bl_2				; no
	mov	bx, di				; update hi max
bl_2:
	cmp	ax, bx				; is hi max < lo max
	jb	bl_MaxOk			; no
	xchg	ax, bx				; make hi max > lo max

bl_MaxOk:
	cmp	cx, di
	jbe	bl_3
	mov	cx, di
	jmp	short bl_4
bl_3:
	cmp	dx, di
	jbe	bl_4
	mov	dx, di
bl_4:
	cmp	cx, dx
	ja	bl_MinOk
	xchg	cx, dx
bl_MinOk:
	inc	si
	inc	si
	cmp	si, offset BL_EndSamples
	jb	bl_loop2
;
	pop	di
	sub	di, ax
	sub	di, bx
	sub	di, cx
	sub	di, dx

	mov	[BaseLineOvf], di	; this is the new calculated 
					; BaseLine ref value for REG mode

; NSM9 - set baelineref depending on the current savings mode value
	call	SetSavingsValues	; set the correct BaseLineRef depending
					; on the current Savings mode
; NSM9 END

	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
;
; SMR7 END
;
		; JAH2 - Restore stack and AX pushed at entry to function
	cli			; Popf at end will reset interrupt enable
; NSM4 - reset indos flag ; we are safe now and can be swapped out
	push	ds
	mov	si,[INDOS_Offset]
	mov	ds,[INDOS_Seg]
	assume ds:nothing
	dec	byte ptr ds:[si]
	pop	ds
	assume	ds:Bios_Data
; NSM4 -END
	mov	SS,Old_SS	; Get entry stack from bios data area
	mov	SP,Old_SP
	mov	StackInUse,0	; Clear value to show not being used.
NewBaseLineExit:
	pop	si		; NSM4
	popf
		; JAH2 - End

	ret

GetNewBaseLine	endp

; NSM9 - BEGIN - 8 levels of savings values/noise spreads
; *******************************************************************
; SetSavingsValues
; Entry:	none	(BaseLineOvf and Savings_mode set)
; Exit:		Current BaseLineRef set
;		Current Noise set
;		Current AvgSpread Set
;
; Regs affected: AX
;
; Uses the shift-right count in BaseLine_Table to shift out the current
; calculated baselineref to arrive at the BaseLineRef for the currently
; selected Savings level.
; also sets NOISE/SPREAD values 
;
;	called by GetNewBaseLine at each EXEC time to set proper values
;		for BaseLineRef, NOISE, SPREAD etc for I16.
; 
SetSavingsValues	proc	near
	push	cx
	push	bx
	xor	cx,cx
	lea	bx,BaseLine_Table	
	mov	ax,[Savings_Mode]	
	cmp	ax,REGSAVINGSMODE	; is it REG ?
	xlat
	mov	cl,al
	mov	ax,[BaseLineOvf]
	mov	bx,[BaseLineOvf]
	jae	SSV_AddLoop
	xor	bx,bx			; start with 0% for all other modes
					; below REG
SSV_AddLoop:	
	jcxz	SSV_SetBLRef
	shr	cl,1			;	
	jnc	SSV_HalveBL
	add	bx,ax
SSV_HalveBL:
	shr	ax,1
	Jmp	SSV_AddLoop
; BX = has the new BaseLineRef
SSV_SetBLRef:
	mov	[BaseLineRef],bx	; set new baseline Ref
	push	si
	lea	si,KYC
	call	CalcNewNoise
	mov	[si].NOISE,ax
	call	CalcNewSpread
	mov	[si].PSPREAD,ax
	pop	si
	pop	cx
	pop	bx
	ret

SetSavingsValues	endp

; *************************** CalcNewNoise/Spread ********************
;
; Entry:	[Savings_Mode]	set
;		si = Period structure for i16 or i28
; Exit:		ax = New Noise (or Spread Value) depending on the current 
;		savings_mode
;
; Regs affected: AX
; 
; EntryPoint:	CalcNewSpread
;
; Uses the shift-right count in  Savings_Table to shift out current BASE/AVG
; to arrive at the correct NOISE/SPREAD for the currently selected savings
; value.

CalcNewNoise	proc	near
	mov	ax,[si].BASE
	jmp	short	CNN_CalcPC

CalcNewSpread	label	near
	mov	ax,[si].PERIOD		; take current avg
; ax = current Base /AVG 
CNN_CalcPC:
	push	bx
	push	cx
	mov	cx,ax
	mov	ax,[Savings_Mode]
	dec	al			; 0 based table
	lea	bx,Savings_Table
	xlat
	xchg	ax,cx		; cl = mode bits and ax = BASE/AVG
	xor	bx,bx
CNN_AddLoop:
	or	cl,cl
	jz	CNN_RetValue
	shr	ax,1
	shr	cl,1
	jnc	CNN_AddLoop
	add	bx,ax
	jmp	CNN_AddLoop
CNN_RetValue:
	or	bx,bx
	jz	CNN_Ret
	mov	ax,bx		; ax = new value for NOISE/SPREAD
CNN_Ret: 
	pop	cx
	pop	bx
	ret	

CalcNewNoise	endp

; NSM9 END

IFDEF INCL_APM

; *********************************** Check_and_Init_APM ***************
; This procedure is called at init time ; checks for the presence of
; APM BIOS , if present connects to it (real mode only).
; If the connection is successful, we set APM_PRESENT flag so that
; later we can make use of APM 
;
; Input: none
; output: CY +NZ if NO APM
;         CY +ZR if cannot connect to it
;               or if APM cannot be enabled
;         NC = success (APM found+connected to APM+APM enabled state)
;       (fAPM_Present set to TRUE if APM present)
;       (APM_RESUME_COUNT initialised to 0)
;       (fAPM_CONNECT set to TRUE if connected to APM)
;       (fAPM_STATE set to TRUE if APM connected+enabled)
;               -> this is referred to before polling APM, before calling APM
;                       for idle
;
; regs affected: AX,BX,CX,DX,flags
;
; M001  : Created; APM support code

	public  Check_and_Init_APM

Check_and_Init_APM      proc    far
	
	mov     ax,APM_INSTALLCHK_FUNC
	mov     bx,APM_SYSTEM_BIOS      
	int     15h                     ; Check for APM BIOS presence

; CY set if no APM present
	jc      CAIA_NoAPM

; NC; check for APM signature (BH = "P" and BL = "M")   ; M003
; AX = version no (in BCD)
; CX = APM flags        (bit 0 - 16bit prot.mode intrfc. supported
;                        bit 1 - 32bit "  "      "  "      "  "
;                        bit 2 - set if CPU_IDLE call slows proc.clock
;                        bit 3 - set if BIOS power management disabled.

	cmp     bx,APM_SIGNATURE        ; M003
	jne     CAIA_NoAPM              
	mov     APM_FLAGS,cx            ; store the APM flags
	mov     APM_VER,ax              ; store APM BIOS ver no

	mov     fAPM_PRESENT,1          ; set APM flag  ; M002

; connect to APM
	call    Do_APM_Connect          ;M005
	jc      CAIA_APM_Err            ; cannot connect ? assume APM
					; not present/functional
;
; check for APM BIOS disabled state
	test    APM_FLAGS,APM_PWMGMT_DISABLED
	jz      CAIA_APM_Success                ; APM in enabled state; all success
;
	mov     cx,APM_ENABLE_FUNC
	call    Do_APM_Enable_Disable   ;M005
	jnc     CAIA_APM_Success
	mov     fAPM_PRESENT,0          ; reset APM flag since we couldn't
						; connect to it
	mov     fAPM_STATE,0            ; disabled state        
	mov     APM_RESUME_COUNT,0      ; initialise RESUME_COUNT
	jmp     short CAIA_APM_Err

CAIA_APM_Success:
	mov     fAPM_STATE,1            ; APM in enabled state
	mov     APM_RESUME_COUNT,0      ; initialise RESUME_COUNT
	or      POWER_STATUS,FW_IDLE_ACTIVE     ; M003: indicate APM is enabled
CAIA_End:
	ret

CAIA_NoAPM:
	mov     al,1                    ; APM not there; CY + NZ
CAIA_FEnd:
	or      al,al                   ; set Zero flag if APM error
	stc
	jmp     short CAIA_End
CAIA_APM_Err:
	xor     al,al                   ; APM is there but connect or some
	jmp     short CAIA_FEnd         ; other error => CY + Z

Check_and_Init_APM      endp

ENDIF   ; for INCL_APM conditional
; M001 END


Bios_Code       ends



;********************** INITIALIZE CODE ******************

Sysinitseg      segment
	assume  cs:Sysinitseg, ds:nothing, es:nothing

; AX.ReturnStatus = DEV_INIT( ES:BX.DRIVER_INIT_REQUEST)

	public  Power_Init
IFDEF   POWERALONE
Power_Init proc far
ELSE
Power_init proc near
ENDIF

	assume  ds:nothing, es:nothing
	pushf	
	sti
	push    si
	push    ds
	push    dx
	push    ax

	mov     ax, Bios_Data
	mov     ds,ax
	assume  ds:Bios_Data

; JAH Start - Get address of DOS data area
	push	bx
	push	es
	mov	ah,52h			; Get the DOS data segment
	int	21h
	mov	WORD PTR PSPsegment,es
	pop	es
	pop	bx
; JAH End

IFDEF   POWERALONE
	; Return DEVICE DRIVER end address
	mov     word ptr es:[bx].RH_D_BREAKPTR+0,offset Bios_Data:End_Data
	mov     word ptr es:[bx].RH_D_BREAKPTR+2,ds

	; Return DO_IDLE address to DOS
	mov     ax,Bios_Res                     ; get resident code segment
	mov     word ptr es:[bx].RH_D_IDLEPTR+0,offset Bios_Code:DO_IDLE_DOS
	mov     word ptr es:[bx].RH_D_IDLEPTR+2,ax

; M092 BEGIN
; see if POWER is already loaded ; If so, disable the previous POWER
; and load ourselves.
	
	xor     bx,bx
	mov     ax,(MultPWR_API*256)+00h; POWER detect mult.call 
	int     2fh
	cmp     ax,(MultPWR_API*256)+00h; MultAPI code unchanged ? 
	jz      pi_NoPrevPower
	cmp     bx,504dh                ; M087 signature correct ?
	jne     pi_NoPrevPower

; There is a previously loaded POWER; disable it.
	mov     bx,100h                 ; disable all Power management
	mov     ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE
	int     2fh                     ; we don't expect any error here
;M092 END

ENDIF

; Continue init.
pi_NoPrevPower:
	mov     dx,Bios_Res             ;code segment of the BIOS
	mov     Pwr_calli16_ret+2,dx            ;init CS for this pointer
	mov     Pwr_calli2f_ret+2,dx            ;init CS for this pointer
	mov     kb_calli16_ret+2,dx            ;init CS for this pointer
	mov	I08_IdleControl_ptr+2,dx

	mov     si,offset I28_VEC               ; chain 28h
	mov     ax,28h                          ; DOS IDLE interrupt
	call    XVECT

	mov     si,offset I2F_VEC               ; chain 2Fh
	mov     ax,2Fh                          ; APP IDLE interrupt
	call    XVECT

	mov     si,offset I2A_VEC               ; chain 2Fh
	mov     ax,2Ah                          ; APP IDLE interrupt
	call    XVECT

	mov     si,offset I16_VEC               ; chain 16h
	mov     ax,16h                          ; keyboard intrrupt
	call    XVECT

	mov     si,offset I9_VEC                ; chain 8h
	mov     ax,9h                           ; PC TIMER interrupt
	call    XVECT

	mov     si,offset I10_VEC               ; chain 10h
	mov     ax,10h                          ; application activity
	call    XVECT

	mov     si,offset I13_VEC               ; chain 13h
	mov     ax,13h                          ; application activity
	call    XVECT

	mov     si,offset I14_VEC               ; chain 14h
	mov     ax,14h                          ; application activity
	call    XVECT

	mov     si,offset I17_VEC               ; chain 17h
	mov     ax,17h                          ; application activity
	call    XVECT

	mov     si,offset I21_VEC               ; chain 21h
	mov     ax,21h                          ; application activity
	call    XVECT

	mov     si,offset I25_VEC               ; chain 25h
	mov     ax,25h                          ; application activity
	call    XVECT

	mov     si,offset I26_VEC               ; chain 26h
	mov     ax,26h                          ; application activity
	call    XVECT

	mov     si,offset I6C_VEC               ; chain 6Ch             ;M080
	mov     ax,6Ch                          ; resume event          ;M080
	call    XVECT                                                   ;M080

; NSM4 - BEGIN get address of INDOS flag and store it for future use
	push	es
	mov	ah,34h				; get address of indos flag
	int	21h				; es:bx = address of INDOS
	mov	[INDOS_Offset],bx
	mov	[INDOS_Seg],es			; store them away for later use
	pop	es
; NSM4 - END

	mov     dx,ds				; I08 vec is in our data seg
	mov     si,offset I08_VEC               ; chain Int 08
	mov     ax,08h                          ; 
	call    XVECT

IFNDEF	POWERALONE
	push    ds      
	mov     ax,cs                           ; DS=CS for the message
	mov     ds,ax
	assume  ds:nothing
	mov     dx,offset INIT_MSG
	mov     ah,9                            ; report init complete
	int     21h
	pop     ds                              ; ds = bios_data
ENDIF ; NOT POWERALONE

	assume  ds:Bios_Data

;M001 BEGIN
;
IFDEF  INCL_APM

; Check and initialize APM.

;M005 BEGIN

IFDEF   POWERALONE
	call    Check_and_Init_APM
	call	InitCmdLineParms		; M104
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF   ;NOT POWERALONE

;M005 END

ENDIF           ; INCL_APM

; M001 END

	pop     ax
	pop     dx
	pop     ds
	assume  ds:nothing
	pop     si

	popf
	clc
	ret

Power_Init      endp

;INIT_MSG db "MS-DOS Power Monitor Extension Version 1.00",10,13
;         db "    Copyright (C) 1990-1991 Microsoft Corp.",10,13,"$"

INIT_MSG:
include msbio.cl9

; void XVECT( ds:[si].vecp, ax.vec#,dx.Bios_Code_Seg)
; purpose: xchange a vector with vector pointed to by ds:si

Xvect   proc    near
	assume  ds:Bios_Data, es:nothing

	push    es
	push    di

	mov     di,ax
	shl     di,1
	shl     di,1

	xor     ax,ax
	mov     es,ax

	pushf
	cli                             ; disable interrupts
	mov     ax,[si]
	xchg    es:[di],ax
	mov     [si],ax
	mov     ax,dx                   ;dx contains Bios_Code seg
	xchg    es:[di]+2,ax
	mov     [si]+2,ax
	popf

	pop     di
	pop     es
	ret

Xvect   endp

;M074   BEGIN

	public  Clock_Init

Clock_init      proc far

IFDEF   POWERALONE                      ; M081
	call    far ptr P_UpdFromCMOS
ELSE
	call    P_UpdFromCMOS_ptr       ; M074 update our date and time
					; from CMOS RTC
ENDIF

;       Ints 1c and 6c are hooked during main power management init, above.
	
	clc
	ret

Clock_Init      endp

;M074   END

 
;
; M098 - begin
;
IFDEF	POWERALONE

;
;------------------------------------------------------------------------------
;
; UMBInit : Try moving ourself into UMB by Allocating memory in UMB and
;		Loading ourselves into it using 4b03 call (We are in EXE
;		format)
;
;	Input : ES:BX is the pointer to the original Request packet
;		passed in by DOS
;
;	Output:	Carry Clear if a copy of POWER was succesfully initialized
;		in an UMB
;		Carry set if POWER was not initialized in an UMB
;		AX=segment of the UMB copy (if carry clear)		
;
;------------------------------------------------------------------------------
;
UMBInit	proc	far

	assume	ds:bios_data

	call	AreWeInUMB			; Are we already in a UMB ?
	jc	StayLow				; if so stay where we are
	call	GetProgName			; extract the device driver name
						;  with full path
	call	TryGettingIntoUMB		; and try loading the program
						;  into an UMB
	jc	StayLow				; try staying low if we failed
	call	SetupDDStub			; Initialize the device driver
						;  loaded in the UMB
StayLow:
	ret

UMBInit	endp

;
;------------------------------------------------------------------------------
;
; AreWeImUMB : Check whether we are already in a UMB
;		Check if we are devicehighed into an UMB
;		This will also help the second copy of POWER which will
;		be EXECed in the UMB not to re-exec itself again
;		
;	Input :	None
;	Output:	Carry clear if we are not in UMB
;		Carry set if we are already in a UMB
;
;------------------------------------------------------------------------------
;
AreWeInUMB	proc	near

	assume	ds:bios_data

	push	es
	push	bx

	mov	ah, GET_IN_VARS			; get DOS data
	int	21h
	mov	ax, cs

	mov	bx, word ptr es:[UMB_ARENA]	; get first UMB arena
						; Note : UMB_ARENA is initial-
						;	 zed to ffff if no UMBs
						;	 are available
	cmp	bx, ax				; Sets/clears carry flag

	pop	bx
	pop	es
	ret

AreWeInUMB	endp

ProgName	db	129 dup (0)		; Storage for devicer driver
						;  name.
;
;------------------------------------------------------------------------------
;
; GetProgName : Extracts the device driver file name (with full path) from
;		device driver command line
;
;	Input : ES:BX = pointer to the request packet
;	Output:	The device driver name is copied into ProgName
;
;------------------------------------------------------------------------------
;
GetProgName	proc	near

	assume	ds:bios_data

	push	ds
	push	es
	push	si
	push	di
	lds	si, es:[bx].RH_D_IDLEPTR	; command line
	cld
gpn_loop1:					; skip all leading spaces/delims
	lodsb
	call	IsDelim
	jz	gpn_loop1

	dec	si				; get back to the 1st char
	mov	di, offset ProgName		; destination of copy
	push	cs
	pop	es
gpn_loop2:					; copy till the first space/delim
	lodsb
	call	IsDelim
	jz	gpn_copied
	stosb
	jmp	gpn_loop2
gpn_copied:
	pop	di
	pop	si
	pop	es
	pop	ds
	ret

GetProgName	endp

;
;------------------------------------------------------------------------------
;
; IsDelim : Check whether a character is a delimiter or not
;
;	Input : AL = character to be checked
;	Output:	Zero flag set if the character is a delimiter
;		Zero flag clear if the character is not a delimiter
;
;	Note : Takes the same Delimiter character set as SYSINIT
;
;------------------------------------------------------------------------------
;
IsDelim		proc	near

	cmp	al, ' '
	jz	id9
	cmp	al, 0dh				; CR ?
	jz	id9
	cmp	al, 0ah				; LF ?
id9:
	ret

IsDelim		endp

;
; Packet for Load Overlay
;
LoadArea	dw	?			; UMB where POWER is going to be
RelocFactor	dw	?


CallthruPtr	dw	?			; Temporary space to call the
		dw	?			;  new copy of POWER


;
;------------------------------------------------------------------------------
;
; TryGettingImtoUMB : Try to allocate UMB and load ourself into UMB using
;			4b03 call
;
;	Input :	ProgName contains the file name with full path
;	Output:	Carry clear if the prog was loaded succesfully into UMB
;		Carry set if the operation failed
;
;------------------------------------------------------------------------------
;

TryGettingIntoUMB	proc	near

	assume	ds:bios_data

	push	es
	push	ds
	push	bx
	push	dx

	push	cs
	pop	ds

	push	cs
	pop	es

	assume	ds:sysinitseg

;
; Open the file
;
	mov	dx, offset ProgName
	mov	ah, OPEN
	int	21h
	jc	tgiu9
;
; Seek to end of file to get the size of file
;
	mov	bx, ax
	mov	ax, (LSEEK shl 8)+2		; lseek from end of file
	xor	cx, cx
	mov	dx, cx
	int	21h
;
; Close the file
;
	pushf
	push	dx
	push	ax
	mov	ah, close
	int	21h
	pop	ax
	pop	dx
	popf
	jc	tgiu9				; fail if seek failed

	or	dx, dx				; > 64K ?
	jnz	tgiu9f				; we cannot be > 64K
						; lets abort this process
	mov	cl, 4
	add	ax, 15
	shr	ax, cl
	inc	ax				; One for the Device sub-arena
						; M105
;
; Allocate UMB space : We know that during SYSINIT the only memory available
;			thru INT 21 ah=48 is in the UMb space
;
	mov	bx, ax
	mov	ah, ALLOC
	int	21h
	jc	tgiu9
;
; Update all segment values
;
	inc	ax				; skip past Device sub-arena
						; M105
	mov	LoadArea, ax
	mov	RelocFactor, ax
	mov	CallThruPtr+2, ax
;
; Exec the program
;
	mov	dx, offset ProgName
	mov	bx, offset LoadArea
	mov	ax, (EXEC SHL 8) + 03		; Load overlay
	int	21h
	jc	RelMemory			; if EXEC failed remember to
						; release the memory we alloced
;
; M105 - begin
;
	mov	ax, LoadArea
	push	ds
	assume	ds:nothing
	dec	ax
	mov	ds, ax
	mov	byte ptr ds:[devmark_id], devmark_device
IFNDEF	DEBUG
	mov	word ptr ds:[devmark_filename+0], 'OP'
	mov	word ptr ds:[devmark_filename+2], 'EW'
	mov	word ptr ds:[devmark_filename+4], 'R'
	mov	word ptr ds:[devmark_filename+6], 0
ELSE
	mov	word ptr ds:[devmark_filename+0], 'PD'
	mov	word ptr ds:[devmark_filename+2], 'WO'
	mov	word ptr ds:[devmark_filename+4], 'RE'
	mov	word ptr ds:[devmark_filename+6], 0
ENDIF	
	dec	ax
	mov	ds, ax
	mov	word ptr ds:[arena_name+0], 'DS'
	mov	byte ptr ds:[arena_name+2], 0
	inc	ax
	inc	ax
	mov	word ptr ds:[devmark_seg+10h], ax
	pop	ds
	clc
;
; M105 - end
;
tgiu9:
	pop	dx
	pop	bx
	pop	ds
	pop	es
	ret
RelMemory:
	mov	ax, LoadArea			; M105
	dec	ax				; We have a arena subheader M105
						; above us		    M105
	mov	es, ax				; M105
	mov	ah, 49h
	int	21h
tgiu9f:
	stc
	jmp	short tgiu9

TryGettingIntoUMB	endp

;
;------------------------------------------------------------------------------
;
; SetupDDStub : Initialize the driver loaded in UMB and resize the UMB to
;		whatever is needed. For initializing we call the copy of
;		the device driver in UMB thru its Strategy & Interrupt
;		entry points with the same init request packet which we
;		received from sysinit.
;		Also we set the variable BreakAddr in the UMB copy to the
;		break address of the low copy, because when the clock driver
;		initialized it should return the break address of the low
;		memory copy, else sysinit will think that our drivers
;		are trying to use memory from the Low memory to the UMB !
;
;	Input : ES:BX pointer to the request packet paased to us by DOS
;	Output:	Carry set if Device driver did not initialize
;		Carry clear if Device driver succesfully initialized
;		AX=segment of the UMB copy (if carry clear)		
;
;	Note : The Clock driver will get initialized when DOS calls the
;		stub which has been re-directed to the copy in UMB
;
;------------------------------------------------------------------------------
;
SetupDDStub	proc	near

	assume	ds:bios_data

	push	es
	mov	es, LoadArea
	assume	es:nothing
	mov	byte ptr es:[SecondCopy], 0ffh
	pop	es

	mov	ax, offset JDEV_STRATEGY
	mov	CallThruPtr, ax			; call the strategy entry
	call	dword ptr CallThruPtr

	mov	ax, offset JDEV_INTERRUPT
	mov	CallThruPtr, ax			; call the interrupt entry
	call	dword ptr CallThruPtr

	mov	ax, word ptr es:[bx].RH_D_BREAKPTR+0
	add	ax, 15
	mov	cl, 4
	shr	ax, cl
	add	ax, word ptr es:[bx].RH_D_BREAKPTR+2
	sub	ax, LoadArea			; get the new size of the mem block
	jz	sds9f				; if ZERO the device driver failed

	push	es
	push	bx
	mov	bx, ax
	mov	ax, LoadArea
	mov	es, ax
	mov	word ptr es:[BreakAddr], offset bios_code:endofstub
	mov	word ptr es:[BreakAddr+2], bios_code
	dec	ax				; device sub-arena	M105
	mov	es, ax				;			M105
	mov	word ptr es:[devmark_size], bx	; Put in the size of	M105
						; device driver		M105
	inc	bx				; device sub-arena	M105

	mov	ah, SETBLOCK			; resize the memory block
	int	21h
	mov	bx, es				; 			M105
	dec	bx				; point to sub-arena	M105
	mov	es, bx				;			M105
	mov	word ptr es:[arena_owner], 8	; SYSTEM owner		M105
	pop	bx
	pop	es

	mov	ax, LoadArea			; return the segment address
	clc
	ret
sds9f:
	stc
	ret

SetupDDStub	endp

;
; M098 - end
;
;
;------------------------------------------------------------------------------
;
; DoCmdLine : process the commadn line and set the power mode
;
;	Input : ES:BX=request packet
;	Output: Zero flag set if /LOW was not specified
;		Zero flag set if /LOW was specified
;
;------------------------------------------------------------------------------
;
DoCmdLine	proc	far

	push	es
	push	bx
	les	di, es:[bx].RH_D_IDLEPTR	; command line
	cld

dcl_loop1:
	mov	al, es:[di]
	inc	di
	call	IsDelim
	jz	dcl_loop1

dcl_loop2:
	mov	al, es:[di]
	inc	di
	call	IsDelim
	jnz	dcl_loop2
	dec	di
	call	far ptr ParseCmdLine
	or	dl, dl				; M104
	pop	bx				; M104
	pop	es				; M104
	ret

DoCmdLine	endp
;
; M104 - begin
;

InitCmdLineParms	proc	near

	push	ds
	push	dx
	push	bx
	push	ax

	mov	ax, Trans_Data
	mov	ds, ax
	assume	ds:Trans_Data

	cmp	PW_Mode, 0ffh
	je	SPM_SkipMode

	mov	bh,1			; set  power state
	mov	bl, PW_Mode
	mov	ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE	; M007
	call	far ptr FPwr_Services
;	int	2fh

	mov	ax, PW_Savings_Value
	or	ax, ax
	jz	SPM_SkipMode

	mov	bx,ax
	mov	ax,(MultPWR_API * 256)+I2F_PW_GETSET_SAVINGS
	call	far ptr FPwr_Services
;	int	2fh

SPM_SkipMode:

IFDEF	DEBUG
	cmp	PW_Debug, 0
	jz	SPM_SkipDbg

	mov	ax,(MultPWR_API*256)+02h; change allocation strategy
	mov	bl,80h			; special value for SOUND toggle
	call	far ptr FPwr_Services
;	int	2fh
SPM_SkipDbg:
ENDIF
	pop	ax
	pop	bx
	pop	dx
	pop	ds
	assume	ds:nothing
	ret
	
InitCmdLineParms	endp

	public	Banner

Banner	proc	far

	push    ds
	mov	ax, Bios_Code
	mov	ds, ax
	assume	ds:nothing
	cmp	byte ptr ds:[SecondCopy], 0
	jne	b_exit
	mov     ax,cs                           ; DS=CS for the message
	mov     ds,ax
	assume  ds:nothing
	mov     dx,offset INIT_MSG
	mov     ah,STD_CON_STRING_OUTPUT        ; display power banner
	int     21h
b_exit:
	pop     ds                              ;
	ret
Banner	endp

ChkDOSVer_DispErr	proc	far
	call	far ptr ChkDOSVer
	jae	cdv_exit
	push	ds
	mov	ah, STD_CON_STRING_OUTPUT
	mov	dx, Trans_Data
	mov	ds, dx
	mov	dx, offset Trans_Data:BadDOSMsg
	int	21h
	pop	ds
	mov	al, 1
	or	al, al
cdv_exit:
	ret
ChkDOSVer_DispErr	endp

ChkDOSVer	proc	far
	push	bx
	mov	ah, GET_VERSION
	int	21h
	cmp	ax, 0005
	pop	bx
	ret
ChkDOSVer	endp

ENDIF ; POWERALONE
Sysinitseg      ends

ENDIF   ;For POWER conditional

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\msload.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160
	title	non-contiguous io.sys loader (msload)

; =========================================================================
;	NOTE:  The boot loader should be verifying that the first
;	  block of io.sys is, in fact, at cluster 2.  This would be saving
;	  a whole lot of time during system debugging.
;
;==============================================================================
;
;     for dos 4.00, msload program has been changed to allow:
;	  1. 32 bit calculation,
;	  2. reading a fat sector when needed, instead of reading the whole fat
;	     sectors at once.  this will make the boot time faster, and eliminate
;	     the memory size limitation problem,
;	  3. solving the limitation of the file size (29 kb) of io.sys0,
;	  4. adding the boot error message.  show the same boot error message
;	     and do the same behavior when the read operation of io.sys
;	     fails as the msboot program, since msload program is the
;	     extention of msboot program.
;
; =========================================================================

;
;----------------------------------------------------------------------------
;
; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
;		SYSINIT & transient portion of COMMAND.COM
;
;----------------------------------------------------------------------------
;
include bpb.inc
include bootform.inc		; extended bpb, boot record defintion.
include versiona.inc		; version number for sys.com
;include dirent.inc
include	dossym.inc
include	dosmac.inc
include mult.inc

; =========================================================================

PUBLIC DIR_ENTRY_PER_SEC
PUBLIC BiosStart
PUBLIC DskAddr
PUBLIC BootSector
PUBLIC IoSysAddr
PUBLIC Sec9
PUBLIC SysVersion
PUBLIC MyStacks
PUBLIC StackPtr
PUBLIC NumHeads
PUBLIC ClusterSize
PUBLIC StartSecL
PUBLIC StartSecH
PUBLIC TempH
PUBLIC TempCluster
PUBLIC LastFatSector
PUBLIC SectorCount
PUBLIC SecPerFat
PUBLIC HiddenSectorsL
PUBLIC HiddenSectorsH
PUBLIC BytesPerSec
PUBLIC ReservSectors
PUBLIC CurrentCluster
PUBLIC NextBioLocation
PUBLIC FirstSectorL
PUBLIC FirstSectorH
PUBLIC TotalSectorsL
PUBLIC TotalSectorsH
PUBLIC SecPerTrack
PUBLIC BootDrive
PUBLIC FatSize
PUBLIC MediaByte
PUBLIC EndOfFile
PUBLIC OrgDasdPtr
PUBLIC FatSegment
PUBLIC SecPerCluster

; =========================================================================

END_OF_FILE		EQU	0ffh
FAT_12_BIT		EQU	01h
FAT_16_BIT		EQU	04h
ROM_TTY			EQU	14	; Int 10h, teletype function
DIR_ENTRY_PER_SEC 	EQU	16	; Num of directory entries per sec

BiosStart		EQU	51ah	; Bios starting cluster in root dir
Sec9			EQU	522h
BiosOffset		EQU	700h
DskAddr			EQU 	1eh * 4	; ROM BIOS diskette table vector

; =========================================================================

BootSeg 	SEGMENT at 0h
       ORG	7c00h

BootSector	label	byte

BootSeg 	ends

; =========================================================================

DosLoadSeg	SEGMENT at 70h
       ORG	00h

IoSysAddr	label	byte

DosLoadSeg	ends

; =========================================================================

cSeg	SEGMENT PUBLIC para 'code'
	ASSUME	CS:CSEG, DS:NOTHING, ES:NOTHING, SS:NOTHING
	ORG	0

Start:
	jmp	SaveInputValuess

SysVersion		dw	expected_version ; from versiona.inc file
MyStacks		dw	128 DUP (0)	; local stack, increased size to
StackPtr		LABEL	WORD

NumHeads		dw	0
ClusterSize		dw	0
StartSecL		dw	0
StartSecH		dw	0
TempH			dw	0	; for 32 bit calculation
TempCluster		dw	0	; temporary place for cluster number
LastFatSector		dw	-1	;fat sector number starting from the first fat entry.
SectorCount		dw	0
SecPerFat		dw	0
HiddenSectorsL		dw	0
HiddenSectorsH		dw	0
BytesPerSec		dw	0
ReservSectors		dw	0
CurrentCluster		dw	0
NextBioLocation		dw	0
FirstSectorL		dw	0
FirstSectorH		dw	0
TotalSectorsL		dw	0	;.max. number of sectors
TotalSectorsH		dw	0
SecPerTrack		dw	0
BootDrive		db	0
FatSize			db	0
MediaByte		db	0
EndOfFile		db	0
OrgDasdPtr		dd	0
FatSegment		dw	0
SecPerCluster		db	0

; =========================================================================
;	SaveInputValuess
; =========================================================================
;
; INPUT:     none
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector (low) on disk (0-based)
;   ds:si = original rom bios diskette parameter table.
;
; if an extended boot record, then ax will be the first data sector
; high word.	save ax and set FirstSectorH according to ax if it is an
; extended boot record.
;
;   ax = first data sector (high) on disk ;
; OUTPUT:
;
;   bx = first data sector on disk
;
;   MediaByte = input ch
;   BootDrive = input dl
;   FirstSectorL = input bx
;   FirstSectorH = input AX, if an extended boot record.;j.k.
;   TotalSectorsL = maximum sector number in this media ;j.k.
;   TotalSectorsH = high word of the above
;   HiddenSectorsL = hidden secotrs
;   HiddenSectorsH
;   ReservSectors = reserved sectors
;   SecPerTrack = sectors/track
;   NumHeads = heads/cylinder
;
;   ds = 0
;   AX,DX,SI destroyed
;
; calls:     none
; =========================================================================
;FUNCTION:
; save input information and bpb informations from the boot record.
; =========================================================================

	PUBLIC SaveInputValueSS
SaveInputValueSS:

	mov	FirstSectorL,BX
	mov	MediaByte,CH
	mov	BootDrive,DL

	mov	WORD PTR OrgDasdPtr,SI
	push	ds
	pop	WORD PTR OrgDasdPtr+2

        xor     CX,CX                   ; segment 0 (obviously)
	mov	DS,CX
	ASSUME	DS:BootSeg

	push	ES
	mov	ES,CX
	ASSUME	ES:BootSeg

	mov	SI,WORD PTR DS:DskAddr
	mov	DS,WORD PTR DS:DskAddr+2 ; DS:si -> current table

	mov	DI,Sec9 		; ES:di -> new table
	mov	CX,11			; taken from ibmboot.asm
	cld
	rep	movsb			; copy table
	push	ES
	pop	DS			; ds = 0

	mov	WORD PTR DS:DskAddr,Sec9
	mov	WORD PTR DS:DskAddr+2,DS ; point disk parm vector to new table
	pop	ES
	ASSUME	ES:NOTHING

	mov	CX,BootSector.ext_boot_bpb.BPB_bytespersector
	mov	CS:BytesPerSec,CX

	mov	CL,BootSector.ext_boot_bpb.BPB_sectorspercluster
	mov	CS:SecPerCluster,CL

	mov	CX,BootSector.ext_boot_bpb.BPB_sectorspertrack	;get sectors per track
	mov	CS:SecPerTrack,CX

	mov	CX,BootSector.ext_boot_bpb.BPB_heads		;get bpb heads per cylinder
	mov	CS:NumHeads,CX

	mov	CX,BootSector.ext_boot_bpb.BPB_sectorsperfat	;get sectors per fat
	mov	CS:SecPerFat,CX

	mov	CX,BootSector.ext_boot_bpb.BPB_reservedsectors	;get reserved sectors
	mov	CS:ReservSectors,CX

	mov	CX,WORD PTR BootSector.ext_boot_bpb.BPB_hiddensectors ;get hidden sectors
	mov	CS:HiddenSectorsL,CX

	mov	CX,BootSector.ext_boot_bpb.BPB_totalsectors
	mov	CS:TotalSectorsL,CX

		; First of all, check if it the boot record is an extended one.
		; This is just a safe guard in case some user just "copy" the
		; 4.00 iosys.com to a media with a conventional boot record.

	cmp	BootSector.ext_boot_sig,ext_boot_signature
	jne	relocate

	mov	CS:FirstSectorH,AX					; start data sector (high)
	mov	AX,WORD PTR BootSector.ext_boot_bpb.BPB_hiddensectors+2
	mov	CS:HiddenSectorsH,AX
	cmp	CX,0							; cx set already before (=totalsectors)
	jne	relocate

	mov	AX,WORD PTR BootSector.ext_boot_bpb.BPB_bigtotalsectors
	mov	CS:TotalSectorsL,AX
	mov	AX,WORD PTR BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
	mov	CS:TotalSectorsH,AX

; =========================================================================
;	Relocate
; =========================================================================
;
; NOTES:
;
;   Relocates the loader code to top-of-memory.
;
; INPUT:     none
;
; OUTPUT:    code and data relocated.
;	     AX,CX,SI,DI destroyed
;
; calls:     none
; =========================================================================
;
; Determine the number of paragraphs (16 byte blocks) of memory.
; this involves invoking the memory size determination interrupt,
; which returns the number of 1k blocks of memory, and then
; converting this to the number of paragraphs.
; Find out whether RPL code is present at top of memory and modify the
; available amount of memory in AX
; leave the number of paragraphs of memory in ax.
;
;-----------------------------------------------------------------------
; copy code from start to top of memory.
;
; the length to copy is EndOfLoader
;
; jump to relocated code
;-----------------------------------------------------------------------

	PUBLIC	Relocate
Relocate:

	ASSUME	DS:NOTHING
	cld
	xor	SI,SI
	mov	DI,SI

	int	12h			; Get system memory size in kbytes
	mov	CL,6
	shl	AX,CL			; Memory size in paragraphs

;M056 - BEGIN
;
;------ Check if an RPL program is present at TOM and do not tromp over it
;
	xor	bx, bx
	mov	ds, bx
	mov	bx, ds:[2fh*4]
	mov	ds, ds:[2fh*4+2]
	cmp	word ptr ds:[bx+3], 'PR'
	jne	SkipRPL
	cmp	byte ptr ds:[bx+5], 'L'
	jne	SkipRPL

	mov	dx, ax			; get TOM into DX
	mov	ax, (multMULT shl 8) + multMULTRPLTOM
	int	2fh			; Get new TOM from any RPL
	mov	ax, dx
SkipRPL:
;
;M056 - END
;
	mov	CL,4
	mov	DX,CS:BytesPerSec
	shr	DX,CL
	inc	DX
	sub	AX,DX
	mov	CS:FatSegment,AX	; This will be used for fat sector

	mov	DX,OFFSET EndOfLoader
	shr	DX,CL
	inc	DX
	sub	AX,DX
	mov	ES,AX			; ES:di -> place be relocated.

	push	CS
	pop	DS			; DS:si -> source
	mov	CX,OFFSET EndOfLoader
	rep	movsb

	push	ES
	mov	AX,OFFSET SetUpStack
	push	AX			; Massage stack for destin of CS:IP

Dumbbb	PROC	FAR

	ret

Dumbbb	ENDP


; =========================================================================
; Start of relocated code
; =========================================================================
;
; Move the stack to just under the boot record and relocation area (0:7c00h)
;
; =========================================================================

	PUBLIC SetUpStack
SetUpStack:

	ASSUME	DS:NOTHING, ES:NOTHING, SS:NOTHING

	mov	AX,CS
	mov	SS,AX			;set up the stack to the known area.
	mov	SP,OFFSET StackPtr

; =========================================================================
;	FindClusterSize
; =========================================================================
;
; INPUT:     bpb information in loaded boot record at 0:7c00h
;
; OUTPUT:
;
;	ds = 0
;	ax = bytes/cluster
;	bx = sectors/cluster
;	si destroyed
; calls:     none
;-----------------------------------------------------------------------
;
; get bytes/sector from bpb
;
; get sectors/cluster from bpb
;
; bytes/cluster = bytes/sector * sector/cluster
; =========================================================================

	PUBLIC FindClusterSize
FindClusterSize:

;for the time being just ASSUME the boot record is valid and the bpb
;is there.

	xor	AX,AX				;segment 0
	mov	DS,AX

	ASSUME DS:BootSeg

	mov	AX,BootSector.ext_boot_bpb.BPB_bytespersector	  ;get bpb bytes/sector
	xor	BX,BX
	mov	BL,BootSector.ext_boot_bpb.BPB_sectorspercluster ;get sectors/cluster
	mul	bx				;bytes/cluster
	mov	CS:ClusterSize,AX		;save it


; =========================================================================
;	CalcFatSize
; =========================================================================
;
; NOTES:
;
;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
;   to find out what system id byte is.
;
; INPUT:
;
; OUTPUT:
;
;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
;   all other registers destroyed
;
;----------------------------------------------------------------------

CalcFatSize:

	mov	CS:FatSize,FAT_12_BIT		;ASSUME 12 bit fat

	mov	DX,CS:TotalSectorsH
	mov	AX,CS:TotalSectorsL		; DX:AX = total disk sectors

	sub	AX,CS:ReservSectors
	sbb	DX,0				; DX:AX = Total avail sectors

	mov	BX,CS:SecPerFat 		; BX = Sectors per FAT
	shl	BX,1				; Assume 2 FATs so mult by 2

	sub	AX,BX
	sbb	DX,0				; DX:AX = Total secs - fat secs

		; Total directory entries per sector = (512 / 32) = 16
		; and (Total dir entries / 16) = Total directory sectors

	mov	BX,BootSector.ext_boot_bpb.BPB_rootentries
	mov	CL,4				; Divide by 16
	shr	BX,CL				; BX = Total directory sectors

	sub	AX,BX				; Subtract directory sectors
	sbb	DX,0				; DX:AX = Sectors in data area

	xor	CX,CX
	mov	CL,BootSector.ext_boot_bpb.BPB_sectorspercluster

	push	ax				; 32 bit divide by sectors per
	mov	AX,DX				; cluster to find total number
	xor	DX,DX				; of clusters.
	div	cx
	mov	CS:TempH,AX
	pop	ax
	div	cx

	cmp	AX,4096-10			; 12 bit fat if < 4096 clusters
	jb	ReadInFirstClusters

	mov	CS:FatSize,FAT_16_BIT		; Else 16 bit fat

; =========================================================================
;	ReadInFirstClusters
; =========================================================================
;
; NOTES: read the start of the clusters that covers at least IbmLoadSize
;	 fully.  for example, if sector/cluster = 2, and IbmLoadSize=3
;	 then we are going to re-read the second cluster to fully cover
;	 msload program in the cluster boundary.
;
; INPUT:
;   IbmLoadSize - make sure this value is the same as the one in
;		  msboot program when you build the new version!!!!!
;
;   SecPerCluster
;   ClusterSize
;   FirstSectorL
;   FirstSectorH
;
; OUTPUT: msload program is fully covered in a cluster boundary.
;	  ax = # of clusters we read in so far.
;
; calls:     ReadSectors
; logic:
;	ax; dx = IbmLoadSize / # of sector in a cluster.
;	if dx = 0 then ok. (msload is in a cluster boundary.)
;      else		   (has to read (ax+1)th cluster to cover msload)
;	read (ax+1)th cluster into the address after the clusters we
;	read in so far.
; =========================================================================

	PUBLIC ReadInFirstClusters
ReadInFirstClusters:

	mov	AX,DS:[BiosStart]	; AX = BIOS starting cluster
	dec	AX			; First cluster is 2 so
	dec	AX			; decrement to make 0 based
	mov	CS:CurrentCluster,AX	; Initialize to this cluster

	mov	AX,IbmLoadSize		; AX = Number sectors in MSLOAD
	div	CS:SecPerCluster	; AL = total cluster read in
					; AH = remaining sectors in last cluster

	cmp	AH,0			; Check for remaining sectors
	je	SetNextClusterNum	; Nothing remaining in last cluster

	xor	AH,AH			; AX = total clusters in the loader
	push	AX			; already read in

		; Calculate sector to start reading from in StartSecH
		; and StartSecL

	mov	CX,CS:FirstSectorL	; Put starting sector of disk data
	mov	CS:StartSecL,CX 	; area in StartSecH:StartSecL
	mov	CX,CS:FirstSectorH
	mov	CS:StartSecH,CX 	; Start sector = First sector dat

	mul	CS:SecPerCluster	; AX = Number of sectors already loaded

	add	CS:StartSecL,AX 	; Add number of sectors already loaded
	adc	CS:StartSecH,0		; to start sector

		; Added to allow BIOS to start anywhere on disk so long
		; as MSLOAD is contigous - 5.00

	mov	AX,DS:[BiosStart]	; AX = BIOS starting cluster
	dec	AX			; Convert to 0 based clusters
	dec	AX			; by subtracting 2


	xor	BX,BX
	mov	BL,CS:SecPerCluster	; BX = sectors per cluster
	mul	BX			; DX:AX = logical start sector
	add	CS:StartSecL,AX		; Add logical sectors to start
	adc	CS:StartSecH,DX		; abs start sector for next read of
					; the rest of the last loader cluster

		; End of changed for 5.00

	pop	AX			; AX = total clusters in the loader
	push	AX			; already read in

	mul	CS:ClusterSize		; AX = bytes in full clusters read in
	mov	DI,BiosOffset		; DI -> Addr where loader was read in
	add	DI,AX			; DI -> Start address for next cluster

	xor	AX,AX
	mov	ES,AX			; ES = segment 0

	mov	AL,CS:SecPerCluster	; AX = sectors per cluster (# to read)
	mov	CS:SectorCount,AX	; SectorCount = sectors to read

	call	ReadSectors		; Read in the entire last cluster

	pop	AX			; AX = total clus read by boot loader
	inc	AX			; AX = total clus read in now

	subttl SetNextClusterNum
	page

SetNextClusterNum:

	inc	AX			; AX = total clusters read in based 2
	add	CS:CurrentCluster,AX	; CurrentCluster = Last cluster read
	dec	AX			; AX = number of clusters loaded


; =========================================================================
; SaveLoadedBios
; =========================================================================
;
; NOTES:
;
;   Determine how much of iosys was loaded in when the loader was loaded
;   by the boot record (only the portion that is guaranteed to be contiguous)
;
; INPUT:
;   AX:Total cluster already read in (loader & bios)
;   CS:CurrentCluster = number of clusters used for loader+2
;
; OUTPUT:
;	ES = 70h
;	DI = next offset to load iosys code
;	AX,BX,CX,DX,SI destroyed
;
;	CS:NextBioLocation = di on output
;	CS:last_cluster = last cluster loaded
;
; calls:     none
;
; =========================================================================
;
; Multiply cluster * cluster size in bytes to get total loaded for msload
;
; Subtract total_loaded - (EndOfLoader) to get loaded io.sys in last cluster
;
; Relocate this piece of iosys down to 70:0
;
; =========================================================================

SaveLoadedBios:

	push	DS

	mul	CS:ClusterSize		; Get total bytes loaded by
					; this is always < 64k, so
					; lower 16 bits ok

					;get portion of iosys loaded
	sub	AX,(OFFSET EndOfLoader)-(OFFSET Start)
	mov	CX,AX			; Save length to move

	mov	AX,70h			; Segment at 70h
	mov	DS,AX			; DS = segment 70h
	mov	ES,AX			; ES = segment 70h

	mov	SI,OFFSET EndOfLoader	; Point at start of iosys
	xor	DI,DI			; Point at 70:0
	rep	movsb			; Relocate this code to 70:00

	mov	CS:NextBioLocation,DI	; Save where location for next read
	pop	DS

; =========================================================================
;	GetContigClusters
; =========================================================================
;
; NOTES: go find clusters as long as they are contiguous
;
;
; INPUT:
;   CS:NextBioLocation
;   CS:
;
; OUTPUT:
;
; calls: GetNextFatEntry
; =========================================================================
;
;Set CS:SectorCount to sectors per cluster
;
;Call GetNextFatEntry to get next cluster in file
;
;Call check_for_eof
;
;if (nc returned)
;
;   {call GetNextFatEntry
;
;    if (new cluster is contig to old cluster)
;	{add sectors per cluster to CS:SectorCount
;
;	 call check_for_eof
;
;	 if (nc returned)
;
;
; =========================================================================

	PUBLIC GetContigClusters
GetContigClusters:

	xor	AH,AH
	mov	AL,CS:SecPerCluster	; Assume we will get one cluster
	mov	CS:SectorCount,AX	; Sector count = sectors in 1 cluster

	push	CS:SectorCount
	call	GetNextFatEntry		; Returns next cluster to read in AX
	pop	CS:SectorCount

	mov	CS:CurrentCluster,AX	; Update the last one found
	cmp	CS:EndOfFile,END_OF_FILE
	je	GoToBioInit

	xor	DX,DX
	sub	AX,2			; Zero base the cluster
	xor	CH,CH
	mov	CL,CS:SecPerCluster	; Get sectors per cluster
	mul	CX			; Get how many

	add	AX,CS:FirstSectorL	; See where the data sector starts
	adc	DX,CS:FirstSectorH

	mov	CS:StartSecL,AX 	; Save it (used by ReadSectors)
	mov	CS:StartSecH,DX

	mov	DI,CS:NextBioLocation	; Get where to put code
	push	CS:SectorCount		; Save how many sectors
	mov	AX,DosLoadSeg		; Get area to load code
	mov	ES,AX

	call	ReadSectors
	pop	AX			; Get back total sectors read in

	mul	CS:BytesPerSec		; Get number of bytes we loaded
	add	CS:NextBioLocation,AX	; Point to where to load next
	jmp	GetContigClusters

; =========================================================================
;	GoToBiosInit
; =========================================================================
;
; NOTES:
;
;  Set up required registers for iosys, then jump to it (70:0)
;
; INPUT:     none
;
;   CS:MediaByte = media byte
;   CS:BootDrive = int 13 drive number we booted from
;   CS:FirstSectorL = first data sector on disk (low) (0-based)
;   CS:FirstSectorH = first data sector on disk (high)
;
; OUTPUT:
;
;   required by msinit
;   DL = int 13 drive number we booted from
;   CH = media byte
;   BX = first data sector on disk (0-based)
;   AX = first data sector on disk (high)
;   DI = sectors/fat for the boot media.
;
; calls:     none
; =========================================================================
;
; set up registers for msinit then do far jmp
;
; =========================================================================

	PUBLIC GoToBioInit
GoToBioInit:

	mov	CH,CS:MediaByte 	; Restore regs required for msint
	mov	DL,CS:BootDrive 	; Physical drv number we booted from.
	mov	BX,CS:FirstSectorL
	mov	AX,CS:FirstSectorH	; BX:AX = first data sector of disk

	jmp	FAR PTR IoSysAddr


; =========================================================================
; ReadSectors
; =========================================================================
;
; notES:
;
;  read in the CS:SectorCount number of sectors at ES:di
;
;
; INPUT:
;
;   DI = OFFSET of start of read
;   ES = segment of read
;   CS:SectorCount = number of sectors to read
;   CS:StartSecL = starting sector (low)
;   CS:StartSecH = starting sector (high)
;   following is bpb info that must be setup prior to call
;   CS:NumHeads
;   CS:number_of_sectors
;   CS:BootDrive
;   CS:SecPerTrack
;
; OUTPUT:
;
;   AX,BX,CX,DX,SI,DI destroyed
; =========================================================================
; divide start sector by sectors per track
; the remainder is the actual sector number, 0 based
;
; increment actual sector number to get 1 based
;
; the quotient is the number of tracks - divide by heads to get the cyl
;
; the remainder is actual head, the quotient is cylinder
;
; figure the number of sectors in that track, set al to this
;
; do the read
;
; if error, do reset, then redo the int 13h
;
; if successful read, subtract # sectors read from SectorCount, add to logical
; sector, add #sectors read * BytesPerSec to bx;
;
; if SectorCount <> 0 do next read
; =========================================================================

ReadSectors PROC	NEAR
	ASSUME	DS:NOTHING, ES:NOTHING

DoDivide:
	mov	CX,5			; 5 retries

		; Convert a logical sector into track/sector/head. AX has the
		; logical sector number
TryRead:
	push	CX			; Save it
	mov	AX,CS:StartSecL 	; Get starting sector
	mov	DX,CS:StartSecH

	push	AX
	mov	AX,DX
	xor	DX,DX
	div	WORD PTR CS:SecPerTrack
	mov	CS:TempH,AX
	pop	AX

	div	WORD PTR CS:SecPerTrack ; [TempH];ax = track, dx = sector number
	mov	BX,CS:SecPerTrack	; Get number of sectors we can read in
	sub	BX,DX			; this track
	mov	SI,BX

	cmp	CS:SectorCount,SI	; Is possible sectors in track more
	jae	GotLength		; than what we need to read?

	mov	SI,CS:SectorCount	; Yes, only read what we need to

GotLength:
	inc	DL			; Sector numbers are 1-based
	mov	BL,DL			; Start sector in DL
	mov	DX,CS:TempH		; DX:AX = Track

	push	AX
	mov	AX,DX
	xor	DX,DX
	div	WORD PTR CS:NumHeads	; Start cyl in AX,head in dl
	mov	CS:TempH,AX
	pop	AX

	div	WORD PTR CS:NumHeads	; [TempH];AX = Cyliner, DX = Head

		; At this moment, we assume that TempH = 0,
		; ax <= 1024, dx <= 255

	mov	DH,DL

		; Issue one read request. ES:BX have the transfer address,
		; AL is the number of sectors.

	mov	CL,6
	shl	AH,CL			; Shift cyl high bits up
	or	AH,BL			; Mix in with sector bits
	mov	CH,AL			; Setup cyl low
	mov	CL,AH			; Setup cyl/high - sector
	mov	BX,DI			; Get back OFFSET
	mov	DL,CS:BootDrive 	; Get drive
	mov	AX,SI			; Get number of sectors to read (al)

	mov	AH,2			; Read
	push	AX			; Save length of read
	push	DI

		; Issue one read request. ES:BX have the transfer address,
		; AL is the number of sectors.

	int	13h
	pop	DI
	pop	AX
	pop	CX			; Get retry count back
	jnc	ReadOk

	mov	BX,DI			; Get offset
	xor	AH,AH
	push	CX
	mov	DL,CS:BootDrive
	push	DI
	int	13h
	pop	DI
	pop	CX
	dec	CX
	jz	ReadError

	jmp	TryRead

ReadError:
	jmp	ErrorOut

ReadOk:
	xor	AH,AH			; Mask out read command, just get # read
	sub	CS:SectorCount,AX	; Bump number down
	jz	EndRead

	add	CS:StartSecL,AX 	; Where to start next time
	adc	CS:StartSecH,0
	xor	BX,BX			; Get number sectors read
	mov	BL,AL
	mov	AX,CS:BytesPerSec	; Bytes per sector
	mul	BX			; Get total bytes read
	add	DI,AX			; Add it to OFFSET
	jmp	DoDivide

EndRead:
	ret

ReadSectors	ENDP

; =========================================================================
;	GetNextFatEntry
; =========================================================================
;
; NOTES:
;
;   given the last cluster found, this will return the next cluster of
;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
;   of iosys has been loaded, and control is passed to goto_iosys
;   msload can handle maximum fat area size of 128 kb.
;
; INPUT:
;
;    CS:CurrentCluster
;    CS:FatSize
;
; OUTPUT:
;
;   CS:CurrentCluster (updated)
;
; calls:  GetFatSector
; =========================================================================
; get CurrentCluster
;
; if (16 bit fat)
;    {if (CurrentCluster = fff8 - ffff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by multiply cluster by 2}
;
; else
;    {if (CurrentCluster = ff8 - fff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by	- multiply cluster by 3
;
;	 rotate right to divide by 2
;
;	 if (cy set - means odd number)
;	    {shr 4 times to keep high twelve bits}
;
;	 else
;	    {and with 0fffh to keep low 12 bits}
;	}
;    }
;
;
; =========================================================================

GetNextFatEntry PROC NEAR
	ASSUME	DS:NOTHING, ES:NOTHING

	push	ES
	mov	AX,CS:FatSegment
	mov	ES,AX			; ES-> FAT area segment

	ASSUME	ES:NOTHING

	mov	CS:EndOfFile,END_OF_FILE ; Assume last cluster
	mov	AX,CS:CurrentCluster	; Get last cluster
	cmp	CS:FatSize,FAT_12_BIT
	jne	Got16Bit

	mov	SI,AX
	shr	AX,1
	add	SI,AX			; SI = AX * 1.5 = AX + AX/2

	push	DX			; M054
	xor	DX,DX			; M054
	call	GetFatSector
	pop	DX			; M054

	jne	ClusterOk

	mov	AL,BYTE PTR ES:[bx]
	mov	BYTE PTR CS:TempCluster,AL
	inc	SI

	push	DX			; M054
	xor	DX,DX			; M054
	call	GetFatSector		; Read next fat sector
	pop	DX			; M054

	mov	AL,BYTE PTR ES:[0]
	mov	BYTE PTR CS:TempCluster+1,AL
	mov	AX,CS:TempCluster
	jmp	SHORT EvenOdd

ClusterOk:
	mov	AX,ES:[bx]

EvenOdd:
	test	CS:CurrentCluster,1	; Was last cluster odd?
	jnz	OddResult		; If carry set it was odd

	and	AX,0fffh		; Keep low 12 bits
	jmp	SHORT TestEOF

OddResult:
	 mov	CL,4			; Keep high 12 bits for odd
	 shr	AX,CL

TestEOF:
	 cmp	AX,0ff8h		; Is it last cluster?
	 jae	GotClusterDone		; Yep, all done here

	 jmp	SHORT NotLastCluster

Got16Bit:
	push	DX			; M054
	xor	DX,DX			; M054
	shl	AX,1			; Multiply cluster by 2
	adc	DX,0			; M054
	mov	SI,AX			; Get the final buffer OFFSET
	call	GetFatSector
	pop	DX			; M054

	mov	AX,ES:[bx]
	cmp	AX,0fff8h
	jae	GotClusterDone

NotLastCluster:
	mov	CS:EndOfFile,NOT END_OF_FILE ; Assume last cluster

GotClusterDone:
	pop	ES
	ret

GetNextFatEntry ENDP

; =========================================================================
;
;function: find and read the corresponding fat sector into ES:0
;
;in). SI = offset value (starting from fat entry 0) of fat entry to find.
;     ES = fat sector segment
;     CS:BytesPerSec
;
;out). corresponding fat sector read in.
;      BX = offset value of the corresponding fat entry in the fat sector.
;      CX destroyed.
;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
;      starts at the last byte of the fat sector.  in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value.	(this will only happen with the 12 bit fat).
;
; =========================================================================

GetFatSector	PROC	NEAR
	ASSUME	DS:NOTHING, ES:NOTHING

	push	AX
	push	SI
	push	DI

;	push	DX			; M054
;	xor	DX,DX			; M054


	mov	AX,SI
	mov	CX,CS:BytesPerSec
	div	CX			; AX = Sector number, DX = Offset

	cmp	AX,CS:LastFatSector	; The same fat sector?
	je	SplitChk		; Don't need to read it again.

	mov	CS:LastFatSector,AX

	push	DX
	xor	DX,DX
	add	AX,CS:HiddenSectorsL
	adc	DX,CS:HiddenSectorsH
	add	AX,CS:ReservSectors
	adc	DX,0

	mov	CS:StartSecL,AX
	mov	CS:StartSecH,DX 	; Set up for ReadSectors
	mov	CS:SectorCount,1	; 1 sector

	xor	DI,DI
	call	ReadSectors

	pop	DX
	mov	CX,CS:BytesPerSec

SplitChk:
	dec	CX			; CX = SECTOR SIZE - 1
	cmp	DX,CX			; If last byte of sector, splitted entry.
	mov	BX,DX			; set bx to dx

;	pop	DX			; M054

	pop	DI
	pop	SI
	pop	AX
	ret

GetFatSector	ENDP

; =========================================================================

ErrorOut:
	push	cs
	pop	ds
	mov	SI,OFFSET sysmsg
	call	WriteTTY

		; Wait for a keypress on the keyboard. Use the bios keyboard
		; interrupt.

	xor	AH,AH
	int	16h			;read keyboard

		; We have to restore the address of the original rom disk
		; parameter table to the location at [0:DskAddr]. The address
		; of this original table has been saved previously in
		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
		; has been restored we can reboot by invoking the bootstrap
		; loader bios interrupt.

	xor	BX,BX
	mov	DS,BX
	les	BX,dWORD PTR DS:OrgDasdPtr
	mov	SI,DskAddr
	mov	WORD PTR DS:[si],BX	;restore offset
	mov	WORD PTR DS:[si+2],ES	;restore segment
	int	19h			;reboot

; =========================================================================
;
;in) DS:si -> asciiz string.
;
; WriteTTY the character in al to the screen.
; use video service 'write teletype to active page' (ROM_TTY)
; use normal character attribute
;
; =========================================================================

WriteTTY PROC  NEAR			; Show error messages

	lodsb
	or	AL,AL
	jz	EndWrite

	mov	AH,ROM_TTY
	mov	BL,7			; "normal" attribute ?
	int	10h			; video write
	jmp	WriteTTY

EndWrite:
	ret

WriteTTY ENDP

; =========================================================================

include msbio.cl1

EndOfLoader label byte

; =========================================================================

cSeg	ENDS
	END	Start

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power.inc ===
;       Standard includes for POWER.EXE device driver and control program
;
;       Microsoft Confidential
;       Copyright (C) 1991 Microsoft Corporation 
;       All Rights Reserved.

;
;------------------------------------------------------------------------------
;
; M077 : B#2669. Registered POWER's 2f channels in mult.inc
;
;------------------------------------------------------------------------------
;
REQHDR	STRUC			; DOS REQUEST HEADER STRUCTURE
RH_B_LEN	db ?		; request header length
		db ?		; block device only
RH_B_CMD	db ?		; command to execute on this request
RH_W_STATUS	dw ?		; return status from driver
		db 8 dup(?)	; reserved for dos
REQHDR	ENDS

RHINIT	STRUC
		db SIZE REQHDR dup(?)
		db ?		; block device only
RH_D_BREAKPTR	dd ?		; return address to end driver
RH_D_IDLEPTR	dd ?		; return address of idle routine
				; for DOS special definition for DOS 5
		db ?		; block device only
RHINIT	ENDS

RHIO	STRUC
		db SIZE REQHDR dup(?)
		db ?		; block device only
RH_D_XFERPTR	dd ?		; address of read/write block
RH_W_XFERCNT	dw ?		; size of block
		dw ?		; block device only
		dd ?		; block device only
RHIO	ENDS

POW_IOCTL_BLOCK struc           ; structure returned by IOCTL READ call

PIB_ENTRY_OFFSET dw ?            ; callback entry point
PIB_ENTRY_SEG   dw ?
PIB_VERSION     db ?            ; version of POWER.EXE
                db 27 dup (?)   ; reserved

POW_IOCTL_BLOCK ends

; SAVEPWR version nos
POW_MAJ_VERSION	EQU 01H 	; M084
POW_MIN_VERSION	EQU 00H 	; M084


; functions supported by POWER direct callback
POW_GET_CONTROL_INFO    equ     0       ; return pointer to control structure
POW_GET_STATS           equ     1       ; return pointer to idle measurment structure
POW_DO_IDLE             equ     2       ; direct DO_IDLE call

;-----------------------
; Equates for the BIT Values in POWER_STATUS (defined in POWER.ASM)
; Also used by GET/SET POWER STATUS API
;
SW_IDLE_ACTIVE	EQU	1	; BIT 0 ON => SW idle detection enabled
FW_IDLE_ACTIVE	EQU	2	; BIT 1 ON => FW (APM) Pow.Mgmt. enabled.

;-----------------------
; IDLE  strategy flags

KYC_ACTIVE	EQU 01h
DOSYIELD_ACTIVE	EQU 02h
APP_ACTIVE	EQU 04h
DOSIDLE_ACTIVE	EQU 08h

AUTO_ACTIVE	EQU 10h		; Set IFF kyc & DOSYIELD are on
SOUND_ACTIVE	EQU 80h		; DEBUG ONLY

ALG_RESERVED_BITS equ NOT (KYC_ACTIVE+DOSYIELD_ACTIVE+APP_ACTIVE+DOSIDLE_ACTIVE)
;-----------------------

CONTROL_INFO struc
IDLE_FLG	dw ?		; startup AUTO, MEASURE, IDLE
SWITCH_DLY	dw ?		; delay to switch between idle algorithms
THRESHOLD	dw ?		; idle ignore threshold
ADAPT_DLY	dw ?		; idle adaptation delay
MAXERRSAMPLE    dw ?            ; max. allowed errors while adapting
SPEED_DLY	dw ?		; full speed delay
SPDUP_RAMP	dw ?		; adjustable ramp delay used in APP_SPDUP
SPDUP_MAX	dw ?		; maximum delay speedup delay
CV86FLG		dw ?		; bit 0 set if test active
				; bit 1 set if 386 or above
CONTROL_INFO ends

IDLE_INFO struc
CPU_ON_TIME	dd ?		; total time CPU is ON (TIMER TICS)
CPU_IDLE_TIME	dd ?		; total time CPU is IDLE (TIMER TICS)
IDLE_TOT	dd ?		; total count of idles executed
APP_TOT		dd ?		; total count of APPLICATION IDLES
DOS_TOT		dd ?		; total count of DOS IDLES
KEY_TOT		dd ?		; total count of KEY BOARD IDLES
SHELL_TOT	dd ?		; total count of shell idles
IDLE_INFO ends

PERIOD_INFO struc
ACC_COUNTER	dw ?			; M106 
ACC_HI		dw ?			; M106
SAMPLE_COUNT	dw ?			; no of samples counted in the avg
PERIOD	dw ?			; Current period in timer tics
PSPREAD	dw ?			; Spread over the current avg in adapt cycle
BASE	dw ?			; Current base period in timer tics
NOISE   dw ?                    ; noise allowed on the current base
ADAPT	dw ?			; (1) Adapting to increase in period
DELAY	dw ?			; WAIT Count prior to adapting
PCOUNT	dw ?			; Counts times this interrupt has been called
PERIOD_INFO ends

MAXCMOSPOLLCOUNT	equ	364	; M092 approx. once in 20 secs 

; M092  BEGIN
BIOSDATASEG	equ	40h
ROLLOVERFLG	equ	70h
BIOSTICKCOUNT	equ	6ch
; M092 END

; M001 APM SUPPORT 
; Comment the next line out, if you don't want APM related code to be
; present in POWER.
INCL_APM	equ	1
;
; additional equates used by APM support code

APM_STATS_STRUC	struc
	RESUME_COUNT	dw	?
APM_STATS_STRUC	ends

APM_STATS_STRUC_SIZE	equ	size APM_STATS_STRUC

.errnz (APM_STATS_STRUC_SIZE - 2)
; If this line generates error message look at power.asm I2f processing code
; for get_STATS API. This is currently the size the APM_RESUME_COUNT

I1A_GET_DATE	equ	0400h		; get date int 1a function code
ROLLOVER_COUNT	equ	70h		; offset to the byte counter of 
					; elapsed days  in bios data area
					; (i.e. 40:70h)

; **************************** ERROR CODES ***********************

ERROR_PM_ALREADY_CONNECTED	equ	02h		; same as APM
ERROR_PM_NOT_CONNECTED		equ	03h		; same as APM
ERROR_PM_FUNCTION_NOT_SUPPORTED	equ	70h
ERROR_PM_BUFFER_TOO_SMALL	equ	71h
ERROR_PM_INVALID_PARAMETER	equ	87h		; same as system EXTEND

; ***************************** Int 2f subfunctions supported by POWER *****
;
I2F_PW_INSTALL_CHK	equ	0
I2F_PW_GET_SET_PWSTATE	equ	1
I2F_PW_SELECT_ALG	equ	2
I2F_PW_GETSET_SAVINGS	equ	3
I2F_PW_TUNE_PARM	equ	80h
I2F_PW_GET_STATS	equ	81h
I2F_PW_APM_POLLCOUNT	equ	82h
I2F_PW_GETSET_BASELINE	equ	8fh
;
; ***************************** parameters/args for the above int 2f functions
;
; args for PW_GET_STATS call (BX reg)
PW_GET_IDLE_STATS	equ	0
PW_GET_APM_STATS	equ	1
;******************************* the broadcast int. used by POWER ***********
;
I2F_APM_BROADCAST	equ	((MultPWR_BRDCST * 256)+0bh)		; M077
;
;*******************************  misc. equates *****************************
;
PWSTATE_RESERVED_BITS	equ	11111100b	; only the least 2 bits are used

IDLE_SUPPORT_BYTE	EQU	01010101b	; JAH Idles support byte for PSP
CUR_PSP_OFFSET		EQU	330h

STACK_WORDS		EQU	128		; JAH2 Size of int 21 stack in words
IDLE_SUPP_FLG		EQU	00000001b	; JAH2 Int 2f idle support flag
EXT_PSP_SIG		EQU	2fh		; JAH2 Flags signature in PSP
;
WIN286STDMODE		equ	1	; NSM2 Bit 0 of dx in Win386 startup
					; int 2f broadcast call
;
MINI16COUNT		equ	25	; no of i16s happened in 1 tick
;
; savings mode equates
PW_ADV_MAX	equ	7
PW_ADV_REG	equ	6
PW_ADV_MIN	equ	4

MAXSAVINGSMODE	equ	PW_ADV_MAX
REGSAVINGSMODE	equ	PW_ADV_REG

MAX_SAVINGS_VALUE	equ	8	; only 8 levels of savings allowed

; M106 -  use 16 samples to find an avg while adapting
MAX_SAMPLES_PER_AVG	equ	16
;
;****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\romrd.asm ===
page	,132
	title	RomDrive physical ROM access routine

;	This is an extended-memory capable version which uses the
;	  ROM BIOS's Int15(ah=87h) block move function.
;	Note:  This module assumes low 16Meg mapping (286 space only)

;
;----------------------------------------------------------------------------
;
; M071 : Made ROMDRIVEBASE_LO equated to 0000 instead of 00 for more
;	 readability
;
;----------------------------------------------------------------------------
;
;ROMCODE	SEGMENT	byte public
;	assume	cs:ROMCODE
	.xlist
	include	biosseg.inc
	include	msgroup.inc
	.list
	assume	cs:bios_data

IFNDEF	FAKEROM

ROMDRIVEBASE_LO	equ	0000h			; M071
ROMDRIVEBASE_HI	equ	0b0h

ELSE

ROMDRIVEBASE_LO	equ	0
ROMDRIVEBASE_HI	equ	0

ENDIF ; FAKEROM

	public	xfer_from_rom

;	Entry:
;	       dx:bx  - 32 bit ROM offset of transfer block
;	       es:di  - real mode address where it should go
;	       cx     - count in bytes, guaranteed to have at least 2 zero lsbs
;		         note:  transfer length == 00 means 64K
;

;	EXIT:
;	    If error detected
;		Carry Set
;		   al == error code 8 (sector not found)

gdts	dw	0,0,0,0		; gdt 0 == dummy
	dw	0,0,0,0		; gdt 1 == GDT seg (Int15 fills in)

	dw	0ffffh		; gdt 2 limit = 65535
src_low	dw	0		; gdt 2 low 16 bits
src_hi	db	0
	db	93h,0,0		; gdt 2 access rights & reserved

	dw	0ffffh		; gdt 3 limit = 65535
dst_low	dw	0		; gdt 3 low 16 bits
dst_hi	db	0
	db	93h,0,0		; gdt 3 access rights & reserved

	dw	0,0,0,0		; gdt 4 == ROM BIOS CODE (Int15 fills in)
	dw	0,0,0,0		; gdt 5 == stack (Int15 fills in)

rombase_low	dw	ROMDRIVEBASE_LO	; point to full ROM address
rombase_high	dw	ROMDRIVEBASE_HI	; as linear address

xfer_from_rom:
	add	bx,rombase_low	; add in ROM base linear address
	adc	dx,rombase_high

IFDEF	FAKEROM

;	****  For debug purposes, we'll also add in the offset to
;		the phony ROM image we load as part of us.  When
;		physical ROM hardware becomes available, the following
;		can be deleted.

	add	bx,offset rom_image
	adc	dx,0
	mov	ax,cs
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1
	push	ax
	and	ax,0fff0h
	add	ax,bx
	mov	src_low,ax		; save low 16 bits of source
	pop	ax
	adc	al,dl
	and	al,0fh		; limit to low meg for simulation
	mov	src_hi,al

;	*this is the end of the debug simulation code*

ELSE
	mov	src_low, bx
	mov	src_hi, dl

ENDIF ; FAKEROM

;	Now calculate and store the destination address

	mov	ax,es
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1
	push	ax
	and	ax,0fff0h
	add	ax,di
	mov	dst_low,ax
	pop	ax
	adc	al,0
	and	al,0fh
	mov	dst_hi,al

	push	es
	push	si
	mov	si,offset gdts
	push	cs
	pop	es
	shr	cx,1			; convert count to words
	jnz	not_64k
	or	ch,80h			; force 64k to be 32K words, not zero
not_64k:
	mov	ah,87h
	int	15h
	pop	si
	pop	es
	mov	al,0
	jnc	no_disk_error
	mov	al,8			; all errors are type 8
no_disk_error:
	ret

IFDEF	FAKEROM
rom_image:
	include	rom8k.inc
ENDIF ; FAKEROM

bios_data	ENDS
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\romdinit.asm ===
page	,132
	title	RomDrive initialization module (disposable)

	.xlist
	include version.inc	; <jrcb>
	include	biosseg.inc
	include	msgroup.inc
	.list
	assume	cs:datagrp


; INIT PACKET OFFSETS
INIT_NUM	EQU	BYTE PTR (13) + 0
INIT_BREAK	EQU	DWORD PTR (13) + 1
INIT_BPB	EQU	DWORD PTR (13) + 5
INIT_DOSDEV	EQU	BYTE PTR (13) + 9

	public	ROM$INIT

	extrn	DEVEXIT:near
	extrn	RDRIVEBPB:byte
	extrn	bpb_rd_length:abs
	extrn	ptrsavx:dword
	extrn	rombase:dword

	extrn	xfer_from_rom:near

;	Note:  This module is not disposed of when this is BIOS
;	  resident, because it is too late to dispose of code by
;	  the time DOS calls back to the INIT entry.  It doesn't
;	  matter much, though, because when ROMDRVALONE is false,
;	  this module isn't very big.

;	externals in message module

	ifdef	romdrvalone
	extrn	headermes:byte
	extrn	badvermes:byte
	extrn	dos_drv:byte
	endif

INITAB	DW	RDRIVEBPB

;**	ROM$INIT - Device Driver Initialization routine
;
;	ROMDRIVE Initialization routine. This is the COMMON initialization
;	code used by ALL driver TYPEs. Its jobs are to:
;
;	    1.  Access the BPB on the ROM drive and set parameters
;	           appropriately.
;	    2.  Print out report of ROMDrive install (on standalone vers)
;	    3.	Set the return INIT I/O packet values
;
;	If at any time during the above steps an error may be detected. When
;	this happens one of the error messages is printed and ROMDrive
;	"de-installs" itself by returning a unit count of 0 in the INIT
;	device I/O packet. The DOS device installation code is responsible
;	for taking care of the details of re-claiming the memory used by the
;	device driver.
;
;	Step 3 sets the INIT I/O packet return values for # of units,
;	Break address, and BPB array pointer and returns via DEVEXIT.
;
;	ENTRY from ROM$IN
;	EXIT Through DEVEXIT
;	USES ALL
;

ROM$INIT:
	cld

;	Standalone version is tightly DOS 5.0 version bound.

	ifdef	ROMDRVALONE
	mov	ah,30h			; get version
	int	21h
	xchg	ah,al
	cmp	ax,500h			; version 5.00 or higher?
	jae	ver_ok			; 5.x or higher are okay

	mov	dx,offset badvermes
	push	cs
	pop	ds
	mov	ah,9			; use DOS function 9 to display string
	int	21h

error_initializing:
	xor	al,al			; indicate no devices
	jmp	short init_done		; and return

ver_ok:

;	display message including drive letter

	LDS	SI,[ptrsavx]
	MOV	AL,[SI.INIT_DOSDEV] ; DOS drive letter
	ADD	CS:[DOS_DRV],AL     ; Need explicit over, this is a forward ref
	mov	dx,offset headermes
	push	cs
	pop	ds
	mov	ah,9
	int	21h		; display message
	endif

;	Now let's try to get the DPB from that device

	push	cs
	pop	es
	mov	di,offset rdrivebpb
	mov	bx,0bh			; this is where the dpb lives
	xor	dx,dx			; high 16 bits of address
	mov	cx,bpb_rd_length
	call	xfer_from_rom

	ifdef	romdrvalone
	jc	error_initializing
	endif

	mov	al,1			; one drive, please!

;**	init_done - Set INIT packet I/O return values
;
;	This entry is used in ERROR situations to return
;	a unit count of 0 by jumping here with AL = 0.
;	The successful code path falls through to here
;	with AL = 1
;
;	ENTRY
;	    AL = INIT packet unit count
;	EXIT
;	    through DEVEXIT
;	USES
;	    DS, BX, CX
;

;	set the return INIT I/o packet values

init_done:
	LDS	BX,[ptrsavx]
	MOV	[BX.INIT_NUM],AL

	ifdef	romdrvalone
	MOV	WORD PTR [BX.INIT_BREAK],offset initab   ;SET BREAK ADDRESS
	MOV	WORD PTR [BX.INIT_BREAK + 2],CS
	endif
	MOV	WORD PTR [BX.INIT_BPB],OFFSET INITAB	   ;SET POINTER TO BPB ARRAY
	MOV	WORD PTR [BX.INIT_BPB + 2],CS
	JMP	DEVEXIT
;

bios_data ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\romdrive.asm ===
page	,132
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	TITLE	ROMDRIVE

break	macro	arg
	subttl	arg		; bogus macro for include files
	endm

;	adapted from RAMDRIVE.SYS from MS-DOS 5.0


.xlist
	include devsym.inc
	include	biosseg.inc
.list

	include	msgroup.inc
SUBTTL	<I/O Packet offset declarations>

;
; Define I/O packet offsets for useful values.
;
; SEE ALSO
;	MS-DOS Technical Reference manual section on Installable Device Drivers
;

; READ/WRITE PACKET OFFSETS
RW_COUNT	EQU	WORD PTR (SIZE SRHEAD) + 5
RW_TRANS	EQU	DWORD PTR (SIZE SRHEAD) + 1
RW_START	EQU	WORD PTR (SIZE SRHEAD) + 7

; MEDIA CHECK PACKET OFFSETS
MCH_RETVAL	EQU	BYTE PTR (SIZE SRHEAD) + 1
MCH_MEDIA	EQU	BYTE PTR (SIZE SRHEAD) + 0

; BUILD BPB PACKET OFFSETS
BPB_BUFFER	EQU	DWORD PTR (SIZE SRHEAD) + 1
BPB_MEDIA	EQU	BYTE PTR (SIZE SRHEAD) + 0
BPB_BPB 	EQU	DWORD PTR (SIZE SRHEAD) + 5



SUBTTL	<Device header>


ASSUME	CS:bios_data,DS:NOTHING,ES:NOTHING,SS:NOTHING

	public	ptrsavx
	public	devexit
	public	rombase
	public	ssize,seclim,rdrivebpb
	public	bpb_rd_length
	extrn	xfer_from_rom:near
	extrn	ROM$INIT:near

	public	rdrive
rdrive:
ROMDEV	LABEL	WORD
	DW	-1,-1
DEVATS	DW	DEVOPCL
	DW	STRATEGY
	DW	ROM$IN
	DB	1			;1 ROMDRIVE


SUBTTL	<Command dispatch table>

;**
;
; This is the device driver command dispatch table.
;
;

ROMTBL	LABEL	WORD
	DB	15			; Max allowed command code
	DW	ROM$INIT
	DW	MEDIA$CHK
	DW	GET$BPB
	DW	CMDERR
	DW	ROM$READ
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	ROM$WRT	; writing not supported, read only
	DW	ROM$WRT	; writing not supported, read only
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	DEVEXIT
	DW	ROM$REM


RDRIVEBPB:
SSIZE	DW	512		; Physical sector size in bytes
CSIZE	DB	0		; Sectors/allocation unit
RESSEC	DW	1		; Reserved sectors for DOS
FATNUM	DB	1		; No. allocation tables
DIRNUM	DW	64		; Number directory entries
SECLIM	DW	0		; Number sectors
	DB	0F8H		; Media descriptor
FATSEC	DW	1		; Number of FAT sectors
	DW	1		; Number of sectors per track
	DW	1		; Number of heads
	DW	0		; Number of hidden sectors

;	now allocate enough extra bytes so that we can guarantee that
;	  the amount we read is always divisible by 4.  This allows
;	  actual ROM interface modules to utilize DWORD moves without
;	  a bunch of extra effort.

	db	((offset rdrivebpb - offset $) and 3) dup (0)

bpb_rd_length = (offset $) - (offset rdrivebpb)


SUBTTL	<Common Device code>

rombase		dd	0

;	ROMDRIVE DEVICE ENTRY POINTS - STRATEGY, ROM$IN

ptrsavx		DD	0		; Storage location for packet addr

;**	STRATEGY - Device strategy routine
;

STRATP	PROC	FAR

STRATEGY:
	MOV	WORD PTR [ptrsavx],BX	; Save packet addr
	MOV	WORD PTR [ptrsavx+2],ES
	RET

STRATP	ENDP

;**	ROM$IN - Device interrupt routine
;
;	ENTRY	ptrsavx has packet address saved by previous STRATEGY call.
;	EXIT	Dispatch to appropriate function handler
;			CX = Packet RW_COUNT
;			DX = Packet RW_START
;			ES:DI = Packet RW_TRANS
;			DS = bios_data
;			STACK has saved values of all regs but FLAGS
;		    All function handlers must return through one of
;			the standard exit points
;	USES	FLAGS
;

ROM$IN:
	PUSH	SI
	PUSH	AX
	PUSH	CX
	PUSH	DX
	PUSH	DI
	PUSH	BP
	PUSH	DS
	PUSH	ES
	PUSH	BX

	LDS	BX,[ptrsavx]	       ;GET POINTER TO I/O PACKET
    ;
    ; Set up registers for READ or WRITE since this is the most common case
    ;
	MOV	CX,DS:[BX.RW_COUNT]	;CX = COUNT
	MOV	DX,DS:[BX.RW_START]	;DX = START SECTOR
	MOV	AL,DS:[BX.REQFUNC]	; Command code
	MOV	AH,BYTE PTR [ROMTBL]	; Valid range
	CMP	AL,AH
	JA	CMDERR			; Out of range command code
	CBW				; Make command code a word
	mov	si,ax			; get to indexable register
	add	si,si
	les	di,ds:[bx.RW_TRANS]	; es:di -> transfer address
	jmp	cs:word ptr ROMTBL+1[si] ; jump to routine


;**	EXIT - ALL ROUTINES RETURN THROUGH ONE OF THESE PATHS
;
;	Exit code entry points:
;
;


ROM$WRT:
	mov	al,0			; write protect error
	jmp	short err$exit
CMDERR:
	MOV	AL,3			;UNKNOWN COMMAND ERROR
	JMP	SHORT ERR$EXIT

ERR$CNT:
	LDS	BX,[ptrsavx]
	MOV	[BX.RW_COUNT],0 	; NO sectors transferred
ERR$EXIT:				; Error in AL
	MOV	AH,(STERR + STDON) SHR 8  ;MARK ERROR RETURN
	JMP	SHORT ERR1

EXITP	PROC	FAR

DEVEXIT:
	MOV    AH,STDON SHR 8
ERR1:
	LDS	BX,[ptrsavx]
	MOV	[BX.REQSTAT],AX 	; Set return status

	POP	BX
	POP	ES
	POP	DS
	POP	BP
	POP	DI
	POP	DX
	POP	CX
	POP	AX
	POP	SI
	RET				;RESTORE REGS AND RETURN
EXITP	ENDP


;**	MEDIA$CHK - Device Driver Media check routine
;
;	ROMDRIVE Media check routine. ALWAYS returns media not changed
;
;	ENTRY from ROM$IN
;	EXIT through DEVEXIT
;	USES DS,BX
;

MEDIA$CHK:
	LDS	BX,[ptrsavx]
	MOV	[BX.MCH_RETVAL],1	; ALWAYS NOT CHANGED
	JMP	DEVEXIT

;**	GET$BPB - Device Driver Build BPB routine
;
;	ROMDRIVE Build BPB routine. Returns pointer to BPB at RDRIVEBPB
;
;	EXIT through DEVEXIT
;	USES DS,BX

GET$BPB:
	LDS	BX,[ptrsavx]
	MOV	WORD PTR [BX.BPB_BPB],OFFSET RDRIVEBPB
	MOV	WORD PTR [BX.BPB_BPB + 2],CS
	JMP	DEVEXIT

;**	ROM$REM - Device Driver Removable Media routine
;
;	ROMDRIVE Removable Media routine. ALWAYS returns media not removable
;	NOTE: This routine is never called if running on DOS 2.X
;
;	ENTRY from ROM$IN
;	EXIT through ERR1
;	USES AX
;

ROM$REM:
	MOV	AX,STBUI + STDON	; Media NOT removable
	JMP	ERR1

;**	ROM$READ - Device Driver READ routine
;
;	ROMDRIVE READ routine. Perform device READ.
;
;		ES:DI is transfer address
;		CX is sector transfer count
;		DX is start sector number
;	EXIT through DEVEXIT or ERR$CNT
;	USES ALL
;

ROM$READ:
	jcxz	devexit		; zero sectors, read okay.

	xchg	ax,dx		; get start sector
	mul	ssize		;  now dx:ax is the start of block
	push	dx		; save dx for now
	mov	bx,ax		; get low 16 bits into correct register
	mov	ax,cx		; get sector count
	mul	ssize		; get byte count
	or	dx,dx		; if overflow, use 64k
	jz	romread1

	xor	ax,ax		; 0 means 64K

romread1:
	mov	cx,ax		; pass count in cx
	pop	dx		; dx:bx is sector address
	call	xfer_from_rom	; es:di is DMA address
	jnc	devexit
	JMP	ERR$CNT


bios_data ENDS
	END

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\sysimes.asm ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	page	,160

MULTI_CONFIG equ 1

	include	version.inc	; set build flags
	include biosseg.inc	; establish bios segment structure

sysinitseg segment

	public	baddblspace
	public	badopm,crlfm,badsiz_pre,badld_pre,badcom,badcountry
	public	badmem,badblock,badstack
	public	insufmemory,badcountrycom
	public	badorder,errorcmd
	public	badparm
ifdef   MULTI_CONFIG
        public  OnOff,StartMsg,$PauseMsg,$CleanMsg,$InterMsg
        public  $MenuHeader,$MenuPrmpt,$StatusLine,$InterPrmpt,$YES,$NO,$TimeOut
        public  BadComPrmpt,$AutoPrmpt
endif
        public  toomanydrivesmsg

	include msbio.cl3

sysinitseg	ends
	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\sysconf.asm ===
page	,160
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	title	bios system initialization
;
;----------------------------------------------------------------------------
;
; M002 : Change for leaving the UMBs in an unlinked state
;
; M003 : Fixed a parse in the DOS= command
;
; M004 : Fixed bug #2005. The file name copied into the device driver arena
;        contained the full pathname. modified it to copy only the file nmae
;        part
;
; M005 : Fixed a bug in the umb insert code. The prev arena ptr was not
;        being updated when traversing the arena chain.
;
;
; M007 : DeviceHi flag was not reset after a DEVICEHIGH. Which forced all
;        subsequent devices in config.sys to be loaded in UMB
;
; M009 : Case of multiple device drivers in a single file where the last
;        device driver fails was not being handled properly.
;
; M016 : Enabling the /X optionin buffers, so that DOS 5.0 does not crib
;	 about /X in old config.sys files. /X is totally ignored now.
;
; M017 : Ignoring the keep count in FCBS= command
;
; M020 : The PDB_Block_Len field is updated to alloclim before
;	 each device driver call. This fix is put specifically for loading
;	 periscope using sysload.sys
;
; M023 : Increased country='s buffer from 2K to 6K
;
; M027 : We will pass the memory limit of a device driver in the break addr
;	 field only for the 1st device driver in a file.
;
; M045 : Backing out OS/2 device driver check
;
; M049 : initialize device header of block device with unit count
;
; M050 : Changed parse limit of buffers from 10000 to 99
;
; M059 : Bug #5002. Treat rollover byte as a count instead of a flag, if
;			t_switch is not set.
;
; M063 : Bug #4984. Added SWITCHES=/W for suppressing mandatory loading of
;		WINA20.386
;
;----------------------------------------------------------------------------
;
;==============================================================================

MULTI_CONFIG equ 1

	.xlist
	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure
	include	magicdrv.inc		; get MagicDrv equates
	.list

lf	equ	10
cr	equ	13
tab	equ	 9

HIGH_FIRST            equ     080h      ; from ARENA.INC - modifier for
                                        ; allocation strategy call

have_install_cmd      equ     00000001b ; config.sys has install= commands
has_installed	      equ     00000010b ; sysinit_base installed.

default_filenum = 8

	break	macro	; dummy empty macro
	endm

	.xlist
	include sysvar.inc
	include dpb.inc
	include	pdb.inc			; M020
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include devmark.inc
        include config.inc

	include	umb.inc
	.xlist			; *** umb.inc re-enables listing!
	include	dossym.inc
	.list

stacksw equ	true		;include switchable hardware stacks

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif




; external variable defined in ibmbio module for multi-track

multrk_on	equ	10000000b	;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.

Bios_Data segment 
	extrn	multrk_flag:word
	extrn	keyrd_func:byte
	extrn	keysts_func:byte
	extrn	t_switch:byte		; M059
Bios_Data ends

; end of multi-track definition.

sysinitseg	segment 

IFDEF	CONFIGPROC
assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

	extrn	area:word

	ifdef	dblspace_hooks
	extrn	MagicBackdoor:dword
	endif

	extrn	badopm:byte,crlfm:byte,badcom:byte,badmem:byte,badblock:byte
	extrn	badsiz_pre:byte,badld_pre:byte
	extrn	badstack:byte,badcountrycom:byte
        extrn   badcountry:byte,insufmemory:byte
	extrn	condev:byte,auxdev:byte,prndev:byte,commnd:byte,config:byte
	extrn	cntry_drv:byte,cntry_root:byte,cntry_path:byte
	extrn	deviceparameters:byte
	extrn	memory_size:word
	extrn	buffers:word
	extrn	files:byte,num_cds:byte
	extrn	dosinfo:dword
	extrn	fcbs:byte,keep:byte
	extrn	confbot:word,alloclim:word,command_line:byte
	extrn	zero:byte,sepchr:byte
	extrn	count:word,chrptr:word,cntryfilehandle:word
	extrn	memlo:word,memhi:word,prmblk:word,ldoff:word
	extrn	packet:byte,unitcount:byte,break_addr:dword
	extrn	bpb_addr:dword,drivenumber:byte,sysi_country:dword
	extrn	devdrivenum:byte
	extrn	config_size:word
	extrn	install_flag:word
	extrn	badorder:byte
        extrn   errorcmd:byte
	extrn	linecount:word
	extrn	showcount:byte
	extrn	buffer_linenum:word
	extrn	h_buffers:word
	extrn	badparm:byte
	extrn	configmsgflag:word
	extrn	org_count:word
	extrn	multi_pass_id:byte

	extrn	mem_err:near,setdoscountryinfo:near
	extrn	pararound:near,tempcds:near
	extrn	set_country_path:near,move_asciiz:near,delim:near
	extrn	badfil:near,round:near
	extrn	do_install_exec:near
	extrn	setdevmark:near

	extrn	print:near,organize:near,newline:near
	extrn	diddleback:near,parseline:near,setparms:near
	extrn	badload:near,calldev:near,prnerr:near

	extrn	runhigh:byte
	extrn	IsXMSLoaded:near

ifndef ROMDOS
	extrn	TryToMovDOSHi:near
endif

ifdef	COPYCDS
	extrn	newnum_cdss:word
endif ; COPYCDS

ifdef DBCS
	extrn	testkanj:near
endif

	if	stacksw

; internal stack parameters

entrysize	equ	8

mincount	equ	8
defaultcount	equ	9
maxcount	equ	64

minsize 	equ	32
defaultsize	equ	128
maxsize 	equ	512

DOS_FLAG_OFFSET	equ	86h

	extrn  stack_count:word
	extrn  stack_size:word
	extrn  stack_addr:dword

	endif

	public doconf
	public getchr
	public multi_pass

;	the syspre module needs hooks back into us, for routines and
;	variables.  Here they are made public.

	public	DevBrkAddr,DevCmdLine,DevSizeOption
	public	ExecDev,InitDevLoad,DevSetBreak
	public	DevLoadAddr,DevBreak,DevSize
	public	ConvLoad,RoundBreakAddr
	public	DeviceHi,SizeDevice,DevLoadEnd



ifdef   MULTI_CONFIG
;
;   config_envlen must immediately precede config_wrkseg, because they
;   may be loaded as a dword ptr
;
        public  config_envlen           ; when config_wrkseg is being used as
config_envlen   dw  0                   ; a scratch env, this is its length

        public  config_wrkseg           ; config work area (above confbot)
config_wrkseg   dw  0                   ; segment of work area

        public  config_cmd              ; current config cmd
config_cmd      db  0                   ; (with CONFIG_OPTION_QUERY bit intact)

        public  config_multi            ;
config_multi    db  0                   ; non-zero if multi-config config.sys

        extrn   newcmd:byte
        extrn   set_numlock:near
        extrn   query_user:near
        extrn   copy_envvar:near

endif  ;MULTI_CONFIG


	public	multdeviceflag
multdeviceflag	db	0
ENDIF ; CONFIGPROC

	public	devmark_addr
devmark_addr	dw	?		;segment address for devmark.
	public	setdevmarkflag
setdevmarkflag	    db	    0		;flag used for devmark

driver_units	db	0		;total unitcount for driver

IFDEF	CONFIGPROC

ems_stub_installed  db	    0

IFDEF	DONT_LOAD_OS2_DD		; M045

Os2ChkBuf	DD	0		; Tmp read buffer

ENDIF					; M045

badparm_ptr	label	dword
badparm_off	dw	0
badparm_seg	dw	0

;******************************************************************************
;take care of config.sys file.
;system parser data and code.
;******************************************************************************

;*******************************************************************
; parser options set for msbio sysconf module
;*******************************************************************
;
;**** default assemble swiches definition **************************

	ifndef	farsw
farsw	equ	0	; near call expected
	endif

	ifndef	datesw
datesw	equ	0	; check date format
	endif

	ifndef	timesw
timesw	equ	0	; check time format
	endif

	ifndef	filesw
filesw	equ	1	; check file specification
	endif

	ifndef	capsw
capsw	equ	0	; perform caps if specified
	endif

	ifndef	cmpxsw
cmpxsw	equ	0	; check complex list
	endif

	ifndef	numsw
numsw	equ	1	; check numeric value
	endif

	ifndef	keysw
keysw	equ	0	; support keywords
	endif

	ifndef	swsw
swsw	equ	1	; support switches
	endif

	ifndef	val1sw
val1sw	equ	1	; support value definition 1
	endif

	ifndef	val2sw
val2sw	equ	0	; support value definition 2
	endif

	ifndef	val3sw
val3sw	equ	1	; support value definition 3
	endif

	ifndef	drvsw
drvsw	equ	1	; support drive only format
	endif

	ifndef	qussw
qussw	equ	0	; support quoted string format
	endif


	.xlist
	include parse.asm		;together with psdata.inc
	.list


;control block definitions for parser.
;---------------------------------------------------
; buffer = [n | n,m] {/e}

p_parms struc
	dw	?
	db	1		; an extra delimiter list
	db	1		; length is 1
	db	';'		; delimiter
p_parms ends

p_pos	struc
	dw	?		; numeric value??
	dw	?		; function
	dw	?		; result value buffer

; note: by defining result_val before this structure, we could remove
;  the "result_val" from every structure invocation

	dw	?		; value list
	db	0		; no switches/keywords
p_pos	ends

p_range struc
	db	1		; range definition
	db	1		; 1 definition of range
	db	1		; item tag for this range
	dd	?		; numeric min
	dd	?		; numeric max
p_range ends

buf_parms p_parms <buf_parmsx>
buf_parmsx dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
	   db	1			; one switch
	   dw	sw_x_ctrl
	   db	0			; no keywords

buf_pos1    p_pos   <8000h,0,result_val,buf_range_1> ; numeric
buf_range_1 p_range <,,,1,99>			     ; M050
buf_pos2    p_pos   <8001h,0,result_val,buf_range_2> ; optional num.
buf_range_2 p_range <,,,0,8>

sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
switch_x  db	'/X',0			; M016

p_buffers	dw	0	; local variables
p_h_buffers	dw	0
p_buffer_slash_x db	0

;common definitions ------------
noval	db	0

result_val	label	byte
	db	?		; type returned
	db	?		; item tag returned
	dw	?		; es:offset of the switch defined
rv_byte 	label	byte
rv_dword dd	?		; value if number,or seg:offset to string.
;-------------------------------

; break = [ on | off ]

brk_parms	p_parms  <brk_parmsx>

brk_parmsx dw	101h,brk_pos	; min,max = 1 positional
	   db	0		; no switches
	   db	0		; no keywords

brk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

on_off_string	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	2		; 2 strings for choice
	db	1		; the 1st string tag
	dw	on_string
	db	2		; the 2nd string tag
	dw	off_string

on_string	db	"ON",0
off_string	db	"OFF",0

p_ctrl_break	db	0	; local variable

;--------------------------------

; country = n {m {path}}
; or
; country = n,,path

cntry_parms	p_parms <cntry_parmsx>

cntry_parmsx dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
	     db	0		; no switches
	     db	0		; no keywords

cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
cc_range p_range <,,,1,999>
cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec

p_cntry_code	dw	0	; local variable
p_code_page	dw	0	; local variable

;--------------------------------

; files = n

files_parms	p_parms <files_parmsx>

files_parmsx dw	101h,files_pos	; min,max 1 positional
	     db	0		; no switches
	     db	0		; no keywords

files_pos   p_pos   <8000h,0,result_val,files_range,0> ; numeric value
files_range p_range <,,,8,255>

p_files db	0		; local variable

;-------------------------------

; fcbs = n,m

fcbs_parms	p_parms <fcbs_parmsx>

fcbs_parmsx dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
	    db	0		; no switches
	    db	0		; no keywords

fcbs_pos_1	p_pos	<8000h,0,result_val,fcbs_range> ; numeric value
fcbs_range	p_range	<,,,1,255>
fcbs_pos_2	p_pos	<8000h,0,result_val,fcbs_keep_range> ; numeric value
fcbs_keep_range p_range <,,,0,255>

p_fcbs	db	0		; local variable
p_keep	db	0		; local variable

;-------------------------------
; lastdrive = x

ldrv_parms	p_parms <ldrv_parmsx>

ldrv_parmsx dw	101h,ldrv_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
					    ; remove colon at end
p_ldrv	db	0		; local variable

;-------------------------------

; stacks = n,m

stks_parms	p_parms <stks_parmsx>

stks_parmsx dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
	    db	0		; no switches
	    db	0		; no keywords

stks_pos_1     p_pos   <8000h,0,result_val,stks_range> ; numeric value
stks_range     p_range <,,,0,64>
stks_pos_2     p_pos   <8000h,0,result_val,stk_size_range> ; numeric value
stk_size_range p_range <,,,0,512>

p_stack_count	dw	0	; local variable
p_stack_size	dw	0	; local variable

;-------------------------------

; multitrack = [ on | off ]

mtrk_parms	p_parms <mtrk_parmsx>

mtrk_parmsx dw	101h,mtrk_pos	; min,max = 1 positional
	    db	0		; no switches
	    db	0		; no keywords

mtrk_pos p_pos	<2000h,0,result_val,on_off_string> ; simple string

p_mtrk	db	0		; local variable

;-------------------------------
; switches=/k

swit_parms	p_parms <swit_parmsx>

swit_parmsx dw	0		; no positionals
            db  5               ; # of switches
	    dw	swit_k_ctrl	; /k control
            dw  swit_n_ctrl     ; /n control (for MULTI_CONFIG only)
            dw  swit_f_ctrl     ; /f control (for MULTI_CONFIG only)
            dw  swit_t_ctrl     ; /t control
            dw  swit_w_ctrl     ; /w control
	    db	0		; no keywords

        public  swit_n          ; used by MULTI_CONFIG in sysinit2.asm
        public  swit_f          ; used by MULTI_CONFIG in sysinit2.asm

swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_k db	'/K',0
swit_n_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_n db       '/N',0
swit_f_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_f db       '/F',0
swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
swit_t db	'/T',0			   ;				M059
swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
swit_w db	'/W',0			   ;				M063

;   There doesn't need to be p_swit_n or p_swit_f because /N and /F are
;   acted upon during MULTI_CONFIG processing;  we only needed entries
;   in the above table to prevent the parsing code from complaining about them

p_swit_k	db     0	; local variable
p_swit_t	db     0	; local variable			M059
p_swit_w	db     0	; local variable			M063

;-------------------------------

; DOS = [ high | low ]

dos_parms	p_parms  <dos_parmsx>

dos_parmsx db	1		; min parameters
	   db	2		; max parameters
	   dw	dos_pos		; 
	   dw	dos_pos		; 
	   db	0		; no switches
	   db	0		; no keywords

dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
        p_pos	<2000h,0,result_val,dos_strings> ; simple string

dos_strings	label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	4		; 4 strings for choice
	db	1		; the 1st string tag
	dw	hi_string
	db	2		; the 2nd string tag
	dw	lo_string
	db	3
	dw	umb_string
	db	4
	dw	noumb_string

hi_string	db	"HIGH",0
lo_string	db	"LOW",0
umb_string	db	"UMB",0
noumb_string	db	"NOUMB",0

p_dos_hi	db	0	; local variable
				; BUGBUG : I dont know whether PARSER uses
				;          this variable or not


;****************************************************************** RICHID ****

include	highvar.inc		; devicehigh variables (used by loadhigh also)

;****************************************************************** RICHID ****

		public	DevEntry

DevSize		dw	?	; size of the device driver being loaded(paras)
DevLoadAddr	dw	?	; Mem addr where the device driver is 2 b loaded
DevLoadEnd	dw	?	; MaxAddr to which device can be loaded
DevEntry	dd	?	; Entry point to the device driver
DevBrkAddr	dd	?	; Break address of the device driver
ConvLoad	db	?	; Use conventional (dos 5 -style) InitDevLoad?
;
DevUMB		db	0	; byte indicating whether to load DDs in UMBs
DevUMBAddr	dw	0	; cuurent UMB used fro loading devices (paras)
DevUMBSize	dw	0	; Size of the current UMB being used   (paras)
DevUMBFree	dw	0	; Start of free are in the current UMB (paras)
;
DevXMSAddr	dd	?
;
DevExecAddr	dw	?	; Device load address parameter to Exec call
DevExecReloc	dw	?	; Device load relocation factor
;
DeviceHi	db	0	; Flag indicating whther the current device
				;  is being loaded into UMB
DevSizeOption	dw	?	; SIZE= option
;
Int12Lied	db	0	; did we trap int 12 ?
OldInt12Mem	dw	?	; value in 40:13h (int 12 ram)
ThreeComName	db	'PROTMAN$'	; 3Com Device name
;
FirstUMBLinked	db	0
DevDOSData	dw	?	; segment of DOS Data
DevCmdLine	dd	?	; Current Command line
DevSavedDelim	db	?	; The delimiter which was replaced with null
				; to use the file name in the command line
;
	ifdef	dblspace_hooks
MagicHomeFlag	db	0	; set non-zero when MagicDrv is final placed
	endif

;----------------------------------------------------------------------------
;
; procedure : doconf
;
;             Config file is parsed intitially with this routine. For the
;             Subsequent passes 'multi_pass' entry is used .
;
;----------------------------------------------------------------------------
;
doconf	proc	near
	push	cs
	pop	ds
	assume	ds:sysinitseg

        mov     ax,(char_oper shl 8)    ; get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

ifdef   MULTI_CONFIG
        mov     [command_line-1],dl     ; save default switchchar
endif  ;MULTI_CONFIG

	mov	dx,offset config	;now pointing to file description
	mov	ax,open shl 8		;open file "config.sys"
	stc				;in case of int 24
	int	21h			;function request
	jnc	noprob			; brif opened okay

ifdef   MULTI_CONFIG
        extrn   kbd_read:near           ; we still want to give the guy
        call    kbd_read                ; a chance to select clean boot!
endif                                   ; (ie, no autoexec.bat processing)

	mov	multi_pass_id,11	; set it to unreasonable number
	ret
noprob: 				;get file size (note < 64k!!)
	mov	bx,ax
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	int	21h
	mov	[count],ax

	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	int	21h

	mov	dx,[alloclim]		;use current alloclim value
	mov	ax,[count]
	mov	[config_size],ax	;save the size of config.sys file.
	call	pararound
	sub	dx,ax

ifdef   MULTI_CONFIG
;
;   The size of the CONFIG.SYS workspace (for recreating the in-memory
;   CONFIG.SYS image, and later for building the initial environment) need
;   not be any larger than CONFIG.SYS itself, EXCEPT for the fact that
;   we (may) add a variable to the environment that does not explicity appear
;   in CONFIG.SYS, and that variable is CONFIG (as in CONFIG=COMMON).
;   The default setting for CONFIG cannot result in more than 1 paragraph
;   of extra space, so here we account for it (the worst case of course is
;   when CONFIG.SYS is some very small size, like 0 -JTP)
;
        dec     dx                      ;reserve 1 additional paragraph
        mov     [config_wrkseg],dx      ;this is the segment to be used for
        sub     dx,ax                   ;rebuilding the config.sys memory image
endif  ;MULTI_CONFIG

	sub	dx,11h			;room for header
	mov	[alloclim],dx		; config starts here. new alloclim value.
	mov	[confbot],dx
	mov	ds,dx
	mov	es,dx

	assume	ds:nothing,es:nothing
	xor	dx,dx
	mov	cx,[count]
	mov	ah,read
	stc				;in case of int 24
	int	21h			;function request
	pushf

; find the eof mark in the file.  if present,then trim length.

	push	ax
	push	di
	push	cx
	mov	al,1ah			; eof mark
	mov	di,dx			; point ro buffer
	jcxz	puteol			; no chars
	repnz	scasb			; find end
	jnz	puteol			; none found and count exahusted

; we found a 1a.  back up

	dec	di			; backup past 1a

;  just for the halibut,stick in an extra eol

puteol:
	mov	al,cr
	stosb
	mov	al,lf
	stosb
	sub	di,dx			; difference moved
	mov	count,di		; new count

	pop	cx
	pop	di
	pop	ax

	push	cs
	pop	ds
	assume	ds:sysinitseg

	push	ax
	mov	ah,close
	int	21h
	pop	ax
	popf
	jc	conferr 		;if not we've got a problem
	cmp	cx,ax
	jz	getcom			;couldn't read the file

conferr:
	mov	dx,offset config	;want to print config error
	call	badfil
endconv:
	ret

;
;----------------------------------------------------------------------------
;
; entry : multi_pass
;
;             called to execute device=,install= commands
;
;----------------------------------------------------------------------------
;

multi_pass:
	push	cs
	pop	ds

	cmp	multi_pass_id,10
jae_endconv:
	jae	endconv 		; do nothing. just return.

	push	confbot
	pop	es			; es -> confbot

	mov	si,org_count
	mov	count,si		; set count
	xor	si,si
        mov     chrptr,si               ; reset chrptr
        mov     linecount,si            ; reset linecount

	call	getchr
	jmp	short conflp

getcom:
        call    organize                ; organize the file
	call	getchr

conflp: jc	endconv

        inc     linecount               ; increase linecount

	mov	multdeviceflag,0	; reset multdeviceflag.
	mov	setdevmarkflag,0	; reset setdevmarkflag.
	cmp	al,lf			; linefeed?
	je	blank_line		;  then ignore this line.

ifdef   MULTI_CONFIG
;
;   If this is a genuine CONFIG.SYS command, then there should be a line
;   number immediately following it....
;
        mov     [config_cmd],al         ; save original command code
        and     al,NOT CONFIG_OPTION_QUERY
        cmp     [config_multi],0        ; is this a multi-config config.sys?
        je      not_final               ; no, line number is not embedded

        push    ax                      ;
        call    getchr                  ; ignore end-of-image errors,
        mov     ah,al                   ; because if there's an error
        call    getchr                  ; fetching the line number that's
        xchg    al,ah                   ; supposed to be there, the next
        mov     [linecount],ax          ; getchr call will get the same error
        pop     ax
;
;   HACK: when 4DOS.COM is the shell and it doesn't have an environment from
;   which to obtain its original program name, it grovels through all of
;   memory to find the filename that was used to exec it;  it wants to find
;   the SHELL= line in the in-memory copy of CONFIG.SYS, and it knows that
;   sysinit converts the SHELL= keyword to an 'S', so it expects to find an 'S'
;   immediately before the filename, but since we are now storing line # info
;   in the config.sys memory image, 4DOS fails to find the 'S' in the right
;   spot.
;
;   So, on the final pass of CONFIG.SYS, copy the command code (eg, 'S')
;   over the line number info, since we no longer need that info anyway.  This
;   relies on the fact that getchr leaves ES:SI pointing to the last byte
;   retrieved.
;
        cmp     multi_pass_id,2         ; final pass?
        jb      not_final               ; no
        test    install_flag,have_install_cmd
        jz      final                   ; no install cmds, so yes it is
        cmp     multi_pass_id,3         ; final pass?
        jb      not_final               ; no
final:                                  ;
        mov     es:[si],al              ; save backward-compatible command code

not_final:                              ;
endif
	mov	ah,al
	call	getchr
	jnc	tryi

	cmp	multi_pass_id,2
        jae     jae_endconv             ; do not show badop again for multi_pass.
	jmp	badop

coff:	push	cs
	pop	ds
	call	newline
	jmp	conflp

blank_line:
	call	getchr
	jmp	conflp

coff_p:
	push	cs
	pop	ds


;to handle install= commands,we are going to use multi-pass.
;the first pass handles the other commands and only set install_flag when
;it finds any install command.	 the second pass will only handle the
;install= command.

;------------------------------------------------------------------------------
;install command
;------------------------------------------------------------------------------
tryi:
	cmp	multi_pass_id,0		; the initial pass for DOS=HI
	jne	not_init_pass
	jmp	multi_try_doshi
not_init_pass:

	cmp	multi_pass_id,2		; the second pass was for ifs=
        je      multi_pass_coff2        ; now it is NOPs
					; This pass can be made use of if
					; we want do some config.sys process
					; after device drivers are loaded
					; and before install= commands
					; are processed

	cmp	multi_pass_id,3		; the third pass for install= ?
	je	multi_try_i
        cmp     ah, CONFIG_DOS
        je      multi_pass_coff2

;       make note of any INSTALL= or INSTALLHIGH= commands we find,
;       but don't process them now.        
        
        cmp     ah,CONFIG_INSTALL               ; install= command?
	jne	precheck_installhigh		; the first pass is for normal operation.
	or	install_flag,have_install_cmd	; set the flag
multi_pass_coff2:
	jmp	coff				; and handles the next command

precheck_installhigh:
        cmp     ah,CONFIG_INSTALLHIGH   ; signifier for INSTALLHIGH
        jne     tryb                    ; carry on with normal processing
        or      install_flag,have_install_cmd
        jmp     coff

multi_try_i:
        cmp     ah, CONFIG_INSTALL      ; install= command?
        jne     multi_try_n             ; no, check for installhigh
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      multi_pass_filter       ; has the CONFIG_OPTION_QUERY bit set
endif
	call	do_install_exec 	;install it.
	jmp	coff			;to handle next install= command.

multi_try_n:
        cmp     ah,CONFIG_INSTALLHIGH   ; installhigh= command?
        jne	multi_pass_filter	; no. ignore this.
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      multi_pass_filter       ; has the CONFIG_OPTION_QUERY bit set
endif

;       The memory environment is in its normal DOS state, so do
;       the standard calls to set the alloc strategy for loading high

	mov	ax,(ALLOCOPER shl 8) OR 0
	int	21h			;get alloc strategy
	mov	bx,ax
        push    bx                      ; save for the return

        or	bx,HIGH_FIRST		;set alloc to HighFirst
	mov	ax,(ALLOCOPER shl 8) OR 1
	int	21h			;set alloc strategy

	mov     ax,(ALLOCOPER shl 8) OR 2 
        int     21h                     ; get link state
        xor     ah,ah                   ; clear top byte
        push    ax                      ; save for return

        mov	ax,(ALLOCOPER shl 8) OR 3
	mov	bx,1
	int	21h			;link in UMBs

	call	do_install_exec 	;install it.

        mov     ax,(ALLOCOPER shl 8) OR 3
        pop     bx                      ; recover original link state
        int     21h
        pop     bx                      ; recover original alloc strategy
        mov     ax,(ALLOCOPER shl 8) OR 1
        int     21h

	jmp	coff			;to handle next install= command.

multi_pass_filter:
        cmp     ah, CONFIG_COMMENT      ; comment?
	je	multi_pass_adjust
        cmp     ah, CONFIG_UNKNOWN      ; bad command?
	je	multi_pass_adjust
        cmp     ah, CONFIG_REM          ; rem?
	jne	multi_pass_coff 	; ignore the rest of the commands.

multi_pass_adjust:			; these commands need to
	dec	chrptr			;  adjust chrptr,count
	inc	count			;  for newline proc.

multi_pass_coff:
	jmp	coff			; to handle next install= commands.

;------------------------------------------------------------------------------
; buffer command
;------------------------------------------------------------------------------
;*******************************************************************************
;									      *
; function: parse the parameters of buffers= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	buffers set							      *
;	buffer_slash_x	flag set if /x option chosen.			      *
;	h_buffers set if secondary buffer cache specified.		      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to buf_parms;  /*parse control definition*/	      *
;	set dx,cx to 0; 						      *
;	reset buffer_slash_x;						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_synonym_ptr == slash_e) then /*not a switch  *
;		    buffer_slash_x = 1					      *
;	       else if	 (cx == 1) then 	    /* first positional */    *
;			  buffers = result_val.$p_picked_val;		      *
;		    else  h_buffers = result_val.$p_picked_val; 	      *
;	  else	{show error message;error exit} 			      *
;	};								      *
;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
; };									      *
;									      *
;*******************************************************************************

tryb:
        cmp     ah,CONFIG_BUFFERS
	jnz	tryc
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      tryc                    ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	p_buffer_slash_x,0
	mov	di,offset buf_parms
	xor	cx,cx
	mov	dx,cx

do7:
	call	sysinit_parse
	jnc	if7			; parse error,
	call	badparm_p		;   and show messages and end the search loop.
	jmp	short sr7

if7:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en7			;  then jmp to $endloop for semantic check
	cmp	result_val.$p_synonym_ptr,offset switch_x
	jnz	if11

;	mov	p_buffer_slash_x,1	; set the flag M016
	jmp	short en11

if11:
	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if13

	mov	p_buffers,ax
	jmp	short en11

if13:
	mov	p_h_buffers,ax
en11:
	jmp	do7

en7:
	cmp	p_buffers,99
	jbe	if18
;	cmp	p_buffer_slash_x,0	; M016
;	jnz	if18

	call	badparm_p
	mov	p_h_buffers,0
	jmp	short sr7

if18:
	mov	ax,p_buffers	; we don't have any problem.
	mov	buffers,ax	; now,let's set it really.

	mov	ax,p_h_buffers
	mov	h_buffers,ax

;	mov	al,p_buffer_slash_x	; M016
;	mov	buffer_slash_x,al

	mov	ax,linecount
	mov	buffer_linenum,ax ; save the line number for the future use.

sr7:
	jmp	coff

;------------------------------------------------------------------------------
; break command
;------------------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the parameters of break = command.			    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	turn the control-c check on or off.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di to brk_parms;						    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */ *
;		   set p_ctrl_break,on;					    *
;	       else					  /*off 	 */ *
;		   set p_ctrl_break,off;				    *
;	  else {show message;error_exit};				    *
;	};								    *
;	if (no error) then						    *
;	   dos function call to set ctrl_break check according to	    *
; };									    *
;									    *
;****************************************************************************

tryc:
        cmp     ah,CONFIG_BREAK
	jnz	trym
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      trym                    ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset brk_parms
	xor	cx,cx
	mov	dx,cx
do22:
	call	sysinit_parse
	jnc	if22			; parse error
	call	badparm_p		;  show message and end the serach loop.
	jmp	short sr22

if22:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en22			; then end the $endloop
	cmp	result_val.$p_item_tag,1
	jnz	if26

	mov	p_ctrl_break,1		; turn it on
	jmp	short en26

if26:
	mov	p_ctrl_break,0		; turn it off
en26:
	jmp	short do22		; we actually set the ctrl break

en22:
	mov	ah,set_ctrl_c_trapping ; if we don't have any parse error.
	mov	al,1
	mov	dl,p_ctrl_break
	int	21h
sr22:
	jmp	coff

;------------------------------------------------------------------------------
; multitrack command
;------------------------------------------------------------------------------
;******************************************************************************
;									      *
; function: parse the parameters of multitrack= command.		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	turn multrk_flag on or off.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di to brk_parms;						      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val.$p_item_tag == 1) then	  /*on		 */   *
;		   set p_mtrk,on;					      *
;	       else					  /*off 	 */   *
;		   set p_mtrk,off;					      *
;	  else {show message;error_exit};				      *
;	};								      *
;	if (no error) then						      *
;	   dos function call to set multrk_flag according to p_mtrk.	      *
;									      *
; };									      *
;									      *
;******************************************************************************

trym:
        cmp     ah,CONFIG_MULTITRACK
	jnz	tryu
ifdef   MULTI_CONFIG
        call    query_user      ; query the user if config_cmd
        jc      tryu            ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset mtrk_parms
	xor	cx,cx
	mov	dx,cx
do31:
	call	sysinit_parse
	jnc	if31		; parse error
	call	badparm_p	;  show message and end the serach loop.
	jmp	short sr31
if31:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en31		; then end the $endloop

	cmp	result_val.$p_item_tag,1
	jnz	if35

	mov	p_mtrk,1	; turn it on temporarily.
	jmp	short en35

if35:
	mov	p_mtrk,0	; turn it off temporarily.
en35:
	jmp	short do31	; we actually set the multrk_flag here

en31:
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	p_mtrk,0
	jnz	if39

	mov	multrk_flag,multrk_off2	; 0001h
	jmp	short en39

if39:
	mov	multrk_flag,multrk_on	; 8000h
en39:
	pop	ds
	assume	ds:sysinitseg
sr31:
	jmp	coff

;----------------------------------------------------------------------------
; DOS=HIGH/LOW command
;----------------------------------------------------------------------------
;

multi_try_doshi:
        cmp     ah,CONFIG_DOS
	je	it_is_h
skip_it:
	jmp	multi_pass_filter
it_is_h:				; M003 - removed initing DevUMB
					;	 & runhigh
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      skip_it                 ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset dos_parms
	xor	cx,cx
	mov	dx,cx
h_do_parse:
	call	sysinit_parse
	jnc	h_parse_ok		; parse error
h_badparm:
	call	badparm_p		;  show message and end the serach loop.
	jmp	short h_end

h_parse_ok:
	cmp	ax,$p_rc_eol		; end of line?
	jz	h_end			; then end the $endloop
	call	ProcDOS
	jmp	short h_do_parse
h_end:
	jmp	coff

;
;-----------------------------------------------------------------------------
; devicehigh command
;-----------------------------------------------------------------------------
;
	assume	ds:nothing
tryu:
        cmp     ah,CONFIG_DEVICEHIGH
	jne	tryd
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      tryd                    ; has the CONFIG_OPTION_QUERY bit set
endif
	call	InitVar
	call	ParseSize		; process the size= option
	jnc	@f

	mov	badparm_off, si		; stash it there in case of an error
	mov	badparm_seg, es
	call	badparm_p
	jmp	coff

@@:	mov	ax, DevSizeOption
	or	ax, ax
	jnz	@f

	call	ParseVar
	jnc	@f

	mov	badparm_off, si		; If ParseVar up there failed, then
	mov	badparm_seg, es		; ES:SI points to its problem area...
	call	badparm_p		; so all we have to do is choke and
	jmp	coff			; die, rather verbosely.

@@:	push	si
	push	es

@@:	mov	al, es:[si]
	cmp	al, cr
	je	@f
	cmp	al, lf
	je	@f
	call	delim
	jz	@f
	inc	si
	jmp	@b

@@:	mov	DevSavedDelim, al	; Save the delimiter before replacing
					;  it with null
	mov	byte ptr es:[si], 0
	pop	es
	pop	si

;------------------------------------------------------------------------------
; BEGIN PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
;------------------------------------------------------------------------------

	call	UmbTest			; See if UMBs are around...
	jnc	NrmTst			; ...yep.  So do that normal thang.

	mov	DeviceHi, 0		; ...nope... so load low.
	jmp short LoadDevice

;------------------------------------------------------------------------------
; END PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
;------------------------------------------------------------------------------

NrmTst:	mov	DeviceHi, 0
	cmp	DevUMB, 0		; do we support UMBs
	je	LoadDevice		; no, we don't
	mov	DeviceHi, 1
	jmp	short LoadDevice
;
;------------------------------------------------------------------------------
; device command
;------------------------------------------------------------------------------

	assume	ds:nothing
tryd:
        cmp     ah,CONFIG_DEVICE
	jz	gotd
skip_it2:
	jmp	tryq
gotd:
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      skip_it2                ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	DeviceHi, 0		; not to be loaded in UMB ;M007
	mov	DevSizeOption, 0
	mov	DevSavedDelim, ' '	; In case of DEVICE= the null has to
					;  be replaced with a ' '

LoadDevice:                             ; device= or devicehigh= command.
        push    cs
        pop     ds
        assume  ds:sysinitseg

	mov	word ptr [bpb_addr],si	; pass the command line to the dvice
	mov	word ptr [bpb_addr+2],es

	mov	word ptr DevCmdLine, si	; save it for ourself
	mov	word ptr DevCmdLine+2, es

	mov	[driver_units], 0	; clear total block units for driver

	call	round

	call	SizeDevice
	jc	BadFile

;
; - Begin DeviceHigh primary logic changes ------------------------------------
;

	mov	ConvLoad, 1		; Doesn't matter if DeviceHi==0

	mov	al, DeviceHi		; If not using upper memory,
	or	DeviceHi, 0		; Skip all this and go on to
	jz	DevConvLoad		; the actual load.

	call	GetLoadUMB		; Returns first UMB spec'ed in AX
	cmp	al, -1			; If umb0 not specified, it's old style
	jz	DevConvLoad		; so load high even if SIZE= is smaller

	dec	ConvLoad		; They specified /L, so use new loader

	call	GetLoadSize		; Returns size of first UMB specified
	or	ax, ax
	jz	@f			; If size1 not specified, nada to do:

	cmp	ax, DevSize		; /L:...,Size < DevSize?
	jge	DevConvLoad

; These two lines commented out, to correct Astro bug #973
;
;	mov	ax, 0			; Yep... so crank load UMB to conv mem
;	call	StoLoadUMB		;
;

@@:	mov	ax, DevSize		; Size < DevSize, so write DevSize as
	call	StoLoadSize		; minsize for load UMB.

;
; - End DeviceHigh primary logic changes --------------------------------------
;

DevConvLoad:
	call	InitDevLoad

	mov	ax, DevLoadAddr
	add	ax, DevSize
	jc	NoMem
	cmp	DevLoadEnd, ax
	jae	LoadDev

NoMem:
	jmp	mem_err

BadFile:
	call	RetFromUM		; Does nothing if didn't call HideUMBs

        cmp     byte ptr es:[si], ' '
        jae     @f
	jmp	badop
@@:
	call	badload
	jmp	coff

LoadDev:
	push	es
	pop	ds
	assume	ds:nothing
	mov	dx,si			;ds:dx points to file name

	if	noexec
	les	bx,dword ptr cs:[memlo]
	call	ldfil			;load in the device driver

	else

	call	ExecDev			; load device driver using exec call

	endif

badldreset:
	push	ds
	pop	es			;es:si back to config.sys
	push	cs
	pop	ds			;ds back to sysinit
	jc	BadFile
goodld:
	push	es
	push	si
	call	RemoveNull
	push	es
	push	si

	push	cs
	pop	es

	push	ds
	push	si

	lds	si, DevEntry			; peeks the header attribute
	test	word ptr ds:[si.sdevatt],devtyp ;block device driver?
	jnz	got_device_com_cont		;no.

	lds	si,dosinfo			; ds:si -> sys_var
	cmp	ds:[si.sysi_numio],26		; no more than 26 drive number
	jb	got_device_com_cont

	pop	si
	pop	ds

	pop	si				;clear the stack
	pop	es

	call	RetFromUM			; Do this before we leave

	jmp	badnumblock

got_device_com_cont:
	pop	si
	pop	ds

	call	LieInt12Mem
	call	UpdatePDB		; update the PSP:2 value M020

	cmp	cs:multdeviceflag, 0	; Pass limit only for the 1st device
					;  driver in the file ; M027
	jne	skip_pass_limit		;		      ; M027

	mov	word ptr break_addr, 0	; pass the limit to the DD
	mov	bx, DevLoadEnd
	mov	word ptr break_addr+2, bx
skip_pass_limit:

;	Note:  sysi_numio (in DOS DATA) currently reflects the REAL
;	number of installed devices (including DblSpace drives) where
;	"drivenumber" is the number that the next block device will
;	be assigned to.  Because some naughty device drivers (like
;	interlnk) look at the internal DOS variable instead of the
;	value we pass it, we'll temporarily stick our value into
;	DOS DATA while we're initializing the device drivers.
;
;	Note that this will make it impossible for this device
;	driver to access the DblSpace drive letters, whether
;	they are swapped-hosts or unswapped compressed drives,
;	during its initialization phase.

	push	ds
	lds	bx,dosinfo		; ds:bx -> sys_var

	mov	al,cs:drivenumber	; temporarily use this next drv value
	mov	cs:devdrivenum, al	; pass drive number in packet to driver
	mov	ah,al
	.errnz	sysi_ncds-sysi_numio-1	; handle adjacent bytes as a word
	xchg	ax,ds:word ptr [bx.sysi_numio]	; swap with existing values
	pop	ds

	push	ax			; save real sysi_numio/ncds in ax

	mov	bx,sdevstrat
	call	calldev 		;   calldev (sdevstrat);
	mov	bx,sdevint
	call	calldev 		;   calldev (sdevint);

	pop	ax			; get real sysi_numio value
	push	ds
	lds	bx,dosinfo		; ds:bx -> sys_var
	.errnz	sysi_ncds-sysi_numio-1	; handle adjacent bytes as a word
	mov	ds:word ptr [bx.sysi_numio],ax	; swap with existing values
	pop	ds

	call	TrueInt12Mem

	mov	ax, word ptr break_addr	; move break addr from the req packet
	mov	word ptr DevBrkAddr, ax
	mov	ax, word ptr break_addr+2
	mov	word ptr DevBrkAddr+2, ax

	assume	ds:nothing

	call	RetFromUM		; There we go... all done.

	cmp	DevUMB, 0
	jz	@f
	call	AllocUMB
@@:

ifndef ROMDOS
;
;------ If we are waiting to be moved into hma lets try it now !!!
;
	cmp	runhigh, 0ffh
	jne	@f

	call	TryToMovDOSHi		; move DOS into HMA if reqd
@@:
endif ; ROMDOS

	pop	si
	pop	ds
	mov	byte ptr [si],0 	;   *p = 0;

	push	cs
	pop	ds

	jmp	short was_device_com
;
;----------------------------------------------------------------------------
;
badnumblock:
	push	cs
	pop	ds
	mov	dx,offset badblock
	call	print

;
;------ fall thru -----------------------------------------------------------
;
erase_dev_do:				; modified to show message "error in config.sys..."
	pop	si
	pop	es

	push	cs
	pop	ds

;	test	[setdevmarkflag],setbrkdone	;if already set_break is done,
;	jnz	skip1_resetmemhi		; then do not
;	dec	[memhi] 			;adjust memhi by a paragrah of devmark.

skip1_resetmemhi:
	cmp	configmsgflag,0
	je	no_error_line_msg

	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
	mov	configmsgflag,0		;set the default value again.

no_error_line_msg:
	jmp	coff
;
;----------------------------------------------------------------------------
;
was_device_com:

	mov	ax,word ptr [DevBrkAddr+2]
	cmp	ax,DevLoadEnd
	jbe	breakok

	pop	si
	pop	es
	jmp	BadFile

breakok:
	lds	dx,DevEntry		;set ds:dx to header
	mov	si,dx
;
;M049	add	si,sdevatt		;ds:si points to attributes
;M049
;M049	ds:si -> hedaer
;
	les	di,cs:[dosinfo] 	;es:di point to dos info
;M049	mov	ax,ds:[si]		;get attributes
	mov	ax,ds:[si.sdevatt]	;M049: get attributes
	test	ax,devtyp		;test if block dev
	jz	isblock
;
;------ lets deal with character devices
;
	or	cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; go ahead and alloc mem for device
jc_edd:
	jc	erase_dev_do		;device driver's init routine failed.

	test	ax,iscin		;is it a console in?
	jz	tryclk

	mov	word ptr es:[di.sysi_con],dx
	mov	word ptr es:[di.sysi_con+2],ds

tryclk: test	ax,isclock		;is it a clock device?
	jz	golink

	mov	word ptr es:[di+sysi_clock],dx
	mov	word ptr es:[di+sysi_clock+2],ds
golink: jmp	linkit
;
;------ deal with block device drivers
;
isblock:
	mov	al,cs:[unitcount]	;if no units found,erase the device
	or	al,al
	jz	erase_dev_do
	mov	[si.sdevname],al	; M049: number of units in name field
	add	cs:[driver_units], al	; keep total for all drivers in file

perdrv:
	cbw				; warning no device > 127 units
	mov	cx,ax
	mov	dh,ah
	mov	dl,es:[di.sysi_numio]	;get number of devices
	mov	ah,dl
	add	ah,al			; check for too many devices
	cmp	ah,26			; 'A' - 'Z' is 26 devices
	jbe	ok_block
	jmp	badnumblock

ok_block:
	or	cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; alloc the device
	jc	jc_edd
	add	es:[di.sysi_numio],al	; update the amount

ifdef	COPYCDS
	xor	ah, ah
	mov	newnum_cdss, ax		; save number of new CDSs to be built
endif ; COPYCDS

	add	cs:drivenumber,al	; remember amount for next device
	lds	bx,cs:[bpb_addr]	; point to bpb array

perunit:
	les	bp,cs:[dosinfo]
	les	bp,dword ptr es:[bp.sysi_dpb]	;get first dpb

scandpb:cmp	word ptr es:[bp.dpb_next_dpb],-1
	jz	foundpb
	les	bp,es:[bp.dpb_next_dpb]
	jmp	scandpb
foundpb:
	mov	ax,word ptr cs:[DevBrkAddr]
	mov	word ptr es:[bp.dpb_next_dpb],ax
	mov	ax, word ptr cs:[DevBrkAddr+2]
	mov	word ptr es:[bp.dpb_next_dpb+2],ax

	les	bp,dword ptr cs:[DevBrkAddr]
	add	word ptr cs:[DevBrkAddr],dpbsiz

;	or	cs:[setdevmarkflag],for_devmark ;add dpb area for this unit
;	call	round				;check for alloc error

	call	RoundBreakAddr

	mov	word ptr es:[bp.dpb_next_dpb],-1
	mov	es:[bp.dpb_first_access],-1

	mov	si,[bx] 			;ds:si points to bpb
	inc	bx
	inc	bx				;point to next guy
	mov	word ptr es:[bp.dpb_drive],dx
	mov	ah,setdpb			;hidden system call
	int	21h

	mov	ax,es:[bp.dpb_sector_size]
	push	es
	les	di,cs:[dosinfo] 		;es:di point to dos info
	cmp	ax,es:[di.sysi_maxsec]
	pop	es
	jna	@f
	jmp	bad_bpb_size_sector
@@:

	push	ds
	push	dx

	lds	dx,cs:[DevEntry]
	mov	word ptr es:[bp.dpb_driver_addr],dx
	mov	word ptr es:[bp.dpb_driver_addr+2],ds

	pop	dx
	pop	ds

	inc	dx
	inc	dh
	loop	perunit

	push	cs
	pop	ds

ifdef	COPYCDS
	xor	al, al			; build CDSs incrementally
endif ; COPYCDS

	call	tempcds 			; set cds for new drives

linkit:
	les	di,cs:[dosinfo] 		;es:di = dos table
	mov	cx,word ptr es:[di.sysi_dev]	;dx:cx = head of list
	mov	dx,word ptr es:[di.sysi_dev+2]

	lds	si,cs:[DevEntry]		;ds:si = device location
	mov	word ptr es:[di.sysi_dev],si	;set head of list in dos
	mov	word ptr es:[di.sysi_dev+2],ds
	mov	ax,ds:[si]			;get pointer to next device
	mov	word ptr cs:[DevEntry],ax	;and save it

	mov	word ptr ds:[si],cx		;link in the driver
	mov	word ptr ds:[si+2],dx

enddev:

	pop	si
	pop	es
	inc	ax			;ax = ffff (no more devs if yes)?
	jz	coffj3

	inc	cs:multdeviceflag	; possibly multiple device driver.
	call	DevBreak		; M009
ifdef BREAK_HARD_CARDS_WILDLY
;BUGBUG 16-Mar-1993 bens Need to fix this correctly in next release!!!
	call	CheckDoubleSpace
else
        nop     ;; don't change size of IO.SYS
        nop
        nop
endif
	jmp	goodld			; otherwise pretend we loaded it in

coffj3: mov	cs:multdeviceflag,0	; reset the flag
	call	DevBreak
	call	CheckProtmanArena	; adjust alloclim if Protman$ just
;					;  created a bogus arena to try
;					;  to protect some of its resident-
;					;  init code.

	call	CheckDoubleSpace
	jmp	coff

CheckDoubleSpace:
	ifdef	dblspace_hooks

;	Now check for two special MagicDrv cases:
;
;       a) the last driver load was MagicDrv final placement:
;	   -> add number of MagicDrv reserved drives to drivenumber
;
;       b) MagicDrv is currently in temporary home:
;          -> call it to give it a chance to mount and shuffle drives

	cmp	cs:MagicHomeFlag,0	; already home?
	jnz	no_more_magic_calls	;  nothing more to do if so

;	Now inquire of driver whether it is present, and final located

	mov	ax,multMagicdrv
	mov	bx,MD_VERSION
	int	2fh			; ch = number of MagicDrv drive letters
	or	ax,ax			; is it there?
	jnz	no_more_magic_calls	; done if not

	test	dx,8000h		; is it final placed?
	jnz	magic_not_yet_home	;  skip if not

;	Okay, now the driver is final placed!  Set the flag so we
;	don't keep checking it, and add its number of drive letters
;	to drivenumber.

	mov	cs:MagicHomeFlag,0ffh	; set the flag!
	add	cs:drivenumber,ch	; add number of MagicDrv volumes to
;					;  the drive number we'll pass to the
;					;  next loadable block device.

	jmp	short no_more_magic_calls ; and finished.


magic_not_yet_home:
	push	es
	push	si

	mov	cx, cs:[memhi]		; pass it a work buffer
	mov	dx, cs:[alloclim]	;   address in cx (segment)
	sub	dx, cx			;   for len dx (paragraphs)

	mov	bx,2
	mov	al,cs:[driver_units]	; shuffle magicdrives and new drives
;					;   by this many units

;BUGBUG 29-Oct-1992 bens Take this 55h out after Beta 4
	mov	ah,55h			; backdoor won't shuffle unless it
;					;  sees this, to prevent bad things
;					;  from happening if people run the
;					;  new driver with an old BIOS
	call	cs:MagicBackdoor

	pop	si
	pop	es

no_more_magic_calls:

	endif
	ret

bad_bpb_size_sector:
	pop	si
	pop	es
	mov	dx,offset badsiz_pre
	mov	bx,offset crlfm
	call	prnerr

;	test	[setdevmarkflag],setbrkdone ;if already set_break is done,
;	jnz	skip2_resetmemhi	; then do not
;	dec	[memhi] 		;adjust memhi by a paragrah of devmark.

skip2_resetmemhi:
	jmp	coff


;------------------------------------------------------------------------------
; country command
;      the syntax is:
;	country=country id {,codepage {,path}}
;	country=country id {,,path}	:default codepage id in dos
;------------------------------------------------------------------------------

tryq:
        cmp     ah,CONFIG_COUNTRY
	jz	tryq_cont
skip_it3:
	jmp	tryf
tryq_cont:
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      skip_it3                ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	cntry_drv,0		; reset the drive,path to default value.
	mov	p_code_page,0
	mov	di,offset cntry_parms
	xor	cx,cx
	mov	dx,cx
do52:
	call	sysinit_parse
	jnc	if52			; parse error,check error code and

	call	cntry_error		;  show message and end the search loop.
	mov	p_cntry_code,-1		; signals that parse error.
	jmp	short sr52

if52:
	cmp	ax,$p_rc_eol		; end of line?
	jz	sr52			; then end the search loop

	cmp	result_val.$p_type,$p_number	; numeric?
	jnz	if56

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if57

	mov	p_cntry_code,ax
	jmp	short en57

if57:
	mov	p_code_page,ax
en57:
	jmp	short en56		; path entered

if56:
	push	ds
	push	es
	push	si
	push	di

	push	cs
	pop	es

	lds	si,rv_dword		; move the path to known place.
	mov	di,offset cntry_drv
	call	move_asciiz

	pop	di
	pop	si
	pop	es
	pop	ds

en56:
	jmp	do52

sr52:
	cmp	p_cntry_code,-1		; had a parse error?
	jne	tryq_open
	jmp	coff

tryqbad:				;"invalid country code or code page"
       stc
       mov     dx,offset badcountry
       jmp     tryqchkerr

tryq_open:
	cmp	cntry_drv,0
	je	tryq_def
	mov	dx,offset cntry_drv
	jmp	short tryq_openit

tryq_def:
	mov	dx,offset cntry_root
tryq_openit:
	mov	ax,3d00h		;open a file
	stc
	int	21h
	jc	tryqfilebad		;open failure

	mov	cs:cntryfilehandle,ax	;save file handle
	mov	bx,ax
	mov	ax,cs:p_cntry_code
	mov	dx,cs:p_code_page	; now,ax=country id,bx=filehandle
	mov	cx,cs:[memhi]
	add	cx,384			; need 6k buffer to handle country.sys
					; M023
	cmp	cx,cs:[alloclim]
	ja	tryqmemory		;cannot allocate the buffer for country.sys

	mov	si,offset cntry_drv	;ds:si -> cntry_drv
	cmp	byte ptr [si],0 	;default path?
	jne	tryq_set_for_dos

	inc	si
	inc	si			;ds:si -> cntry_root

tryq_set_for_dos:
	les	di,cs:sysi_country	;es:di -> country info tab in dos
	push	di			;save di
	add	di,ccpath_countrysys
	call	move_asciiz		;set the path to country.sys in dos.
	pop	di			;es:di -> country info tab again.

	mov	cx,cs:[memhi]
	mov	ds,cx
	xor	si,si			;ds:si -> 2k buffer to be used.
	call	setdoscountryinfo	;now do the job!!!
	jnc	tryqchkerr		;read error or could not find country,code page combination

	cmp	cx,-1			;could not find matching country_id,code page?
	je	tryqbad 		;then "invalid country code or code page"

tryqfilebad:
	push	cs
	pop	es
	cmp	cs:cntry_drv,0		;is the default file used?
	je	tryqdefbad

	mov	si,offset cntry_drv
	jmp	short tryqbadload

tryqdefbad:				;default file has been used.
	mov	si,offset cntry_root	;es:si -> \country.sys in sysinit_seg
tryqbadload:
	call	badload 		;ds will be restored to sysinit_seg
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot.
	jmp	short coffj4

tryqmemory:
	mov	dx,offset insufmemory
tryqchkerr:
	mov	cx,cs:[confbot]
	mov	es,cx			;restore es -> confbot seg
	push	cs
	pop	ds			;retore ds to sysinit_seg
	jnc	coffj4			;if no error,then exit

	call	print			;else show error message
	call	error_line

coffj4:
	mov	bx,cntryfilehandle
	mov	ah,3eh
	int	21h			;close a file. don't care even if it fails.
	jmp	coff

cntry_error	proc	near

;function: show "invalid country code or code page" messages,or
;		"error in country command" depending on the error code
;		in ax returned by sysparse;
;in:	ax - error code
;	ds - sysinitseg
;	es - confbot
;out:	show message.  dx destroyed.

	cmp	ax,$p_out_of_range
	jnz	if64
	mov	dx,offset badcountry	;"invalid country code or code page"
	jmp	short en64

if64:
	mov	dx,offset badcountrycom ;"error in contry command"
en64:
	call	print
	call	error_line
	ret
cntry_error	endp

;------------------------------------------------------------------------------
; files command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of files= command.			       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	variable files set.						       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to files_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     files = result_val.$p_picked_val				       *
;	  else								       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************
tryf:
        cmp     ah,CONFIG_FILES
	jnz	tryl
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      tryl                    ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset files_parms
	xor	cx,cx
	mov	dx,cx

do67:
	call	sysinit_parse
	jnc	if67			; parse error
	call	badparm_p		;   and show messages and end the search loop.
	jmp	short sr67

if67:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en67			; then end the $endloop
	mov	al,byte ptr result_val.$p_picked_val
	mov	p_files,al		; save it temporarily
	jmp	short do67

en67:
	mov	al,p_files
	mov	files,al		; no error. really set the value now.

sr67:
	jmp	coff

;------------------------------------------------------------------------------
; lastdrive command
;------------------------------------------------------------------------------
;*******************************************************************************
; function: parse the parameters of lastdrive= command. 		       *
;									       *
; input :								       *
;	es:si -> parameters in command line.				       *
; output:								       *
;	set the variable num_cds.					       *
;									       *
; subroutines to be called:						       *
;	sysinit_parse							       *
; logic:								       *
; {									       *
;	set di points to ldrv_parms;					       *
;	set dx,cx to 0; 						       *
;	while (end of command line)					       *
;	{ sysinit_parse;						       *
;	  if (no error) then						       *
;	     set num_cds to the returned value; 			       *
;	  else	/*error exit*/						       *
;	     error exit;						       *
;	};								       *
; };									       *
;									       *
;*******************************************************************************

tryl:
        cmp     ah,CONFIG_LASTDRIVE
	jnz	tryp
ifdef   MULTI_CONFIG
        call    query_user      ; query the user if config_cmd
        jc      tryp            ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset ldrv_parms
	xor	cx,cx
	mov	dx,cx

do73:
	call	sysinit_parse
	jnc	if73		; parse error
	call	badparm_p	;   and show messages and end the search loop.
	jmp	short sr73

if73:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en73		; then end the $endloop
	mov	al,rv_byte	; pick up the drive number
	mov	p_ldrv,al	; save it temporarily
	jmp	do73

en73:
	mov	al,p_ldrv
	mov	num_cds,al	; no error. really set the value now.
sr73:
	jmp	coff


;--------------------------------------------------------------------------
; setting drive parameters
;--------------------------------------------------------------------------

tryp:
        cmp     ah,CONFIG_DRIVPARM
	jnz	tryk
ifdef   MULTI_CONFIG
        call    query_user      ; query the user if config_cmd
        jc      tryk            ; has the CONFIG_OPTION_QUERY bit set
endif
	call	parseline
	jc	trypbad
	call	setparms
	call	diddleback

; No error check here, because setparms and diddleback have no error 
; returns, and setparms as coded now can return with carry set. 
;       jc	trypbad

	jmp	coff
trypbad:jmp	badop
;--------------------------------------------------------------------------
; setting internal stack parameters
; stacks=m,n where
;	m is the number of stacks (range 8 to 64,default 9)
;	n is the stack size (range 32 to 512 bytes,default 128)
; j.k. 5/5/86: stacks=0,0 implies no stack installation.
;	any combinations that are not within the specified limits will
;	result in "unrecognized command" error.
;--------------------------------------------------------------------------

;****************************************************************************
;									    *
; function: parse the parameters of stacks= command.			    *
;	    the minimum value for "number of stacks" and "stack size" is    *
;	    8 and 32 each.  in the definition of sysparse value list,they   *
;	    are set to 0.  this is for accepting the exceptional case of    *
;	    stacks=0,0 case (,which means do not install the stack.)	    *
;	    so,after sysparse is done,we have to check if the entered	    *
;	    values (stack_count,stack_size) are within the actual range,    *
;	    (or if "0,0" pair has been entered.)			    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	set the variables stack_count,stack_size.			    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to stks_parms;					    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	     { if (cx == 1) then /* first positional = stack count */	    *
;		   p_stack_count = result_val.$p_picked_val;		    *
;	       if (cx == 2) then /* second positional = stack size */	    *
;		   p_stack_size = result_val.$p_picked_val;		    *
;	     }								    *
;	  else	/*error exit*/						    *
;	     error exit;						    *
;	};								    *
;	here check p_stack_count,p_stack_size if it meets the condition;    *
;	if o.k.,then set stack_count,stack_size;			    *
;	 else error_exit;						    *
; };									    *
;****************************************************************************

tryk:
        if      stacksw

        cmp     ah,CONFIG_STACKS
	je	do_tryk
skip_it4:
	jmp	trys

do_tryk:
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      skip_it4                ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset stks_parms
	xor	cx,cx
	mov	dx,cx

do79:
	call	sysinit_parse
	jnc	if79			; parse error

	mov	dx,offset badstack	; "invalid stack parameter"
	call	print			;  and show messages and end the search loop.
	call	error_line
	jmp	sr79

if79:
	cmp	ax,$p_rc_eol		; end of line?
	jz	en79			; then end the $endloop

	mov	ax,word ptr result_val.$p_picked_val
	cmp	cx,1
	jnz	if83

	mov	p_stack_count,ax
	jmp	short en83

if83:
	mov	p_stack_size,ax
en83:
	jmp	do79

en79:
	cmp	p_stack_count,0
	jz	if87

	cmp	p_stack_count,mincount
	jb	ll88
	cmp	p_stack_size,minsize
	jnb	if88

ll88:
	mov	p_stack_count,-1	; invalid
if88:
	jmp	short en87

if87:
	cmp	p_stack_size,0
	jz	en87
	mov	p_stack_count,-1	; invalid
en87:
	cmp	p_stack_count,-1	; invalid?
	jnz	if94

	mov	stack_count,defaultcount ;reset to default value.
	mov	stack_size,defaultsize
	mov	word ptr stack_addr,0

	mov	dx,offset badstack
	call	print
	call	error_line
	jmp	short sr79

if94:
	mov	ax,p_stack_count
	mov	stack_count,ax
	mov	ax,p_stack_size
	mov	stack_size,ax
	mov	word ptr stack_addr,-1	; stacks= been accepted.
sr79:
	jmp	coff

	endif

;------------------------------------------------------------------------
; shell command
;------------------------------------------------------------------------

trys:
        cmp     ah,CONFIG_SHELL
	jnz	tryx
ifdef   MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      tryx                    ; has the CONFIG_OPTION_QUERY bit set
        mov     [newcmd],1
endif
        mov     word ptr [command_line],0;zap length,first byte of command-line

        mov     di,offset commnd+1      ; we already have the first char
        mov     [di-1],al               ; of the new shell in AL, save it now

storeshell:
	call	getchr
        or      al,al                   ; this is the normal case: "organize"
        jz      getshparms              ; put a ZERO right after the filename

        cmp     al," "                  ; this may happen if there are no args
        jb      endofshell              ; I suppose...
	mov	[di],al
	inc	di
        cmp     di,offset commnd+63     ; this makes sure we don't overflow
        jb      storeshell              ; commnd (the filename)
        jmp     short endofshell

getshparms:
        mov     byte ptr [di],0         ; zero-terminate the filename
        mov     di,offset command_line+1; prepare to process the command-line

parmloop:
	call	getchr
	cmp	al," "
        jb      endofparms
	mov	[di],al
	inc	di
        cmp     di,offset command_line+126
        jb      parmloop

endofparms:
        mov     cx,di
        sub     cx,offset command_line+1
        mov     [command_line],cl

endofshell:
        mov     byte ptr [di],0         ; zero-terminate the filename (or
                                        ; the command-line as the case may be)
skipline:
        cmp     al,lf                   ; the safest way to eat the rest of
        je      endofline               ; the line:  watch for ever-present LF
	call	getchr
        jnc     skipline                ; keep it up as long as there are chars

endofline:
        jmp     conflp

;------------------------------------------------------------------------
; fcbs command
;------------------------------------------------------------------------

;************************************************************************
; function: parse the parameters of fcbs= command.			*
;									*
; input :								*
;	es:si -> parameters in command line.				*
; output:								*
;	set the variables fcbs,keep.					*
;									*
; subroutines to be called:						*
;	sysinit_parse							*
; logic:								*
; {									*
;	set di points to fcbs_parms;					*
;	set dx,cx to 0; 						*
;	while (end of command line)					*
;	{ sysparse;							*
;	  if (no error) then						*
;	     { if (cx == 1) then /* first positional = fcbs */		*
;		   fcbs = result_val.$p_picked_val;			*
;	       if (cx == 2) then /* second positional = keep */ 	*
;		   keep = result_val.$p_picked_val;			*
;	     }								*
;	  else	/*error exit*/						*
;	     error exit;						*
;	};								*
; };									*
;************************************************************************

tryx:
        cmp     ah,CONFIG_FCBS
        jnz     try1
ifdef   MULTI_CONFIG
        call    query_user      ; query the user if config_cmd
        jc      try1            ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset fcbs_parms
	xor	cx,cx
	mov	dx,cx

do98:
	call	sysinit_parse
        jnc     if98            ; parse error
        call    badparm_p       ;  and show messages and end the search loop.
	jmp	short sr98

if98:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en98		; then end the $endloop

	mov	al,byte ptr result_val.$p_picked_val
	cmp	cx,1		; the first positional?
	jnz	if102
	mov	p_fcbs,al
	jmp	short en102

if102:
	mov	p_keep,al
en102:
	jmp	do98

en98:
	mov	al,p_fcbs	; M017
	mov	fcbs,al		; M017
	mov	keep,0		; M017
sr98:
	jmp	coff

;-----------------------------------------------------------------------
; switches command
;-----------------------------------------------------------------------
;****************************************************************************
;									    *
; function: parse the option switches specified.			    *
; note - this command is intended for the future use also.  when we need to *
; to set system data flag,use this command.				    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	p_swit_k set if /k option chosen.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di points to swit_parms;  /*parse control definition*/	    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val.$p_synonym_ptr == swit_k) then		    *
;		    p_swit_k = 1					    *
;	       endif							    *
;	  else {show error message;error exit}				    *
;	};								    *
; };									    *
;									    *
;****************************************************************************

try1:
        cmp     ah,CONFIG_SWITCHES
        je      do_try1         ; switches= command entered?
skip_it5:
        jmp     tryv
do_try1:
ifdef   MULTI_CONFIG
        call    query_user      ; query the user if config_cmd
        jc      skip_it5        ; has the CONFIG_OPTION_QUERY bit set
endif
	mov	di,offset swit_parms
	xor	cx,cx
	mov	dx,cx

do110:
	call	sysinit_parse
	jnc	if110		; parse error
	call	badparm_p	;  and show messages and end the search loop.
	jmp	short sr110

if110:
	cmp	ax,$p_rc_eol	; end of line?
	jz	en110		; then jmp to $endloop for semantic check

	cmp	result_val.$p_synonym_ptr,offset swit_k
	jnz	if115		;				;M059
	mov	p_swit_k,1	; set the flag
	jmp	do110
if115:								;M059
	cmp	result_val.$p_synonym_ptr, offset swit_t	;M059
	jne	if116						;M059 M063
	mov	p_swit_t, 1					;M059
	jmp	do110						;M059
if116:
	cmp	result_val.$p_synonym_ptr, offset swit_w	;M063
	jne	do110						;M063
	mov	p_swit_w, 1					;M063
	jmp	do110						;M063
en110:
	cmp	p_swit_k,1	;if /k entered,

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data
	jnz	if117
	mov	keyrd_func,0	;use the conventional keyboard functions
	mov	keysts_func,1
if117:
	mov	al, p_swit_t					;M059
	mov	t_switch, al					;M059

	cmp	p_swit_w, 0					;M063
	je	skip_dos_flag					;M063
	push	es
	push	bx
	mov	ah, GET_IN_VARS					;M063
	int	21h						;M063
	or	byte ptr es:[DOS_FLAG_OFFSET], SUPPRESS_WINA20	;M063
	pop	bx
	pop	es
skip_dos_flag:							;M063
	pop	ds
	assume	ds:sysinitseg

sr110:
	jmp	coff

tryv:

ifdef   MULTI_CONFIG
;------------------------------------------------------------------------
; set command (as in "set var=value<cr/lf>")
;------------------------------------------------------------------------

        cmp     ah,CONFIG_SET
        jne     tryn
        call    query_user      ; query the user if config_cmd
        jc      tryn            ; has the CONFIG_OPTION_QUERY bit set
        call    copy_envvar     ; copy var at ES:SI to "config_wrkseg"
        jnc     sr110           ; no error
err:    call    error_line      ; whoops, display error in line XXX
        jmp     short sr110     ; jump to coff (to skip to next line)

;------------------------------------------------------------------------
; numlock command (as in "numlock=on|off")
;------------------------------------------------------------------------
tryn:
        cmp     ah,CONFIG_NUMLOCK
        jne     tryy            ;
        call    query_user      ; query the user if config_cmd
        jc      tryy            ; has the CONFIG_OPTION_QUERY bit set
        call    set_numlock
        jc      err
        jmp     sr110           ; all done

endif  ;MULTI_CONFIG

;-------------------------------------------------------------------------
; comment= do nothing. just decrese chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

tryy:
        cmp     ah,CONFIG_COMMENT
	jne	try0

donothing:
	dec	chrptr
	inc	count
	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				;do nothing with this line.
        cmp     ah,CONFIG_REM
	je	donothing

;------------------------------------------------------------------------
; bogus command
;------------------------------------------------------------------------

tryz:
        cmp     ah,0ffh         ;null command? (BUGBUG - who sets FFh anyway?)
        je      donothing

	dec	chrptr
	inc	count
	jmp	short badop

doconf	endp

;***	CheckProtmanArena -- special hack for adjusting alloclim with Protman$
;
;	adjusts alloclim if Protman$ reduced our arena through a manual hack.
;

CheckProtmanArena	proc	near

	push	es
	mov	ax,cs:area	; get our arena header
	dec	ax
	mov	es,ax
	add	ax,es:word ptr 3 ; find end of arena
	inc	ax
	cmp	ax,cs:alloclim	; is it less than alloclim?
	ja	CheckProtmanDone

	mov	cs:alloclim,ax	; reduce alloclim then

CheckProtmanDone:
	pop	es
	ret

CheckProtmanArena	endp

;------------------------------------------------------------------------------

sysinit_parse	proc
;set up registers for sysparse
;in)	es:si -> command line in  confbot
;	di -> offset of the parse control defintion.
;
;out)	calls sysparse.
;	carry will set if parse error.
;	*** the caller should check the eol condition by looking at ax
;	*** after each call.
;	*** if no parameters are found,then ax will contain a error code.
;	*** if the caller needs to look at the synomym@ of the result,
;	***  the caller should use cs:@ instead of es:@.
;	cx register should be set to 0 at the first time the caller calls this
;	 procedure.
;	ax - exit code
;	bl - terminated delimeter code
;	cx - new positional ordinal
;	si - set to pase scanned operand
;	dx - selected result buffer

	push	es			;save es,ds
	push	ds

	push	es
	pop	ds			;now ds:si -> command line

	push	cs
	pop	es			;now es:di -> control definition

	mov	cs:badparm_seg,ds	;save the pointer to the parm
	mov	cs:badparm_off,si	; we are about to parse for badparm msg.
	mov	dx,0
	call	sysparse
	cmp	ax,$p_no_error		;no error

;**cas note:  when zero true after cmp, carry clear

	jz	ll4
	cmp	ax,$p_rc_eol		;or the end of line?
	jnz	if4

ll4:
	clc
	jmp	short en4

if4:
	stc
en4:
	pop	ds
	pop	es
	ret
sysinit_parse	endp

;
;----------------------------------------------------------------------------
;
; procedure : badop_p
;
;             same thing as badop,but will make sure to set ds register back
;             to sysinitseg and return back to the caller.
;
;----------------------------------------------------------------------------
;
badop_p proc	near


	push	cs
	pop	ds			;set ds to configsys seg.
	mov	dx,offset badopm
	call	print
        call    error_line
	ret

badop_p endp
;
;----------------------------------------------------------------------------
;
; label : badop
;
;----------------------------------------------------------------------------
;
badop:	mov	dx,offset badopm	;want to print command error "unrecognized command..."
	call	print
	call	error_line		;show "error in config.sys ..." .
	jmp	coff


;
;----------------------------------------------------------------------------
;
; procedure : badparm_p
;
;             show "bad command or parameters - xxxxxx"
;             in badparm_seg,badparm_off -> xxxxx
;
;----------------------------------------------------------------------------
;
badparm_p	proc	near


	push	ds
	push	dx
	push	si

	push	cs
	pop	ds

	mov	dx,offset badparm
	call	print			;"bad command or parameters - "
	lds	si,badparm_ptr

;	print "xxxx" until cr.

do1:
	mov	dl,byte ptr [si]	; get next character
	cmp	dl,cr			; is a carriage return?
	jz	en1			; exit loop if so

	mov	ah,std_con_output	; function 2
	int	21h			; display character
	inc	si			; next character
	jmp	do1
en1:
	push	cs
	pop	ds

	mov	dx,offset crlfm
	call	print
	call	error_line

	pop	si
	pop	dx
	pop	ds
badparmp_ret:
	ret
badparm_p	endp

;
;----------------------------------------------------------------------------
;
; procedure : getchr
;
;----------------------------------------------------------------------------
;
getchr	proc	near
	push	cx
	mov	cx,count
	jcxz	nochar

	mov	si,chrptr
	mov	al,es:[si]
	dec	count
	inc	chrptr
	clc
get_ret:
	pop	cx
	ret

nochar: stc
	jmp	short get_ret
getchr	endp

;
;----------------------------------------------------------------------------
;
; procedure : incorrect_order
;
;             show "incorrect order in config.sys ..." message.
;
;----------------------------------------------------------------------------
;

incorrect_order proc	near

	mov	dx,offset badorder
	call	print
	call	showlinenum
	ret

incorrect_order endp

;
;----------------------------------------------------------------------------
;
; procedure : error_line
;
;             show "error in config.sys ..." message.
;
;----------------------------------------------------------------------------
;
		public	error_line
error_line	proc	near


	push	cs
	pop	ds
	mov	dx,offset errorcmd
	call	print
	call	showlinenum
	ret

error_line	endp

;
;----------------------------------------------------------------------------
;
; procedure : showlinenum
;
; convert the binary linecount to decimal ascii string in showcount
;and display showcount at the current curser position.
;in.) linecount
;
;out) the number is printed.
;
;----------------------------------------------------------------------------
;
showlinenum	proc	near


	push	es
	push	ds
	push	di

	push	cs
	pop	es		; es=cs

	push	cs
	pop	ds

	mov	di,offset showcount+4	; di -> the least significant decimal field.
	mov	cx,10			; decimal devide factor
	mov	ax,cs:linecount

sln_loop:
	cmp	ax,10			; < 10?
	jb	sln_last

	xor	dx,dx
	div	cx
	or	dl,30h			; add "0" (= 30h) to make it an ascii.
	mov	[di],dl
	dec	di
	jmp	sln_loop

sln_last:
	or	al,30h
	mov	[di],al
	mov	dx,di
	call	print			; show it.
	pop	di
	pop	ds
	pop	es
	ret
showlinenum	endp

comment ^
set_devmark	proc	near
;***************************************************************************
; function: set a paragraph of informations infront of a device file or    *
;	    an ifs file to be loaded for mem command.			   *
;	    the structure is:						   *
;	      devmark_id	byte "d" for device,"i" for ifs		   *
;	      devmark_size	size in para for the device loaded	   *
;	      devmark_filename	11 bytes. filename			   *
;									   *
; input :								   *
;	    [memhi] = address to set up devmark.			   *
;	    [memlo] = 0 						   *
;	    es:si -> pointer to [drive][path]filename,0 		   *
;	    [ifs_flag] = is_ifs bit set if ifs= command.		   *
;									   *
; output:   devmark_id,devmark_filename set				   *
;	    cs:[devmark_addr] set.					   *
;	    ax,cx register destroyed.					   *
;***************************************************************************

	push	ds
	push	si
	push	es
	push	di

	mov	di,cs:[memhi]
	mov	ds,di
	assume	ds:nothing
	mov	[devmark_addr],di	; save the devmark address for the future.
	mov	ds:[devmark_id],devmark_device	; 'd'
	inc	di
	mov	ds:[devmark_seg],di
	xor	al,al
	push	si
	pop	di			; now es:si = es:di = [path]filename,0
	mov	cx,128			; maximum 128 char
	repnz	scasb			; find 0
	dec	di			; now es:di-> 0
sdvmk_backward: 			; find the pointer to the start of the filename.
	mov	al,byte ptr es:[di]	; we do this by check es:di backward until
	cmp	al,'\' 		        ; di = si or di -> '\' or di -> ':'.
	je	sdvmk_gotfile
	cmp	al,':'
	je	sdvmk_gotfile
	cmp	di,si
	je	sdvmk_fileptr
	dec	di
	jmp	sdvmk_backward
sdvmk_gotfile:
	inc	di
sdvmk_fileptr:				; now es:di -> start of file name
	push	di			; cas - holy sh*t!!!  CODE!
	pop	si			; save di to si.

	push	ds			; switch es,ds
	push	es
	pop	ds
	pop	es			; now,ds:si -> start of filename

	mov	di,devmark_filename
	push	di
	mov	al,' '
	mov	cx,8
	rep	stosb			; clean up memory.
	pop	di
	mov	cx,8			; max 8 char. only
sdvmk_loop:
	lodsb
	cmp	al,'.'
	je	sdvmk_done
	cmp	al,0
	je	sdvmk_done
	stosb
	loop	sdvmk_loop

sdvmk_done:
	pop	di
	pop	es
	pop	si
	pop	ds
	ret
set_devmark	endp
^
; =========================================================================
;reset_dos_version	proc	near
;
;;function: issue ax=122fh,dx=0,int 2fh to restore the dos version.
;
;	push	ax
;	push	dx
;	mov	ax,122fh
;	mov	dx,0
;	int	2fh
;	pop	dx
;	pop	ax
;	ret
;reset_dos_version	endp
;
;
; =========================================================================

IFDEF	DONT_LOAD_OS2_DD		; M045

EXE_SIG		EQU	5a4dh		; .EXE file signature
OS2_SIG 	EQU	454eh		; OS2 .EXE file signature

SIGNATURE_LEN	EQU	2		; Lenght of .EXE signature in bytes
SIZE_DWORD	EQU	4

SEG_SIG_OFFSET	EQU	18h		; Offset of segmented .EXE signature
SEG_EXE_SIG	EQU	40h		; Signature of a segmented .EXE file
SEG_HEADER_PTR	EQU	3ch		; Offsets of ptr to segmented header

; =========================================================================
; CheckForOS2 PROC
;
; Examines an open file to see if it is really an OS2 executable file.
;
; REGISTERS:	AX	- Open file handle
; RETURNS:	Carry	- Carry set if file is an OS2 executable or error.
; DESTROYS:	NOTHING
;		NOTE:	The file ptr is assumed to be set to start of file
;			on entry and is not reset to begining of the file
;			on exit.
;
; Strategy:	If word value at 00h == 454eh file is OS2
;		else if word value at 00h == 5a4dh and
;		        (word value at 18h == 40h and the dword ptr at 3ch
;			 points to word value of 454eh) file is OS2.
;
; =========================================================================

CheckForOS2 PROC NEAR

	push	AX
	push	BX
	push	CX
	push	DX
	push	DS
	push	BP

	push	CS				; BUGBUG
	pop	DS				; NOT ROM DOS COMPATIBLE

	mov	BX,AX				; Put open file handle in BX
	mov	BP,offset DS:Os2ChkBuf		; Save buff offset for latter

		; First we need to read in the first 2 bytes of the file
		; to see if it's an OS2 .EXE file and if not see if 
		; it is a DOS .EXE file. 

	mov	AX,(read shl 8)			; AH = DOS read function
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; DS:DX --> tmp buffer
	int	21h
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	mov	AX, WORD PTR DS:Os2ChkBuf
	cmp	AX, OS2_SIG			; Check for 454eh
	je	IsOS2				; Return is OS2 if match
	cmp	AX, EXE_SIG			; Now see if it's a DOS .EXE
	jne	NotOS2				; If no match can't be OS2

		; Here we know the file has a valid DOS .EXE signature so
		; now we need to see if it's a segmented .EXE file by looking
		; for the segmented .EXE signature at file offset 18h

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_SIG_OFFSET		; CX:DX = offset of segmented
	int	21h				; Seek to offset 18h
	jc	OS2ChkExit			; Return carry on error

	mov	AX,read shl 8			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word value
	mov	DX,BP				; Restore buffer offset
	int	21h 				; DS:DX -> buffer
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

	cmp	WORD PTR DS:Os2ChkBuf,SEG_EXE_SIG ; Chk for segmented .EXE file
	jne	NotOS2				; Can't be OS2 if no match

		; Here we know we have a segmented .EXE file so we have
		; to get the offset of the start of the segmented  header
		; from offset 3ch in the file.

	mov	AX,(lseek shl 8)		; AX = Seek from begining
	xor	CX,CX
	mov	DX,SEG_HEADER_PTR		; CX:DX = offset of head ptr
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIZE_DWORD			; CX = size of dword (4 bytes)
	mov	DX,BP				; Restore buffer offset
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	cmp	AX,SIZE_DWORD			; Check number of byte read
	jne	NotOs2				; Must be at end of file

		; At this point OS2ChkBuf has a 4 byte offset into the file
		; to the start of a segmented .EXE header so we need to read
		; the 2 bytes at this location to see if they are 454eh

	mov	DX,WORD PTR DS:Os2ChkBuf
	mov	CX,WORD PTR DS:Os2ChkBuf[2]	; CX:DX = offset of new header
	mov	AX,(lseek shl 8)		; AX = Seek from begining
	int	21h				; Seek to offset 3ch
	jc	OS2ChkExit			; Return carry on error

	mov	AX,(read shl 8)			; AX = Read file
	mov	CX,SIGNATURE_LEN		; CX = size of word (2 bytes)
	mov	DX,BP				; DS:DX --> Os2ChkBuf
	int	21h 				; Read in 4 byte offset
	jc	OS2ChkExit			; Return carry on error

	dec	AX				; Check number of byte read
	dec	AX
	jnz	NotOs2				; Must be at end of file

		; We have the segmented .EXE header in OS2ChkBuf so all
		; we have left to do is see if it's a .EXE signature.

	cmp	WORD PTR DS:OS2ChkBuf,OS2_SIG	; Check for 454eh
	jne	NotOs2				; Not OS2 if it doesn't match

IsOs2:
	stc					; Signal error or OS2 .EXE
	jmp	SHORT OS2ChkExit
NotOs2:
	clc					; Signal no err and not OS2

OS2ChkExit:
	pop	BP
	pop	DS
	pop	DX
	pop	CX
	pop	BX
	pop	AX
	ret

CheckForOS2 ENDP

ENDIF						; M045

;
;----------------------------------------------------------------------------
;
; procedure : ProcDOS
;
;	Process the result of DOS= parsing
;
;	result_val.$p_item_tag	= 1 for DOS=HIGH
;				= 2 for DOS=LOW
;				= 3 for DOS=UMB
;				= 4 for DOS=NOUMB
;----------------------------------------------------------------------------
;
ProcDOS	proc	near
	assume	ds:nothing, es:nothing
	xor	ah, ah
	mov	al, result_val.$p_item_tag
	dec	ax
	jz	pd_hi
	dec	ax
	jz	pd_lo
	dec	ax
	jz	pd_umb
	mov	DevUMB, 0
	ret
pd_umb:
	mov	DevUMB, 0ffh
	ret
pd_lo:
	mov	runhigh, 0
	ret
pd_hi:
	mov	runhigh, 0ffh
	ret
ProcDOS	endp

;
;----------------------------------------------------------------------------
;
; procedure : LieInt12Mem
;
;	Input : DevEntry points to Device Start address (offset == 0)
;		alloclim set to the limit of low memory.
;
;	Output : none
;
;	Changes the ROM BIOS variable which stores the total low memory
;	If a 3com device driver (any character device with name 'PROTMAN$')
;	is being loaded alloclim is converted into Ks and stored in 40:13h
;	Else if a device driver being loaded into UMB the DevLoadEnd is
;	converted into Ks and stored in 40:13h
;
;----------------------------------------------------------------------------
;
LieInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		mov	ax, alloclim		; lie INT 12 as alloclim
						; assuming that it is 3Com
		call	IsIt3Com?		; Is it 3Com driver?
		je	lim_set			; yes, lie to him differently
		cmp	DeviceHi, 0		; Is the DD being loaded in UMB
		je	limx			; no, don't lie
		mov	ax, DevLoadEnd		; lie INT 12 as end of UMB
lim_set:
		call	SetInt12Mem
limx:
		ret
LieInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : SetInt12Mem
;
;	Input : AX = Memory size to be set (in paras)
;	Output : none
;
;	Sets the variable 40:13 to the memory size passed in AX
;	It saves the old value in 40:13 in OldInt12Mem,
;	It also sets a flag Int12Lied to 0ffh, which is checked before
;	restoring the value of 40:13
;
;----------------------------------------------------------------------------
;
SetInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		push	ds
		mov	bx, 40h
		mov	ds, bx			; ROM BIOS Data Segment
		mov	bx, word ptr ds:[13h]	; INT 12 memory variable
		mov	OldInt12Mem, bx		; save it
		mov	cl, 6
		shr	ax, cl			; convert paras into Ks
		mov	word ptr ds:[13h], ax	; Lie
		mov	Int12Lied, 0ffh		; mark that we are lying
		pop	ds
		ret
SetInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : TrueInt12Mem
;
;	Input : Int12Lied = 0 if we are not lying currently
;			  = 0ffh if we are lying
;		OldInt12Mem = Saved value of 40:13h
;
;	Output : none
;
;	Resets the INT 12 Memory variable if we were lying about int 12
;	and resets the flag which indicates that we were lying
;
;----------------------------------------------------------------------------
;
TrueInt12Mem	proc	near

		assume	ds:nothing, es:nothing
 
		cmp	Int12Lied, 0		; were we lying so far?
		mov	Int12Lied, 0		; reset it anyway
		je	timx			; no, we weren't
		push	ds
		mov	ax, 40h
		mov	ds, ax
		mov	ax, OldInt12Mem
		mov	word ptr ds:[13h], ax	; restore INT 12 memory
		pop	ds
timx:
		ret
TrueInt12Mem	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsIt3Com?
;
;	Input : DevEntry = Seg:0 of device driver
;	Output : Zero flag set if device name is 'PROTMAN$'
;		 else Zero flag is reset
;
;----------------------------------------------------------------------------
;
IsIt3Com?	proc	near
		assume	ds:nothing, es:nothing, ss:nothing
		push	ds
		push	es
		push	si
		lds	si, DevEntry		; ptr to device header
		add	si, sdevname		; ptr device name
		push	cs
		pop	es
		mov	di, offset ThreeComName
		mov	cx, 8			; name length
		rep	cmpsb
		pop	si
		pop	es
		pop	ds
		ret
IsIt3Com?	endp

;M020 : BEGIN
;
;----------------------------------------------------------------------------
;----------------------------------------------------------------------------
;
UpdatePDB	proc	near
		assume	ds:nothing
		push	ds
		mov	ah, 62h
		int	21h
		mov	ds, bx
		mov	bx, alloclim
		mov	ds:[PDB_Block_Len], bx
		pop	ds
		ret
UpdatePDB	endp
;
; M020 : END
;
;----------------------------------------------------------------------------
;
; procedure : InitDevLoad
;
;	Input : DeviceHi = 0 indicates load DD in low memory
;			 = 1 indicates load in UMB:
;		           ConvLoad = 0 indicates a new-style load (see below)
;		                    = 1 indicates a DOS 5-style load
;		DevSize  = Size of the device driver file in paras
;
;	Output : none
;
;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
;	Also sets up a header for the Device driver entry for mem utility
;
;----------------------------------------------------------------------------
; For a "new-style load", we break off the current DevEntry and link the umbs
; as we see fit, using HideUMBs (and UnHideUMBs at exit, though _it_ decides
; whether it's entitled to do anything).  HideUMBs uses the chart built by
; ParseVar to determine which UMBs to leave FREE, and which not.
;----------------------------------------------------------------------------
;

include	highload.inc	; Routines for devicehigh parsing, control of HIDDEN
include	highexit.inc	; umb's, etc

;
; ---------------------------------------------------------------------------
;

InitDevLoad	proc	near

		assume	ds:nothing, es:nothing

		cmp	DeviceHi, 0		; Are we loading in UMB
		je	InitForLo		; no, init for lo mem

		cmp	ConvLoad, 1		; Are we loading as per Dos 5?
		je	InitForConv

;
; There are two stages to preparing upper-memory; first, we mark as 8+HIDDEN
; any areas not specified on the /L:... chain.  Second, we mark as 8+FROZEN
; any areas left in upper-memory, except for elements in the load UMB...
; we then malloc space as per Dos-5 style, and mark as free any spaces which
; are 8+FROZEN (but leave 8+HIDDEN still hidden).  The load is performed,
; and UnHideUMBs later on marks all 8+HIDDEN as free.
;

		call	ShrinkUMB	; Stop using the old device arena

		call	HideUMBs	; Mark up the UM area as we see fit
		call	FreezeUM	; Hide everything BUT the load area
		call	GetUMBForDev	; And grab that load area as needed
		pushf
		call	UnFreeze	; Then unhide everything frozen
		popf

		jc	InitForLo	; (if carry, it's loading low)

		jmp short InitForHi

InitForConv:
		call	SpaceInUMB?		; Do we have space left in the
						;  current UMB ?
		jnc	InitForHi		; yes, we have
		call	ShrinkUMB		; shrink the current UMB in use
		call	GetUMBForDev		; else try to allocate new UMB
		jc	InitForLo		; we didn't succeed, so load
						;  in low memory
InitForHi:
		mov	ax, DevUMBFree		; get Para addr of free mem
		mov	dx, DevUMBAddr		; UMB start addr
		add	dx, DevUMBSize		; DX = UMB End addr
		jmp	short idl1

InitForLo:
		mov	DeviceHi, 0		; in case we failed to load
						;  into UMB indicate that we
						;  are loading low
		mov	ax, memhi		; AX = start of Low memory
		mov	dx, alloclim		; DX = End of Low memory

idl1:
		call	DevSetMark		; setup a sub-arena for DD
		mov	DevLoadAddr, ax		; init the Device load address

		mov	DevLoadEnd, dx		; init the limit of the block
		mov	word ptr DevEntry, 0	; init Entry point to DD
		mov	word ptr DevEntry+2, ax
		ret
InitDevLoad	endp

;
;----------------------------------------------------------------------------
;
; procedure : SpaceInUMB?
;
;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
;	Output : Carry set if no space in UMB
;		 Carry clear if Space is available for the device in
;		   current UMB
;
;----------------------------------------------------------------------------
;
SpaceInUMB?	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, DevUMBSize
		add	ax, DevUMBAddr		; End of UMB
		sub	ax, DevUMBFree		; - Free = Remaining space
		or	ax, ax			; Nospace ?
		jnz	@f
		stc
		ret
@@:
		dec	ax			; space for sub-arena
		cmp	ax, DevSize		; do we have space ?
		ret
SpaceInUMB?	endp

;
;----------------------------------------------------------------------------
;
; procedure : PrepareMark
;
;	Input : AX==Address of MCB (not addr of free space), BX==Size
;	Output : None; MCB marked appropriately and DevUMB* set as needed.
;
;----------------------------------------------------------------------------
;
PrepareMark	proc	near

		push	ds
		mov	ds, ax
		mov	word ptr ds:[arena_owner], 8
		mov	word ptr ds:[arena_name], 'DS'
		pop	ds

		inc	ax
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		mov	DevUMBSize, bx		; update the UMB Variables
		ret

PrepareMark	endp

;
;----------------------------------------------------------------------------
;
; procedure : GetUMBForDev
;
;	Input : DevSize
;	Output : Carry set if couldn't allocate a UMB to fit the
;		 the device.
;		 If success carry clear
;
;	Allocates the biggest UMB for loading devices and updates
;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
;	UMB.
;
;	This routine relies on the fact that all of the low memory
;	is allocated, and any DOS alloc calls should return memory
;	from the UMB pool.
;
;----------------------------------------------------------------------------
;
GetUMBForDev	proc	near

		assume	ds:nothing, es:nothing

		mov	bx, 0ffffh
		mov	ax, 4800h
		int	21h

		or	bx, bx
		jz	gufd_err

		dec	bx
		cmp	DevSize, bx
		ja	gufd_err
		inc	bx

		mov	ax, 4800h
		int	21h
		jc	gufd_err

		dec	ax
		call	PrepareMark

		clc				; mark no error
		ret
gufd_err:
		xor	ax, ax
		mov	DevUMBSize, ax		; erase the previous values
		mov	DevUMBAddr, ax
		mov	DevUMBFree, ax
		stc
		ret
GetUMBForDev	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetMark
;
;	Input : AX - Free segment were device is going to be loaded
;	Output : AX - Segment at which device can be loaded (AX=AX+1)
;
;	Creates a sub-arena for the device driver
;	puts 'D' marker in the sub-arena
;	Put the owner of the sub-arena as (AX+1)
;	Copies the file name into sub-arena name field
;
;	Size field of the sub-arena will be set only at succesful
;	completion of Device load.
;
;----------------------------------------------------------------------------
;
DevSetMark	proc	near

		assume	ds:nothing, es:nothing

		push	es
		push	di
		push	ds
		push	si
		mov	es, ax
		mov	byte ptr es:[devmark_id], devmark_device	; 'D'
		inc	ax
		mov	word ptr es:[devmark_seg], ax
;
;-------------- Copy file name
;
		push	ax			; save load addr
		lds	si, bpb_addr		; command line is still there
;M004 - BEGIN
		mov	di, si
		cld
dsm_again:
		lodsb
		cmp	al, ':'
		jne	isit_slash
		mov	di, si
		jmp	dsm_again
isit_slash:
		cmp	al, '\'
		jne	isit_null
		mov	di, si
		jmp	dsm_again
isit_null:

ifdef DBCS
		call	testkanj
		jz	@f		; if this is not lead byte
		lodsb			; get tail byte
@@:
endif

		or	al, al
		jnz	dsm_again
		mov	si, di
;M004 - END
		mov	di, devmark_filename
		mov	cx, 8			; maximum 8 characters
dsm_next_char:
		lodsb
		or	al, al
		jz	blankout
		cmp	al, '.'
		jz	blankout
		stosb
		loop	dsm_next_char
blankout:
		jcxz	dsm_exit
		mov	al, ' '
		rep	stosb			; blank out the rest
dsm_exit:
		pop	ax			; restore load addr
		pop	si
		pop	ds
		pop	di
		pop	es
		ret
DevSetMark	endp

;
;----------------------------------------------------------------------------
;
; procedure : SizeDevice
;
;	Input : ES:SI - points to device file to be sized
;
;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
;
;	Calculates the size of the device file in paras and stores it
;	in DevSize
;
;----------------------------------------------------------------------------
;
SizeDevice	proc	near

		assume	ds:nothing, es:nothing

                push    ds
		push	es
		pop	ds
		mov	dx, si			; ds:dx -> file name
		mov	ax, 3d00h		; open
		int	21h
		jc	sd_err			; open failed

IFDEF	DONT_LOAD_OS2_DD			; M045
		call	CheckForOS2		; is it a OS2 EXE file ?
		jc	sd_close		; yeah, we dont load them
ENDIF						; M045

		mov	bx, ax			; BX - file handle
		mov	ax, 4202h		; seek
		xor	cx, cx
		mov	dx, cx			; to end of file
		int	21h
		jc	sd_close		; did seek fail (impossible)
		add	ax, 15			; para convert
		adc	dx, 0
		test	dx, 0fff0h		; size > 0ffff paras ?
		jz	@f			; no
		mov	DevSize, 0ffffh		; invalid device size
						; assuming that we fail later
		jmp	short sd_close
@@:
		mov	cl, 4			; conver it to paras
		shr	ax, cl
		mov	cl, 12
		shl	dx, cl
		or	ax, dx			;
		mov	DevSize, ax		; save file size
		clc
sd_close:
		pushf				; let close not spoil our
						;  carry flag
		mov	ax, 3e00h		; close
		int	21h			; we are not checking for err
		popf
sd_err:
                pop     ds
		ret
SizeDevice	endp

;
;----------------------------------------------------------------------------
;
; procedure : ExecDev
;
;	Input : ds:dx -> device to be executed
;		DevLoadAddr - contains where device has to be loaded
;
;	Output : Carry if error
;		 Carry clear if no error
;
;	Loads a device driver using the 4b03h function call
;
;----------------------------------------------------------------------------
;
ExecDev		proc	near

		assume	ds:nothing, es:nothing

		mov	bx, DevLoadAddr
		mov	DevExecAddr, bx		; Load the parameter block
						;  block for exec with
						;  Load address
		mov	DevExecReloc, bx
		mov	bx,cs
		mov	es,bx
		mov	bx,offset DevExecAddr	;es:bx points to parameters
		mov	al,3
		mov	ah,exec
		int	21h			;load in the device driver
		ret
ExecDev		endp

;
;----------------------------------------------------------------------------
;
; procedure : RetFromUM
;
;	Input : None
;	Output : ConvLoad set if didn't previously call HideUMBs
;		 ConvLoad clear if did.
;
;	Prepares memory for more devices after returning from loading one
;	using the Dos 6 options (/L:... etc).
;
;----------------------------------------------------------------------------
;
RetFromUM	proc	near
	pushf
	mov	ConvLoad, 1
	call	UnHideUMBs
	jc	@f			; Skip this if didn't HideUMBs:
	mov	ConvLoad, 0
@@:	popf
	ret

RetFromUM	endp


;
;----------------------------------------------------------------------------
;
; procedure : RemoveNull
;
;	Input : ES:SI points to a null terminated string
;
;	Output : none
;
;	Replaces the null at the end of a string with blank
;
;----------------------------------------------------------------------------
;

RemoveNull	proc	near

		assume	ds:nothing, es:nothing

rn_next:
		mov	bl, es:[si]
		or	bl, bl			; null ?
		jz	rn_gotnull
		inc	si			; advance the pointer
		jmp	rn_next
rn_gotnull:
		mov	bl, DevSavedDelim
		mov	byte ptr es:[si], bl	; replace null with blank
		ret
RemoveNull	endp

;
;----------------------------------------------------------------------------
;
; procedure : RoundBreakAddr
;
;	Input : DevBrkAddr
;	Output : DevBrkAddr
;
;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
;
;----------------------------------------------------------------------------
;
RoundBreakAddr	proc	near

		assume	ds:nothing, es:nothing

		mov	ax, word ptr DevBrkAddr
		call	pararound
		add	word ptr DevBrkAddr+2, ax
		mov	word ptr DevBrkAddr, 0
		mov	ax, DevLoadEnd
		cmp	word ptr DevBrkAddr+2, ax
		jbe	rba_ok
		jmp	mem_err
rba_ok:
		ret
RoundBreakAddr	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevSetBreak
;
;	Input : DevBrkAddr
;	Output : Carry set if Device returned Init failed
;		 Else carry clear
;
;----------------------------------------------------------------------------
;
DevSetBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ax

		mov	ax,word ptr [DevBrkAddr+2]  ;remove the init code
		cmp	multdeviceflag, 0
		jne	set_break_continue	    ;do not check it.
		cmp	ax, DevLoadAddr
		jne	set_break_continue	    ;if not same, then o.k.

		cmp	word ptr [DevBrkAddr],0
		je	break_failed		;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0

set_break_continue:
		call	RoundBreakAddr
		pop	ax
		clc
		ret
break_failed:
		pop	ax
		stc
		ret
DevSetBreak	endp

;
;----------------------------------------------------------------------------
;
; procedure : DevBreak
;
;	Input : DevLoadAddr & DevBrkAddr
;	Output : none
;
;	Marks a succesful install of a device driver
;	Sets device size field in sub-arena &
;	Updates Free ptr in UMB or adjusts memhi
;
;----------------------------------------------------------------------------
;
DevBreak	proc	near

		assume	ds:nothing, es:nothing

		push	ds
		mov	ax, DevLoadAddr
		mov	bx, word ptr [DevBrkAddr+2]
		dec	ax			; seg of sub-arena
		mov	ds, ax
		inc	ax			; Back to Device segment
		sub	ax, bx
		neg	ax			; size of device in paras
		mov	ds:[devmark_size], ax	; store it in sub-arena
		cmp	DeviceHi, 0
		je	db_lo
		mov	DevUMBFree, bx		; update Free ptr in UMB
		jmp	short db_exit
db_lo:
		mov	memhi, bx
		mov	memlo, 0
db_exit:
		pop	ds
		ret
DevBreak	endp
;
;----------------------------------------------------------------------------
;
; procedure : ParseSize
;
;	Parses the command line for SIZE= command
;
;	ES:SI = command line to parsed
;
;	returns ptr to command line after SIZE= option in ES:SI
;	updates the DevSizeOption variable with value supplied
;	in SIZE=option
;	Returns carry if the SIZE option was invalid
;
;----------------------------------------------------------------------------
;

co	macro	arg
	mov	dl, arg
	mov	ah, 2
	int	21h
	endm

ParseSize	proc	near

		assume	ds:nothing, es:nothing

		push	bx
		mov	bx, si

		mov	DevSizeOption, 0	; init the value
		mov	word ptr DevCmdLine, si
		mov	word ptr DevCmdLine+2, es
		call	SkipDelim
		cmp	word ptr es:[si], 'IS'
		jne	ps_no_size
		cmp	word ptr es:[si+2], 'EZ'
		jne	ps_no_size
		mov	al, es:[si+4]
		call	delim
		jne	ps_no_size
		add	si, 5
		call	GetHexNum
		jc	ps_err
		mov	DevSizeOption, ax
		call	SkipDelim
		mov	bx, si

ps_no_size:	mov	si, bx
		pop	bx
		clc
		ret
ps_err:
		pop	bx
		stc
		ret
ParseSize	endp
;
;----------------------------------------------------------------------------
;
; procedure : SkipDelim
;
;	Skips delimiters in the string pointed to by ES:SI
;	Returns ptr to first non-delimiter character in ES:SI
;
;----------------------------------------------------------------------------
;
SkipDelim	proc	near

		assume	ds:nothing, es:nothing

sd_next_char:
		mov	al, es:[si]
		call	delim
		jnz	sd_ret
		inc	si
		jmp	sd_next_char
sd_ret:
		ret
SkipDelim	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetHexNum
;
;	Converts an ascii string terminated by a delimiter into binary.
;	Assumes that the ES:SI points to a Hexadecimal string
;
;	Returns in AX the number number of paras equivalent to the
;	hex number of bytes specified by the hexadecimal string.
;
;	Returns carry in case it encountered a non-hex character or
;	if it encountered crlf
;
;----------------------------------------------------------------------------
;
GetHexNum	proc	near

		assume	ds:nothing, es:nothing

		xor	ax, ax
		xor	dx, dx
ghn_next:
		mov	bl, es:[si]
		cmp	bl, cr
		je	ghn_err
		cmp	bl, lf
		je	ghn_err
		push	ax
		mov	al, bl
		call	Delim
		pop	ax
		jz	ghn_into_paras
		call	GetNibble
		jc	ghn_err
		mov	cx, 4
ghn_shift1:
		shl	ax, 1
		rcl	dx, 1
		loop	ghn_shift1
		or	al, bl
		inc	si
		jmp	ghn_next
ghn_into_paras:
		add	ax, 15
		adc	dx, 0
		test	dx, 0fff0h
		jnz	ghn_err
		mov	cx, 4
ghn_shift2:
		clc
		rcr	dx, 1
		rcr	ax, 1
		loop	ghn_shift2
		clc
		ret
ghn_err:
		stc
		ret
GetHexNum	endp
;
;----------------------------------------------------------------------------
;
; procedure : GetNibble
;
;	Convert one nibble (hex digit) in BL into binary
;
;	Retruns binary value in BL
;
;	Returns carry if BL contains non-hex digit
;
;----------------------------------------------------------------------------
;
GetNibble	proc	near
		cmp	bl, '0'
		jb	gnib_err
		cmp	bl, '9'
		ja	is_it_hex
		sub	bl, '0'			; clc
		ret
is_it_hex:
		cmp	bl, 'A'
		jb	gnib_err
		cmp	bl, 'F'
		ja	gnib_err
		sub	bl, 'A'- 10		; clc
		ret
gnib_err:
		stc
		ret
GetNibble	endp
;
;
;============================================================================
;============================================================================
;
;----------------------------------------------------------------------------
;
; procedure : AllocUMB
;
;	Allocate all UMBs and link it to DOS arena chain
;
;----------------------------------------------------------------------------
;
AllocUMB	proc	near
		call	InitAllocUMB		; link in the first UMB
		jc	au_exit			; quit on error
au_next:
		call	umb_allocate		; allocate
		jc	au_coalesce
		call	umb_insert		; & insert till no UMBs
		jmp	short au_next
au_coalesce:
		call	umb_coalesce		; coalesce all UMBs
au_exit:
		ret
AllocUMB	endp
;
;----------------------------------------------------------------------------
;
; procedure : InitAllocUMB
;
;----------------------------------------------------------------------------
;
InitAllocUMB	proc	near

		call	IsXMSLoaded
		jnz	iau_err			; quit on no XMS driver
		mov	ah, 52h
		int	21h			; get DOS DATA seg
		mov	DevDOSData, es		; & save it for later
		mov	ax, 4310h
		int	2fh
		mov	word ptr DevXMSAddr, bx	; get XMS driver address
		mov	word ptr DevXMSAddr+2, es
		cmp	FirstUMBLinked, 0	; have we already linked a UMB?
		jne	@f			; quit if we already did it
		call	LinkFirstUMB		; else link the first UMB
		jc	iau_err
		mov	FirstUMBLinked, 0ffh	; mark that 1st UMB linked
@@:
		clc
		ret
iau_err:
		stc
		ret
InitAllocUMB	endp

;-------------------------------------------------------------------------
;
; Procedure Name	: umb_allocate
;
; Inputs		: DS = data
;
; Outputs		: if UMB available
;				Allocates the largest available UMB and 
;			  	BX = segment of allocated block
;				DX = size of allocated block
;				NC
;			  else 
;				CY
;
; Uses			: BX, DX
;
;-------------------------------------------------------------------------

umb_allocate	proc	near

		push	ax
		mov	ah, XMM_REQUEST_UMB
		mov	dx, 0ffffh		; try to allocate largest
						;   possible
		call	dword ptr DevXMSAddr
						; dx now contains the size of
						; the largest UMB
		or	dx, dx
		jz	ua_err
	
		mov	ah, XMM_REQUEST_UMB
		call	dword ptr DevXMSAddr

		cmp	ax, 1			; Q: was the reqst successful
		jne	ua_err			; N: error

		clc

ua_done:
		pop	ax
		ret		

ua_err:
		stc
		jmp	short ua_done

umb_allocate	endp



;---------------------------------------------------------------------------
;
; Procedure Name	: umb_insert
;
; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
;			: BX = seg address of UMB to be linked in
;			: DX = size of UMB to be linked in paras
;			; DS = data
;
; Outputs		: links the UMB into the arena chain
;
; Uses			: AX, CX, ES, DX, BX
;
;---------------------------------------------------------------------------


umb_insert	proc	near

		push	ds

		mov	ds, [DevDOSData]
		mov	ds, ds:[UMB_ARENA]	; es = UMB_HEAD
		mov	ax, ds
		mov	es, ax

ui_next:
		cmp	ax, bx			; Q: is current block above
						;    new block
		ja	ui_insert     		; Y: insert it
						; Q: is current block the
						;    last
		cmp	es:[arena_signature], arena_signature_end
		jz	ui_append		; Y: append new block to chain
						; N: get next block

		mov	ds, ax			; M005
		call	get_next		; ax = es = next block
		jmp	short ui_next

ui_insert:
	
		mov	cx, ds			; ds = previous arena
		inc	cx			; top of previous block

		sub	cx, bx
		neg	cx			; cx = size of used block
		mov	ds:[arena_signature], arena_signature_normal
		mov	ds:[arena_owner], 8	; mark as system owned
		mov	ds:[arena_size], cx	
		mov	word ptr ds:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		sub	dx, 2			; make room for arena at
						; start & end of new block
		mov	es:[arena_size], dx	
		
; prepare arena at end of new block
	
		add	bx, dx
		inc	bx
		mov	es, bx			; es=arena at top of new block
		inc	bx			; bx=top of new block

						; ax contains arena just above
						; this block
		sub	ax, bx			; ax = size of used block
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

		jmp	short ui_done

ui_append:

						; es = arena of last block	

		add	ax, es:[arena_size]	; ax=top of last block-1 para
		sub	es:[arena_size], 1	; reflect the space we are
						; going to rsrv on top of this 
						; block for the next arena.
		mov	es:[arena_signature], arena_signature_normal

		mov	cx, ax			; cx=top of prev block-1
		inc	ax
		sub	ax, bx			; ax=top of prev block - 
						;    seg. address of new block

		neg	ax

		mov	es, cx			; ds = arena of unused block


		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'

; prepare the arena at start of new block

		mov	es, bx
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system
						; mark as free
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	

ui_done:
		pop	ds
		ret

umb_insert	endp


;
;----------------------------------------------------------------------------
;
;**	umb_coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	cx, di, ds, es
;
;----------------------------------------------------------------------------
;

umb_coalesce	proc	near



		xor	di, di

		mov	es, [DevDOSData]
		mov	es, es:[UMB_ARENA]	; es = UMB_HEAD

uc_nextfree:
		mov	ax, es
		mov	ds, ax
		cmp	es:[arena_owner], di	; Q: is current arena free
		jz	uc_again		; Y: try to coalesce with next block
						; N: get next arena
		call	get_next		; es, ax = next arena
		jc	uc_done
		jmp	short uc_nextfree
uc_again:
		call	get_next		; ES, AX <- next block
		jc	uc_done
uc_check:
		cmp     es:[arena_owner],di	; Q: is arena free
		jnz	uc_nextfree		; N: get next free arena
						; Y: coalesce
		mov     cx,es:[arena_size]      ; cx <- next block size
		inc     cx                      ; cx <- cx + 1 (for header size)
		add     ds:[arena_size],cx      ; current size <- current size + cx
		mov     cl,es:[di]              ; move up signature
		mov     ds:[di],cl
		jmp     short uc_again		; try again
uc_done:
		ret

umb_coalesce	endp

;
;----------------------------------------------------------------------------
;
;**	get_next - Find Next item in Arena
;
;	ENTRY	dS - pointer to block head
;	EXIT	AX,ES - pointers to next head
;		'C' set iff arena damaged
;
;----------------------------------------------------------------------------
;

get_next	proc	near

		cmp	byte ptr ds:[0], arena_signature_end
		je	gn_err

		mov     ax,ds                   ; ax=current block
		add     ax,ds:[arena_size]      ; ax=ax + current block length
		inc     ax                      ; remember that header!
		mov	es, ax
		clc
		ret
gn_err:
		stc
		ret

get_next	endp

;
;----------------------------------------------------------------------------
;
; procedure : LinkFirstUMB
;
;----------------------------------------------------------------------------
;
LinkFirstUMB	proc	near

		call	umb_allocate
		jc	lfu_err

; bx = segment of allocated UMB
; dx = size of UMB

		int	12h			; ax = size of memory
		mov	cl, 6
		shl	ax, cl			; ax = size in paragraphs

		mov	cx, ax			; cx = size in paras
		sub	ax, bx			; ax = - size of unused block

		neg	ax

		sub	cx, 1			; cx = first umb_arena
		mov	es, cx			; es = first umb_arena
	
		mov	es:[arena_signature], arena_signature_normal
		mov	es:[arena_owner], 8	; mark as system owned
					
		mov	es:[arena_size], ax	
		mov	word ptr es:[arena_name], 'CS'


; put in the arena for the first UMB

		mov	es, bx			; es has first free umb seg
		mov	es:[arena_signature], arena_signature_end
		mov	es:[arena_owner], arena_owner_system	
						; mark as free 
		dec	dx			; make room for arena
		mov	es:[arena_size], dx	


		mov	es, [DevDOSData]
		mov	di, UMB_ARENA
		mov	es:[di], cx		; initialize umb_head in DOS
						;  data segment with the arena
						;  just below Top of Mem

; we must now scan the arena chain and update the size of the last
; arena

		mov	di, DOS_ARENA
		mov	es, word ptr es:[di]	; es = start arena
		xor	di, di

	
scan_next:
		cmp	byte ptr es:[di], arena_signature_end
		jz	got_last
	
		mov	ax, es
		add	ax, es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short scan_next

got_last:
		sub	es:[arena_size], 1
		mov	es:[arena_signature], arena_signature_normal
		clc
		ret

lfu_err:
		stc
		ret
LinkFirstUMB	endp

;
;----------------------------------------------------------------------------
;
; procedure : ShrinkUMB
;
;	Shrinks the current UMB in use, so that the unused portions
;	of the UMB is given back to the DOS free mem pool
;
;----------------------------------------------------------------------------
;
		public	ShrinkUMB

ShrinkUMB	proc	near
		cmp	DevUMBAddr, 0
		je	su_exit
		push	es
		push	bx
		mov	bx, DevUMBFree
		sub	bx, DevUMBAddr
		mov	es, DevUMBAddr
		mov	ax, 4a00h
		int	21h
		mov	ax, es
		dec	ax
		mov	es, ax
		mov	word ptr es:[arena_owner], 8
		pop	bx
		pop	es
su_exit:
		ret
ShrinkUMB	endp

;M002 - BEGIN
;
;----------------------------------------------------------------------------
;
; procedure : UnlinkUMB
;
;	Unlinks the UMBs from the DOS arena chain
;
;----------------------------------------------------------------------------
;
		public	UnlinkUMB

UnlinkUMB	proc	near
		push	ds
		push	es
		cmp	FirstUMBLinked, 0
		je	ulu_x			; nothing to unlink
		mov	es, DevDOSData		; get DOS data seg
		mov	ds, es:[DOS_ARENA]
		mov	di, es:[UMB_ARENA]
ulu_next:
		call	get_next
		jc	ulu_x
		cmp	di, ax			; is the next one UMB ?
		je	ulu_found
		mov	ds, ax
		jmp	ulu_next
ulu_found:
                mov     ds:[arena_signature], arena_signature_end
ulu_x:
		pop	es
		pop	ds
		ret
UnlinkUMB	endp

;M002 - END

; =========================================================================
;
ENDIF ; CONFIGPROC
sysinitseg	ends
		end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\romrdlo.asm ===
page	,132
	title	RomDrive physical ROM access routine

	.xlist
	include	biosseg.inc
	include	msgroup.inc
	.list
	assume	cs:bios_data

ifndef		FAKEROMDRIVE
ROMDRIVESEG	equ	0A000h
endif	; FAKEROMDRIVE

	public	xfer_from_rom

;	Entry:
;	       dx:bx  - 32 bit ROM offset of transfer block
;	       es:di  - real mode address where it should go
;	       cx     - count in bytes, guaranteed to have at least 2 zero lsbs
;		         note:  transfer length == 00 means 64K
;

;	EXIT:
;	    If error detected
;		Carry Set
;		   al == error code 8 (sector not found)

xfer_error:
	mov	al,8			; return 'sector not found'
	stc
	ret

ifndef	FAKEROMDRIVE
xfer_from_rom:
	push	ds
	push	si
	mov	ax, ROMDRIVESEG
	mov	ds, ax
	mov	si, bx
	shr	cx,1			; convert count to words
	jnz	not_64k
	or	ch,80h			; force 64k to be 32K words, not zero
not_64k:
	cld
	rep	movsw
	pop	si
	pop	ds
	clc
	ret
else
xfer_from_rom:
;	assume dx is zero for now.

	push	ds
	push	si
	mov	si,offset rom_image
	add	si,bx
	shr	cx,1			; convert count to words
	jnz	not_64k
	or	ch,80h			; force 64k to be 32K words, not zero
not_64k:
	cld
	push	cs
	pop	ds
	rep	movsw
	pop	si
	pop	ds
	clc
	ret

rom_image:
	include	rom8k.inc
endif	; FAKEROMDRIVE

bios_data	ENDS
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\romrdhi.asm ===
page	,132
	title	RomDrive physical ROM access routine

;	This is an extended-memory capable version which uses the
;	  ROM BIOS's Int15(ah=87h) block move function.
;	Note:  This module assumes low 16Meg mapping (286 space only)

;
;----------------------------------------------------------------------------
;
; M071 : Made ROMDRIVEBASE_LO equated to 0000 instead of 00 for more
;	 readability
;
;----------------------------------------------------------------------------
;
;ROMCODE	SEGMENT	byte public
;	assume	cs:ROMCODE
	.xlist
	include	biosseg.inc
	include	msgroup.inc
	.list
	assume	cs:bios_data

IFNDEF	FAKEROM

ROMDRIVEBASE_LO	equ	0000h			; M071
ROMDRIVEBASE_HI	equ	0ech

ELSE

ROMDRIVEBASE_LO	equ	0
ROMDRIVEBASE_HI	equ	0

ENDIF ; FAKEROM

	public	xfer_from_rom

;	Entry:
;	       dx:bx  - 32 bit ROM offset of transfer block
;	       es:di  - real mode address where it should go
;	       cx     - count in bytes, guaranteed to have at least 2 zero lsbs
;		         note:  transfer length == 00 means 64K
;

;	EXIT:
;	    If error detected
;		Carry Set
;		   al == error code 8 (sector not found)

gdts	dw	0,0,0,0		; gdt 0 == dummy
	dw	0,0,0,0		; gdt 1 == GDT seg (Int15 fills in)

	dw	0ffffh		; gdt 2 limit = 65535
src_low	dw	0		; gdt 2 low 16 bits
src_hi	db	0
	db	93h,0,0		; gdt 2 access rights & reserved

	dw	0ffffh		; gdt 3 limit = 65535
dst_low	dw	0		; gdt 3 low 16 bits
dst_hi	db	0
	db	93h,0,0		; gdt 3 access rights & reserved

	dw	0,0,0,0		; gdt 4 == ROM BIOS CODE (Int15 fills in)
	dw	0,0,0,0		; gdt 5 == stack (Int15 fills in)

rombase_low	dw	ROMDRIVEBASE_LO	; point to full ROM address
rombase_high	dw	ROMDRIVEBASE_HI	; as linear address

xfer_from_rom:
	add	bx,rombase_low	; add in ROM base linear address
	adc	dx,rombase_high

IFDEF	FAKEROM

;	****  For debug purposes, we'll also add in the offset to
;		the phony ROM image we load as part of us.  When
;		physical ROM hardware becomes available, the following
;		can be deleted.

	add	bx,offset rom_image
	adc	dx,0
	mov	ax,cs
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1
	push	ax
	and	ax,0fff0h
	add	ax,bx
	mov	src_low,ax		; save low 16 bits of source
	pop	ax
	adc	al,dl
	and	al,0fh		; limit to low meg for simulation
	mov	src_hi,al

;	*this is the end of the debug simulation code*

ELSE
	mov	src_low, bx
	mov	src_hi, dl

ENDIF ; FAKEROM

;	Now calculate and store the destination address

	mov	ax,es
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1
	push	ax
	and	ax,0fff0h
	add	ax,di
	mov	dst_low,ax
	pop	ax
	adc	al,0
	and	al,0fh
	mov	dst_hi,al

	push	es
	push	si
	mov	si,offset gdts
	push	cs
	pop	es
	shr	cx,1			; convert count to words
	jnz	not_64k
	or	ch,80h			; force 64k to be 32K words, not zero
not_64k:
	mov	ah,87h
	int	15h
	pop	si
	pop	es
	mov	al,0
	jnc	no_disk_error
	mov	al,8			; all errors are type 8
no_disk_error:
	ret

IFDEF	FAKEROM
rom_image:
	include	rom8k.inc
ENDIF ; FAKEROM

bios_data	ENDS
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\sysinit1.asm ===
page	,160
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1981-1991
; *                      All Rights Reserved.
; */
	title	bios	system initialization
;
;----------------------------------------------------------------------------
;
; M012 : Changed sysinit so that sysinit does not alloc mem for DOS from DOS
;        Instead it goes ahead and manipulates arena head and makes arena
;        head point to memory immediately above DOS
;
; M022 : Improved method for calling seg_reinit.  Uses a dword pointer 
;	 instead of a bunch of confusing pushes, calls, and patched code.
;
; M024 : Have LoadDOSHiOrLow call TryToMovDOSHi instead of doing all 
;	 the work itself.
;
; M025 : Restructuring to facilitate ROMDOS (and also make the code a 
;	 little smaller): call dos_segreinit before calling AllocFreeMem.
;
; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
;		SYSINIT & transient portion of COMMAND.COM
;
; M067 : Set up the environment ptr to point to NULL when calling exec for
;	 install= command.
;
; M069 : Close NMI window.
;
; I070 : Bypass INT 15h block move in ClrVDISKHeader() for Tortugas & 30-286
;
; M072 : Call Power_Init after DOS HIGH stubs are loaded to enable POWER to
;		hook Int 2f properly
;----------------------------------------------------------------------------
;

MULTI_CONFIG equ 1

break	macro	; dummy empty macro
	endm

	.xlist
	include version.inc
	include biosseg.inc
	include	bpb.inc
	include sysvar.inc
	include dpb.inc
	include curdir.inc
	include pdb.inc
	include exe.inc
	include sf.inc
	include arena.inc
	include syscall.inc
	include devsym.inc
	include ioctl.inc
	include biostruc.inc
	include dossym.inc
	include	dosmac.inc
	include	mult.inc
	include	oemconf.inc
	.list

Bios_Code	segment
	extrn	BCode_start:near
	extrn	BCode_end:near
	extrn	seg_reinit:far

Bios_Code	ends

	.xlist
	include devmark.inc
	include cputype.inc
	.list


true	equ	0ffffh
false	equ	0
cr	equ	13
lf	equ	10
tab	equ	9

;multMULT		equ	4ah
multMULTGETHMAPTR	equ	1
multMULTALLOCHMA	equ	2


; Boot options flags for ROMDOS

ifdef ROMDOS

BF_NoConfig	=	00000001b	; No config.sys processing
BF_DefaultMask	=	00000110b	; Bits to indicate default drive:
BF_DefFloppy	=	00000000b	; 	First floppy drive (00)
BF_DefHard	=	00000010b 	;	First hard drive   (80)
BF_DefROM	=	00000100b	;	ROM drive          (7F)

endif

stacksw equ	true			;include switchable hardware stacks
mycds_size equ	88			; size of curdir_list. if it is not
					;the same, then will generate compile error.

if DEBUG				; BUGBUG - Jeez, remove this!
  dossize equ	0b200h
else
  dossize equ	0a000h
endif

	if	ibmjapver
NOEXEC  equ     TRUE
	else
NOEXEC  equ     FALSE
	endif

;     if mycds_size <> curdirlen,then force a compilatiaon error.

	if	mycds_size ne curdirlen
	%out	!!! sysinit1 compilation failed. different cds size !!!
	.erre	ycds_size eq curdirlen
	endif

	if	not ibmjapver
	extrn	 re_init:far
	endif

	ifdef	TAIWAN
	extrn	cdosinit:near
	endif

;---------------------------------------

Bios_Data	segment 

;equates for main stack and stack initialization program

	if	stacksw

	extrn	NextStack:dword		; Win386 Instance table stuff
	extrn	IT_StackLoc:dword	;  we have to plug in so that our
	extrn	IT_StackSize:word	;  stacks can be instanced

entrysize   equ     8

mincount    equ     8
defaultcount equ    9
maxcount    equ     64

minsize     equ     32
defaultsize equ     128
maxsize     equ     512

allocbyte   equ     0
intlevel    equ     1
savedsp     equ     2
savedss     equ     4
newsp	    equ     6

free	    equ     0
allocated   equ     1
overflowed  equ     2
clobbered   equ     3


;	 external variables in ibmbio for int19h handling rouitne.

	extrn	 int19sem:byte

	irp	   aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
	extrn	 int19old&aa:dword
	endm
	endif


;---------------------------------------
; external variable defined in ibmbio module for multi-track
multrk_on equ	10000000b		;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
multrk_off1 equ 00000000b		;initial value. no "multitrack=" command entered.
multrk_off2 equ 00000001b		;user specified multitrack=off.

	extrn	multrk_flag:word
;
;SR; Win386 present flag
;
	extrn	IsWin386:BYTE
;
;SR; Added for SetFocus routine for WIN386 support
;
         extrn	V86_Crit_SetFocus:far

	extrn	xms:dword		; entry point for xms driver
	extrn	inHMA:byte		; flag meaning we're running high

	extrn	FreeHMAPtr:word
	extrn	MoveDOSIntoHMA:dword
	extrn	SysinitPresent:byte

ifdef ROMDOS
	extrn	DOS_Res:word		; seg addr of dos code ROM
	extrn	BootFlags:word		; boot options
endif

Bios_Data	ends


sysinitseg segment 
	assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

ifdef   MULTI_CONFIG
        extrn   newcmd:byte
        extrn   tmplate:byte
        extrn   config_cmd:byte
        extrn   config_envlen:word
        extrn   config_wrkseg:word
        extrn   query_user:near
        extrn   disable_autoexec:near
        extrn   badcomprmpt:byte
        extrn   commnd2:byte, commnd3:byte, commnd4:byte
endif

	extrn	DevEntry:dword

	ifdef	dblspace_hooks
	extrn	MagicPreload:near
	extrn	MagicPostload:near
	extrn	MagicSetCdss:near
	endif

        extrn   crlfm:byte
	extrn	badcom:byte
	extrn	SI_end:byte
	extrn	condev:byte
	extrn	auxdev:byte
	extrn	prndev:byte
        extrn   commnd:byte, command_line:byte
	extrn	deviceparameters:byte
	extrn	devmark_addr:word
	extrn	setdevmarkflag:byte
IFDEF	CONFIGPROC
	extrn	pathstring:byte			; this is not being referenced
ENDIF ; CONFIGPROC
        extrn   print:near,badmem:byte
	extrn	int24:near
	extrn	mem_err:near

IFDEF	CONFIGPROC
	extrn	doconf:near
	extrn	multi_pass:near 
	extrn	badload:near 
	extrn	error_line:near

	extrn	ShrinkUMB:near
	extrn	UnlinkUMB:near					;M002
ENDIF ; CONFIGPROC

        extrn   toomanydrivesmsg:byte				; M029

IFDEF	POWER
	extrn	Power_Init:near				; M072
ENDIF

	ifdef	dblspace_hooks
	public	NullBackdoor
	public	MagicBackdoor
	endif

	public	current_dos_location
	public	device_list
	public	sysi_country
	public	memory_size
	public	default_drive
	public	buffers
	public	files
	public	num_cds
	public	sysinit
	public	cntryfilehandle

	if	stacksw 		; internal stack information
	public	stack_count
	public	stack_size
	public	stack_addr
	endif

	public	dosinfo
	public	fcbs
	public	keep
	public	confbot
	public	alloclim
	public	zero
	public	sepchr
	public	count
	public	chrptr
	public	org_count
	public	bufptr
	public	memlo
	public	prmblk
	public	memhi
	public	ldoff
	public	area
	public	packet
	public	unitcount
	public	break_addr
	public	bpb_addr
	public	drivenumber
	public	devdrivenum
	public	config_size
	public	install_flag
	public	com_level
	public	cmmt
	public	cmmt1
	public	cmmt2
	public	cmd_indicator
	public	linecount
	public	showcount
	public	buffer_linenum
	public	donotshownum
	public	h_buffers
	public	configmsgflag
IFDEF	CONFIGPROC
	public	do_install_exec
ENDIF ; CONFIGPROC

	public	multi_pass_id
	public	temp_bcode_seg
	public	seg_reinit_ptr

        public toomanydrivesflag			; M029

sysinit$:
	if	stacksw
.sall

;	interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - at level)
;	should follow the standard interrupt sharing scheme which has
;	a standard header structure.
;	fyi, the following shows the relations between
;	the interrupt vector and interrupt level.
; vec(hex)    2  8  9  a  b  c	d  e  70  72  73  74  76  77
; lvl(deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
;	msstack module modifies the following interrupt vectors
;	to meet the standard interrupt sharing standard;
;	  a, b, c, d, e, 72, 73, 74, 76, 77.
;	also, for interrupt level 7 and 15, the firstflag in a standard header
;	should be initialized to indicat whether this interrupt handler is
;	the first (= 80h) or not.  the firstflag entry of int77h's
;	program header is initialized in this module.
;	firstflag is only meaningful for interrupt level 7 and 15.
;

;  user specifies the number of stack elements - default = 9
;						 minimum = 8
;						 maximum = 64
;
;  intercepts asynchronous hardware interrupts only
;
;  picks a stack from pool of stacks and switches to it
;
;  calls the previously saved interrupt vector after pushing flags
;
;  on return, returns the stack to the stack pool
;


; this is a modification of stacks:
; 1. to fix a bug which was causing the program to take up too much space.
; 2. to dispense stack space from hi-mem first rather than low-mem first.
;    . clobbers the stack that got too big instead of innocent stack
;    . allows system to work if the only stack that got too big was the most
;      deeply nested one
; 3. disables nmi interrupts while setting the nmi vector.
; 4. double checks that a nested interrupt didn't get the same stack.
; 5. intercepts ints 70, 72-77 for pc-ats and other future products

		even
		dw	0	; spare field but leave these in order
stackcount	dw	0
stackat 	dw	0
stacksize	dw	0
stacks		dw	0
		dw	0

firstentry	dw	stacks
lastentry	dw	stacks+(defaultcount*entrysize)-entrysize
nextentry	dw	stacks+(defaultcount*entrysize)-entrysize


; these are the individual interrupt handlers

	assume	ds:nothing,es:nothing,ss:nothing

public	int02
public	old02
	old02	dd	0
int02	proc	far

; *********************************************************************
;
; this is special support for the pc convertible / nmi handler
;
;	on the pc convertible, there is a situation where an nmi can be 
;	caused by using the "out" instructions to certain ports.  when this
;	occurs, the pc convertible hardware *guarantees* that **nothing** 
;	can stop the nmi or interfere with getting to the nmi handler.  this
;	includes other type of interrupts (hardware and software), and
;	also includes other type of nmi's.  when any nmi has occured,
;	no other interrtupt (hardware, software or nmi) can occur until
;	the software takes specific steps to allow further interrupting.
;
;	for pc convertible, the situation where the nmi is generated by the
;	"out" to a control port requires "fixing-up" and re-attempting.  in
;	otherwords, it is actually a "restartable exception".  in this
;	case, the software handler must be able to get to the stack in
;	order to figure out what instruction caused the problem, where
;	it was "out"ing to and what value it was "out"ing.  therefore,
;	we will not switch stacks in this situation.  this situation is
;	detected by interrogating port 62h, and checking for a bit value
;	of 80h.  if set, *****do not switch stacks*****.
;
; *********************************************************************

	push	ax
	push	es
	mov	ax,0f000h
	mov	es,ax
	cmp	byte ptr es:[0fffeh],mdl_convert	;check if convertible
	pop	es
	jne	normal02

	in	al,62h
	test	al,80h
	jz	normal02

special02:
	pop	ax
	jmp	dword ptr old02

normal02:
	pop	ax
	call	do_int_stacks
	dw	old02

int02	endp

public	int08
public	old08
old08	dd	0
int08	proc	far
	call	do_int_stacks
	dw	old08
int08	endp

public	int09
public	old09
old09	dd	0
int09	proc	far

; keyboard interrupt must have a three byte jump, a nop and a zero byte
; as its first instruction for compatibility reasons

	ifidn	<09>,<09>
	jmp	short keyboard_lbl
	nop
	db	0
keyboard_lbl	label	near
	endif

	call	do_int_stacks
	dw	old09
int09	endp

public	int70
public	old70
old70	dd	0
int70	proc	far
	call	do_int_stacks
	dw	old70
int70	endp

	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
public	int&a
public	old&a
public	firstflag&a
int&a	proc	far
	jmp	short entry_int&a&_stk
old&a	dd	  0		;forward pointer
	dw	  424bh 	;compatible signature for int. sharing
firstflag&a db   0		;the firstly hooked.
	jmp	short intret_&a	;reset routine. we don't care this.
	db	7 dup (0)	;reserved for future.
entry_int&a&_stk:
	call	do_int_stacks
	dw	old&a
intret_&a:
	iret
int&a	endp
	endm

;********************************************************************
;common routines

;	do interrupt stack switching.  the fake return address holds
;	  a pointer to the far-pointer of the actual interrupt
;	  service routine

do_int_stacks:
	push	ax
	push	bp
	push	es
	mov	es, cs:[stacks+2]	; get segment of stacks

	mov	bp,nextentry		; get most likely candidate
	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; grab the entry
	cmp	al,free 		; still avail?
	jne	notfree02

	sub	nextentry,entrysize	; set for next interrupt

found02:
	mov	es:word ptr savedsp[bp],sp		; save sp value
	mov	es:word ptr savedss[bp],ss		; save ss also

	mov	ax,bp			; temp save of table offset


	mov	bp,es:word ptr newsp[bp]		; get new sp value
	cmp	es:[bp],ax		; check for offset into table
	jne	foundbad02

	mov	ax,es			; ax = new stack segment
	mov	es,bp			; es = new stack offset
	mov	bp,sp			;
	mov	bp,[bp+6]		; get offset of interrupt vector
	mov	ss,ax			;
	mov	sp,es			; ss:sp = new stack
	mov	es,ax			; restore es
	mov	bp,cs:[bp]		; get pointer of interrupt vector

	pushf				; go execute the real interrupt handler
	call	cs:dword ptr [bp]	; call the old interrupt vector

	mov	bp,sp			; retrieve the table offset for us
	mov	bp,es:[bp]		;  but leave it on the stack
	mov	ss,es:word ptr savedss[bp]		; get old stack back
	mov	sp,es:word ptr savedsp[bp]


	mov	es:byte ptr allocbyte[bp],free		; free the entry
	mov	nextentry,bp		; setup to use next time

newerror02:
	pop	es
	pop	bp			; saved on entry
	pop	ax			; saved on entry
	add	sp,2			; lose the fake return address

intret_02:
	iret				; done with this interrupt

notfree02:
	cmp	al,allocated		; error flag
	je	findnext02		;  no, continue
	xchg	es:byte ptr allocbyte[bp],al		;  yes, restore error value

findnext02:
	call	longpath
	jmp	found02

foundbad02:
	cmp	bp,firstentry
	jc	findnext02
	mov	bp,ax			; flag this entry
	mov	es:byte ptr allocbyte[bp],clobbered
	jmp	findnext02		; keep looking
longpath:
	mov	bp,lastentry		; start with last entry in table

lploopp:
	cmp	es:byte ptr allocbyte[bp],free		; is entry free?
	jne	inuse			;  no, try next one

	mov	al,allocated
	xchg	es:byte ptr allocbyte[bp],al		; allocate entry
	cmp	al,free 		; is it still free?
	je	found			;  yes, go use it

	cmp	al,allocated		; is it other than allocated or free?
	je	inuse			;  no, check the next one

	mov	es:byte ptr allocbyte[bp],al		;  yes, put back the error state

inuse:
	cmp	bp,firstentry
	je	fatal
	sub	bp,entrysize
	jmp	lploopp

found:
	ret

fatal	proc	near
	push	ds
	mov	ax, 0f000h		;look at the model byte
	mov	ds, ax
	cmp	ds:byte ptr [0fffeh], mdl_convert ;convertible?
	pop	ds
	jne	skip_nmis

	mov	al,07h				; disable pc convertible nmis
	out	72h,al

skip_nmis:
	cli					; disable and mask
	mov	al,0ffh 			;   all other ints
	out	021h,al
	out	0a1h,al

	mov	si,cs
	mov	ds,si
	mov	si,offset fatal_msg
;SR;
;   We set all foci to this VM to issue the stack failure message
;
	push	ax
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	test	ds:[IsWin386],1
	pop	ds
	pop	ax
	assume	ds:nothing
	jz	fatal_loop	;win386 not present, continue

	call	V86_Crit_SetFocus	;set focus to this VM
;
;SR; We do not bother about the returned status of this call. 
;

fatal_loop:
	lodsb
	cmp	al,'$'
	je	fatal_done

	mov	bl,7
	mov	ah,14
	int	010h			; whoops, this enables ints
	jmp	fatal_loop

fatal_done:
	jmp	fatal_done
fatal	endp

	include msbio.cl5		;fatal stack error message
.xall
	public	endstackcode
endstackcode label  byte
	endif

sysinit:
	jmp	goinit
;
;----------------------------------------------------------------------------
;
DDHighInfo	struc
 ddhigh_CSegPtr	dd	?		; pointer to code segment to be relocated
 ddhigh_CSegLen	dw	?		; length of code segment to be relocated
 ddhigh_CallBak	dd	?		; pointer to the call back routine
DDHighInfo	ends

		public	runhigh
runhigh		db	0h


dosinfo	dd	0		; address of the DOS Sysini Variables

dos_temp_location label	dword
dosinit	dw	0
current_dos_location dw 0

device_list dd	0

sysi_country dd	0			; pointer to country table in dos

dos_segreinit	dw	0,0		; room for dword

lo_doscod_size	dw	0		; dos code size when in low mem
hi_doscod_size	dw	0		; dos code size when in HMA

def_php		dw	0


; M022--
; pointer for calling into Bios_Code for re-initializing segment values.
;  call with ax = new segment for Bios_Code.  Notice that we'll
;  call it in its temporary home, cuz seg_reinit won't get moved to
;  the new home.

seg_reinit_ptr	label dword

		dw	offset Bios_Code:seg_reinit
temp_bcode_seg	dw	Bios_Code


fake_floppy_drv db 0			;set to 1 if this machine
					;does not have any floppies!!!

;variables for stack initialization program.

ifdef		COPYCDS
		public	newnum_cdss
oldnum_cdss	dw	?		; number of DPB/CDSs built so far
newnum_cdss	dw	?		; number of CDSs to be built for the
					;  newly initialized device
endif ; COPYCDS

	if	stacksw
stack_count dw	    defaultcount
stack_size  dw	    defaultsize
stack_addr  dd	    0
	endif

; various default values

memory_size	dw	1
RPLMemTop	dw	0
default_drive	db	0		;initialized by ibminit.
buffers 	dw	DEFAULT_BUFFERS	; initialized during buffer allocation
h_buffers	dw	0		; # of the heuristic buffers. initially 0.
singlebuffersize dw	?		; maximum sector size + buffer header

files	db	DEFAULT_FILES		; enough files for pipe
fcbs	db	DEFAULT_FCBS		; performance for recycling
keep	db	0			; keep original set
num_cds db	DEFAULT_CDSS		; 5 net drives
confbot dw	?
alloclim dw	?
top_of_cdss	dw	?
DirStrng db	"A:\",0                 ; string for the root directory of a drive
zero	db	0
sepchr	db	0
linecount dw    0                       ; line count in config.sys
showcount db    '     ',cr,lf,'$'       ; used to convert linecount to ascii.
buffer_linenum dw 0			; line count for "buffers=" command if entered.

sys_model_byte db 0ffh			;model byte used in sysinit
sys_scnd_model_byte db 0		;secondary model byte used in sysinit

buf_prev_off dw 0

        if      not NOEXEC
comexe  exec0   <0,command_line,default_drive,zero>
	endif

;------------------------------------------------------------------
;	variables for install= command.

multi_pass_id	db	0		; parameter passed to multi_pass
					;  indicating the pass number
					; 0 - do scan for DOS=HIGH/LOW
					; 1 - load device drivers
					; 2 - was to load IFS
					;      now it is unused
					; 3 - do install=
					; >3 - nop
install_flag	dw	0

have_install_cmd equ	00000001b	; config.sys has install= commands
has_installed	equ	00000010b	; sysinit_base installed.

config_size	dw	0		; size of config.sys file. set by sysconf.asm
sysinit_base_ptr dd	0		; pointer to sysinit_base
sysinit_ptr	dd	0		; returning addr. from sysinit_base
checksum	dw	0		; used by sum_up

ldexec_fcb	db	20 dup (' ')	;big enough
ldexec_line	db	0		;# of parm characters
ldexec_start	db	' '
ldexec_parm	db	80 dup (0)

instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>

;------------------------------------------------------------------
;variables for comment=

com_level	db	0		;level of " " in command line
cmmt		db	0		;length of comment string token
cmmt1		db	0		;token
cmmt2		db	0		;token
cmd_indicator	db	?
donotshownum	db	0

;------------------------------------------------------------------
count		dw	0
org_count	dw	0
chrptr		dw	0
cntryfilehandle dw	0
old_area	dw	0
impossible_owner_size dw 0		; paragraph
;------------------------------------------------------------------

bucketptr label dword
bufptr	label	dword			;leave this stuff in order!
memlo	dw	0
prmblk	label	word
memhi	dw	0
ldoff	dw	0
area	dw	0

; Following is the request packet used to call INIT routines for 
; all device drivers.  Some fields may be accessed individually in
; the code, and hence have individual labels, but they should not
; be separated.

packet	db	24			; was 22
	db	0
	db	0			;initialize code
	dw	0
	db	8 dup (?)

unitcount	db	0
break_addr	dd	0
bpb_addr	dd	0
devdrivenum	db	0 
configmsgflag	dw	0		; used to control "error in config.sys line #" message

; end of request packet

drivenumber	db	0

toomanydrivesflag db    0               ;>24 fixed disk partitions flag   ; M029 

BCodeSeg	dw	Bios_Code

	ifdef	dblspace_hooks
MagicBackdoor	dd	0

NullBackdoor	proc	far

	ret				; prevent hang with bogus backdoor

NullBackdoor	endp
	endif

;SR;
; This is the communication block between the DOS and the BIOS. It starts at
;the SysinitPresent flag. Any other data that needs to be communicated 
;to the DOS should be added after SysinitPresent. The pointer to this block
;is passed to DOS as part of the DOSINIT call.
;

BiosComBlock	dd	Bios_Data:SysinitPresent

tempstack db	80h dup (?)

goinit:

ifdef JAPAN
	mov	ah,50h			; set crt mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	10h
	mov	ah,50h			; set keyboard mode
	mov	al,0
	mov	bx,81			; for JAPAN
	int	16h
endif

; before doing anything else,let's set the model byte

	mov	ah,0c0h 		;get system configuration
	int	15h
	jc	no_rom_config

	cmp	ah,0			; double check
	jne	no_rom_config

	mov	al,es:[bx.bios_sd_modelbyte]
	mov	cs:[sys_model_byte],al
	mov	al,es:[bx.bios_sd_scnd_modelbyte]
	mov	cs:[sys_scnd_model_byte],al
	jmp	short move_myself

no_rom_config:				; old rom
	mov	ax,0f000h
	mov	ds,ax
	mov	al,byte ptr ds:[0fffeh]
	mov	cs:[sys_model_byte],al ;set the model byte.

check_for_fake_floppy:			;entry point for rom_config above
	int	11h			;check equipment flag
 
	if	IBMCOPYRIGHT

;************************************************************************
; p????
;
; the following fix for lloyds of london does work correctly but it
; causes a regression in the ripl machine. machines with no ipl
; diskette will have ax bit 0 = 0. the cds structure is stomped on
; later to insure that a: is a invalid drive. this is where ripl fails.
; it wants the a: drive to be valid because it intercepts requests
; to the drive and returns info from it's memory image. but,if ibmbio
; finds no ipl drive,it tells ibmdos never to request anything from
; that drive.
;
; for the meantime,we will take out the support for lloyds of london
; by setting up a false condition. (ie. ax=1).
; (they have a special build,dos 3.31 to use). architecture needs to
; get the ripl machine to set bit 0 to say that there is in fact an
; virtual ipl diskette.
;
; the next 4 lines of code should be removed when the ripl people have
; gotten their act together. the unique identifier is used in case in
; the future,we want to dynamically patch ibmbio to work on the lloyds
; machine. the program could be written to scan for:
;
;	ebh,03h,52h,50h,53h,0dh,01h
;	 "jmp"	"R" "P" "S"  or  1
;
; and dynamically change the 0dh,01h to 90h,90h. note: that this string
; must be changed twice in ibmbio.com.
;************************************************************************

	jmp	short set_bit		; jmup over db
	db	"RPS"			; unique identifier

set_bit:
	or	ax,1			; turn on the ipl bit

	endif	; conditional on IBMCOPYRIGHT

	test	ax,1			;have any floppies?
	jnz	move_myself		;yes,normal system

;
; Some ROM BIOSs lie that there are no floppy drives. Lets find out
; whether it is an old ROM BIOS or a new one
;
; WARNING !!!
;
; This sequence of code is present in MSINIT.ASM also. Any modification
; here will require an equivalent modification in MSINIT.ASM also
;
	push	es

	xor	cl, cl	
	mov	ah, 8			; get disk parameters
	mov	dl, 0			; of drive 0
	int	13h

	pop	es

	jc	move_myself		; if error lets assume that the
					;  ROM BIOS lied
	cmp	cl, 0			; double check (max sec no cannot be 0
	je	move_myself

	or	dl, dl			; number of flp drvs == 0?
	jnz	move_myself

	mov	cs:fake_floppy_drv,1	;set fake flag.


;	set fake_floppy_drv if there is no diskette drives in this machine.
;	execute the equipment determination interrupt and then
;	check the returned value to see if we have any floppy drives
;	if we have no floppy drive we set cs:fake_floppy_drv to 1
;	see the at tech ref bios listings for help on the equipment
;	flag interrupt (11h)

move_myself:
	cld			; set up move
	xor	si,si
	mov	di,si

	if	msver
	mov	cx,cs:[memory_size]
	cmp	cx,1		; 1 means do scan
	jnz	noscan
	mov	cx,2048		; start scanning at 32k boundary
	xor	bx,bx

memscan:inc	cx
	jz	setend
	mov	ds,cx
	mov	al,[bx]
	not	al
	mov	[bx],al
	cmp	al,[bx]
	not	al
	mov	[bx],al
	jz	memscan
setend:
	mov	cs:[memory_size],cx
	endif

	if	ibmver or ibmjapver
	mov	cx,cs:[memory_size]
	endif

noscan: 				; cx is mem size in para
;
;	cas -- a) if we got our memory size from the ROM, we should test it
;		  before we try to run.
;	       b) in any case, we should check for sufficient memory and give
;		  an appropriate error diagnostic if there isn't enough
;
	push	cs
	pop	ds

;	cas note:  It would be better to put dos + bios_code BELOW sysinit
;	  that way it would be easier to slide them down home in a minimal
;	  memory system after sysinit.  As it is, you need room to keep
;	  two full non-overlapping copies, since sysinit sits between the
;	  temporary home and the final one.  the problem with doing that
;	  is that sys*.asm are filled with "mov ax,cs, sub ax,11h" type stuff.

	dec	cx			; one para for an arena at end of mem
					; in case of UMBs
;M056 - BEGIN
;
;------ Check if an RPL program is present at TOM and do not tromp over it
;
	xor	bx, bx
	mov	es, bx
	mov	bx, es:[2fh*4]
	mov	es, es:[2fh*4+2]
	cmp	word ptr es:[bx+3], 'PR'
	jne	NoRPL
	cmp	byte ptr es:[bx+5], 'L'
	jne	NoRPL

	mov	dx, cx			; get TOM into DX
	push	dx
	mov	ax, (multMULT shl 8) + multMULTRPLTOM
	int	2fh			; Get new TOM from any RPL
	pop	ax
	mov	cx, dx
	cmp	dx, ax
	je	NoRPL
	mov	RPLMemTop, dx
	dec	cx
NoRPL:
;
;M056 - END
;
	mov	ax,offset SI_end	; need this much room for sysinit
	call	off_to_para
	sub	cx,ax

; we need to leave room for the DOS and (if not ROMDOS) for the BIOS
; code above sysinit in memory
;
	sub	cx,dossize/16		; leave this much room for DOS

ifndef ROMDOS
	mov	ax,offset BCode_end
	call	off_to_para		; leave this much room for BIOS code
	sub	cx,ax
endif ; ROMDOS

	mov	es,cx			; offset where sysinit will be located

	mov	cx,offset SI_end
	shr	cx,1			;divide by 2 to get words
	rep	movsw			;relocate sysinit

	push	es			; push relocated segment
	mov	ax,offset sysin
	push	ax			; push relocated entry point

	retf				; far jump to relocated sysinit


;	move the dos to its proper location

sysin:
	assume	ds:nothing,es:nothing,ss:nothing

	mov	ax, Bios_Data		; point DS to BIOS data
	mov	ds, ax

	assume	ds:Bios_Data

	mov	word ptr MoveDOSIntoHMA+2, cs	; set seg of routine to move DOS
	mov	SysinitPresent, 1	; flag that MoveDOSIntoHMA can be called

; first move the MSDOS.SYS image up to a harmless place 
; on top of our new sysinitseg

	mov	ax,offset SI_end	; how big is sysinitseg?
	call	off_to_para
	mov	cx,cs			; pick a buffer for msdos above us
	add	ax,cx
	mov	es,ax
	xor	si,si
	mov	di,si

	mov	ds,[current_dos_location] ; where it is (set by msinit)

	assume	ds:nothing

	mov	cx,dossize/2
	rep	movsw
	mov	[current_dos_location],es

; The DOS code is ORGed at a non-zero value to allow it to be located in
; HIMEM.  Thus, the DOS segment location must be adjusted accordingly.
; If this is ROMDOS, however, only the init code is loaded into RAM, so
; this ORG is not done.  The entry point is at offset zero in the segment.

ifndef ROMDOS

	mov	ax,ds:word ptr 3	; get offset of dos
	mov	[dosinit],ax		; that's the entry point offset
	call	off_to_para		; subtract this much from segment
	sub	[current_dos_location],ax
else
	mov	[dosinit], 0		; entry to init is at zero

endif ; ROMDOS


; If this is not ROMDOS, then the BIOS code is moved to the top of memory
; until it is determined whether it will be running in HIMEM or not.

ifndef ROMDOS

; now put Bios_Code up on top of that.  Assume Bios_Code + dossize < 64k

	mov	ax,es
	add	ax,dossize/16		; get paragraph of end of dos
	mov	es,ax
	xchg	ax,temp_bcode_seg	; swap with original home of Bios_Code
	mov	ds,ax			; point to loaded image of Bios_Code

	assume	ds:nothing

	mov	si,offset BCode_start
	mov	di,si
	mov	cx,offset BCode_end
	sub	cx,si
	shr	cx,1
	rep	movsw			; move Bios_Code into place

	mov	ax,es			; tell it what segment it's in
	call	[seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)

endif	; not ROMDOS


;	now call dosinit while it's in its temporary home

	les	di,cs:[BiosComBlock]	; ptr to BIOS communication block
	lds	si,cs:[device_list]	; set for call to dosinit

	assume	ds:nothing, es:nothing

	mov	dx,cs:[memory_size]	; set for call to dosinit

	cli
	mov	ax,cs
	mov	ss,ax

;M069 start
locstack =      (offset $ - offset sysinit$) and 0FFFEh
        mov     sp, locstack            ; set stack
        
;M069 - ensure no NMI window exists here
;	align	2		; assembler wouldn't let me do an "and 0fffeh"
;locstack label	byte		;  on the mov sp,offset locstack
;	mov	sp,offset locstack	; set stack


	sti


; This call to DOSINIT will relocate the DOS data from its present location
; at the top of memory, to its final location in low memory just above the
; BIOS data.  It will then build important DOS data structures in low 
; memory following the DOS data.  It returns (among many other things) the
; new starting address of free memory.

	call	[dos_temp_location]	; call dosinit
					;es:di -> sysinitvars_ext

	mov	[def_php],ds		; save pointer to PSP
	mov	[hi_doscod_size],ax	; size of doscode (including exepatch)
	mov	[lo_doscod_size],cx	; (not including exepatch)
	mov	[dos_segreinit],dx	; save offset of segreinit

	mov	ax,word ptr es:[di.sysi_initvars]
	mov	word ptr dosinfo,ax
	mov	ax,word ptr es:[di.sysi_initvars+2]
	mov	word ptr [dosinfo+2],ax ;set the sysvar pointer

	mov	ax,word ptr es:[di.sysi_country_tab]
	mov	word ptr [sysi_country],ax
	mov	ax,word ptr es:[di.sysi_country_tab+2]
	mov	word ptr [sysi_country+2],ax ;set the sysi_country pointer

	mov	es,[current_dos_location]	; give dos its temporary loc.
	mov	[dos_segreinit+2],es
;
;M056 - BEGIN
;
;------ Cover up RPL code with an arena
;
	cmp	cs:RPLMemTop, 0
	je	NoRPLArena
;
;------ alloc all memory
;
	mov	bx, 0ffffh
	mov	ah, 48h
	int	21h
	mov	ah, 48h
	int	21h

	mov	es, ax				; get it into Es and save it
	push	es
;
;------ resize upto RPL mem
;
	sub	ax, cs:RPLMemTop
	neg	ax
	dec	ax
	mov	bx, ax
	mov	ah, 4ah
	int	21h
;
;------ allocate the free (RPL MEM)
;
	mov	bx, 0ffffh
	mov	ah, 48h
	int	21h
	mov	ah, 48h
	int	21h
;
;----- mark that it belongs to RPL
;
	dec	ax
	mov	es, ax
	mov	word ptr es:[arena_owner], 8
	mov	word ptr es:[arena_name], 'PR'
	mov	word ptr es:[arena_name+2], 'L'
	mov	word ptr es:[arena_name+4], 0
	mov	word ptr es:[arena_name+6], 0

        pop     es                      ; get back ptr to first block
        mov     ah, Dealloc             ; and free it
	int	21h
NoRPLArena:
;
;M056 - END
;
	les	di,dosinfo		;es:di -> dosinfo

	clc				;get the extended memory size

;	execute the get extended memory size subfunction in the bios int 15h
;	if the function reports an error do nothing else store the extended
;	memory size reported at the appropriate location in the dosinfo buffer
;	currently pointed to by es:di.	use the offsets specified in the
;	definition of the sysinitvars struct in inc\sysvar.inc


	mov	ah,88h
	int	15h			;check extended memory size
	jc	no_ext_memory
	mov	es:[di].sysi_ext_mem,ax ;save extended memory size
	or	ax, ax
	jz	no_ext_memory
	call	ClrVDISKHeader
no_ext_memory:
	mov	ax,es:[di.sysi_maxsec]	; get the sector size
	add	ax,bufinsiz		; size of buffer header
	mov	[singlebuffersize],ax	; total size for a buffer

	mov	al,default_drive	; get the 1 based boot drive number set by msinit
	mov	es:[di.sysi_boot_drive],al ; set sysi_boot_drive

; determine if 386 system...

	get_cpu_type			; macro to determine cpu type
	cmp	ax,2			; is it a 386?
	jne	not_386_system		; no: don't mess with flag
	mov	es:[di.sysi_dwmove],1
not_386_system:
	mov	al,es:[di.sysi_numio]
	mov	drivenumber,al		; save start of installable block drvs

	mov	ax,cs
	sub	ax,11h			; room for PSP we will copy shortly
	mov	cx,[singlebuffersize]	; temporary single buffer area
	shr	cx,1			
	shr	cx,1			; divide size by 16...
	shr	cx,1
	shr	cx,1			; ...to get paragraphs...
	inc	cx			; ... and round up

;	cas note:  this unorthodox paragraph rounding scheme wastes a byte if
;	  [singlebuffersize] ever happens to be zero mod 16.  Could this
;	  ever happen?  Only if the buffer overhead was zero mod 16, since
;	  it is probably safe to assume that the sector size always will be.
;
;	 mohans also found a bug in CONFIG.SYS processing where it replaces
;	  EOF's with cr,lf's, without checking for collision with [confbot].
;	  perhaps the extra byte this code guarantees is what has kept that
;	  other code from ever causing a problem???

	sub	ax,cx
	mov	[top_of_cdss],ax	; temp "unsafe" location

;	chuckst -- 25 Jul 92 -- added code here to pre-allocate space
;	for 26 temporary CDSs, which makes it easier to use alloclim
;	for allocating memory for MagicDrv.

	push	es			; preserve pointer to dosinfo
	push	di
	mov	cx,ax			; save pointer for buffer

;	now allocate space for 26 CDSs

	sub	ax,((26 * (size curdir_list)) + 15)/16
	mov	[alloclim],ax		; init top of free memory pointer
	mov	[confbot],ax		; init this in case no CONFIG.SYS

; setup and initialize the temporary buffer at cx

	les	di,es:[di.sysi_buf]	;get the buffer chain entry pointer
	mov	word ptr es:[di.Dirty_Buff_Count],0
	mov	word ptr es:[di.Buff_Queue],0
	mov	word ptr es:[di.Buff_Queue+2],cx
	mov	es,cx
	xor	ax,ax
	mov	di,ax			;es:di -> single buffer

	mov	es:[di.buf_next],ax	;points to itself
	mov	es:[di.buf_prev],ax	;points to itself

	mov	word ptr es:[di.buf_id],00ffh ;free buffer,clear flag
	mov	word ptr es:[di.buf_sector],0
	mov	word ptr es:[di.buf_sector+2],0

	pop	di			; restore pointer to DOSINFO data
	pop	es

	push	cs
	pop	ds

	assume	ds:sysinitseg

ifdef	COPYCDS
	mov	al, 1			; ask tempcds to build CDSs from
					;  scratch
endif ; COPYCDS

	call	tempcds 		; set up cdss so re_init and sysinit
					;   can make disk system calls
	assume	ds:nothing		; tempcds trashes ds

	mov	ds,[def_php]		; retreive pointer to PSP returned by DOSINIT

	if	not ibmjapver
	call	re_init			; re-call the bios
	endif

	sti				; ints ok
	cld				; make sure

; dosinit has set up a default "process" (php) at ds:0. we will move it out
; of the way by putting it just below sysinit at end of memory.

	mov	bx,cs
	sub	bx,10h
	mov	es,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw

	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it

	push	ds			; preserve DS returned by DOSINIT

ifdef	ROMDOS
	mov	ds, bx			; DS=PSP
	mov	dx, 80h			; set default DTA to PSP:80h
	mov	ah, set_dma		;  reqd for doing ROM_FIND_FIRST
	int	21h			;  later when we look for shell
endif ; ROMDOS

	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

	; set up temp. critical error handler
	mov	dx,offset int24 	;set up int 24 handler
	mov	ax,(set_interrupt_vector shl 8) or 24h
	int	21h

        cmp     byte ptr [TooManyDrivesFlag],0  ;Q: >24 partitions? M029
        je      no_err                          ;  N: continue      M029
        mov     dx,offset TooManyDrivesMsg      ;  Y: print error message M029
        call	print                           ;		    M029
no_err:						;		    M029

	pop	ds			; start of free memory

	assume	ds:nothing

	mov	dl,[default_drive]
	or	dl,dl
	jz	nodrvset		; bios didn't say
	dec	dl			; a = 0
	mov	ah,set_default_drive
	int	21h			;select the disk

nodrvset:

;
; Process the CONFIG.SYS file 
;
ifdef ROMDOS

	; see if we need to skip CONFIG.SYS processing

	push	ds			; preserve current DS
	mov	ax, Bios_Data		; get bios data segment
	mov	ds, ax			; point ds to bios data
	assume	ds:Bios_Data

	mov	ax, BootFlags		; get boot flags
	test	ax, BF_NoConfig		; is no config bit set?
	pop	ds			; restore former DS
	assume	ds:nothing
	jz	ProcessConfig		; no, process config.sys

	; Skip config.sys processing

;M072 BEGIN
ifdef POWER
; No Config.sys to be processed
; initialise POWER 

	call	Power_Init

endif
;M072 END

        mov     ax,(char_oper shl 8)    ; get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

	call	AllocFreeMem		; allocate free memory
	call	endfile			; setup fcbs, files, buffers etc

	jmp	short ConfigDone

endif ; ROMDOS

	
ProcessConfig:

	ifdef	dblspace_hooks
	mov	cs:word ptr MagicBackdoor,offset NullBackdoor
	mov	cs:word ptr MagicBackdoor+2,cs

	call	AllocFreeMem		; get the largest free block from DOS
	call	MagicPreload		; **** PRE-LOAD MAGICDRV!!! ****
	or	ax,ax			; error?
	jnz	PreloadFailed

	mov	es,cs:[area]
	mov	bx,cs:[memhi]
	sub	bx,cs:[area]		; get desired block size in paras
	mov	ah,setblock
	int	21h
	mov	ax,es
	dec	ax
	mov	es,ax			; point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data

;	BUGBUG -- 3 Aug 92 -- chuckst -- Device drivers like PROTMAN$ (part
;					 of Microsoft's networking products)
;					 assume that their arena is the first
;					 one.  Therefore, we must remove
;					 MagicDrv from the arena list.  The
;					 problem with this is that MagicDrv's
;					 stub will not show up in a MEM
;					 listing.

	mov	ax,es			; get Magicdrv arena
	add	ax,es:word ptr [3]	; get MCB length
	inc	ax			; get addr of next MCB
	les	si,dosinfo		; get to arena header
	mov	es:word ptr [si-2],ax	; store that

	jmp	short PreloadCommon

PreloadFailed:
	mov	ah,Dealloc		; free the block if no load
	mov	es,cs:[area]
	int	21h

PreloadCommon:
	endif


ifndef	TAIWAN

IFDEF	CONFIGPROC
	call	doconf			;do pre-scan for dos=high/low
ELSE
	mov	ax,(char_oper shl 8)	;get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

ENDIF ; CONFIGPROC

else	; taiwan

	call	chkoemlocaldrv
	mov	cs:oemdriverinst,ax
	call	cdosinit
	push	es
	push	bx

	pop	bx
	pop	es
	call	maketempvector		;make dummy int service routine

	call	doconf			;do pre-scan for dos=high/low

	call	chklocalexist		;check if local dev drv exist
					;if not found,system halt
	call	recovercsiint		;recover csi interrupt vector
endif	; taiwan

; Now, if this is not romdos, we decide what to do with the DOS code.
; It will either be relocated to low memory, above the DOS data structures,
; or else it will be located in HiMem, in which case a stub with the DOS
; code entry points will be located in low memory.  Dos_segreinit is used
; to tell the DOS data where the code has been placed, and to install the
; low memory stub if necessary.  If the DOS is going to go into HiMem, we
; must first initialize it in its present location and load the installable
; device drivers.  Then, if a HiMem driver has been located, we can actually
; relocate the DOS code into HiMem.
;
; For ROMDOS, if DOS=HIGH is indicated, then we need to call dos_segreinit
; to install the low memory stub  (this must be done before allowing any
; device drivers to hook interrupt vectors).  Otherwise, we don't need to 
; call dos_segreinit at all, since the interrupt vector table has already 
; been patched.

; M025 begin

	cmp	runhigh, 0		; Did user choose to run low ?
	je	dont_install_stub	; yes, don't install dos low mem stub
;
;------ user chose to load high
;

ifndef ROMDOS

	mov	es,[current_dos_location]	; give dos its temporary loc.

else

	mov	ax, Bios_Data		; get bios data segment
	mov	es, ax			; point es to bios data
	assume	es:Bios_Data
	mov	es, [DOS_Res]		; get DOS resident code segment
	assume	es:nothing

endif ; ROMDOS

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit
	jmp	short do_multi_pass
	
;
;------ User chose to load dos low
;
dont_install_stub:

ifndef ROMDOS
	xor	bx, bx			; M012
					;  don't use int 21 call to alloc mem

	call	MovDOSLo		; move it !


	mov	ax, 1			; dont install stub
	mov	es, current_dos_location; set_dos_final_position set it up
	call	dword ptr dos_segreinit	; inform dos about new seg

endif ; ROMDOS

do_multi_pass:

; M072 BEGIN
ifdef POWER
; If DOS=HIGH was specified, stubs for int 2f would have already been loaded
; by now and so it safe to initialise POWER.
; It is done here so that POWER hooks int 2f after DOS puts its int2f stub
; and before any other CONFIG.SYS device/tsr hooks int 2f.

	call	Power_Init

endif
; M072 END

	call	AllocFreeMem		; allocate all the free mem
					;  & update [memhi] & [area]
					; start of free memory.

	ifdef	dblspace_hooks
	mov	bx,0			; magic backdoor to place int hooks
	call	cs:MagicBackdoor
	endif

; M025 end

IFDEF	CONFIGPROC
; Now, process config.sys some more.  
; Load the device drivers and install programs

	inc	cs:multi_pass_id	; multi_pass_id = 1
	call	multi_pass		; load device drivers
	call	ShrinkUMB
	call	UnlinkUMB		; unlink all UMBs	;M002
	inc	cs:multi_pass_id	; multi_pass_id = 2
	call	multi_pass		; was load ifs (now does nothing)
ENDIF ; CONFIGPROC

	ifdef	dblspace_hooks
	call	MagicPostload		; make sure Magicdrv is final placed
	endif

	call	endfile			; setup fcbs, files, buffers etc

	ifdef	dblspace_hooks
	call	MagicSetCdss		; disable CDSs of reserved drives
	endif

;
;Reset SysinitPresent flag here. This is needed for the special fix for lying
;to device drivers. This has been moved up to this point to avoid problems 
;with overlays called from installed programs
;
	mov	ax,Bios_Data
	mov	es,ax			; point ES to bios data

	assume	es:Bios_Data

	mov	es:SysinitPresent,0	; clear SysinitPresent flag

IFDEF	CONFIGPROC
	test	install_flag,have_install_cmd ; are there install commands?
	jz	dolast			; no, no need for further processing
	inc	cs:multi_pass_id	; mult_pass_id = 3
	call	multi_pass		; execute install= commands
ENDIF ; CONFIGPROC

dolast:
	assume	es:nothing

; [area] has the segment address for the allocated memory of sysinit, confbot.
;  free the confbot area used for config.sys and sysinit itself.


; Now if DOS is supposed to run high, we actually move it into high memory 
; (if HiMem manager is available).  For ROMDOS, we don't actually move
; anything, but just set up the ROM area for suballocation (or print
; a message if HiMem is not available).
;
; There is also this little hack for CPM style DOS calls that needs to
; be done when A20 is set...

	cmp	runhigh, 0ffh		; are we still waiting to be moved?
	jne	@f			; no, our job is over
	call	LoadDOSHiOrLo
@@:

	cmp	runhigh, 0		; are we running low
	je	@f			; yes, no CPM hack needed
	call	CPMHack			; make ffff:d0 same as 0:c0
@@:


; We are now done with CONFIG.SYS processing

ConfigDone:

	mov	cs:[donotshownum],1	; done with config.sys. do not show line number message.
	mov	es,[area]

	assume	es:nothing

        mov     ah,Dealloc              ; free allocated memory for command.com
	int	21h

	test	cs:[install_flag],has_installed ; sysinit_base installed?
	jz	skip_free_sysinitbase	; no.

;set block from the old_area with impossible_owner_size.
;this will free the unnecessary sysinit_base that had been put in memory to
;handle install= command.

        push    es                      ; BUGBUG 3-30-92 JeffPar: no reason to save ES
	push	bx
	mov	es,cs:[old_area]
	mov	bx,cs:[impossible_owner_size]
	mov	ah,setblock
	int	21h
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	bx
        pop     es                      ; BUGBUG 3-30-92 JeffPar: no reason to save ES

skip_free_sysinitbase:

	cmp	runhigh, 0
	je	@f
	call	InstVDiskHeader		; Install VDISK header (allocates some mem from DOS)
@@:

if      NOEXEC
        mov     bp,ds                   ; save command.com segment
	push	ds
	pop	es
	mov	bx,cs
	sub	bx,10h			; point to current php
	mov	ds,bx
	xor	si,si
	mov	di,si
	mov	cx,80h
	rep	movsw			; copy it to new location for shell
	mov	word ptr es:[pdb_jfn_pointer + 2],es ; relocate
	mov	bx,es
	mov	ah,set_current_pdb
	int	21h			; tell dos we moved it
	mov	es:[pdb_parent_pid],es	;we are the root
endif ; NOEXEC

	push	cs
	pop	ds			; point DS to sysinitseg

	assume	ds:sysinitseg

; set up the parameters for command

ifdef   MULTI_CONFIG
        mov     [config_cmd],0          ; set special code for query_user
        call    query_user              ; to issue the AUTOEXEC prompt
        jnc     process_autoexec        ; we should process autoexec normally
        call    disable_autoexec        ; no, we should disable it
process_autoexec:
endif

        mov     cl,[command_line]
        mov     ch,0
        inc     cx
        mov     si,offset command_line

if      NOEXEC
	mov	al,[default_drive]
        mov     es:[5ch],al

        mov     di,80h
        rep     movsb
        mov     al,cr                   ; cr-terminate command line
	stosb
else
        add     si,cx
        mov     byte ptr [si],cr        ; cr-terminate command line
endif

;
;   Once we get to this point, the above code, which is below "retry"
;   in memory, can be trashed (and in fact is -- see references to retry
;   which follow....)
;
retry:
	mov	dx,offset commnd	;now pointing to file description

if      NOEXEC
	mov	es,bp		;set load address
	mov	bx,100h
	call	dfil		;read in command
	jc	comerr
	mov	ds,bp
	mov	dx,80h
	mov	ah,set_dma	;set disk tranfer address
	int	21h
	cli
	mov	ss,bp
	mov	sp,dx
	sti
	xor	ax,ax		;push a word of zeros
	push	ax
	push	bp		;set high part of jump address
	mov	ax,100h
	push	ax		;set low part of jump address
	retf			;crank up command!

else ; not NOEXEC

; we are going to open the command interpreter and size it as is done in
; ldfil.  the reason we must do this is that sysinit is in free memory.  if
; there is not enough room for the command interpreter,exec will probably
; overlay our stack and code so when it returns with an error sysinit won't be
; here to catch it.  this code is not perfect (for instance .exe command
; interpreters are possible) because it does its sizing based on the
; assumption that the file being loaded is a .com file.  it is close enough to
; correctness to be usable.

ifdef	ROMDOS
;
; By doing a ROM_FIND_FIRST we check to see whther shell is present in ROM
; module. If so we can not (and should not) do the memory check. In this case
; we leave the responsibilty to the ROM module shell to figure out whether
; there is sufficient memory for it to run.
;
	mov	ah, ROM_FIND_FIRST
	int	21h
	jnc	skip_memchk
endif ; ROMDOS

; first, find out where the command interpreter is going to go.

	push	dx		; save pointer to name
	mov	bx,0ffffh
	mov	ah,alloc
        int     21h             ; get biggest piece
	mov	ah,alloc
	int	21h		; second time gets it
	jc	memerrjx	; oooops

	mov	es,ax
	mov	ah,dealloc
	int	21h		; give it right back
	mov	bp,bx

; es:0 points to block,and bp is the size of the block
;   in para.

; we will now adjust the size in bp down by the size of sysinit. we
;   need to do this because exec might get upset if some of the exec
;   data in sysinit is overlayed during the exec.

        mov     bx,[memory_size]; get location of end of memory
	mov	ax,cs		; get location of beginning of sysinit

ifdef   MULTI_CONFIG
;
;   Note that the "config_wrkseg" environment data is a segment in
;   unallocated memory (as of the Dealloc of [area], above).  This is ideal
;   in one sense, because Exec is going to make a copy of it for COMMAND.COM
;   anyway, and no one has responsibility for freeing "config_wrkseg".  But
;   we need to make sure that there's no way Exec will stomp on that data
;   before it can copy it, and one way to do that is to make the available
;   memory calculation even more "paranoid", by subtracting "config_wrkseg"
;   from the "memory_size" segment value (which is typically A000h) instead
;   of the current sysinit CS....
;
;   The reason I use the term "paranoid" is because this code should have
;   slid the data required by Exec up to the very top of memory, because as
;   it stands, you have to have sizeof(COMMAND.COM) PLUS 64K to load just
;   COMMAND.COM (64k is about what sysinit, and all the goop above sysinit,
;   consumes).  Now it's just a little worse (65K or more, depending on
;   the size of your CONFIG.SYS, since the size of the environment workspace
;   is determined by the size of CONFIG.SYS.... -JTP
;
        mov     cx,[config_envlen]
        jcxz    no_env          ; use config_wrkseg only if there's env data
        mov     ax,[config_wrkseg]
no_env:
endif  ;MULTI_CONFIG

        sub     bx,ax           ; bx is size of sysinit in para
	add	bx,11h		; add the sysinit php
	sub	bp,bx		; sub sysinit size from amount of free memory
	jc	memerrjx	; if there isn't even this much memory, give up

        mov     ax,(open shl 8) ; open the file being execed
        stc                     ; in case of int 24
	int	21h
	jc	comerr		; ooops

        mov     bx,ax           ; handle in bx

ifdef   MULTI_CONFIG
;
;   If the standard command interpreter is being used, verify it is correct
;
        cmp     newcmd,0        ; was a new shell selected?
        jne     skip_validation ; yes
        mov     dx,offset retry-4
        mov     cx,4            ;
        mov     ah,Read         ;
        int     21h             ;
        cmp     byte ptr [retry-4],0E9h
        jne     comerr          ;
        cmp     byte ptr [retry-1],((major_version AND 0Fh) SHL 4) OR (minor_version AND 0Fh)
        jne     comerr          ;

skip_validation:

endif  ;MULTI_CONFIG

	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc			;in case of int 24
	int	21h		; get file size in dx:ax
	jc	comerr
				; convert size in dx:ax to para in ax
	add	ax,15		; round up size for conversion to para
	adc	dx,0
	call	off_to_para
	mov	cl,12
	shl	dx,cl		; low nibble of dx to high nibble
	or	ax,dx		; ax is now # of para for file
	add	ax,10h		; 100h byte php
	cmp	ax,bp		; will command fit in available mem?
	jb	okld		; jump if yes.

memerrjx:
	mov	dx,offset badmem
	call	print
        jmp     short continue

okld:
	mov	ah,close
	int	21h		; close file

ifdef	ROMDOS
skip_memchk:			; label to skip SHELL memory requirement
				;  check, if we are lauching a SHELL which
				;  is in ROM
endif ; ROMDOS

	push	cs		; point es to sysinitseg
	pop	es
        mov     bx,offset comexe; point to exec block
        pop     dx              ; recover pointer to name

ifdef   MULTI_CONFIG
;
;   If there's any environment data in "config_wrkseg", pass it to shell;
;   there will be data if there were any valid SET commands and/or if a menu
;   selection was made (in which case the CONFIG environment variable will be
;   set to that selection).
;
        mov     cx,[config_envlen]
        jcxz    no_envdata
        mov     cx,[config_wrkseg]
no_envdata:
        mov     [bx.exec0_environ],cx
endif  ;MULTI_CONFIG

	mov	word ptr [bx.exec0_com_line+2],cs ; set segments
	mov	word ptr [bx.exec0_5c_fcb+2],cs
	mov	word ptr [bx.exec0_6c_fcb+2],cs
	mov     ax,(exec SHL 8) + 0
        stc                     ; in case of int 24
        int     21h             ; go start up command
        push    cs
        pop     ds
        push    dx              ; push to balance fall-through pop

endif   ;not NOEXEC


; note fall through if exec returns (an error)

comerr:
ifdef   MULTI_CONFIG
        cmp     [commnd4],0
        je      comerr2         ; all defaults exhausted, print err msg
        cmp     [newcmd],0
        je      continue        ; don't print err msg for defaults just yet
comerr2:
endif
        mov     dx,offset badcom; want to print command error
	extrn	badfil:near
	call	badfil

continue:
        pop     dx

ifndef  MULTI_CONFIG
        jmp     stall
else
        mov     ah,Get_Default_Drive
        int     21h             ;
        add     al,'A'          ;
        mov     dl,al           ; DL == default drive letter
        mov     si,offset commnd2
        cmp     [newcmd],0      ; if a SHELL= was given
        jne     do_def2         ; then try the 2nd alternate;
        mov     byte ptr [si],0 ; otherwise, the default SHELL= was tried,
        jmp     short do_def3   ; which is the same as our 2nd alt, so skip it
do_def2:                        ;
        cmp     byte ptr [si],0 ; has 2nd alternate been tried?
        jne     do_alt          ; no
do_def3:
        mov     si,offset commnd3
        cmp     byte ptr [si],0 ; has 3rd alternate been tried?
        jne     do_alt          ; no
        mov     si,offset commnd4
        cmp     byte ptr [si],0 ; has 4th alternate been tried?
        jne     do_alt          ; no
        push    dx              ;
        mov     dx,offset badcomprmpt
        call    print           ;
        pop     dx              ; recover default drive letter in DL
request_input:                  ;
        mov     ah,Std_Con_Output
        int     21h             ;
        push    dx              ;
        mov     dl,'>'          ;
        int     21h             ;
        mov     bl,tmplate+1    ;
        mov     bh,0            ;
        mov     commnd[bx],0Dh  ;
        mov     dx,offset tmplate
        mov     ah,Std_Con_String_Input
        int     21h             ; read a line of input
        mov     dx,offset crlfm ;
        call    print           ;
        pop     dx              ;
        mov     bl,tmplate+1    ;
        or      bl,bl           ; was anything typed?
        jz      request_input   ;
        mov     [newcmd],1      ; disable validation for user-specified binaries
        mov     commnd[bx],0    ; NULL-terminate it before execing it
        mov     word ptr [command_line],0D00h
        jmp     short do_exec   ;

do_alt:
        push    ds
        pop     es
        mov     [newcmd],0      ; force validation for alternate binaries
        mov     di,offset commnd;
do_alt1:
        lodsb                   ; copy the alternate, zapping it as we go,
        mov     byte ptr [si-1],0; so that we know it's been tried
        stosb                   ;
        or      al,al           ;
        jnz     do_alt1         ;
        mov     di,offset command_line
        cmp     byte ptr [si+2],':'
        jne     do_alt2         ;
        mov     [si+1],dl       ; stuff default drive into alt. command line
do_alt2:                        ;
        lodsb                   ;
        stosb                   ;
        or      al,al           ;
        jnz     do_alt2         ;
        mov     byte ptr [di-1],CR
;
;   Last but not least, see if we need to call disable_autoexec
;
        cmp     [command_line-1],0
        jne     do_exec         ;
        mov     [command_line-1],'/'
        call    disable_autoexec;

do_exec:
        jmp     retry           ;

endif   ;MULTI_CONFIG

;
;----------------------------------------------------------------------------
; procedure : AllocFreeMem
;
; Allocate Max memory from DOS to find out where to load DOS.
; DOS is at temporary location when this call is being made
;
; Inputs : None
; Outputs: The biggest chunk of memory is allocated (all mem at init time)
;	   [area] & [memhi] set to the para value of the start of the
;	   free memory.
;
; Uses   : AX, BX
;
;----------------------------------------------------------------------------
;
AllocFreeMem	proc	near

	assume	es:nothing, ds:nothing
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h			;first time fails
	mov	ah,alloc
	int	21h			;second time gets it
	mov	[area],ax
	mov	[memhi],ax		; memhi:memlo now points to
	ret
					; start of free memory
AllocFreeMem	endp

;	start M000
	include	msbio.cl6
;	end M000

;
;----------------------------------------------------------------------------
;
; procedure : LoadDOSHiOrLo
;
;		Tries to move DOS into HMA. If it fails then loads
;		DOS into Low memory.  For ROMDOS, nothing is actually
;		moved; this just tries to allocate the HMA, and prints
;		a message if this is not possible.
;
;----------------------------------------------------------------------------
;

LoadDOSHiOrLo	proc	near
	call	TryToMovDOSHi			; Try moving it into HMA (M024)
	jc	LdngLo				; If that don't work...
	ret
LdngLo:
	push	cs
	pop	ds
	mov	ah, 9
	mov	dx, offset DOSLOMSG		; inform user that we are
	int	21h				;  loading low

ifndef ROMDOS
	; actually move the dos, and reinitialize it.

	mov	bx, 1				; M012
						;  use int 21 alloc for mem
	call	MovDOSLo
	mov	es,[current_dos_location]	; give dos its temporary loc.
	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit
endif ; ROMDOS

	mov	runhigh, 0			; mark that we are running lo
	ret
LoadDOSHiOrLo	endp


;
;----------------------------------------------------------------------------
;
; procedure : TryToMovDOSHi
;
;		This tries to move DOS into HMA.
;		Returns CY if it failed.
;		If it succeeds returns with carry cleared.
;
;		For ROMDOS, dos_segreinit must be called again to allow
;		the A20 switching code in the low mem stub to be installed.
; 
;----------------------------------------------------------------------------
;

		public	TryToMovDOSHi

TryToMovDOSHi	proc	near
	call	MovDOSHi
	jc	ttldhx

ifndef ROMDOS

	mov	es,[current_dos_location]	; give dos its temporary loc.

else

	mov	ax, Bios_Data		; get bios data segment
	mov	es, ax			; point es to bios data
	assume	es:Bios_Data
	mov	es, [DOS_Res]		; get DOS resident code segment
	assume	es:nothing

endif ; ROMDOS

	xor	ax,ax				; ax = 00 ---> install stub
	call	cs:dword ptr [dos_segreinit]	; call dos segreinit

	mov	runhigh, 1
	clc
ttldhx:
	ret
TryToMovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSHi
;
;		Tries to allocate HMA and Move DOS/BIOS code into HMA
;		For ROMDOS, the code is not actually moved, but the
;		HMA is allocated and prepared for sub-allocation.
;
;		Returns : CY if it failed
;
;----------------------------------------------------------------------------
;

MovDOSHi	proc	near
	call	AllocHMA
	jc	mdhx				; did we get HMA?
	mov	ax, 0ffffh			; yes, HMA seg = 0ffffh
	mov	es, ax

ifndef ROMDOS
	; actually move the BIOS and DOS

	call	MovBIOS				; First move BIOS into HMA

	; ES:DI points to free HMA after BIOS

	mov	cx, hi_doscod_size		; pass the code size of DOS
						;  when it is in HMA
	call	MovDOS				; and move it

	; ES:DI points to free HMA after DOS
else
	; allocate space at beginning of HMA to allow for CPMHack

	mov	di, 0E0h			; room for 5 bytes at ffff:d0

endif ; ROMDOS

	call	SaveFreeHMAPtr			; Save the Free HMA ptr
	clc
mdhx:
	ret
MovDOSHi	endp


;
;----------------------------------------------------------------------------
;
; procedure : MovDOSLo
;
;		Allocates memory from DOS and moves BIOS/DOS code into it
;
;----------------------------------------------------------------------------
;

ifndef ROMDOS

MovDOSLo	proc	near
	call	AllocMemForDOS			; incestuosly!!!
	mov	es, ax				; pass the segment to MovBIOS
	call	MovBIOS
;
;------ ES:DI points memory immediately after BIOS
;
	mov	cx, lo_doscod_size		; DOS code size when loaded
						;  low
	call	MovDOS
	ret
MovDOSLo	endp

endif ; ROMDOS

;
;----------------------------------------------------------------------------
;
; procedure : MovBIOS
;
;		Moves BIOS code into requested segment
;
;	In : ES - segment to which BIOS is to be moved
;		  ( it moves always into offset BCode_Start)
;
;	Out : ES:DI - pointer to memory immediately after BIOS
;
;----------------------------------------------------------------------------
;

ifndef ROMDOS

MovBIOS	proc	near
	mov	ds, temp_bcode_seg		; current BIOS code seg
	mov	si, offset BCode_Start
	mov	di, si
	mov	cx, offset BCode_End
	sub	cx, si				; size of BIOS
	shr	cx, 1				; Both the labels are para
						;  aligned
	rep	movsw
	push	es
	push	di				; save end of BIOS
	mov	ax, es
	mov	BCodeSeg, ax			; save it for later use
	call	[seg_reinit_ptr]		; far call to seg_reinit (M022)
	pop	di
	pop	es				; get back end of BIOS
	ret
MovBIOS	endp

endif ; ROMDOS

;
;----------------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is  to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
;----------------------------------------------------------------------------
;

ifndef ROMDOS

MovDOS	proc	near
	push	es
	push	di
	lds	si, dos_temp_location		; current location of DOS
	rep	movsb
	pop	bx				; get back offset into which
						;  DOS was moved
	mov	ax, dosinit			; get the offset at which DOS
						;  wants to run
	sub	ax, bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx, ax				; Adjust segment
	mov	current_dos_location, bx	; and save it
	ret
MovDOS	endp

endif ;ROMDOS

;
;----------------------------------------------------------------------------
;
; procedure : AllocMemForDOS
;
;		Allocate memory for DOS/BIOS code from DOS !!!
;
;	Out : AX - seg of allocated memoryblock
;
;----------------------------------------------------------------------------
;

ifndef ROMDOS

AllocMemForDOS	proc	near
	mov	ax, offset BCode_end
	sub	ax, offset BCode_start		; BIOS code size
	add	ax, lo_doscod_size		; + DOS code size
	add	ax, 15
	call	off_to_para			; convert to para
	or	bx, bx				; M012
						;  can we use int 21 for alloc
	mov	bx, ax
	jz	update_arena			; M012
	mov	ah, 48h				; request DOS
	int	21h
	jc	FatalErr			; IF ERR WE ARE HOSED
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	mov	es, ax
	mov	word ptr es:[20h+arena_owner], 08h	; mark it as system
	mov	word ptr es:[20h+arena_name], 'CS'	;  code area
	ret

;	BUGBUG -- 5 Aug 92 -- chuckst -- Allocating space for DOS
;		  using DOS itself causes an arena to be generated.
;		  Unfortunately, certain programs (like PROTMAN$)
;		  assume that the device drivers are loaded into
;		  the first arena.  For this reason, MagicDrv's
;		  main device driver header arena is manually
;		  truncated from the arena chain, and the space
;		  for DOS is allocated using the following
;		  simple code, which also assumes that the
;		  first arena is the free one where DOS's low
;		  stub will go.
;
; M012 : BEGIN
;
update_arena:
	push	ds
	push	di
	push	cx
	push	dx
	lds	di, dosinfo			; get ptr to DOS var
	dec	di
	dec	di				; Arena head is immediately
						;  before sysvar
	mov	es, ds:[di]			; es = arena head
	mov	cx, es:[arena_size]		; cx = total low mem size
	cmp	cx, bx				; is it sufficient ?
	jb	FatalErr			; no, fatal error

	mov	dl, es:[arena_signature]
	mov	ax, es
	add	ax, bx				; ax = new arena head
	mov	ds:[di], ax			; store it in DOS data area
	mov	ds, ax
	mov	byte ptr ds:[arena_signature], dl	; type of arena
	mov	word ptr ds:[arena_owner], 0		; free
	sub	cx, bx				; size of the new block
	mov	word ptr ds:[arena_size], cx	; store it in the arena
	mov	ax, es				; return seg to the caller
	sub	ax, 3				; Take care ORG 30h of
						;  BIOS code
	pop	dx
	pop	cx
	pop	di
	pop	ds
	ret
;
; M012 : END
;
FatalErr:
	push	cs
	pop	ds
	mov	dx, offset FEMsg
	mov	ah, 9h
	int	21h
        jmp     stall

AllocMemForDOS	endp

endif ;ROMDOS

;
;----------------------------------------------------------------------------
;
; procedure : AllocHMA
;
;	grab_the_hma tries to enable a20 and make sure there is memory
;	  up there.  If it gets any sort of error, it will return with
;	  carry set so that we can resort to running low.
;
;	It also returns ES: -> 0ffffh if it returns success
;
;----------------------------------------------------------------------------
;

AllocHMA	proc near
	assume	ds:nothing,es:nothing
;
;	cas note:  The pre-286 check is no longer needed here since the
;		   presence of XMS is sufficient.  However, this code hasn't
;		   been deleted because it can be recycled for skipping the
;		   extra pass of CONFIG.SYS and assuming we're running low
;		   in the case of a pre-286.

;
;;	see if we're running on a pre-286.  If not, force low.
;
;	xor	ax,ax
;	pushf			; save flags (like int)
;	push	ax
;	popf
;	pushf
;	pop	ax
;	popf			; restore original flags (like int)
;	and	ax,0f000h
;	cmp	ax,0f000h	; 8088/8086?
;	jz	grab_hma_error
;
	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume 	ds:Bios_Data

	call	IsXMSLoaded
	jnz	grabhma_error

	mov	ax,4310h
	int	2fh		; get the vector into es:bx
	mov	word ptr xms,bx
	mov	word ptr xms+2,es

	mov	ah,1		; request HMA
	mov	dx,0ffffh
	call	xms
	dec	ax
	jz	@f		; error if not able to allocate HMA

;
;------ Himem may be lying because it has allocated mem for int 15
;
	mov	ah, 88h
	int	15h
	cmp	ax, 64		; less than 64 K of hma ?
	jb	grabhma_error

@@:	mov	ah,5		; localenableA20
	call	xms
	dec	ax
	jnz	grabhma_error	; error if couldn't enable A20

	call	IsVDiskInstalled
	jz	grabhma_error	; yes, we cant use HMA

	mov	ax,0ffffh
	mov	es,ax
	mov	es:word ptr 10h,1234h	; see if we can really read/write there
	cmp	es:word ptr 10h,1234h
	jnz	grabhma_error	; don't try to load there if XMS lied

	clc
	pop	ds
	ret

grabhma_error:
	stc
	pop	ds
	assume	ds:nothing
	ret

AllocHMA	endp

;
;----------------------------------------------------------------------------
;
; procedure : IsXMSLoaded
;
;             Checks whether a XMS driver is loaded
;
; Returns : Z flag set if XMS driver loaded
;           Z flag reset if no XMS drivers are present
;
;----------------------------------------------------------------------------
;
		public	IsXMSLoaded

IsXMSLoaded	proc	near
		mov	ax,4300h
		int	2fh
		cmp	al,80h		; XMS installed?
		ret
IsXMSLoaded	endp

;
;
;----------------------------------------------------------------------------
; procedure : FTryToMovDOSHi
;
;		Called from HMA suballoc calls
;	
;----------------------------------------------------------------------------
;
;

		public	FTryToMovDOSHi
FTryToMovDOSHi	proc	far

		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	ds
		push	es
		cmp	runhigh, 0ffh
		jne	@f

		call	TryToMovDOSHi
@@:
		pop	es
		pop	ds
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax

		ret
FTryToMovDOSHi	endp


;
;

;
;----------------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
;----------------------------------------------------------------------------
;
StartVDHead	label	byte
;
;-------------- what follows is a dummy device driver header (not used by DOS)
;
		dd	0		; link to next device driver
		dw	8000h		; device attribute
		dw	0		; strategy routine offset
		dw	0		; interrupt routine offset
		db	1		; number of units
		db	7 dup(0)	; reserved area
VDiskSig1	db	'VDISK'

VLEN1		equ	($-offset VDiskSig1)

		db	'  V3.3'	; vdisk label
		db	15 dup (0)	; pad
		dw	0		; bits 0-15 of free HMA
		db	11h		; bits 16-23 of free HMA (1M + 64K)

VDInt19:
		db	0eah		; jmp to old vector
OldVDInt19	dd	?		; Saved int 19 vector

EndVDHead	label	byte
;
;
VDiskHMAHead	db	0,0,0		; non-bootable disk
VDiskSig2	db	'VDISK'

VLEN2		equ	($-offset VDiskSig2)

		db	'3.3'		; OEM - signature
		dw	128		; number of bytes/sector
		db	1		; sectors/cluster
		dw	1		; reserved sectors
		db	1		; number of FAT copies
		dw	64		; number of root dir entries
		dw	512		; number of sectors
		db	0feh		; media descriptor
		dw	6		; number of sectors/FAT
		dw	8		; sectors per track
		dw	1		; number of heads
		dw	0		; number of hodden sectors
		dw	440h		; Start of free HMA in K (1M+64K)
EndVDiskHMAHead	label	byte
;
;
;----------------------------------------------------------------------------
;
; procedure : InstVDiskHeader
;
;             Installs the VDISK header to reserve the 64k of HMA
;	      It puts a 32 byte header at 10000:0 and
;	      another header at (seg of int19):0
;
; Inputs : None
;
; Outputs : None
;
; USES : DS,SI,AX,CX,DX
;
;----------------------------------------------------------------------------
;
		assume	ds:nothing

InstVDiskHeader	proc	near

		xor	ax, ax
		mov	ds, ax			; seg of int vect table
;
;-------------- save old int 19 vector
;
		mov	ax, word ptr ds:[19h*4]
		mov	word ptr OldVDint19, ax
		mov	ax, word ptr ds:[19h*4+2]
		mov	word ptr OldVDint19+2, ax
;
;-------------- calculate seg of new int 19 handler
;
		mov	ah, 48h			; allocate memory
		mov	bx, (offset EndVDHead - offset StartVDHead + 15) shr 4
		int	21h

;	if carry, fatal hanging error!!!!!

		dec	ax			; point to arena
		mov	es, ax
		mov	word ptr es:[arena_owner], 8	; owner = System
		mov	word ptr es:[arena_name], 'CS'	; System Code
		inc	ax
		mov	es, ax			; get back to allocated memory
;
;-------------- install new int 19 vector
;
		cli				; no reboots at this time
		mov	word ptr ds:[19h*4], (offset VDint19 - offset StartVDHead)
		mov	word ptr ds:[19h*4+2], ax
;
;-------------- move the code into proper place
;
		mov	cx, (offset EndVDHead - offset StartVDHead)
		mov	si, offset StartVDHead
		xor	di, di
		push	cs
		pop	ds
		cld
		rep	movsb
		sti				; BUGBUG is sti OK now?
;
;-------------- mov the HMA VDisk head into HMA
;
		push	di
		push	es

		mov	ax, 0ffffh
		mov	es, ax
		mov	di, 10h
		mov	cx, (offset EndVDiskHMAHead - offset VDiskHMAHead)
		mov	si, offset VDiskHMAHead
		rep	movsb			; ds already set to cs

		pop	di
		pop	es

		ret

InstVDiskHeader	endp

;
;----------------------------------------------------------------------------
; procedure : ClrVDISKHeader
;
;		Clears the first 32 bytes at 1MB boundary
;		So that DOS/HIMEM is not confused about the VDISK header
;		left by previous DOS=HIGH session
;
;----------------------------------------------------------------------------
;


desc		struc
 seg_lim	dw	0			; seg limit 64K 
 lo_word	dw	0			; 24 bit seg physical 
 hi_byte	db	0			; address
 acc_rights	db	0			; access rights ( CPL0 - R/W )
 reserved	dw	0			;
desc		ends

bmove		label byte

dummy		desc	<> 
gdt		desc	<>
src_desc	desc	<0ffffh,0,0,93h,0>
tgt_desc	desc	<0ffffh,0,10h,93h,0>	; 1MB
rombios_code	desc	<>
temp_stack	desc	<>


ClrdVDISKHead	db	32 dup (0)

		assume	ds:nothing

ClrVDISKHeader	proc	near

;-----------------------------------------------------------	      ;I070
; The following workaround get around a problem with the	      ;I070
; Tortugas and PS/2 30-286 BIOS when password server mode	      ;I070
; is set.  On those machines the INT 15h block move code	      ;I070
; goes through the 8042 to twiddle A20 instead of port 92h.	      ;I070
; In password server mode the 8042 is disabled so the block	      ;I070
; move crashes the system. We can do this because these		      ;I070
; systems clear all of memory on a cold boot.			      ;I070
								      ;I070
                in      al,64h         ; Test for password servr mode ;I070
                test    al,10h         ; Is keyboard inhibited?	      ;I070
                jnz     ClrVDISKok     ; No, go do block move.	      ;I070
                                       ; Check for Tortugas...	      ;I070
                cmp     word ptr cs:[sys_model_byte],19F8h	      ;I070
                je      ClrVDISKno				      ;I070
                                       ; Check for mod 30-286	      ;I070
                cmp     word ptr cs:[sys_model_byte],09FCh	      ;I070
                jne     ClrVDISKok				      ;I070
ClrVDISKno:     ret                    ; Return w/o block move.	      ;I070
								      ;I070
ClrVDISKok:							      ;I070
;-----------------------------------------------------------	      ;I070

		push	es
		mov	ax, cs
		mov	dx, ax
		mov	cl, 12
		shr	dx, cl
		mov	cl, 4
		shl	ax, cl
		add	ax, offset ClrdVDISKHead
		adc	dl, 0
		mov	src_desc.lo_word, ax
		mov	src_desc.hi_byte, dl
		mov	cx, 16			; 16 words
		push	cs
		pop	es
		mov	si, offset bmove
		mov	ah, 87h
		int	15h
		pop	es
		ret
ClrVDISKHeader	endp

;
;
;----------------------------------------------------------------------------
;
; procedure : SaveFreeHMAPtr
;
;		Save the Free HMA pointer in BIOS variable for later use.
;		(INT 2f ax==4a01 call returns pointer to free HMA)
;		Normalizes the pointer to ffff:xxxx format and stores only
;		the offset.
;
; Inputs : ES:DI - pointer to free HMA
; Output : FreeHMAPtr in BIOS data segment updated
;
;----------------------------------------------------------------------------
;
SaveFreeHMAPtr	proc	near
		mov	bx, es
		mov	ax, 0ffffh		; HMA segment
		sub	ax, bx
		add	di, 15			; para round
		and	di, 0fff0h
		mov	cl, 4
		shl	ax, cl
		sub	di, ax
		push	ds
		mov	ax, Bios_Data
		mov	ds, ax
		assume	ds:Bios_Data
		mov	FreeHMAPtr, di
		mov	inHMA, 0ffh
		pop	ds
		assume	ds:nothing
		ret
SaveFreeHMAPtr	endp
;
;
;----------------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector
;
; Inputs  : A20 flag should be ON
; Outputs : Zero set if VDISK header found else Zero cleared
;
;----------------------------------------------------------------------------
;
IsVDiskInstalled proc	near
		xor	ax, ax
		mov	ds, ax
		mov	ds, word ptr ds:[19*4+2]
		mov	si, offset VDiskSig1 - offset StartVDHead
		mov	cx, VLEN1
		push	cs
		pop	es
		mov	di, offset VDiskSig1
		rep	cmpsb
		je	@f
		mov	ax, 0ffffh
		mov	ds, ax
		mov	si, 10h+(offset VDiskSig2 - offset VDiskHMAHead)
		mov	di, offset VDiskSig2
		mov	cx, VLEN2
		rep	cmpsb
@@: 
		ret			; returns the Zero flag
IsVDiskInstalled endp
;
;----------------------------------------------------------------------------
;
; procedure : CPMHack
;
;		Copies the code from 0:c0 into ffff:0d0h
;		for CPM comatibilty
;
;----------------------------------------------------------------------------
;
CPMHack		proc	near
		push	ds
		mov	cx, 0ffffH
		mov	es, cx		; ES = FFFF
		xor	cx, cx
		mov	ds, cx		; DS = 0
		mov	si, 0c0h
		mov	di, 0d0h
		mov	cx, 5
		cld
		rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
		pop	ds
		ret
CPMHack		endp
	
;
;----------------------------------------------------------------------------
;
; procedure : off_to_para
;
;----------------------------------------------------------------------------
;

off_to_para proc near
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret
off_to_para endp


;**	TempCDS - Create (Temporary?) CDS
;
;	ENTRY	?? BUGBUG
;		(DS) = SysInitSeg
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG

	public	tempcds
Procedure TempCDS

    assume ds:sysinitseg

ifdef	COPYCDS
	push	ax			; save build from scratch flag
endif ; COPYCDS

	les	di,dosinfo
	mov	cl,byte ptr es:[di.sysi_numio]
	xor	ch,ch			; (cx) = # of block devices

	mov	es:[di.sysi_ncds],cl	; one CDS per device
	mov	al,cl
	mov	ah,size curdir_list
	mul	ah			; (ax) = byte size for those CDSs
	call	pararound		; (ax) = paragraph size for CDSs
	mov	si,[top_of_cdss]

;	BUGBUG - we don't update confbot - won't someone else use it?
;	chuckst -- answer: no.  Confbot is used to access the CDSs,
;	25 jul 92  which are stored BELOW it.  Alloclim is the
;		   variable which has the top of free memory for
;		   device driver loads, etc.

	sub	si,ax

;	chuckst, 25 Jul 92 -- note:  I'm removing the code here
;		that automatically updates alloclim every time we
;		set up some new CDSs.  Instead, I've added code
;		which pre-allocates space for 26 CDSs.  This
;	        way we've got room for worst case CDSs before
;		we place MagicDrv.sys
;
;	mov	[alloclim],si		; can't alloc past here!

	mov	word ptr es:[di.sysi_cds + 2],si
	mov	ax,si
	mov	word ptr es:[di.sysi_cds],0	; set address of CDS list
	lds	si,es:[di.sysi_dpb]	; (ds:si) = address of first DPB
	assume	ds:nothing
	mov	es,ax
	xor	di,di			; (es:di) = address of 1st CDS


ifdef	COPYCDS
	pop	ax			; get back build from scratch flag
	or	al, al			; build from scratch ?
	jz	@f
	mov	byte ptr DirStrng,"A"	; if from scratch, start with A
	mov	oldnum_cdss, cx
	jmp	short fooset		; yes!
@@:
	call	SlideCDSs		; Do not build from scratch, instead
					;  slide the old CDSs down and build
					;  the new ones

endif ; COPYCDS


;*	Initialize our temporary CDSs.	We'll init each CDS with the
;	info from the corresponding DPB.
;
;	(cx) = count of CDSs left to process
;	(es:di) = address of next CDS

fooset:
	mov	ax,word ptr DirStrng


	.errnz	CURDIR_TEXT		; setup the root as the curdir
	stosw
	call	get_dpb_for_drive_al	; get dpb for drive in dpb
;	(ds:si) = address of DPB
;		    (si) = -1 if no drive

	mov	ax,word ptr DirStrng+2
	stosw
	inc	byte ptr DirStrng
	xor	ax,ax
	push	cx
	.errnz	CURDIR_FLAGS - CURDIR_TEXT - size CURDIR_TEXT
	mov	cx,curdir_flags - 4
	rep	stosb			; zero out rest of CURDIR_TEXTs

;	should handle the system that does not have any floppies.
;	in this case,we are going to pretended there are two dummy floppies
;	in the system. still they have dpb and cds,but we are going to
;	0 out curdir_flags,curdir_devptr of cds so ibmdos can issue
;	"invalid drive specification" message when the user try to
;	access them.
;
;	(ax) = 0
;	(es:di) = CURDIR_FLAGS in the CDS records
;	(ds:si) = Next DPB (-1 if none)

	cmp	si,-1
	je	fooset_zero		;don't have any physical drive.

;	check to see if we are faking floppy drives.  if not go to normcds.
;	if we are faking floppy drives then see if this cds being initialised
;	is for drive a: or b: by checking the appropriate field in the dpb
;	pointed to by ds:si.  if not for a: or b: then go to normcds.  if
;	for a: or b: then execute the code given below starting at fooset_zero.
;	for dpb offsets look at inc\dpb.inc.

	cmp	cs:[fake_floppy_drv],1
	jne	normcds 		; machine has floppy drives
	cmp	ds:[si.dpb_drive],1	;if dpb_drive = 0 (a) or 1 (b).
	INTTEST
	ja	normcds
	mov	cl,3			;  the next dbp pointer
	INTTEST 			; AX should be zero here
	rep	stosw
	pop	cx
	jmp	short get_next_dpb

;	(ax) = 0

fooset_zero:
	mov	cl,3
	rep	stosw
	pop	cx
	jmp	short fincds


;*	We have a "normal" DPB and thus a normal CDS.
;
;	(ax) = 0
;	(es:di) = CURDIR_FLAGS in the CDS records
;	(ds:si) = Next DPB (-1 if none)

normcds:pop	cx

;	if a non-fat based media is detected (by dpb.numberoffat == 0),then
;	set curdir_flags to 0.	this is for signaling ibmdos and ifsfunc that
;	this media is a non-fat based one.

	cmp	[si.dpb_fat_count],0	; non fat system?
	je	setnormcds		; yes. set curdir_flags to 0. ax = 0 now.
	mov	ax,curdir_inuse 	;  else,fat system. set the flag to curdir_inuse.
setnormcds:
	FOLLOWS	CURDIR_FLAGS,CURDIR_TEXT,2
	stosw				; curdir_flags
	mov	ax,si
	FOLLOWS CURDIR_DEVPTR,CURDIR_FLAGS,4
	stosw				; curdir_devptr
	mov	ax,ds
	stosw

get_next_dpb:				; entry point for fake_fooset_zero

fincds:
	mov	ax,-1
	FOLLOWS CURDIR_ID,CURDIR_DEVPTR,4
	stosw				; curdir_id
	stosw				; curdir_id
	FOLLOWS CURDIR_USER_WORD,CURDIR_ID,2
	stosw				; curdir_user_word
	mov	ax,2
	FOLLOWS CURDIR_END,CURDIR_USER_WORD,2
	stosw				; curdir_end
	mov	al,0			;clear out 7 bytes (curdir_type,
	FOLLOWS CURDIR_TYPE,CURDIR_END,1
	stosb
	FOLLOWS CURDIR_IFS_HDR,CURDIR_TYPE,4
	stosw				;  curdir_ifs_hdr,curdir_fsda)
	stosw
	FOLLOWS CURDIR_FSDA,CURDIR_IFS_HDR,2
	stosw
	LAST	CURDIR_FSDA,CURDIR_LIST
	loop	fooset

ifndef	COPYCDS
	mov	byte ptr DirStrng,"A"
endif ; COPYCDS

	ret

EndProc TempCDS

ifndef	COPYCDS

;***	get_dpb_for_drive_al -- lookup the DPB for drive in al
;
;	entry:
;	   al == ASCII CAPS drive letter
;
;	exit:
;	   ds:si -> DPB, or si = -1 if not found

get_dpb_for_drive_al	proc	near
	assume	ds:nothing

	lds	si,[dosinfo]		; point to first DPB
	lds	si,ds:[si.sysi_dpb]	; (ds:si) = address of first DPB
	sub	al,'A'

get_dpb_for_drive_1:
	cmp	al,ds:[si].DPB_DRIVE	; match?
	jz	got_dpb_for_drive	;  done if so

	lds	si,ds:[si].DPB_NEXT_DPB
	cmp	si,-1
	jnz	get_dpb_for_drive_1	; loop until hit end of DPBs

got_dpb_for_drive:
	ret

get_dpb_for_drive_al	endp

endif ; COPYCDS

ifdef	COPYCDS
;
;----------------------------------------------------------------------------
;
; SlideCDSs : Slide the old CDSs down and build the new CDSs above the
;		old ones.
;
;	INPUT :
;	DS:SI = pointer to first DPB
;	ES:DI = pointer to the start of new CDS table
;	oldnum_cdss = number of CDSs built so far
;	newnum_cdss = number of CDSs to be added
;
;	OUTPUT : (regs are set up for FOOSET)
;	DS:SI = pointer to first new DPB for which CDS is to be built
;	ES:DI = pointer to memory where the new CDSs can be built
;	CX    = number of new CDSs to be built
;	oldnum_cdss is updated to take the newly built CDSs into account
;
;----------------------------------------------------------------------------
;
SlideCDSs	proc

	mov	cx, oldnum_cdss		; CX = number of CDSs already
					;	present
	jcxz	sc90			; if zero CDSs no need to slide
	push	cx			; save old number of CDSs
sc10:
	lds	si, [si].dpb_next_dpb	; skip the old DPBs for which CDSs
	loop	sc10			;  have been already built
	pop	cx

	push	ds
	push	si			; save pointer to first new DPB

	mov	al, SIZE curdir_list
	mul	cl
	push	ax
	call	pararound		; AX = size of old CDS table in paras
	mov	si, [top_of_cdss]
	sub	si, ax
	mov	ds, si
	xor	si, si			; DS:SI = pointer to the current CDS
					;	   table
	pop	cx			; CX = size of the CDS table
					;	(note push AX above)
	cld
	rep	movsb

	pop	si			; get back pointer to first new DPB
	pop	ds

sc90:
	mov	cx, newnum_cdss		; set CX = number new CDSs to be built
	add	oldnum_cdss, cx		; update oldnumCDSs to reflect the new
					;  addition
	ret

SlideCDSs	endp

endif ; COPYCDS

;**	EndFile - Build DOS structures
;
; This procedure is called after the config.sys has been processed and
; installable device drivers have been loaded (but before "install="
; programs are loaded) to create the dos structures such as SFTs, buffers,
; FCBs, CDSs, etc.  It also loads the sysinit_base module in low memory
; to allow for the safe EXECing of "install=" programs.  All memory
; above these structures is deallocated back to DOS.
;
;	ENTRY	?? BUGBUG
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG


;------------------------------------------------------------------------------
; allocate files
;------------------------------------------------------------------------------

endfile:

; we are now setting up final cdss,buffers,files,fcss strings etc.  we no
; longer need the space taken by the temp stuff below confbot,so set alloclim
; to confbot.

;	if this procedure has been called to take care of install= command,
;	    then we have to save es,si registers.

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data

	cmp	multrk_flag,multrk_off1 ;=0,multrack= command entered?
	jne	multrk_flag_done
	or	multrk_flag,multrk_on	; default will be on.
multrk_flag_done:

	pop	ds
	assume	ds:nothing

	mov	ax,[confbot]
	mov	[alloclim],ax

	push	cs
	pop	ds
	extrn	round:near
	call	round
	mov	al,[files]
	sub	al,5
	jbe	dofcbs

	push	ax
	mov	al,devmark_files
	call	setdevmark		; set devmark for sfts (files)
	pop	ax
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	lds	di,[di+sysi_sft]	;ds:bp points to sft
	mov	word ptr [di+sflink],bx
	mov	word ptr [di+sflink+2],dx ;set pointer to new sft

	push	cs
	pop	ds

	les	di,dword ptr [memlo]	;point to new sft
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mul	bl			;ax = number of bytes to clear
	mov	cx,ax
	add	[memlo],ax		;allocate memory
	mov	ax,6
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax
	xor	ax,ax
	rep	stosb			;clean out the stuff

;------------------------------------------------------------------------------
; allocate fcbs
;------------------------------------------------------------------------------

dofcbs:
	push	cs
	pop	ds
	call	round
	mov	al,devmark_fcbs		;='x'
	call	setdevmark
	mov	al,[fcbs]
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,dosinfo		;get pointer to dos data
	assume	ds:nothing

	mov	word ptr [di+sysi_fcb],bx
	mov	word ptr [di+sysi_fcb+2],dx ;set pointer to new table
	mov	bl,cs:keep
	xor	bh,bh
	mov	[di+sysi_keep],bx

	push	cs
	pop	ds
	assume	ds:sysinitseg

	les	di,dword ptr [memlo]	;point to new table
	mov	word ptr es:[di+sflink],-1
	mov	es:[di+sfcount],ax
	mov	bl,size sf_entry
	mov	cx,ax
	mul	bl			;ax = number of bytes to clear
	add	[memlo],ax		;allocate memory
	mov	ax,size sf-2
	add	[memlo],ax		;remember the header too
	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before the stosb
	add	di,ax			;skip over header
	mov	al,"A"
fillloop:
	push	cx			; save count
	mov	cx,size sf_entry	; number of bytes to fill
	cld
	rep	stosb			; filled

	mov	word ptr es:[di-(size sf_entry)+sf_ref_count],0
	mov	word ptr es:[di-(size sf_entry)+sf_position],0
	mov	word ptr es:[di-(size sf_entry)+sf_position+2],0

	pop	cx
	loop	fillloop

;------------------------------------------------------------------------------
; allocate buffers
;------------------------------------------------------------------------------

; search through the list of media supported and allocate 3 buffers if the
; capacity of the drive is > 360kb

	cmp	[buffers],-1		; has buffers been already set?
	je	dodefaultbuff
	jmp	dobuff			; the user entered the buffers=.

dodefaultbuff:
	mov	[h_buffers],0		; default is no heuristic buffers.

	ifndef	TAIWAN
	mov	[buffers],2		; default to 2 buffers
	else
	mov	[buffers],6		; default to 6 buffers for csi
	endif

	push	ax
	push	ds
	les	bp,cs:dosinfo	; search through the dpb's
	les	bp,dword ptr es:[bp.sysi_dpb] ; get first dpb

	assume	ds:sysinitseg
	push	cs
	pop	ds

nextdpb:
					; test if the drive supports removeable media

	mov	bl,byte ptr es:[bp.dpb_drive]
	inc	bl
	mov	ax,(ioctl shl 8) or 8
	int	21h

; ignore fixed disks

	or	ax,ax			; ax is nonzero if disk is nonremoveable
	jnz	nosetbuf

; get parameters of drive

	xor	bx,bx
	mov	bl,byte ptr es:[bp.dpb_drive]
	inc	bl
	mov	dx,offset deviceparameters
	mov	ax,(ioctl shl 8) or generic_ioctl
	mov	cx,(rawio shl 8) or get_device_parameters
	int	21h
	jc	nosetbuf		; get next dpb if driver doesn't support
					; generic ioctl

; determine capacity of drive
; media capacity = #sectors * bytes/sector

	mov	bx,word ptr deviceparameters.dp_bpb.bpb_totalsectors

; to keep the magnitude of the media capacity within a word,
; scale the sector size
; (ie. 1 -> 512 bytes,2 -> 1024 bytes,...)

	mov	ax,word ptr deviceparameters.dp_bpb.bpb_bytespersector
	xor	dx,dx
	mov	cx,512
	div	cx			; scale sector size in factor of
					; 512 bytes

	mul	bx			; ax = #sectors * size factor
	or	dx,dx			; just in case of large floppies
	jnz	setbuf
	cmp	ax,720			; 720 sectors * size factor of 1
	jbe	nosetbuf
setbuf:
	mov	[buffers],3
	jmp	short chk_memsize_for_buffers ; now check the memory size
					; for default buffer count

nosetbuf:
	cmp	word ptr es:[bp.dpb_next_dpb],-1
	jz	chk_memsize_for_buffers
	les	bp,es:[bp.dpb_next_dpb]
	jmp	nextdpb

;from dos 3.3,the default number of buffers will be changed according to the
;memory size too.
; default buffers = 2
; if diskette media > 360 kb,then default buffers = 3
; if memory size > 128 kb (2000h para),then default buffers = 5
; if memory size > 256 kb (4000h para),then default buffers = 10
; if memory size > 512 kb (8000h para),then default buffers = 15.

chk_memsize_for_buffers:
	cmp	[memory_size],2000h
	jbe	bufset
	mov	[buffers],5
	cmp	[memory_size],4000h
	jbe	bufset
	mov	[buffers],10
	cmp	[memory_size],8000h
	jbe	bufset
	mov	[buffers],15

bufset:
	assume	ds:nothing
	pop	ds
	pop	ax

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;j.k. here we should put extended stuff and new allocation scheme!!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;*******************************************************************************
;									       *
; function: actually allocate buffers in the memory and initialize	       *
;	    it. 							       *
; input :								       *
;    memhi:memlo - start of the next available memory			       *
;    buffers = number of buffers					       *
;    h_buffers = number of secondary buffers				       *
;									       *
; output:								       *
;	buffinfo.cache_count - # of caches to be installed.		       *
;	buffinfo set.							       *
;	bufferqueue set.						       *
;									       *
; subroutines to be called:						       *
;									       *
;*******************************************************************************
dobuff:
	lds	bx,cs:dosinfo	; ds:bx -> sysinitvar

	mov	ax,[buffers]		;set sysi_buffers
	mov	word ptr ds:[bx.sysi_buffers],ax
	mov	ax,[h_buffers]
	mov	word ptr ds:[bx.sysi_buffers+2],ax
	lds	bx,ds:[bx.sysi_buf]	; now,ds:bx -> buffinfo

	call	round		; get [memhi]:[memlo]
	mov	al,devmark_buf	; ='b'
	call	setdevmark

;allocate buffers

	push	ds			; save buffer info. ptr.
	push	bx

	call	 set_buffer
	pop	bx
	pop	ds

;now set the secondary buffer if specified.

	cmp	[h_buffers],0
	jz	xif16
	call	round
	mov	cx,[memlo]
	mov	word ptr ds:[bx.cache_ptr],cx
	mov	cx,[memhi]
	mov	word ptr ds:[bx.cache_ptr+2],cx
	mov	cx,[h_buffers]
	mov	ds:[bx.cache_count],cx
	mov	ax,512			; 512 byte
	mul	cx
	mov	[memlo],ax
	or	[setdevmarkflag],for_devmark
	call	round
xif16:

;------------------------------------------------------------------------------
; allocate cdss
;------------------------------------------------------------------------------
buf1:
	call	round

	push	ax
	mov	ax,devmark_cds		;='l'
	call	setdevmark
	pop	ax

	les	di,dosinfo
	mov	cl,byte ptr es:[di.sysi_numio]
	cmp	cl,[num_cds]
	jae	gotncds 		; user setting must be at least numio
	mov	cl,[num_cds]
gotncds:

	xor	ch,ch
	mov	es:[di.sysi_ncds],cl
	mov	ax,[memhi]
	mov	word ptr es:[di.sysi_cds + 2],ax
	mov	ax,[memlo]
	mov	word ptr es:[di.sysi_cds],ax
	mov	al,cl
	mov	ah,size curdir_list
	mul	ah
	call	pararound
	add	[memhi],ax

	or	[setdevmarkflag],for_devmark
	call	round			; check for mem error before initializing
	lds	si,es:[di.sysi_dpb]
	assume	ds:nothing
	les	di,es:[di.sysi_cds]
ifdef	COPYCDS
	xor	ch, ch
	sub	cx, oldnum_cdss		; CX = number of new CDSs to be built
	mov	newnum_cdss, cx
	call	SlideCDSs
	jcxz	skip_fooset		; quit if no more CDSs to be built
	mov	si, -1			; new CDSs do not have DPBs
endif ; COPYCDS
	call	fooset
ifdef	COPYCDS
skip_fooset:
endif ; COPYCDS

;------------------------------------------------------------------------------
; allocate space for internal stack
;------------------------------------------------------------------------------

	if	stacksw

	push	cs
	pop	ds
	assume	ds:sysinitseg

;	if the user did not entered stacks= command, as a default, do not install
;	sytem stacks for pc1,pc xt,pc portable cases.
;	otherwise,install it to the user specified value or to the default
;	value of 9,128 for other systems.

	cmp	word ptr [stack_addr],-1 ;has the user entered "stacks=" command?
	je	doinstallstack		;then install as specified by the user
	cmp	[sys_scnd_model_byte],0 ;pc1,xt has the secondary model byte = 0
	jne	doinstallstack		;other model should have default stack of 9,128
	cmp	[sys_model_byte],0feh	;pc1, pc/xt or pc portable ?
	jae	skipstack
doinstallstack:
	mov	ax,[stack_count]	; stack_count = 0?
	or	ax,ax			;then,stack size must be 0 too.
	jz	skipstack		;don't install stack.

;	dynamic relocation of stack code.

	call	round			;[memhi] = seg. for stack code
					;[memlo] = 0

; set devmark block into memory for mem command
; devmark_id = 's' for stack

	mov	al,devmark_stk	;='s'
	call	setdevmark

	mov	ax,[memhi]
	mov	es,ax		;es -> seg. the stack code is going to move.
	assume	es:nothing
	push	cs
	pop	ds
	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
	xor	di,di
	mov	cx,offset endstackcode
	mov	[memlo],cx
	call	round		;have enough space for relocation?
	rep	movsb

	push	ds		; stick the location of the NextStack entry
	mov	ax,Bios_Data	; into the Win386 Instance Data tables
	mov	ds,ax
	assume	ds:Bios_Data
	mov	word ptr NextStack,offset nextentry
	mov	word ptr NextStack+2,es

	mov	ax,[memlo]
	mov	word ptr [stack_addr],ax ;set for stack area initialization
	mov	word ptr IT_StackLoc,ax	; pass it as Instance Data, too
	mov	ax,[memhi]	;this will be used by stack_init routine.
	mov	word ptr [stack_addr+2],ax
	mov	word ptr IT_StackLoc+2,ax

;	space for internal stack area = stack_count(entrysize + stack_size)

	mov	ax,entrysize
	add	ax,[stack_size]
	mul	[stack_count]

	mov	IT_StackSize,ax		; pass through to Instance Tables

	pop	ds			; no more need to access Instance Table
	assume	ds:nothing

	call	pararound	; convert size to pargraphs
	add	[memhi],ax
	or	[setdevmarkflag],for_devmark ;to set the devmark_size for stack by round routine.
	call	round		; check for memory error before
				; continuing
	call	stackinit	; initialize hardware stack. cs=ds=sysinitseg,es=relocated stack code & data

skipstack:
	endif

	push	cs
	pop	ds
	assume	ds:sysinitseg

	mov	al,[files]
	xor	ah,ah		; do not use cbw instruction!!!!!
				;  it does sign extend.
	mov	cx,ax
	xor	bx,bx		;close standard input
	mov	ah,close
	int	21h
	mov	bx,2
rcclloop:			;close everybody but standard output
	mov	ah,close	; need output so we can print message
	int	21h		; in case we can't get new one open.
	inc	bx
	loop	rcclloop

	mov	dx,offset condev
	mov	al,2
	mov	ah,open 	;open con for read/write
	stc			; set for possible int 24
	int	21h
	jnc	goaux
	call	badfil
	jmp	short goaux2

goaux:	push	ax
	mov	bx,1		;close standard output
	mov	ah,close
	int	21h
	pop	ax

	mov	bx,ax		;new device handle
	mov	ah,xdup
	int	21h		;dup to 1,stdout
	mov	ah,xdup
	int	21h		;dup to 2,stderr

goaux2: mov	dx,offset auxdev
	mov	al,2		;read/write access
	extrn	open_dev:near
	call	open_dev

	mov	dx,offset prndev
	mov	al,1		;write only
	call	open_dev

;global rearm command for shared interrupt devices attached in the system;
;shared interrupt attachment has some problem when it issues interrupt
;during a warm reboot.	once the interrupt is presented by the attachment,
;no further interrupts on that level will be presented until a global rearm
;is issued.  by the request of the system architecture group, msbio will
;issue a global rearm after every device driver is loaded.
;to issue a global rearm:	;for pc1,xt,palace
;
;			  out 02f2h,xx  ; interrupt level 2
;			  out 02f3h,xx  ; interrupt level 3
;			  out 02f4h,xx  ; interrupt level 4
;			  out 02f5h,xx  ; interrupt level 5
;			  out 02f6h,xx  ; interrupt level 6
;			  out 02f7h,xx  ; interrupt level 7
;
;	for pc at,in addition to the above commands,
;	need to handle the secondary interrupt handler
;
;			  out 06f2h,xx  ; interrupt level 10
;			  out 06f3h,xx  ; interrupt level 11
;			  out 06f4h,xx  ; interrupt level 12
;			  out 06f6h,xx  ; interrupt level 14
;			  out 06f7h,xx  ; interrupt level 15
;
;	for round-up machine
;
;			  none.

; where xx stands for any value.
;
; for your information,after naples level machine,the system service bios
; call (int 15h),function ah=0c0h returns the system configuration parameters
;

	push	ax
	push	bx
	push	dx
	push	es

	mov	al,0ffh 		;reset h/w by writing to port
	mov	dx,2f2h 		;get starting address
	out	dx,al			; out 02f2h,0ffh
	inc	dx
	out	dx,al			; out 02f3h,0ffh
	inc	dx
	out	dx,al			; out 02f4h,0ffh
	inc	dx
	out	dx,al			; out 02f5h,0ffh
	inc	dx
	out	dx,al			; out 02f6h,0ffh
	inc	dx
	out	dx,al			; out 02f7h,0ffh

;sb secondary global rearm

	mov	ax,0f000h		;get machine type
	mov	es,ax
	cmp	byte ptr es:[0fffeh],0fch ;q:is it a at type machine
	je	startrearm		; *if at no need to check

	mov	ah,0c0h 		;get system configuration
	int	15h			; *
	jc	finishrearm		; *jmp if old rom

; test feature byte for secondary interrupt controller

	test	es:[bx.bios_sd_featurebyte1],scndintcontroller
	je	finishrearm		;jmp if it is there

startrearm:
	mov	al,0ffh 		;write any pattern to port
	mov	dx,6f2h 		;get starting address
	out	dx,al			;out 06f2h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f3h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f4h,0ffh
	inc	dx			;bump address
	inc	dx			;bump address
	out	dx,al			;out 06f6h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f7h,0ffh

finishrearm:
	pop	es
	pop	dx
	pop	bx
	pop	ax

;    global rearm end *******************

;------------------------------------------------------------------------------
; allocate sysinit_base for install= command
;------------------------------------------------------------------------------
; sysinit_base allocation.
;   check if endfile has been called to handle install= command.

set_sysinit_base:
IFDEF	CONFIGPROC
;--------------------------------------------------------------------------
;sysinit_base will be established in the secure area of
;lower memory when it handles the first install= command.
;sysinit_base is the place where the actual exec function will be called and
;will check sysinit module in high memory if it is damaged by the application
;program.  if sysinit module has been broken,then "memory error..." message
;is displayed by sysinit_base.
;--------------------------------------------------------------------------

	push	ax			; set devmark for mem command
	mov	ax,[memhi]
	sub	ax,[area]
	mov	[impossible_owner_size],ax ;remember the size in case.
	mov	al,devmark_inst
	call	setdevmark
	pop	ax

	mov	di,[memhi]
	mov	es,di
	assume	es:nothing
	mov	word ptr [sysinit_base_ptr+2],di ; save this entry for the next use.
	xor	di,di
	mov	word ptr [sysinit_base_ptr],di ; es:di -> destination.
	mov	si,offset sysinit_base	;ds:si -> source code to be relocated.
	mov	cx,(offset end_sysinit_base) - (offset sysinit_base)
	add	[memlo],cx
	or	cs:[setdevmarkflag],for_devmark
	call	round			; check mem error. also,readjust memhi for the next use.
	rep	movsb			; reallocate it.

	mov	word ptr [sysinit_ptr],offset sysinitptr ; returing address from
	mov	word ptr [sysinit_ptr+2],cs ;	sysinit_base back to sysinit.
	or	[install_flag],has_installed ; set the flag.
ENDIF ; CONFPROC

;------------------------------------------------------------------------------
; free the rest of the memory from memhi to confbot.  still from confbot to
; the top of the memory will be allocated for sysinit and config.sys if
; have_install_cmd.
;------------------------------------------------------------------------------

	call	round
	mov	bx,[memhi]
	mov	ax,[area]
	mov	[old_area],ax		; save [area]
	mov	es,ax			;calc what we needed
	sub	bx,ax
	mov	ah,setblock
	int	21h			;give the rest back

	push	es
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	mov	es:[arena_owner],8	;set impossible owner
	mov	word ptr es:[arena_name], 'DS'	; System Data
	pop	es

	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate the rest of the memory

	mov	[memhi],ax		; start of the allocated memory
	mov	[memlo],0		;   to be used next.

;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
;;;; allocated.
;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
;;;; this time) to the top-of-the memory),here we are going to
;;;; 1). "setblock" from memhi to confbot.
;;;; 2). "alloc" from confbot to the top of the memory.
;;;; 3). "free alloc memory" from memhi to confbot.

;memory allocation for sysinit,confbot module.

	mov	es,ax
	mov	bx,[confbot]
	sub	bx,ax			; confbot - memhi
	dec	bx			; make a room for the memory block id.
	dec	bx			; make sure!!!.
	mov	ah,setblock
	int	21h			; this will free (confbot to top of memory)
	mov	bx,0ffffh
	mov	ah,alloc
	int	21h
	mov	ah,alloc
	int	21h			; allocate (confbot to top of memory)
	mov	[area],ax		; save allocated memory segment.
					; need this to free this area for command.com.
	mov	es,[memhi]
	mov	ah,49h			; free allocated memory.
	int	21h			; free (memhi to confbot(=area))

endfile_ret:
	ret

; End of "EndFile" DOS structure configuration.

IFDEF	CONFIGPROC
;-------------------------------------------------------------------------
; Do_Install_Exec
;
; This procedure is used to EXEC a program being loaded via the 
; "install=" mechanism in config.sys.  It does this by setting up
; the parameters, and then jumping to sysinit_base, which has been
; setup in low memory.  When complete, sysinit_base will jump back
; up to this procedure (if sysinit remains uncorrupted by the installed
; program).

do_install_exec proc near		; now,handles install= command.

	push	si			; save si for config.sys again.

; we are going to call load/exec function.
; set es:bx to the parameter block here;;;;;;;
; set ds:dx to the asciiz string. remember that we already has 0
; after the filename. so parameter starts after that. if next
; character is a line feed (i.e. 10),then assume that the 0
; we already encountered used to be a carrage return. in this
; case,let's set the length to 0 which will be followed by
; carridge return.

; es:si -> command line in config.sys. points to the first non blank
;character after =.

	push	es
	push	ds
	pop	es
	pop	ds			; es->sysinitseg,ds->confbot seg
	assume	ds:nothing
	mov	dx,si			; ds:dx->file name,0 in config.sys image.

	xor	cx,cx
	cld
	mov	cs:ldexec_start,' '	; clear out the parm area
	mov	di,offset ldexec_parm
installfilename:			;  skip the file name
	lodsb				;  al = ds:si; si++
	cmp	al,0
	je	got_installparm
	jmp	installfilename
got_installparm:			;  copy the parameters to ldexec_parm
	lodsb
	mov	es:[di],al
	cmp	al,lf			;  line feed?
	je	done_installparm
	inc	cl			;  # of char. in the parm.
	inc	di
	jmp	got_installparm
done_installparm:
	mov	byte ptr cs:[ldexec_line],cl ;	length of the parm.
	cmp	cl,0			;if no parm,then
	jne	install_seg_set 	; let the parm area
	mov	byte ptr cs:[ldexec_start],cr ;	starts with cr.
install_seg_set:
	mov	word ptr cs:0,0		; make a null environment segment
	mov	ax,cs			; by overlap jmp instruction of sysinitseg.

;---------------------------------------------------M067---------------
;
; 	the environment pointer is made 0. so the current environment ptr.
; 	will be the same as pdb_environ which after dosinit is 0.
;
; 	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.
;
;
; 	instexe.exec0_environ need not be initialized to 0 above. It was
; 	done as a fix for bug #529. The actual bug was in NLSFUNC and
; 	was fixed. 
;
;--------------------------------------------------------------------------
ifdef   MULTI_CONFIG
;
;   If there's any environment data in "config_wrkseg", pass to app
;
        mov     cx,ax
        cmp     cs:[config_envlen],0
        je      no_envdata2
        mov     cx,cs:[config_wrkseg]
no_envdata2:
endif  ;MULTI_CONFIG

        mov     cs:[instexe.exec0_environ],cx ; set the environment seg.

	mov	word ptr cs:[instexe.exec0_com_line+2],ax ; set the seg.
	mov	word ptr cs:[instexe.exec0_5c_fcb+2],ax
	mov	word ptr cs:[instexe.exec0_6c_fcb+2],ax
	call	sum_up
	mov	es:checksum,ax		; save the value of the sum
	xor	ax,ax
	mov	ah,exec			; load/exec
	mov	bx,offset instexe	; es:bx -> parm block.
	push	es			; save es,ds for load/exec
	push	ds			; these registers will be restored in sysinit_base.
	jmp	cs:dword ptr sysinit_base_ptr ; jmp to sysinit_base to execute
					; load/exec function and check sum.

;j.k. this is the returning address from sysinit_base.

sysinitptr:				; returning far address from sysinit_base
	pop	si			; restore si for config.sys file.
	push	es
	push	ds
	pop	es
	pop	ds			; now ds - sysinitseg,es - confbot
        jnc     install_exit_ret

	push	si			; error in loading the file for install=.
	call	badload 		; es:si-> path,filename,0.
	pop	si

install_exit_ret:
	ret

do_install_exec endp

ENDIF ; CONFIGPROC


;**	ParaRound - Round Up length to paragraph multiple
;
;	ParaRound rounds a byte count up to a multiple of 16, then divides
;	by 16 yielding a "length in paragraphs" value.
;
;	ENTRY	(ax) = byte length
;	EXIT	(ax) = rounded up length in paragraphs
;	USES	ax, flags

Procedure ParaRound

	add	ax,15
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	ret

EndProc   ParaRound


;------------------------------------------------------------------------------
; sysinit_base module.
;
; This module is relocated by the routine EndFile to a location in low
; memory.  It is then called by SYSINIT to perform the EXEC of programs
; that are being loaded by the "install=" command.  After the EXEC call
; completes, this module performs a checksum on the SYSINIT code (at the
; top of memory) to be sure that the EXECed program did not damage it.
; If it did, then this module will print an error message and stop the
; system.  Otherwise, it returns control to SYSINIT.
;
;
;in: after relocation,
;    ax = 4b00h - load and execute the program dos function.
;    ds = confbot. segment of config.sys file image
;    es = sysinitseg. segment of sysinit module itself.
;    ds:dx = pointer to asciiz string of the path,filename to be executed.
;    es:bx = pointer to a parameter block for load.
;    SI_end (byte) - offset vaule of end of sysinit module label
;    bigsize (word) - # of word from confbot to SI_end.
;    chksum (word) - sum of every byte from confbot to SI_end in a
;			word boundary moduler form.
;    sysinit_ptr (dword ptr) - return address to sysinit module.
;
;note: sysinit should save necessary registers and when the control is back

	public	sysinit_base
sysinit_base:
	mov	word ptr cs:sysinit_base_ss,ss	; save stack
	mov	word ptr cs:sysinit_base_sp,sp
	int	21h				; load/exec dos call.
	mov	ss,word ptr cs:sysinit_base_ss	; restore stack
	mov	sp,word ptr cs:sysinit_base_sp
	pop	ds				; restore confbot seg
	pop	es				; restore sysinitseg
	jc	sysinit_base_end		; load/exec function failed.
						; at this time,i don't have to worry about
						; that sysinit module has been broken or not.
	call	sum_up				; otherwise,check if it is good.
	cmp	es:checksum,ax
	je	sysinit_base_end

;	memory broken. show "memory allocation error" message and stall.

	mov	ah,9
	push	cs
	pop	ds
	mov	dx,offset mem_alloc_err_msgx - sysinit_base
	int	21h

        public  stall
stall:  hlt                             ;use HLT to minimize energy consumption
        jmp     stall

sysinit_base_end: jmp es:sysinit_ptr	;return back to sysinit module

sum_up:

;in:   es - sysinitseg.
;out:  ax - result
;
;remark: since this routine will only check starting from "locstack" to the end of
;	 sysinit segment,the data area, and the current stack area are not
;	 coverd.  in this sense,this check sum routine only gives a minimal
;	 gaurantee to be safe.
;
;first sum up confbot seg.

	push	ds
	mov	ax,es:confbot
	mov	ds,ax
	xor	si,si
	xor	ax,ax
	mov	cx,es:config_size	; if config_size has been broken,then this
					;whole test better fail.
	shr	cx,1			; make it a word count
	jz	sum_sys_code		; when config.sys file not exist.
sum1:
	add	ax,ds:word ptr [si]
	inc	si
	inc	si
	loop	sum1
;now,sum up sysinit module.
sum_sys_code:
	mov	si, locstack	        ; starting after the stack.  M069
					;  this does not cover the possible stack code!!!
	mov	cx,offset SI_end	; SI_end is the label at the end of sysinit
	sub	cx,si			;  from after_checksum to SI_end
	shr	cx,1
sum2:
	add	ax,es:word ptr [si]
	inc	si
	inc	si
	loop	sum2
	pop	ds
	ret

sysinit_base_ss equ $-sysinit_base
	dw	?
sysinit_base_sp equ $-sysinit_base
	dw	?
mem_alloc_err_msgx:

       include msbio.cl4		; memory allocation error message

end_sysinit_base label byte

;-------------------------------------------------------------------------
; Set_Buffer
;
;function: set buffers in the real memory.				  
;	   lastly set the memhi,memlo for the next available free address.
;
;input:    ds:bx -> buffinfo.
;	   [memhi]:[memlo = 0] = available space for the hash bucket.	  
;	   singlebuffersize = buffer header size + sector size		  
;
;output:   buffers Queue established.	       				   
;	   [memhi]:[memlo] = address of the next available free space.	   
;

set_buffer proc near

	assume	ds:nothing
	xor	dl, dl				; assume buffers not in HMA
	call	GetBufferAddr
	je	@f
	mov	dl, 1				; buffers in HMA
@@:
	mov	word ptr ds:[bx].Buff_Queue,di	; head of Buff Q
	mov	word ptr ds:[bx].Buff_Queue[2],es
	mov	word ptr ds:[bx.Dirty_Buff_Count],0 ;set dirty_count to 0.

	mov	ax, di
	mov	cx, [buffers]
	push	di				; remember first buffer

;	for each buffer

nxt_buff:
	call	set_buffer_info 		;set buf_link,buf_id...
	mov	di, ax
	loop	nxt_buff

	sub	di, [singlebuffersize]		; point to last buffer

	pop	cx				; get first buffer
	mov	word ptr es:[di].buf_next, cx	; last->next = first
	xchg	cx, di
	mov	word ptr es:[di].buf_prev, cx	; first->prev = last

	or	dl, dl				; In HMa ?
	jz	@f				; no
	mov	byte ptr ds:[bx].Buff_In_HMA, 1
	mov	ax, memhi			; seg of scratch buff
	mov	word ptr ds:[bx].Lo_Mem_Buff, 0	; offset of sctarch buff is 0
	mov	word ptr ds:[bx].Lo_Mem_Buff[2], ax
	mov	ax, singlebuffersize		; size of scratch buff
	sub	ax, bufinsiz			; buff head not reqd
@@:
	add	memlo, ax
	or	[setdevmarkflag], for_devmark
	call	round
	ret
set_buffer endp

;;---------------------------------------------------------------------------
;
; procedure : GetBufferAddr
;
;		Gets the buffer address either in HMA or in Lo Mem
;
; returns in es:di the buffer adress
; returns NZ if allocated in HMA
;
;;---------------------------------------------------------------------------

GetBufferAddr	proc	near
		push	bx
		push	dx
		mov	ax, singlebuffersize
		mul	buffers
		add	ax, 15
		and	ax, not 15		; para round
		mov	bx, ax
		mov	ax, ((multMULT shl 8)+multMULTALLOCHMA)
		int	2fh
		cmp	di, 0ffffh
		jne	got_hma
		mov	di, 0			; dont xor di,di Z flag needed
		mov	es, [memhi]
got_hma:
		pop	dx
		pop	bx
		ret
GetBufferAddr	endp


set_buffer_info proc

;function: set buf_link,buf_id,buf_sector
;
;in: es:di -> buffer header to be set.
;    ax = di
;
;out:
;    above entries set.

	push	[buf_prev_off]
	pop	es:[di.buf_prev]
	mov	buf_prev_off,ax
	add	ax,[singlebuffersize]		;adjust ax
	mov	word ptr es:[di.buf_next],ax
	mov	word ptr es:[di.buf_id],00ffh	;new buffer free
	mov	word ptr es:[di.buf_sector],0	;to compensate the masm 3 bug
	mov	word ptr es:[di.buf_sector+2],0 ;to compensate the masm 3 bug
	ret
set_buffer_info endp


;------------------------------------------------------------------------------
; ibmstack initialization routine.
	if	stacksw
.sall
;
;	to follow the standard interrupt sharing scheme, msstack.asm
;	has been modified.  this initialization routine also has to
;	be modified because for the interrupt level 7 and 15, firstflag
;	should be set to signal that this interrupt handler is the
;	first handler hooked to this interrupt vector.
;	we determine this by looking at the instruction pointed by
;	this vector.  if it is iret, then this handler should be the
;	first one.  in our case, only the interrupt vector 77h is the
;	interrupt level 15. (we don't hook interrupt level 7.)
;
;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
;	some design changes are needed to the above interrupt sharing
;	method.  the above sharing scheme assumes that 1). interrupt
;	sharing is never done on levels that have bios support. 2). "phantom"
;	interrupts would only be generated on levels 7 and 15.
;	these assumptions are not true any more. we have to use the firstflag
;	for every level of interrupt.  we will set the firstflag on the following
;	conditions:
;
;	 a.	 if the cs portion of the vector is 0000, then "first"
;	 b. else if cs:ip points to valid shared header, then not "first"
;	 c. else if cs:ip points to an iret, then "first"
;	 d. else if cs:ip points to dummy, then "first"
;
;	where dummy is - the cs portion must be f000, and the ip portion must
;	be equal to the value at f000:ff01. this location is the initial value
;	from vector_table for interrupt 7, one of the preserved addresses in all
;	the bioses for all of the machines.
;
;	system design group requests bios to handle the phantom interrupts.
;
;	the "phantom" interrupt is an illegal interrupt such as an interrupt
;	produced by the bogus adapter card even without interrupt request is
;	set.  more specifically, 1). the 8259 has a feature when running in
;	edge triggered mode to latch a pulse and present the interrupt when
;	the processor indicates interrupt acknowledge (inta).  the interrupt
;	pulse was exist at the time of inta to get a "phantom" interrupt.
;	2). or, this is caused by adapter cards placing a glitch on the
;	interrupt line.
;
;	to handle those "phantom" interrupts, the main stack code will check
;	the own firstflag, and if it is not "first" (which means the forward
;	pointer points to the legal shared interrupt handler), then pass the
;	control.  if it is the first, then the following action should be
;	taken.	we don't have to implement skack logic in this case.
;
;	to implement this logic, we rather choose a simple method.
;	if ont of the above "firstflag" conditions is met, we are not
;	going to hook this interrupt vector.  the reason is if the original
;	vector points to "iret" and do nothing, we don't need
;	to implement the stack logic for it.  this will simplify implementation
;	while maintaining compatibility with the old version of dos.
;	this implies that in the main stack code, there might be a stack code
;	that will never be used, a dead code.
;
;in - cs, ds -> sysinitseg, es -> relocated stack code & data.

	page
	assume	ds:sysinitseg
stackinit	proc near

	push	ax
	push	ds
	push	es
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	bp

;currently es -> stack code area

	mov	ax, cs:[stack_count]		;defined in cs
	mov	es:[stackcount], ax		;defined in stack code area
	mov	ax, [stack_size]		;in cs
	mov	es:[stacksize], ax
	mov	ax, word ptr cs:[stack_addr]	; offset
	mov	word ptr es:[stacks], ax
	mov	ax, word ptr cs:[stack_addr+word] ; segment
	mov	word ptr es:[stacks+word], ax

; initialize the data fields with the parameters

; "firstentry" will always be at stacks

	mov	bp, word ptr es:stacks		; get offset of stack
	mov	es:firstentry,bp

; the stacks will always immediately follow the table entries

	mov	ax,entrysize
	mov	cx,es:stackcount
	mul	cx
	add	ax,bp
	mov	es:stackat,ax
	mov	bx,ax
	sub	bx,2

; zero the entire stack area to start with

	mov	di,es:stackat
	mov	ax,es:stacksize
	mul	cx
	mov	cx,ax
	xor	ax,ax
	push	es
	pop	ds				;ds = relocated stack code seg.
	assume	ds:nothing

;now, ds -> stack code area

	mov	es, word ptr ds:[stacks+2]	; get segment of stack area.
	cld
	rep	stosb

	mov	cx, ds:stackcount

; loop for "count" times, building a table entry
;  cs = sysinitseg, ds = relocated stack code seg , es = segment of stack space
;  cx = number of entries
;  es:bp => base of stacks - 2
;  es:bx => first table entry

buildloop:
	mov	es:byte ptr allocbyte[bp],free
	mov	es:byte ptr intlevel[bp],al	;ax = 0
	mov	es:word ptr savedsp[bp],ax
	mov	es:word ptr savedss[bp],ax
	add	bx,ds:stacksize
	mov	es:word ptr newsp[bp],bx
	mov	es:[bx],bp
	add	bp,entrysize

	loop	buildloop

	sub	bp,entrysize
	mov	ds:lastentry,bp
	mov	ds:nextentry,bp

	push	ds
	mov	ax, 0f000h			;look at the model byte
	mov	ds, ax
	cmp	ds:byte ptr [0fffeh], mdl_convert ;convertible?
	pop	ds
	jne	skip_disablenmis

	mov	al,07h				; disable convertible nmis
	out	72h,al

skip_disablenmis:
	xor	ax,ax
	mov	es,ax				;es - segid of vector table at 0
	assume	es:nothing			;ds - relocated stack code segment

	cli

	irp	aa,<02,08,09,70>

	mov	si,aa&h*4		;pass where vector is to be adjusted
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx,offset old&aa	;pass where to save original owner pointer
	mov	dx,offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler,
					;  saving pointer to original owner
	endm

	irp	aa,<0a,0b,0c,0d,0e,72,73,74,76,77>	;shared interrupts

	mov	si,aa&h*4		;pass where vector is to be adjusted
	push	ds			;save relocated stack code segment
	lds	bx, es:[si]		;ds:bx -> original interrupt handler
	push	ds
	pop	dx			;dx = segment value

	cmp	dx,0
	jz	int&aa&_first

	cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
	jz	int&aa&_first

	cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
	jz	int&aa&_not_first

	cmp	dx,0f000h		;rom bios segment
	jnz	int&aa&_not_first

	push	es
	push	dx
	mov	dx,0f000h
	mov	es,dx
	cmp	bx,word ptr es:0ff01h
       	pop	dx
	pop	es
	jz	int&aa&_first

int&aa&_not_first:			;not the first. we are going to hook vector.
	pop	ds
	mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	mov	bx, offset old&aa	;pass where to save original owner pointer
	mov	dx, offset int&aa	;pass where new handler is
	call	new_init_loop		;adjust the vector to new handler, saving
					;pointer to original owner.
	jmp	short int&aa&_end
int&aa&_first:				 ;the first. don't have to hook stack code.
	pop	ds
int&aa&_end:

	endm

	push	ds
	mov	ax, 0f000h		;loook at the model byte
	mov	ds, ax
	cmp	ds:byte ptr [0fffeh], mdl_convert	;pc convertible?
	pop	ds
	jne	skip_enablenmis

	mov	al,27h				; enable convertible nmis
	out	72h,al

skip_enablenmis:
	sti
	mov	ax,Bios_Data
	mov	ds,ax
	assume	ds:Bios_Data


	mov	[int19sem],1		; indicate that int 19
					; initialization is complete

	pop	bp			; restore all
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx

	pop	es
	pop	ds
	assume	ds:sysinitseg

	pop	ax
	ret
stackinit	endp

new_init_loop proc near

;input: si=ofset into vector table of the particular int vector being adjusted
;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
;	dx=ds:offset of intxx, the new interrupt handler
;	di=offset value of int19old&aa variable in bios.
;	es=zero, segid of vector table
;	ds=relocated stack code segment

	mov	ax,es:[si+0]		;remember offset in vector
	mov	word ptr ds:[bx],ax	; to original owner in ds
	mov	ax,es:[si+2]		;remember segid in vector
	mov	word ptr ds:[bx]+2,ax	; to original owner in ds

	push	ds
	mov	ax,Bios_Data
	mov	ds,ax			;set int19oldxx value in bios for
	mov	ax,es:[si+0]		;int 19 handler
	mov	word ptr ds:[di],ax
	mov	ax,es:[si+2]
	mov	word ptr ds:[di]+2,ax
	pop	ds

	mov	word ptr es:[si+0],dx  ;set vector to point to new int handler
	mov	es:[si+2],ds
	ret
new_init_loop endp


.xall
	endif
;------------------------------------------------------------------------------
	public	setdevmark
setdevmark proc

;set the devmark for mem command.
;in: [memhi] - the address to place devmark
;    [memlo] = 0
;    al = id for devmark_id
;out: devmark established.
;     the address saved in cs:[devmark_addr]
;     [memhi] increase by 1.

	push	es
	push	cx

	mov	cx,cs:[memhi]
	mov	cs:[devmark_addr],cx
	mov	es,cx
	mov	es:[devmark_id],al
	inc	cx
	mov	es:[devmark_seg],cx

	pop	cx
	pop	es
	inc	cs:[memhi]
	ret
setdevmark endp


	ifdef	TAIWAN

;---------------------
; entry : none
; exit : ax = 0  --> oem local driver not found
;	    = 1  --> oem local driver found
; destore : ds,es,bx,cx,dx,si,di
; description :
;  search config.sys to find oem local driver.
;  oem local driver should in \csi\driver\ directory .
;  if (found oem local driver in config.sys)
;	ax=1;
;  else
;	ax=0;
;  return;
;  ps. please see state diagram for state description.
;---------------------

chkoemlocaldrv proc near
	push	es
	push	ds
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	call	chkconfig
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ds
	pop	es
	ret
chkoemlocaldrv endp

config_sys db	"\CONFIG.SYS",0
sizeofconfig dw 0
filehandle dw	0
workingmemptr dw 0
deviceid db	"DEVICE"
csidrvid db	"CSI\DRIVER\"
localdrvname dw 0
chkconfig proc	near
	call	preprocess
	jnc	initstate
	jmp	notfoundret

;
; processing config.sys
;
; state 0
; ds:si --> current line ( end of line is oah or 0dh )

initstate:
	mov	si,dx
state_0:
	push	cs
	pop	es
	mov	di,offset deviceid
	mov	cx,3
	repz	cmpsw
	jz	state_1
	mov	ax,0ffffh
	jmp	state_10
state_1:
	lodsb
	cmp	al,' '
	jz	state_1
	cmp	al,'='
	jz	state_2
state_10a:
	jmp	state_10
state_2:
	lodsb
	cmp	al,' '
	jz	state_2
	cmp	al,'\'
	jz	state_5
	cmp	al,'A'
	jb	state_10a
	cmp	al,'z'
	ja	state_10a
state_3:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
state_4:
	lodsb
	cmp	al,':'
	jz	state_6
	jmp	state_10
state_5:
	dec	si
	mov	cs:[localdrvname],si
	inc	si
	jmp	state_7
state_6:
	lodsb
	cmp	al,'\'
	jz	state_7
	cmp	al,'c'
	jne	state_10a
	inc	si
state_7:
	mov	di,offset csidrvid
	mov	cx,11
	repz	cmpsb
	jnz	state_10a
state_8:
	lodsb
	cmp	al,'1'
	jb	state_10
	cmp	al,'z'
	ja	state_10
state_9:
tryopenlocaldrv:
	mov	dx,cs:[localdrvname]
	mov	si,dx
chknextbyte:
	lodsb
	cmp	al,0h
	jz	openfile
	cmp	al,' '
	jne	chknextbyte
	dec	si
	mov	byte ptr ds:[si],0
openfile:
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	notfoundret
	mov	bx,ax			; bx = file handle
	mov	ah,3eh
	int	21h			; close local driver
	jc	notfoundret
	jmp	foundret

state_10:
	cmp	al,1ah			; look current char. == eof ?
	jz	notfoundret
	lodsb
	cmp	al,0
	jz	newlinestate
	cmp	al,1ah
	jz	notfoundret
	jmp	state_10
newlinestate:
	lodsb
	cmp	al,1ah
	jz	notfoundret
	cmp	al,0
	jz	newlinestate
	dec	si
	jmp	state_0
notfoundret:
	mov	ax,0
	jmp	freemem
foundret:
	mov	ax,1
freemem:
	push	ax
	call	freememory
	pop	ax
	ret

chkconfig endp

preprocess proc near
	push	cs
	pop	ds
	mov	dx,offset config_sys
	mov	ax,3d00h		; open config.sys
	stc
	int	21h
	jc	errorfile

; get size of config.sys

	mov	bx,ax			; bx = file handle
	mov	cs:[filehandle],bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,4202h		; move file ptr
	int	21h
	mov	cs:[sizeofconfig],ax	; ax == size of config.sys
	xor	dx,dx			; ignore more than 64k of config
	mov	ax,4200h		; mov file ptr to beginning of file
	int	21h

; allocate for config.sys

	mov	ax,cs:[sizeofconfig]
	add	ax,15			; change to para
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	add	ax,20h
	mov	bx,ax			; size of memory in para
	mov	ah,48h
	int	21h
	jc	memerr
					; ax --> free memory
	mov	cs:[workingmemptr],ax

; read config.sys

	mov	bx,cs:[filehandle]	; file handle
	mov	cx,cs:[sizeofconfig]	; byte count of reading
	xor	dx,dx
	mov	ds,ax			; ds:dx --> buffer
	mov	ah,3fh
	int	21h
	jc	errorfile

; translate to upper case

	call	transtoupper
	clc
	ret
errorfile:
memerr:
	stc
	ret
preprocess endp

; entry : ds:dx --> buffer
; exit : none
; description : translate all letter in buffer to upper type
;	ps ,don't change ds:dx

transtoupper proc near
	cld
	mov	cx,cs:[sizeofconfig]
	mov	si,dx
transnext:
	lodsb
	cmp	al,'A'
	jb	chklfcr
	cmp	al,'z'
	ja	chkcounter
	sub	al,'a'-'A'
	mov	ds:[si-1],al
	jmp	chkcounter
chklfcr:
	cmp	al,0dh
	jz	setzero
	cmp	al,0ah
	jz	setzero
	jmp	chkcounter
setzero:
	mov	al,0
	mov	ds:[si-1],al
chkcounter:
	loop	transnext
	ret
transtoupper endp

;entry : none ( free memory block ptr in [workingmem] )
;exit : none

freememory proc near
	mov	ax,cs:[workingmemptr]
	mov	es,ax
	mov	ah,49h
	int	21h
	ret
freememory endp


; name : maketempvector
; entry : es:bx -->
;		dd	original int 9 vector	  ( offfset ,segment )
;		dd	original int 10h vector   ( offfset ,segment )
;		dd	original int 16h vector   ( offfset ,segment )
;
; exit : none
; description : 1. save local driver table in static area
;		2. make temp. vector for int9 ,10h ,16h
;
oemdriverinst dw 0
orgvectblptr dd 0

	db	0eah
dummyint9 dd	0
	db	0eah
dummyint10h dd	0
	db	0eah
dummyint16h dd	0

csiint9 dd	0
csiint10h dd	0
csiint16h dd	0

maketempvector proc near
	push	ds
	push	ax
	push	di
	push	si
	push	cx

; save table ptr

	mov	word ptr cs:[orgvectblptr],bx
	mov	word ptr cs:[orgvectblptr+2],es
	cmp	cs:oemdriverinst,0
	jnz	ignoreint9

; make temp. vector for int 9 ,

	mov	bx,9			; int #
	push	cs
	pop	es
	mov	di,offset csiint9	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint9	; ds:si --> dummy int service
	call	dummyvector

ignoreint9:

; make temp. vector for int 10h

	mov	bx,10h			; int #
	push	cs
	pop	es
	mov	di,offset csiint10h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint10h	; ds:si --> dummy int service
	call	dummyvector

; make temp. vector for  int 16h

	mov	bx,16h			; int #
	push	cs
	pop	es
	mov	di,offset csiint16h	; es:di --> store area for csi vector
	push	cs
	pop	ds
	mov	si,offset dummyint16h	; ds:si --> dummy int service
	call	dummyvector
	pop	cx
	pop	si
	pop	di
	pop	ax
	pop	ds
	ret


maketempvector endp

;name	: dummyvector
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
; exit : none
; description :
;		setting dummy vector of int 9 ,10h,16h
;		for recover csi vector
;		/* phase 1*/
;		[ds:si]=[0:bx*4]
;		[ds:si+2]=[0:bx*4+2]
;		/* phase 2*/
;		[es:di]=[0:bx*4]
;		[es:di+2]=[0:bx*4+2]
;		/* phase 2*/
;		[0:bx*4]=si-1;
;		[0:bx*4+2]=ds;

dummyvector proc near
	shl	bx,1			; bx <- bx*4
	shl	bx,1			; ie ,get offset of vector

; phase 1
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	mov	ax,es:[bx]		; get offset  ds-->0
	mov	ds:[si],ax		; store  offset
	mov	ax,es:[bx+2]		; get offset  ds-->0
	mov	ds:[si+2],ax		; store segment
	pop	es

; phase 2
; ds --> 0
; ds:bx --> cpu int vector table

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	ax,ds:[bx]		; get offset
	mov	es:[di],ax		; store  offset
	mov	ax,ds:[bx+2]		; get offset
	mov	es:[di+2],ax		; store segment
	pop	ds

; phase 3
; es --> 0
; es:bx --> cpu int vector table

	xor	ax,ax
	push	es
	mov	es,ax
	dec	si
	mov	es:[bx],si
	mov	ax,ds
	mov	es:[bx+2],ax
	pop	es
	ret
dummyvector endp

; name : recovercsiint
; entry : none
; exit :none
; description :
;	recover int 9 ,10h,16h ,for csi vector

recovercsiint proc near
	push	es
	push	ds
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di

;recover int 9

	cmp	cs:oemdriverinst,0
	jnz	ignoreint9recover

	push	cs
	pop	ds
	mov	si,offset dummyint9
	push	cs
	pop	es

	mov	di,offset csiint9
	mov	bx,9
	mov	ax,0
	call	recoverint
ignoreint9recover:

; recover int 10h

	push	cs
	pop	ds
	mov	si,offset dummyint10h
	push	cs
	pop	es
	mov	di,offset csiint10h
	mov	bx,10h
	mov	ax,0+4
	call	recoverint

;recover int 16h

	push	cs
	pop	ds
	mov	si,offset dummyint16h
	push	cs
	pop	es
	mov	di,offset csiint16h
	mov	bx,16h
	mov	ax,0+4+4
	call	recoverint
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	ds
	pop	es
	ret
recovercsiint endp

; name : recoverint
; entey : ds:si --> dummy int sevice routine
;	  es:di --> point to  csi vector store area
;	  bx  == int number
;	  ax  == 0	; int 9
;		 4	; int 10h
;		 4+4	; int 16h
; exit : none
; description :
;	  1. if( [0:bx*4] == si-1  .and.  [es:bx*4+2] == ds )
;	     {
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;	     }
;	     else
;	     {
;		 /* phase 1 */
;		 [ds:si]  = [(*orgvectblptr)+ax]
;		 [ds:si+2]= [(*orgvectblptr)+ax+2];
;		 /* phase 2 */
;		 [orgvectblptr+ax) ]=[0:bx*4] ;
;		 [orgvectblptr+ax+2 ]=[0:bx*4+2] ;
;		 /* phase 3 */
;		 [0:bx*4]   = [es:di];
;		 [0:bx*4+2] = [es:di+2];
;
;
;	     }

;

recoverint proc near
;chek vector change ?
; es --> 0

	push	es
	mov	cx,ax
	xor	ax,ax
	mov	es,ax
	shl	bx,1
	shl	bx,1			; es:bx --> cpu int vector
	mov	ax,si
	dec	ax
	cmp	es:[bx],ax		; offset same ?
	jne	vectorbechanged

	mov	ax,ds
	cmp	es:[bx+2],ax		; segmnet same ?
	jne	vectorbechanged
	pop	es

; vector not be changed
; ds --> 0

	xor	ax,ax
	mov	ds,ax			; ds:bx --> cpu int vector
	mov	ax,es:[di]
	mov	ds:[bx],ax
	mov	ax,es:[di+2]
	mov	ds:[bx+2],ax
	ret

vectorbechanged:

;phase 1
; di:es --> addres of local driver

	pop	es
	push	di
	push	es
	mov	di,word ptr cs:[orgvectblptr]
	mov	es,word ptr cs:[orgvectblptr+2]
	add	di,cx
	mov	ax,es:[di]
	mov	ds:[si],ax
	mov	ax,es:[di+2]
	mov	ds:[si+2],ax

;phase2
; di:es --> addres of local driver
; ds --> 0

	push	ds
	xor	ax,ax
	mov	ds,ax
	mov	ax,ds:[bx]		; ds:bx --> cpu int vector
	mov	es:[di],ax
	mov	ax,ds:[bx+2]
	mov	es:[di+2],ax
	pop	ds
	pop	es
	pop	di

;phase3
; ds --> 0

	xor	ax,ax
	push	ds
	mov	ds,ax
	mov	cx,es:[di]
	mov	ds:[bx],cx		; ds:bx --> cpu int vector
	mov	cx,es:[di+2]
	mov	ds:[bx+2],cx
	pop	ds
	ret

recoverint endp

;name : chklocalexist
;entry : none
;exit :none
; descriptin : check local driver exist ?
;		if not exist system halt !
;		otherwise null return

chklocalexist proc near
	push	ax
	push	cx
	push	dx
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,01			; syscmd_extquerysysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	csisystemerror		; no,system halt
					; yes ,dx == country id
	push	dx			; save current id
	mov	dx,58h
	mov	ah,0dbh
	mov	al,80h			; module_extsysutil
	mov	cx,02			; syscmd_extsetsysmode
	int	16h
	test	ax,8000h		; bit 15 on
	jnz	localdrvnotfound	; no ,local driver error

	pop	cx
	cmp	cx,dx			; current id == previous id ?
	jnz	localdrvnotfound	; no ,local driver error

	pop	dx
	pop	cx
	pop	ax
	ret

localdrvnotfound:
csisystemerror:
	push	cs
	pop	ds
	mov	dx,offset bootfailmsg
	mov	ah,9
	int	21h
	cli
	hlt
	ret

	include	msbio.cl7		; bootfailmsg
chklocalexist endp
	endif

sysinitseg ends
	end


=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\syspre.asm ===
page	,160
	title	syspre.asm - pre-load and final placement of dblspace.bin
;/*
; *			 Microsoft Confidential
; *			 Copyright (C) Microsoft Corporation 1981-1992
; *			 All Rights Reserved.
; */

;	History:
;
;	    09-Jul-1992 chuckst    Initial version
;	    26-Jul-1992 chuckst    substantial changes for final placement
;				   of device driver
;
;	Exported Routines:
;
;	public	MagicPreload	; loads the MagicDrv driver and initializes it
;	public	MagicPostLoad	; does final default placement of Magicdrv.bin
;	public	MagicSetCdss	; let's us disable extra DblSpace drives
;
;	Design Notes:
;
;	    This code was basically stripped out of SYSCONF.ASM, in
;	    the function multi_pass, just after the label tryd:.
;	    The original implementation was to make a special
;	    call to multi_pass with a phoney 'organized' CONFIG.SYS,
;	    but the code is not in the greatest shape, so it was
;	    not really suitable.
;
;	    In this version of the code, I've added better
;	    comments on what the subroutines are expected
;	    to accomplish, and also optimized it a bit since
;	    we don't have to deal with as many special cases
;	    as the main DD loading code.


break	macro	; dummy empty macro for include files
	endm


	.xlist
	include biosseg.inc
	include version.inc
	include sysvar.inc
	include dpb.inc
	include syscall.inc
	include devsym.inc
	include devmark.inc
	include ds_vers.inc
	include curdir.inc
	include magicdrv.inc
	.list

	ifdef	dblspace_hooks

	public	MagicPreload	; loads the MagicDrv driver and initializes it
	public	MagicPostLoad	; does final default placement of Magicdrv.bin
	public	MagicSetCdss	; let's us disable extra DblSpace drives

SYSPRE_BADFILE_ERROR	=	40h	; problem loading dblspace.bin
SYSPRE_EXEC_FAIL_ERROR	=	41h
SYSPRE_MEMORY_ERROR	=	42h
SYSPRE_NO_UNITS_ERROR	=	43h
SYSPRE_TOO_MANY_UNITS_ERROR =	44h
SYSPRE_BAD_SECTOR_SIZE_ERROR =	45h
SYSPRE_NOT_MAGIC	=	46h
SYSPRE_DRIVER_FAILED	=	47h

	extrn	NullBackdoor:near
	extrn	baddblspace:byte
	extrn	packet:byte
	extrn	MagicBackdoor:dword

	if	ibmjapver
noexec	equ	   true
	else
noexec	equ	   false
	endif


	if	not ibmjapver
	extrn	 re_init:far
	endif

	ifdef	TAIWAN
	extrn	cdosinit:near
	endif

;---------------------------------------



sysinitseg segment
	assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing
	extrn	memhi:word
	extrn	alloclim:word


	extrn	ExecDev:near
	extrn	DevBreak:near
	extrn	tempcds:near
	extrn	round:near
	extrn	SizeDevice:near
	extrn	RoundBreakAddr:near
	extrn	DevSetBreak:near
	extrn	SetDevMark:near
	extrn	InitDevLoad:near

	extrn	unitcount:byte
	extrn	ConvLoad:byte
	extrn	DeviceHi:byte
	extrn	setdevmarkflag:byte
	extrn	drivenumber:byte
	extrn	devdrivenum:byte

	extrn	break_addr:dword
	extrn	dosinfo:dword
	extrn	DevEntry:dword
	extrn	bpb_addr:dword
	extrn	DevBrkAddr:dword
	extrn	DevCmdLine:dword

	extrn	DevSize:word
	extrn	DevLoadAddr:word
	extrn	DevLoadEnd:word
	extrn	DevSizeOption:word

	ifdef	COPYCDS
	extrn	newnum_cdss:word
	endif


MagicDDName	db	'\DBLSPACE.BIN',0

;***	MagicPreload - pre-load dblspace.bin
;
;	EXIT	ax = error code, 00 means none.
;		ZF = true if ax == 0
;

MagicPreload	proc	near

	mov	DeviceHi, 0		; not to be loaded in UMB
	mov	DevSizeOption, 0

	push	cs
	pop	ds			; BUGBUG - 7/9/92 chuckst - needed?

	mov	si,offset MagicDDName

;	MagicDrv won't actually look at the <null> command tail.

	mov	word ptr [bpb_addr],si	; pass the command line to the device
	mov	word ptr [bpb_addr+2],cs

	mov	word ptr DevCmdLine, si ; save it for error reporting
	mov	word ptr DevCmdLine+2, cs

	call	round			; normalize memhi:memlo (first free
;					;			   memory)

	push	cs
	pop	es			; get filename pointer to es:si
	call	SizeDevice		; get size of device file into DevSize
	mov	ax,SYSPRE_BADFILE_ERROR
	jc	pre_exit1

	mov	ConvLoad, 1		; Doesn't matter if DeviceHi==0

	call	InitDevLoad		; set up sub-arena, DevLoadAddr,
;					;  DevLoadEnd, and DevEntry
;					;  gets arena name from bpb_addr

;	check to make sure device driver fits our available space.

	mov	ax, DevLoadAddr
	add	ax, DevSize		; calculate seg after DD load
	jc	pre_exit_memory_err1	; choke if overflows address space
	cmp	DevLoadEnd, ax		; does it overflow available space?
	jae	loaddev 		; we're golden if not

pre_exit_memory_err1:
	mov	ax,SYSPRE_MEMORY_ERROR
pre_exit1:
	jmp	pre_exit


loaddev:
	lds	dx,DevCmdLine		; get the load file name
	assume	ds:nothing

	if	noexec
	les	bx,dword ptr cs:[memlo]
	call	ldfil			;load in the device driver

	else

	call	ExecDev 		; load device driver using exec call

	endif

	mov	ax,SYSPRE_EXEC_FAIL_ERROR
	jc	pre_exit1

	mov	word ptr break_addr, 0	; pass the limit to the DD
	mov	ax, DevLoadEnd
	mov	word ptr break_addr+2, ax


	les	bx,DevEntry		; point to the Magic DD header
	cmp	es:[bx].12h,'.,'	; is it our stamp?
	mov	ax,SYSPRE_NOT_MAGIC
	jnz	pre_exit_3		; abort if not MagicDrv!!!

;	Now save the backdoor entry.

	mov	cs:word ptr MagicBackdoor,14h
	mov	cs:word ptr MagicBackdoor+2,es

	mov	al,cs:drivenumber	; pass drive number to DBLSPACE as if
	mov	cs:devdrivenum,al	;  it is a normal block device driver

	push	cs
	pop	es			; calldev needs packet segment in es
	mov	bx,offset packet
	mov	ax,DS_INTERNAL_REVISION ; tell it what revision we expect
	call	cs:MagicBackdoor	; first time call is init entry point
;					;  with a standard device driver
;					;  init packet at es:bx
	jnc	no_driver_version_fail	; skip if not a version failure

;	In this case, we're going to display a message

	push	cs
	pop	ds
	mov	dx,offset baddblspace
	mov	ah,9
	int	21h			; display the message
	jmp	short fail_driver_load

no_driver_version_fail:
	or	ax,ax			; error code returned?????
	jz	magic_is_resident	; skip if no error

;	point backdoor call back to safe far return

fail_driver_load:
	mov	cs:word ptr MagicBackdoor,offset NullBackdoor
	mov	cs:word ptr MagicBackdoor+2,cs
	mov	ax,SYSPRE_DRIVER_FAILED ; error code
pre_exit_3:
	jmp	short pre_exit_2

;	Normalize the break_addr into ENDSEG:0 form.

magic_is_resident:
	mov	ax,word ptr break_addr
	add	ax,15
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1			; convert to paragraphs
	add	ax,word ptr break_addr+2 ; add to terminate segment
	mov	word ptr DevBrkAddr+2,ax
	mov	word ptr DevBrkAddr,0	; store normalized end here

;	see if we can move the bulk of the driver up out of the
;	way for now.

	mov	bx,4			; inquire how many paragraphs it wants
	call	cs:MagicBackdoor

	mov	bx,[alloclim]		; get top of free memory
	sub	bx,ax			; see how much we'll lower it
	cmp	bx,word ptr [DevBrkAddr+2] ; is there that much room free?
	jb	cant_move_driver	; if not, just leave it low

;	BUGBUG -- 29 Jul 92 -- chuckst -- If we are in a very low memory
;					situation, and there isn't enough
;					space free to copy the driver up,
;					we'll just leave it sitting where
;					it is.	The big disadvantage of
;					this is that it can't be placed
;					in a UMB, and the init-resident
;					code will stay resident.

	sub	[alloclim],ax		; allocate space!
	mov	es,[alloclim]
	mov	bx,6			; tell the driver to move itself
	call	cs:MagicBackdoor

	mov	word ptr [DevBrkAddr+2],ax ; save end of low stub

cant_move_driver:
	mov	ax,word ptr [DevBrkAddr+2] ; get terminate segment
	cmp	ax,DevLoadEnd		; terminate size TOO big?
	mov	ax,SYSPRE_MEMORY_ERROR
	ja	pre_exit2		;  error out if so

	lds	si,DevEntry		;set ds:si to header
	les	di,cs:[dosinfo] 	;es:di point to dos info

	jmp	short isblock

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; central error exit

pre_exit_memory_err:
	mov	ax,SYSPRE_MEMORY_ERROR
pre_exit_2:
	jmp	pre_exit

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;
;------ deal with block device drivers
;
isblock:
	mov	al,cs:[unitcount]	;if no units found, erase the device
	or	al,al
	jz	pre_exit_no_units_err

	mov	[si.sdevname],al	; number of units in name field
;					;  device drivers are *supposed*
;					;  to do this for themselves.

	xor	ah,ah
	mov	cx,ax
	mov	dh,ah
	mov	dl,es:[di.sysi_numio]	;get number of devices into dx

	mov	ah,dl
	add	ah,al			; check for too many devices
	cmp	ah,26			; 'A' - 'Z' is 26 devices

	ja	pre_exit_too_many_units_err

	or	cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; alloc the device
	jc	pre_exit_memory_err

	add	es:[di.sysi_numio],al	; update the amount

ifdef	COPYCDS
	xor	ah, ah
	mov	newnum_cdss, ax 	; save number of new CDSs to be built
endif ; COPYCDS

;	Note:  We won't add in the DblSpace drive count to [drivenumber],
;	which is used to inform future loadable devices of their base address.
;	Instead, we'll leave this alone, and after they load, call
;	back to DBLSPACE to shuffle the drives around.
;
;	add	cs:drivenumber,al	; remember amount for next device

	lds	bx,cs:[bpb_addr]	; point to bpb array

perunit:
	les	bp,cs:[dosinfo]
	les	bp,dword ptr es:[bp.sysi_dpb]	;get first dpb

scandpb:
	cmp	word ptr es:[bp.dpb_next_dpb],-1
	jz	foundpb
	les	bp,es:[bp.dpb_next_dpb]
	jmp	scandpb

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;	Here are some centrally located error exits

pre_exit_too_many_units_err:
	mov	ax,SYSPRE_TOO_MANY_UNITS_ERROR
	jmp	short pre_exit2

pre_exit_no_units_err:
	mov	ax,SYSPRE_NO_UNITS_ERROR
pre_exit2:
	jmp	pre_exit
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;	We've found the end of the DPB chain.  Now extend it.

foundpb:
	mov	ax,word ptr cs:[DevBrkAddr]
	mov	word ptr es:[bp.dpb_next_dpb],ax
	mov	ax, word ptr cs:[DevBrkAddr+2]
	mov	word ptr es:[bp.dpb_next_dpb+2],ax

	les	bp,dword ptr cs:[DevBrkAddr]
	add	word ptr cs:[DevBrkAddr],dpbsiz

	call	RoundBreakAddr

	mov	word ptr es:[bp.dpb_next_dpb],-1
	mov	es:[bp.dpb_first_access],-1

	mov	si,[bx] 			;ds:si points to bpb
	inc	bx
	inc	bx				;point to next guy
	mov	word ptr es:[bp.dpb_drive],dx
	mov	ah,setdpb			;hidden system call
	int	21h

	mov	ax,es:[bp.dpb_sector_size]
	push	es
	les	di,cs:[dosinfo] 		;es:di point to dos info
	cmp	ax,es:[di.sysi_maxsec]
	pop	es
	mov	ax,SYSPRE_BAD_SECTOR_SIZE_ERROR
	ja	pre_exit

	push	ds
	lds	ax,cs:[DevEntry]
	mov	word ptr es:[bp.dpb_driver_addr],ax
	mov	word ptr es:[bp.dpb_driver_addr+2],ds
	pop	ds

	inc	dl			; increment drive number
	inc	dh			; increment unit number
	loop	perunit

	push	cs			; restore addressability
	pop	ds

ifdef	COPYCDS
	xor	al, al			; build CDSs incrementally
endif ; COPYCDS

	call	tempcds 			; set cds for new drives

linkit:
	les	di,cs:[dosinfo] 		;es:di = dos table
	mov	cx,word ptr es:[di.sysi_dev]	;dx:cx = head of list
	mov	dx,word ptr es:[di.sysi_dev+2]

	lds	si,cs:[DevEntry]		;ds:si = device location
	mov	word ptr es:[di.sysi_dev],si	;set head of list in dos
	mov	word ptr es:[di.sysi_dev+2],ds

	mov	word ptr ds:[si],cx		;link in the driver
	mov	word ptr ds:[si+2],dx

;	For the magicdrv load case, assume only one device driver
;	per file.

	call	DevBreak		; mark successful install

	mov	cx, word ptr cs:[DevBrkAddr+2]	; pass it a work buffer
	mov	dx, cs:[alloclim]		;   address in cx (segment)
	sub	dx, cx				;   for len dx (paragraphs)

	mov	ax,5500h		; we're shuffle aware, but don't move
;					;  any drives at this point.
	mov	bx,2			; switch what we can now
	call	cs:MagicBackdoor

	xor	ax,ax			; no errors!!!!

pre_exit:
	or	ax,ax			; reset zero flag if error
	ret

MagicPreload	endp


;***	MagicPostload -- called to clean up and make sure Magic is final placed
;

MagicPostload	proc	near

	mov	ax,multMagicdrv
	mov	bx,MD_VERSION
	int	2fh
	or	ax,ax		; is it there?
	jnz	no_magic	; done if not
	test	dx,8000h	; is it already permanent?
	jz	no_magic	; done if so

	mov	bx,-1		; how much space does it want?
	mov	ax,multMagicdrv
	int	2fh		; get paragraphs into ax

;	Now adjust that for the extra 2 paragraph stub we're going to add

	add	ax,((offset tiny_stub_end - offset tiny_stub_start)+15)/16
	mov	DevSize,ax	; store that

	mov	DeviceHi, 0		; not to be loaded in UMB
	mov	DevSizeOption, 0
	mov	ConvLoad,1		; conventional load

	push	cs
	pop	ds			; BUGBUG - 7/9/92 chuckst - needed?

	mov	word ptr [bpb_addr],offset MagicDDName	; pass name so that
	mov	word ptr [bpb_addr+2],cs	; arena header can be set

	call	round			; normalize memhi:memlo

	call	InitDevLoad		; set up sub-arena, DevLoadAddr,
;					;  DevLoadEnd, and DevEntry
;					;  getss arena name from bpb_addr

;	check to make sure device driver fits our available space.

	mov	ax, DevLoadAddr
	add	ax, DevSize		; calculate seg after DD load
	mov	word ptr DevBrkAddr+2,ax ; save as ending address!
	mov	word ptr DevBrkAddr,0

;	Note:  no need to check out of memory here!  If we overflow the
;	       top, we just extend into the space where MagicDrv
;	       was temporarily located.  The driver should be smart
;	       enough to move itself correctly.

	mov	es, DevLoadAddr

;	First, move a little header in place so that this looks
;	to the mem command like a legitimate driver load.  Otherwise,
;	it will display garbage for the device name.

	mov	si,offset tiny_stub_start
	xor	di,di
	mov	cx,(offset tiny_stub_end - offset tiny_stub_start)
	rep	movsb			; move it!
	mov	ax,es			; advance es appropriately
	add	ax,((offset tiny_stub_end - offset tiny_stub_start)+15)/16
	mov	es,ax

	mov	ax,multMagicdrv
	mov	bx,-2			; final placement!!!!!
	int	2fh

	or	cs:[setdevmarkflag],for_devmark
	call	DevSetBreak		; go ahead and alloc mem for device
	call	DevBreak

no_magic:
	ret

MagicPostload	endp

;***	MagicSetCdss -- disable CDSs for still unmounted DblSpace drives
;
;	entry:
;	   CDSs are now persistent and in their final place

MagicSetCdss	proc	near

	mov	ax,multMagicdrv
	mov	bx,MD_VERSION	; get version
	int	2fh
	or	ax,ax		; is it there?
	jnz	magic_set_exit	; done if not

;	version call returned cl=first DblSpace drive in ASCII
;			      ch=number of DblSpace drive letters

	mov	al,cl		; get first DblSpace drive letter
	sub	al,'A'		; make it zero based.
	mov	dl,al		; and save for drive testing loop

	les	si,[dosinfo]	; point to DOS data area
	les	si,es:[si].sysi_cds ; fetch CDSs
	mov	ah,curdirLen
	mul	ah		; find first DblSpace CDS
	add	si,ax

	mov	cl,ch		; get DblSpace drive count into cx
	xor	ch,ch

;	We know cx > 0, or else the driver wouldn't have stayed resident

magic_set_cdss_1:

	push	si		; save cds pointer
	push	es
	push	cx		; save loop count
	push	dx		; and drive letter

	mov	ax,multMagicdrv
	mov	bx,MD_DRIVE_MAP ; inquire drive map
	int	2fh		; see if this is an unused DblSpace drive

	pop	dx
	pop	cx
	pop	es
	pop	si

	cmp	bl,dl		; if mapped to itself, it is vacant
	jnz	magic_set_cdss_2 ; skip if used

	and	es:[si].CURDIR_FLAGS,not CURDIR_inuse ; reset the bit in flags

magic_set_cdss_2:
	add	si,curdirLen
	inc	dl		; next drive
	loop	magic_set_cdss_1

magic_set_exit:
	ret

MagicSetCdss	endp


tiny_stub_start:
	dw	-1,-1		; phony device driver link
	dw	8000h		; mark as character device for MEM display
	dw	0,0		; strat and irpt
	db	'DBLSBIN$'	; magic default load
tiny_stub_end:


sysinitseg ends
	endif			; ifdef dblspace_hooks

	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power21\lpc.asm ===
PAGE    ,132
        TITLE   'Power Control Transient Portion'

;-----------------------------------------------------------------------------
;       Power control transient module for POWER.EXE
;
;       This file contains the transient code used to turn power
;       monitoring on and off from the command line.
;
;       Microsoft Confidential
;       Copyright (C) 1991 Microsoft Corporation 
;       All Rights Reserved.
;
; This code is bound to the device driver image of POWER.EXE.  This
; transient program can be used to turn power control on and off.
; POWER has the following options:
;
;       POWER [ADV | STD |OFF |SOUND |/?]
;               ADV   - Monitors applications and devices
;               STD   - Monitors devices only
;		OFF   - turns off all pw. management
;               SOUND - activate speaker during idle (debug version only) - toggle
;               /? - print help message
;
; MODIFICATIONS:
;	M004	9/5/91	NSM	power status from APM in BL reg. was trashed
;				and so we were skipping call to get and print
;				APM stats. Fixed by storing status and
;				using it whenever we need to look at current
;				POWER status
;	M007	09/11/91 SMR	B#2669. Registered POWER's 2f channels
;					in mult.inc
;	M009	09/11/91 SMR	Build non-debug version.
;
;  	M010	09/12/91 SMR	PWR_API returns 0 in AX instead of no carry flag
;				in case of no error
;	M011	09/17/91 NSM	PWR_API returns the version no in AX for the
;				install_chk call and so we shouldn't chk for
;				AX==0 for install-chk call.
;	M087	09/23/91 NSM	Install_chk returns 504d in BX and not 4d50
;				B#2756
;
;	M089	09/25/91 NSM	UI changes.	
;
;	M092	10/18/91 NSM	B#2872(5.1) Clear out BH
;				(correction for a typo: xor was entered as or)
;-----------------------------------------------------------------------------

Trans_Code      segment word public 'CODE'
Trans_Code      ends

Trans_Data      segment word public 'DATA'
Trans_Data      ends

Trans_Stack     segment para stack 'STACK'
        db      512 dup (?)
Trans_Stack     ends

break		macro		; satisfy mult.inc & pdb.inc		; M009
		endm							; M009

include		mult.inc				; M007
include         power.inc
include         pdb.inc

; DOS calls used
EXIT            equ     4Ch
OUT_STRING      equ     09h
OUT_CHAR        equ     02h

Trans_Data      segment
include         powermsg.inc

psp             dw      0,0             ; stores our PSP address 

digit_buf       db      8 dup (0)       ; stores chars generated by get_dec

idle_data	IDLE_INFO	<>

pow_status	db	0		; M004 ; to store current POWER
					; enabled/disabled state

Trans_Data      ends

Trans_Code      segment
        assume  cs:Trans_Code, ds:nothing, es:nothing

        extrn   get_dec:near, uldiv:near, lmul:near        
        
start:
        public  start
        mov     ax,Trans_Data
        mov     ds,ax                   ; set up data segment
        assume  ds:Trans_Data

        mov     [psp]+2,es              ; save our PSP address for later
        
; look at the command line and determine what we are supposed to be
; doing.  

        les     bx,dword ptr [psp]      ; recover our PSP address
        lea     di,es:[bx].PDB_TAIL
        cmp     es:[bx].PDB_TAIL,0      ; is there a command line?
	je	not_help		; no tail; go display stats
look_at_tail:
	inc	di			; skip the first blank in tail

clear_spaces:
        cmp     es:byte ptr [bx+di],' ' ; scan past any spaces
        jne     get_command_option      ; not a space, load it and check it
        inc     di
        jmp     short clear_spaces      ; assume we will stop on CR terminator

get_command_option:
        mov     ax,es:word ptr [bx+di]  ; get start of command line,
        cmp     ax,'?/'                 ; looks like /?
	jne	not_help
	jmp	display_help

not_help:

; We've established this is not /?.  Now check for other options        
; before proceeding, detect the presence of POWER by power detect call

	push	bx
	mov	ax,(MultPWR_API*256)+00h; POWER detect mult.call ; M007
	int	2fh
	cmp	ax,(MultPWR_API*256)+00h; MultAPI code unchanged ? ; M011
	jnz	chk_signature		; M011
to_open_fail:
	jmp	open_failed
chk_signature:
	cmp	bx,504dh		; M087 signature correct ?
	jne	to_open_fail

IFDEF	DEBUG
	push	di
        lea     dx,rev_msg      	; Display current rev. no & date
        mov     ah,OUT_STRING		;
        int     21h                     
	pop	di
ENDIF
	pop	bx

        mov     ax,es:word ptr [bx+di]  ; get start of command line,

        cmp     al,13                   ; is it the CR terminator?
        je      display_info            ; yes, just go display status
	cmp	al,0			; no tail at all
	je	display_info		; just display status

        or      ax,2020h                ; map to lower case -- this is a
                                        ; command line, so don't need lang.
                                        ; independence
; M089 BEGIN - UI changes

        cmp     ax,'da'                 ; turning on?
        je      turn_on_all
	cmp	ax,'ts'			; Standard ?
	je	turn_on_FW
        cmp     ax,'fo'                 ; looks like OFF?
        je      turn_off                ; 

; M089 END

IFDEF      DEBUG           ; only active in debug version
        cmp     ax,'os'                 ; looks like SOUND?
        jne     bad_command             ; none of the above, parameter error

; User requests we toggle control of speaker on at idle
	mov	ax,(MultPWR_API*256)+02h; change allocation strategy ; M007
	mov	bl,80h			; special value for SOUND toggle
	int	2fh
        jmp     short display_info      ; go show current state

bad_command:

ENDIF

; User provided an invalid command line

        lea     dx,bad_command_msg      ; scold the user
        jmp     err_exit

turn_on_all:        ; User requested power control be activated
	mov	bl,3			; set both F/W and S/W
;
change_pw_state:			; issue mult.int to turn on/off PW mgmt.
	mov	bh,1			; set  power state
	mov	al,I2F_PW_GET_SET_PWSTATE
	mov	ah,MultPWR_API		; M007
	int	2fh
        jmp     short display_info

turn_on_FW:
	mov	bl,2			; turn on only F/W
	jmp	short change_pw_state
	

turn_off:       ; User requests power control be deactivated
	xor	bl,bl		; turn off all pw mgmt
	jmp	short change_pw_state
	
        
display_info:   ; Print current state and idle stats
	mov	al,I2F_PW_GET_SET_PWSTATE
	mov	ah,MultPWR_API		; M007
	mov	bx,0			; get pw state
	int	2fh
	or	ax, ax			; M010
	jz	chk_status		; M010
	jmp	stats_failed		; error in get pw state ? just quit
chk_status:
	mov	[pow_status],bl		; M004
        lea     dx,power_stat1_msg      ; Display current POWER status
        mov     ah,OUT_STRING		; Whether "ON/OFF/NOAPP"
        int     21h                     

	or	bl,bl			; all pow.mgmt off ?
        lea     dx,power_off_msg         ; assume power control is off
	jz	got_msg			
	cmp	bl,2
	lea	dx,power_allon_msg
	jne	got_msg
	lea	dx,power_noid_msg
got_msg:
        mov     ah,OUT_STRING		
        int     21h                     
	lea	dx,power_stat2_msg	; complete the above stat msg
        mov     ah,OUT_STRING		
        int     21h                     

; Compute percentage of time idle if idle detection is on
	test	[pow_status],1		;M004; is idle detection on ?
	jz	Print_APM_Stats
        lea     dx,cpu_idle_msg1
        mov     ah,OUT_STRING
        int     21h

	lea	si,idle_data
	mov	cx,size IDLE_INFO
	mov	al,I2F_PW_GET_STATS
	mov	ah,MultPWR_API		; M007
	mov	bx,PW_GET_IDLE_STATS	; get only idle detection stats
	int	2fh			; get stats
	or	ax, ax			; M010
	jnz	stats_failed		; M010

	lea	bx,idle_data
        push    word ptr [bx].CPU_IDLE_TIME+2
        push    word ptr [bx].CPU_IDLE_TIME   ; get total idle time
        xor     ax,ax
        push    ax
        mov     ax,100
        push    ax
        call    lmul                    ; returns result in DX:AX
        add     sp,8
        push    word ptr [bx].CPU_ON_TIME+2
        push    word ptr [bx].CPU_ON_TIME
        push    dx
        push    ax
        call    uldiv                   ; returns result in DX:AX
        add     sp,8

	call	calc_and_print_no
        
        lea     dx,cpu_idle_msg2
        mov     ah,OUT_STRING
        int     21h

Print_APM_Stats:
IFDEF	INCL_APM
	test	[pow_status],2		;M004; is APM enabled ?
	jz	good_exit		; no, all stats display over
	call	Display_APM_Stats
ENDIF
	

good_exit:      ; And exit

        xor     al,al
        mov     ah,EXIT
        int     21h


; Help message display

display_help:
        lea     dx,help_text
        mov     ah,OUT_STRING
        int     21h
        jmp     short good_exit


; Various error exits

open_failed:
        
        lea     dx,open_failed_msg
        jmp     short err_exit

stats_failed:
        lea     dx,stats_failed_msg
err_exit:
        mov     ah,OUT_STRING
        int     21h                     ; display error message
        mov     ah,EXIT
        mov     al,1                    ; signal error on exit 
        int     21h                     

; END OF Main (of transient POWER.EXE)

calc_and_print_no	proc	near
;dx:ax = no to print
;
        lea     di,digit_buf
        call    get_dec                 ; convert result to ASCII

        mov     ah,OUT_CHAR
        lea     bx,digit_buf

next_digit:
        mov     dl,[bx]                 ; reached end of string?
        or      dl,dl
        jz      capn_end              ; yes, go wrap up
        int     21h                     ; print the character
        inc     bx                      ; point to next char in string
        jmp     short next_digit
capn_end:
	ret

calc_and_print_no	endp

IFDEF	INCL_APM

batt_stat_table	label	word
	dw	battery_high
	dw	battery_low
	dw	battery_critical
	dw	battery_charging

;***************************************** Display_APM_Stats
; display APM statistics (ACLine status, Battery status and battery life)
;

Display_APM_Stats	proc	near
	mov	ax,530ah		; get power status
	mov	bx,1
	int	15h			;
	jc	APM_stats_End
	push	cx
	push	bx
	cmp	bh,-1
	je	go_chk_batt_stat
        lea     dx,ACLine_Stat1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	push	bx
        lea     dx,AC_Offline_str
	or	bh,bh
	je	go_print_acstat
	lea	dx,AC_Online_str
go_print_acstat:
        mov     ah,OUT_STRING
        int     21h
        lea     dx,ACLine_Stat2
        mov     ah,OUT_STRING
        int     21h

go_chk_batt_stat:
	pop	bx
	cmp	bl,-1
	je	go_print_batt_life
	xor	bh,bh		; M092
	push	bx
	lea	dx,battery_status1
        mov     ah,OUT_STRING
        int     21h
	pop	bx
	shl	bx,1		; word offset
	mov	dx,cs:batt_stat_table[bx]
        mov     ah,OUT_STRING
        int     21h

	lea	dx,battery_status2
        mov     ah,OUT_STRING
        int     21h

go_print_batt_life:
	pop	cx
	cmp	cl,-1
	je	APM_stats_End
	mov	ax,cx
	xor	ah,ah
	push	ax
	lea	dx,battery_life_str1
        mov     ah,OUT_STRING
        int     21h
	pop	ax
	xor	dx,dx
	call	calc_and_print_no
	lea	dx,battery_life_str2
        mov     ah,OUT_STRING
        int     21h
APM_stats_END:
	ret

Display_APM_Stats	endp

ENDIF

Trans_Code      ends

        end     start
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\sysinit2.asm ===
page	,160
;
;       Microsoft Confidential
;       Copyright (C) Microsoft Corporation 1981-1991
;       All Rights Reserved.
;

        title   bios system initialization

;
; Multiple configuration block support  Created 16-Mar-1992 by JeffPar
;
; Summary:
;
;   The procedure "organize" crunches the in-memory copy of config.sys
;   into lines delimited by CR/LF (sometimes no CR, but *always* an LF)
;   with the leading "keyword=" replaced by single character codes (eg, B
;   for BUFFERS, D for DEVICE, Z for any unrecognized keyword);  see comtab
;   and/or config.inc for the full list.
;
;   [blockname] and INCLUDE are the major syntactical additions for multi-
;   configuration support.  blockname is either MENU, which contains one
;   or more MENUITEM lines, an optional MENUDEFAULT (which includes optional
;   time-out), or any user-defined keyword, such as NETWORK, CD-ROM, etc.
;   INCLUDE allows the current block to name another block for inclusion
;   during the processing phase of CONFIG.SYS.  An INCLUDE is only honored
;   once, precluding nasty infinite-loop scenarios.  If blocks are present
;   without a MENU block, then only lines inside COMMON blocks are processed.
;
; Example:
;
;   [menu]
;   menuitem=misc,Miscellaneous
;   menuitem=network,Network Configuration
;   menudefault=network,15
;
;   [network]
;   include misc
;   device=foo
;
;   [misc]
;   device=bar
;   include alternate
;
;   [alternate]
;   device=tar
;
;
;   When the menu is displayed
;
;    1. Miscellaneous
;    2. Network Configuration
;
;   #2 is highlighted as the default option, and will be automatically
;   selected after 15 seconds.  It will invoke the following lines in the
;   following order:
;
;       DEVICE=BAR
;       DEVICE=TAR
;       DEVICE=FOO
;

MULTI_CONFIG equ 1

	.xlist
	include version.inc		; set version build flags
	include biosseg.inc		; establish bios segment structure
	.list

lf	equ	10
cr	equ	13
tab	equ	9

; the following depends on the positions of the various letters in switchlist

switchnum	equ 11111000b		; which switches require number

	.xlist
	include	bpb.inc
	include syscall.inc
	include doscntry.inc
	include devsym.inc
	include ioctl.inc
        include devmark.inc
        include config.inc
ifdef   MULTI_CONFIG
        include rombios.inc
endif
	.list

stacksw equ     true                    ; include switchable hardware stacks

	if	ibmjapver
noexec	equ	true
	else
noexec	equ	false
	endif


Bios_Data segment 
	extrn eot:byte
	extrn ec35_flag: byte
Bios_Data ends

sysinitseg segment public

assume	cs:sysinitseg,ds:nothing,es:nothing,ss:nothing

ifdef   MULTI_CONFIG

        MAX_MULTI_CONFIG equ 9          ; max # of multi-config menu items supported

        extrn   config_envlen:word
        extrn   config_wrkseg:word
        extrn   config_cmd:byte
        extrn   config_multi:byte
        extrn   OnOff:byte
        extrn   $PauseMsg:byte
        extrn   $CleanMsg:byte
        extrn   $InterMsg:byte
        extrn   $MenuHeader:byte
        extrn   $MenuPrmpt:byte
        extrn   $StatusLine:byte
        extrn   $InterPrmpt:byte
        extrn   $YES:byte
        extrn   $NO:byte
        extrn   $TimeOut:byte
        extrn   $AutoPrmpt:byte
        extrn   swit_n:byte, swit_f:byte

        public  newcmd,tmplate,commnd2,commnd3,commnd4
endif

IFDEF	CONFIGPROC

	extrn	badopm:byte,badcom:byte,badblock:byte
	extrn	badsiz_pre:byte,
	extrn	error_line:near

	extrn	dosinfo:dword
	extrn	memory_size:word,fcbs:byte,keep:byte
	extrn	default_drive:byte,confbot:word
	extrn	buffers:word,zero:byte,sepchr:byte
	extrn	files:byte
	extrn	count:word,chrptr:word
	extrn	bufptr:byte,prmblk:byte
	extrn	ldoff:word,area:word,packet:byte,unitcount:byte,
	extrn	break_addr:dword,bpb_addr:dword,drivenumber:byte
	extrn	com_level:byte, cmmt:byte, cmmt1:byte, cmmt2:byte
	extrn	cmd_indicator:byte
	extrn	multdeviceflag:byte
	extrn	org_count:word

	extrn	getchr:near
	extrn	DevEntry:dword

	insert_blank	db	0	; M051: indicates that blank has been
					; M051: inserted 
ENDIF ; CONFIGPROC

	extrn	memlo:word,memhi:word,alloclim:word
	extrn	devmark_addr:word,badmem:byte,crlfm:byte
	extrn	setdevmarkflag:byte,badld_pre:byte

	extrn	donotshownum:byte
	extrn	pararound:near
	extrn	stall:near


        public  int24,open_dev,mem_err,prndev,auxdev,condev
        public  commnd,command_line
	public	badfil,round,print

IFDEF	CONFIGPROC

	public	organize,newline,calldev,badload
	public	config,getnum,prnerr
	public	delim
	public	setparms, parseline, diddleback
	public	setdoscountryinfo,set_country_path,move_asciiz
	public	cntry_drv,cntry_root,cntry_path
	public	pathstring

;
;----------------------------------------------------------------------------
;
; procedure : setparms
;
; the following set of routines is used to parse the drivparm = command in
; the config.sys file to change the default drive parameters.
;
;----------------------------------------------------------------------------
;
setparms	proc	near

	push	ds
	push	ax
	push	bx
	push	cx
	push	dx

	push	cs
	pop	ds
	assume	ds:sysinitseg

	xor	bx,bx
	mov	bl,byte ptr drive
	inc	bl			; get it correct for ioctl
					;  call (1=a,2=b...)
	mov	dx,offset deviceparameters
	mov	ah,ioctl
	mov	al,generic_ioctl
	mov	ch,rawio
	mov	cl,set_device_parameters
	int	21h

	mov	ax,Bios_Data		; get Bios_Data segment
	mov	ds,ax			; set Bios_Data segment
	assume	ds:Bios_Data

	test	cs:word ptr switches, flagec35
	jz	not_ec35

	mov	cl,cs:byte ptr drive	; which drive was this for?

	mov	al,1			; assume drive 0
	shl	al,cl			; set proper bit depending on drive
	or	ds:ec35_flag,al 	; set the bit in the permanent flags

not_ec35:

;	Now adjust the BIOS's EOT variable if our new drive has more
;	sectors per track than any old ones.

	mov	al,cs:byte ptr deviceparameters.DP_BPB.BPB_SECTORSPERTRACK
	cmp	al,eot
	jbe	eot_ok
	mov	eot,al
eot_ok:

	pop	dx			; fix up all the registers
	pop	cx
	pop	bx
	pop	ax
	pop	ds
	assume	ds:nothing
	ret

setparms	endp

;
;----------------------------------------------------------------------------
;
; procedure : diddleback
;
; replace default values for further drivparm commands
;
;----------------------------------------------------------------------------
;

diddleback	proc	near

	push	ds
	push	cs
	pop	ds
	assume	ds:sysinitseg
	mov	word ptr deviceparameters.dp_cylinders,80
	mov	byte ptr deviceparameters.dp_devicetype, dev_3inch720kb
	mov	word ptr deviceparameters.dp_deviceattributes,0
	mov	word ptr switches,0	    ; zero all switches
	pop	ds
	assume	ds:nothing
	ret

diddleback	endp

;
;----------------------------------------------------------------------------
;
; procedure : parseline
;
; entry point is parseline. al contains the first character in command line.
;
;----------------------------------------------------------------------------
;

parseline	proc	near
					; don't get character first time
	push	ds

	push	cs
	pop	ds
	assume	ds:sysinitseg

nextswtch:
	cmp	al,cr			; carriage return?
	jz	done_line
	cmp	al,lf			; linefeed?
	jz	put_back		; put it back and done

; anything less or equal to a space is ignored.

	cmp	al,' '                  ; space?
	jbe	get_next		; skip over space
	cmp	al,'/'
	jz	getparm
	stc				; mark error invalid-character-in-input
	jmp	short exitpl

getparm:
	call	check_switch
	mov	word ptr switches,bx	; save switches read so far
	jc	swterr

get_next:
	call	getchr
	jc	done_line
	jmp	nextswtch

swterr:
	jmp	short exitpl		; exit if error

done_line:
	test	word ptr switches,flagdrive  ; see if drive specified
	jnz	okay
	stc				; mark error no-drive-specified
	jmp	short exitpl

okay:
	mov	ax,word ptr switches
	and	ax,0003h	    ; get flag bits for changeline and non-rem
	mov	word ptr deviceparameters.dp_deviceattributes,ax
	mov	word ptr deviceparameters.dp_tracktableentries, 0
	clc			    ; everything is fine
	call	setdeviceparameters
exitpl:
	pop	ds
	ret

put_back:
	inc	count			; one more char to scan
	dec	chrptr			; back up over linefeed
	jmp	short done_line

parseline	endp

;
;----------------------------------------------------------------------------
;
; procedure : check_switch
;
; processes a switch in the input. it ensures that the switch is valid, and
; gets the number, if any required, following the switch. the switch and the
; number *must* be separated by a colon. carry is set if there is any kind of
; error.
;
;----------------------------------------------------------------------------
;

check_switch	proc	near

	call	getchr
	jc	err_check
        and     al,0dfh                 ; convert it to upper case
	cmp	al,'A'
	jb	err_check
	cmp	al,'Z'
	ja	err_check

	push	es

	push	cs
	pop	es

	mov	cl,byte ptr switchlist	; get number of valid switches
	mov	ch,0
	mov	di,1+offset switchlist	; point to string of valid switches
	repne	scasb

	pop	es
	jnz	err_check

	mov	ax,1
	shl	ax,cl			; set bit to indicate switch
	mov	bx,word ptr switches	; get switches so far
	or	bx,ax			; save this with other switches
	mov	cx,ax
	test	ax, switchnum		; test against switches that require number to follow
	jz	done_swtch

	call	getchr
	jc	err_swtch

	cmp	al,':'
	jnz	err_swtch

	call	getchr
	push	bx			; preserve switches
	mov	byte ptr cs:sepchr,' '	; allow space separators
	call	getnum
	mov	byte ptr cs:sepchr,0
	pop	bx			; restore switches

; because getnum does not consider carriage-return or line-feed as ok, we do
; not check for carry set here. if there is an error, it will be detected
; further on (hopefully).

	call	process_num

done_swtch:
	clc
	ret

err_swtch:
	xor	bx,cx			; remove this switch from the records
err_check:
	stc
	ret

check_switch	endp

;
;----------------------------------------------------------------------------
;
; procedure : process_num
;
; this routine takes the switch just input, and the number following (if any),
; and sets the value in the appropriate variable. if the number input is zero
; then it does nothing - it assumes the default value that is present in the
; variable at the beginning. zero is ok for form factor and drive, however.
;
;----------------------------------------------------------------------------
;

process_num	proc	near
	test	word ptr switches,cx	; if this switch has been done before,
	jnz	done_ret		; ignore this one.
	test	cx,flagdrive
	jz	try_f
	mov	byte ptr drive,al
	jmp	short done_ret

try_f:
	test	cx,flagff
	jz	try_t

; ensure that we do not get bogus form factors that are not supported

	mov	byte ptr deviceparameters.dp_devicetype,al
	jmp	short done_ret

try_t:
	or	ax,ax
	jz	done_ret		; if number entered was 0, assume default value
	test	cx,flagcyln
	jz	try_s

	mov	word ptr deviceparameters.dp_cylinders,ax
	jmp	short done_ret

try_s:
	test	cx,flagseclim
	jz	try_h
	mov	word ptr slim,ax
	jmp	short done_ret

; must be for number of heads

try_h:
	mov	word ptr hlim,ax

done_ret:
	clc
	ret

process_num	endp

;	M047 -- Begin modifications (too numerous to mark specifically)
;
;----------------------------------------------------------------------------
;
; procedure : setdeviceparameters
;
; setdeviceparameters sets up the recommended bpb in each bds in the
; system based on the form factor. it is assumed that the bpbs for the
; various form factors are present in the bpbtable. for hard files,
; the recommended bpb is the same as the bpb on the drive.
; no attempt is made to preserve registers since we are going to jump to
; sysinit straight after this routine.
;
;	if we return carry, the DRIVPARM will be aborted, but presently
;	  we always return no carry
;
;
;	note:  there is a routine by the same name in msdioctl.asm
;
;----------------------------------------------------------------------------
;

setdeviceparameters	proc	near

	push	es

	push	cs
	pop	es
	assume	es:sysinitseg

	xor	bx,bx
	mov	bl,byte ptr deviceparameters.dp_devicetype
	cmp	bl,dev_5inch
	jnz	got_80

	mov	word ptr deviceparameters.dp_cylinders,40 	; 48 tpi=40 cyl

got_80:
	shl	bx,1			; get index into bpb table
	mov	si,bpbtable[bx]		; get address of bpb

	mov	di,offset deviceparameters.dp_bpb ; es:di -> bpb
	mov	cx,size A_BPB
	cld
	repe	movsb

	pop	es
	assume es:nothing

	test	word ptr switches,flagseclim
	jz	see_heads

	mov	ax,word ptr slim
	mov	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack,ax

see_heads:
	test	word ptr switches,flagheads
	jz	heads_not_altered

	mov	ax,word ptr hlim
	mov	word ptr deviceparameters.dp_bpb.bpb_heads,ax

heads_not_altered:


; set up correct media descriptor byte and sectors/cluster
;   sectors/cluster is always 2 except for any one sided disk or 1.44M

	mov	byte ptr deviceparameters.dp_bpb.bpb_sectorspercluster,2
	mov	bl,0f0h			; get default mediabyte

;	preload the mediadescriptor from the bpb into bh for convenient access

	mov	bh,byte ptr deviceparameters.dp_bpb.bpb_mediadescriptor

	cmp	word ptr deviceparameters.dp_bpb.bpb_heads,2	; >2 heads?
	ja	got_correct_mediad	; just use default if heads>2

	jnz	only_one_head		; one head, do one head stuff

;	two head drives will use the mediadescriptor from the bpb

	mov	bl,bh			; get mediadescriptor from bpb

;	two sided drives have two special cases to look for.  One is
;	   a 320K diskette (40 tracks, 8 secs per track).  It uses
;	   a mediaid of 0fch.  The other is 1.44M, which uses only
;	   one sector/cluster.

;	any drive with 18secs/trk, 2 heads, 80 tracks, will be assumed
;	   to be a 1.44M and use only 1 sector per cluster.  Any other
;	   type of 2 headed drive is all set.

	cmp	deviceparameters.dp_bpb.bpb_sectorspertrack,18
	jnz	not_144m
	cmp	deviceparameters.dp_cylinders,80
	jnz	not_144m

;	We've got cyl=80, heads=2, secpertrack=18.  Set cluster size to 1.

	jmp	short got_one_secperclus_drive


;	check for 320K

not_144m:
	cmp	deviceparameters.dp_cylinders,40
	jnz	got_correct_mediad
	cmp	deviceparameters.dp_bpb.bpb_sectorspertrack,8
	jnz	got_correct_mediad

	mov	bl,0fch
	jmp	short got_correct_mediad


only_one_head:

;	if we don't have a 360K drive, then just go use 0f0h as media descr.

	cmp	deviceparameters.dp_devicetype,dev_5inch
	jnz	got_one_secperclus_drive

;	single sided 360K drive uses either 0fch or 0feh, depending on
;	  whether sectorspertrack is 8 or 9.  For our purposes, anything
;	  besides 8 will be considered 0fch

	mov	bl,0fch			; single sided 9 sector media id
	cmp	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack,8
	jnz	got_one_secperclus_drive ; okay if anything besides 8

	mov	bl,0feh			; 160K mediaid

;	we've either got a one sided drive, or a 1.44M drive
;	  either case we'll use 1 sector per cluster instead of 2

got_one_secperclus_drive:
	mov	byte ptr deviceparameters.dp_bpb.bpb_sectorspercluster,1

got_correct_mediad:
	mov	byte ptr deviceparameters.dp_bpb.bpb_mediadescriptor,bl


;	 Calculate the correct number of Total Sectors on medium
;
	mov	ax,deviceparameters.dp_cylinders
	mul	word ptr deviceparameters.dp_bpb.bpb_heads
	mul	word ptr deviceparameters.dp_bpb.bpb_sectorspertrack
	mov	word ptr deviceparameters.dp_bpb.bpb_totalsectors,ax
	clc				; we currently return no errors

	ret

setdeviceparameters	endp

;	M047 -- end rewritten routine

;
;----------------------------------------------------------------------------
;
; procedure : organize
;
;----------------------------------------------------------------------------
;
		assume ds:nothing, es:nothing
organize	proc	near

	mov	cx,[count]
	jcxz	nochar1

ifndef  MULTI_CONFIG
;
;   In MULTI_CONFIG, we map to upper case on a line-by-line basis,
;   because we the case of values in SET commands preserved
;
	call	mapcase
endif
	xor	si,si
	mov	di,si
	xor	ax,ax
	mov	com_level, 0

org1:
	call	skip_comment
	jz	end_commd_line		; found a comment string and skipped.
	call	get2			; not a comment string. then get a char.
	cmp	al, lf
	je	end_commd_line		; starts with a blank line.
	cmp	al, ' '
	jbe	org1			; skip leading control characters
	jmp	short findit

end_commd_line:
	stosb				; store line feed char in buffer for the linecount.
	mov	com_level, 0		; reset the command level.
	jmp	org1

nochar1:
	stc
	ret

findit:
	push	cx
	push	si
	push	di
	mov	bp,si
	dec	bp
        mov     si,offset comtab        ; prepare to search command table
	mov	ch,0
findcom:
	mov	di,bp
	mov	cl,[si]
	inc	si
	jcxz	nocom

ifdef   MULTI_CONFIG
;
;   Simplify future parsing by collapsing ";" onto "REM", and at the same
;   time skip the upcoming delimiter test (since ";" need not be followed by
;   anything in particular)
;
        cmp     byte ptr es:[di],CONFIG_SEMICOLON
        je      semicolon
loopcom:
        mov     al,es:[di]
        inc     di
        and     al,not 20h              ; force upper case
        inc     si                      ; compare to byte @es:di
        cmp     al,ds:[si-1]
        loope   loopcom
else
	repe	cmpsb
endif
	lahf
        add     si,cx                   ; bump to next position without affecting flags
	sahf
        lodsb                           ; get indicator letter
	jnz	findcom
        cmp     byte ptr es:[di], cr    ; the next char might be cr,lf
	je	gotcom0 		; such as in "rem",cr,lf case.
	cmp	byte ptr es:[di], lf
	je	gotcom0

ifdef   MULTI_CONFIG
;
;   Skip the delimiter test for the BEGIN identifier (it doesn't have one).
;
        cmp     al,CONFIG_BEGIN
        je      gotcom0
endif
	push	ax
        mov     al, byte ptr es:[di]    ; now the next char. should be a delim.

ifdef   MULTI_CONFIG
;
;   If keyword is *immediately* followed by a question mark (?), then
;   set the high bit of the ASCII command code (CONFIG_OPTION_QUERY) that is
;   stored in the CONFIG.SYS memory image.
;
        cmp     al,'?'                  ; explicit interactive command?
        jne     no_query                ; no
        pop     ax                      ; yes, so retrieve the original code
        or      al,CONFIG_OPTION_QUERY  ; and set the QUERY bit
        jmp     short gotcom0           ;
semicolon:
        mov     al,CONFIG_REM
        jmp     short gotcom0
no_query:
endif  ;MULTI_CONFIG

	call	delim
no_delim:
	pop	ax
	jnz	findcom
gotcom0:
	pop	di
	pop	si
	pop	cx
	jmp	short gotcom

nocom:
	pop	di
	pop	si
	pop	cx
        mov     al,CONFIG_UNKNOWN
	stosb				; save indicator char.
skipline:
	call	get2
	cmp	al, lf			; skip this bad command line
        jne     skipline
	jmp	end_commd_line		; handle next command line

gotcom:
        stosb                           ; save indicator char in buffer

ifdef   MULTI_CONFIG
;
;   Don't pollute "cmd_indicator" with the CONFIG_OPTION_QUERY bit though;
;   it screws up the direct comparisons below.
;
        and     al,NOT CONFIG_OPTION_QUERY
endif
	mov	cmd_indicator, al	; save it for the future use.

ifdef   MULTI_CONFIG
;
;   There is no whitespace/delimiter between the "begin block" character
;   ([) and the name of block (eg, [menu]), therefore skip this delimiter
;   skipping code
;
        cmp     al,CONFIG_BEGIN
        je      org31
        cmp     al,CONFIG_SUBMENU
        je      no_mapcase
        cmp     al,CONFIG_MENUITEM
        je      no_mapcase
        cmp     al,CONFIG_MENUDEFAULT
        je      no_mapcase
        cmp     al,CONFIG_INCLUDE
        je      no_mapcase
        call    mapcase                 ; map case of rest of line to UPPER
no_mapcase:
endif

org2:	call    get2                    ; skip the command name until delimiter
        cmp     al, lf
	je	org21
	cmp	al, cr
	je	org21
	cmp	al, '/'			; T-RICHJ: Added to allow DEVHIGH/L:...
	je	org21			; T-RICHJ: to be parsed properly.

	call	delim
        jnz     org2
	jmp	short org3

org21:					;if cr or lf then
	dec	si			; undo si, cx register
	inc	cx			;  and continue

org3:	cmp     cmd_indicator, CONFIG_COMMENT
	je	get_cmt_token
        cmp     cmd_indicator, CONFIG_DEVICE
	je	org_file
        cmp     cmd_indicator, CONFIG_INSTALL
	je	org_file
        cmp     cmd_indicator, CONFIG_INSTALLHIGH
        je      org_file
        cmp     cmd_indicator, CONFIG_SHELL
	je	org_file
        cmp     cmd_indicator, CONFIG_SWITCHES
	je	org_switch
org31:
	jmp	org4

org_switch:
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim
	jz	org_switch

	stosb
	jmp	org5

org_file:			; get the filename and put 0 at end,
	call	skip_comment
	jz	org_put_zero

	call	get2		; not a comment
	call	delim
	jz	org_file	; skip the possible delimeters

	stosb			; copy the first non delim char found in buffer

org_copy_file:
	call	skip_comment	; comment char in the filename?
	jz	org_put_zero	; then stop copying filename at that point

	call	get2
	cmp	al, '/' 	; a switch char? (device=filename/xxx)
	je	end_file_slash	; this will be the special case.

	stosb			; save the char. in buffer
	call	delim
	jz	end_copy_file

	cmp	al, ' '
	ja	org_copy_file	; keep copying
	jmp	short end_copy_file ; otherwise, assume end of the filename.

get_cmt_token:			; get the token. just max. 2 char.
	call	get2
	cmp	al, ' ' 	; skip white spaces or "=" char.
	je	get_cmt_token	; (we are allowing the other special
	cmp	al, tab 	;  charaters can used for comment id.
	je	get_cmt_token	;  character.)
	cmp	al, '=' 	; = is special in this case.
	je	get_cmt_token
	cmp	al, cr
	je	get_cmt_end	; cannot accept the carridge return
	cmp	al, lf
	je	get_cmt_end

	mov	cmmt1, al	; store it
	mov	cmmt, 1 	; 1 char. so far.
	call	get2
	cmp	al, ' '
	je	get_cmt_end
	cmp	al, tab
	je	get_cmt_end
	cmp	al, cr
	je	get_cmt_end
	cmp	al, lf
	je	end_commd_line_brdg

	mov	cmmt2, al
	inc	cmmt

get_cmt_end:
	call	get2
	cmp	al, lf
	jne	get_cmt_end		; skip it.

end_commd_line_brdg: jmp end_commd_line ; else jmp to end_commd_line

org_put_zero:				; make the filename in front of
	mov	byte ptr es:[di], 0	;  the comment string to be an asciiz.
	inc	di
	jmp	end_commd_line		;  (maybe null if device=/*)

end_file_slash: 			; al = "/" option char.
	mov	byte ptr es:[di],0	; make a filename an asciiz
	inc	di			; and
	stosb				; store "/" after that.
	jmp	short org5		; continue with the rest of the line

end_copy_file:
	mov	byte ptr es:[di-1], 0	; make it an asciiz and handle the next char.
	cmp	al, lf
	je	end_commd_line_brdg
	jmp	short org5

org4:					; org4 skips all delimiters after the command name except for '/'
	call	skip_comment
	jz	end_commd_line_brdg

	call	get2
	call	org_delim		; skip delimiters except '/' (mrw 4/88)
	jz	org4
	jmp	short org51

org5:					; rest of the line
	call	skip_comment		; comment?
	jz	end_commd_line_brdg
	call	get2			; not a comment.

org51:
	stosb				; copy the character
	cmp	al, '"' 		; a quote ?
	je	at_quote
	cmp	al, ' '
	ja	org5
					; M051 - Start

        cmp     cmd_indicator, CONFIG_DEVICEHIGH; Q: is this devicehigh
	jne	not_dh			; N: 
	cmp	al, lf			; Q: is this line feed
	je	org_dhlf		; Y: stuff a blank before the lf
	cmp	al, cr			; Q: is this a cr
	jne	org5			; N: 
	mov	byte ptr es:[di-1], ' '	; overwrite cr with blank
	stosb				; put cr after blank
	inc	[insert_blank]		; indicate that blank has been 
					; inserted
	jmp	org5
not_dh:					; M051 - End

	cmp	al, lf			; line feed?
	je	org1_brdg		; handles the next command line.
	jmp	org5			; handles next char in this line.

org_dhlf:				; M051 - Start
	cmp	[insert_blank], 1	; Q:has a blank already been inserted
	je	org1_brdg		; Y:
	mov	byte ptr es:[di-1], ' '	; overwrite lf with blank
	stosb				; put lf after blank
					; M051 - End

org1_brdg: 
	mov	[insert_blank], 0	; M051: clear blank indicator for 
					; M051: devicehigh
	jmp	org1

at_quote:
	cmp	com_level, 0
	je	up_level
	mov	com_level, 0		; reset it.
	jmp	org5

up_level:
	inc	com_level		; set it.
	jmp	org5

organize	endp

;
;----------------------------------------------------------------------------
;
; procedure : get2
;
;----------------------------------------------------------------------------
;
get2	proc	near
	jcxz	noget
        lods    byte ptr es:[si]
	dec	cx
	ret
noget:
	pop	cx
	mov	count,di
	mov	org_count, di
	xor	si,si
	mov	chrptr,si
ifndef  MULTI_CONFIG
	ret
else
;
;   This was the rather kludgy way out of procedure "organize", but instead
;   of returning to doconf, we now want to check config.sys BEGIN/END blocks
;   and the new boot menu stuff...
;
        mov     cx,di
        jmp     menu_check
endif
get2	endp


;
;----------------------------------------------------------------------------
;
; procedure : skip_comment
;
;skip the commented string until lf, if current es:si-> a comment string.
;in) es:si-> sting
;	 cx -> length.
;out) zero flag not set if not found a comment string.
;	  zero flag set if found a comment string and skipped it. al will contain
;	  the line feed charater at this moment when return.
;	  ax register destroyed.
;	  if found, si, cx register adjusted accordingly.
;
;----------------------------------------------------------------------------
;
skip_comment	proc	near

	jcxz	noget		; get out of the organize routine.
	cmp	com_level, 0	; only check it if parameter level is 0.
	jne	no_commt	;  (not inside quotations)

	cmp	cmmt, 1
	jb	no_commt

	mov	al, es:[si]
	cmp	cmmt1, al
	jne	no_commt

	cmp	cmmt, 2
	jne	skip_cmmt

	mov	al, es:[si+1]
	cmp	cmmt2, al
	jne	no_commt

skip_cmmt:
	jcxz	noget		; get out of organize routine.
	mov	al, es:[si]
	inc	si
	dec	cx
	cmp	al, lf		; line feed?
	jne	skip_cmmt

no_commt:
	ret

skip_comment	endp


ifdef   MULTI_CONFIG

        assume  ds:sysinitseg
;
;----------------------------------------------------------------------------
;
;   kbd_read: wait for keystroke
;
;   INPUT
;       DS == CS == sysinitseg
;
;   OUTPUT
;       Carry SET to clean boot, CLEAR otherwise
;
;   OTHER REGS USED
;       All
;
;   HISTORY
;       Created 16-Nov-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  kbd_read

kbd_read proc   near
        test    byte ptr [bDisableUI],2
        jnz     kbd_nodelay

        push    ds              ; the bios timer tick count is incremented
        sub     ax,ax           ; 18.2 times per second;
        mov     ds,ax           ; watch the timer tick count for 37 transitions
        mov     dx,ds:[046Ch]   ; get initial value
kbd_loop:
        mov     ah,1            ;
        int     16h             ; peek the keyboard
        jnz     kbd_loopdone    ; something's there, get out
        mov     ah,2            ; peek the shift states
        int     16h             ;
        test    al,03h          ; either right or left shift key bits set?
        jnz     kbd_loopdone    ; yes
        mov     ax,ds:[046Ch]   ;
        sub     ax,dx           ; get difference
        cmp     al,37           ; reached limit?
        jb      kbd_loop        ; not yet
kbd_loopdone:
        pop     ds              ; delay complete!

kbd_nodelay:
        sub     bx,bx           ; assume clean boot
        mov     ah,2            ; peek the shift states
        int     16h             ;
        test    al,03h          ; either right or left shift key bits set?
        jz      kbd_notshift    ; no
        inc     bx              ; yes
        inc     bx              ;
kbd_notshift:                   ;
        mov     ah,1            ; peek the keyboard
        int     16h             ;
        jz      kbd_test        ; no key present
        or      al,al           ; is it a function key?
        jnz     kbd_test        ; no
        cmp     ah,3Fh          ; F5 function key?
        jne     kbd_notf5       ; no
        mov     dx,offset $CleanMsg
        call    print           ;
        jmp     short kbd_eat   ; yes, clean boot selected
kbd_notf5:
        cmp     ah,42h          ; F8 function key?
        jne     kbd_exit        ; no
        mov     dx,offset $InterMsg
        call    print           ;
        mov     bl,1            ; yes, interactive-boot option enabled
        mov     [bQueryOpt],bl  ; change default setting
kbd_eat:                        ;
        mov     ah,0            ;
        int     16h             ; eat the key we assumed was a signal
        mov     byte ptr [secElapsed],-1
        or      bx,bx           ;
        jz      kbd_clean       ;
kbd_test:                       ;
        cmp     bl,2            ;
        jb      kbd_exit        ;
kbd_clean:                      ;
        call    disable_autoexec; yes, tell COMMAND to skip autoexec.bat
        stc                     ; set carry to indicate abort
        ret                     ;
kbd_exit:                       ;
        clc                     ; clear carry to indicate success
        ret                     ;
kbd_read endp

;
;----------------------------------------------------------------------------
;
;   set_numlock: set numlock LED
;
;   INPUT
;       ES:SI -> numlock setting (ie, "ON" or "OFF")
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   HISTORY
;       Created 16-Nov-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  set_numlock

set_numlock proc near
        push    ax
        push    ds
        sub     ax,ax
        mov     ds,ax
        mov     ax,es:[si]      ; get 1st 2 bytes of value (ON or OF)
        cmp     ax,word ptr cs:[OnOff+2]; should we turn it off?
        jne     not_off         ; no
        and     byte ptr ds:[0417h],not 20h
        jmp     short set_done
not_off:
        cmp     ax,word ptr cs:[OnOff]  ; should we turn it on?
        stc
        jne     set_done        ; no
        or      byte ptr ds:[0417h],20h
set_done:
        pop     ds
        pop     ax
        ret
set_numlock endp

;
;----------------------------------------------------------------------------
;
;   menu_check:  check for presence of menu (and other) configuration blocks
;
;   INPUT
;       CX == "organized" config.sys memory image length
;    ES:SI -> "organized" config.sys memory image
;       DS == CS == sysinitseg
;
;   OUTPUT
;       Same as above;  the idea is that menu_check simply transforms
;       a block-structured config.sys image into a conventional image,
;       based on the user's block selection and any other boot-time options
;       the user may have employed...
;
;   OTHER REGS USED
;       All
;
;   NOTES
;       [count] and [org_count] are set to the new config.sys image length
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  menu_check

menu_check  proc near
;
;   Search for SWITCHES, determine if /N or /F are present;  if so, then
;   disable clean/interactive boot options
;
        push    cx              ;
        push    si              ;
        sub     bx,bx           ; remains ZERO until first block
swchk_loop:                     ;
        call    get_char        ; get first char of current line
        jc      swchk_end       ; hit eof
        cmp     al,CONFIG_BEGIN ;
        jne     swchk_next1     ;
        inc     bx              ; remember that we've seen a block
        jmp     short swchk_nextline
swchk_next1:                    ;
        cmp     al,CONFIG_NUMLOCK
        jne     swchk_next2     ;
        or      bx,bx           ; only do NUMLOCK commands that exist
        jnz     swchk_nextline  ; before the first block
        call    set_numlock     ; REM it out so we don't act on it later, too
        mov     byte ptr es:[si-1],CONFIG_REM
        jmp     short swchk_nextline
swchk_next2:                    ;
        cmp     al,CONFIG_SWITCHES
        jne     swchk_nextline  ; this line ain't it
swchk_scan:                     ;
        call    get_char        ; look for /N or /F
swchk_scan1:                    ;
        cmp     al,LF           ; end of line?
        je      swchk_nextline  ; yes
        cmp     al,'/'          ; switch-char?
        jne     swchk_scan      ; no
        call    get_char        ;
        and     al,not 20h      ; convert to upper case
        cmp     al,byte ptr swit_n+1
        jne     swchk_scan2     ; no
        or      byte ptr [bDisableUI],1
        jmp     swchk_scan      ; continue looking for switches of interest
swchk_scan2:                    ;
        cmp     al,byte ptr swit_f+1
        jne     swchk_scan1     ; no
        or      byte ptr [bDisableUI],2
        jmp     swchk_scan      ; continue looking for switches of interest
swchk_nextline:                 ;
        call    skip_opt_line   ;
        jmp     swchk_loop      ;
swchk_end:                      ;
        pop     si              ;
        pop     cx              ;
;
;   Do the keyboard tests for clean/interactive boot now, but only if
;   the DisableUI flag is still clear
;
        test    byte ptr [bDisableUI],1
        jnz     menu_search
;
;   Wait for 2 seconds first, UNLESS the /F bit was set in bDisableUI, or
;   there is anything at all in the keyboard buffer
;
        call    kbd_read
        jnc     menu_search
        jmp     menu_abort
;
;   Search for MENU block;  it is allowed to be anywhere in config.sys
;
menu_search:
        sub     bx,bx           ; if no MENU, default to zero for no_selection
        mov     di,offset szMenu;
        call    find_block      ; find the MENU block
        jnc     menu_found      ;
        mov     byte ptr [szBoot],0
        jmp     no_selection    ; not found
;
;   Process the requested menu color(s)
;
menu_color:
        push    cx              ;
        push    dx              ;
        mov     dx,0007h        ; default color setting
        call    get_number      ; get first number
        and     bl,00Fh         ; first # is foreground color (for low nibble)
        mov     ch,bl           ; save it in CH
        and     dl,0F0h         ;
        or      dl,bl           ;
        call    delim           ; did we hit a delimiter
        jne     check_color     ; no, all done
        call    get_number      ; get next number
        and     bl,00Fh         ; second # is background color (for high nibble)
        mov     dh,bl           ; save it in DH
        and     dl,00Fh         ;
        mov     cl,4            ;
        shl     bl,cl           ;
        or      dl,bl           ;
check_color:                    ;
        cmp     ch,dh           ; are foreground/background the same?
        jne     set_color       ; no
        xor     dl,08h          ; yes, so modify the fgnd intensity
set_color:
        mov     [bMenuColor],dl ;
        pop     dx              ;
        pop     cx              ;
        jmp     menu_nextitem   ;
;
;   Back to our regularly scheduled program (the COLOR and other goop
;   above is there simply to alleviate short jump problems)
;
menu_found:
        mov     byte ptr [bDefBlock],1
        mov     word ptr [offDefBlock],0
        mov     byte ptr [secTimeOut],-1
        and     byte ptr [bQueryOpt],not 2

        call    skip_opt_line   ; skip to next line
        sub     dx,dx           ; initialize total block count (0 => none yet)
;
;   Process the menu block now
;
menu_process:
        call    get_char        ; get first char of current line
        jc      to_menu_getdefault  ; could happen if menu block at end (rare)
        and     al,NOT CONFIG_OPTION_QUERY
        cmp     al,CONFIG_BEGIN ; BEGIN implies END
        je      to_menu_getdefault
        cmp     al,CONFIG_SUBMENU
        je      menu_item       ; go process sub-menu
        cmp     al,CONFIG_MENUITEM
        je      menu_item       ; go process menu item
        cmp     al,CONFIG_MENUDEFAULT
        je      menu_default    ; go process menu default
        cmp     al,CONFIG_MENUCOLOR
        je      menu_color      ; go process menu color
        cmp     al,CONFIG_NUMLOCK
        je      menu_numlock    ;
        cmp     al,CONFIG_REM   ; allow remarks in menu block
        je      menu_nextitem   ;
        call    any_delim       ; allow blank lines and such
        je      menu_nextitem   ;
        stc                     ;
        call    print_error     ; non-MENU command!
        jmp     short menu_nextitem
menu_numlock:
        call    set_numlock
        jmp     short menu_nextitem
to_menu_getdefault:
        jmp     short menu_getdefault
;
;   Save the offset of the default block name, we'll need it later
;
menu_default:
        mov     [offDefBlock],si; save address of default block name
        cmp     byte ptr [secElapsed],0
        jne     timeout_skip    ; secElapsed is only zero for the FIRST menu,
        call    skip_token      ; and for subsequent menus IF nothing was typed;
        jc      menu_nextitem   ; secElapsed becomes -1 forever as soon as
        call    skip_delim      ; something is typed
        jc      menu_nextitem   ;
        mov     si,bx           ;
        call    get_number      ; get number (of seconds for timeout)
        cmp     bl,90           ; limit it to a reasonable number
        jb      timeout_ok      ; (besides, 99 is the largest # my simple
        mov     bl,90           ;  display function can handle)
timeout_ok:                     ;
        mov     [secTimeOut],bl ;
timeout_skip:
        jmp     short menu_nextitem
;
;   Verify that this is a valid menu item by searching for the named block
;
menu_item:
        cmp     dl,MAX_MULTI_CONFIG ; have we reached the max # of items yet?
        jae     menu_nextitem   ;
        mov     di,si           ; DS:DI -> block name to search for
        call    srch_block      ;
        je      menu_itemfound  ;
        stc                     ;
        call    print_error     ; print error and pause
        jmp     short menu_nextitem ; if not found, ignore this menu item
;
;   srch_block, having succeeded, returns DI -> past the token that it
;   just matched, which in this case should be a descriptive string;  ES:SI
;   and CX are unmodified
;
menu_itemfound:
        inc     dx              ; otherwise, increment total block count
        mov     bx,dx           ; and use it to index the arrays of offsets
        mov     abBlockType[bx],al
        add     bx,bx           ; of recorded block names and descriptions
;
;   There should be a description immediately following the block name on
;   MENUITEM line;  failing that, we'll just use the block name as the
;   description...
;
        mov     aoffBlockName[bx],si
        mov     aoffBlockDesc[bx],si
        mov     di,bx           ; skip_delim modifies BX, so stash it in DI
        call    skip_token      ;
        jc      menu_nextitem   ; hit eol/eof
        call    skip_delim      ;
        jc      menu_nextitem   ; hit eol/eof
        xchg    bx,di           ;
        mov     aoffBlockDesc[bx],di

menu_nextitem:
        call    skip_opt_line   ;
        jmp     menu_process    ; go back for more lines
;
;   Display menu items now, after determining which one is default
;
menu_getdefault:
        or      dl,dl           ; where there any valid blocks at all?
        jnz     menu_valid      ; yes
        sub     bx,bx           ; no, so force autoselect of 0
        jmp     menu_autoselect ; (meaning: process common blocks only)
menu_valid:
        sub     bx,bx           ;
        mov     [bMaxBlock],dl  ; first, record how many blocks we found
        mov     di,[offDefBlock];
        or      di,di           ; does a default block exist?
        jz      menu_nodefault  ; no
        inc     bx              ; yes, walk name table, looking for default
menu_chkdefault:
        push    bx              ;
        add     bx,bx           ;
        mov     si,aoffBlockName[bx]
        mov     cx,128          ; arbitrary maximum length of a name
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    comp_names      ; is this block the same as the default?
        pop     ds              ;
        pop     bx              ;
        je      menu_setdefault ; yes
        inc     bx              ;
        cmp     bl,[bMaxBlock]  ; all done searching?
        jbe     menu_chkdefault ; not yet
menu_nodefault:
        mov     bl,1            ; if no default, force default to #1
menu_setdefault:
        mov     [bDefBlock],bl  ; yes, this will be the initial current block
;
;   If the timeout was explicitly set to 0 (or technically, anything that
;   failed to resolve to a number, like "NONE" or "EAT POTATOES"), then we're
;   supposed to skip menu display and run with the specified default block;
;   however, if the user hit Enter prior to boot, thereby requesting fully
;   INTERACTIVE boot, then we shall display the menu block anyway (though still
;   with no timeout)
;
        cmp     [secTimeOut],0  ; is timeout zero? (ie, assume default)
        jne     menu_display    ; no
        test    byte ptr [bQueryOpt],1  ; yes, but was INTERACTIVE requested?
        jnz     menu_display    ; yes, so *don't* assume default after all
        jmp     not_topmenu     ;
;
;   Reset the mode, so that we know screen is clean and cursor is home
;
menu_display:
        mov     ah,0Fh          ; get current video mode
        int     10h             ;
        mov     ah,00h          ; just re-select that mode
        int     10h             ;
        push    es              ;
        mov     ax,40h          ; reach down into the ROM BIOS data area
        mov     es,ax           ; and save the current (default) video page
        mov     ax,es:[004Eh]   ; start address and page #, in case the
        mov     [wCRTStart],ax  ; undocumented QUIET option was enabled
        mov     al,es:[0062h]   ;
        mov     [bCRTPage],al   ;
        mov     ax,word ptr [bMenuPage] ; select new page for menu
        int     10h             ;
        mov     ax,0600h        ; clear entire screen
        mov     bh,[bMenuColor] ; using this color
        sub     cx,cx           ; upper left row/col
        mov     dl,byte ptr es:[CRT_Cols]
        dec     dl              ;
        mov     dh,es:[CRT_Rows];
        or      dh,dh           ; # of rows valid?
        jnz     menu_clear      ; hopefully
        mov     dh,[bLastRow]   ; no, use a default
menu_clear:
        int     10h             ; clear the screen using the req. attribute
        pop     es              ;
        mov     [bLastRow],dh   ; save DH
        mov     dx,offset $MenuHeader
        call    print           ; cursor now on row 3 (numbered from 0)

        test    byte ptr [bDisableUI],1
        jnz     menu_nostatus   ;
        mov     bh,[bMenuPage]  ;
        mov     dh,[bLastRow]   ; restore DH
        mov     dl,0            ; print the status line on row DH, col 0,
        mov     ah,02h          ; now that we can trash the cursor position
        int     10h             ;
        mov     dx,offset $StatusLine
        call    print           ;
        mov     ah,3            ; get cursor position
        int     10h             ;
        sub     dl,2            ;
        mov     [bLastCol],dl   ; save column where status char will go

menu_nostatus:
        mov     bx,1            ; now prepare to display all the menu items
menu_disploop:
        call    print_item      ; print item #BL
        inc     bx              ; why "inc bx"?  because it's a 1-byte opcode
        cmp     bl,[bMaxBlock]  ; all done?
        jbe     menu_disploop   ; not yet
;
;   Set cursor position to just below the menu items
;
        mov     dl,0            ; select column
        mov     dh,bl           ;
        add     dh,4            ; select row below menu
        mov     bh,[bMenuPage]  ;
        mov     ah,02h          ; set cursor position beneath the block list
        int     10h             ;

        mov     dx,offset $MenuPrmpt
        call    print           ;
        call    select_item     ; make a selection, return # in BX
        mov     dx,offset crlfm ;
        call    print           ;
        push    word ptr [bDisableUI]
        or      byte ptr [bDisableUI],1
        call    show_status     ; clear the status line now
        pop     word ptr [bDisableUI]
;
;   Now begins the "re-organization" process...
;
menu_autoselect:
        cmp     bx,-1           ; clean boot requested?
        jne     normal_boot     ; no
        call    disable_autoexec; basically, add a /D to the command.com line
menu_abort:
        sub     cx,cx           ; then immediately exit with 0 config.sys image
        jmp     menu_exit       ;

normal_boot:
        cmp     bx,-2           ; back to top-level menu?
        jne     not_topmenu     ; no
        mov     cx,[count]      ; yes, start all over
        sub     si,si           ;
        jmp     menu_search

not_topmenu:
        cmp     abBlockType[bx],CONFIG_SUBMENU
        jne     not_submenu     ;
        add     bx,bx           ;
        mov     di,aoffBlockName[bx]
        call    srch_block      ; THIS CANNOT FAIL!
        mov     si,di           ;
        mov     cx,bx           ; ES:SI and CX are ready for another round
        jmp     menu_found

not_submenu:
        add     bx,bx           ; get BX -> name of selected block
        mov     bx,aoffBlockName[bx]
;
;   BX should now either be ZERO (meaning no block has been selected) or
;   the offset relative to ES of the block name to be processed (along with
;   all the "common" lines of course)
;
no_selection:
        mov     [offDefBlock],bx; save selection
        mov     cx,[count]      ; reset ES:SI and CX for reprocessing
        sub     si,si           ;
        push    ds              ;
        mov     ds,[config_wrkseg]; this is where we'll store new config.sys image
        assume  ds:nothing      ;
        sub     di,di           ;
;
;   ES:SI-> config.sys, DS:DI -> new config.sys workspace
;
;   Work our way through the config.sys image again, this time copying
;   all lines that are (A) "common" lines outside any block or (B) lines
;   within the requested block.  Lines inside INCLUDEd blocks are transparently
;   copied by copy_block in a recursive fashion;  the amount of recursion is
;   limited by the fact INCLUDE statements are REMed by copy_block as they are
;   processed and by the number of unique INCLUDE stmts in config.sys...
;
;   BUGBUG 20-Mar-1992 JeffPar:  If we can figure out the lower bound of the
;   stack we're running on, then we should check it inside copy_block
;
copyblock_loop:
        push    bx              ; save selected block name
        call    copy_block      ; process (named or common) block
        pop     bx              ;
        jc      move_config     ; hit eof
;
;   copy_block can only return for two reasons:  it hit eof or a new block
;
copyblock_begin:
        push    ax              ;
        push    cx              ;
        push    si              ;
        push    di              ; always do "common" blocks
        mov     di,offset szCommon
        push    ds              ;
        push    cs              ;
        pop     ds              ;
        call    comp_names      ;
        pop     ds              ;
        pop     di              ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
        je      copyblock_check ;
        or      bx,bx           ; is there a block name to check?
        jz      copyblock_skip  ; no
        push    di              ;
        mov     di,bx           ; check block against given block name
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    comp_names      ; is this the block we really want to do?
        pop     ds              ;
        pop     di              ;
copyblock_check:
        jc      move_config     ; hit eof
        jne     copyblock_skip  ;
        call    skip_opt_line   ;
        jmp     copyblock_loop  ;

copyblock_skip:                 ;
        call    skip_opt_line   ; this ain't the block we wanted, so skip it
        call    get_char        ;
        jc      move_config     ; hit eof
        and     al,NOT CONFIG_OPTION_QUERY
        cmp     al,CONFIG_BEGIN ;
        je      copyblock_begin ;
        jmp     copyblock_skip  ; anything else is just skipped
;
;   To create as little risk to the rest of SysInit as little as possible,
;   and to free the workspace at "config_wrkseg" for creating an environment,
;   copy the new config.sys image to "confbot"
;
move_config:
        mov     cx,di           ; now copy workspace at DS:DI to "confbot"
        push    cx              ;
;
;   But first, copy the CONFIG=<configuration><0> string to the workspace,
;   since the configuration name only currently exists in the "confbot" area
;
        mov     cx,offset szMenu-offset szBoot-1
        mov     si,offset szBoot; first copy the CONFIG= part
        inc     di              ; skip a byte, in case absolutely nothing
                                ; was copied to the workspace, because we always
                                ; zero the first byte of the workspace (below)
copy_boot:                      ;
        lods    byte ptr cs:[si];
        mov     [di],al         ;
        inc     di              ;
        loop    copy_boot       ;

        push    es              ; then copy the configuration name
        mov     cx,128-7        ; put an upper limit on the name, to be safe
        mov     si,cs:[offDefBlock]; ES:SI -> default block name
        or      si,si           ; valid?
        jnz     l1              ; yes
        push    cs              ;
        pop     es              ;
        mov     si,offset szCommon
l1:     mov     al,es:[si]      ;
        call    any_delim       ;
        je      l2              ;
        mov     [di],al         ;
        inc     si              ;
        inc     di              ;
        loop    l1              ;
l2:     mov     byte ptr [di],LF; terminate the configuration string
        pop     es              ;
;
;   Now we can copy "config_wrkseg" (DS) to "confbot" (ES)
;
        sub     di,di           ;
        mov     [config_envlen],di
        sub     si,si           ;
        pop     cx              ; recover the size of "config_wrkseg"

        push    cx              ;
        rep     movsb           ; moved!
        pop     cx              ;
        mov     ax,ds           ;
        pop     ds              ;
        assume  ds:sysinitseg   ;
;
;   Now that the config_wrkseg is available once again, we shall
;   use it to create an environment.  The first thing to go in will be
;   the "CONFIG=configuration" thing.  It is also important to zero
;   the first byte of the workspace, so that copy_envvar knows the buffer
;   is empty.
;
        push    es              ;
        mov     es,ax           ;
        inc     si              ; ES:SI -> "CONFIG=configuration"
        mov     byte ptr es:[0],0;empty the environment block
        call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
        pop     es
;
;   Before returning, restore the default video page setting but do NOT
;   do it using INT 10h's Set Active Page function, because if the menu was
;   displayed on a different page, then it's because we don't want to see
;   all the device driver/TSR goop (which goes to the default page)
;
menu_done:
        cmp     byte ptr [bMenuPage],0
        je      menu_exit       ;
        push    es              ;
        mov     ax,40h          ;
        mov     es,ax           ;
        mov     ax,[wCRTStart]  ;
        mov     es:[004Eh],ax   ;
        mov     al,[bCRTPage]   ;
        mov     es:[0062h],al   ;
        pop     es              ;
menu_exit:
        mov     [count],cx      ; set new counts
        mov     [org_count],cx  ;
        sub     si,si           ; always return ES:SI pointing to config.sys
        ret
menu_check  endp

;
;----------------------------------------------------------------------------
;
;   copy_envvar:  copy the envvar at ES:SI to "config_wrkseg"
;
;   INPUT
;    ES:SI -> environment variable (in the form "var=string<cr/lf>")
;
;   OUTPUT
;       config_envlen (ie, where to put next envvar) updated appropriately
;       carry set if error (eg, missing =); clear otherwise
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 29-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  copy_envvar
        assume  ds:sysinitseg,es:nothing

copy_envvar proc near
        push    cx              ;
        push    si              ;
        push    ds              ;
        push    es              ;
        push    es              ;
        mov     es,[config_wrkseg]; ES:DI to point to next available byte
        pop     ds                ; DS:SI to point to envvar
        assume  ds:nothing      ;
;
;   Have to calculate the length of the variable name (and if we hit
;   the end of the line before we hit '=', then it's curtains for this
;   config.sys line)
;
;   The check for NULL is important because copy_envvar is also used to copy
;   the initial CONFIG= setting, which will have been zapped by a NULL if no
;   menu block existed (in order to prevent the creation of an environment)
;
        sub     cx,cx           ;
copy_varlen:                    ;
        lodsb                   ;
        or      al,al           ; NULL?
        stc                     ;
        jz      copy_envexit    ; yes, abort
        cmp     al,CR           ;
        stc                     ;
        je      copy_envexit    ;
        cmp     al,LF           ;
        stc                     ;
        je      copy_envexit    ;
        inc     cx              ;
        cmp     al,'='          ;
        jne     copy_varlen     ;
        mov     al,0            ;
        mov     ah,[si]         ; save char after '='
        sub     si,cx           ; back up to given varname
        dec     cx              ; CX == # of bytes in varname
        sub     di,di           ; start looking for DS:SI at ES:0
copy_varsrch:
        cmp     byte ptr es:[di],al
        je      copy_envprep    ; search failed, just copy var
        mov     bx,di           ; ES:BX -> start of this varname
        push    cx              ;
        push    si              ;
        repe    cmpsb           ;
        pop     si              ;
        pop     cx              ;
        jne     copy_varnext    ; no match, skip to next varname
        cmp     byte ptr es:[di],'='
        jne     copy_varnext    ; no match, there's more characters
;
;   Previous occurrence of variable has been found;  determine the
;   entire length and then destroy it
;
        mov     cx,-1           ;
        repne   scasb           ; guaranteed to get null (since we put it there)
        push    si              ;
        mov     si,di           ;
        mov     di,bx           ;
        mov     cx,[config_envlen]
        sub     cx,si           ; destroy variable now
        rep movs byte ptr es:[di],byte ptr es:[si]
        pop     si              ;
copy_envprep:
        cmp     ah,CR           ; if there is nothing after the '='
        je      copy_envdel     ; then just exit with variable deleted
        cmp     ah,LF           ;
        je      copy_envdel     ;
        jmp     short copy_envloop

copy_varnext:                   ;
        push    cx              ;
        mov     cx,-1           ;
        repne   scasb           ;
        pop     cx              ;
        jmp     copy_varsrch    ;

copy_envloop:                   ;
        lodsb                   ;
        cmp     al,CR           ;
        je      copy_envdone    ;
        cmp     al,LF           ;
        je      copy_envdone    ;
        stosb                   ;
        jmp     copy_envloop    ;

copy_envdone:                   ;
        sub     al,al           ; do SUB to clear carry as well
        stosb                   ; always null-terminate these puppies
copy_envdel:                    ;
        mov     es:[di],al      ; and stick another null to terminate the env.
        mov     [config_envlen],di

copy_envexit:                   ;
        pop     es              ;
        pop     ds              ;
        assume  ds:sysinitseg   ;
        pop     si              ;
        pop     cx              ;
        ret                     ;
copy_envvar endp

;
;----------------------------------------------------------------------------
;
;   copy_block:  copy the current block to the new config.sys workspace
;
;   INPUT
;       CX == remaining bytes in "organized" config.sys memory image
;    ES:SI -> remaining bytes in "organized" config.sys memory image
;    DS:DI -> new config.sys workspace (equal in size to the original
;             config.sys image) where the current block is to be copied
;
;   OUTPUT
;       Same as above
;       AL also equals the last character read from the organized image
;
;   OTHER REGS USED
;       All
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  copy_block

copy_block  proc near
        call    get_char        ; check for include
        jc      copy_done       ;
        and     al,NOT CONFIG_OPTION_QUERY
        cmp     al,CONFIG_BEGIN ; another BEGIN implies END as well
        je      copy_done       ;
;
;   BOOTCON relies on these things being in-memory (sigh)
;
;       cmp     al,CONFIG_REM   ; don't bother copying this
;       je      copy_nextline   ;
;       cmp     al,CONFIG_COMMENT;don't bother copying this either
;       je      copy_nextline   ;
;
;   This is being left out for old reporting of bad command lines;
;   alternatively, we could report the error here and save the rest of
;   sysinit from ever having to deal with bogus CONFIG.SYS stuff...
;
;       cmp     al,CONFIG_UNKNOWN;don't bother copying this either too
;       je      copy_nextline   ;
                                ;
        cmp     al,CONFIG_INCLUDE
        mov     al,ah           ; AL == the original line code
        jne     copy_line       ; not an "include" line
;
;   We have hit an "INCLUDE" line;  first, REM out the line so that we
;   never try to include the block again (no infinite include loops please),
;   then search for the named block and call copy_block again.
;
        mov     byte ptr es:[si-1],CONFIG_REM
        push    di              ;

        mov     di,offset szMenu
        call    comp_names_safe ; don't allow INCLUDE MENU
        je      copy_skip       ;

        mov     di,offset szCommon
        call    comp_names_safe ; don't allow INCLUDE COMMON
        je      copy_skip       ;

        mov     di,si           ; try to find the block
        call    srch_block      ;
        mov     dx,di           ;
        pop     di              ;
        jne     copy_error      ; no such block
        push    cx              ;
        mov     cx,bx           ;
        push    si              ;
        dec     dx              ;
        mov     si,dx           ;
        call    skip_line       ; skip the rest of the "block name" line
        call    copy_block      ; and copy in the rest of that block
        pop     si              ;
        pop     cx              ;
        sub     al,al           ; force skip_opt_line to skip...
        jmp     short copy_nextline

copy_skip:
        pop     di
copy_error:
        clc                     ;
        call    print_error     ; note that carry is clear, no pause
        jmp     short copy_nextline
;
;   Copy the line at ES:SI to the current location at DS:DI
;
copy_line:
        mov     [di],al         ;
        inc     di              ;
        cmp     al,' '          ; is this is a "real" line with a "real" code?
        jb      copy_nextline   ; no
        cmp     cs:[config_multi],0
        je      copy_loop       ; not a multi-config config.sys, don't embed #s
        call    get_linenum     ; BX == line # of line @ES:SI
        mov     [di],bx         ; stash it immediately following the line code
        inc     di              ;
        inc     di              ;
        jmp     short copy_next ;
copy_loop:                      ;
        call    get_char        ;
        jc      copy_done       ; end of file
        mov     [di],al         ;
        inc     di              ;
copy_next:
        cmp     al,LF           ; done with line?
        jne     copy_loop       ; nope

copy_nextline:
        call    skip_opt_line   ;
        jmp     copy_block      ;

copy_done:
        ret
copy_block  endp

;
;----------------------------------------------------------------------------
;
;   get_linenum:  return line # (in BX) of current line (@ES:SI)
;
;   INPUT
;    ES:SI -> some line in the config.sys memory image
;
;   OUTPUT
;       BX == line # (relative to 1)
;
;   OTHER REGS USED
;       DX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  get_linenum

get_linenum proc near
        push    ax              ;
        sub     bx,bx           ; BX == line # (to be returned)
        push    cx              ;
        mov     dx,si           ; DX == the offset we're looking for
        push    si              ;
        mov     cx,cs:[count]   ;
        sub     si,si           ; prepare to scan entire file
get_linenum_loop:               ;
        call    skip_line       ;
        jc      get_linenum_done;
        inc     bx              ;
        cmp     si,dx           ; have we exceeded the desired offset yet?
        jb      get_linenum_loop; no
get_linenum_done:               ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
        ret                     ;
get_linenum endp

;
;----------------------------------------------------------------------------
;
;   srch_block:  searches entire config.sys for block name @ES:DI
;
;   INPUT
;       ES -> config.sys image
;    ES:DI -> block name to find
;
;   OUTPUT
;       ZF flag set, if found
;    ES:DI -> just past the name in the block heading, if found
;       BX == # bytes remaining from that point, if found
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This differs from "find_block" in that it searches the ENTIRE
;       config.sys image, not merely the remaining portion, and that it
;       takes a pointer to block name that is *elsewhere* in the image
;       (ie, ES) as opposed to some string constant in our own segment (DS).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  srch_block

srch_block  proc near           ; returns BX -> named block in CONFIG.SYS
        push    ax              ;
        push    cx              ;
        mov     cx,cs:[count]   ;
        push    si              ;
        sub     si,si           ;
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    find_block      ;
        mov     di,si           ;
        mov     bx,cx           ;
        pop     ds              ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
        ret                     ;
srch_block  endp

;
;----------------------------------------------------------------------------
;
;   find_block:  searches rest of config.sys for block name @DS:DI
;
;   INPUT
;    DS:DI -> block name to find
;    ES:SI -> remainder of config.sys image
;       CX == remaining size of config.sys image
;
;   OUTPUT
;       ZF flag set, if found (also, CF set if EOF)
;    ES:SI -> where the search stopped (at end of block name or EOF)
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       This differs from "srch_block" in that it searches only the
;       remaining portion of the config.sys image and leaves SI and CX
;       pointing to where the search left off, and that it takes a pointer
;       to search string in our own segment (DS:DI instead of ES:DI).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  find_block

find_block  proc near
        call    get_char        ; get line code
        jc      find_exit       ; end of file
        and     al,NOT CONFIG_OPTION_QUERY
        cmp     al,CONFIG_BEGIN ; beginning of a block?
        je      check_line      ; no
        cmp     al,CONFIG_INCLUDE
        jne     next_line       ;
        or      cs:[config_multi],1
        jmp     short next_line ;
check_line:
        or      cs:[config_multi],1
        call    comp_names      ; compare block names
        jbe     find_exit       ; end of file, or names matched
next_line:
        call    skip_opt_line   ; no, so skip to next line
        jmp     find_block      ;
find_exit:
        ret
find_block  endp

;
;----------------------------------------------------------------------------
;
;   comp_names:  compares keyword @DS:DI to position in config.sys @ES:SI
;
;   INPUT
;    DS:DI -> keyword to compare
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       ZF flag set, if match (also, CF set if EOF)
;    ES:SI -> where the comparison stopped (at end of block name or EOF)
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  comp_names

comp_names  proc near
        push    di              ;
comp_loop:                      ;
        call    get_char        ;
        jc      comp_exit       ;
        call    any_delim       ; is next character a delimiter?
        mov     ah,[di]         ; (get next character we're supposed to match)
        je      comp_almost     ; yes, it *could* be a match
        inc     di              ;
        and     ax,not 2020h    ; BUGBUG -- assumes both names are alphanumeric -JTP
        cmp     al,ah           ; match?
        je      comp_loop       ; yes, keep looking at the characters
        clc                     ; prevent erroneous eof indication: clear carry
comp_exit:                      ;
        pop     di              ;
        ret                     ;
comp_almost:                    ;
        xchg    al,ah           ; we don't know for sure if it's a match
        call    any_delim       ; until we verify that the second string has
        xchg    al,ah           ; been exhausted also...
        jmp     comp_exit       ; if we are, this call to any_delim will tell...
comp_names  endp

        public  comp_names_safe

comp_names_safe proc near
        push    ax
        push    cx
        push    si
        push    ds
        push    cs
        pop     ds
        call    comp_names
        pop     ds
        pop     si
        pop     cx
        pop     ax
        ret
comp_names_safe endp


;
;----------------------------------------------------------------------------
;
;   print_item:  display menu item #BL
;
;   INPUT
;       BL == menu item # to display
;
;   OUTPUT
;       Menu item displayed, with appropriate highlighting if BL == bDefBlock
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This function saves/restores the current cursor position, so you
;       needn't worry about it.
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  print_item

print_item  proc near           ; prints menu item #BL (1 to N)
        push    ax              ;
        push    bx              ;
        push    cx              ;
        push    dx              ;
        push    si              ;
        mov     ah,03h          ; get cursor position
        mov     bh,[bMenuPage]  ; always page zero
        int     10h             ; DH/DL = row/column
        push    dx              ; save it
        mov     ah,02h          ; set cursor position
        mov     dh,bl           ;
        add     dh,3            ;
        mov     dl,5            ;
        int     10h             ; set cursor position for correct row/col
        mov     al,bl           ;
        add     al,'0'          ; convert menu item # to ASCII digit
        mov     ah,[bMenuColor] ; normal attribute
        cmp     bl,[bDefBlock]  ; are we printing the current block?
        jne     print_other     ; no
        or      ah,70h          ; yes, set bgnd color to white
        mov     ch,ah           ;
        mov     cl,4            ;
        rol     ch,cl           ;
        cmp     ch,ah           ; are fgnd/bgnd the same?
        jne     print_other     ; no
        xor     ah,08h          ; yes, so modify the fgnd intensity
print_other:                    ;
        mov     bh,0            ;
        add     bx,bx           ;
        mov     di,aoffBlockDesc[bx]
        mov     bl,ah           ; put the attribute in the correct register now
        mov     bh,[bMenuPage]  ; get correct video page #
        mov     ah,09h          ; write char/attr
        mov     cx,1            ;
        int     10h             ;
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        mov     ax,0900h+'.'    ;
        int     10h             ; display '.'
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        mov     ax,0900h+' '    ;
        int     10h             ; display ' '
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        push    es              ;
print_loop:                     ;
        mov     al,es:[di]      ; get a character of the description
        inc     di              ;
        cmp     al,TAB          ; substitute spaces for tabs
        jne     print_nontab    ;
        mov     al,' '          ;
print_nontab:                   ;
        cmp     al,' '          ;
        jb      print_done      ; stop at the 1st character < space
        cmp     al,'$'          ;
        je      print_done      ; also stop on $
        mov     ah,09h          ; display function #
        int     10h             ;
        inc     dl              ; increment column
        cmp     dl,78           ; far enough?
        jae     print_done      ; yes
        mov     ah,02h          ;
        int     10h             ;
        jmp     print_loop      ;
print_done:                     ;
        pop     es              ;
        pop     dx              ;
        mov     ah,02h          ;
        int     10h             ; restore previous row/col
        pop     si              ;
        pop     dx              ;
        pop     cx              ;
        pop     bx              ;
        pop     ax              ;
        ret                     ;
print_item  endp

;
;----------------------------------------------------------------------------
;
;   select_item:  wait for user to select menu item, with time-out
;
;   INPUT
;       None
;
;   OUTPUT
;       BX == menu item # (1-N), or -1 for clean boot
;       Selected menu item highlighted
;       Cursor positioned beneath menu, ready for tty-style output now
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  select_item

select_item proc near           ; returns digit value in BX (trashes AX/CX/DX)
        mov     bl,[bDefBlock]  ; BL will be the default block #
        mov     al,bl           ;
        call    disp_num        ;
        call    show_status     ; display current interactive status
        cmp     byte ptr [secTimeOut],-1
        je      input_key       ; no time-out, just go to input
        mov     ah,Get_Time     ;
        int     21h             ;
        mov     bh,dh           ; BH = initial # of seconds
check_time:
        mov     al,[secTimeOut] ;
        sub     al,[secElapsed] ;
        jae     show_time       ;
        or      byte ptr [bQueryOpt],2  ; disable all further prompting
        mov     byte ptr [secElapsed],0
        jmp     select_done     ; time's up!
show_time:
        push    bx              ;
        mov     bl,al           ; save # in BL
        mov     bh,[bMenuPage]  ;
        mov     ah,03h          ; get cursor position
        int     10h             ;
        push    dx              ;
	add	dl,8		; move cursor to the right
        mov     ah,02h          ; set cursor position
        int     10h             ;
        mov     dx,offset $TimeOut
        call    print           ; print the "Time remaining: " prompt
        mov     al,bl           ; recover # from BL
        cbw                     ; this works because AL is always <= 90
        mov     cl,10           ;
        div     cl              ; AL = tens digit, AH = ones digit
        mov     cl,ah           ;
        add     al,'0'          ;
        mov     ah,0Eh          ;
        int     10h             ; write TTY tens digit
        mov     al,cl           ;
        add     al,'0'          ;
        mov     ah,0Eh          ;
        int     10h             ; write TTY ones digit
        pop     dx
        mov     ah,02h          ; set cursor position back to where it was
        int     10h             ;
        pop     bx              ;
input_key:
        mov     ah,Raw_Con_IO   ;
        mov     dl,0FFh         ; input request
        int     21h             ;
        jnz     got_key         ;
        cmp     byte ptr [secTimeOut],-1; is there a time-out?
        je      input_key       ; no, just go back to input
        mov     ah,Get_Time     ;
        int     21h             ; DH = seconds
        mov     ah,dh           ;
        sub     dh,bh           ; should generally be zero or one
        mov     bh,ah           ;
        jnc     got_time        ;
        mov     dh,1            ; it wrapped back to zero, so assume one
got_time:
        or      dh,dh           ; any change?
        jz      input_key       ; no
        add     [secElapsed],dh ;
        jmp     check_time      ;
got_key:
        push    ax              ;
        mov     ax,-1           ; zap both secTimeOut and secElapsed
        xchg    word ptr [secTimeOut],ax
        cmp     al,-1           ; was time-out already disabled?
        je      timeout_disabled; yes
        push    bx              ; let's disable # seconds display
        mov     ax,0A20h        ; write multiple spaces
        mov     bx,word ptr [bMenuColor]
        mov     cx,80           ; 80 of them, to be safe
        int     10h             ; to completely obliterate # seconds display
        pop     bx              ;
timeout_disabled:
        pop     ax              ;
        or      al,al           ; extended key pressed?
        jnz     normal_key      ; no
        int     21h             ; get the next part of the key then
        jz      input_key       ; hmmm, what happened to the second part?

        cmp     al,48h          ; up arrow?
        jne     not_up          ; no
        cmp     bl,1            ; are we as up as up can get?
        jbe     input_key       ; yes, ignore it
        dec     [bDefBlock]     ;
        call    print_item      ; re-print the current item
        dec     bl              ; and then print the new current item
        jmp     short print1
not_up:
        cmp     al,50h          ; down arrow?
        jne     not_down        ; no
        cmp     bl,[bMaxBlock]  ; are we as down as down can get?
        jae     to_input_key    ; yes, ignore it
        inc     [bDefBlock]     ;
        call    print_item      ; re-print the current item
        inc     bx              ; and then print the new current item
print1: mov     al,bl           ;
print2: call    print_item      ;
        call    disp_num        ;
to_input_key:
        jmp     input_key       ;
not_down:
        test    byte ptr [bDisableUI],1
        jnz     to_input_key    ; don't allow F8 or F5
        cmp     al,42h          ; F8 function key?
        jne     not_f8          ; no
        xor     byte ptr [bQueryOpt],1
        call    show_status     ;
        jmp     input_key       ;
not_f8:
        cmp     al,3Fh          ; F5 function key?
        jne     to_input_key    ; no
        mov     bx,-1           ; special return code (-1) indicating clean boot
        mov     al,' '          ; don't want to display anything really;
        jmp     short disp_input; just want to display the cr/lf sequence...

normal_key:
        cmp     al,0Dh          ; Enter?
        je      select_done     ; yes
        cmp     al,08h          ; backspace?
        jne     not_backspace   ; no
        mov     bx,-2           ; yes, special return code
        ret                     ;
not_backspace:
        sub     al,'0'          ; is greater than '0'?
        jbe     to_input_key    ; no
        cmp     al,[bMaxBlock]  ; is less than or equal to the maximum digit?
        ja      to_input_key    ; no
        mov     [bDefBlock],al  ;
        call    print_item      ; redisplay the current selection
        mov     bl,al           ; set new selection
        jmp     print2

select_done:
        mov     bh,0            ; return a full 16-bit value (for indexing)
        mov     al,bl           ;
        add     al,'0'          ; convert it into a digit, then display it
        if2
        .errnz  disp_input-$    ; fall into disp_input
        endif
select_item endp

;
;----------------------------------------------------------------------------
;
;   disp_input:  display a single character + cr/lf
;
;   INPUT
;       AL == character to display
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This function is used not only for the menu input selection but
;       also for the interactive line prompting (the y/n/a thing).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  disp_input

disp_input  proc near
        push    ax
        cmp     al,' '
        jae     disp_ok
        mov     al,' '
disp_ok:
        mov     dl,al
        mov     ah,Std_Con_Output
        int     21h
        mov     dx,offset crlfm
        call    print
        pop     ax
        ret
disp_input  endp

disp_num    proc near
        push    bx
        add     al,'0'
        mov     ah,0Ah
        mov     bx,word ptr [bMenuColor]
        mov     cx,1
        int     10h
        pop     bx
        ret
disp_num    endp

;
;----------------------------------------------------------------------------
;
;   show_status:  display current interactive mode setting (on/off/none)
;
;   INPUT
;       None
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  show_status

show_status proc near
        push    bx              ; BL = video page #
        mov     bx,word ptr [bMenuColor]
        mov     ah,03h          ; get cursor position
        int     10h             ;
        push    dx              ; save it
        mov     ah,02h          ; set cursor position
        mov     dx,word ptr [bLastCol]   ; set correct row/col
        test    byte ptr [bDisableUI],1
        jz      show_onoff      ; just show on/off
        mov     dl,0            ;
        int     10h             ;
        mov     ax,0A20h        ; write multiple spaces
        mov     cx,80           ; 80 of them, to be exact
        int     10h             ; to obliterate the status line
        jmp     short show_done ;
show_onoff:                     ;
        int     10h             ;
        mov     al,$NO          ; assume OFF
        cmp     byte ptr [bQueryOpt],1  ; is interactive mode on?
        jne     show_noton      ; no
        mov     al,$YES         ; yes
show_noton:                     ;
        mov     ah,0Eh          ; write TTY
        int     10h             ;
show_done:                      ;
        pop     dx              ;
        mov     ah,02h          ;
        int     10h             ; restore original cursor position
        pop     bx              ;
        ret                     ;
show_status endp

;
;----------------------------------------------------------------------------
;
;   skip_token:  advances ES:SI/CX past the current token
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOL/EOF hit
;       AL == 1st char of delimiter
;    ES:SI -> just past the delimiter
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  skip_token

skip_token  proc near
        call    get_char
        jc      skip_token_done
        call    any_delim
        jne     skip_token
skip_check_eol:
        cmp     al,CR
        je      skip_token_eol
        cmp     al,LF
        je      skip_token_eol
        clc
        jmp     short skip_token_done
skip_token_eol:
        stc
skip_token_done:
        ret
skip_token  endp

;
;----------------------------------------------------------------------------
;
;   skip_delim:  advances ES:SI/CX past the current delimiter
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;       AL == 1st char of token
;    ES:SI -> just past the token
;       CX == # bytes remaining from that point
;    ES:BX -> new token (since ES:SI is already pointing 1 byte past token)
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  skip_delim

skip_delim  proc near           ; returns carry set if eol/eof
        call    get_char        ;
        lea     bx,[si-1]       ; also returns BX -> next token
        jc      skip_token_done ;
        call    delim           ;
        je      skip_delim      ;
        jmp     skip_check_eol  ;
skip_delim  endp

;
;----------------------------------------------------------------------------
;
;   skip_opt_line:  same as skip_line provided AL != LF
;
;   INPUT
;       AL == last character read
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;       AL == 1st char of new line
;    ES:SI -> just past 1st char of new line
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       In other words, the purpose here is to skip to the next line,
;       unless ES:SI is already sitting at the front of the next line (which
;       it would be if the last character fetched -- AL -- was a linefeed)
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  skip_opt_line

skip_opt_line   proc near
        cmp     al,LF
        je      skip_line_done
        if2
        .errnz  skip_line-$     ; fall into skip_line
        endif
skip_opt_line   endp

;
;----------------------------------------------------------------------------
;
;   skip_line:  skip to the next line
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;    ES:SI -> just past 1st char of new line
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  skip_line

skip_line   proc near
        call    get_char
        jc      skip_line_done
        cmp     al,LF
        jne     skip_line
skip_line_done:
        ret
skip_line   endp

;
;----------------------------------------------------------------------------
;
;   get_number:  return binary equivalent of numeric string
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       AL == non-digit encountered
;       BX == binary #
;    ES:SI -> just past 1st non-digit
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  get_number

get_number  proc near
        sub     bx,bx           ; BX = result
num_loop:
        call    get_char        ;
        jc      num_done        ;
        cmp     al,'0'          ; convert to value
        jb      num_done        ; no more number
        cmp     al,'9'          ;
        ja      num_done        ;
        push    ax              ;
        mov     ax,10           ;
        push    dx              ;
        mul     bx              ;
        pop     dx              ;
        mov     bx,ax           ;
        pop     ax              ;
        sub     al,'0'          ;
        cbw                     ;
        add     bx,ax           ;
        jmp     num_loop        ;
num_done:
        ret
get_number  endp

;
;----------------------------------------------------------------------------
;
;   get_char:  return next character, advance ES:SI, and decrement CX
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       AL == next character
;    ES:SI -> just past next character
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  get_char

get_char    proc near
        sub     cx,1            ; use SUB to set carry,zero
        jb      get_fail        ; out of data
        lods    byte ptr es:[si];
        mov     ah,al           ;
        ret                     ;
get_fail:                       ; restore CX to zero
        mov     cx,0            ; leave carry set, zero not set
nearby_ret:
        ret
get_char    endp

;
;----------------------------------------------------------------------------
;
;   query_user:  ask user whether to execute current config.sys command
;
;   INPUT
;       AL == current command code
;    ES:SI -> current command line in config.sys
;    config_cmd == current command code, but with QUERY bit intact
;                  (00h used to generate "Process AUTOEXEC.BAT" prompt)
;
;   OUTPUT
;       CF set if command should be ignored (it is also REM'ed out)
;
;   OTHER REGS USED
;       BX, CX, DX, DI
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  query_user

query_user  proc near
        test    byte ptr [bQueryOpt],4  ; answer no to everything?
        jz      @F                      ;
        jmp     skip_all                ;
@@:     test    byte ptr [bQueryOpt],2  ; answer yes to everything?
        jnz     nearby_ret              ; yes (and return carry clear!)
        push    ax                      ;
        mov     al,[config_cmd]         ;
        test    byte ptr [bQueryOpt],1  ; query every command?
        jnz     query_all               ; yes
        test    al,CONFIG_OPTION_QUERY  ;
        jnz     query_all               ;
        jmp     do_cmd                  ;
query_all:
;
;   Search for the command code (AL) in "comtab", and then print
;   out the corresponding keyword, followed by the rest of the actual
;   line pointed to by ES:SI
;
        push    si                      ; save pointer to rest of CONFIG.SYS line
        mov     dx,offset $AutoPrmpt    ;
        and     al,NOT CONFIG_OPTION_QUERY
        jz      generic_prompt          ; config_cmd must have been 0

        mov     dh,al                   ; save config_cmd in DH
        sub     bx,bx                   ;
        mov     di,offset comtab        ;
find_match:                             ;
        mov     bl,[di]                 ; get size of current keyword
        or      bl,bl                   ;
        jz      line_print              ; end of table
        inc     di                      ;
        cmp     al,[di+bx]              ; match?
        je      cmd_match               ; yes
        lea     di,[di+bx+1]            ; otherwise, skip this command code
        jmp     find_match              ; loop
cmd_match:                              ;
        mov     cl,[di-1]               ;
        mov     ch,0                    ;
        mov     ah,Std_Con_Output
cmd_print:                              ;
        mov     al,[di]                 ;
        inc     di                      ;
        mov     dl,al                   ;
        int     21h                     ;
        loop    cmd_print               ;
        mov     dl,'='                  ;
        cmp     dh,CONFIG_SET           ; for SET commands, don't display a '='
        jne     cmd_notset              ;
        mov     dl,' '                  ;
cmd_notset:
        int     21h                     ; '=' looks funny on SET commands
line_print:                             ;
        lods    byte ptr es:[si]        ;
        or      al,al                   ;
        jnz     non_null                ;
        mov     al,' '                  ;
non_null:                               ;
        cmp     al,' '                  ; control code?
        jb      prompt_user             ; yes, assume end of line
        jne     non_space               ;
        cmp     byte ptr es:[si],' '    ;
        jb      prompt_user             ;
non_space:                              ;
        mov     dl,al                   ;
        mov     ah,Std_Con_Output       ;
        int     21h                     ;
        jmp     line_print              ;
prompt_user:                            ;
        mov     dx,offset $InterPrmpt   ;

generic_prompt:
        call    print                   ;
input_loop:                             ;
        mov     ah,0                    ; read a key
        int     16h                     ;
        or      al,al                   ; is it a function key?
        jnz     not_func                ; no
        cmp     ah,3Fh                  ; F5 function key?
        jne     input_loop              ; no
        mov     al,$NO                  ;
        or      byte ptr [bQueryOpt],4  ; no more queries
        jmp     short legal_char        ;
not_func:
        and     al,not 20h              ; converting to upper case
        cmp     al,$NO                  ; verify character is legal
        je      legal_char              ;
        cmp     al,$YES                 ;
        je      legal_char              ;
        cmp     [config_cmd],0          ;
        je      input_loop              ; don't allow Esc on this query
        cmp     al,1Bh                  ; Esc?
        jne     input_loop              ;
        or      byte ptr [bQueryOpt],2  ; no more interactive boot prompts
        mov     al,$YES
legal_char:                             ;
        call    disp_input              ;
        pop     si                      ; restore pointer to rest of CONFIG.SYS line

        cmp     al,$NO                  ; process line?
        je      skip_cmd                ; no
do_cmd:
        pop     ax                      ;
        clc                             ; just do the command
        ret

skip_cmd:
        pop     ax                      ;
skip_all:
        mov     ah,CONFIG_REM           ; fake out the rest of sysinit's processing
        stc
        ret
query_user  endp

;
;----------------------------------------------------------------------------
;
;   print_error:  displays multi-config error conditions
;
;   INPUT
;    Carry set to pause, clear to not
;    ES:SI -> current command line in config.sys
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------
;
        public  print_error
        extrn   error_line:near
        extrn   linecount:word

print_error proc near
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    cs
        pop     ds
        pushf
        call    get_linenum
        mov     [linecount],bx
        call    error_line
        popf
        jnc     pe_ret
        mov     dx,offset $PauseMsg
        call    print
        mov     ax,0C07h                ; flush input buffer, then wait for key
        int     21h                     ; wait for a key
        or      al,al                   ; extended key?
        jnz     @F                      ; no
        mov     ah,07h                  ; yes
        int     21h                     ; eat it too
@@:     mov     dx,offset crlfm
        call    print
pe_ret: pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
	ret
print_error endp


;
;   This function is very simple:  it merely prepends a "/D" to the
;   command-line for the shell;  this (undocumented) switch disables
;   AUTOEXEC.BAT processing and the date/time prompt that is usually
;   displayed when there's no AUTOEXEC.BAT.
;
        public  disable_autoexec

disable_autoexec proc near
        or      byte ptr [bQueryOpt],2
        mov     al,[command_line-1]     ; get default switchchar
        or      al,al                   ; anything there?
        jz      disable_exit            ; no, disable_autoexec already called
        mov     bl,[command_line]       ;
        mov     bh,0                    ; BX == command-line length
        mov     cx,bx                   ;
        add     bl,3                    ;
        cmp     bl,126                  ;
        ja      disable_exit            ;
        mov     [command_line],bl       ; update length
        add     bx,offset command_line+1; make sure we move the NULL too
        inc     cx                      ; (just for consistency sake)
disable_loop:                           ;
        mov     ah,[bx-3]               ;
        mov     [bx],ah                 ;
        dec     bx                      ;
        loop    disable_loop            ;
        mov     [bx-2],al               ;
        mov     word ptr [bx-1],' D'    ; /D is stuffed into place now
        mov     byte ptr [command_line-1],0
disable_exit:                           ;
        ret                             ;
disable_autoexec endp

        assume  ds:nothing

endif  ;MULTI_CONFIG

;
;----------------------------------------------------------------------------
;
; procedure : delim
;
;----------------------------------------------------------------------------
;
ifdef   MULTI_CONFIG
any_delim proc  near
        cmp     al,CR
        je      delim_ret
        cmp     al,LF
        je      delim_ret
        cmp     al,'['
        je      delim_ret
        cmp     al,']'
        je      delim_ret
        if2
        .errnz  delim-$
        endif
any_delim endp
endif  ;MULTI_CONFIG

delim	proc	near
	cmp	al,'/'		; ibm will assume "/" as an delimeter.
	jz	delim_ret

	cmp	al, 0		; special case for sysinit!!!
	jz	delim_ret

org_delim:			; used by organize routine except for getting
	cmp	al,' '          ;the filename.
	jz	delim_ret
        cmp     al,TAB
	jz	delim_ret
	cmp	al,'='
	jz	delim_ret
	cmp	al,','
	jz	delim_ret
	cmp	al,';'
ifdef   MULTI_CONFIG
;
;   Make sure there's no chance of a false EOF indication
;
        clc
endif
delim_ret:
	ret
delim	endp

;
;----------------------------------------------------------------------------
;
; procedure : newline
;
;  newline returns with first character of next line
;
;----------------------------------------------------------------------------
;

newline	proc	near

	call	getchr			;skip non-control characters
	jc	nl_ret
	cmp	al,lf			;look for line feed
	jnz	newline
	call	getchr
nl_ret:
	ret

newline	endp

;
;----------------------------------------------------------------------------
; 
; procedure : mapcase
;
;----------------------------------------------------------------------------
;
mapcase	proc	near
	push	cx
	push	si
	push	ds

	push	es
	pop	ds

ifdef   MULTI_CONFIG
        mov     bl,al                   ; same cmd code this line
else
	xor	si,si
endif

convloop:
	lodsb

	ifdef	DBCS
	call	testkanj
	jz	normconv		; if this is not lead byte

	mov	ah,al
	lodsb				; get tail byte
	cmp	ax,DB_SPACE
	jnz	@f			; if this is not dbcs space
	mov	word ptr [si-2],'  '	; set 2 single space
@@:

	dec	cx
        jcxz    convdone                ; just ignore 1/2 kanji error
	jmp	short noconv

;fall through, know al is not in 'a'-'z' range

normconv:
	endif

	cmp	al,'a'
	jb	noconv
	cmp	al,'z'
	ja	noconv
	sub	al,20h
	mov	[si-1],al
noconv:
ifdef   MULTI_CONFIG
;
;   When MULTI_CONFIG enabled, "mapcase" is used to map everything to
;   upper-case a line at a time, after we've been able to figure out whether
;   the line is a SET command or not (since we don't want to upper-case
;   anything after the "=" in a SET)
;
        cmp     bl,CONFIG_SET           ; preserve case for part of the line?
        jne     check_eol               ; no, just check for end-of-line
        cmp     al,'='                  ; separator between SET var and value?
        je      convdone                ; yes
check_eol:
        cmp     al,cr
        je      convdone
        cmp     al,lf
        je      convdone
endif
	loop	convloop

convdone:
	pop	ds
	pop	si
	pop	cx
	ret

	ifdef	DBCS

	public	testkanj
testkanj:
	push	si
	push	ds

	push	ax
	mov	ax,6300h		; get dos dbcs vector
	int	21h
	pop	ax

bdbcs_do:

	cmp	ds:word ptr [si],0	; end of lead byte info?
	jz	bdbcs_notfound		; jump if so
	cmp	al,ds:[si]		; less than first byte character?
	jb	bdbcs_next		; jump if not
	cmp	al,ds:[si+1]		; grater than first byte character?
	ja	bdbcs_next

bdbcs_found:

	push	ax
	xor	ax,ax
	inc	ax			; reset zero flag
	pop	ax

bdbcs_exit:

	pop	ds
	pop	si
	ret

bdbcs_notfound:

	push	ax
	xor	ax,ax			; set zero flag
	pop	ax
	jmp	short bdbcs_exit

bdbcs_next:

	add	si,2			; points next lead byte table
	jmp	short bdbcs_do

	endif  ; DBCS

mapcase	endp

ENDIF ; CONFIGPROC

;
;----------------------------------------------------------------------------
;
; procedure : round
;
; round the values in memlo and memhi to paragraph boundary.
; perform bounds check.
;
;----------------------------------------------------------------------------
;

round	proc	near

	push	ax
	mov	ax,[memlo]

	call	pararound		; para round up

	add	[memhi],ax
	mov	[memlo],0
	mov	ax,memhi		; ax = new memhi
	cmp	ax,[alloclim]		; if new memhi >= alloclim, error
	jae	mem_err
	test	cs:[setdevmarkflag], for_devmark
	jz	skip_set_devmarksize
	push	es
	push	si
	mov	si, cs:[devmark_addr]
	mov	es, si
	sub	ax, si
	dec	ax
	mov	es:[devmark_size], ax	; paragraph
	and	cs:[setdevmarkflag], not_for_devmark
	pop	si
	pop	es
skip_set_devmarksize:
	pop	ax
	clc				;clear carry
	ret

mem_err:
	mov	dx,offset badmem
	push	cs
	pop	ds
	call	print
	jmp	stall

round	endp

IFDEF	CONFIGPROC
;
;----------------------------------------------------------------------------
;
; procedure : calldev
;
;----------------------------------------------------------------------------
;
calldev	proc	near

	mov	ds,word ptr cs:[DevEntry+2]
	add	bx,word ptr cs:[DevEntry]	;do a little relocation
	mov	ax,ds:[bx]

	push	word ptr cs:[DevEntry]
	mov	word ptr cs:[DevEntry],ax
	mov	bx,offset packet
	call	[DevEntry]
	pop	word ptr cs:[DevEntry]
	ret

calldev	endp

;
;----------------------------------------------------------------------------
;
; procedure : todigit
;
;----------------------------------------------------------------------------
;
todigit	proc	near
	sub	al,'0'
	jb	notdig
	cmp	al,9
	ja	notdig
	clc
	ret
notdig:
	stc
	ret
todigit	endp

;
;----------------------------------------------------------------------------
;
; procedure : getnum
;
; getnum parses a decimal number.
; returns it in ax, sets zero flag if ax = 0 (may be considered an
; error), if number is bad carry is set, zero is set, ax=0.
;
;----------------------------------------------------------------------------
;

getnum	proc	near

	push	bx
	xor	bx,bx			; running count is zero

b2:
	call	todigit 		; do we have a digit
	jc	badnum			; no, bomb

	xchg	ax,bx			; put total in ax
	push	bx			; save digit
	mov	bx,10			; base of arithmetic
	mul	bx			; shift by one decimal di...
	pop	bx			; get back digit
	add	al,bl			; get total
	adc	ah,0			; make that 16 bits
	jc	badnum			; too big a number

	xchg	ax,bx			; stash total

	call	getchr			;get next digit
	jc	b1			; no more characters
	cmp	al, ' ' 		; space?
	jz	b15			; then end of digits
	cmp	al, ',' 		; ',' is a seperator!!!
	jz	b15			; then end of digits.
	cmp	al, tab 		; tab
	jz	b15
	cmp	al,sepchr		; allow 0 or special separators
	jz	b15
	cmp	al,'/'			; see if another switch follows
	nop				; cas - remnant of old bad code
	nop
	jz	b15
	cmp	al,lf			; line-feed?
	jz	b15
	cmp	al,cr			; carriage return?
	jz	b15
	or	al,al			; end of line separator?
	jnz	b2			; no, try as a valid char...

b15:
	inc	count			; one more character to s...
	dec	chrptr			; back up over separator
b1:
	mov	ax,bx			; get proper count
	or	ax,ax			; clears carry, sets zero accordingly
	pop	bx
	ret
badnum:
	mov	sepchr,0
	xor	ax,ax		; set zero flag, and ax = 0
	pop	bx
	stc			; and carry set
	ret

getnum	endp

;*****************************************************************

setdoscountryinfo	proc	near

;input: es:di -> pointer to dos_country_cdpg_info
;	ds:0  -> buffer.
;	si = 0
;	ax = country id
;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
;	bx = file handle
;	this routine can handle maxium 438 country_data entries.
;
;output: dos_country_cdpg_info set.
;	 carry set if any file read failure or wrong information in the file.
;	 carry set and cx = -1 if cannot find the matching country_id, codepage
;	 _id in the file.

	push	di
	push	ax
	push	dx

	xor	cx,cx
	xor	dx,dx
	mov	ax,512			;read 512 bytes
	call	readincontrolbuffer	;read the file header
	jc	setdosdata_fail

	push	es
	push	si

	push	cs
	pop	es

	mov	di,offset country_file_signature
	mov	cx,8			;length of the signature
	repz	cmpsb

	pop	si
	pop	es
	jnz	setdosdata_fail 	;signature mismatch

	add	si,18			;si -> county info type
	cmp	byte ptr ds:[si],1	;only accept type 1 (currently only 1 header type)
	jne	setdosdata_fail 	;cannot proceed. error return

	inc	si			;si -> file offset
	mov	dx,word ptr ds:[si]	;get the info file offset.
	mov	cx,word ptr ds:[si+2]
	mov	ax,6144			;read 6144 bytes.
	call	readincontrolbuffer	;read info
	jc	setdosdata_fail

	mov	cx, word ptr ds:[si]	;get the # of country, codepage combination entries
	cmp	cx, 438			;cannot handle more than 438 entries.
					;	
	ja	setdosdata_fail

	inc	si
	inc	si			;si -> entry information packet
	pop	dx			;restore code page id
	pop	ax			;restore country id
	pop	di

setdoscntry_find:			;search for desired country_id,codepage_id.
	cmp	ax, word ptr ds:[si+2]	;compare country_id
	jne	setdoscntry_next

	cmp	dx, 0			;no user specified code page ?
	je	setdoscntry_any_codepage;then no need to match code page id.
	cmp	dx, word ptr ds:[si+4]	;compare code page id
	je	setdoscntry_got_it

setdoscntry_next:
	add	si, word ptr ds:[si]	;next entry
	inc	si
	inc	si			;take a word for size of entry itself
	loop	setdoscntry_find

	mov	cx, -1			;signals that bad country id entered.
setdoscntry_fail:
	stc
	ret

setdosdata_fail:
	pop	si
	pop	cx
	pop	di
	jmp	short setdoscntry_fail

setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
	mov	dx, word ptr ds:[si+4]

setdoscntry_got_it:			;found the matching entry
	mov	cs:cntrycodepage_id, dx ;save code page id for this country.
	mov	dx, word ptr ds:[si+10] ;get the file offset of country data
	mov	cx, word ptr ds:[si+12]
	mov	ax, 512 		;read 512 bytes
	call	readincontrolbuffer
	jc	setdoscntry_fail

	mov	cx, word ptr ds:[si]	;get the number of entries to handle.
	inc	si
	inc	si			;si -> first entry

setdoscntry_data:
	push	di			;es:di -> dos_country_cdpg_info
	push	cx			;save # of entry left
	push	si			;si -> current entry in control buffer

	mov	al, byte ptr ds:[si+2]	;get data entry id
	call	getcountrydestination	;get the address of destination in es:di
	jc	setdoscntry_data_next	;no matching data entry id in dos

	mov	dx, word ptr ds:[si+4]	;get offset of data
	mov	cx, word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer
	jc	setdosdata_fail

	mov	dx,512			;start of data buffer
	mov	cx,20			;read 20 bytes only. we only need to
	mov	ah,3fh			;look at the length of the data in the file.
	stc
	int	21h			;read the country.sys data
	jc	setdosdata_fail 	;read failure

	cmp	ax,cx
	jne	setdosdata_fail

	mov	dx,word ptr ds:[si+4]	;get offset of data again.
	mov	cx,word ptr ds:[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer back again
	jc	setdosdata_fail

	push	si
	mov	si,(512+8)		;get length of the data from the file
	mov	cx,word ptr ds:[si]
	pop	si
	mov	dx,512			;start of data buffer
	add	cx,10			;signature + a word for the length itself
	mov	ah,3fh			;read the data from the file.
	stc
	int	21h
	jc	setdosdata_fail

	cmp	ax, cx
	jne	setdosdata_fail

	mov	al,byte ptr ds:[si+2]	;save data id for future use.
	mov	si,(512+8)		;si-> data buffer + id tag field
	mov	cx,word ptr ds:[si]	;get the length of the file
	inc	cx			;take care of a word for lenght of tab
	inc	cx			;itself.
	cmp	cx,(2048 - 512 - 8)	;fit into the buffer?
	ja	setdosdata_fail

	if	bugfix
	call	setdbcs_before_copy
	endif

	cmp	al, setcountryinfo	;is the data for setcountryinfo table?
	jne	setdoscntry_mov 	;no, don't worry

	push	word ptr es:[di+ccmono_ptr-cccountryinfolen]	;cannot destroy ccmono_ptr address. save them.
	push	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	;at this time di -> cccountryinfolen
	push	di			;save di

	push	ax
	mov	ax,cs:cntrycodepage_id	;do not use the code page info in country_info
	mov	ds:[si+4], ax		;use the saved one for this !!!!
	pop	ax

setdoscntry_mov:
	rep	movsb			;copy the table into dos
	cmp	al, setcountryinfo	;was the ccmono_ptr saved?
	jne	setdoscntry_data_next

	pop	di			;restore di
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen+2]	 ;restore
	pop	word ptr es:[di+ccmono_ptr-cccountryinfolen]

setdoscntry_data_next:
	pop	si			;restore control buffer pointer
	pop	cx			;restore # of entries left
	pop	di			;restore pointer to dso_country_cdpg
	add	si, word ptr ds:[si]	;try to get the next entry
	inc	si
	inc	si			;take a word of entry length itself
	dec	cx
	cmp	cx,0
	je	setdoscntry_ok
	jmp	setdoscntry_data

setdoscntry_ok:
	ret
setdoscountryinfo	endp

	if	bugfix
setdbcs_before_copy	proc	near

	cmp	al,setdbcs		; dbcs vector set?
	jnz	@f			; jump if not
	cmp	word ptr es:[di], 0	; zero byte data block?
	jz	@f			; jump if so

	push	di
	push	ax
	push	cx
	mov	cx,es:[di]		; load block length
	add	di,2			; points actual data
	xor	al,al			; fill bytes
	rep	stosb			; clear data block
	pop	cx
	pop	ax
	pop	di
@@:
	ret
setdbcs_before_copy	endp
	endif

getcountrydestination	proc	near

;get the destination address in the dos country info table.
;input: al - data id
;	es:di -> dos_country_cdpg_info
;on return:
;	es:di -> destination address of the matching data id
;	carry set if no matching data id found in dos.

	push	cx
	add	di,ccnumber_of_entries	;skip the reserved area, syscodepage etc.
	mov	cx,word ptr es:[di]	;get the number of entries
	inc	di
	inc	di			;si -> the first start entry id

getcntrydest:
	cmp	byte ptr es:[di],al
	je	getcntrydest_ok
	cmp	byte ptr es:[di],setcountryinfo ;was it setcountryinfo entry?
	je	getcntrydest_1

	add	di,5			;next data id
	jmp	short getcntrydest_loop

getcntrydest_1:
	add	di,new_country_size + 3 ;next data id
getcntrydest_loop:
	loop	getcntrydest
	stc
	jmp	short getcntrydest_exit

getcntrydest_ok:
	cmp	al,setcountryinfo	;select country info?
	jne	getcntrydest_ok1

	inc	di			;now di -> cccountryinfolen
	jmp	short getcntrydest_exit

getcntrydest_ok1:
	les	di,dword ptr es:[di+1]	;get the destination in es:di

getcntrydest_exit:
	pop	cx
	ret
getcountrydestination	endp


readincontrolbuffer	proc	near

;move file pointer to cx:dx
;read ax bytes into the control buffer. (should be less than 2 kb)
;si will be set to 0 hence ds:si points to the control buffer.
;entry:  cx,dx offset from the start of the file where the read/write pointer
;	 be moved.
;	 ax - # of bytes to read
;	 bx - file handle
;	 ds - buffer seg.
;return: the control data information is read into ds:0 - ds:0200.
;	 cx,dx value destroyed.
;	 carry set if error in reading file.

	push	ax			;# of bytes to read
	mov	ax, 4200h
	stc
	int	21h			;move pointer
	pop	cx			;# of bytes to read
	jc	ricb_exit

	xor	dx,dx			;ds:dx -> control buffer
	xor	si,si
	mov	ah,3fh			;read into the buffer
	stc
	int	21h			;should be less than 1024 bytes.

ricb_exit:
	ret
readincontrolbuffer	endp


set_country_path	proc	near

;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
;     assumes current directory is the root directory.
;out: ds:di -> full path (cntry_drv).
;     set the cntry_drv string from the country=,,path command.
;     ds, es, si value saved.

	push	si

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;now ds -> confbot, es -> sysinitseg

	call	chk_drive_letter	;current ds:[si] is a drive letter?
	jc	scp_default_drv 	;no, use current default drive.

	mov	al, byte ptr ds:[si]
	inc	si
	inc	si			;si -> next char after ":"
	jmp	short scp_setdrv

scp_default_drv:
	mov	ah, 19h
	int	21h
	add	al, "A"			;convert it to a character.

scp_setdrv:
	mov	cs:cntry_drv, al	;set the drive letter.
	mov	di, offset cntry_path
	mov	al, byte ptr ds:[si]
	cmp	al, "\"
	je	scp_root_dir

	cmp	al,"/"			;let's accept "/" as an directory delim
	je	scp_root_dir

	jmp	short scp_path

scp_root_dir:
	dec	di			;di -> cntry_root
scp_path:
	call	move_asciiz		;copy it

	mov	di, offset cntry_drv
scpath_exit:

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;ds, es value restored

	pop	si
	ret
set_country_path	endp


chk_drive_letter	proc	near
;check if ds:[si] is a drive letter followed by ":".
;assume that every alpha charater is already converted to upper case.
;carry set if not.

	push	ax
	cmp	byte ptr ds:[si], "A"
	jb	cdletter_no
	cmp	byte ptr ds:[si], "Z"
	ja	cdletter_no
	cmp	byte ptr ds:[si+1], ":"
	jne	cdletter_no

	jmp	short cdletter_exit

cdletter_no:
	stc

cdletter_exit:
	pop	ax
	ret
chk_drive_letter	endp


move_asciiz	proc	near
;in: ds:si -> source es:di -> target
;out: copy the string until 0.
;assumes there exists a 0.

masciiz_loop:
	movsb
	cmp	byte ptr ds:[si-1],0	;was it 0?
	jne	masciiz_loop
	ret
move_asciiz	endp

ENDIF ; CONFIGPROC

;
;	ds:dx points to string to output (asciz)
;
;	prints <badld_pre> <string> <badld_post>

badfil:
	push	cs
	pop	es

	mov	si,dx
badload:
	mov	dx,offset badld_pre	;want to print config error
	mov	bx, offset crlfm

prnerr:
	push	cs
	pop	ds
	call	print

prn1:
	mov	dl,es:[si]
	or	dl,dl
	jz	prn2
	mov	ah,std_con_output
	int	21h
	inc	si
	jmp	prn1

prn2:
	mov	dx,bx
	call	print

IFDEF	CONFIGPROC
	cmp	donotshownum,1		; suppress line number when handling command.com
	je	prnexit
	call	error_line
ENDIF ; CONFIGPROC

prnexit:
	ret

print:
	mov	ah,std_con_string_output
	int	21h
	ret


	if	noexec

; load non exe file called [ds:dx] at memory location es:bx

ldfil:
	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	ds
	push	bx

	xor	ax,ax			;open the file
	mov	ah,open
	stc				;in case of int 24
	int	21h
	pop	dx			;clean stack in case jump
	jc	ldret

	push	dx
	mov	bx,ax			;handle in bx
	xor	cx,cx
	xor	dx,dx
	mov	ax,(lseek shl 8) or 2
	stc				;in case of int 24
	int	21h			; get file size in dx:ax
	jc	ldclsp

	or	dx,dx
	jnz	lderrp			; file >64k
	pop	dx

	push	dx
	mov	cx,es			; cx:dx is xaddr
	add	dx,ax			; add file size to xaddr
	jnc	dosize
	add	cx,1000h		; ripple carry
dosize:
	mov	ax,dx
	call	pararound
	mov	dx,ax

	add	cx,dx
	cmp	cx,[alloclim]
	jb	okld
	jmp	mem_err

okld:
	xor	cx,cx
	xor	dx,dx
	mov	ax,lseek shl 8		;reset pointer to beginning of file
	stc				;in case of int 24
	int	21h
	jc	ldclsp

	pop	dx

	push	es			;read the file in
	pop	ds			;trans addr is ds:dx

	mov	cx,0ff00h		; .com files arn't any bigger than
					; 64k-100h
	mov	ah,read
	stc				;in case of int 24
	int	21h
	jc	ldcls

	mov	si,dx			;check for exe file
	cmp	word ptr [si],"ZM"
	clc				; assume ok
	jnz	ldcls			; only know how to do .com files

	stc
	jmp	short ldcls

lderrp:
	stc
ldclsp:
	pop	dx			;clean stack
ldcls:
	pushf
	mov	ah,close		;close the file
	stc
	int	21h
	popf

ldret:	pop	ds
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	ret
	endif

;
;  open device pointed to by dx, al has access code
;   if unable to open do a device open null device instead
;
open_dev:
	call	open_file
	jnc	open_dev3

open_dev1:
	mov	dx,offset nuldev
	call	open_file
of_ret:
	ret

open_dev3:
	mov	bx,ax			; handle from open to bx
	xor	ax,ax			; get device info
	mov	ah,ioctl
	int	21h
	test	dl,10000000b
	jnz	of_ret

	mov	ah,close
	int	21h
	jmp	open_dev1

open_file:
	mov	ah,open
	stc
	int	21h
	ret

; test int24. return back to dos with the fake user response of "fail"

int24:
	mov	al, 3			; fail the system call
	iret				; return back to dos.

include copyrigh.inc			; copyright statement


nuldev	db	"NUL",0
condev	db	"CON",0
auxdev	db	"AUX",0
prndev	db	"PRN",0

IFDEF	CONFIGPROC
config	db	"\CONFIG.SYS",0

cntry_drv   db	  "A:"
cntry_root  db	  "\"
cntry_path  db	  "COUNTRY.SYS",0
	    db	  52 dup (0)

country_file_signature db 0ffh,'COUNTRY'

cntrycodepage_id dw ?

ENDIF ; CONFIGPROC

ifdef   MULTI_CONFIG
newcmd  db      0                       ; non-zero if non-std shell specified
tmplate db      64                      ; must precede commnd
endif

ifdef	ROMEXEC
        db      7                       ; size of commnd line (excl. null)
commnd	db	"COMMAND",0
	db	56 dup (0)
else
        db      12                      ; size of commnd line (excl. null)
commnd	db	"\COMMAND.COM",0
	db	51 dup (0)
endif

ifdef   MULTI_CONFIG
commnd2 db      "\COMMAND.COM",0        ; alternate commands to exec,
        db      2,"/P",0                ; followed by their respective alternate
commnd3 db      "\MSDOS\COMMAND.COM",0  ; command lines
        db      11,"A:\MSDOS /P",0      ;(the drive letter are dynamically replaced)
commnd4 db      "\DOS\COMMAND.COM",0    ;
        db      9,"A:\DOS /P",0         ;

        db      0                       ; default switchchar (referenced as command_line-1)
endif

command_line    db  2,"/P"              ; default command.com args
        db      125 dup (0)

IFDEF	CONFIGPROC

pathstring db	64 dup (0)

ifdef   MULTI_CONFIG
;
;   Beware of byte pairs accessed as words (see all "KEEP AFTER" notes below)
;
bMenuColor      db      07h ;1Fh        ; default fgnd/bgnd color
bMenuPage       db      0               ; menu video page (KEEP AFTER bMenuColor)
                db      5               ; video page function # (KEEP AFTER bMenuPage)
bLastCol        db      ?               ; ending column on status line
bLastRow        db      24              ; row # of status line (KEEP AFTER bLastCol)
bDisableUI      db      0               ; 1=disable clean/interactive
                                        ; 2=disable default 2-second delay
bCRTPage        db      ?               ; value saved from BIOS data area
wCRTStart       dw      ?               ; value saved from BIOS data area
bQueryOpt       db      0               ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
bDefBlock       db      1               ; default block #
bMaxBlock       db      ?               ; maxmimum block #
offDefBlock     dw      0               ; offset of name of default block (if any)
secTimeOut      db      -1              ; # of seconds for timeout (-1 == indefinite)
secElapsed      db      0               ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
abBlockType     db  MAX_MULTI_CONFIG+1 dup(?)   ; array of block types
aoffBlockName   dw  MAX_MULTI_CONFIG+1 dup(?)   ; array of offsets of block names
aoffBlockDesc   dw  MAX_MULTI_CONFIG+1 dup(?)   ; array of offsets of block descriptions

szBoot          db      "CONFIG=",0
szMenu          db      "MENU",0
szCommon        db      "COMMON",0

endif  ;MULTI_CONFIG

comtab	label	byte

;            cmd len    command         cmd code
;            -------    -------         --------
;
ifdef MULTI_CONFIG
        db      1,      "[",            CONFIG_BEGIN
endif
        db      5,      "BREAK",        CONFIG_BREAK
        db      7,      "BUFFERS",      CONFIG_BUFFERS
        db      7,      "COMMENT",      CONFIG_COMMENT
        db      7,      "COUNTRY",      CONFIG_COUNTRY
        db      6,      "DEVICE",       CONFIG_DEVICE
        db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
        db      3,      "DOS",          CONFIG_DOS
        db      8,      "DRIVPARM",     CONFIG_DRIVPARM
        db      4,      "FCBS",         CONFIG_FCBS
        db      5,      "FILES",        CONFIG_FILES
ifdef MULTI_CONFIG
        db      7,      "INCLUDE",      CONFIG_INCLUDE
endif
        db      7,      "INSTALL",      CONFIG_INSTALL
        db      11,     "INSTALLHIGH",  CONFIG_INSTALLHIGH
        db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
ifdef MULTI_CONFIG
        db      7,      "SUBMENU",      CONFIG_SUBMENU
        db      9,      "MENUCOLOR",    CONFIG_MENUCOLOR
        db      11,     "MENUDEFAULT",  CONFIG_MENUDEFAULT
        db      8,      "MENUITEM",     CONFIG_MENUITEM
endif
        db      10,     "MULTITRACK",   CONFIG_MULTITRACK
ifdef MULTI_CONFIG
        db      7,      "NUMLOCK",      CONFIG_NUMLOCK
endif
        db      3,      "REM",          CONFIG_REM
ifdef MULTI_CONFIG
        db      3,      "SET",          CONFIG_SET
endif
        db      5,      "SHELL",        CONFIG_SHELL
if    STACKSW
        db      6,      "STACKS",       CONFIG_STACKS
endif
        db      8,      "SWITCHES",     CONFIG_SWITCHES
	db	0

ENDIF  ;CONFIGPROC

public deviceparameters
deviceparameters a_deviceparameters <0,dev_3inch720kb,0,80>

IFDEF	CONFIGPROC

hlim	    dw	    2
slim	    dw	    9

public drive
drive	db	?

public switches
switches    dw	0


; the following are the recommended bpbs for the media that we know of so
; far.

; 48 tpi diskettes

bpb48t	dw	512
	db	2
	dw	1
	db	2
	dw	112
	dw	2*9*40
	db	0fdh
	dw	2
	dw	9
	dw	2
	dd	0
        dd      0

; 96tpi diskettes

bpb96t	dw	512
	db	1
	dw	1
	db	2
	dw	224
	dw	2*15*80
	db	0f9h
	dw	7
	dw	15
	dw	2
	dd	0
        dd      0

; 3 1/2 inch diskette bpb

bpb35	dw	512
	db	2
	dw	1
	db	2
	dw	70h
	dw	2*9*80
	db	0f9h
	dw	3
	dw	9
	dw	2
	dd	0
        dd      0
      
bpb35h	dw	0200h
	db	01h
	dw	0001h
	db	02h
	dw	0e0h
	dw	0b40h
	db	0f0h
	dw	0009h
	dw	0012h
	dw	0002h
	dd	0
        dd      0

;
; m037 - BEGIN
;
bpb288	dw	0200h
	db	02h
	dw	0001h
	db	02h
	dw	240
	dw	2*36*80
	db	0f0h
	dw	0009h
	dw	36
	dw	0002h
	dd	0
        dd      0
;
; m037 - END
;
bpbtable    dw	    bpb48t		; 48tpi drives
	    dw	    bpb96t		; 96tpi drives
	    dw	    bpb35		; 3.5" drives
; the following are not supported, so default to 3.5" media layout
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - hard files
	    dw	    bpb35		; not used - tape drives
	    dw	    bpb35h		; 3-1/2" 1.44mb drive
	    dw	    bpb35		; ERIMO				m037
	    dw	    bpb288		; 2.88 MB diskette drives	m037

switchlist  db	8,"FHSTDICN"	     ; preserve the positions of n and c.

; the following depend on the positions of the various letters in switchlist

;switchnum	equ 11111000b		; which switches require number

flagec35	equ 00000100b		; electrically compatible 3.5 inch disk drive
flagdrive	equ 00001000b
flagcyln	equ 00010000b
flagseclim	equ 00100000b
flagheads	equ 01000000b
flagff		equ 10000000b
ENDIF ; CONFIGPROC
sysinitseg	ends
	end

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power21\powermsg.inc ===
IFDEF	DEBUG
rev_msg	db	"POWER Rev. 2 (11/14/91)",13,10,'$'
ENDIF

; error messages

bad_command_msg     db      "Invalid parameter",13,10,"$"
;
open_failed_msg     db      13,10,"Power Manager (POWER.EXE) not installed.",13,10,10,'$' ; M008
;
stats_failed_msg    db      "Error accessing power manager.",13,10,"$"


IFDEF	INCL_APM

;------------------------------------------------------------------------
; the following message will have one of OFFLINE /ONLINE
; as an insert between ACLine_Stat1 and ACLine_Stat2.
;	e.g.: "AC Line Status : OFFLINE "
;
ACLine_Stat1	db	13,10,"AC Line Status : ",'$'
ACLine_Stat2	db	13,10,'$'

AC_Offline_str	db	"OFFLINE",'$'
AC_Online_str	db	"ONLINE",'$'

;------------------------------------------------------------------------
; TRANSLATORS: NOTE:
; the following message will have one of battery_high/low/critical/charging
; as an insert between battery_status1 and battery_status2.
;	e.g.: "Battery status : Critical"
battery_status1	db	13,10,"Battery status : ",'$'
battery_status2	db	13,10,'$'

battery_high	db	"High",'$'
battery_low	db	"Low",'$'
battery_critical	db	"Critical",'$'
battery_charging	db	"Charging",'$'
;------------------------------------------------------------------------

;TRANSLATORS, NOTE:
; The next message is displayed together with a no between batter_life_str1
; and str2.
battery_life_str1	db	13,10,"Battery life (%) : "
battery_life_str2	db	13,10,'$'
;------------------------------------------------------------------------

ENDIF	; of INCL_APM

; other messages

;----------------------------------------------------------------------
;TRANSLATORS, NOTE:
; The next message is displayed together with a no between cpu_idle_msg1
; and msg2.
; e.g. "20% of CPU time idle"
cpu_idle_msg1   db      "$"
cpu_idle_msg2   db      "% of CPU time idle.",13,10,"$"
;----------------------------------------------------------------------
; TRANSLATORS: NOTE:
; One of the strings - on_msg,off_msg,noapp_msg - will be displayed
; between stat1_msg and stat2_msg.
; E.G.	CR,LF,"Power Manager : NOAPP",CR,LF

power_stat1_msg	db	13,10,"Power Manager : ",'$'
power_stat2_msg	db	13,10,'$'

; M089 BEGIN - UI changes
power_allon_msg	db	"ADV",'$'
power_off_msg	db	"OFF",'$'
power_noid_msg	db	"STD",'$'
;---------------------------------------------------------------------
help_text       db      "Reduces power used by your computer.",13,10,13,10
                db      "POWER [ADV | STD | OFF]",13,10				; M008
                db      "  ADV - Conserves power by monitoring applications"
		db	" and hardware devices.",13,10
		db	"  STD - Conserves power by monitoring hardware devices.",13,10
                db      "  OFF - Turns off power management.",13,10
; M089 END

IFDEF      DEBUG
                db      "  SOUND - toggle speaker during idle (debug version only).",13,10
ENDIF			; IFDEF DEBUG
                db      "$"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\setcds\curdir.inc ===
BREAK <Current directory list structure>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	CDS - Current Directory Structure
;
; CDS items are used bu the internal routines to store cluster numbers and
; network identifiers for each logical name.  The ID field is used dually,
; both as net ID and for a cluster number for local devices.  In the case
; of local devices, the cluster number will be -1 if there is a potential
; of the disk being changed or if the path must be recracked.
;
;	Some pathnames have special preambles, such as
;
;		\\machane\sharename\...
;	For these pathnames we can't allow ".." processing to back us
;	up into the special front part of the name.  The CURDIR_END field
;	holds the address of the seperator character which marks
;	the split between the special preamble and the regular
;	path list; ".." processing isn't allowed to back us up past
;	(i.e., before) CURDIR_END
;	For the root, it points at the leading /.  For net
;	assignments it points at the end (nul) of the initial assignment:
;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
;	  ^		 ^		     ^


DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

CURDIR_LIST	STRUC
CURDIR_TEXT	DB	DIRSTRLEN DUP (?)   ; text of assignment and curdir
CURDIR_FLAGS	DW	?		; various flags
CURDIR_DEVPTR	DD	?		; local pointer to DPB or net device
CURDIR_ID	DW	2 dup (?)	; cluster of current dir (net ID)
CURDIR_USER_WORD DW	?
CURDIR_END	DW	?		; index to ".." backup limit - see above
CURDIR_TYPE	DB	?		; IFS drive (2=ifs, 4=netuse)
CURDIR_IFS_HDR	DD	?		; Ptr to File System Header
CURDIR_FSDA	DB	2 DUP (?)	; File System Dependent Data Area
CURDIR_LIST	ENDS

curdirLen	EQU	Size CURDIR_list	; Needed for screwed up
						; ASM87 which doesn't allow
						; Size directive as a macro
						; argument
CURDIR_netID	EQU	DWORD PTR CURDIR_ID


;**	Flag values for CURDIR_FLAGS

CURDIR_isnet	EQU	1000000000000000B
CURDIR_isifs	EQU	1000000000000000B
CURDIR_inuse	EQU	0100000000000000B
CURDIR_splice	EQU	0010000000000000B
CURDIR_local	EQU	0001000000000000B

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power21\power.asm ===
PAGE    ,132
;**************************************************************
;*  POWER.SYS - MSDOS 5.0 IDLE DETECTION DEVICE DRIVER
;*
;*  Microsoft Confidential
;*  Copyright (C) Microsoft Corporation 1991
;*  All Rights Reserved.
;*
;*  Revision History
;*  90/7/19  [BR]       Completed beta DRIVER V0.30
;*  04/29/91 SR         Modified to make it ROMmable. Separated CODE,
;*                      DATA & INIT segments.
;*  06/03/91 MD         Merged standalone and resident versions,
;*                      support idle checking on INT 2F Idle
;*  07/01/91 JRCB       Changed STANDALONE to POWERALONE to remove confusion
;*                      with ROMDRIVE variable of same name.
;*  08/12/91  NSM       added APM support (M001)
;*
;*  08/21/91  NSM       M002: Removed the comment marks in Int14 hook
;                       (bug #    : printing slowed when POWER is present)
;                       Added a call to CPU_BUSY after resume
;
;   08/29/91  NSM       M003: removed rest of IOCTL support
;               
;   09/05/91  NSM       M004: Bug# 2587 
;                       Moved CheckV86 calls only for DOING HLT and not
;                       for OEM_IDLE or for APM_IDLE (2587)
;                       Also fixed the problem with multiple resumes.
;                       If we get a resume without a initial suspend notifi.
;                       then we ignore this resume command now.
;                       Bug#2574 Count CPU_IDLE time at Int 1c
;
;   09/08/91  DBO       M005: Straighten out far calls in BIOS-resident
;                       driver:
;                        Do_APM_Enable_Disable  -- make near
;                        Check_and_Init_APM     -- list in seg_reinit
;                        time_to_ticks          -- reference via ttticks 
;                                                  (already in seg_reinit)
;                        Do_APM_Connect         -- make near
;
;   09/11/91  NSM/DBO   M074: Replace clock driver functions, so we can manage
;                       manage system date & time updates after resume events.
;
;   09/11/91  SMR       M075: B#2670. Get Idle Algorithm was trashing IDLE_FLG
;
;   09/11/91  SMR       M076: B#2668. Statistics were not being copied if the
;                       user buffer is bigger than the required size.
;
;   09/11/91  SMR       M077: B#2669. Registered POWER's 2f channels in mult.inc
;
;   09/11/91  SMR       M078: Use HLT even if the processor is in V86 mode
;
;   09/11/91  SMR       M079: PWR_API returns 0 in AX instead of no carry flag
;                               in case of no error
;
;   09/11/91  DBO       M080: Power management clock hooks int 6C for
;                       resume events.
;
;   09/12/91  SMR       Call P_UpdFromCMOS directly if power is standalone
;
;   09/12/91  SMR       Load ES:DI before dispatching a CLOCK$ call.
;
;   09/17/91  NSM       M084: Don't zero out AX for version check int 2f call
;
;   09/19/91  SMR       M085: Return break address from clock driver init also
;
;   09/19/91  SMR       M086: Save/Restore SI in get/Set statistics calls
;
;   09/23/91  NSM       M087: Change signature to 504DH
;
;   09/25/91  NSM       M088: (B# 2730) Hang in GET_APM_STAT - missing "push si"
;
;   09/25/91  NSM       M089: I2F service routine changes related to UI change.
;                       (definition of POWER STD needed some extra code)
;
;   09/25/91  NSM       M090: CLOCK driver related changes to take care of
;                       WIN 3 ENH mode eating up I1Cs.  Soln. is to update our
;                       time from CMOS once in 1024 I1c ticks. Do this only 
;                       when win enh mode starts up and discontinue once win
;                       ends. (Bug# 2729)
;
;   09/25/91  NSM       M091: Also update our time from CMOS when POWER STD
;                       is selected on an APM machine. 
;
;   10/25/91  NSM       M093: CX reg is getting trashed while making suspend
;                       standby APM call in Int1C.
;                       While changing APM_MAX_POLLCOUNT, we should update
;                       the current APMPoll Counter also (APM_POLL_COUNT).
;
;   10/29/91  NSM       M094: AX and BL regs were getting trashed in some of
;                       the INT 2f service routines.
;
;   11/05/91  NSM       M096: Eat the rollover flag in Int 1C before command
;                       gets it.
;
;**************************************************************

	TITLE   POWER$ IDLE DETECTION V1.0

	.xlist

	include version.inc     ; M004 set build flags

break   macro                   ; satisfy mult.inc
	endm

	include mult.inc        ; get our int 2f function equates       ; M077

IFDEF   POWER

IFNDEF  POWERALONE              ; segment declarations for resident version

	include biosseg.inc     ; establish bios segment structure

ELSE                            ; segment declarations for standalonde version

.SEQ

Bios_Code       segment word public 'Bios_Code'
Bios_Code       ends

Bios_Data       segment word public 'Bios_Data'
Bios_Data       ends

SysInitSeg      segment word public 'system_init'
SysInitSeg      ends

Pdb_Data segment at 0h			; JAH Dummy segment for accessing the
	org 42h				; JAH active program's PSP
PDB_Idle	label	BYTE		; JAH
Pdb_Data ends				; JAH

; following segment definitions used by transient part of code

ENDIF

	include msequ.inc
	include devsym.inc
	include bpb.inc
	include ioctl.inc
	include power.inc

IFDEF INCL_APM
	include apmequ.inc              ; M001
ENDIF

break   macro
	endm

	include error.inc
	.list

	include msgroup.inc     ; define Bios_Data segment

IFDEF   POWERALONE                      ; standalone device driver version
Bios_Res        dw      Bios_Code       ; Our code segment address
ELSE                                    ; resident BIOS version
	extrn   Bios_Res:word           ; Code segment address supplied externally
	extrn   ttticks:dword           ; far ptr to time_to_ticks routine
	extrn   P_UpdFromCMOS_Ptr:dword ; ptr to CMOS clock read        ; M081
IFDEF   INCL_APM
	extrn   Check_and_Init_APM_Ptr:dword    ; ptr to APM init routine
ENDIF   ;INCL_APM
ENDIF   ;NOT POWERALONE

public  RHPTR, KYC, I28, CONTROL, INFO, MSW
public  IDLTIC, TOTTIC, SPDUP, SPDUP_DLY, SPDUP_CNT    ; M004
public  I2F_VEC, I28_TMR0, I28_VEC, KYC_TMR0, KYC_RET, IN_KYC 
public  I16_VEC, SWITCH_CNT, I1C_VEC, I9_COUNT, I9_VEC, I10_VEC, I13_VEC
public  I14_VEC, I17_VEC, I21_VEC,I25_VEC,I26_VEC,I2A_VEC

IFDEF INCL_APM                                  ; M001
public  fAPM_PRESENT,APM_FLAGS,APM_VER,APM_POLL_COUNT,fAPM_CONNECT
public  APM_MAX_POLLCOUNT,fAPM_STATE,APM_RESUME_COUNT
ENDIF

RHPTR   dd 0

; M003 : BEGIN ioctl support removed
; following is indirect entry point into power control module.
; Replacements for Power.exe can plug a different address into
; this space to redirect calls to the Power driver.
;
;EntryPoint      dw      pow_control, Bios_Code
; M003 END

dbg_printchar   macro dispchar
IFDEF   DEBUG
	push    ax
	mov     ah,0eh
	mov     al,dispchar
	int     10h
	pop     ax      
ENDIF
endm

POWER_DATA label byte
KYC     PERIOD_INFO     < 0, 20, 20, 0, 0, 0>   ; default values for base and
I28     PERIOD_INFO     < 0, 100, 20, 0, 0, 0>  ; noise are (random)conservative

CONTROL CONTROL_INFO    < 00101111b, 8*2, 58982, 4,  40, 0,  1,   8,    0>  
                                                                ; M078
;                       idle_flg, sw_dly,thres,ad_dl,mx,sp_dl,ramp,sp_mx,386flg
INFO    IDLE_INFO       < 0, 0, 0, 0, 0, 0, 0>

ErrSampleCount  dw      0

MSW     dw 0            ; store machine status word
			; bit 0 = 1 indicates protected mode

IDLTIC          dw 0    ; M004 used as a flag that says CPU was idle 
			; in the last (I1c) tick period

TOTTIC          dw 0    ; running total of halt time
			; in 1/1.19 MHZ increments 65536=55ms

SPDUP           dw 0    ; Activity indicator 1 active avoid halting
SPDUP_DLY       dw 0    ; MAX DELAY set by activity monitor
SPDUP_CNT       dw 0    ; incremented via INT 1C

PSPsegment		dw	(?)	; JAH - Dos DATA seg  used to	
				; access Current PSP

I2F_VEC dw I2F_IDLE, 0                  ; holds next pointer in chain

I2F_TMR0        dw   0          ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD
		dw   2          ;+2, Counts number of times PC
				;    timer has Overflowed

I2A_VEC dw I2A_IDLE, 0                  ; holds next pointer in chain

I28_TMR0        dw 0            ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD
		dw 2            ;+2, Counts number of times PC
				;    timer has Overflowed

I28_VEC dw I28_IDLE, 0

KYC_TMR0        dw 0            ;+0, holds temporary PC timer 0
				;    values used to compute PERIOD
		dw 2            ;+2, Counts number of times PC
				;    timer has Overflowed

KYC_RET dw 0,0                  ; stores 1 return address

IN_KYC  dw 0                    ; flags re-entry of key board check

I16_VEC dw I16_IDLE, 0          ; stores next key routine in chain

SWITCH_CNT      dw 0                    ; keeps track of when to
					; switch idle detect methods

I1C_VEC dw I1C_TIMR,0

I9_COUNT        dw 2                    ; for every key press more
					; a minimum of 2 INT 9's occur

I9_VEC          dw I9_APP,0

I10_VEC dw I10_APP,0

I13_VEC dw I13_APP,0

I14_VEC dw I14_APP,0

I17_VEC dw I17_APP,0

I21_VEC dw I21_APP,0

I25_VEC dw I25_APP,0

I26_VEC dw I26_APP,0

I6C_VEC dw I6C_RESUME, 0        ;M080

IFDEF   INCL_APM                                ; M001

fAPM_PRESENT    db      0
fAPM_CONNECT    db      0               ; set to 1 if connected
APM_MAX_POLLCOUNT       dw      50
APM_FLAGS       dw      0
APM_VER         dw      0
APM_POLL_COUNT  dw      50
				; counter for APM polling ; counted in int 1c
				; int. time.
fAPM_STATE      db      0       ; 0 if APM disabled and 1 if APM enabled

APM_RESUME_COUNT        dw      0       ; counter for no of resumes from last
				; APM enable

ENDIF                   ;INCL_APM

	PUBLIC  CMOSUpdFlg      ; M090
	PUBLIC  CMOSPollCount   ; M090

CMOSUpdFlg      db      0       ; M090 set to 1 if we need to update from CMOS
CMOSPollCount   dw      MAXCMOSPOLLCOUNT        ; M090
CMOSFlg         db      0       ; M091 bit 0 set to 1 in POWER STD mode on APM 
				; machines

BaseLineRef   dw      0		; counters for counting no of i16s we can get
				; through in about 4 secs  (done at each
				; exec)
BaseLineOvf	dw	0	;
				

IFDEF   POWERALONE              ; needed only for standalone version
	public  daycnt
daycnt  dw      0
	public  daycnt2
daycnt2 dw      0
	public  base_century
base_century    db      19
	public  base_year
base_year       db      80
	public  month_tab
month_tab       db      31,28,31,30,31,30,31,31,30,31,30,31

	public  bin_date_time
bin_date_time:
	db      0               ; year in century (0...99) or minutes (0-59)
	db      0               ; century (19 or 20) or hours (0-23)
	db      0               ; day in month (1...31)
	db      0               ; month in year (1...12) or seconds (0-59)

	public  month_table

month_table:
	dw      0               ; january
	dw      31              ; february
	dw      59              ; march
	dw      90              ; april
	dw      120             ; may
	dw      151             ; june
	dw      181             ; july
	dw      212             ; august
	dw      243             ; september
	dw      273             ; october
	dw      304             ; november
	dw      334             ; december

ELSE                            ; for resident version
	extrn   bin_date_time:byte
	extrn   month_table:word
	extrn   daycnt:word
	extrn   daycnt2:word

ENDIF                   ; POWERALONE

;-------------------------------------------------------------------
; 1 byte for each int 21 api from functions 0 thro 57h
; an entry of 0ffh means ignore this api for false idle monitoring
; 0 -> this api means we are  busy
; any other number -> special cases
i21_table	label	near
	db	0,   0,   0,   0,   0,   0,   5,   0	; fns 0-7
	db	0,   0,   0,0ffh,   0,   0,   0,   0	; fns 8-0f
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 10-17
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 18-1f
	db	0,   0,   0,   0,   0,0ffh,   0,   0	; fns 20-27
	db	0,   0,0ffh,   0,0ffh,   0,   0,   0	; fns 28-2f
	db	0,   0,   0,   0,   0,0ffh,   0,   0	; fns 30-37
	db	0,   0,   0,   0,   0,   0,   0,   0	; fns 38-3f
	db	0,   0,   0,   0,043h,   0,   0,   0	; fns 40-47
	db	0,   0,   0,04ah,   0,   0,   0,   0	; fns 48-4f
	db   0ffh,0ffh,   0,   0,   0,   0,   0,   0	; fns 50-57
	db	0,   0,   0,   0,   0,   0,   0,05eh	; fns 58-5f
MAX_I21_ENTRY	equ 5fh
;-------------------------------------------------------------------

POWER_STATUS    db      1       ; default ;bit 0 -  S/W pw.mgmt always enabled
				; bit 1 - Take control of APM/FIRMWARE  mgmt 
				; (or get connected to APM)
				; M001
				; M089 If bit1 is set, We are connected to APM
				; but not neccessarily enabled APM
				; (look at fAPM_State)
	
Pwr_i2f_next    dw      Pwr_i2f_lab
		dw      Bios_Data
Pwr_i2f_lab:
	pop     ds
	jmp     dword ptr cs:I2f_Vec

Pwr_i2a_next    dw      Pwr_i2a_lab
		dw      Bios_Data
Pwr_i2a_lab:
	pop     ds
	jmp     dword ptr cs:I2a_Vec

IFDEF  POWERALONE
Pwr_i28_next    dw      Pwr_i28_lab
		dw      Bios_Data
Pwr_i28_lab:
	pop     ds
	jmp     dword ptr cs:i28_Vec
ENDIF

Pwr_i16_next    dw      Pwr_i16_lab
		dw      Bios_Data
Pwr_i16_lab:
	pop     ds
	jmp     dword ptr cs:I16_Vec

Pwr_call_i16    dw      Pwr_calli16_lab
		dw      Bios_Data

Pwr_calli16_ret dw      Calli16ret
		dw      0

Pwr_calli16_lab:
	pop     ds
	pop     Kyc_Ret
	pop     Kyc_Ret+2

	call    dword ptr I16_Vec
	pushf
	push    Kyc_Ret+2               ; don't clear before
	push    Kyc_Ret         ; return values on stack

	push    ds
	jmp     dword ptr Pwr_calli16_ret

kb_call_i16	dw	kb_calli16_lab
		dw	Bios_Data
kb_calli16_ret	dw	kbChkRet
		dw	0

kb_calli16_lab:
	pushf
	call	dword ptr I16_Vec
	jmp	dword ptr kb_calli16_ret

Pwr_i1c_next    dw      Pwr_i1c_lab
		dw      Bios_Data
Pwr_i1c_lab:
	pop     ds
	jmp     dword ptr cs:I1c_Vec

Pwr_i9_next     dw      Pwr_i9_lab
		dw      Bios_Data
Pwr_i9_lab:
	pop     ds
	jmp     dword ptr cs:I9_Vec

Pwr_i10_next    dw      Pwr_i10_lab
		dw      Bios_Data
Pwr_i10_lab:
	pop     ds
	jmp     dword ptr cs:I10_Vec

Pwr_i13_next    dw      Pwr_i13_lab
		dw      Bios_Data
Pwr_i13_lab:
	pop     ds
	jmp     dword ptr cs:I13_Vec

Pwr_i14_next    dw      Pwr_i14_lab
		dw      Bios_Data
Pwr_i14_lab:
	pop     ds
	jmp     dword ptr cs:I14_Vec

Pwr_i17_next    dw      Pwr_i17_lab
		dw      Bios_Data
Pwr_i17_lab:
	pop     ds
	jmp     dword ptr cs:I17_Vec

Pwr_i21_next    dw      Pwr_i21_lab
		dw      Bios_Data
Pwr_i21_lab:
	pop     ds
	jmp     dword ptr cs:I21_Vec

Pwr_i25_next    dw      Pwr_i25_lab
		dw      Bios_Data
Pwr_i25_lab:
	pop     ds
	jmp     dword ptr cs:I25_Vec

Pwr_i26_next    dw      Pwr_i26_lab
		dw      Bios_Data
Pwr_i26_lab:
	pop     ds
	jmp     dword ptr cs:I26_Vec

Pwr_i6c_next    dw      Pwr_i6c_lab     ;M080
		dw      Bios_Data       ;M080
Pwr_i6c_lab:                            ;M080
	pop     ds                      ;M080
	jmp     dword ptr cs:I6c_Vec    ;M080

End_Data        label   near

	tocode                  ;Bios_Code segment starts

IFDEF   POWERALONE              ; device header needed here only for
				; standalone version - in MSBIO1 for resident
	assume  ds:nothing

	org 0
DEV_HDR dd CDEV_HDR             ; address of next driver in chain
	dw 8000H                ; character device      ; M003
	dw DEV_STRATEGY         ; DOS entry points to driver
	dw DEV_INTERRUPT        ;
	db 'POWER$  '           ; driver name

CDEV_HDR        dd      -1      ; address of next dev hdr in chain
	dw      8008h           ; CLOCK device (& character)
	dw      DEV_STRATEGY
	dw      CDEV_INTERRUPT
	db      'CLOCK$  '      ; driver name

;*************** DOS DEVICE REQUEST DEFINITIONS **************

; void DEV_STRATEGY( ES:BX.DOS_REQUEST_HEADER)
; purpose:   Store DOS REQUEST HEADER (ES:BX) for
;            DEV_INTERRUPT routine

DEV_STRATEGY proc far
	push    ds
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	mov     word ptr [RHPTR]+0,bx
	mov     word ptr [RHPTR]+2,es
	pop     ds
	assume  ds:nothing
	ret
DEV_STRATEGY endp

; void DEV_INTERRUPT( [REQHDR].DOS_REQUEST_HEADER)
; purpose:   Executes DOS request; only one fuction is  ; M003
;               supportted by this driver: INIT         ; M003

DEV_INTERRUPT proc far
	push    ax
	push    dx
	push    bx
	push    es
	push    ds

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	les     bx,[RHPTR]
	cmp     es:[bx].RH_B_CMD,DEVINIT        ; DEVICE INIT?
	jne     dstot0
	call    far ptr Power_Init
	jmp     short dstex0

; M003 : remove ioctl support
dstot0: 
;       cmp     es:[bx].RH_B_CMD,DEVRDIOCTL     ; DEVICE IOCTL READ?
;       jne     dstxxx
;       call    Power_IOCTL_Read
;       jmp     short dstex0
;
; M003: END

dstxxx: mov     ax,STERR+03H            ; RETURN DEVICE ERROR,
					; ILLEGAL COMMAND
dstex0: les     bx,[RHPTR]
	mov     es:[bx].RH_W_STATUS,ax
	pop     ds
	assume  ds:nothing
	pop     es
	pop     bx
	pop     dx
	pop     ax
	ret
DEV_INTERRUPT endp

Bios_Data_Word  dw      Bios_Data               ; Our data segment

	extrn   tim_read:near
	extrn   tim_writ:near

	extrn   P_UpdFromCMOS:far               ; M081

	public  tim_table

tim_table       label   byte
	db      (((offset tim_table_end) - (offset tim_table) -1)/2)
	dw      Normal_exit     ; 00    init
	dw      Normal_exit     ; 01
	dw      Normal_exit     ; 02
	dw      Cldev_cmderr    ; 03
	dw      tim_read        ; 04
	dw      Cldev_BusyErr   ; 05
	dw      Normal_exit     ; 06
	dw      Normal_exit     ; 07
	dw      tim_writ        ; 08
	dw      tim_writ        ; 09
tim_table_end:


CDEV_INTERRUPT  proc    far
	assume  cs:Bios_Code,ds:nothing
	push    si
	push    ax
	push    bx
	push    cx
	push    dx
	push    di
	push    ds
	push    es

	lea     si,tim_table

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	
	les     bx,[RHPTR]
	mov     al,es:[bx].RH_B_CMD             ; al = cmd
	cmp     al,cs:[si]
	jae     Cldev_cmd_error
	or      al,al                   ; is it init call
	jz      Cldev_Init

	cbw                             ; note that al <= 15 means ok
	shl     ax,1

	add     si,ax

	les     di, es:[bx].trans       ; M082
	cld                             ; ***** always clear direction
	call    cs:word ptr [si+1]      ;go do command
	assume  ds:nothing
	jc      Cldev_set_stat          ; if function returned status, don't
Cldev_Success:
	mov     ah,1                    ;  load with normal completion

Cldev_set_stat:
	mov     ds,Bios_Data_Word       ; cas///// note: shouldn't be needed!
	assume  ds:Bios_Data
	les     bx,[RHPTR]
	mov     word ptr es:[bx].status,ax ;mark operation complete

	pop     es
	pop     ds
	pop     di
	pop     dx
	pop     cx
	pop     bx
	pop     ax
	pop     si
	ret

Cldev_cmd_error:
	mov     ax,STERR+03H            ; RETURN DEVICE ERROR,
					; ILLEGAL COMMAND
	jmp     short Cldev_set_stat

Cldev_Init:
	call    far ptr Clock_Init

IFDEF   POWERALONE                      ; M085
	; Return DEVICE DRIVER end address
	les     bx,[RHPTR]
	mov     word ptr es:[bx].RH_D_BREAKPTR+0,offset Bios_Data:End_Data
	mov     word ptr es:[bx].RH_D_BREAKPTR+2,ds
ENDIF                                   ; M085
	jmp     short Cldev_Success

CDEV_INTERRUPT  endp

Cldev_cmderr    proc    near
	mov     al,3            ; unknown command error
	mov     ah,81h          ; error return
Cldev_Ret:
	stc                     ; indicate abnormal end
	ret

Cldev_BusyErr   label   near
	mov     ah,3            ; indicate busy status
	jmp     short Cldev_Ret

Cldev_cmderr    endp

ELSE                                            ; resident driver version

	extrn   Bios_Data_Word:word             ; supplied externally

	public  power_table
power_table:
	db      (((offset power_table_end) - (offset power_table) - 1) / 2)
	dw      Normal_exit
	dw      Normal_exit
	dw      Normal_exit
; M003 : BEGIN ; remove ioctl support
;       dw      Power_ioctl_read
	dw      Normal_exit
; M003 : END

power_table_end:


ENDIF                                           ; resident driver version

Normal_exit      proc    near

	clc
	ret

Normal_exit      endp
;
; M003: BEGIN ; remove ioctl support
;

IF 0

Power_ioctl_read proc near
	assume  ds:Bios_Data
	push    es
	push    di
	cmp     es:[bx].RH_W_XFERCNT,32 ; get transfer size
	je      dirot0

	mov     es:[bx].RH_W_XFERCNT,0  ; invalid size non-transfered
	jmp     short dirxxx

dirot0: les     di,es:[bx].RH_D_XFERPTR ; address of read block
	mov     word ptr es:[di].PIB_ENTRY_OFFSET,offset EntryPoint 
	mov     word ptr es:[di].PIB_ENTRY_SEG,ds
	mov     byte ptr es:[di].PIB_VERSION,POW_VERSION

dirxxx: pop     di
	pop     es

	clc
	ret

power_ioctl_read endp


PUBLIC  Pow_control
Pow_control proc far
	assume  ds:nothing, es:nothing
; M001 - NSM all these functions except IDLE_INFO have been replaced
; by equivalent INT 2f functions 
	cmp     ah,POW_GET_CONTROL_INFO        ; return CONTROL_INFO pointer
	jnz     pclot0
	mov     dx,cs:Bios_Data_Word
	mov     ax,offset CONTROL
	mov     cx,size CONTROL_INFO
	jmp     short pclex0

pclot0: cmp     ah,POW_GET_STATS               ; return IDLE_INFO pointer
	jne     pclot1
	mov     dx,cs:Bios_Data_Word
	mov     ax,offset INFO
	mov     cx,size IDLE_INFO
	jmp     short pclex0


pclot1: cmp     ah,POW_DO_IDLE                 ; return call DO_IDLE direct
	jne     pclot2

	push    ds
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data

	call    CheckV86        ; AVOID IN V86
	pop     ds
	assume  ds:nothing
	jnz     pclex0
	push    ds
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	call    DO_IDLE         ; return CY set if idle
	pop     ds
	assume  ds:nothing
	jmp     short pclxxx

; M001 -nsm - commented out
pclot2: cmp     ah,0feh         ; Return POWER_DATA
	jne     pclerr          ; address ES:BX
	mov     es,cs:Bios_Data_Word       ; special function for cstat
	mov     bx,offset POWER_DATA

pclex0: clc                     ; return no error
	ret

pclot2:                         ; falls through to error
pclerr: mov     ax,-1           ; INVALID OPERATION
	stc

pclxxx: ret


Pow_control endp

ENDIF   ; the code above is commented out - M003 END

;******************** INT 2F routine for POWER services *************
;  Entry: AL = function code
;       0       Install check
;       
;               EXIT:
;               BX = 504dH (PM) signature if installed  /* M087 */
;
;       1       GET/(Enable/Disable) Power management
;               BH = 0  -> get POWER enabled status
;                  = 1 -> ENABLE DISABLE POWER
;                  BL:bit 0 =T enable Idle detection
;                           =F disable Idle detection
;                  BL:bit 1 =T enable FW/APM 
;                           =F disable FW/APM
;               EXIT:
;                  BH = Prev. Power status (bit 0 & 1 as defined above)
;                  BL = Current power status
;                  CY set if function failed
;
;       2       Get/Set Idle Detection Alg
;               BH = 0 -> Get Current idle detection alg.       
;                  = 1 -> set Current alg.
;                    BL:bit 0 -> T - AUTO SELECT
;                       bit 1 -> T - App Idle (int 2f 1680)
;                       bit 2 -> T - Dos Yield (int 28)
;                       bit 3 -> T - Keyboard idle (int 16)
;                    BL = 0 -> disable Idle detecion
;               EXIT:
;                       BL = current alg if Get_ALG
;
;       80      Get/Set Idle Detection Tuning parameters
;               BX = 0 -> get 
;               else Set
;               CX = size of buffer 
;               DS:SI -> ptr to buffer
;       81      Get Statistics
;               CX = size of buffer
;               DS:SI -> ptr to buffer
;
;       82      Get/Set APM polling count
;               BX = 0 -> get APM polling count
;               else new polling count to be set
;               EXIT:
;                       BL = new polling count
;
; M001: Created - NSM
;
Pwr_Services    proc    near

	push    ds

	cmp     al,I2F_PW_INSTALL_CHK           ; install check
	je      PS_Install_Chk
;
	cmp     al,I2F_PW_GET_SET_PWSTATE       ; enable/disable PW MGMT
	jne     PS_Chk_SelAlg
	jmp     PS_GetSet_PWState
;
PS_Chk_SelAlg:
	cmp     al,I2F_PW_SELECT_ALG            ; select Idle Detection Alg
	je      PS_Select_Alg
;
	cmp     al,I2f_PW_TUNE_PARM             ; Idle detect. parm. Get/Set
	je      PS_Parm_Tune
;
	cmp     al,I2F_PW_APM_POLLCOUNT         ; Get/Set APM poll count
	je      PS_APM_PollCount
;
	cmp	al,I2F_PW_GETSET_BASELINE
	jne	PS_ChkGetStat
	jmp	PS_GetSet_BaseLine
;
PS_ChkGetStat:
	cmp     al,I2F_PW_GET_STATS             ; Get Idle Detect stats
	je      PS_Get_Stats
;
	mov     ax,ERROR_PM_FUNCTION_NOT_SUPPORTED
PS_FRet:
	stc
	jmp     PS_Ret


PS_Install_Chk:
	mov     bx,504dH                ; "PM"  ;M087
	mov     ah,POW_MAJ_VERSION      ; M084 major version no
	mov     al,POW_MIN_VERSION      ; M084
	clc                             ; M084
	jmp     PS_Ret                  ; M084

;
PS_Select_Alg:
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data

IFDEF DEBUG
	cmp     bl,80h          ; SOUND toggle
	je      PS_Toggle_Sound
ENDIF
	or      bh,bh           ; get current algorithm
	je      PS_Get_Alg
	test    bl,ALG_RESERVED_BITS
	jnz     PS_Inv_Parm_Err
;
PS_Alg_OK:
	xor     bh,bh
	shl     bx,1                    ; rotate the given alg.bits to the IDLE_FLG format
	shl     bx,1
	and     [CONTROL].IDLE_FLG,NOT ( AUTO_ACTIVE+APP_ACTIVE+DOS_ACTIVE+KYC_ACTIVE)
	or      [CONTROL].IDLE_FLG,bx

; M094 - Fall through to return the current algorithm in BL

PS_Get_Alg:
	mov     bx,[CONTROL].IDLE_FLG   
	and     bx,( AUTO_ACTIVE+APP_ACTIVE+DOS_ACTIVE+KYC_ACTIVE)      ; M075
	shr     bx,1                    ; put this info into the desired 
	shr     bx,1                    ; API output format
	jmp     short PS_SRet

IFDEF DEBUG                     ;Toggle sound only for DEBUG VERSION
PS_Toggle_Sound:
	xor     [CONTROL].IDLE_FLG,SOUND_ACTIVE ; toggle the sound flag
	jmp     short PS_SRet
ENDIF

PS_APM_PollCount:                               ; 7 change APM poll count
	call    Do_APM_GetSet_PollCount
	jmp     short PS_SRet 

	assume  ds:nothing
;
PS_Parm_Tune:                           ; 4 Tune various POWER.SYS parameters
	cmp     cx, size CONTROL_INFO - SWITCH_DLY
	jb      PS_Buff_Ovf_Err
	push    si                      ; M086
	push    di
	push    es
	mov     es,Bios_Data_Word
	assume  es:Bios_Data
	lea     di,[CONTROL].SWITCH_DLY
	assume  es:nothing
	or      bx,bx                   ; get parm or set parm ?
	jnz     PS_DoCopy               ; if set parm 
	mov     bx,-1
PS_Exch_ESDS_SIDI:
	push    es
	push    ds
	pop     es
	pop     ds
	xchg    si,di
	or              bx,bx
	jz      PS_EndCopy
PS_DoCopy:
	rep     movsb                   ; transfer data
	inc     bx
	jz      PS_Exch_ESDS_SIDI
PS_EndCopy:
	pop     es
	pop     di
	pop     si                      ; M086
	jmp     short PS_SRet

PS_Get_Stats:

IFDEF INCL_APM
	cmp     bx,PW_GET_APM_STATS     ;                               ; M076
	ja      PS_Inv_Parm_Err         ; invalid info level ?
	je      PS_Get_APM_Stats        ; APM statistics (resume count ) ?
ELSE
	or      bx,bx                   ; only Idle detection stats will be
	jnz     PS_Inv_Parm_Err         ; returned
ENDIF
	cmp     cx,size IDLE_INFO       ; No, Idle detection statistics
	jb      PS_Buff_Ovf_Err         ; Buffer not sufficient         ; M076
	push    si                      ; M086
	push    di
	lea             di,     INFO
PS_Transf_Stats:
	push    es
	mov     es,Bios_Data_Word
	assume  es:Bios_Data
	assume  es:nothing
	mov     bx,-1                   ; get stats ; there is no set stats
	jmp     short PS_Exch_ESDS_SIDI

IFDEF   INCL_APM

PS_Get_APM_Stats:
	cmp     cx, APM_STATS_STRUC_SIZE
	jb      PS_Buff_Ovf_Err         ; Buffer not sufficient         ; M076
	push    si                      ; M088
	push    di
	lea     di,APM_RESUME_COUNT
	jmp     short PS_Transf_Stats

ENDIF   ; of IFDEF INCL_APM

PS_Inv_Parm_Err:
	mov     ax,ERROR_PM_INVALID_PARAMETER
	stc
	jmp     short PS_Ret

PS_SRet: xor    ax,ax                   ; M084 : Clear CY and  put
					; 0 in AX to mean no error
PS_Ret:
	pop     ds
	ret


PS_Buff_Ovf_Err:
	mov     ax,ERROR_PM_BUFFER_TOO_SMALL
	jmp     PS_FRet

PS_GetSet_PWState:
	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	or      bh,bh           ; get power state ?
	call    GetPowStatus    ; M089 : old state in AL
	mov     bh,al           ; get old status
	mov     ax,0            ; M084 : Assume no error 
	jz      PS_APM_Ret      ; M084 
	test    bl,PWSTATE_RESERVED_BITS
	jnz     PS_Inv_Parm_Err
	push    bx              ; save old status on stack
; set power status
	test    bl,1            ; check for POWER.SYS/EXE enable
	jnz     PS_Enable_Power
; disable POWER.SYS
	test    POWER_STATUS,1
	jz      PS_Test_APM_Bit         ; already disabled
;
	and     [CONTROL].IDLE_FLG,NOT(IDLE_ACTIVE)     ; turn of idle detection
	and     POWER_STATUS,NOT(1)     ; turn off S/W PM
	jmp     short PS_Test_APM_Bit
PS_Enable_Power:
	test    POWER_STATUS,1
	jnz     PS_Test_APM_Bit         ; already enabled
	or      [CONTROL].IDLE_FLG,IDLE_ACTIVE  ; turn on idle detection
	or      POWER_STATUS,1          ; turn on S/W PM
;
PS_Test_APM_Bit:
;
IFDEF   INCL_APM
	call    Do_APM_Control
ENDIF
;
	pop     bx                      ; get back old status
;
; M084: NSM
; At this point :
; CY set if error 
;       AX = error code
; NC -> AX = 0
;
PS_APM_Ret:
	push    ax                      ; M089  BEGIN
	call    GetPowStatus            ; status in al
	mov     bl,al                   ; return with current status
	pop     ax                      ; M089  END
	jmp     PS_Ret

PS_GetSet_BaseLine:
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data
	or	bx,bx			; get base line ?
	je	PS_GetBaseLine
	mov	[BaseLineRef],bx
	mov	[KYC].BASE,bx
;
PS_GetBaseLine:
	mov	bx,[BaseLineRef]
	mov	cx,[BaseLineOvf]
	jmp	PS_SRet

Pwr_Services    endp

;****************************** GetPowStatus **********
; Get the current power status
; Entry: none
; Exit:  AL:Bit 0 - 1 if S/W PowMgmt enabled
;           Bit 1 - 1 if H/W PowMgmt enabled
; Regs: AX
; M089: Created
;******************************************************************
GetPowStatus    proc    near
	pushf
	mov     al,POWER_STATUS
	test    al,2            ; test for H/W enabled state
	jnz     GPS_Ret
; H/W not connected state; let us see if it is atleast enabled from what
; we know of before last disconnect.
IFDEF   INCL_APM
	test    fAPM_STATE,1            
	jz      @f
	or      al,2            ; H/W pow.mgmt enabled - POWER STD mode
@f:
ENDIF                   ; IFDEF INCL_APM
GPS_Ret:
	popf
	ret
GetPowStatus    endp

IFDEF   INCL_APM
;****************************** Do_APM_GetSet_PollCount **********
; INT 2F subfunction service procedure 
; To get/set the APM pollcount
; Entry: BX = 0 -> get APM poll count
;               otherwise, New poll count to be set
; Exit:  BX = new APM Poll count
; Regs: BX,DS,Flags
;******************************************************************
Do_APM_GetSet_PollCount Proc    NEAR

	mov     ds,cs:Bios_Data_Word
	assume  ds:Bios_Data
	or      bx,bx
	jz      DAPC_Get_PollCount
	mov     [APM_MAX_POLLCOUNT],bx
	mov     [APM_POLL_COUNT],bx             ; M093
	jmp     short DAPC_Ret 
DAPC_Get_PollCount:
	mov     bx,APM_MAX_POLLCOUNT
DAPC_Ret:
	ret

Do_APM_GetSet_PollCount endp

;****************************** Do_APM_Control *********************
; INT 2F subfunction service procedure 
; To (enable-connect to)/(disable-disconnect from) APM
; Entry:  BL = 3 -> connect and enable APM              ; M089
;         BL = 2 -> stay disconnected but enable it if needed
;         BL = 1 or 0 -> disconnect and disable
;
; Exit:  CY if operation failed
;               ax = error code
;        ELSE AX = 0
;
;       (POWER_STATUS flags updated properly
;        fAPM_STATE also updated)
;       APM_RESUME_COUNT initialised to zero if enable successful
;
; Regs: ax,bx,cx,dx
;******************************************************************

Do_APM_Control  proc    near

	cmp     bl,2            ; check for F/w PM bit enable
	jae     DACt_Enable_APM

; M089 BEGIN
; With the new definition of POWER STD, we need to enable APM but not
; connected to it (and sometime disable APM but we would not have been
; connected to it for doing it). Enable/disable can only be done if we
; are connected to APM and so We first connect to APM to enable/disable
; APM and depending on the requested state, we disconnect from APM
;
; Disconnect and disable APM
	and     [CMOSFlg],NOT(1)        ; M091 reset STD mode+APM bit in CMOSFlg
	test    POWER_STATUS,2          ; are we  connected already ?
	jnz     DACt_Dis_con_able       ; yes, just disable and disconnect
; we are not connected ; so go connect to it first, enable it
; and then disable it!

IFDEF POWERALONE
	call    far ptr Check_and_Init_APM ; M003: always check for APM presence
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF
; M089 END
DACt_Dis_con_able:
	test    fAPM_PRESENT,1          ; M003:no need to do anything if APM not
	jz      DACt_End                ; M003:present
; disable APM
	mov     cx,APM_DISABLE_FUNC
	call    Do_APM_Enable_Disable   ; disable APM ;M005
	jc      DACt_End
	mov     fAPM_STATE,0            ; flag APM disabled state
	call    Do_APM_DisConnect
	and     POWER_STATUS,NOT (2)            
	jmp     short DACt_End
DACt_Enable_APM:
	push    bx                      ; save the desired state (input)

;M089 BEGIN
	test    POWER_STATUS,2
	jz      DACt_Connect            ; Go connect and enable
	test    fAPM_STATE,1            ; are we also enabled ?
	jnz     DACt_ChkForDiscon       ; yes, go see if we have to disconnect
	mov     cx,APM_ENABLE_FUNC
	call    Do_APM_Enable_Disable   ; enable APM 
	mov     fAPM_STATE,1            ; flag APM enabled state

DACt_Connect:
;M005 BEGIN - for resident driver call Check_and_Init_APM through pointer

IFDEF POWERALONE
	call    far ptr Check_and_Init_APM ; M003: always check for APM presence
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF ; POWERALONE

;M005 END

	jnc     DACt_ChkForDiscon       ;  before connecting to it
	jz      DACt_APM_ConnErr        ; ignore if APM not present
	clc

DACt_ChkForDiscon:
	pop     bx                      ; get back requested APM state
	and     [CMOSFlg],NOT(1)        ; assume not stdmode+apm
	cmp     bl,3                    ; both S/W and F/W pwmgmt ON ?
	je      DACt_End                ; Yes, all done

; User requested APM be ON but we should stay disconnected

	call    Do_APM_DisConnect
	and     POWER_STATUS,NOT (2)            
	test    fAPM_PRESENT,1          ; M091
	jz      DACt_End                ; M091
	or      [CMOSFlg],1             ; M091 set POWER_STDMODE+APM
	mov     [CMOSPollCount],MAXCMOSPOLLCOUNT ; M091
; M089 END

DACt_End: xor   ax,ax                   ; M094  - ax=0 -> no error
DACt_Ret:
	ret

DACt_APM_ConnErr:
	pop     bx
	mov     ax,ERROR_PM_ALREADY_CONNECTED   ; put valid error code here
	stc
	jmp     short DACt_Ret

Do_APM_Control  endp

ENDIF
;********************** TIMER TIC READ ROUTINE *******************

; ax = READ_TMR0( void)
; purpose: to return tic stored in timer0
;
; M0FF:
; OEMs NOTE:
; This procedure should always return a count between 64k and 1
; This code assumes an 8254 timer chip and also assumes that 64k is the
; max count and counted DOWN.
; DOS usually uses mode 3 in both 8253/54. ( mode 2 counts the MAXCOUNT
; just once whereas mode counts it twice in a tic period). But in 8254,
; we can get half cycle we are in, in mode 3 whereas we can't get that
; info in 8253.   
; OEMS, if they don't have an 8254, need to modify this code to always
; return a count as if we are operating in mode 2 (down counter).

PUBLIC Read_tmr0
Read_tmr0 proc near
	assume  ds:nothing, es:nothing

IFDEF 8253
	cli
	mov     al,0
	out     43h,al
	jmp     $+2
	in      al,40h
	jmp     $+2
	mov     ah,al
	in      al,40h
	sti
	xchg    ah,al
	ret
ELSE				; 8254 assumed so that we will know the mode
	push    bx
	mov     al,0c2h         ; read mode as well as count of tmr0
	cli
	out     43h,al
	jmp     $+2

	in      al,40h		; status byte
				; bit 7 -> first half cycle
				; bit 1-3 -> mode 
	mov     bl,al		; save status in bl&bh
	mov     bh,al
	jmp	$+2

	in      al,40h		; low byte of count
	jmp     $+2
	mov     ah,al

	in      al,40h		; high byte of count
	sti
	xchg    ah,al		; ax = current tmr count

	and     bl,0eh          ; mask everything but mode bits 
	cmp     bl,6            ; mode 3 ?
	jne     rt_ret		; if mode 2 no need for adjustments
	shr     ax,1            ; halve for mode 3 cycle 1
	test    bh,80h          ; is this cycle 2 ?
	jz      rt_ret		; yes, the count is already correct 
	add     ax,8000h        ; first cycle, so add 32k to the count
rt_ret:
	pop     bx
	ret
ENDIF

Read_tmr0 endp

IFDEF DEBUG                         ; only use this code on test version

START_SOUND proc

	mov     al,0
	out     42h,al
	jmp     $+2
	mov     al,50h
	out     42h,al

	mov     al,3
	in      al,61h
	jmp     $+2
	or      al,3
	out     61h,al
	ret

START_SOUND endp

END_SOUND proc
	in      al,61h
	jmp     $+2
	and     al,not 3
	out     61h,al
	ret
END_SOUND endp

ENDIF                                   ; IFDEF DEBUG


; Z.flag CheckV86()
; return - NZ, if 386 V86 or protected  mode


PUBLIC CheckV86
CheckV86 proc near
	assume  ds:Bios_Data, es:nothing

	test    [CONTROL].CV86FLG,1     ; Avoid  test
	jz      cv8ret                  ; if bit cleared

	test    [CONTROL].CV86FLG,2             ; is it a 386?
	jz      cv8all                  ; don't know yet ...
cv8386:
	.386p
	smsw    [MSW]

	.8086
	test    [MSW],1                 ; check for protected mode
	ret                             ; NZ, yes

cv8all: push    ax                      ; run through all proccesors

	push    sp                      ; below 286?
	pop     ax
	cmp     sp,ax
	jne     cv8ex0                  ; yes, disable check

	pushf                           ; check TS
	pop     ax                      ; should be zero for 286
	or      ax,4000h                ; try setting TS high
	push    ax
	popf
	pushf
	pop     ax                      ; restore TS

	test    ax,4000h                ; did it remain 0?
	jz      cv8ex0                  ; yes, 286

	pop     ax
	or      [CONTROL].CV86FLG,2     ; Set 386 bit to save time
	jmp     short cv8386

cv8ex0: xor     ax,ax                   ; We don't have to test again
	mov     [CONTROL].CV86FLG,ax    ; return ZF
	pop     ax

cv8ret: ret
CheckV86 endp

;***************** DO_IDLE OEM EXTENDABLE ****************

PUBLIC Do_idle_dos
Do_idle_dos proc far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data
	call    DO_IDLE
	pop     ds
	assume  ds:nothing
	ret

Do_idle_dos endp

; CY.flag DO_IDLE()
; purpose: To put CPU in a low power state via a halt or
;          OEM supplied OEM_IDLE routine.
; passed:  control.IDLE_FLG - enables/disables DO_IDLE
; return:  Carry Set, if IDLE was executed

PUBLIC Do_idle
Do_idle proc near
	assume  ds:Bios_Data, es:nothing

; JAH Start - If app supports IDLE only idle on int 2f idle entry point below
	push	ds
	mov	ds,PSPsegment		; DS:BX --> Current PSP in Dosdata
	mov	ds,WORD PTR ds:[CUR_PSP_OFFSET]	; DS -> current app's PSP
	assume	ds:Pdb_Data
	cmp	PDB_Idle,IDLE_SUPPORT_BYTE ; Check app's idle support byte
	pop	ds
	assume	ds:Bios_Data

	je	didex1			; Idle aware app so don't idle

	PUBLIC I2fIdleEntry
I2fIdleEntry:				; Entry point from int 2fh handler
; JAH End

	test    [CONTROL].IDLE_FLG,IDLE_ACTIVE
	jnz     didbgn
didex1: clc                             ; idle failed  to execute
	ret

didbgn: push    ax

	; if activity has been detected DO_IDLE will be avoided
	; for a period measured in timer interrupts

	cmp     [SPDUP],0               ; is system speed up?
	je      did1ot

	mov     ax,[SPDUP_DLY]          ; check if enough time
did3ot: cmp     [SPDUP_CNT],ax          ; has passed to return
	jae     did2ot                  ; to normal idle

didxxx: pop     ax
	jmp     short didex1

did2ot: mov     [SPDUP],0
	mov     [SPDUP_DLY],0

did1ot: in      al,21h                  ; get interrupt mask
	test    al,3h                   ; make sure timer and
	jnz     didxxx                  ; keyboard aren't masked 

	add     word ptr [INFO].IDLE_TOT,1
	adc     word ptr [INFO].IDLE_TOT+2,0


IFDEF DEBUG

	test    [CONTROL].IDLE_FLG,SOUND_ACTIVE
	jz      did0ot

	call    START_SOUND

ENDIF                                   ; IFDEF DEBUG

did0ot: test    [CONTROL].IDLE_FLG,MEASURE_ACTIVE
	jz      didhlt
	mov     [IDLTIC],1              ; set IDLE flag ; M004

didhlt:

IFDEF INCL_APM
	cmp     fAPM_STATE,0            ; is APM present and enabled ?
	je      didNoAPM
	call    Do_APM_Idle
	jmp     short didResume
didNoAPM:
ENDIF   ; for IFDEF INCL_APM

IFDEF OEM_EXTENSION
	call    OEM_IDLE
ELSE
	call    CheckV86                ; M004 AVOID HLT IN V86
	jnz     didNoHlt
	sti                             ; interrupts must be enabled
	hlt                             ; or system will halt ...
didNoHlt:
ENDIF

didResume:

didot2: 
IFDEF DEBUG        
	test    [CONTROL].IDLE_FLG,SOUND_ACTIVE
	jz      didex0

	call    END_SOUND
ENDIF                                    ; IFDEF DEBUG

didex0: pop     ax
	stc                             ; CY.set halt executed
	ret
DO_IDLE endp

;********************* APM functions ***********************************

IFDEF INCL_APM

;********************* APM IDLE routine ********************************
; Called by Do_Idle procedure when APM BIOS is present
; 
; Psuedocode:
;       call APM_IDLE API
;       if (clock changes for CPU_IDLE API) {
;               call CPU_BUSY API
;       }
;
; Entry: nothing
; exit: nothing
;
;***********************************************************************
; Do_APM_CPUBUSY        Entry Point             (M002 addition)
;       Calls APM CPUBUSY API to return CPU to full speed after a resume
;               or a CPU_IDLE
; Entry: none
; Exit: none
;***********************************************************************
 
Do_APM_Idle     Proc    near

	push    bx
	mov     ax,APM_CPUIDLE_FUNC
	int     15h             ; make CPU_IDLE API call
	pop     bx
;
Do_APM_CPUBUSY  label   near            ; M002; added this entry point
;
; Check if we need to make a CPU_BUSY call 
	test    APM_FLAGS,APM_SLOW_CLOCK        ; does CPU_IDLE slows clock ?
	jz      dai_End

; need to make CPU_BUSY call
	push    bx
	mov     ax,APM_CPUBUSY_FUNC
	int     15h             ; make CPU_BUSY call to speedup CPU
	pop     bx
dai_End:
	ret

Do_APM_Idle     endp

;********************* Do_APM_Connect **********************************
; Purpose: to connect to APM BIOS as the coop.process (real mode only)
; Entry: none
; exit: CY      - connect failed
;               ax = error code
;       NC      - connection succeeded
;***********************************************************************

Do_APM_Connect  proc    near            ;M005

	test    fAPM_PRESENT,1          ; Do this only if APM is present
	jz      DAC_End
	mov     ax,APM_CONNECT_FUNC
	mov     bx,APM_SYSTEM_BIOS
	int     15h
	jc      DAC_End
	mov     fAPM_CONNECT,1
DAC_End:
	ret
Do_APM_Connect  endp

;********************* Do_APM_Disconnect **********************************
; Purpose: to disconnect from APM BIOS 
; Entry: none
; exit: CY      - Disconnect failed (can this ever happen ?)
;               ax = error code
;       NC      - disconnect succeeded
;***********************************************************************

Do_APM_Disconnect       proc    near

	test    fAPM_CONNECT,1          ; disconnect only if WE are 
	jz      DAD_End                 ; connected     
	mov     ax,APM_DISCONNECT_FUNC
	mov     bx,APM_SYSTEM_BIOS
	int     15h
	jc      DAD_End
	mov     fAPM_CONNECT,0
DAD_End:
	ret
Do_APM_Disconnect       endp
;********************* Do_APM_Enable_Disable **********************************
; Purpose: to enable/disable all power management 
;
; Entry: CX = APM_DO_DISABLE -> disable all power management
;           = APM_DO_ENABLE  -> enable all power management
;
; exit: CY      - function unsuccessful
;               ax = error code
;       NC      - function succeeded
;***********************************************************************


Do_APM_Enable_Disable   proc    near    ;M005

	mov     ax,APM_ENABLE_DISABLE_FUNC
	mov     bx,APM_ALL_DEVICES
	int     15h
	jnc     DAED_Ret
	mov     ax,ERROR_PM_NOT_CONNECTED
DAED_Ret:
	ret

Do_APM_Enable_Disable   endp


ENDIF           ; for IFDEF INCL_APM 

;********************* General Idle Check Routine **********************
; purpose: called by INT 28 and 16 interrupt handlers
;       This is the common routine which checks elapsed time between
;       interrupts in order to adjust idle signaling.
;
;       Entry : SI = base address of PERIOD_INFO structure for this interrupt
;               DI = address of total delay accumulator for this interrupt
;               BX = address of time accumulator for this interrupt
;               DS = our data segment
;       Exit  : nothing
;       must preserve all registers


public Chk_Delay
Chk_Delay       proc
	assume  ds:Bios_Data, es:nothing
	xor	cx,cx

; entry point for i16 idle checking
; for i16: cx = 1

Chk_i16idle	label	near
;
	push    ax
	cmp     word ptr [bx]+2,1      ; waited too long?
	jb	cd_readtime
	jmp	cd_ClrTmr              ; yes, do a recount

cd_readtime:
	call    READ_TMR0               ; read return time
	neg     ax
	cmp     word ptr [bx]+2,1
	jb      cd_0

	add     ax,0ffffh               ; OVERFLOW=-AX + 65535
	add     [bx],ax                 ; TICS=TICS + OVERFLOW
	jnc	cd_1
	jmp     cd_ClrTmr        	; Go recount on overflow

cd_0:
	add     [bx],ax                 ; TICS=TICS + -ax

cd_1: 	mov     ax,[si].BASE            ; is TIC >= BASE+THRESHOLD?
	add     ax,[CONTROL].THRESHOLD
	jnc     cd_2
	mov     ax,0FFFFh

cd_2:
	cmp     [bx],ax
	jae     cd_go_recount           ; yes, ignore reading   

	cmp     word ptr [si].ADAPT,0   ; are we in adapt cycle ?
	jne     cd_3			; yes go do avg.

; we are in idle cycle. check to see if we are within allowed limites for
; idle
	mov     ax,[si].BASE            ; is TIC <= BASE+NOISE?
	add     ax,[si].NOISE
	cmp     [bx],ax
	jbe     cd_doidle                 ; yes, stay in halt state

; we are above the allowed idle limits; go for adapt cycles

cd_adapt:
	mov     word ptr [si].ADAPT,1   ; start measuring increase
	mov     word ptr [si].DELAY,0

cd_go_recount:
	jmp     short cd_transf_period

; adapt cycle processing
; try calculating avg.
; [bx] = current period
; [si].PERIOD = avg so far
; if the current period is not within 50% of prev. avg we check to see if
; we can ignore this period for avg and go for next one. If we have seen 
; a no of such high(or low) values in the cycle so far, then start adapt
; cycle all over again

cd_3:
	mov     ax,[CONTROL].ADAPT_DLY
	cmp     [si].DELAY,ax           ; is delay over?
	jae	cd_end_adapt		; yes, go cmp our avg with baselineref
	mov	ax,[si].PERIOD
	shr	ax,1			; ax = 1/2 of avg
	shr	ax,1			; ax = .25 of avg
	push	ax

	push	bx
	mov	bx,ax
	add	ax,ax
	add	ax,bx			; ax = 0.75 of avg
	pop	bx

	add	ax,[si].PERIOD		; ax = 1.75 times avg
	cmp	ax,[bx]			; is current period more than 50% 
        pop	ax			; above our prev. period/avg
	jb	cd_throw_sample
	cmp	ax,[bx]			; ax = 1/2 of avg	
	ja	cd_throw_sample		; if below 0.5 (avg) then ignore this
;

	mov	ax,[bx]			; get current period
	add	ax,[si].PERIOD		; add previous period

; BUGBUG - nagara This should never happen ; we should rather ignore 
; this CY so that we get a low avg. this should help us not go idle when
; the period bet. ints are 32k apart
IFDEF DEBUG
	jnc	cd_4
	dbg_printchar 'o'
ENDIF
;	shr	ax,1
;	add	ax,8000h
;	jmp	short cd_5
; END BUGBUG

cd_4: 	shr	ax,1
cd_5:	mov	[bx],ax
	jmp	short cd_transf_period        ; go for next int

cd_end_adapt:
	mov	[ErrSampleCount],0
	mov     word ptr [si].ADAPT,0
	mov     ax,[si].PERIOD             ; for next compare ...
	jcxz	cd_setbase		; for i28 and i2f, no baseline ref.
	cmp	ax,[BaseLineRef]	; for i16, have a max limit for period
	jbe	cd_setbase		; 
	mov	ax,[BaseLineRef]
	mov	[si].BASE,ax		; go up to the max.allowed base
	shr	ax,1			; 50% of base
	mov	[si].NOISE,ax
	shr	ax,1			; 25% of base
	add	[si].NOISE,ax		; noise = 75% of base
	jmp	short cd_transf_period

cd_setbase:
	mov     [si].BASE,ax
	shr	ax,1			; 50% of base
	mov	[si].NOISE,ax
	shr	ax,1			; 25% of base
	add	[si].NOISE,ax		; noise = 75% of base
	
cd_doidle:
	call    DO_IDLE
	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	mov     word ptr [bx]+2,0       ; avoid speed up error

cd_transf_period:
	mov	ax,[bx]
	mov     [si].PERIOD,ax
cd_ClrTmr:
	call    ClearTimer              ; do speedup if needed, clear 
					; timer accumulator
	pop     ax
	ret

cd_throw_sample:
	inc	[ErrSampleCount]	
	mov	ax,[ErrSampleCount]
	cmp	ax,[CONTROL].MAXERRSAMPLE
	jbe	cd_ClrTmr		; go try adapting again
	mov	[ErrSampleCount],0
	jmp	cd_adapt

Chk_Delay       endp




;*************** Timer clear and app speedup adjustment
;       Helper routine for Chk_Delay.  Called independently
;       by I16_IDLE when it detects a key waiting.  Calls APP_SPDUP
;       if required, and clears out timer overflow
;
;       Entry : BX = address of timer accumulator for this interrupt
;       Exit  : nothing
;       Uses AX -- caller must preserve

public  ClearTimer
ClearTimer         proc
	assume  ds:Bios_Data
	cmp     word ptr [bx]+2,3
	jb      ct_0
	call    APP_SPDUP               ; speedup proportional
					; to delay...
ct_0:
	mov     word ptr [bx]+2,0       ; clear key timer
	call    READ_TMR0
	mov     [bx],ax
	cmp     word ptr [bx]+2,0
	jne     ct_0

	ret

ClearTimer         endp


;********************* APPLICATION IDLE CHECK *******************
; purpose: check application idle (INT 2F Function 1680H)
;          if interrupt is detected than DO_IDLE should be called
;          the interrupt should be absorbed.

PUBLIC I2f_idle
I2f_idle proc   far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds, Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ax,1680h                ; Any app idles?
	jne     i2F_chk_ours            ; check for a service call to us

; JAH Set the idle support byte in the current apps PSP
	push	ds
	mov	ds,PSPsegment		; DS:BX --> Current PSP in Dosdata
	mov	ds,WORD PTR ds:[CUR_PSP_OFFSET] ; DS -> current app's PSP
	assume	ds:Pdb_Data
	mov	PDB_Idle,IDLE_SUPPORT_BYTE ; Set this app's idle support byte
	pop	ds
	assume	ds:Bios_Data
; JAH end 

; load up registers and call do_idle
	push    di
	lea     di,[INFO].APP_TOT

; JAH	call    DO_IDLE			
	call	I2fIdleEntry		; JAH Use new idle entry point

	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0

I2FIdleCleanup:				; JAH New label
	pop	di
	pop	ds
	iret

i2Fnxt: 
	jmp     dword ptr pwr_i2f_next

i2f_chk_ours:
	cmp     ah, MultPWR_API         ; is this a call for one of our ; M077
	jne     i2fnxt                  ; services ?
	pop     ds                      ; restore original vector
	call    Pwr_Services            ; one of our services
	iret                            ; no propagation

I2f_idle endp

;************************ I28_IDLE *********************

PUBLIC I28_idle
I28_idle proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	inc     [I28].PCOUNT

	test    [CONTROL].IDLE_FLG,DOS_ACTIVE
	jz      i28ret

		; load up registers and call general delay checker
	push	cx
	push    bx
	push    si
	push    di
	lea     bx,I28_TMR0
	lea     si,I28
	lea     di,[INFO].DOS_TOT
	call    Chk_Delay
	pop     di
	pop     si
	pop     bx
	pop	cx

i28ret:

IFDEF   POWERALONE                      ; chain to next
	jmp     dword ptr pwr_i28_next
ELSE
	pop     ds
	assume  ds:nothing
	iret                            ; don't need to chain if BIOS resident
ENDIF

I28_idle endp

;********************* Shell idle check ******************************
; purpose: check idle (INT 2A Function 84h)
;          if interrupt is detected than DO_IDLE should be called
;          the interrupt should be absorbed.

PUBLIC I2A_idle
I2A_idle proc   far
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds, Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,84h                  
	jne     i2Anxt            	; check for a service call to us

; load up registers and call do idle
	push    di
	lea     di,[INFO].SHELL_TOT
	call    DO_IDLE
	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	pop	di
	pop	ds
	iret

i2Anxt: 
	jmp     dword ptr pwr_i2a_next

I2A_idle endp
;************************ I16_IDLE *********************

PUBLIC I16_IDLE
I16_IDLE proc near
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data


	cmp     [IN_KYC],0
	jne     kybxxx
	cmp     ah,01h
	je      kbpchk
	cmp     ah,11h
	je      kbpchk
	or	ah,ah
	jz	kbChkIdle
	cmp	ah,10h
	jz	kbChkIdle
kybxxx: 
	jmp     dword ptr pwr_i16_next


kbpchk: inc     [KYC].PCOUNT
	test    [CONTROL].IDLE_FLG,KYC_ACTIVE
	jz      kybxxx

	mov     [IN_KYC],1              ; ONLY ALLOW ONE RE-ENTRY

	jmp     dword ptr pwr_call_i16  ;call old int 16h handler
;
;We return to the label below after calling the previous int 16h handler
;
calli16ret:
	mov     ds,Bios_Data_Word               ;reinit DS to Bios_Data
	assume  ds:Bios_Data

	push    bx
	lea     bx,KYC_TMR0

		; if a key is ready, just clear out our timer and
		; return.  If no key is ready, go through the full
		; delay check.  Here we check the flags returned
		; by the INT 16 handler we called.
       
	jz      i16_ChkDelay

		; Just clear the timer
	push    ax
	call    ClearTimer
	pop     ax
	jmp     short kbpret
	
i16_ChkDelay:
		; load up registers and call delay check
	push	cx
	push    si
	push    di
	lea     si,KYC
	lea     di,[INFO].KEY_TOT
	mov	cx,1
	call    Chk_i16idle
	pop     di
	pop     si
	pop	cx

kbpret: 
	pop     bx
	mov     [IN_KYC],0              ; can start up again
	pop     ds
	assume  ds:nothing
	iret

kbChkIdle:
	assume  ds:Bios_Data
; see if there is a key available
	inc	ah			; make it to fn 1 or 11
kbChkKey:
	push	ax			; save function no (1 or 11h)
	jmp     dword ptr kb_call_i16  ;call old int 16h handler
kbChkRet:
	pop	ax			; get back orig. polling fn no
	jz	kbDoIdle		; no key available
	dec	ah			; get back original get key fn(0 or 10)
	jmp	kybxxx			; go get the key
; no key available do idle
kbDoIdle:
	push	ax
	push    bx
	push    di
	lea     bx,KYC_TMR0
	lea     di,[INFO].KEY_TOT
	call    DO_IDLE
	adc     word ptr [di],0         ; accumulate idle time
	adc     word ptr [di]+2,0
	mov     word ptr [bx]+2,0       ; avoid speed up error
	call    ClearTimer
	pop	di
	pop	bx
	pop	ax
	jmp	short kbChkKey		; go look for key

I16_IDLE endp


;************************ I1C_TIMR *********************

PUBLIC I1c_Timr
I1c_Timr proc
	assume  ds:nothing, es:nothing

	push    ds
	push    ax
	mov     ax,BIOSDATASEG          ; M092 check rollover flag in BIOS
	mov     ds,ax                   ; M092
	xor     al,al                   ; M096
	xchg    al,ds:[ROLLOVERFLG]     ; M096 get Bios rollover flg and 
					;   reset it
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	or      [CMOSUpdFlg],al         ; M092 set update flag if rollover

	dec     [CMOSPollCount]         ; M090
	jz      itmSetCMOSFlg           ; M090

itmNoTmUpdate:
	inc     [SPDUP_CNT]             ; speedup delay

	test    [POWER_STATUS],1        ; is idle detection on ?
	jz      i1c_to_end

	inc     [KYC_TMR0]+2            ; timer over flow
	inc     [KYC].DELAY             ; adjust delay

	inc     [I28_TMR0]+2            ; timer over flow
	inc     [I28].DELAY             ; adjust delay


	add     word ptr [INFO].CPU_ON_TIME,1
	adc     word ptr [INFO].CPU_ON_TIME+2,0

	xor     ax,ax                   ; M004  BEGIN
	xchg    [IDLTIC],ax             ; If we were idle during the last
	add     word ptr [INFO].CPU_IDLE_TIME,ax        ; tick period, let's
	adc     word ptr [INFO].CPU_IDLE_TIME+2,0       ; count it
					; M004 END

	test    [CONTROL].IDLE_FLG,AUTO_ACTIVE  ; no AUTO adjust
i1c_to_end:
	jz      itmxxx

itmot1: inc     [SWITCH_CNT]            ; time to switch methods?
	mov     ax,[CONTROL].SWITCH_DLY
	cmp     [SWITCH_CNT],ax
	jb      itmxxx                  ; not yet ...

itmot2: mov     [SWITCH_CNT],0
	mov     ax,[I28].PCOUNT         ; If( KYC.COUNT < I28.COUNT)
	cmp     ax,[KYC].PCOUNT         ; occurs in windows ...
	ja      itmdos

		; keyboard count is higher than INT 28 count
		; keyboard is highest count, it wins

	cmp     [KYC].PCOUNT,0          ; avoid thrashing
	je      itmxxx
	mov     ax,KYC_ACTIVE
	jmp     short itmset

itmSetCMOSFlg:
	mov     al,[CMOSFlg]            ; M090 ; need to update from CMOS
	or	[CMOSUpdFlg],al         ; M090 ; only if POWER STD mode in APM 
	mov	ax,MAXCMOSPOLLCOUNT	; machines
	mov	[CMOSPollCount],ax	; start counting again
	jmp     itmNoTmUpdate

itmdos:         ; INT 28 count higher than keyboard count
		; INT 28 count is highest, it wins
	or      ax,ax                   ; don't bother if count is 0
	jz      itmxxx
	mov     ax,DOS_ACTIVE

itmset: and     [CONTROL].IDLE_FLG,NOT ( APP_ACTIVE+DOS_ACTIVE+KYC_ACTIVE)
	or      [CONTROL].IDLE_FLG,ax

itmskp: xor     ax,ax                   ;reset for next round
	mov     [KYC].PCOUNT,ax
	mov     [I28].PCOUNT,ax

itmxxx: 
	test    [POWER_STATUS],2        ; M089 is F/W mgmt on ?
	jz      itmChain                ; M089 No need to poll APM in POWER
					; STD mode
IFDEF INCL_APM
; now check to see if we need to call APM for a PMEVENT 
	cmp     fAPM_STATE,0            ; is APM enabled ?
	je      itmChain
	dec     APM_POLL_COUNT
	jnz     itmChain

; time to poll APM for any PM Event

	push    bx
	mov     ax,[APM_MAX_POLLCOUNT]  ; first reset the counter
	mov     APM_POLL_COUNT,ax
;
itmPoll:
	mov     ax,APM_GETPMEVENT_FUNC
	int     15h
	jc      itm_End                 ; no events -> no work to do 
;
; BX = PM Event
;       1 = stand-by request
;       2 = suspend request
;       3 = normal resume
;       4 = crit. resume
;       5 = battery low
	cmp     bx,APM_NORM_RESUME
	je      itm_Set_time
	cmp     bx,APM_CRIT_RESUME
	jne     itm_broadcast

itm_Set_time:
	INC     APM_RESUME_COUNT
	call    Do_APM_CPUBUSY          ; M002 bring CPU to full speed
	mov     [CMOSUpdFlg],1          ; M090

itm_broadcast:
	mov     ax,I2F_APM_BROADCAST
	int     2fh                     ; broadcast the pm events to other
					; apps
; BUGBUG: Warning: the function codes for APM BIOS GetPMEvent and 
; the multiplex API broadcast functions are assumed to be the same
	cmp     bl,APM_NORM_RESUME      ; was it a stand-by/suspend request
	jae     itm_End                 ; if not, nothing else to do
;
; this was an APM request for system stand-by/suspend
; if no apps/tsrs objected to this request, let us call the APM to suspend/
; stand-by
	or      bh,bh
	jnz     itm_End                 ; somebody objected ? if so quit
	push    cx                      ; M093
	mov     cx,bx                   ; required power mode in CX
	mov     bx,APM_SYSTEM_DEV       ; full system
	mov     ax,APM_SETPWSTATE_FUNC
	int     15h
	pop     cx                      ; M093
IFDEF DEBUG
	jnc     itm_dbg_Success
	dbg_printchar   'f'             ; CY for a set power state call
itm_dbg_Success:
ENDIF                                   ; IFDEF DEBUG
; Resumed from a suspend/stand-by; we should get a resume notification
; from APM so that we can go and update the date and time 
	jmp     itmPoll                 ; go back and poll APM for
					; a resume notification event
;
itm_End:pop     bx
ENDIF
itmChain:
	pop     ax
	jmp     dword ptr pwr_i1c_next

I1C_TIMR endp

;************* I6C_RESUME *****************************
;
; On interrupts 6C, update system date and time from the hardware
; clock.  Int 6C is one way a system may signal a resume event.
; Entire routine is part of modification M080.

I6C_Resume      proc

	assume  ds:nothing,es:nothing

	push    ds
	mov     ds,cs:Bios_Data_Word
	assume ds:Bios_Data

;       Bugbug -- need to sti?
;       Bugbug -- enough stack space?

	push    ax
	push    bx
	push    cx
	push    dx
	push    si
	push    di

IFDEF   POWERALONE                      ; M081
	call    far ptr P_UpdFromCMOS
ELSE
	call    P_UpdFromCMOS_ptr       ; M074 update our date and time
					; from CMOS RTC
ENDIF

	pop     di
	pop     si
	pop     dx
	pop     cx
	pop     bx
	pop     ax

	jmp     dword ptr pwr_i6c_next

I6C_Resume      endp

;************* APPLICATION ACTIVITY MONITORS ***********

; SPEED UP by setting DOIdle delay count relitive to TIMER interrupts
; that have occurred between polling interrupt ...
; ** REQUIRES TESTING -- At this point APP_SPDUP tends to inhibit idle

PUBLIC APP_SPDUP
App_Spdup proc near
	assume  ds:Bios_Data, es:nothing

	push    ax
	mov     ax,[SPDUP_DLY]          ; machine speed dependent
	add     ax,[CONTROL].SPDUP_RAMP
	cmp     ax,[CONTROL].SPDUP_MAX  ; machine speed dependent
	jb      asdot3
	mov     ax,[CONTROL].SPDUP_MAX
asdot3: mov     [SPDUP],1               ; indicate activity
	mov     [SPDUP_DLY],ax
	mov     [SPDUP_CNT],0
	pop     ax
asdex0: ret

App_Spdup endp

I9_App  proc    
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	dec     [I9_COUNT]
	jnz     i9ex0
	mov     [I9_COUNT],2
	call    APP_SPDUP
i9ex0:  
	jmp     dword ptr Pwr_i9_next

I9_App  endp

I10_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,04h                          ; avoid cursor set
	jb      i10ex0                          ; calls
	call    APP_SPDUP
i10ex0: 
	jmp     dword ptr Pwr_i10_next

I10_App         endp

I13_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i13_next

I13_App         endp

I14_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,3                            ; avoid status calls
	je      i14ex0
	call    APP_SPDUP                       ; M002
i14ex0: 
	jmp     dword ptr Pwr_i14_next

I14_App         endp

I17_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	cmp     ah,2                            ; avoid status calls
	je      i17ex0
	call    APP_SPDUP
i17ex0: 
	jmp     dword ptr Pwr_i17_next

I17_App         endp

I21_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	push	ax

; upper bound check
	cmp	ah,MAX_I21_ENTRY
	ja	i21SpdUp

; get action from the lookup table 
	push	bx
	mov	bx,offset i21_table		; look up table for APIs
	xchg	ah,al			; get function code  in al
	xlat
	pop	bx
	or	al,al			; a busy call ?
	jz	i21SpdUp
	inc	al			; idle calls ?
	jz	i21ex0

; special cases
	cmp	ax,644h			; ioctl get input status call ?
	je	i21ex0

	cmp	al,4bh			; is it an exec call ?
	je	i21GetNewBL		; go get a new base line for int 16s

	cmp	ax,505fh		; is it network assign call ?
	je	i21ex0			; ignore it

; right now, there are only two special cases - 4406 and direct console io (6,
; dl= ff) and so now we just check for direct console io call

	cmp	dl,0ffh			; Direct console input ?
	je	i21ex0

; fall through for other special cases - should be changed if we add
; other special cases
i21SpdUp:
	call    APP_SPDUP
i21ex0: 
	pop	ax
	jmp     dword ptr Pwr_i21_next
	
i21GetNewBL:
	call	GetNewBaseLine
	jmp	short i21SpdUp
	
I21_App         endp

I25_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i25_next

I25_App         endp

I26_App         proc
	assume  ds:nothing, es:nothing

	push    ds
	mov     ds,Bios_Data_Word
	assume  ds:Bios_Data

	call    APP_SPDUP

	jmp     dword ptr Pwr_i26_next

I26_App         endp

GetNewBaseLine	proc	near

	push	ax
	push	cx
	push	dx
	push	[BaseLineOvf]		; save old value

	mov	[BaseLineRef],0		; init the I16 counters
	mov	[BaseLineOvf],0

	mov     [SPDUP],1               ; indicate activity
					; and stop idles temporarily
	mov     [SPDUP_DLY],5		; measure for 4 ticks
	mov     [SPDUP_CNT],0
	sti
gnb_start:
	cmp	[SPDUP_CNT],1
	jb	gnb_start
gnb_kb_loop:
	mov	ah,1
	int	16h			; get kbd status	
	add	[BaseLineRef],1
	adc	[BaseLineOvf],0
	cmp	[SPDUP_CNT],5
	jb	gnb_kb_loop
; 
	mov	ax,[BaseLineRef]
	mov	dx,[BaseLineOvf]
	shr	dx,1	
	rcr	ax,1		; divide by 2
	shr	dx,1	
	rcr	ax,1		; divide by 4 ; got I16 count for  1 tick
	shr	ax,1		; 50% of BaseLine 
	shr	ax,1		; 25% of BaseLine
	shr	ax,1		; 12.5% of baseline
	mov	dx,ax
	shr	ax,1		; 6.25 % of baseline
	add	ax,dx		; 18.75% of baseline
;	
	mov	cx,ax		; cx = no of I16s per tick (I16_count)
	xor	dx,dx
	mov	ax,0ffffh	; 64k /I16_count = period bet I16s
	div	cx		; ax = period bet I16s; dx remainder (ignored)
	mov	[BaseLineRef],ax; this is the new BaseLine ref value
	pop	[BaseLineOvf]	; get back old baseline value
	pop	dx
	pop	cx
	pop	ax
	ret

GetNewBaseLine	endp
	
	
IFDEF INCL_APM

; *********************************** Check_and_Init_APM ***************
; This procedure is called at init time ; checks for the presence of
; APM BIOS , if present connects to it (real mode only).
; If the connection is successful, we set APM_PRESENT flag so that
; later we can make use of APM 
;
; Input: none
; output: CY +NZ if NO APM
;         CY +ZR if cannot connect to it
;               or if APM cannot be enabled
;         NC = success (APM found+connected to APM+APM enabled state)
;       (fAPM_Present set to TRUE if APM present)
;       (APM_RESUME_COUNT initialised to 0)
;       (fAPM_CONNECT set to TRUE if connected to APM)
;       (fAPM_STATE set to TRUE if APM connected+enabled)
;               -> this is referred to before polling APM, before calling APM
;                       for idle
;
; regs affected: AX,BX,CX,DX,flags
;
; M001  : Created; APM support code

	public  Check_and_Init_APM

Check_and_Init_APM      proc    far
	
	mov     ax,APM_INSTALLCHK_FUNC
	mov     bx,APM_SYSTEM_BIOS      
	int     15h                     ; Check for APM BIOS presence

; CY set if no APM present
	jc      CAIA_NoAPM

; NC; check for APM signature (BH = "P" and BL = "M")   ; M003
; AX = version no (in BCD)
; CX = APM flags        (bit 0 - 16bit prot.mode intrfc. supported
;                        bit 1 - 32bit "  "      "  "      "  "
;                        bit 2 - set if CPU_IDLE call slows proc.clock
;                        bit 3 - set if BIOS power management disabled.

	cmp     bx,APM_SIGNATURE        ; M003
	jne     CAIA_NoAPM              
	mov     APM_FLAGS,cx            ; store the APM flags
	mov     APM_VER,ax              ; store APM BIOS ver no

	mov     fAPM_PRESENT,1          ; set APM flag  ; M002

; connect to APM
	call    Do_APM_Connect          ;M005
	jc      CAIA_APM_Err            ; cannot connect ? assume APM
					; not present/functional
;
; check for APM BIOS disabled state
	test    APM_FLAGS,APM_PWMGMT_DISABLED
	jz      CAIA_APM_Success                ; APM in enabled state; all success
;
	mov     cx,APM_ENABLE_FUNC
	call    Do_APM_Enable_Disable   ;M005
	jnc     CAIA_APM_Success
	mov     fAPM_PRESENT,0          ; reset APM flag since we couldn't
						; connect to it
	mov     fAPM_STATE,0            ; disabled state        
	mov     APM_RESUME_COUNT,0      ; initialise RESUME_COUNT
	jmp     short CAIA_APM_Err

CAIA_APM_Success:
	mov     fAPM_STATE,1            ; APM in enabled state
	mov     APM_RESUME_COUNT,0      ; initialise RESUME_COUNT
	or      POWER_STATUS,2          ; M003: indicate APM is enabled
CAIA_End:
	ret

CAIA_NoAPM:
	mov     al,1                    ; APM not there; CY + NZ
CAIA_FEnd:
	or      al,al                   ; set Zero flag if APM error
	stc
	jmp     short CAIA_End
CAIA_APM_Err:
	xor     al,al                   ; APM is there but connect or some
	jmp     short CAIA_FEnd         ; other error => CY + Z

Check_and_Init_APM      endp

ENDIF   ; for INCL_APM conditional
; M001 END


Bios_Code       ends



;********************** INITIALIZE CODE ******************

Sysinitseg      segment
	assume  cs:Sysinitseg, ds:nothing, es:nothing

; AX.ReturnStatus = DEV_INIT( ES:BX.DRIVER_INIT_REQUEST)

	public  Power_Init
IFDEF   POWERALONE
Power_Init proc far
ELSE
Power_init proc near
ENDIF

	assume  ds:nothing, es:nothing
	pushf	
	sti
	push    si
	push    ds
	push    dx
	push    ax

	mov     ax, Bios_Data
	mov     ds,ax
	assume  ds:Bios_Data

; JAH Start - Get address of DOS data area
	push	bx
	push	es
	mov	ah,52h			; Get the DOS data segment
	int	21h
	mov	WORD PTR PSPsegment,es
	pop	es
	pop	bx
; JAH End

IFDEF   POWERALONE
	; Return DEVICE DRIVER end address
	mov     word ptr es:[bx].RH_D_BREAKPTR+0,offset Bios_Data:End_Data
	mov     word ptr es:[bx].RH_D_BREAKPTR+2,ds

	; Return DO_IDLE address to DOS
	mov     ax,Bios_Res                     ; get resident code segment
	mov     word ptr es:[bx].RH_D_IDLEPTR+0,offset Bios_Code:DO_IDLE_DOS
	mov     word ptr es:[bx].RH_D_IDLEPTR+2,ax

; M092 BEGIN
; see if POWER is already loaded ; If so, disable the previous POWER
; and load ourselves.
	
	xor     bx,bx
	mov     ax,(MultPWR_API*256)+00h; POWER detect mult.call 
	int     2fh
	cmp     ax,(MultPWR_API*256)+00h; MultAPI code unchanged ? 
	jz      pi_NoPrevPower
	cmp     bx,504dh                ; M087 signature correct ?
	jne     pi_NoPrevPower

; There is a previously loaded POWER; disable it.
	mov     bx,100h                 ; disable all Power management
	mov     ax,(MultPWR_API*256)+I2F_PW_GET_SET_PWSTATE
	int     2fh                     ; we don't expect any error here
;M092 END

ENDIF

; Continue init.
pi_NoPrevPower:
	mov     dx,Bios_Res             ;code segment of the BIOS
	mov     Pwr_calli16_ret+2,dx            ;init CS for this pointer
	mov     kb_calli16_ret+2,dx            ;init CS for this pointer

	mov     si,offset I1C_VEC               ; chain 1Ch
	mov     ax,1Ch                          ; 18.2 second interrupt
	call    XVECT

	mov     si,offset I28_VEC               ; chain 28h
	mov     ax,28h                          ; DOS IDLE interrupt
	call    XVECT

	mov     si,offset I2F_VEC               ; chain 2Fh
	mov     ax,2Fh                          ; APP IDLE interrupt
	call    XVECT

	mov     si,offset I2A_VEC               ; chain 2Fh
	mov     ax,2Ah                          ; APP IDLE interrupt
	call    XVECT

	mov     si,offset I16_VEC               ; chain 16h
	mov     ax,16h                          ; keyboard intrrupt
	call    XVECT

	mov     si,offset I9_VEC                ; chain 8h
	mov     ax,9h                           ; PC TIMER interrupt
	call    XVECT

	mov     si,offset I10_VEC               ; chain 10h
	mov     ax,10h                          ; application activity
	call    XVECT

	mov     si,offset I13_VEC               ; chain 13h
	mov     ax,13h                          ; application activity
	call    XVECT

	mov     si,offset I14_VEC               ; chain 14h
	mov     ax,14h                          ; application activity
	call    XVECT

	mov     si,offset I17_VEC               ; chain 17h
	mov     ax,17h                          ; application activity
	call    XVECT

	mov     si,offset I21_VEC               ; chain 21h
	mov     ax,21h                          ; application activity
	call    XVECT

	mov     si,offset I25_VEC               ; chain 25h
	mov     ax,25h                          ; application activity
	call    XVECT

	mov     si,offset I26_VEC               ; chain 26h
	mov     ax,26h                          ; application activity
	call    XVECT

	mov     si,offset I6C_VEC               ; chain 6Ch             ;M080
	mov     ax,6Ch                          ; resume event          ;M080
	call    XVECT                                                   ;M080

	push    ds      
	mov     ax,cs                           ; DS=CS for the message
	mov     ds,ax
	assume  ds:nothing
	mov     dx,offset INIT_MSG
	mov     ah,9                            ; report init complete
	int     21h
	pop     ds                              ; ds = bios_data
	assume  ds:Bios_Data

;M001 BEGIN
;
IFDEF  INCL_APM

; Check and initialize APM.

;M005 BEGIN

IFDEF   POWERALONE
	call    Check_and_Init_APM
ELSE
	call    Check_and_Init_APM_Ptr
ENDIF   ;NOT POWERALONE

;M005 END

ENDIF           ; INCL_APM

; M001 END

	pop     ax
	pop     dx
	pop     ds
	assume  ds:nothing
	pop     si

	popf
	clc
	ret

Power_Init      endp

;INIT_MSG db "MS-DOS Power Monitor Extension Version 1.00",10,13
;         db "    Copyright (C) 1990-1991 Microsoft Corp.",10,13,"$"

INIT_MSG:
include msbio.cl9

; void XVECT( ds:[si].vecp, ax.vec#,dx.Bios_Code_Seg)
; purpose: xchange a vector with vector pointed to by ds:si

Xvect   proc    near
	assume  ds:Bios_Data, es:nothing

	push    es
	push    di

	mov     di,ax
	shl     di,1
	shl     di,1

	xor     ax,ax
	mov     es,ax

	pushf
	cli                             ; disable interrupts
	mov     ax,[si]
	xchg    es:[di],ax
	mov     [si],ax
	mov     ax,dx                   ;dx contains Bios_Code seg
	xchg    es:[di]+2,ax
	mov     [si]+2,ax
	popf

	pop     di
	pop     es
	ret

Xvect   endp

;M074   BEGIN

	public  Clock_Init

Clock_init      proc far

IFDEF   POWERALONE                      ; M081
	call    far ptr P_UpdFromCMOS
ELSE
	call    P_UpdFromCMOS_ptr       ; M074 update our date and time
					; from CMOS RTC
ENDIF

;       Ints 1c and 6c are hooked during main power management init, above.
	
	clc
	ret

Clock_Init      endp

;M074   END

Sysinitseg      ends

ENDIF   ;For POWER conditional

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\power21\power.inc ===
;       Standard includes for POWER.EXE device driver and control program
;
;       Microsoft Confidential
;       Copyright (C) 1991 Microsoft Corporation 
;       All Rights Reserved.

;
;------------------------------------------------------------------------------
;
; M077 : B#2669. Registered POWER's 2f channels in mult.inc
;
;------------------------------------------------------------------------------
;
REQHDR	STRUC			; DOS REQUEST HEADER STRUCTURE
RH_B_LEN	db ?		; request header length
		db ?		; block device only
RH_B_CMD	db ?		; command to execute on this request
RH_W_STATUS	dw ?		; return status from driver
		db 8 dup(?)	; reserved for dos
REQHDR	ENDS

RHINIT	STRUC
		db SIZE REQHDR dup(?)
		db ?		; block device only
RH_D_BREAKPTR	dd ?		; return address to end driver
RH_D_IDLEPTR	dd ?		; return address of idle routine
				; for DOS special definition for DOS 5
		db ?		; block device only
RHINIT	ENDS

RHIO	STRUC
		db SIZE REQHDR dup(?)
		db ?		; block device only
RH_D_XFERPTR	dd ?		; address of read/write block
RH_W_XFERCNT	dw ?		; size of block
		dw ?		; block device only
		dd ?		; block device only
RHIO	ENDS

POW_IOCTL_BLOCK struc           ; structure returned by IOCTL READ call

PIB_ENTRY_OFFSET dw ?            ; callback entry point
PIB_ENTRY_SEG   dw ?
PIB_VERSION     db ?            ; version of POWER.EXE
                db 27 dup (?)   ; reserved

POW_IOCTL_BLOCK ends

; SAVEPWR version nos
POW_MAJ_VERSION	EQU 01H 	; M084
POW_MIN_VERSION	EQU 00H 	; M084


; functions supported by POWER direct callback
POW_GET_CONTROL_INFO    equ     0       ; return pointer to control structure
POW_GET_STATS           equ     1       ; return pointer to idle measurment structure
POW_DO_IDLE             equ     2       ; direct DO_IDLE call


; IDLE flags

IDLE_ACTIVE	EQU 01h
MEASURE_ACTIVE	EQU 02h
AUTO_ACTIVE	EQU 04h
KYC_ACTIVE	EQU 08h
DOS_ACTIVE	EQU 10h
APP_ACTIVE	EQU 20h
SOUND_ACTIVE	EQU 80h

CONTROL_INFO struc
IDLE_FLG	dw ?		; startup AUTO, MEASURE, IDLE
SWITCH_DLY	dw ?		; delay to switch between idle algorithms
THRESHOLD	dw ?		; idle ignore threshold
ADAPT_DLY	dw ?		; idle adaptation delay
MAXERRSAMPLE    dw ?            ; max. allowed errors while adapting
SPEED_DLY	dw ?		; full speed delay
SPDUP_RAMP	dw ?		; adjustable ramp delay used in APP_SPDUP
SPDUP_MAX	dw ?		; maximum delay speedup delay
CV86FLG		dw ?		; bit 0 set if test active
				; bit 1 set if 386 or above
CONTROL_INFO ends

IDLE_INFO struc
CPU_ON_TIME	dd ?		; total time CPU is ON (TIMER TICS)
CPU_IDLE_TIME	dd ?		; total time CPU is IDLE (TIMER TICS)
IDLE_TOT	dd ?		; total count of idles executed
APP_TOT		dd ?		; total count of APPLICATION IDLES
DOS_TOT		dd ?		; total count of DOS IDLES
KEY_TOT		dd ?		; total count of KEY BOARD IDLES
SHELL_TOT	dd ?		; total count of shell idles
IDLE_INFO ends

PERIOD_INFO struc
PERIOD	dw ?			; Current period in timer tics
BASE	dw ?			; Current base period in timer tics
NOISE   dw ?                    ; noise allowed on the current base
ADAPT	dw ?			; (1) Adapting to increase in period
DELAY	dw ?			; WAIT Count prior to adapting
PCOUNT	dw ?			; Counts times this interrupt has been called
PERIOD_INFO ends

MAXCMOSPOLLCOUNT	equ	364	; M092 approx. once in 20 secs 

; M092  BEGIN
BIOSDATASEG	equ	40h
ROLLOVERFLG	equ	70h
BIOSTICKCOUNT	equ	6ch
; M092 END

; M001 APM SUPPORT 
; Comment the next line out, if you don't want APM related code to be
; present in POWER.
INCL_APM	equ	1
;
; additional equates used by APM support code

APM_STATS_STRUC	struc
	RESUME_COUNT	dw	?
APM_STATS_STRUC	ends

APM_STATS_STRUC_SIZE	equ	size APM_STATS_STRUC

.errnz (APM_STATS_STRUC_SIZE - 2)
; If this line generates error message look at power.asm I2f processing code
; for get_STATS API. This is currently the size the APM_RESUME_COUNT

I1A_GET_DATE	equ	0400h		; get date int 1a function code
ROLLOVER_COUNT	equ	70h		; offset to the byte counter of 
					; elapsed days  in bios data area
					; (i.e. 40:70h)

; **************************** ERROR CODES ***********************

ERROR_PM_ALREADY_CONNECTED	equ	02h		; same as APM
ERROR_PM_NOT_CONNECTED		equ	03h		; same as APM
ERROR_PM_FUNCTION_NOT_SUPPORTED	equ	70h
ERROR_PM_BUFFER_TOO_SMALL	equ	71h
ERROR_PM_INVALID_PARAMETER	equ	87h		; same as system EXTEND

; ***************************** Int 2f subfunctions supported by POWER *****
;
I2F_PW_INSTALL_CHK	equ	0
I2F_PW_GET_SET_PWSTATE	equ	1
I2F_PW_SELECT_ALG	equ	2
I2F_PW_TUNE_PARM	equ	80h
I2F_PW_GET_STATS	equ	81h
I2F_PW_APM_POLLCOUNT	equ	82h
I2F_PW_GETSET_BASELINE	equ	8fh
;
; ***************************** parameters/args for the above int 2f functions
;
; args for PW_GET_STATS call (BX reg)
PW_GET_IDLE_STATS	equ	0
PW_GET_APM_STATS	equ	1
;******************************* the broadcast int. used by POWER ***********
;
I2F_APM_BROADCAST	equ	((MultPWR_BRDCST * 256)+0bh)		; M077
;
;*******************************  misc. equates *****************************
;
ALG_RESERVED_BITS	equ	11110000b	; only the least 4 bits are used
PWSTATE_RESERVED_BITS	equ	11111100b	; only the least 2 bits are used

IDLE_SUPPORT_BYTE	EQU	01010101b	; JAH Idles support byte for PSP
CUR_PSP_OFFSET		EQU	330h
;
;****************************************************************************
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\setcds\magicdrv.inc ===
;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1992
;	All Rights Reserved.
;

; MagicDrv Int 2Fh Equates

multMagicdrv	equ	4a11h	; Int2f multiplex number

MD_VERSION	equ	0	; Get driver version #
MD_DRIVE_MAP	equ	1	; Get drive mapping info function


; PLAIN_BPB - This is a simple BPB as DOS defines it. Refer to DOS technical
;	      manual for more details

PLAIN_BPB	struc
jmpBOOT 	db	3 dup (?)	;jump to bootstrap routine
achOEMName	db	8 dup (?)	;OEM Name
cbPerSec	dw	?		;count of bytes per sector
csecPerClu	db	?		;count of sectors per cluster
csecReserved	dw	?		;reserved sectors
cFATs		db	?		;count of FATs
cRootDirEntries dw	?		;count of root dir entries
csecTotalWORD	dw	?		;count of total sectors
bMedia		db	?		;media descriptor byte
csecFAT 	dw	?		;count of sectors in FAT
csecPerTrack	dw	?		;count of sectors per track
cHeads		dw	?		;count of disk heads
csecHidden	dd	?		;count of hidden sectors
csecTotalDWORD	dd	?		;count of total sectors
					;  (if csecTotalWORD = 0)
PLAIN_BPB	ends



; MD_BPB - This is the structure that is stored at teh begining of the
;	   MagicDrv Compressed Volume File (CVF).  Early versions of
;	   MagicDrv used different names for the MD_BPB fields;  these
;	   names are documented after this structure.

MD_BPB		struc

dos_bpb 	db  (SIZE PLAIN_BPB) dup (?)	;starts with a normal DOS BPB

secMDFATStart	dw	?	;logical sector of MD FAT start
nLog2cbPerSec	db	?	;Power 2 of sector size
csecMDReserved	dw	?	;sector count reserved for internal tables
secRootDirStart dw	?	;logical sector of root directory start
secHeapStart	dw	?	;logical sector of sector heap start
cluFirstData	dw	?	;first internal 'cluster' which contains data
cpageBitFAT	db	?	;count of pages for bit_fat table
		dw	?	;reserved
nLog2csecPerClu db	?	;Power 2 of csecPerClu (sectors per cluster)
		dw	?	;reserved

cbCVFMin	dd	?	;minimum CVF size in bytes
		dd	?	;reserved
f12BitFAT	db	?	;NZ if 12 bit FAT, Z if 16 bit FAT
cmbCVFMax	dw	?	;maximum CVF size, in megabytes

MD_BPB		ends


; Following is a mapping of the new MD_BPB field names to the old
; "our_bpb" names.
;
;  secMDFATStart	sqztor_cluster_o
;  nLog2cbPerSec	sector_pow2
;  csecMDReserved	log_internal
;  secRootDirStart	first_root
;  secHeapStart 	first_data
;  cluFirstData 	first_cluster
;  cpageBitFAT		b_fat_parts
;  nLog2csecPerClu	sectors_p_unit_pow2
;			pass_off
;  cbCVFMin		min_file
;			max_file
;  f12BitFAT		xfat_12bit
;  cmbCVFMax		max_cap
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\setcds\setcds.asm ===
page	,132
;***	MagicSetCdss -- disable CDSs for still unmounted DblSpace drives
;	   this routine was lifted out of MS-DOS 6's SYSPRE.ASM module.
;
;	entry:
;	   CDSs are now persistent and in their final place

	.xlist
break	macro		; dummy macro for include files
	endm
	include	curdir.inc
	include	magicdrv.inc
	include	sysvar.inc
	.list

boofy	segment
	assume	cs:boofy

entryx:
	call	MagicSetCdss
	mov	ax,4c00h	; terminate
	int	21h

MagicSetCdss	proc	near

	mov	ah,52h		; get DOS DATA pointer
	int	21h
	mov	si,bx		; get pointer into es:si

	mov	ax,multMagicdrv
	mov	bx,MD_VERSION	; get version
	int	2fh
	or	ax,ax		; is it there?
	jnz	magic_set_exit	; done if not

;	version call returned cl=first DblSpace drive in ASCII
;			      ch=number of DblSpace drive letters

	mov	al,cl		; get first DblSpace drive letter
	sub	al,'A'		; make it zero based.
	mov	dl,al		; and save for drive testing loop

	les	si,es:[si].sysi_cds ; fetch CDSs
	mov	ah,curdirLen
	mul	ah		; find first DblSpace CDS
	add	si,ax

	mov	cl,ch		; get DblSpace drive count into cx
	xor	ch,ch

;	We know cx > 0, or else the driver wouldn't have stayed resident

magic_set_cdss_1:

	push	si		; save cds pointer
	push	es
	push	cx		; save loop count
	push	dx		; and drive letter

	mov	ax,multMagicdrv
	mov	bx,MD_DRIVE_MAP ; inquire drive map
	int	2fh		; see if this is an unused DblSpace drive

	pop	dx
	pop	cx
	pop	es
	pop	si

	cmp	bl,dl		; if mapped to itself, it is vacant
	jnz	magic_set_cdss_2 ; skip if used

	and	es:[si].CURDIR_FLAGS,not CURDIR_inuse ; reset the bit in flags

magic_set_cdss_2:
	add	si,curdirLen
	inc	dl		; next drive
	loop	magic_set_cdss_1

magic_set_exit:
	ret

MagicSetCdss	endp

boofy	ends
	end	entryx

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\bios\setcds\sysvar.inc ===
;	SCCSID = @(#)sysvar.asm 1.1 85/04/10

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

SysInitVars STRUC
SYSI_DPB	    DD	    ?		; DPB chain
SYSI_SFT	    DD	    ?		; SFT chain
SYSI_CLOCK	    DD	    ?		; CLOCK device
SYSI_CON	    DD	    ?		; CON device
SYSI_MAXSEC	    DW	    ?		; maximum sector size
SYSI_BUF	    DD	    ?		; points to Hashinitvar
SYSI_CDS	    DD	    ?		; CDS list
SYSI_FCB	    DD	    ?		; FCB chain
SYSI_Keep	    DW	    ?		; keep count
SYSI_NUMIO	    DB	    ?		; Number of block devices
SYSI_NCDS	    DB	    ?		; number of CDS's
SYSI_DEV	    DD	    ?		; device list
SYSI_ATTR	    DW	    ?		; null device attribute word
SYSI_STRAT	    DW	    ?		; null device strategy entry point
SYSI_INTER	    DW	    ?		; null device interrupt entry point
SYSI_NAME	    DB	 8 DUP(?)	; null device name
SYSI_SPLICE	    DB	    0		; TRUE -> splicees being done
SYSI_IBMDOS_SIZE    DW	    ?		; DOS size in paragraphs
SYSI_IFS_DOSCALL@   DD	    ?		; IFS DOS service rountine entry
SYSI_IFS	    DD	    ?		; IFS header chain
SYSI_BUFFERS	    DW	    ?,0 	; BUFFERS= values (m,n)
SYSI_BOOT_DRIVE     DB	    ?		; boot drive A=1 B=2,..
SYSI_DWMOVE	    DB	    0		; 1 if 386 machine
SYSI_EXT_MEM	    DW	    0		; Extended memory size in KB.
SysInitVars ENDS

;This is added for more information exchage between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86
SysInitVars_Ext struc
SYSI_InitVars		DD	0	; Points to the above structure.
SYSI_Country_Tab	DD	0	; DOS_Country_cdpg_info
SysInitVars_Ext ends

;The SYSI_BUF of SysInitVars points to the follwong structure
EMS_MAP_BUFF_SIZE      EQU	12	; EMS map buffer size

Buffinfo    STRUC
Buff_Queue	 DD	 ?		     ; Head of list of buffers
Dirty_Buff_Count DW	 ?		     ; number of dirty buffers in list
Cache_ptr	 DD	 ?		     ; pointer to secondary cache
Cache_count	 DW	 0		     ; number of secondary cache entries

Buff_In_HMA	db	0		     ; flag to indicate that buffers
					     ; are in HMA
Lo_Mem_Buff	dd	0		     ; Ptr to scratch buff in Low Mem
					     ;  used to read/write on disks

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG

UU_EMS_FIRST_PAGE	DW	0, 0
UU_EMS_NPA640	DW	0

;smr; removal of BUFFERFLAG; ENDIF

UU_EMS_mode	 DB	 -1		     ; no EMS = -1
UU_EMS_handle	 DW	 ?		     ; EMS handle for buffers
UU_EMS_PageFrame_Number	DW   -1 	     ; EMS page frame number
UU_EMS_Seg_Cnt	 DW	 1		     ; EMS segment count
UU_EMS_Page_Frame	 DW	 -1		     ; EMS page frame segment address
UU_EMS_reserved	 DW	 0		     ; EMS segment count

;smr; removal of BUFFERFLAG; IF	BUFFERFLAG
UU_EMS_Map_Buff	 DB	 0  ; map buffer
;smr; removal of BUFFERFLAG; ELSE
;smr; removal of BUFFERFLAG; EMS_Map_Buff	DB	12 dup(0)
;smr; removal of BUFFERFLAG; ENDIF

Buffinfo    ENDS

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\boot\msboot.asm ===
Page ,132
TITLE BOOT	SECTOR 1 OF TRACK 0 - BOOT LOADER
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;   Rev 1.0 ChrisP, AaronR and others.	2.0 format boot
;
;   Rev 3.0 MarkZ   PC/AT enhancements
;		    2.50 in label
;   Rev 3.1 MarkZ   3.1 in label due to vagaries of SYSing to IBM drive D's
;		    This resulted in the BPB being off by 1.  So we now trust
;		    2.0 and 3.1 boot sectors and disbelieve 3.0.
;
;   Rev 3.2 LeeAc   Modify layout of extended BPB for >32M support
;		    Move PHYDRV to 3rd byte from end of sector
;		    so that it won't have to be moved again
;		    FORMAT and SYS count on PHYDRV being in a known location
;
;   Rev. 3.3 D.C. L. Changed Sec 9 EOT field from 15 to 18. May 29, 1986.
;
;   Rev 3.31 MarkT  The COUNT value has a bogus check (JBE????) to determine
;		    if we've loaded in all the sectors of IBMBIO. This will
;		    cause too big of a load if the sectors per track is high
;		    enough, causing either a stack overflow or the boot code
;		    to be overwritten.
;
;   Rev 4.00 J. K.  For DOS 4.00 Modified to handle the extended BPB, and
;		    32 bit sector number calculation to enable the primary
;		    partition be started beyond 32 MB boundary.
;
;
; The ROM in the IBM PC starts the boot process by performing a hardware
; initialization and a verification of all external devices.  If all goes
; well, it will then load from the boot drive the sector from track 0, head 0,
; sector 1.  This sector is placed at physical address 07C00h.	The initial
; registers are set up as follows:  CS=DS=ES=SS=0.  IP=7C00h, SP=0400H.
;
; The code in this sector is responsible for locating the MSDOS device drivers
; (IBMBIO) and for placing the directory sector with this information at
; physical address 00500h.  After loading in this sector, it reads in the
; entirety of the BIOS at BIOSEG:0 and does a long jump to that point.
;
; If no BIOS/DOS pair is found an error message is displayed and the user is
; prompted to reinsert another disk.  If there is a disk error during the
; process, a message is displayed and things are halted.
;
; At the beginning of the boot sector, there is a table which describes the
; MSDOS structure of the media.  This is equivalent to the BPB with some
; additional information describing the physical layout of the driver (heads,
; tracks, sectors)
;
;==============================================================================
;REVISION HISTORY:
;AN000 - New for DOS Version 4.00 - J.K.
;AC000 - Changed for DOS Version 4.00 - J.K.
;AN00x - PTM number for DOS Version 4.00 - J.K.
;==============================================================================
;AN001; d52 Make the fixed positioned variable "CURHD" to be local.  7/6/87 J.K.
;AN002; d48 Change head settle at boot time.			     7/7/87 J.K.
;AN003; P1820 New message SKL file				   10/20/87 J.K.
;AN004; D304 New structrue of Boot record for OS2.		   11/09/87 J.K.
;AN005; Changed version to 5.0					   03/08/90 E.A.
;AN006; Changed to remove MSLOAD in first cluster restriction	   04/23/90 J.H.
;==============================================================================


ORIGIN		EQU	7C00H		; Origin of bootstrap LOADER
BIO_SEG		EQU	70H		; Destingation segment of BIOS
BIO_OFFSET	EQU	700H		; Offset of bios
SECTOR_SIZE	EQU	512		; Sector size in bytes
DIR_ENTRY_SIZE	EQU	32		; Size of directory entry in bytes
DIR_OFF		EQU	500h
IBM_LOAD_SIZE	EQU	3		;J.K. Size of IBMLOAD module in sectors
ROM_DISKRD	EQU	2
DSK_PARMS	EQU	1EH*4		;POINTER TO DRIVE PARAMETERS



; ==========================================================================

include version.inc
include	dirent.inc

; ==========================================================================

SEGBIOS SEGMENT AT BIO_SEG

	; Define the destination segment of the BIOS, including the
	; initialization label

BIOS	LABEL	BYTE

SEGBIOS ENDS

; ==========================================================================

CODE	SEGMENT
	ASSUME CS:CODE,DS:NOTHING,ES:NOTHING,SS:NOTHING
	ORG	ORIGIN


	Public $START
$START:
			; WARNING -- Don't change this to a short jmp
	jmp	Main			; Jump to start of code


; ==========================================================================

					; Start of BPB area of the boot record
IF IBMCOPYRIGHT
		DB	"IBM  "
ELSE
		DB	"MSDOS"
ENDIF

;	BUGBUG -- 7 Dec 1992 -- chuckst -- changed version back to 5.0 to
;					avoid bug in PC-TOOLS DISKFIX
OsVersion	DB	"5.0"		; DOS version number
BytesPerSector	DW	SECTOR_SIZE	; Size of a physical sector
SecsPerClust	DB	8		; Sectors per allocation unit
ReservedSecs	DW	1		; Number of reserved sectors
NumFats		DB	2		; Number of fats
NumDirEntries	DW	512		; Number of direc entries
TotalSectors	DW	4*17*305-1	; Number of sectors - number of hidden
					; sectors (0 when 32 bit sector number)
MediaByte	DB	0F8H		; MediaByte byte
NumFatSecs	DW	8		; Number of fat sectors
SecPerTrack	DW	17		; Sectors per track
NumHeads	DW	4		; Number of drive heads

HiddenSecs	DD	1		; Number of hidden sectors
BigTotalSecs	DD	0		; 32 bit version of number of sectors
BootDrv		DB	80h
CurrentHead	DB	0h		; Current Head
ExtBootSig	DB	41
SerialNum	DD	0
VolumeLabel	DB	'NO NAME    '
FatId		DB	'FAT12   '

		; Danger!!! If not 32 bit sector number calculation,
		; FORMAT should set the value of HiddenSecsHigh and
		; BigTotalSectors to 0 !!!

	PUBLIC uData
uData	LABEL	BYTE
						;Equates to allow access to
						;storage where Main is now
Sec9		EQU	BYTE PTR uData+0	;11 byte diskette parm. table
BiosLow 	EQU	WORD PTR uData+11
BiosHigh	EQU	WORD PTR uData+13
CurTrk		EQU	WORD PTR uData+15
CurSec		EQU	BYTE PTR uData+17
DirLow		EQU	WORD PTR uData+18
DirHigh		EQU	WORD PTR uData+20

; =========================================================================

		; First thing is to reset the stack to a better and more known
		; place. The ROM  may change, but we'd like to get the stack
		; in the correct place.
MAIN:
	cli				;Stop interrupts till stack ok
	xor	AX,AX
	mov	SS,AX			;Work in stack just below this routine

	ASSUME	SS:CODE
	mov	SP,ORIGIN
	push	SS
	pop	ES

	ASSUME	ES:CODE

		; We copy the disk parameter table into a local area. We scan
		; the table above for non-zero parameters.  Any we see get
		; changed to their non-zero values. We copy the disk parameter
		; table into a local area (overlayed into the code)

	mov	BX,DSK_PARMS
	lds	SI,DWORD PTR SS:[BX]	; get address of disk table
	push	DS			; save original vector for possible
	push	SI			; restore
	push	SS
	push	BX
	mov	DI,OFFSET Sec9
	mov	CX,11
	cld

	repz	movsb
	push	ES
	pop	DS			; DS = ES = code = 0.
	assume	DS:CODE

		; Set the head settle time to 15ms because we don't have room
		; to do a disk retry and then set sectors per from the value
		; in the BPB

	mov	BYTE PTR [DI-2], 0fh	; Head settle time
	mov	CX, SecPerTrack
	mov	BYTE PTR [DI-7], cl	; End of Track

	mov	[BX+2],AX		; Place in new disk parameter
	mov	[BX],offset Sec9	; table vector

		; We may now turn interrupts back on. Before this, there is
		; a small window when a reboot command may come in when the
		; disk parameter table is garbage

	sti				; Interrupts OK now
	int	13h			; Reset the disk system just in case
	jc	CkErr			; any thing funny has happened.

		; The system is now prepared for us to begin reading.
		; First, determine logical sector numbers of the start of the
		; directory and the start of the data area.

	xor	AX,AX
	cmp	TotalSectors,AX		; 32 bit calculation?
	je	Dir_Cont

	mov	CX,TotalSectors
	mov	WORD PTR BigTotalSecs,CX ; BigTotalSecs

Dir_Cont:
	mov	AL,NumFats		;Determine sector dir starts on
	mul	NumFatSecs		;DX;AX
	add	AX,WORD PTR HiddenSecs
	adc	DX,WORD PTR HiddenSecs[2]
	add	AX,ReservedSecs
	adc	DX,0

		; DX:AX = NumFats * NumFatSecs + ReservedSecs + cSecHid

	mov	[DirLow],AX
	mov	[DirHigh],DX
	mov	[BiosLow],AX
	mov	[BiosHigh],DX

		; Take into account size of directory (only know number
		; of directory entries)

	mov	AX,DIR_ENTRY_SIZE	; bytes per directory entry
	mul	NumDirEntries		; convert to bytes in directory
	mov	BX,BytesPerSector	; add in sector size
	add	AX,BX
	dec	AX			; decrement so that we round up
	div	BX			; convert to sector number
	add	[BiosLow],AX		; Start sector # of Data area
	adc	[BiosHigh],0

		; We load in the first directory sector and examine it to
		; make sure the the BIOS and DOS are the first two directory
		; entries. If they are not found, the user is prompted to
		; insert a new disk. The directory sector is loaded into 00500h

	mov	BX,DIR_OFF		; sector to go in at 00500h

	mov	DX,[DirHigh]
	mov	AX,[DirLow]		; logical sector of directory
	call	DoDiv			; convert to sector, track, head
	jc	CkErr			; Overflow? BPB must be wrong!!

	mov	al, 1			; disk read 1 sector
	call	DoCall			; do the disk read
	jb	CkErr			; if errors try to recover


		; Now we scan for the presence of BIOS file.

	mov	DI,BX
	mov	CX,11
	mov	SI,OFFSET Bio		; point to "ibmbio  com"
	repz	cmpsb			; see if the same
	jnz	CkErr			; if not there advise the user

		; Found the BIOS. Check the second directory entry.
		; SI will already point to "MSDOS  SYS" if first compare
		; was successful

	lea	DI,[BX+20h]
;**	mov	SI,OFFSET Dos
	mov	CX,11
	repz	cmpsb
	jz	DoLoad

		; There has been some recoverable error. Display a message
		; and wait for a keystroke.


CkErr:	mov	SI,OFFSET SysMsg	; point to no system message

ErrOut:
	call	Write			; and write on the screen


	xor	AX,AX			; wait for response
	int	16h			; get character from keyboard
	pop	SI			; reset disk parameter table back to
	pop	DS			; rom
	pop	[SI]
	pop	[SI+2]
	int	19h			; Continue in loop till good disk

Load_Failure:
	pop	ax			;adjust the stack
	pop	ax
	pop	ax
	jmp	short CkErr		;display message and reboot.

		; We now begin to load the BIOS in.
		; All we have to do is just read is multiply the BioStartClus
		; by SecsPerClust to find the logical sector for the start
		; of the BIOS file. When this value is added to the double
		; word BiosHigh:BiosLow we get the absolute sector offset
		; for the start of the file and then read the  sectors
		; contiguously IBM_LOAD_SIZE times. We here assume that
		; IBMLOAD module is contiguous. Currently we estimate that
		; IBMLOAD module will not be more than 3 sectors.
DoLoad:
	mov	AX,[BX].DIR_FIRST	; AX = BIOS starting cluster
	dec	AX			; Subtract first 2 reserved clusters
	dec	AX
	mov	BL,SecsPerClust		; BX = Sectors per cluster
	xor	BH,BH
	mul	BX			; DX:AX = first logical sector of bios

	add	AX,[BiosLow]		; Add absolute start sector
	adc	DX,[BiosHigh]		; DX:AX = Absolute bios sector offset

	mov	BX,BIO_OFFSET		;offset of ibmbio(IBMLOAD) to be loaded.
	mov	CX,IBM_LOAD_SIZE	;# of sectors to read.

Do_While:
	push	AX
	push	DX
	push	CX
	call	DoDiv			; DX:AX = sector number.
	jc	Load_Failure		; Adjust stack. Show error message
	mov	al, 1			; Read 1 sector at a time.
					; This is to handle a case of media
					; when the first sector of IBMLOAD is the
					; the last sector in a track.
	call	DoCall			; Read the sector.
	pop	CX
	pop	DX
	pop	AX
	jc	CkErr			; Read error?
	add	AX,1			; Next sector number.
	adc	DX,0
	add	BX,BytesPerSector	; Adjust buffer address.
	loop	Do_While


; =========================================================================
; Main read-in loop.
; ES:BX points to area to read.
; Count is the number of sectors remaining.
; BIOS$ is the next logical sector number to read
;
; CurrentHead is the head for this next disk request
; CurTrk is the track for this next request
; CurSec is the beginning sector number for this request
;
; AX is the number of sectors that we may read.
;
; =========================================================================
;
; IBMINIT requires the following input conditions:
;
;   DL = INT 13 drive number we booted from
;   CH = media byte
;   IBMBIO init routine should check if the boot record is the
;   extended one by looking at the extended_boot_signature.
;   If it is, then should us AX;BX for the starting data sector number.
; =========================================================================

DISKOK:
	mov	CH,MediaByte
	mov	DL,BootDrv
	mov	BX,[BiosLow]		; J.K.I1.Get bios sector in bx
	mov	AX,[BiosHigh]		; J.K.I1.
	jmp	FAR PTR Bios		;CRANK UP THE DOS

WRITE:
	lodsb				;GET NEXT CHARACTER
	or	AL,AL			;Clear the high bit
	jz	EndWr			;ERROR MESSAGE UP, JUMP TO BASIC
	mov	AH,14			;WILL WRITE CHARACTER & ATTRIBUTE
	mov	BX,7			;ATTRIBUTE
	int	10h			;PRINT THE CHARACTER
	jmp	Write

		; Convert a logical sector into Track/sector/head.
		; DX;AX has the sector number. Because of not enough space, we
		; are  going to use Simple 32 bit division here.
		; Carry set if DX;AX is too big to handle.

DODIV:
	cmp	DX,SecPerTrack		; To prevent overflow!!!
	jae	DivOverFlow		; Compare high word with the divisor.
	div	SecPerTrack		; AX = Total tracks, DX = sector number
	inc	DL			; We assume SecPerTrack < 255 & DH=0
					; curSec is 1-based.
	mov	CurSec, DL		; Save it
	xor	DX,DX
	div	NumHeads
	mov	CurrentHead,DL		;Also, NumHeads < 255.
	mov	CurTrk,AX
	clc
	ret

DivOverFlow:
	stc

EndWR:
	ret
; =========================================================================
;
; Issue one read request. ES:BX have the transfer address,
; AL is the number of sectors.
;
; =========================================================================

DOCALL:
	mov	AH,ROM_DISKRD			;=2
	mov	DX,CurTrk
	mov	CL,6
	shl	DH,CL
	or	DH,CurSec
	mov	CX,DX
	xchg	CH,CL
	mov	DL, BootDrv
	mov	DH, CurrentHead
	int	13h
	ret

; =========================================================================

include boot.cl1

; =========================================================================

	IF IBMCOPYRIGHT
Bio	DB	"IBMBIO  COM"
Dos	DB	"IBMDOS  COM"
	ELSE
Bio	DB	"IO      SYS"
Dos	DB	"MSDOS   SYS"
	ENDIF

; =========================================================================

Free	EQU (SECTOR_SIZE - 4) - ($-$start)

if Free LT 0
    %out FATAL PROBLEM:boot sector is too large
	.ERR
endif

	org	origin + (SECTOR_SIZE - 2)
	db	55h,0aah			; Boot sector signature

; =========================================================================

CODE	ENDS
	END 

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\api.h ===
/* TS = NONE */
/*** API.H:  Extern procs for the compression and decompression libraries. ***/


  /* procedures in SUCOMP.LIB */
extern  SHORT   far  CbWriteFileHeader(int fhDest);
extern  LONG    far  LcbCompressToFile(SHORT wAlgType, int fhSrc, int fhDest,
                           LONG lcbDestMax);
extern  LONG    far  LcbCalculateCompressedLength(SHORT wAlgType, int fhSrc,
                           LONG lcbDestMax);

  /* procedures in SUDECOMP.LIB */
extern  SHORT   far  WReadHeaderInfo(int fhSrc);
extern  BOOL    far  FFreeHeaderInfo(void);   /* also in SUCOMP.LIB */
extern  LONG    far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead,
                           BYTE far * pfbBuf, LONG lcbBuf, PFNWFROMW pfn,
                           int cProgTicks, PFNWFROMW pfnYield);
extern  LONG    far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbCalculateDecompressedLength(int fhSrc,
                           BOOL fHeaderAlreadyRead);

  /* global variables for file header info before writing or after reading */
extern  SHORT   vwAlgType;
extern  LONG    vlcbSrcLength;
extern  BOOL    vfChecksum;
extern  USHORT  vusChecksum;
extern  USHORT  vcbArgs;
extern  BYTE *  vrgbArgs;
extern  CHAR    vszBaseName[9];
extern  CHAR    vszExtension[4];
extern  SZ      vszText;
extern  USHORT  vcbText;

#ifdef EAS
extern  CHAR    far *vfrgbEAs;
extern  CHAR    *vrgbEAs;
extern  USHORT  vuscbEAs;
#endif /* EAS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\boot\boot11.inc ===
;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
	db	0EBH,027H,090H,008H,000H,014H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,0CDH
	db	019H,0FAH,08CH,0C8H,08EH,0D8H,033H,0D2H
	db	08EH,0D2H,0BCH,000H,07CH,0FBH,0B8H,060H
	db	000H,08EH,0D8H,08EH,0C0H,033H,0D2H,08BH
	db	0C2H,0CDH,013H,072H,069H,0E8H,085H,000H
	db	072H,0DDH,02EH,083H,03EH,003H,07CH,008H
	db	074H,006H,02EH,0C6H,006H,064H,07DH,002H
	db	0BBH,000H,000H,02EH,08BH,00EH,003H,07CH
	db	051H,0B0H,009H,02AH,0C1H,0B4H,000H,08BH
	db	0F0H,056H,033H,0D2H,033H,0C0H,08AH,0C5H
	db	02EH,0F6H,036H,064H,07DH,08AH,0E8H,08AH
	db	0F4H,08BH,0C6H,0B4H,002H,0CDH,013H,072H
	db	02DH,05EH,059H,02EH,029H,036H,005H,07CH
	db	074H,01FH,08BH,0C6H,02EH,0F7H,026H,065H
	db	07DH,003H,0D8H,0FEH,0C5H,0B1H,001H,051H
	db	0BEH,008H,000H,02EH,03BH,036H,005H,07CH
	db	07CH,005H,02EH,08BH,036H,005H,07CH,0EBH
	db	0C0H,0EAH,000H,000H,060H,000H,0BEH,067H
	db	07DH,0E8H,002H,000H,0EBH,0FEH,032H,0FFH
	db	02EH,0ACH,024H,07FH,074H,00BH,056H,0B4H
	db	00EH,0BBH,007H,000H,0CDH,010H,05EH,0EBH
	db	0EFH,0C3H,0E9H,033H,0FFH,0BBH,000H,000H
	db	0B9H,004H,000H,0B8H,001H,002H,0CDH,013H
	db	01EH,072H,033H,08CH,0C8H,08EH,0D8H,0BFH
	db	000H,000H,0B9H,00BH,000H,026H,080H,00DH
	db	020H,026H,080H,04DH,020H,020H,047H,0E2H
	db	0F4H,0BFH,000H,000H,0BEH,08BH,07DH,0B9H
	db	00BH,000H,0FCH,0F3H,0A6H,075H,00FH,0BFH
	db	020H,000H,0BEH,097H,07DH,0B9H,00BH,000H
	db	0F3H,0A6H,075H,002H,01FH,0C3H,0BEH,01BH
	db	07DH,0E8H,0A2H,0FFH,0B4H,000H,0CDH,016H
	db	01FH,0F9H,0C3H,00DH,00AH,04EH,06FH,06EH
	db	02DH,053H,079H,073H,074H,065H,06DH,020H
	db	064H,069H,073H,06BH,020H,06FH,072H,020H
	db	064H,069H,073H,06BH,020H,065H,072H,072H
	db	06FH,072H,00DH,00AH,052H,065H,070H,06CH
	db	061H,063H,065H,020H,061H,06EH,064H,020H
	db	073H,074H,072H,069H,06BH,065H,020H,061H
	db	06EH,079H,020H,06BH,065H,079H,020H,077H
	db	068H,065H,06EH,020H,072H,065H,061H,064H
	db	079H,00DH,00AH,000H,001H,000H,002H,00DH
	db	00AH,044H,069H,073H,06BH,020H,042H,06FH
	db	06FH,074H,020H,066H,061H,069H,06CH,075H
	db	072H,065H,00DH,00AH,000H,04DH,069H,063H
	db	072H,06FH,073H,06FH,066H,074H,02CH,049H
	db	06EH,063H,020H
IF	IBMCOPYRIGHT
	db	'ibmbio  com'
	db	030H
	db	'ibmdos  com'
ELSE
	db	'io      sys'
	db	030H
	db	'msdos   sys'
ENDIF
	db	030H,005H,0C6H,006H,077H,02FH
	db	0FFH,083H,07EH,0FCH,000H,075H,00BH,080H
	db	07EH,0F7H,03BH,075H,005H,0C6H,006H,076H
	db	02FH,0FFH,089H,0ECH,05DH,0CAH,004H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H
	db	000H,000H,000H,000H,000H,000H,000H,000H

=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\compress.c ===
/* TS = none */
/*
**  COMPRESS.C  --  general compression routines for Setup Toolkits.
*/

#include <string.h>
#include <io.h>
#include <stdio.h>

#include "sutkcomp.h"



/*
**  LONG  far  LcbCompressToFile(SHORT wAlgType, int fhSrc, int fhDest,
**                                                              LONG lcbDestMax)
**
**  Calls the appropriate compression routine.  Assumes that fhSrc points to
**  location to start reading (may not be the beginning if we are splitting).
**  If it returns successfully, fhSrc points at either EOF or the next source
**  byte to start compression at if a split occurred because lcbDestMax was
**  reached.  Returns number of bytes written to fhDest if successful, or an
**  error return code if not.  Resets fhDest to its original value when an
**  error occurs.
**
**  if lcbDestMax == NIL then no limit on output size.
*/
LONG  far  LcbCompressToFile(SHORT wAlgType, int fhSrc, int fhDest,
                                                                LONG lcbDestMax)
{
    SHORT    cbHeader;
    LONG     lcbHeader;
    LONG     lcbReturned;                     /* also used in error-exit case */
    LONG     libSrcStart;
    LONG     libDestStart;

    if (fhSrc == -1)
        return((LONG)rcReadError);

    if (vlcbSrcLength != NIL && (libSrcStart = tell(fhSrc)) == NIL)
        return((LONG)rcReadSeekError);

    if (fhDest == -1 || fhSrc == fhDest)
        return((LONG)rcWriteError);

    if ((libDestStart = tell(fhDest)) == NIL)
        return((LONG)rcWriteSeekError);

      /* set global vars for header info */
    vwAlgType = wAlgType;                        /* REVIEW maybe already done */

    cbHeader = CbWriteFileHeader(fhDest);
    if (cbHeader < rcNoError && cbHeader > -100)
        {
        lcbReturned = (LONG)cbHeader;     /* cbHeader contains the error code */
        goto LCompToFileError;
        }
	 lcbHeader = (LONG) ((USHORT) cbHeader);

      /* zero-length files */
    if (eof(fhSrc))
        return(lcbHeader);

    if (lcbDestMax != NIL && lcbHeader >= lcbDestMax)
        {
        lcbReturned = (LONG)rcSplitSizeTooSmall;
        goto LCompToFileError;
        }

    if (lcbDestMax != NIL)
        lcbDestMax -= lcbHeader;

    switch (wAlgType)
        {
    default:
        lcbReturned = (LONG)rcUnknownAlgType;
        goto LCompToFileError;

#ifdef NC_XOR1
    case wAlgTypeNoCompress:
        lcbReturned = Lcb_NC_XOR1_StraightCopy(fhSrc, fhDest, lcbDestMax, NULL,
                                                                     0L, FALSE);
        break;

    case wAlgTypeXOR1:
        lcbReturned = Lcb_NC_XOR1_StraightCopy(fhSrc, fhDest, lcbDestMax, NULL,
                                                                      0L, TRUE);
        break;
#endif /* NC_XOR1 */

#ifdef ZK1
    case wAlgTypeZK1:
        lcbReturned = Lcb_ZK1_CompressToFile(fhSrc, fhDest, lcbDestMax);
        break;
#endif /* ZK1 */

#ifdef JJJ1
    case wAlgTypeJJJ1:
        lcbReturned = Lcb_JJJ1_CompressToFile(fhSrc, fhDest, lcbDestMax);
        break;
#endif /* JJJ1 */
        }

    if (lcbReturned < rcNoError)             /* compression returned an error */
        goto LCompToFileError;

      /* patch usChecksum */
    if (vfChecksum && vlibChecksum != NIL &&
                                   !FPatchUs(fhDest, vlibChecksum, vusChecksum))
        {
        lcbReturned = (LONG)rcDestPatchError;
        goto LCompToFileError;
        }

      /* patch lcbSrcLength at location vlibSrcLength */
    if (vlcbSrcLength != NIL && vlibSrcLength != NIL && libSrcStart != NIL)
        {
        if ((vlcbSrcLength = tell(fhSrc)) == NIL)
            {
            lcbReturned = (LONG)rcReadSeekError;
            goto LCompToFileError;
            }
        vlcbSrcLength -= libSrcStart;
        if (!FPatchUl(fhDest, vlibSrcLength, (ULONG)vlcbSrcLength))
            {
            lcbReturned = (LONG)rcDestPatchError;
            goto LCompToFileError;
            }
        }

    return(lcbReturned + lcbHeader);

LCompToFileError:                       /* reset fhDest to its original value */
    lseek(fhDest, libDestStart, SEEK_SET);
    chsize(fhDest, libDestStart);
    return(lcbReturned);
}


/*
**  LONG  far  LcbCalculateCompressedLength(SHORT wAlgType, int fhSrc,
**                                                              LONG lcbDestMax)
**
**  Call the appropriate compression routine.  Assumes that fhSrc points to
**  location to start reading.  If it returns successfully, fhSrc points to
**  its original value.  Returns number of bytes that would have been written
**  if this had been a call to LcbCompressToFile() and it was successful, or
**  an error return code if not.
**
**  if lcbDestMax == NIL then no limit on output size.
*/
LONG  far  LcbCalculateCompressedLength(SHORT wAlgType, int fhSrc,
                                                                LONG lcbDestMax)
{
    SHORT   cbHeader;
    LONG    lcbHeader;
    LONG    lcbReturned;
    LONG    libSrcStart;

    if (fhSrc == -1)
        return((LONG)rcReadError);

    if ((libSrcStart = tell(fhSrc)) == NIL)
        return((LONG)rcReadSeekError);

      /* set global vars for header info */
    vwAlgType = wAlgType;                        /* REVIEW maybe already done */

    cbHeader = CbWriteFileHeader(-1);
    if (cbHeader < rcNoError && cbHeader > -100)
        return((LONG)cbHeader);
    lcbHeader = (LONG) ((USHORT) cbHeader);

    if (lcbDestMax != NIL && lcbHeader >= lcbDestMax)
        return((LONG)rcSplitSizeTooSmall);

    if (lcbDestMax != NIL)
        lcbDestMax -= lcbHeader;

    switch (wAlgType)
        {
    default:
        return((LONG)rcUnknownAlgType);

#ifdef NC_XOR1
    case wAlgTypeNoCompress:
        lcbReturned = Lcb_NC_XOR1_StraightCopy(fhSrc, -1, lcbDestMax, NULL, 0L,
                                                                         FALSE);
        break;

    case wAlgTypeXOR1:
        lcbReturned = Lcb_NC_XOR1_StraightCopy(fhSrc, -1, lcbDestMax, NULL, 0L,
                                                                          TRUE);
        break;
#endif /* NC_XOR1 */

#ifdef ZK1
    case wAlgTypeZK1:
        lcbReturned = Lcb_ZK1_CompressToFile(fhSrc, -1, lcbDestMax);
        break;
#endif /* ZK1 */

#ifdef JJJ1
    case wAlgTypeJJJ1:
        lcbReturned = Lcb_JJJ1_CompressToFile(fhSrc, -1, lcbDestMax);
        break;
#endif /* JJJ1 */
        }

    if (lcbReturned < rcNoError)             /* compression returned an error */
        return(lcbReturned);

    if (lseek(fhSrc, libSrcStart, SEEK_SET) == NIL)
        return((LONG)rcReadSeekError);

    return(lcbReturned + lcbHeader);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\fmemset.asm ===
; fmemset.asm:  _fmemset() for C 5.1

	.model	small, c

	.code

lcb_fmemset proc   far uses es si di, lpDst:far ptr, val:word, cnt:word

	les	di, lpDst
	mov	ax, val
	mov	cx, cnt
	rep stosb

	mov	dx, es			;returns lpDst
	mov	ax, word ptr lpDst

	ret

lcb_fmemset endp

	end
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\decomp.c ===
/* TS = none */
/*
**  DECOMP.C  --  general decompression routines for Setup Toolkits.
*/

#include <io.h>
#include <stdio.h>
#ifdef EAS
#include <malloc.h>
#endif /* EAS */
#include "sutkcomp.h"

extern PFNWFROMW vpfn;
extern PFNWFROMW vpfnYield;
extern int       vcTicks;
extern LONG      vcbPerTick;
extern LONG      vcbCur;


/*
**  LONG  far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
**                                       LONG libStart, BOOL fHeaderAlreadyRead)
**
**  If fHeaderAlreadyRead is TRUE, assumes the header has already been read
**  (and global variables have been set), otherwise it reads the header.
**  Then calls the appropriate decompress routine.  The routine starts
**  decompression at fhSrc's current position, and writes starting at fhDest's
**  current position (either of which may not be the beginning of the file.)
**  If vlcbSrcLength has been set to a size other than NIL, this procedure
**  checks the decompressed file's length and returns an error if mismatched.
**  Returns number of bytes written to fhDest, or an error return code.
*/
LONG  far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                                         LONG libStart, BOOL fHeaderAlreadyRead)
{
    return(LcbDecompFile(fhSrc, fhDest, lcbDestMax, libStart,
            fHeaderAlreadyRead, NULL, 0L, NULL, 0, NULL));
}



/*
**  LONG  far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
**                 LONG libStart, BOOL fHeaderAlreadyRead, BYTE far * fpbBuf,
**                 LONG lcbBuf, PFNWFROMW pfn, int cProgTicks,
**                 PFNWFROMW pfnYield)
**
**  If fHeaderAlreadyRead is TRUE, assumes the header has already been read
**  (and global variables have been set), otherwise it reads the header.
**  Then calls the appropriate decompress routine.  The routine starts
**  decompression at fhSrc's current position, and writes starting at fhDest's
**  current position (either of which may not be the beginning of the file.)
**  If vlcbSrcLength has been set to a size other than NIL, this procedure
**  checks the decompressed file's length and returns an error if mismatched.
**  Returns number of bytes written to fhDest, or an error return code.
*/
LONG  far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
               LONG libStart, BOOL fHeaderAlreadyRead, BYTE far * fpbBuf,
               LONG lcbBuf, PFNWFROMW pfn, int cProgTicks, PFNWFROMW pfnYield)
{
    SHORT   wAlgType;
    LONG    lcbReturn;
    LONG    libDestStart;
    long    lfaCur, lfaEnd;

    if (fhSrc == -1)
        return((LONG)rcReadError);

    if (fhDest == -1 || fhSrc == fhDest)
        return((LONG)rcWriteError);

    if ((libDestStart = tell(fhDest)) == NIL)
        return((LONG)rcWriteSeekError);

    if (!fHeaderAlreadyRead)
        if ((wAlgType = WReadHeaderInfo(fhSrc)) < rcNoError)
            return((LONG)wAlgType);

    if (pfn == NULL || cProgTicks < 0)
        cProgTicks = 0;
    if (cProgTicks == 0)
        pfn = NULL;

      /* zero-length files */
    if (eof(fhSrc))
        {
        if (pfn != NULL)
            (*pfn)(cProgTicks);
        return(0L);
        }

#ifdef EAS
#ifdef OS2_VER
    if (vfrgbEAs && vuscbEAs)  // Need to dump out EA stuff...
        {
        EAOP eaop;

        eaop.fpFEAList = (PFEALIST) vfrgbEAs;
        if (DosSetFileInfo(fhDest, 2, (PBYTE)&eaop, sizeof(EAOP)))
            {
            }
        }
    if (vfrgbEAs)
        {
        _ffree(vfrgbEAs);
        vfrgbEAs = NULL;
        }
    vuscbEAs = 0;
#endif /* OS2_VER */
#endif /* EAS */

    if ((lfaCur = lseek(fhSrc, 0L, SEEK_CUR)) == -1L ||
            (lfaEnd = lseek(fhSrc, 0L, SEEK_END)) == -1L ||
            lseek(fhSrc, lfaCur, SEEK_SET) != lfaCur ||
            lfaCur > lfaEnd)
        return((LONG)rcReadSeekError);

	vpfnYield = pfnYield;
    if ((vpfn = pfn) != NULL)
        {
        vcTicks    = cProgTicks;
        vcbPerTick = ((lfaEnd - lfaCur) / cProgTicks) + 1;
        }
    vcbCur     = 0L;

    switch (vwAlgType)
        {
    default:
        lcbReturn = (LONG)rcUnknownAlgType;
        break;

#ifdef NC_XOR1
    case wAlgTypeNoCompress:
        lcbReturn = Lcb_NC_XOR1_StraightCopy(fhSrc, fhDest, lcbDestMax, NULL,
                                                               libStart, FALSE);
        break;

    case wAlgTypeXOR1:
        lcbReturn = Lcb_NC_XOR1_StraightCopy(fhSrc, fhDest, lcbDestMax, NULL,
                                                                libStart, TRUE);
        break;
#endif

#ifdef ZK1
    case wAlgTypeZK1:
#if 1  /* REVIEW eventually remove */
        if (lcbDestMax != NIL)
            lcbReturn = rcGenericDecompError;
        else
#endif
        lcbReturn = Lcb_ZK1_DecompressToFile(fhSrc, fhDest, lcbDestMax,
                                                                      libStart);
        break;
#endif

#ifdef JJJ1
    case wAlgTypeJJJ1:
#if 1  /* REVIEW eventually remove */
        if (lcbDestMax != NIL)
            lcbReturn = rcGenericDecompError;
        else
#endif
        lcbReturn = Lcb_JJJ1_DecompressToFile(fhSrc, fhDest, lcbDestMax,
                                                      libStart, fpbBuf, lcbBuf);
        break;
#endif
        }
    
    /* check that source length matches */
    if (lcbReturn > rcNoError && vlcbSrcLength != NIL &&
                                  (lcbDestMax == NIL || lcbReturn < lcbDestMax))
        {
        if (lcbReturn != vlcbSrcLength)
            lcbReturn = (LONG)rcCompLengthBad;
        }

    if (lcbReturn < rcNoError)
        {
        lseek(fhDest, libDestStart, SEEK_SET);
        chsize(fhDest, libDestStart);
        }

    if (vcTicks > 0 && vpfn != NULL)
        (*vpfn)(vcTicks);
    vpfn       = NULL;
	vpfnYield  = NULL;
    vcTicks    = 0;
    vcbPerTick = 0L;
    vcbCur     = 0L;

    return(lcbReturn);
}



#ifdef COMPLEX
/*
**  LONG  far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
**                                       LONG libStart, BOOL fHeaderAlreadyRead)
**
**  If fHeaderAlreadyRead = FALSE, reads the header contents; otherwise assumes
**  the header has been read into the global variables.  Calls the appropriate
**  decompression routine, which decompresses into buffer fpbBuf at most
**  lcbBuf bytes, starting the buffer filling at the offset libStart bytes
**  from the current position in fhSrc.  (It is an error for fpbBuf == NULL.
**  If lcbBuf == NIL, nothing is read into the buffer.)
**  Returns number of bytes actually uncompressed or an error return code.
*/
LONG  far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
                                         LONG libStart, BOOL fHeaderAlreadyRead)
{
    SHORT  wAlgType;
    
    if (fhSrc == -1)
        return((LONG)rcReadError);

    if (lcbBuf == NIL)
        return(0L);

    if (fpbBuf == NULL)
        return((LONG)rcWriteError);

    if (!fHeaderAlreadyRead)
        if ((wAlgType = WReadHeaderInfo(fhSrc)) < rcNoError)
            return((LONG)wAlgType);


    switch (vwAlgType)
        {
    default:                            /* unrecognized compression algorithm */
        return((LONG)rcUnknownAlgType);

#ifdef NC_XOR1
    case wAlgTypeNoCompress:
        return(Lcb_NC_XOR1_StraightCopy(fhSrc, -1, lcbBuf, fpbBuf, libStart,
                                                                        FALSE));

    case wAlgTypeXOR1:
        return(Lcb_NC_XOR1_StraightCopy(fhSrc, -1, lcbBuf, fpbBuf, libStart,
                                                                         TRUE));
#endif

#ifdef ZK1
    case wAlgTypeZK1:
        return(Lcb_ZK1_DecompressToBuffer(fhSrc, fpbBuf, lcbBuf, libStart));
#endif

#ifdef JJJ1
    case wAlgTypeJJJ1:
        return(Lcb_JJJ1_DecompressToBuffer(fhSrc, fpbBuf, lcbBuf, libStart));
#endif
        }
}
#endif /* COMPLEX */



#ifdef COMPLEX
/*
**  LONG  far  LcbCalculateDecompressedLength(int fhSrc,
**                                                      BOOL fHeaderAlreadyRead)
**
**  If fHeaderAlreadyRead == TRUE, assumes the header contents are already
**  available in the global variables; otherwise it reads the header.
**  Calculates the decompressed length of the file but doesn't actually
**  create the output file.  Assumes that fhSrc is set to the beginning of 
**  the file, or right past the header if fHeaderAlreadyRead is TRUE.  If 
**  successful, it resets fhSrc to its original value.
**  Returns length of decompressed file or an error return code.
*/
LONG  far  LcbCalculateDecompressedLength(int fhSrc, BOOL fHeaderAlreadyRead)
{
    SHORT  wAlgType;
    LONG   lcbReturn;
    LONG   libSrcStart;

    if (fhSrc == -1)
        return((LONG)rcReadError);

    if ((libSrcStart = tell(fhSrc)) == NIL)
        return((LONG)rcReadSeekError);

    if (!fHeaderAlreadyRead)
        if ((wAlgType = WReadHeaderInfo(fhSrc)) < rcNoError)
            return((LONG)wAlgType);

    if (vlcbSrcLength != NIL)
        {
        lseek(fhSrc, libSrcStart, SEEK_SET);
        return(vlcbSrcLength);
        }

    switch (vwAlgType)
        {
    default:
        return((LONG)rcUnknownAlgType);

#ifdef NC_XOR1
    case wAlgTypeNoCompress:
    case wAlgTypeXOR1:
        lcbReturn = Lcb_NC_XOR1_StraightCopy(fhSrc, -1, -1L, NULL, 0L, FALSE);
#endif

#ifdef ZK1
    case wAlgTypeZK1:
        lcbReturn = Lcb_ZK1_DecompressToFile(fhSrc, -1, NIL, 0L);
#endif

#ifdef JJJ1
    case wAlgTypeJJJ1:
        lcbReturn = Lcb_JJJ1_DecompressToFile(fhSrc, -1, NIL, 0L, NULL, 0L);
#endif
        }

    if (lcbReturn >= rcNoError)
        lseek(fhSrc, libSrcStart, SEEK_SET);

    return(lcbReturn);
}
#endif /* COMPLEX */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\sutkcomp.c ===
/* TS = none */
/* REVIEW - we really should have a ReadChar() in case we support kanji */
/*
**  SUTKCOMP.C  --  general compression routines for
**                  Setup Toolkits.  Handles all header manipulation.
*/

#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <dos.h>

#include "sutkcomp.h"


  /* global header info variables */
extern SHORT   vwAlgType;
extern LONG    vlcbSrcLength;
extern BOOL    vfChecksum;
extern USHORT  vusChecksum;
extern USHORT  vcbArgs;
extern BYTE *  vrgbArgs;
extern CHAR    vszBaseName[9];
extern CHAR    vszExtension[4];
extern SZ      vszText;
extern USHORT  vcbText;

#ifdef WIN2_VER
extern HANDLE  vhRgbArgs;
extern HANDLE  vhSzText;
#endif /* WIN2_VER */

  /* global variables needed within toolkit layer */
extern  LONG    vlibChecksum;
extern  LONG    vlibSrcLength;


  /* forward declarations of local routines */
extern  SHORT   far CbWriteFileHeader(int fhDest);
extern  BOOL        FPatchUs(int fh, LONG lib, USHORT us);
extern  BOOL        FPatchUl(int fh, LONG lib, ULONG ul);

#ifdef NOT_USED
extern  USHORT      CbWriteFar(int fh, BYTE far * fp, USHORT cb);
#endif /* NOT_USED */


/*
**  SHORT  far  CbWriteFileHeader(int fhDest)
**
**  Write the info contained in the header globals out to fhDest.  Assumes
**  that fhDest is positioned to where the header should be written (the
**  beginning of the file.)  If the source file length or checksum need to
**  be included in the header, the global variables vlibSrcLength and
**  vlibChecksum are set to the positions to patch those numbers later when 
**  the length and checksum are known.
**
**  Returns the length of the header written.  fhDest is left positioned at
**  the byte after the header.  If there is an error during writing, the file
**  position is reset to its original value, and the file truncated.
*/
SHORT  far  CbWriteFileHeader(int fhDest)
{
    USHORT    us;
    USHORT    cbWritten = 0;
    USHORT    cbBase;
    USHORT    cbExt;
    ULONG     ulSizeSeek;
    BOOL      fOkayWrite;
    LONG      libDestStart;

    if (fhDest != -1 && (libDestStart = tell(fhDest)) == -1)
        return(rcWriteSeekError);

    cbBase = strlen(vszBaseName);
    cbExt = strlen(vszExtension);

    /* REVIEW: this sleazy thing checks to make sure we have a valid alg type
       for the flags that are currently turned on.  REWRITE THIS. */
    if (TRUE
#ifdef ZK1
            && (vwAlgType != wAlgTypeZK1)
#endif /* ZK1 */
#ifdef JJJ1
            && (vwAlgType != wAlgTypeJJJ1)
#endif /* JJJ1 */
#ifdef NC_XOR1
            && (vwAlgType != wAlgTypeNoCompress)
            && (vwAlgType != wAlgTypeXOR1)
#endif /* NC_XOR1 */
            )
        {
        return(rcUnknownAlgType);
        }

    if (cbBase > 8 || cbExt > 3)
        return(rcFilenamesTooLong);

    fOkayWrite = FWriteNBytes(fhDest, rgbMagicValue, cbMagic);
    cbWritten += cbMagic;

    fOkayWrite &= FWriteUs(fhDest, vwAlgType);
    cbWritten += sizeof(USHORT);

    if (fhDest != -1)
        ulSizeSeek = tell(fhDest);         /* where to write cbHeader & flags */
    fOkayWrite &= FWriteUs(fhDest, 0);                            /* cbHeader */
    fOkayWrite &= FWriteUs(fhDest, 0);                               /* flags */
    cbWritten += sizeof(USHORT) * 2;

    us = 0;                            /* build flags and write optional data */
    if (vlcbSrcLength != NIL)
        {
        us |= bmSrcLength;
        if (fhDest != -1)
            vlibSrcLength = tell(fhDest);     /* length will be patched later */
        fOkayWrite &= FWriteUl(fhDest, NIL);
        cbWritten += sizeof(ULONG);
        }
    if (vfChecksum)
        {
        us |= bmChecksum;
        if (fhDest != -1)
            vlibChecksum = tell(fhDest);           /* where to write checksum */
        fOkayWrite &= FWriteUs(fhDest, vusChecksum);
        cbWritten += sizeof(USHORT);
        }
    if (vcbArgs != 0)
        {
        us |= bmArgs;
        fOkayWrite &= FWriteUs(fhDest, vcbArgs);
        fOkayWrite &= FWriteNBytes(fhDest, vrgbArgs, vcbArgs);
        cbWritten += sizeof(USHORT) + vcbArgs;
        }
    if (vszBaseName[0] != '\0')
        {
        us |= bmBaseName;
        fOkayWrite &= FWriteNBytes(fhDest, vszBaseName, cbBase);
        fOkayWrite &= FWriteByte(fhDest, '\0');
        cbWritten += 1 + cbBase;
        }
    if (vszExtension[0] != '\0')
        {
        us |= bmExtension;
        /* REVIEW for " " should we write " \0" or "\0"? */
        fOkayWrite &= FWriteNBytes(fhDest, vszExtension, cbExt);
        fOkayWrite &= FWriteByte(fhDest, '\0');
        cbWritten += 1 + cbExt;
        }
    if (vszText != NULL)
        {
        us |= bmText;
        fOkayWrite &= FWriteUs(fhDest, vcbText);
        fOkayWrite &= FWriteNBytes(fhDest, vszText, vcbText);
        cbWritten += sizeof(USHORT) + vcbText;
        }

#ifdef EAS
    if (vuscbEAs > 0)
        {
        us |= bmEAs;
        fOkayWrite &= FWriteUs(fhDest, vuscbEAs);
        fOkayWrite &= FWriteNBytes(fhDest, vrgbEAs, vuscbEAs);
        cbWritten += sizeof(USHORT) + vuscbEAs;
        free(vrgbEAs);
        vrgbEAs = NULL;
        vuscbEAs = 0;
        }
#endif /* EAS */

      /* Patch unfilled fields in header (cbHeader and flags) */
    if (fOkayWrite && fhDest != -1 && ulSizeSeek != -1)
        {
        BOOL   fOkaySeek = (BOOL)TRUE;

        if (lseek(fhDest, ulSizeSeek, SEEK_SET) == -1)
            fOkaySeek = FALSE;

        fOkayWrite &= FWriteUs(fhDest, cbWritten);
        fOkayWrite &= FWriteUs(fhDest, us);

        if (lseek(fhDest, 0L, SEEK_END) == -1)
            fOkaySeek = FALSE;

        if (!fOkaySeek)
            {
            lseek(fhDest, libDestStart, SEEK_SET);
            chsize(fhDest, libDestStart);
            return(rcWriteSeekError);
            }
        }

      /* if there's an error, blows away file */
    if (!fOkayWrite && fhDest != -1)
        {
        lseek(fhDest, libDestStart, SEEK_SET);
        chsize(fhDest, libDestStart);
        return(rcWriteError);
        }

    return(cbWritten);
}


/*
**  BOOL  FPatchUs(int fh, LONG lib, USHORT us)
**
**  Patch the USHORT at lib offset of fh with the us value, but leave
**  the fh unchanged.  Return TRUE if okay, FALSE in failure.
*/
BOOL  FPatchUs(int fh, LONG lib, USHORT us)
{
    LONG   libSav;

    if (fh == -1 || (libSav = tell(fh)) == -1 || lseek(fh, lib, SEEK_SET) == -1)
        return(FALSE);

    if (!FWriteUs(fh, us))
        {
        lseek(fh, libSav, SEEK_SET);
        return(FALSE);
        }

    if (lseek(fh, libSav, SEEK_SET) == -1)
        return(FALSE);

    return((BOOL)TRUE);
}


/*
**  BOOL  FPatchUl(int fh, LONG lib, ULONG ul)
**
**  Patch the ULONG at lib offset of fh with the ul value, but leave
**  the fh unchanged.  Return TRUE if okay, FALSE in failure.
*/
BOOL  FPatchUl(int fh, LONG lib, ULONG ul)
{
    LONG   libSav;

    if (fh == -1 || (libSav = tell(fh)) == -1 || lseek(fh, lib, SEEK_SET) == -1)
        return(FALSE);

    if (!FWriteUl(fh, ul))
        {
        lseek(fh, libSav, SEEK_SET);
        return(FALSE);
        }

    if (lseek(fh, libSav, SEEK_SET) == -1)
        return(FALSE);

    return((BOOL)TRUE);
}


#ifdef NOT_USED
/*
**  USHORT  CbWriteFar(int fh, BYTE far * fp, USHORT cb)
**
**  write with far pointer
*/
USHORT  CbWriteFar(int fh, BYTE far * fp, USHORT cb)
{
    union  REGS  inregs, outregs;
    struct SREGS segregs;

    inregs.x.bx = fh;            /* file handle */
    inregs.x.cx = cb;            /* bytes to write */
    inregs.x.dx = FP_OFF(fp);    /* offset of buffer */
    segregs.ds  = FP_SEG(fp);    /* segment of buffer */
    inregs.h.ah = 0x40;          /* Write Handle */

    intdosx(&inregs, &outregs, &segregs);

    return((outregs.x.cflag) ? 0 : outregs.x.ax);
}
#endif /* NOT_USED */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\os2types.h ===
/* TS = NONE */
/*
**  OS2TYPES.H  --  Header containing types for Compression/Decompression
**    modules in Setup Toolkits.
*/


#ifdef WIN_VER
#undef min
#undef max
#undef NULL
#include "windows.h"
#endif /* WIN_VER */

#ifdef OS2_VER

#define INCL_NOPM
#define INCL_DOSDEVICES
#include <os2.h>

#else /* not OS2_VER */

/* C 5.1 doesn't have _fmemset--this one is compatible */

void _far * _far lcb_fmemset(void _far *dst, int c, size_t count);
#define _fmemset(a,b,c) lcb_fmemset(a,b,c)

typedef  unsigned char  BYTE;
#define  BOOL  int
#undef TRUE
#define  TRUE  ~0
#undef LONG
typedef  long           LONG;
#define  FALSE  0
#ifndef NULL
#define  NULL   0
#endif
typedef  int            SHORT;
typedef  unsigned int   USHORT;
typedef  unsigned long  ULONG;
typedef  char           CHAR;
typedef  unsigned char  UCHAR;

#endif /* OS2_VER */

#define  NIL   (-1L)
typedef  CHAR *         SZ;

typedef int (far *PFNWFROMW)(int);



#ifdef C700
#define  open          _open
#define  close         _close
#define  read          _read
#define  write         _write
#define  eof           _eof
#define  lseek         _lseek
#define  tell          _tell
#define  filelength    _filelength
#define  stat          _stat
#define  chsize        _chsize
#define  chmod         _chmod
#define  access        _access
#define  mkdir         _mkdir
#define  stricmp       _stricmp
#define  strdup        _strdup
#endif /* C700 */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\sutkcomp.h ===
/* TS = none */
/*
**  SUTKCOMP.H  --  internal header for compression module for Setup Toolkit.
*/

#include  "os2types.h"
#include  "retcodes.h"


/* The compressed file header format can be found in doc\header.doc. */


#define  cbMagic        8
#define  rgbMagicValue  "KWAJ\x88\xf0\x27\xd1"


/* bit masks for accessing flags in rgfsFlags[] */
#define  bmAnotherUsFlag   0x8000

/* First Bank of FsFlags */
#define  bmSrcLength       0x0001
#define  bmChecksum        0x0002
#define  bmArgs            0x0004
#define  bmBaseName        0x0008
#define  bmExtension       0x0010
#define  bmText            0x0020
#ifdef EAS
#define  bmEAs             0x0040
#endif /* EAS */

  /* global header info variables */
extern  SHORT   vwAlgType;
extern  LONG    vlcbSrcLength;
extern  BOOL    vfChecksum;
extern  USHORT  vusChecksum;
extern  USHORT  vcbArgs;
extern  BYTE *  vrgbArgs;
extern  CHAR    vszBaseName[9];
extern  CHAR    vszExtension[4];
extern  SZ      vszText;
extern  USHORT  vcbText;
#ifdef EAS
extern  CHAR    far *vfrgbEAs;
extern  CHAR    *vrgbEAs;
extern  USHORT  vuscbEAs;
#endif /* EAS */

  /* other global variables needed in toolkit layer */
extern  LONG    vlibChecksum;               /* patch location of usChecksum */
extern  LONG    vlibSrcLength;              /* patch location of lcbSrclength */


/*
**  File I/O macros.
**  FWriteXX returns TRUE if it works, FALSE on errors.
**    (Note:  fh == -1 is not considered an error in FWriteXX; it always
**    returns TRUE.  This happens when just calculating a length.)
*/

#define EOF  (-1)

extern  BYTE  _bWrite;
#define FWriteByte(fh, b) \
      ((BOOL)((fh == -1) ? TRUE : (_bWrite = b, write(fh, &_bWrite, 1) == 1)))
#define FWriteNBytes(fh, rgb, n) \
      ((BOOL)((fh == -1) ? TRUE : (write(fh, rgb, n) == (int)n)))
#define FWriteUs(fh, us) \
      ((BOOL)(FWriteByte(fh, (BYTE)us) && FWriteByte(fh, (BYTE)(us >> 8))))
#define FWriteUl(fh,ul) \
      ((BOOL)(FWriteByte(fh, (BYTE)ul) && FWriteByte(fh, (BYTE)(ul >> 8)) \
      && FWriteByte(fh, (BYTE)(ul >> 16)) && FWriteByte(fh,(BYTE) (ul >> 24))))


/***** EXTERN PROCS *****/

  /* routines from sutkcomp.c */
extern  SHORT   far  WReadHeaderInfo(int fhSrc);
extern  SHORT   far  CbWriteFileHeader(int fhDest);
extern  BOOL    far  FFreeHeaderInfo(void);
extern  BOOL         FReadNBytes(int fh, BYTE *pb, int n);
extern  BOOL         FReadUs(int fh, USHORT *pw);
extern  BOOL         FReadUl(int fh, ULONG *pul);
extern  BOOL         FPatchUs(int fh, LONG lib, USHORT us);
extern  BOOL         FPatchUl(int fh, LONG lib, ULONG ul);
extern  USHORT       CbReadFar(int fh, BYTE far * fp, USHORT cb);

#define FReadByte(fh, pb)  FReadNBytes(fh, pb, 1)


  /* routines from compress.c */
extern  LONG    far  LcbCompressToFile(SHORT wAlgType, int fhSrc, int fhDest,
                           LONG lcbDestMax);
extern  LONG    far  LcbCalculateCompressedLength(SHORT wAlgType, int fhSrc,
                           LONG lcbDestMax);


  /* routines from decomp.c */
extern  LONG    far  LcbDecompFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead,
                           BYTE far * fpbBuf, LONG lcbBuf, PFNWFROMW pfn,
                           int cProgTicks, PFNWFROMW pfnYield);
extern  LONG    far  LcbDecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbDecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart, BOOL fHeaderAlreadyRead);
extern  LONG    far  LcbCalculateDecompressedLength(int fhSrc,
                           BOOL fHeaderAlreadyRead);


  /* routines from zk1\zk1comp.c */
extern  LONG    Lcb_ZK1_CompressToFile(int fhSrc, int fhDest,
                           LONG lcbDestMax);

  /* routines from zk1\zk1deco.c */
extern  LONG    Lcb_ZK1_DecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                           LONG libStart);
extern  LONG    Lcb_ZK1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart);

  /* routines from zk1\zk1share.c */
extern  void    WriteOutBuff(BYTE bToAdd);
extern  BOOL    FAllocateGlobals(LONG lcbDestMax, BOOL fCompressing);
extern  void    FreeGlobals(void);
extern  USHORT  ReadByte(int fh);

  /* routines from jjj1\jjj1comp.c */
extern  LONG    Lcb_JJJ1_CompressToFile(int fhSrc, int fhDest,
                           LONG lcbDestMax);

  /* routines from jjj1\jjj1deco.c */
extern  LONG    Lcb_JJJ1_DecompressToFile(int fhSrc, int fhDest,
                           LONG lcbDestMax, LONG libStart,
                           BYTE far * fpbBuf, LONG lcbBuf);
extern  LONG    Lcb_JJJ1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf,
                           LONG lcbBuf, LONG libStart);

  /* routines from nc_xor1\nc_xor1.c */
extern  LONG    Lcb_NC_XOR1_StraightCopy(int fhSrc, int fhDest, LONG lcbDestMax,
                           BYTE far * fpbBufDest, LONG libStart, BOOL fXor);

  /* Buffered Read/Write Stuff */
#define WriteByte(b) \
        if (fpbOutBufCur < fpbOutBufEnd) *fpbOutBufCur++=b; else WriteOutBuff(b);
#define WriteUs(us) \
        WriteByte((BYTE)us); WriteByte((BYTE)us >> sizeof(BYTE))
#define WriteUl(ul) \
        WriteByte((BYTE)ul); \
        WriteByte((BYTE)ul >> sizeof(BYTE));  \
        WriteByte((BYTE)ul >> (2 * sizeof(BYTE))); \
        WriteByte((BYTE)ul >> (3 * sizeof(BYTE)))

extern  BOOL        fDestFull;
extern  BOOL        fWriteError;
extern  BYTE far *  fpbBufDest;
extern  int         fhSrcGlobal;
extern  LONG        lcbDest;
extern  LONG        lcbDestStop;
extern  LONG        lcbSkipOut;
extern  int         fhDestGlobal;

extern  BYTE far *  fpbOutBuf;
extern  BYTE far *  fpbOutBufCur;
extern  BYTE far *  fpbOutBufEnd;

extern  BYTE far *  fpbInBuf;
extern  BYTE far *  fpbInBufCur;
extern  BYTE far *  fpbInBufEnd;

extern  BOOL  FAllocateReadWriteGlobals(LONG lcbDestMax);
extern  void  FreeReadWriteGlobals(void);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\retcodes.h ===
/* TS = NONE */
/*
**  RETCODES.H  --  Return Codes for compression module for Setup Toolkit.
**
**  If you add return codes, please update ExitErrorMsgRc in tools\tlshare.c
*/


 
  /* error codes - quick check is anything less than rcNoError */
#define  rcNoError                 0     /* no errors */
#define  rcNoHeader              (-1)    /* no header (eg no magic value) */
#define  rcUnknownAlgType        (-2)    /* wAlgType doesn't match knowns */
#define  rcBadHeader             (-3)    /* header too short or bad value */
#define  rcFilenamesTooLong      (-4)    /* filenames bigger than 8.3 */

#define  rcReadError             (-5)    /* reading error with fhSrc */
#define  rcReadSeekError         (-6)    /* seeking error with fhSrc */

#define  rcWriteError            (-7)    /* writing error with fhDest */
#define  rcWriteSeekError        (-8)    /* seeking error with fhDest */
#define  rcDestPatchError        (-9)    /* patching error with fhDest */

#define  rcCompChecksumBad      (-10)    /* compressed checksums mismatch */
#define  rcDecompChecksumBad    (-11)    /* decompressed checksums mismatch */
#define  rcCompLengthBad        (-12)    /* compressed length mismatch */
#define  rcDecompLengthBad      (-13)    /* decompressed length mismatch */

#define  rcGenericCompError     (-14)    /* internal compression error */
#define  rcGenericDecompError   (-15)    /* internal decompression error */

#define  rcSplitSizeTooSmall    (-16)    /* split size too small for header */

#define  rcOutOfMemory          (-17)    /* unable to alloc a buffer */

#define  rcZeckSplitFile        (-18)    /* unable to handle Zeck-Split file */


  /* each code below here has a standard header */
#define  wAlgTypeNil             (-1)    /* no algorithm type (never found) */
#define  wAlgTypeNoCompress        0     /* no compression, straight copy */
#define  wAlgTypeXOR1              1     /* straight copying XORing each byte */
#define  wAlgTypeZK1               2     /* Steve Zeck compression algorithm */
#define  wAlgTypeJJJ1              3     /* Jeff J. Johnson algorithm */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\sutkdeco.c ===
/* TS = none */
/*
**  SUTKDECO.C  --  general decompression routines for
**                  Setup Toolkits.  Handles all header manipulation.
*/

#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <dos.h>

#include "sutkcomp.h"


  /* global header info variables and default values */
extern SHORT   vwAlgType;
extern LONG    vlcbSrcLength;
extern BOOL    vfChecksum;
extern USHORT  vusChecksum;
extern USHORT  vcbArgs;
extern BYTE *  vrgbArgs;
extern CHAR    vszBaseName[9];
extern CHAR    vszExtension[4];
extern SZ      vszText;
extern USHORT  vcbText;
#ifdef EAS
extern CHAR    *vrgbEAs;
extern CHAR    far *vfrgbEAs;
extern USHORT  vuscbEAs;
#endif /* EAS */


#ifdef WIN2_VER
extern HANDLE  vhRgbArgs;
extern HANDLE  vhSzText;
#endif /* WIN2_VER */


  /* forward declarations of local routines */
extern  SHORT   far WReadHeaderInfo(int fhSrc);
extern  BOOL        FReadNBytes(int fh, BYTE *pb, int n);
extern  BOOL        FReadUs(int fh, USHORT *pw);
extern  BOOL        FReadUl(int fh, ULONG *pul);

#ifdef ZECKFORMAT
/* This is the magic value for non-split Zeck files.  Since we can't handle
   Zeck split files, we don't try to understand that form of header. */
#define rgbZeckMagicValue  "\x53\x5a\x20\x88\xf0\x27\x33\xd1"
BOOL   vfZeckFormat = FALSE;
#endif /* ZECKFORMAT */


/*
**  SHORT  far  WReadHeaderInfo(int fhSrc)
**  
**  Determine whether the given file has a header in our format, and if
**  so, extract the information from it into globals.  If the 8 magic bytes
**  at the beginning of the file are correct, we assume it's a compressed
**  file and we give errors if something is wrong with the rest of the
**  header (eg the agorithm is not a known type, or something is wrong with
**  the format of the rest of the header.)  If the 8 magic bytes don't match,
**  we assume it's uncompressed.
**  (Notice that the file could also be uncompressed but still have a
**  header.  The wAlgType in the header would be wAlgTypeNoCompress.)
**  Hitting EOF in reading the magic bytes is not an error, but premature
**  EOF while reading any of the rest of the header is an error.
**
**  Returns the algorithm type used to compress the file, or a return code
**  indicating an error.  If the header is read sucessfully, this procedure
**  may allocate memory to store some of the header information; the caller
**  should always call FFreeHeaderInfo() after the decompression has finished.
**  WReadHeaderInfo calls FFreeHeaderInfo before reading and on errors, so
**  the headers of any number of files can be read and FFreeHeaderInfo need
**  only be called after the last file is read.
**
**  Seeks fhSrc to the byte after the header, if there was a header.
**  If there was no header, resets fhSrc to its original value.
*/
SHORT  far  WReadHeaderInfo(int fhSrc)
{
    USHORT  us;
    USHORT  cbHeader;
    USHORT  usFlags;
    SHORT   rcError;
    LONG    libSav;
    BYTE    b;
    BYTE    rgb[8];

    FFreeHeaderInfo();

    if (fhSrc == -1)
        return(rcReadError);

    if ((libSav = tell(fhSrc)) == NIL)
        return(rcReadSeekError);

      /* read first 8 required bytes */
    if (!FReadNBytes(fhSrc, rgb, 8))
        {
        rcError = rcNoHeader;
        goto ErrorReturn;
        }

      /* check magic number */
    for (us = 0;  us < cbMagic;  us++)
        {
        if (rgb[us] != (BYTE)(*(rgbMagicValue + us)))
            break;
        }
    if (us != cbMagic)   /* magic bytes didn't match */
        {
#ifdef ZECKFORMAT
        for (us = 0;  us < cbMagic;  us++)   /* check Zeck magic bytes */
            {
            if (rgb[us] != (BYTE)(*(rgbZeckMagicValue + us)))
                break;
            }
        if (us == cbMagic - 1)  /* only last byte is different -- split file */
            {
            /* Zeck split file */
            rcError = rcZeckSplitFile;
            goto ErrorReturn;
            }
        if (us == cbMagic && FReadUl(fhSrc, &vlcbSrcLength))
            {
            vfZeckFormat = (BOOL)TRUE;
            vwAlgType = wAlgTypeZK1;
            return(vwAlgType);
            }
#endif /* ZECKFORMAT */
          /* must be an uncompressed file with no header */
        rcError = rcNoHeader;
        goto ErrorReturn;
        }

      /* read next 6 required bytes */
    if (!FReadNBytes(fhSrc, rgb, 6))
        goto ReadErrorReturn;

      /* get algorithm type */
    us = rgb[0] + (rgb[1] << 8);

    /* REVIEW: this sleazy thing checks to make sure we have a valid alg type
       for the flags that are currently turned on.  REWRITE THIS. */
    if (FALSE
#ifdef ZK1
            || (us == wAlgTypeZK1)
#endif /* ZK1 */
#ifdef JJJ1
            || (us == wAlgTypeJJJ1)
#endif /* JJJ1 */
#ifdef NC_XOR1
            || (us == wAlgTypeNoCompress)
            || (us == wAlgTypeXOR1)
#endif /* NC_XOR1 */
            )
        vwAlgType = us;
    else
        {
        rcError = rcUnknownAlgType;
        goto ErrorReturn;
        }

      /* get size of header; save for later Seek */
    cbHeader = rgb[2] + (rgb[3] << 8);

      /* get first flag word */
    usFlags = rgb[4] + (rgb[5] << 8);

      /* then read the optional components that had their flags set */
    if (usFlags & bmSrcLength)
        {
        if (!FReadUl(fhSrc, &vlcbSrcLength))
            goto ReadErrorReturn;
        }
    if (usFlags & bmChecksum)
        {
        vfChecksum = (BOOL)TRUE;
        if (!FReadUs(fhSrc, &vusChecksum))
            goto ReadErrorReturn;
        }
    if (usFlags & bmArgs)
        {
        if (!FReadUs(fhSrc, &vcbArgs))
            goto ReadErrorReturn;
        if (vcbArgs == 0)
            {
            rcError = rcBadHeader;
            goto ErrorReturn;
            }
#ifndef WIN2_VER
        vrgbArgs = (BYTE *)malloc(vcbArgs * sizeof(BYTE));
#else /* WIN2_VER */
        if ((vhRgbArgs = LocalAlloc(LMEM_FIXED, vcbArgs * sizeof(BYTE)))
                                                                        != NULL)
            if ((vszText = (BYTE *)LocalLock(vhRgbArgs)) == NULL)
                {
                LocalFree(vhRgbArgs);
                vhRgbArgs = NULL;
                }
#endif /* WIN2_VER */
        if (vrgbArgs == NULL)
            {
            rcError = rcOutOfMemory;
            goto ErrorReturn;
            }
        if (!FReadNBytes(fhSrc, (BYTE *)vrgbArgs, vcbArgs))
            goto ReadErrorReturn;
        }

      /* handle filename strings */
    if (usFlags & bmBaseName)
        {
        us = 0;
        b = 'Z';
        while (FReadByte(fhSrc, &b) && ((vszBaseName[us] = b) != '\0'))
            {
            if (us < 8)
                us++;
            else
                {
                rcError = rcFilenamesTooLong;
                goto ErrorReturn;
                }
            }
        if (b != '\0')
            goto ReadErrorReturn;
        }
    if (usFlags & bmExtension)
        {
        us = 0;
        b = 'Z';
        while (FReadByte(fhSrc, &b) && ((vszExtension[us] = b) != '\0'))
            {
            if (us < 3)
                us++;
            else
                {
                rcError = rcFilenamesTooLong;
                goto ErrorReturn;
                }
            }
        if (b != '\0')
            goto ReadErrorReturn;
        }
    if (usFlags & bmText)
        {
        if (!FReadUs(fhSrc, &vcbText))
            goto ReadErrorReturn;
        if (vcbText == 0)
            {
            rcError = rcBadHeader;
            goto ErrorReturn;
            }
#ifndef WIN2_VER
        vszText = (SZ)malloc(vcbText * sizeof(CHAR));
#else /* WIN2_VER */
        if ((vhSzText = LocalAlloc(LMEM_FIXED, vcbText * sizeof(CHAR))) != NULL)
            if ((vszText = (SZ)LocalLock(vhSzText)) == NULL)
                {
                LocalFree(vhSzText);
                vhSzText = NULL;
                }
#endif /* WIN2_VER */
        if (vszText == NULL)
            {
            rcError = rcOutOfMemory;
            goto ErrorReturn;
            }
        if (!FReadNBytes(fhSrc, (BYTE *)vszText, vcbText))
            goto ReadErrorReturn;
        }

#ifdef EAS
    if (usFlags & bmEAs)
        {
        if (!FReadNBytes(fhSrc, (BYTE *) &vuscbEAs, sizeof(USHORT)))
            goto ReadErrorReturn;
#ifdef OS2_VER
        vfrgbEAs = _fmalloc(vuscbEAs);
        if (!vfrgbEAs)
            {
            if (lseek(fhSrc, (LONG)vuscbEAs, SEEK_CUR) == -1)
                {
                rcError = rcReadSeekError;
                goto ErrorReturn;
                }
            }
        else
            {
            USHORT cbRead;

            if (DosRead(fhSrc, vfrgbEAs, vuscbEAs, &cbRead))
                {
                _ffree(vfrgbEAs);
                vfrgbEAs = NULL;
                vuscbEAs = 0;
                goto ReadErrorReturn;
                }    
            }
#else
        if (lseek(fhSrc, (LONG)vuscbEAs, SEEK_CUR) == -1)
            {
            rcError = rcReadSeekError;
            goto ErrorReturn;
            }
#endif /* OS2_VER */
        }
#endif /* EAS */

      /* skip any remaining header components that we don't grok */
    if (lseek(fhSrc, (LONG)cbHeader, SEEK_SET) == -1)
        {
        rcError = rcReadSeekError;
        goto ErrorReturn;
        }

    return(vwAlgType);

    /* errors that cause jumps to here have a trashed header (ie magic
       bytes were correct but something else was bad) or a read failure,
       but it is not an error if header is missing entirely */
ReadErrorReturn:
    if (eof(fhSrc))
        rcError = rcBadHeader;
    else
        rcError = rcReadError;

ErrorReturn:
    FFreeHeaderInfo();
    lseek(fhSrc, libSav, SEEK_SET);
    return(rcError);
}


/*
**  BOOL  FReadNBytes(int fh, BYTE * pb, int n)
**
**  Reads n bytes from file handle fh into buffer pointed to by pb.
**  Returns TRUE if read was sucessful, FALSE if not (or if EOF.)
*/
BOOL  FReadNBytes(int fh, BYTE * pb, int n)
{
    if (read(fh, pb, n) == n)
        return((BOOL)TRUE);
    else
        return(FALSE);
}


/*
**  BOOL  FReadUs(int fh, USHORT * pw)
**
**  Reads a short word from file handle fh into word pointed to by pw.
**  Returns TRUE if read was sucessful, FALSE if not (or if EOF.)
*/
BOOL  FReadUs(int fh, USHORT * pw)
{
    BYTE  rgb[2];

    if (FReadNBytes(fh, rgb, 2))
        {
        *pw = rgb[0] + (rgb[1] << 8);
        return((BOOL)TRUE);
        }
    return(FALSE);
}


/*
**  BOOL  FReadUl(int fh, ULONG * pul)
**
**  Reads a long from file handle fh into the long pointed to by pul.
**  Returns TRUE if read was sucessful, FALSE if not (or if EOF.)
*/
BOOL  FReadUl(int fh, ULONG * pul)
{
    BYTE   rgb[4];
    ULONG  ul;
    ULONG  ulShift;

    if (!FReadNBytes(fh, rgb, 4))
        return(FALSE);
    ul = rgb[0];

    ulShift = rgb[1];
    ul = (ulShift << 8) + ul;

    ulShift = rgb[2];
    ul = (ulShift << 16) + ul;

    ulShift = rgb[3];
    ul = (ulShift << 24) + ul;

    *pul = ul;
    return((BOOL)TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\sutkshar.c ===
/* TS = none */
/*
**  SUTKSHAR.C  --  general shared comp/decompression routines for
**                  Setup Toolkits.  Handles all header manipulation.
*/

#include <io.h>
#include <stdlib.h>
#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <dos.h>
#include <ctype.h>
#include <fcntl.h>

#include "sutkcomp.h"

#ifdef WIN_VER
HANDLE hOutBuf = NULL;
#endif /* WIN_VER */

BYTE _bWrite = 0;

BOOL vfUserCancel = FALSE;

BOOL FTerminateDecomp(void)
{
    vfUserCancel = TRUE;
    return(TRUE);
}

#include "setjmp.h"

BOOL    fJmpEnvSet = FALSE;
jmp_buf jmpEnv = { NULL };


  /* global header info variables and default values */
SHORT   vwAlgType =        wAlgTypeNil;
LONG    vlcbSrcLength =    NIL;
BOOL    vfChecksum =       FALSE;
USHORT  vusChecksum =      0;
USHORT  vcbArgs =          0;
BYTE *  vrgbArgs =         NULL;
CHAR    vszBaseName[9] =   "\0";
CHAR    vszExtension[4] =  "\0";
SZ      vszText =          NULL;
USHORT  vcbText =          0;
#ifdef EAS
CHAR *  vrgbEAs =          NULL;
CHAR far *  vfrgbEAs =     NULL;
USHORT  vuscbEAs =         0;
#endif /* EAS */

  /* global variables needed within toolkit layer */
LONG    vlibChecksum =     NIL;
LONG    vlibSrcLength =    NIL;

  /* global variables needed for Progress Gizmo Callback */
PFNWFROMW vpfn       = NULL;
PFNWFROMW vpfnYield  = NULL;
int       vcTicks    = 0;
LONG      vcbPerTick = 0L;
LONG      vcbCur     = 0L;


  /* forward declarations of local routines */
extern  BOOL    far FFreeHeaderInfo(void);



/*
**  BOOL  far  FFreeHeaderInfo(void)
**
**  Frees any allocated global header structures, and resets all header
**  variables to their default values.  Always returns TRUE.
**
**  This procedure is called at the beginning of WReadHeaderInfo, so the
**  user only needs to directly call this procedure after finishing reading
**  the last file to be decompressed.
*/
BOOL  far  FFreeHeaderInfo(void)
{
      /* free any space used */
    if (vrgbArgs != NULL)
        free(vrgbArgs);
    if (vszText != NULL)
        free(vszText);
#ifdef EAS
    if (vrgbEAs != NULL)
        free(vrgbEAs);
    if (vfrgbEAs != NULL)
        _ffree(vrgbEAs);
#endif /* EAS */

      /* reset to defaults */
    vwAlgType =        wAlgTypeNil;
    vlcbSrcLength =    NIL; 
    vfChecksum =       FALSE;
    vusChecksum =      0;
    vcbArgs =          0;
    vrgbArgs =         NULL;
    vszBaseName[0] =   '\0';
    vszExtension[0] =  '\0';
    vszText =          NULL;
    vcbText =          0;
#ifdef EAS
    vrgbEAs =          NULL;
    vfrgbEAs=          NULL;
    vuscbEAs=          0;
#endif /* EAS */

    return((BOOL)TRUE);
}


  /* Buffered Read/Write stuff */
static	void	  fmemmove(BYTE far * fpb1, BYTE far * fpb2, USHORT cb);
static	BYTE far *NormalizePtr(BYTE far *fp);
static  unsigned  readf(int fh, CHAR far * fp, unsigned uLen);
static  unsigned  writef(int fh, CHAR far * fp, unsigned uLen);

LONG        lcbDest      = 0L;     /* bytes already emptied from output buf */
LONG        lcbDestStop  = 0L;     /* when to quit, NIL means run to EOF */
BOOL        fWriteError  = FALSE;
BOOL        fDestFull    = FALSE;  /* set when we reach lcbDestStop */
LONG        lcbSkipOut   = 0L;     /* bytes to skip (seek) before writing */
int         fhDestGlobal = 0;      /* output file */
int         fhSrcGlobal  = 0;      /* used by UnpackZK1() for input */
BYTE far *  fpbBufDest   = NULL;   /* buffer to use instead of a file */

BYTE far *  fpbOutBuf    = NULL;
BYTE far *  fpbOutBufCur = NULL;
BYTE far *  fpbOutBufEnd = NULL;

BYTE far *  fpbInBuf     = NULL;
BYTE far *  fpbInBufCur  = NULL;
BYTE far *  fpbInBufEnd  = NULL;


/*
**  void  WriteOutBuff(BYTE bToAdd)
**
**  Empty the output buffer.  Set fWriteError if a problem is encountered.
**  Set fDestFull if we have surpassed lcbDestStop.  Increment lcbDest by
**  how many bytes are emptied.  There are three cases of how to empty the
**  bytes:
**    1) written to a buffer                   [fpbBufDest != NULL]
**    2) written to a file                     [fhDestGlobal != -1]
**    3) not written at all (just counting!)   [else]
*/
void WriteOutBuff(BYTE bToAdd)
{
    USHORT   cbWrite;
    USHORT   cbSkip = 0;      /* how many bytes of the current buffer to skip */

    cbWrite = fpbOutBufCur - fpbOutBuf;                    /* bytes in buffer */

    if (lcbDestStop != NIL && (LONG)cbWrite >= (lcbDestStop - lcbDest))
        {
        cbWrite = (USHORT)(lcbDestStop - lcbDest);              /* stop early */
        fDestFull = (BOOL)TRUE;
        }

    if (lcbDestStop != NIL && lcbDest > lcbDestStop)      /* already too many */
        {
        lcbDest = 0L;
        fWriteError = fDestFull = (BOOL)TRUE;
        }
    
    if (lcbDest + cbWrite > lcbSkipOut)    /* do we actually need to transfer */
        {
        if (lcbSkipOut > lcbDest)                  /* skip a few at beginning */
            cbWrite -= (cbSkip = (USHORT)(lcbSkipOut - lcbDest));

        if (fhDestGlobal != -1)                              /* write to file */
            {
            if (cbWrite != writef(fhDestGlobal, fpbOutBuf + cbSkip, cbWrite))
                {
                lcbDest = 0L;
                fWriteError = fDestFull = (BOOL)TRUE;
                }
            }
        else if (fpbBufDest != NULL)                       /* write to buffer */
	    {
	    fpbBufDest = NormalizePtr(fpbBufDest);
            fmemmove(fpbBufDest, fpbOutBuf + cbSkip, cbWrite);
            fpbBufDest += cbWrite;      /* fix fpbBufDest so next write works */
            }
        }
    /* case 3 - just counting - falls through */

    if (!fWriteError)
        lcbDest += cbWrite + cbSkip;

    fpbOutBufCur = fpbOutBuf;

    *fpbOutBufCur++ = bToAdd;
}


/*
**  static  void  fmemmove(BYTE far * fpb1, BYTE far * fpb2, USHORT cb)
**
**  a far version of memmove
*/
static  void  fmemmove(BYTE far * fpb1, BYTE far * fpb2, USHORT cb)
{
    if (fpb1 == fpb2 || cb == 0)
        return;

    if (fpb1 < fpb2)
        for ( ; cb-- > 0; )
            *(fpb1++) = *(fpb2++);
    else
        {
        fpb1 += cb - 1;
        fpb2 += cb - 1;
        for ( ; cb-- > 0; )
            *(fpb1--) = *(fpb2--);
        }
}

static BYTE far *NormalizePtr(BYTE far *fp)
{
    FP_SEG(fp) += FP_OFF(fp) >> 4;
    FP_OFF(fp) &= 0x000F;

    return(fp);
}


/*
**  BOOL  FAllocateReadWriteGlobals(LONG lcbDestMax)
*/
BOOL  FAllocateReadWriteGlobals(LONG lcbDestMax)
{
    USHORT  cbBuf;

    lcbDest = 0L;
    lcbDestStop = lcbDestMax;
    fpbBufDest = NULL;
    fWriteError = FALSE;
    fDestFull = FALSE;

    /* allocate the biggest possible buffer, then split between read & write */
    cbBuf = ((USHORT)126 * 512);
#ifndef WIN_VER
    while (cbBuf >= (3 * 512)
           && (fpbOutBuf = (BYTE far *)_fmalloc(cbBuf)) == NULL)
        cbBuf -= (3 * 512);
#else  /* WIN_VER */
    GlobalCompact((DWORD)cbBuf);
    while (cbBuf >= (3 * 512)
           && (hOutBuf = GlobalAlloc(GHND, (DWORD)cbBuf)) == NULL)
        cbBuf -= (3 * 512);
    if (hOutBuf != NULL)
        fpbOutBuf = (BYTE far *)GlobalLock(hOutBuf);
    else
        fpbOutBuf = NULL;
#endif /* WIN_VER */

    if (fpbOutBuf == NULL)
        {
        FreeReadWriteGlobals();
        return(FALSE);
        }

    fpbInBufEnd = fpbOutBuf + cbBuf;
    fpbInBufCur = fpbInBufEnd;   /* to force a buffer refill the first time */
    fpbOutBufCur = fpbOutBuf;

    cbBuf /= 512;
    cbBuf /= 3;
    cbBuf *= 512;

    /* REVIEW if cbBuf > libStart + lcbBuf in DecompToBuffer case then
    **   should be able to quit earlier by limiting OutBuf */

    fpbOutBufEnd = fpbOutBuf + cbBuf;
    fpbInBuf = fpbOutBufEnd;

    return((BOOL)TRUE);
}


/*
**  void  FreeReadWriteGlobals(void)
*/
void FreeReadWriteGlobals(void)
{
#ifndef WIN_VER
    if (fpbOutBuf != NULL)
        {
        _ffree(fpbOutBuf);
        fpbOutBuf = NULL;
        }
#else  /* WIN_VER */
    if (hOutBuf != NULL)
        {
        GlobalUnlock(hOutBuf);
        GlobalFree(hOutBuf);
        hOutBuf = NULL;
        fpbOutBuf = NULL;
        }
#endif /* WIN_VER */
}



USHORT  ReadByte(fh)
int fh;
{
    if (fpbInBufCur >= fpbInBufEnd)
        {
        USHORT   cb;

          /* Progress Gizmo */
        if (vcTicks <= 0)
            vcbCur = 0L;
        else if (vcbCur > vcbPerTick && vpfn != NULL)
            {
            long lcTicks = vcbCur / vcbPerTick;
            int  cTicks  = (int)(lcTicks & 0x00007FFF);

            vcbCur -= (cTicks * vcbPerTick);
            if (cTicks > vcTicks)
                cTicks = vcTicks;
            if (!((*vpfn)(cTicks)))
                vpfn = NULL;
            vcTicks -= cTicks;
            }

        if ((cb = readf(fh, fpbInBuf, (USHORT)(fpbInBufEnd - fpbInBuf))) == 0)
            return((USHORT)EOF);
        fpbInBufCur = fpbInBuf;
        fpbInBufEnd = fpbInBuf + cb;

        vcbCur += cb;
        }

    return(*fpbInBufCur++);
}


/* read with far pointer; returns count read if successful, 0 if error */
static unsigned readf(int fh, CHAR far * fp, unsigned uLen)
{
    unsigned  uResult;

    if (vpfnYield != NULL)
        (*vpfnYield)(0);

#ifdef OS2_VER
    if (DosRead((HFILE)fh, (PVOID)fp, (USHORT)uLen, (PUSHORT)(&uResult)))
#else  /* DOS_VER */
    if (_dos_read(fh, fp, uLen, &uResult))
#endif /* OS2_VER */
        {
        if (fJmpEnvSet)
            longjmp(jmpEnv, rcReadError);
        return(0);
        }

    if (vpfnYield != NULL)
        (*vpfnYield)(0);

    return(uResult);
}


/* write with far pointer; returns count written if successful, 0 if error */
static unsigned writef(int fh, CHAR far * fp, unsigned uLen)
{
    unsigned  uResult;

#ifdef OS2_VER
    if (DosWrite(fh, (PVOID)fp, uLen, (PUSHORT)(&uResult)))
#else /* DOS_VER */
    if (_dos_write(fh, fp, uLen, &uResult))
#endif /* OS2_VER */
        {
        if (fJmpEnvSet)
            longjmp(jmpEnv, rcWriteError);
        return(0);
        }
    return(uResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\jjj1\jjj1.h ===
/*
**  JJJ1.H -- Defines and externs for JJJ1 compression/decompression
**
**  Code adapted from ZK1 code by Jeff Johnson, 10/12/90 added a triple
**  huffman compressor to the window compressor
*/

#include "..\lzss\lz.h"


typedef struct _HTREE 
{
   int   parent, left, right;
   long  weight;
} HTREE;

typedef struct _CODETABLE
{
   unsigned int  usCode;
   BYTE          cbCode, nextCode;
} CODETABLE;

#define  HUFFMAN  0

#define  NOTABLE      0
#define  COMPRESS1BIT 1
#define  COMPRESS2BIT 2
#define  COMPRESSNONE 3

#define  cbLitMax   32

  /***** EXTERNS *****/
extern  USHORT      iPowers[16];

extern long far *   fpbAnalysis4a;
extern long far *   fpbAnalysis4b;
extern long far *   fpbAnalysis5;
extern long far *   fpbAnalysis6;
extern long far *   fpbAnalysis8;

extern HTREE far *  fphtArr;

extern CODETABLE far *  fpct4a;
extern CODETABLE far *  fpct4b;
extern CODETABLE far *  fpct5;
extern CODETABLE far *  fpct6;
extern CODETABLE far *  fpct8;

extern BYTE far *       fpbLookup4a;
extern BYTE far *       fpbLookup4b;
extern BYTE far *       fpbLookup5;
extern BYTE far *       fpbLookup6;
extern BYTE far *       fpbLookup8;

extern  BOOL  FAllocateJJJGlobals(LONG lcbDestMax, BOOL fCompressing);
extern  void  FreeJJJGlobals(void);
extern  BOOL  BuildCodeTable(CODETABLE far *fpct, int cbct);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\jjj1\jjj1comp.c ===
/*
**  JJJ1COMP.C  --  JJJ1 Compression module - first implementation
*/

/*  This code was written by modifying the Zeck compression code
**  and adding a triple huffman compressor.  The results are much
**  smaller.  This was done by Jeff Johnson, 10/15/90 to accomodate
**  Microsoft Excel 3.0.
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>

#include "..\sutkcomp.h"

#ifdef OS2SU
#include <doscalls.h>
#endif

#include "jjj1.h"

#include "setjmp.h"

extern BOOL    fJmpEnvSet;
extern jmp_buf jmpEnv;



// Globals used by compression
BYTE  bPassCnt = 0;
long  lcbSrcStart;

BYTE    rgbLitBuf[cbLitMax];
USHORT  ibLitBuf=0;
BYTE    bBitHold = 0, cbBitHold=0;

void  WriteBits(unsigned int val, unsigned int cnt)
{
    if (cnt + cbBitHold <= 8)
        {
        bBitHold <<= (cnt);
        bBitHold  |= (val) & iPowers[cnt];
        if ((cbBitHold += (cnt)) == 8)
            {
            WriteByte(bBitHold);
            cbBitHold = 0;
            }
        }
    else
        {
        bBitHold <<= 8 - cbBitHold;
        bBitHold  |= (val >> (cnt -= (8 - cbBitHold))) & iPowers[8 - cbBitHold];
        WriteByte(bBitHold);
        if (cnt >= 8)
            WriteByte((BYTE) (val >> (cnt -= 8)));
        cbBitHold = (BYTE) cnt;
        bBitHold = (BYTE) val;
        }
}

#define WriteHuffman4a(val) WriteBits(fpct4a[val].usCode,fpct4a[val].cbCode)
#define WriteHuffman4b(val) WriteBits(fpct4b[val].usCode,fpct4b[val].cbCode)
#define WriteHuffman5(val)  WriteBits(fpct5 [val].usCode,fpct5 [val].cbCode)
#define WriteHuffman6(val)  WriteBits(fpct6 [val].usCode,fpct6 [val].cbCode)
#define WriteHuffman8(val)  WriteBits(fpct8 [val].usCode,fpct8 [val].cbCode)


void  InitAnalyze()
{
    int  cnt;

    for (cnt = 0; cnt < 256; cnt++)
        fpbAnalysis8[cnt] = 0;
    for (cnt = 0; cnt < 64; cnt++)
        fpbAnalysis6[cnt] = 0;
    for (cnt = 0; cnt < 32; cnt++)
        fpbAnalysis5[cnt] = 0;
    for (cnt = 0; cnt < 16; cnt++)
        fpbAnalysis4a[cnt] = fpbAnalysis4b[cnt] = 0;
}


int  TraverseHTree(int curpos, CODETABLE far *fpct, int depth)
{
    int  dep1, dep2;

    if (fphtArr[curpos].left == -1) //leaf node
        {
        fpct[curpos].cbCode = (BYTE) depth;
        return(depth);
        }
    dep1 = TraverseHTree(fphtArr[curpos].left , fpct, depth+1);
    dep2 = TraverseHTree(fphtArr[curpos].right, fpct, depth+1);
    if (dep1 > dep2)
        return(dep1);
    else
        return(dep2);
}


void  BuildHTree(long far *fpbInWgt, int cbInWgt, CODETABLE far *fpct)
{
    int   cnt, passcnt, ndxsmall, ndxsmallest, unused;
    long  small, smallest;

LStartBuildHTree:
    unused = 0;
    for (cnt = 0; cnt < cbInWgt; cnt++)
        fpct[cnt].cbCode = 0;

    for (cnt = 0; cnt < cbInWgt; cnt++)
        {
        fphtArr[cnt].left = fphtArr[cnt].right = fphtArr[cnt].parent = -1;
        if ((fphtArr[cnt].weight = fpbInWgt[cnt]) == 0) // Don't give it a code
            {
            fphtArr[cnt].parent = -2;
            unused++;
            }
        }

    if (unused >= cbInWgt - 1) // Can't build a proper tree
        {
        if (unused == cbInWgt) // No entries, just assign 1-bit to last 2 codes
            fpct[cbInWgt-1].cbCode = fpct[cbInWgt-2].cbCode = 1;
        else
            {
            cnt = -1;
            while (!fpbInWgt[++cnt]);
                if (cnt)
                    fpct[cnt].cbCode = fpct[cnt-1].cbCode = 1;
                else
                    fpct[cnt].cbCode = fpct[cnt+1].cbCode = 1;
            }
        return;
        }
       
    for (passcnt = 0; passcnt < cbInWgt - unused - 1; passcnt++)
        {
        small = smallest = 1L << 30;
        for (cnt = 0; cnt < cbInWgt + passcnt; cnt++)
            {
            if ((fphtArr[cnt].weight < small) && (fphtArr[cnt].parent == -1))
                {
                if (fphtArr[cnt].weight < smallest)
                    {
                    small = smallest;
                    ndxsmall = ndxsmallest;
                    smallest = fphtArr[cnt].weight;
                    ndxsmallest = cnt;
                    }
                else
                    {
                    small = fphtArr[cnt].weight;
                    ndxsmall = cnt;
                    }
                }
            }
        fphtArr[ndxsmall].parent = fphtArr[ndxsmallest].parent = cnt;
        fphtArr[cnt].weight = small+smallest;
        fphtArr[cnt].left   = ndxsmallest;
        fphtArr[cnt].right  = ndxsmall;
        fphtArr[cnt].parent = -1;
        }

    for (cnt = 0; cnt < cbInWgt; cnt++)
        fpct[cnt].cbCode = 0;

    if (TraverseHTree(2 * cbInWgt - unused - 2, fpct, 0) < 16)
        return;

    small = 1;
    smallest = 1L << 30;
    for (cnt = 0; cnt < cbInWgt; cnt++)
        {
        long  wgt = fpbInWgt[cnt];

        if (wgt > 0L)
            {
            if (wgt < smallest)
                {
                small = smallest;
                smallest = wgt;
                }
            else if (wgt > smallest && wgt < small)
                small = wgt;
            }
        }

    if (smallest >= small || smallest == 0L)
        return;    /* ERROR */

    for (cnt = 0; cnt < cbInWgt; cnt++)
        {
        if (fpbInWgt[cnt] == smallest)
            fpbInWgt[cnt] = small;
        }
    goto LStartBuildHTree;
}


// Returns TRUE if the given codetable is better than no code at all
BOOL  CodeTradeoff(long far * fpAnal, CODETABLE far * fpct, int cbAnal, int cbHdr,
        int *bBit)
{
    int   cnt = cbAnal, codesize = 0;
    long  size = 0, repcnt = 0;

    while (cnt >>= 1)
        codesize++;

    for (cnt = 0; cnt < cbAnal; cnt++)
        {
        size   += fpAnal[cnt] * fpct[cnt].cbCode;
        repcnt += fpAnal[cnt];
        }
    size >>= 3; // Convert to bytes
    repcnt = repcnt * codesize / 8;

   size += cbHdr;  // Account for the cost of the header

// Calculate interesting info
#ifdef STATS
{

   long totfreq = 0;
   double result = 0.0, work, log(double);
   for(cnt=0;cnt<cbAnal;cnt++)
      totfreq += fpAnal[cnt];
   for(cnt=0;cnt<cbAnal;cnt++)
   {
      if(fpAnal[cnt]) //Don't do if 0 freq
      {
         work = (double) fpAnal[cnt] / (double) totfreq;
         work = log(work) / log(2.0);
         work*= (double) (-fpAnal[cnt]);
         result += work;
      }
   }
   printf("Entries: %3d, Uncomp: %6ld, Comp: %6ld, Optimal: %6.0f, Savings: %6.0f\n",
          cbAnal, repcnt, size, result/8,(double) size - (result/8));
}
#endif

    if (size >= repcnt) // Not worth it
        {
        *bBit = NOTABLE;  // Have to rebuild generic huffman tables
        for (cnt = 0; cnt < cbAnal; cnt++)
            fpct[cnt].cbCode = (BYTE) codesize;
        BuildCodeTable(fpct, cbAnal);
        }
    return ((BOOL)(size < repcnt));
}


int  TableComp(CODETABLE far *fpct, int cbct, int *bBit)
{
//  int  totsize[2] = { 4,4 };			// jem
    int  totsize[2];
    int  lastval    = fpct[0].cbCode;
    int  cnt, diff;

    totsize[0] = totsize[1] = 4;

    for (cnt = 1; cnt < cbct; cnt++)
        {
        diff = fpct[cnt].cbCode - lastval;

        if (!diff)
            totsize[0]++;
        else if (diff == 1)
            totsize[0]+=2;
        else
            totsize[0]+=6;


        if (diff > -2 && diff < 2)
            totsize[1] += 2;
        else
            totsize[1] += 6;

        lastval = fpct[cnt].cbCode;
        }

    totsize[0] >>= 3; //Convert to bytes
    totsize[1] >>= 3; //Convert to bytes

    if ((totsize[0] < totsize[1]) && (totsize[0] < (cbct>>1)))
        {
        *bBit = COMPRESS1BIT;
        cnt   = totsize[0];
        }
    else if (totsize[1] < (cbct >> 1))
        {
        *bBit = COMPRESS2BIT;
        cnt   = totsize[1];
        }
    else
        {
        *bBit = COMPRESSNONE;
        cnt   = cbct >> 1;
        }
    return(cnt);
}


void  WriteTable(CODETABLE far *fpct, int cbct, int Method)
{
    int  cnt, lastval = fpct[0].cbCode, diff, curval;

    if (Method == NOTABLE)
        return;

    WriteBits(lastval, 4);

    for (cnt = 1; cnt < cbct; cnt++)
        {
        curval = fpct[cnt].cbCode;
        diff   = curval - lastval;

        switch (Method)
            {
        case COMPRESSNONE:
            WriteBits(curval, 4);
            break;
        case COMPRESS1BIT:
            if (diff == 0)
                WriteBits(0, 1);
            else if (diff == 1)
                WriteBits(2, 2);
            else
                WriteBits(0x30|curval, 6);
            break;
        case COMPRESS2BIT:
            if ((diff > -2) && (diff < 2))
                WriteBits(diff+1, 2);
            else
                WriteBits(0x30|curval, 6);
            break;
            }
        lastval = curval;
        }
}


/*
**  LONG Lcb_JJJ1_CompressToFile(int fhSrc, int fhDest, LONG lcbDestMax)
**
**  Assumes that the header has already been written.
*/
LONG Lcb_JJJ1_CompressToFile(int fhSrc, int fhDest, LONG lcbDestMax)
{
    USHORT   us,cnt;
    SHORT    ch, cbLen, ibCharCur, ibStringCur, cbMatchLast,iMatchRel;
    LONG     libSrcStart = tell(fhSrc);
    LONG     libDestStart = tell(fhDest);
    LONG     lReturn;
    static   SHORT    b8Bit, b6Bit, b5Bit, b4aBit, b4bBit;
    SHORT    cb8Hdr, cb6Hdr, cb5Hdr, cb4aHdr, cb4bHdr;
    int      isPtr = FALSE;
    int      iJmpReturn;

    bBitHold = cbBitHold = 0;
    ibLitBuf = 0;

    if (bPassCnt == 0)
        {
        if (!FAllocateJJJGlobals(lcbDestMax, (BOOL)TRUE))
            return((LONG)rcOutOfMemory);

        if ((lcbSrcStart = lseek(fhSrc, 0L, SEEK_CUR)) == -1L)
            {
            FreeJJJGlobals();
            return((LONG)rcReadSeekError);
            }

        if ((iJmpReturn = setjmp(jmpEnv)) != 0)
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return((LONG)iJmpReturn);
            }
        fJmpEnvSet = TRUE;

        if (lcbDestMax != NIL && (LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestMax)
              fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestMax;

        fhDestGlobal = fhDest;
        lcbSkipOut = 0L;
        fpbBufDest = NULL;

        InitAnalyze();
        }
    else
        {
        // Output the header info and tables
        WriteByte((BYTE) ((b4aBit<<4) | b4bBit));
        WriteByte((BYTE) ((b5Bit<<4)  | b6Bit));  
        WriteByte((BYTE) ((b8Bit<<4)  | 0));  

        WriteTable(fpct4a, 16, b4aBit);
        WriteTable(fpct4b, 16, b4bBit);
        WriteTable(fpct5,  32, b5Bit);
        WriteTable(fpct6,  64, b6Bit);
        WriteTable(fpct8, 256, b8Bit);
        }

    LZInitTree();

    /* Clear the buffer with any character that will appear often. */
    ibStringCur = 0;
    _fmemset(ringBuf, ' ', (ibCharCur = cbBufMax - cbStrMax));

    /* Read cbStrMax bytes into the last cbStrMax bytes of the buffer */
    for (cbLen = 0; (USHORT)cbLen < cbStrMax && (ch = ReadByte(fhSrc)) != EOF;
            cbLen++)
        ringBuf[ibCharCur + cbLen] = (BYTE)ch;

    /* Insert the cbStrMax strings,
    ** each of which begins with one or more 'space' characters.  Note
    ** the order in which these strings are inserted.  This way,
    ** degenerate trees will be less likely to occur.
    */
    for (us = 1; us <= cbStrMax; us++)
        LZInsertNode(ibCharCur - us);

    /* Finally, insert the whole string just read.  The
    ** global variables cbMatchCur and iMatchCur are set.
    */
    LZInsertNode(ibCharCur);

    do  {
        /* cbMatchCur may be spuriously long near the end of text. */
        if ((SHORT) cbMatchCur > cbLen)
            cbMatchCur = cbLen;

        if (cbMatchCur <= cbIndex)
            {  /* Not long enough match. Send one byte. */
               /* 'send one byte' flag.  Send uncoded. */
            cbMatchCur = 1;
            rgbLitBuf[ibLitBuf++] = ringBuf[ibCharCur];
            if (ibLitBuf >= cbLitMax)
                {
                if (ibLitBuf)  // Flush Literals
                    {
                    if (ibLitBuf == cbLitMax)
                        isPtr = FALSE;
                    else
                        isPtr = TRUE;

                    if (bPassCnt == 0)  // Analyze phase
                        {
                        fpbAnalysis4a[0]++;
                        fpbAnalysis5[ibLitBuf-1]++;
                        }
                    else
                        {
                        WriteHuffman4a(0);
                        WriteHuffman5((BYTE) (ibLitBuf-1));
                        }
                    if (fWriteError || fDestFull)
                        goto LExit;

                    for (cnt = 0; cnt < ibLitBuf; cnt++)
                        {
                        if (bPassCnt == 0) // Analyze phase
                            fpbAnalysis8[rgbLitBuf[cnt]]++;
                        else
                            WriteHuffman8(rgbLitBuf[cnt]);

                        if (fWriteError || fDestFull)
                            goto LExit;
                        }
                    ibLitBuf = 0; 
                    }
                }
            }
        else
            {  /* Send position and length pair. Note cbMatchCur > cbIndex. */
            if (ibLitBuf)  // Flush Literals
                {
                if (ibLitBuf == cbLitMax)
                    isPtr = FALSE;
                else
                    isPtr = TRUE;

                if (bPassCnt == 0)  // Analyze phase
                    {
                    fpbAnalysis4a[0]++;
                    fpbAnalysis5[ibLitBuf-1]++;
                    }
                else
                    {
                    WriteHuffman4a(0);
                    WriteHuffman5((BYTE) (ibLitBuf-1));
                    }
                if (fWriteError || fDestFull)
                    goto LExit;

                for (cnt = 0; cnt < ibLitBuf; cnt++)
                    {
                    if (bPassCnt == 0) // Analyze phase
                        fpbAnalysis8[rgbLitBuf[cnt]]++;
                    else
                        WriteHuffman8(rgbLitBuf[cnt]);

                    if (fWriteError || fDestFull)
                        goto LExit;
                    }
                ibLitBuf = 0; 
                }

            iMatchRel = (ibCharCur + cbBufMax - iMatchCur) & (cbBufMax-1);
            if (bPassCnt == 0) // Analyze Phase
                {
                if (isPtr)
                    fpbAnalysis4b[cbMatchCur-cbIndex]++;
                else
                    fpbAnalysis4a[cbMatchCur-cbIndex]++;

                fpbAnalysis6 [iMatchRel>>6]++;
                }
            else
                {
                if (isPtr)
                    WriteHuffman4b((BYTE) (cbMatchCur-cbIndex));
                else
                    WriteHuffman4a((BYTE) (cbMatchCur-cbIndex));

                WriteHuffman6((BYTE) (iMatchRel>>6));
                WriteBits(iMatchRel, 6);
                }
            isPtr = FALSE;
            }

        cbMatchLast = cbMatchCur;

        for (us = 0; us < (USHORT)cbMatchLast && (ch=ReadByte(fhSrc))!=EOF;us++)
            {
            LZDeleteNode(ibStringCur);      /* Delete old strings and */
            ringBuf[ibStringCur] = (BYTE)ch;        /* read new bytes */

              /* If the position is near the end of buffer, extend the
              ** buffer to make string comparison easier.
              */
            if ((USHORT)ibStringCur < cbStrMax - 1)
                ringBuf[ibStringCur + cbBufMax] = (BYTE)ch;

              /* ring buffer, increment the position modulo N. */
            ibStringCur = ibStringCur+1 & (cbBufMax - 1);
            ibCharCur = ibCharCur+1 & (cbBufMax - 1);

              /* Register the string in ringBuf[r..r+cbStrMax-1] */
            LZInsertNode(ibCharCur);
            }

        while (us++ < (USHORT) cbMatchLast)      /* After the end of text, */
            {
            LZDeleteNode(ibStringCur);        /* no need to read, but */

            ibStringCur = ibStringCur+1 & (cbBufMax - 1);
            ibCharCur = ibCharCur+1 & (cbBufMax - 1);
            if (--cbLen)
                LZInsertNode(ibCharCur);          /* buffer may not be empty. */
            }
        } while (cbLen > 0); /* length of string to be processed is zero */

    if (ibLitBuf)  // Flush Literals
        {
        if (ibLitBuf == cbLitMax)
            isPtr = FALSE;
        else
            isPtr = TRUE;

        if (bPassCnt == 0)  // Analyze phase
            {
            fpbAnalysis4a[0]++;
            fpbAnalysis5[ibLitBuf-1]++;
            }
        else
            {
            WriteHuffman4a(0);
            WriteHuffman5((BYTE) (ibLitBuf-1));
            }
        if (fWriteError || fDestFull)
            goto LExit;
        for (cnt = 0; cnt < ibLitBuf; cnt++)
            {
            if (bPassCnt == 0) // Analyze phase
                fpbAnalysis8[rgbLitBuf[cnt]]++;
            else
                WriteHuffman8(rgbLitBuf[cnt]);

            if (fWriteError || fDestFull)
                goto LExit;
            }
        ibLitBuf = 0; 
        }

    if (bPassCnt > 0)  // Not the analyze phase
        {
        if (cbBitHold)  // There are a few bits left in the stream
            if (isPtr)
                // Make sure extraneous bits aren't interpeted as a 0
                if (fpct4b[0].usCode&1)
                    WriteBits(0,   8-cbBitHold);
                else
                    WriteBits(255, 8-cbBitHold);
            else
                if (fpct4a[0].usCode&1)
                    WriteBits(0,   8-cbBitHold);
                else
                    WriteBits(255, 8-cbBitHold);

        WriteOutBuff(0);
        }
    else
        {
        BuildHTree(fpbAnalysis4a, 16, fpct4a);
        if (!BuildCodeTable(fpct4a, 16))
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return(rcGenericCompError);
            }

        BuildHTree(fpbAnalysis4b, 16, fpct4b);  
        if (!BuildCodeTable(fpct4b, 16)) 
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return(rcGenericCompError);
            }

        BuildHTree(fpbAnalysis5, 32, fpct5);
        if (!BuildCodeTable(fpct5, 32))
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return(rcGenericCompError);
            }

        BuildHTree(fpbAnalysis6, 64, fpct6);
        if (!BuildCodeTable(fpct6, 64))
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return(rcGenericCompError);
            }

        BuildHTree(fpbAnalysis8, 256, fpct8);
        if (!BuildCodeTable(fpct8, 256))
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return(rcGenericCompError);
            }
      
        cb4aHdr = TableComp(fpct4a, 16, &b4aBit);
        cb4bHdr = TableComp(fpct4b, 16, &b4bBit);
        cb5Hdr  = TableComp(fpct5,  32, &b5Bit);
        cb6Hdr  = TableComp(fpct6,  64, &b6Bit);
        cb8Hdr  = TableComp(fpct8, 256, &b8Bit);
      
        CodeTradeoff(fpbAnalysis4a, fpct4a, 16, cb4aHdr, &b4aBit);
        CodeTradeoff(fpbAnalysis4b, fpct4b, 16, cb4bHdr, &b4bBit);
        CodeTradeoff(fpbAnalysis5 , fpct5,  32, cb5Hdr,  &b5Bit);
        CodeTradeoff(fpbAnalysis6 , fpct6,  64, cb6Hdr,  &b6Bit);
        CodeTradeoff(fpbAnalysis8 , fpct8, 256, cb8Hdr,  &b8Bit);

        if (lseek(fhSrc, lcbSrcStart, SEEK_SET) == -1L)
            {
            fJmpEnvSet = FALSE;
            FreeJJJGlobals();
            return((LONG)rcReadSeekError);
            }

        bPassCnt = 1;
        lReturn  = Lcb_JJJ1_CompressToFile(fhSrc, fhDest, lcbDestMax);
        bPassCnt = 0;
        return(lReturn);
        }
LExit:
    fJmpEnvSet = FALSE;
    FreeJJJGlobals();
 
    if (fWriteError)
        return((LONG)rcWriteError);

    if (lcbDestMax == NIL || fhDest == -1)
        return(lcbDest);

      /* fix fhSrc because we split */
    lReturn = lcbDest;             /* lcbDest gets altered by the Decomp call */

    /* reset fhDest (after header) */
    if (lseek(fhDest, libDestStart, SEEK_SET) == -1L)
        return((LONG)rcWriteSeekError);

    /* lcbDest = uncompressed length of this current piece */
    lcbDest = Lcb_JJJ1_DecompressToFile(fhDest, -1, NIL, 0L, NULL, 0L);
    if (lcbDest < rcNoError)
        return(lcbDest);

    /* reset fhSrc */
    if (lseek(fhSrc, libSrcStart + lcbDest, SEEK_SET) == -1L)
        return((LONG)rcReadSeekError);

    return(lReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\lzss\lzcomp.c ===
/* TS = none */
/*
**  LZCOMP.C
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>

#include "..\sutkcomp.h"

#ifdef OS2SU
#include <doscalls.h>
#endif

#include "lz.h"



/*
**  void  LZInitTree(void)
**
**  For i = 0 to cbBufMax - 1, rson[i] and lson[i] will be the right and
**  left children of node i.  These nodes need not be initialized.
**  Also, dad[i] is the parent of node i.  These are initialized to
**  nilND (= N), which stands for 'not used.'
**  For i = 0 to 255, rson[cbBufMax + i + 1] is the root of the tree
**  for strings that begin with character i.  These are initialized
**  to nilND.  Note there are 256 trees.
*/
void LZInitTree(void)
{
    USHORT  us;

    for (us = 0; us < cbBufMax; us++) 
        {
        rgND[us].ibRingBuf = us;
        rgND[us].pNDpar = &nilND;
        }

    for (us = 0; us < 256; us++)
        rgRoot[us].pNDright = &nilND;
}


/*
**  void  LZDeleteNode(SHORT iND)
**
**  Deletes node p from tree.
*/
void LZDeleteNode(SHORT iND)
{
    register ND *pNDdel = &rgND[iND];
    register ND *pND;
        
    if (pNDdel->pNDpar == &nilND)
        return;                              /* not in tree */

        // if the node is a leaf, the insert ND is easy
    if (pNDdel->pNDright == &nilND)
        pND = pNDdel->pNDleft;
    else if (pNDdel->pNDleft == &nilND)
        pND = pNDdel->pNDright;
    else                      // node to be deleted is an interior node
        {
        pND = pNDdel->pNDleft;

        if (pND->pNDright != &nilND)
            {
            do  {
                pND = pND->pNDright;
                } while (pND->pNDright != &nilND);

            pND->pNDpar->pNDright = pND->pNDleft;
            pND->pNDleft->pNDpar = pND->pNDpar;

            pND->pNDleft = pNDdel->pNDleft;

            pNDdel->pNDleft->pNDpar = pND;
            }
        pND->pNDright = pNDdel->pNDright;
        pNDdel->pNDright->pNDpar = pND;
        }
    pND->pNDpar = pNDdel->pNDpar;

        // set the rigth/left pointer to parent node to new current
    if (pNDdel->pNDpar->pNDright == pNDdel)
        pNDdel->pNDpar->pNDright = pND;
    else
        pNDdel->pNDpar->pNDleft = pND;

    pNDdel->pNDpar = &nilND;
}


/*
** Inserts string of length cbStrMax, ringBuf[r..r+cbStrMax-1], into one of the
** trees (rgRoot[*iString]'th tree) and returns the longest-match position
** and length via the global variables iMatchCur and cbMatchCur.
** If cbMatchCur = cbStrMax, then removes the old node in favor of the new
** one, because the old one will be deleted sooner.
**
** There is a one to one relationship with the i'th position in the ringBuf
** and the i'th position in the rgND.
*/
void LZInsertNode(SHORT iString)
{
    ND *     pND;
    ND  *    pNDNew;
    SHORT    fComp;
    SHORT    cbMatchND;
    BYTE far *  pKey;

    pKey =   &ringBuf[iString];
    pND =    &rgRoot[*pKey];    // start with tree index by first char in string
    pNDNew = &rgND[iString];

    pNDNew->pNDleft = pNDNew->pNDright = &nilND;
    cbMatchCur = 0;
    goto first;

    do {
          // Follow the tree down to the leaves depending on the result
          // of the last string compare.  When you come the a leaf in the
          // tree, you are done and insert the node.
        if (fComp >= 0)
            {
first:
            if (pND->pNDright != &nilND)
                pND = pND->pNDright;
            else
                {
                pND->pNDright = pNDNew;
                pNDNew->pNDpar = pND;
                return;
                }
            }
        else
            {
            if (pND->pNDleft != &nilND)
                pND = pND->pNDleft;
            else
                {
                pND->pNDleft = pNDNew;
                pNDNew->pNDpar = pND;
                return;
                }
            }

          // compare the string at the current node with the string
          // that we are looking for.
        for (cbMatchND = 1; (USHORT)cbMatchND < cbStrMax; cbMatchND++)
            if ((fComp =pKey[cbMatchND]-ringBuf[pND->ibRingBuf+cbMatchND]) != 0)
                break;

          // if the length of the matched string is greater then the
          // current, make the iMatchCur point the pND
        if ((USHORT)cbMatchND > cbMatchCur)
            {
            /* iMatchCur = (ND far *)pND - (ND far *)rgND; */
            unsigned long ul = (unsigned long)((BYTE far *)pND);

            ul -= (unsigned long)((BYTE far *)rgND);
            ul = ul / sizeof(ND);
            if (ul > 0x0000FFFF)
                printf("Assert - Overflow in iMatchCur assignment!\n");
            iMatchCur = (USHORT)ul;

            cbMatchCur = (USHORT)cbMatchND;
            }

          // Search for strings while a less then maxium length string
          // is found
        } while (cbMatchCur < cbStrMax);

      // replace an older ND with the new node in the tree,
      // by replacing the current pND with the new node pNDNew
    pNDNew->pNDleft = pND->pNDleft;
    pND->pNDleft->pNDpar = pNDNew;
    pNDNew->pNDright = pND->pNDright;
    pND->pNDright->pNDpar = pNDNew;

      // insert into left/right side of parent
    pNDNew->pNDpar = pND->pNDpar;

    if (pND->pNDpar->pNDright == pND)
        pND->pNDpar->pNDright = pNDNew;
    else
        pND->pNDpar->pNDleft = pNDNew;

    pND->pNDpar = &nilND;        /* remove old node */
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\jjj1\jjj1shar.c ===
/*
**  JJJ1SHAR.C --  Shared code, variables, and defines for
**                 JJJ1 compression/decompression module.
*/

/*  This code was written by modifying the Zeck compression code
**  and adding a triple huffman compressor.  The results are much
**  smaller.  This was done by Jeff Johnson, 10/15/90 to accomodate
**  Microsoft Excel 3.0.
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <dos.h>
#include <stdio.h>

#include "..\sutkcomp.h"
#include "jjj1.h"

#ifdef WIN_VER
HANDLE vhAnalysis = NULL;
HANDLE vhCt4a = NULL;
HANDLE vhHtArr = NULL;
HANDLE vhLookup4a = NULL;
#endif /* WIN_VER */


USHORT iPowers[16] = { 0,1,3,7,15,31,63,127,255,511,1023,2047,4095,8191,16383,
                       32767 };

//Analysis globals
long far *   fpbAnalysis     = NULL;
long far *   fpbAnalysis4a   = NULL;
long far *   fpbAnalysis4b   = NULL;
long far *   fpbAnalysis5    = NULL;
long far *   fpbAnalysis6    = NULL;
long far *   fpbAnalysis8    = NULL;

HTREE far *  fphtArr         = NULL;

CODETABLE far *  fpct4a      = NULL;
CODETABLE far *  fpct4b      = NULL;
CODETABLE far *  fpct5       = NULL;
CODETABLE far *  fpct6       = NULL;
CODETABLE far *  fpct8       = NULL;

//Decomp globals
BYTE far *       fpbLookup4a = NULL;
BYTE far *       fpbLookup4b = NULL;
BYTE far *       fpbLookup5  = NULL;
BYTE far *       fpbLookup6  = NULL;
BYTE far *       fpbLookup8  = NULL;


/*
**  BOOL  FAllocateJJJGlobals(LONG lcbDestMax, fCompressing)
**
**  Global arrays take about 45K so I wanted to allocate and free them rather
**  than leave them around when not needed.
**
**  rgRoot and rgND are only needed when compressing, so they are only allocated
**  if fCompressing is TRUE.
*/
BOOL  FAllocateJJJGlobals(LONG lcbDestMax, BOOL fCompressing)
{
    if (fCompressing)
        {
        // This chunk holds all the long arrays for analysis
#ifndef WIN_VER
        fpbAnalysis = (long far *)_fmalloc(((256+64+32+16+16)*sizeof(long)));
#else  /* WIN_VER */
        GlobalCompact((DWORD)((256+64+32+16+16)*sizeof(long)));
        if ((vhAnalysis = GlobalAlloc(GHND,
                (DWORD)((256+64+32+16+16)*sizeof(long)))) != NULL)
            fpbAnalysis = (long far *)GlobalLock(vhAnalysis);
        else
            fpbAnalysis = NULL;
#endif /* WIN_VER */

        if (fpbAnalysis == NULL)
            {
            FreeJJJGlobals();
            return(FALSE);
            }
        fpbAnalysis8 = fpbAnalysis;
        fpbAnalysis6 = &(fpbAnalysis8[256]);
        fpbAnalysis5 = &(fpbAnalysis6[64]);
        fpbAnalysis4a= &(fpbAnalysis5[32]);
        fpbAnalysis4b= &(fpbAnalysis4a[16]);
        }
    else
        {
        fpbAnalysis = NULL;
#ifdef WIN_VER
        vhAnalysis = NULL;
#endif /* WIN_VER */
        }

    // This chunk holds all the code tables
#ifndef WIN_VER
    fpct4a = (CODETABLE far *)_fmalloc(((256+64+32+16+16)*sizeof(CODETABLE)));
#else  /* WIN_VER */
    GlobalCompact((DWORD)((256+64+32+16+16)*sizeof(CODETABLE)));
    if ((vhCt4a = GlobalAlloc(GHND,
            (DWORD)((256+64+32+16+16)*sizeof(CODETABLE)))) != NULL)
        fpct4a = (CODETABLE far *)GlobalLock(vhCt4a);
    else
        fpct4a = NULL;
#endif /* WIN_VER */

    if (fpct4a == NULL)
        {
        FreeJJJGlobals();
        return(FALSE);
        }
    fpct4b = &(fpct4a[16]);
    fpct5  = &(fpct4b[16]);
    fpct6  = &(fpct5[32]);
    fpct8  = &(fpct6[64]);


    // Allocate a structure used to build huffman trees
#ifndef WIN_VER
    fphtArr = (HTREE far *)_fmalloc((512*sizeof(HTREE)));
#else  /* WIN_VER */
    GlobalCompact((DWORD)(512*sizeof(HTREE)));
    if ((vhHtArr = GlobalAlloc(GHND, (DWORD)(512*sizeof(HTREE)))) != NULL)
        fphtArr = (HTREE far *)GlobalLock(vhHtArr);
    else
        fphtArr = NULL;
#endif /* WIN_VER */

    if (fphtArr == NULL)
        {
        FreeJJJGlobals();
        return(FALSE);
        }

    // This chunk holds all the decomp lookup tables
    if (!fCompressing)
        {
#ifndef WIN_VER
        fpbLookup4a = (BYTE far *)_fmalloc(((5*256)*sizeof(BYTE)));
#else  /* WIN_VER */
        GlobalCompact((DWORD)((5*256)*sizeof(BYTE)));
        if ((vhLookup4a = GlobalAlloc(GHND,
                (DWORD)((5*256)*sizeof(BYTE)))) != NULL)
            fpbLookup4a = (BYTE far *)GlobalLock(vhLookup4a);
        else
            fpbLookup4a = NULL;
#endif /* WIN_VER */

        if (fpbLookup4a == NULL)
            {
            FreeJJJGlobals();
            return(FALSE);
            }
        fpbLookup4b = &(fpbLookup4a[256]);
        fpbLookup5  = &(fpbLookup4b[256]);
        fpbLookup6  = &(fpbLookup5[256]);
        fpbLookup8  = &(fpbLookup6[256]);
        }
    else
        {
        fpbLookup4a = NULL;
#ifdef WIN_VER
        vhLookup4a = NULL;
#endif /* WIN_VER */
        }

    cbStrMax = (15 + cbIndex);
    if (!FAllocateLZGlobals(lcbDestMax, fCompressing))
        {
        FreeJJJGlobals();
        return(FALSE);
        }

    return((BOOL)TRUE);
}


/*
**  void  FreeJJJGlobals(void)
*/
void FreeJJJGlobals(void)
{
    FreeLZGlobals();

#ifndef WIN_VER
    if (fpbAnalysis != NULL)
        _ffree(fpbAnalysis);

    if (fpct4a != NULL)
        _ffree(fpct4a);

    if (fpbLookup4a != NULL)
        _ffree(fpbLookup4a);

    if (fphtArr != NULL)
        _ffree(fphtArr);
#else  /* WIN_VER */
    if (vhAnalysis != NULL)
        {
        GlobalUnlock(vhAnalysis);
        GlobalFree(vhAnalysis);
        vhAnalysis = NULL;
        }

    if (vhCt4a != NULL)
        {
        GlobalUnlock(vhCt4a);
        GlobalFree(vhCt4a);
        vhCt4a = NULL;
        }

    if (vhLookup4a != NULL)
        {
        GlobalUnlock(vhLookup4a);
        GlobalFree(vhLookup4a);
        vhLookup4a = NULL;
        }

    if (vhHtArr != NULL)
        {
        GlobalUnlock(vhHtArr);
        GlobalFree(vhHtArr);
        vhHtArr = NULL;
        }
#endif /* WIN_VER */
}


// Routine builds huffman codes given their lengths and the table size
BOOL BuildCodeTable(CODETABLE far * fpct, int cbct)
{
    int           cnt, prev = -1;
    BYTE          curlen = 0;
    unsigned int  curcode = 0;

    for (cnt = 0; cnt < cbct; cnt++)
        {
        fpct[cnt].usCode = 0;
        }

    while (++curlen < 16)
        {
        for (cnt = 0; cnt < cbct; cnt++)
            {
            if (fpct[cnt].cbCode == curlen)  // Assign it a code
                {
                fpct[cnt].usCode = curcode++;
                if (prev != -1)
                    fpct[prev].nextCode = (BYTE) cnt;
                prev = cnt;
                }
            }
        curcode <<= 1;
        }

    for (cnt = 0; cnt < cbct; cnt++)
        {
        if (fpct[cnt].cbCode >= 16)
            return(FALSE);
        }

    return((BOOL)TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\nc_xor1\nc_xor1.c ===
/* TS = none */
/*
**  NC_XOR1.C  --  No Compression (Straight Copy) and Xor Compression Algorithm
**                 - Compression and Decompression routines.
*/

#include <stdio.h>
#include <io.h>
#include <stdlib.h>
#include <malloc.h>
#include <dos.h>
#include "..\sutkcomp.h"


extern  USHORT  CbReadFar(int fh, BYTE far * fp, USHORT cb);


/*
**  static  BOOL  XorBuf(BYTE far * fpbBuf, LONG lcbBuf)
**
**  Xor lcbBuf bytes in fpbBuf with ~0.
*/
static  BOOL  XorBuf(BYTE far * fpbBuf, LONG lcbBuf)
{
    while (lcbBuf-- > 0)
        {
        *fpbBuf = *fpbBuf ^ (~0);
        fpbBuf++;
        }

    return(TRUE);
}


/*
**  static  LONG  LcbFarRead(int fh, BYTE far * fpbBuf, LONG lcb)
**
**  Read lcb bytes into fpbBuf from fh.  Return number of bytes read
**  or an error return code.
*/
static  LONG  LcbFarRead(int fh, BYTE far * fpbBuf, LONG lcb)
{
    USHORT  cbBuf = (32 * 1024);
    LONG    lcbSav = lcb;

    while (lcb > (LONG)cbBuf)
        {
        if (CbReadFar(fh, fpbBuf, cbBuf) != cbBuf)
            return((LONG)rcReadError);
        lcb -= (LONG)cbBuf;
        fpbBuf += cbBuf;
        }
    if (CbReadFar(fh, fpbBuf, (USHORT)lcb) != (USHORT)lcb)
        return((LONG)rcReadError);

    return(lcbSav);
}


/*
**  LONG  Lcb_NC_XOR1_StraightCopy(int fhSrc, int fhDest, LONG lcbDestMax,
**                              BYTE far * fpbBufDest, LONG libStart, BOOL fXor)
**
**  Copy from fhSrc to either fhDest or fpbBufDest.   XORing them with ~0 as we
**  go if fXor is TRUE.  Skip the first libStart bytes.  Copy at most
**  lcbDestMax bytes.  Return number of bytes copied if successful, or an
**  error return code if not.
*/
LONG  Lcb_NC_XOR1_StraightCopy(int fhSrc, int fhDest, LONG lcbDestMax,
                                BYTE far * fpbBufDest, LONG libStart, BOOL fXor)
{
    LONG   lcbToWrite;
    LONG   libSrcSav;

    if (fhDest != -1 && fpbBufDest != NULL)
        return((LONG)rcWriteError);

    if (fhSrc == -1 || (libSrcSav = tell(fhSrc)) == NIL)
        return((LONG)rcReadError);

    if ((lcbToWrite = lseek(fhSrc, 0L, SEEK_END)) == NIL)
        return((LONG)rcReadSeekError);

    lcbToWrite -= libSrcSav;               /* equals length that CAN be read  */

    if (libStart == NIL)
        libStart = 0L;

    if (lcbToWrite <= libStart)
        return(0L);

    lcbToWrite -= libStart;                /* equals length that WILL be read */

    if (lcbDestMax == NIL || lcbDestMax > lcbToWrite)
        lcbDestMax = lcbToWrite;

    if (lcbDestMax == 0L)
        return(0L);

    if (fhDest == -1 && fpbBufDest == NULL)
        lseek(fhSrc, libSrcSav + libStart + lcbDestMax, SEEK_SET);
    else
        {
        lcbToWrite = lcbDestMax;
        lseek(fhSrc, libSrcSav + libStart, SEEK_SET);
        if (fpbBufDest != NULL)                            /* write to buffer */
            {
            LONG   lReturn;

            if ((lReturn = LcbFarRead(fhSrc, fpbBufDest, lcbToWrite)) !=
                                                                     lcbToWrite)
                return((lReturn < 0L) ? lReturn : (LONG)rcReadError);
            if (fXor && !XorBuf(fpbBufDest, lcbToWrite))
                return((LONG)rcGenericCompError);
            }
        else                                                 /* write to file */
            {
            BYTE *  pbBuf;
            USHORT  cbBuf = (32 * 1024);

            while (cbBuf >= 256 && (pbBuf = (BYTE *)malloc(cbBuf)) == NULL)
                cbBuf >>= 1;

            if (pbBuf == NULL)
                return((LONG)rcOutOfMemory);

            while (lcbToWrite > (LONG)cbBuf)
                {
                if (read(fhSrc, pbBuf, cbBuf) != cbBuf)
                    {
                    free(pbBuf);
                    return((LONG)rcReadError);
                    }
                if (fXor && !XorBuf((BYTE far *)pbBuf, (LONG)cbBuf))
                    {
                    free(pbBuf);
                    return((LONG)rcGenericCompError);
                    }
                if (write(fhDest, pbBuf, cbBuf) != cbBuf)
                    {
                    free(pbBuf);
                    return((LONG)rcWriteError);
                    }
                lcbToWrite -= (LONG)cbBuf;
                }
            if (read(fhSrc, pbBuf, (USHORT)lcbToWrite) != (USHORT)lcbToWrite)
                {
                free(pbBuf);
                return((LONG)rcReadError);
                }
            if (fXor && !XorBuf((BYTE far *)pbBuf, lcbToWrite))
                {
                free(pbBuf);
                return((LONG)rcGenericCompError);
                }
            if (write(fhDest, pbBuf, (USHORT)lcbToWrite) != (USHORT)lcbToWrite)
                {
                free(pbBuf);
                return((LONG)rcWriteError);
                }

            free(pbBuf);
            }
        }

    return(lcbDestMax);
}


/*
**  USHORT  CbReadFar(int fh, BYTE far * fp, USHORT cb)
**
**  Reads cb bytes from file handle fh into far pointer fp.
**  Returns number of bytes read, 0 on error.
*/
USHORT  CbReadFar(int fh, BYTE far * fp, USHORT cb)
{
#ifndef OS2_VER
    union  REGS  inregs, outregs;
    struct SREGS segregs;

    inregs.x.bx = fh;            /* file handle */
    inregs.x.cx = cb;            /* bytes to read */
    inregs.x.dx = FP_OFF(fp);    /* offset of buffer */
    segregs.ds  = FP_SEG(fp);    /* segment of buffer */
    inregs.h.ah = 0x3F;          /* Read Handle */
    intdosx(&inregs, &outregs, &segregs);

    return((outregs.x.cflag) ? 0 : outregs.x.ax);
#else /* OS2_VER */
/* REVIEW - total kludge!! */
    BYTE   rgb[128];
    USHORT cbReadTotal = 0;
    USHORT cbRead;
    USHORT ib;

    while (cb > 0)
        {
        if ((cbRead = read(fh, rgb, (cb > 128 ? 128 : cb))) == -1)
            {
            return(0);
            }
        if (cbRead == 0)
            {
            return(cbReadTotal);
            }
        cbReadTotal += cbRead;
        cb -= cbRead;
        for (ib = 0; ib < cbRead; ib++)
            {
            *(fp++) = rgb[ib];
            }
        }
    return(cbReadTotal);
#endif /* !OS2_VER */
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\test\example1.c ===
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include <fcntl.h>
#include <direct.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <dos.h>
#include <malloc.h>

#include "sutkcomp.h"


/* ************************************************************** */
int main(int argc, char * argv[])
{
	int        fhDest     = -1;
	int        fhSrc      = -1;
	SHORT      wReturn;
	LONG       lcbDecomp;

	if ((fhSrc = open("input", O_RDONLY | O_BINARY)) == -1)
		{
		printf("unable to open source file 'input'\n");
		goto LExit;
		}

	if ((wReturn = WReadHeaderInfo(fhSrc)) < rcNoError)
		{
		printf("WReadHeaderInfo() failed; code = %d\n", wReturn);
		goto LExit;
		}

	if ((fhDest = open("output", O_TRUNC | O_BINARY | O_CREAT | O_WRONLY,
			S_IREAD | S_IWRITE)) == -1)
		{
		printf("unable to open destination file 'output'\n");
		goto LExit;
		}

	lcbDecomp = LcbDecompressToFile(fhSrc, fhDest, NIL, 0L, (BOOL)TRUE);

	if (lcbDecomp < rcNoError)
		{
		printf("LcbDecompressToFile() failed; code = %ld\n", lcbDecomp);
		goto LExit;
		}

LExit:
	if (fhSrc != -1)
		close(fhSrc);
	if (fhSrc != -1)
		close(fhDest);

	exit(0);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\lzss\lz.h ===
/* TS = none */
/*
**  LZ.H -- Defines and externs for LZ compression/decompression
*/

typedef struct _ND {
    struct _ND  *pNDright;          // left and right node
    struct _ND  *pNDleft;
    struct _ND  *pNDpar;            // parent node
    USHORT       ibRingBuf;
} ND;

#define  cbBufMax   4096            /* size of ring buffer */
#define  cbIndex       2            /* encode string into position and length */
extern   USHORT     cbStrMax;


  /***** EXTERNS *****/
extern  USHORT  iMatchCur;
extern  USHORT  cbMatchCur;

extern  ND *  rgRoot;
extern  ND *  rgND;
extern  ND    nilND;
extern  BYTE far *  ringBuf;

extern  BOOL  FAllocateLZGlobals(LONG lcbDestMax, BOOL fCompressing);
extern  void  FreeLZGlobals(void);

extern  void  LZInitTree(void);
extern  void  LZDeleteNode(SHORT iND);
extern  void  LZInsertNode(SHORT iString);
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\jjj1\jjj1deco.c ===
/*
**  JJJ1DECO.C  --  Jeff Johnson Decompression module - first implementation
*/

/*  This code was written by modifying the Zeck compression code
**  and adding a triple huffman compressor.  The results are much
**  smaller.  This was done by Jeff Johnson, 10/15/90 to accomodate
**  Microsoft Excel 3.0.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <io.h>
#include <fcntl.h>

#include "..\sutkcomp.h"

#ifdef OS2SU
#include <doscalls.h>
#endif

#include "jjj1.h"

#include "setjmp.h"


extern BOOL vfUserCancel;
extern PFNWFROMW vpfnYield;

extern BOOL    fJmpEnvSet;
extern jmp_buf jmpEnv;

  /* forward declarations */
BOOL  UnpackJJJ1(void);


/*
**  LONG  Lcb_JJJ1_DecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
**              LONG libStart, BYTE far * fpbBuf, LONG lcbBuf)
*/
LONG Lcb_JJJ1_DecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
           LONG libStart, BYTE far * fpbBuf, LONG lcbBuf)
{
    int iJmpReturn;

    if (lcbDestMax != NIL)
        return((LONG)rcGenericDecompError);

    if (!FAllocateJJJGlobals((lcbDestMax == NIL) ? NIL : (libStart +lcbDestMax),
                                                                         FALSE))
        return((LONG)rcOutOfMemory);

    if ((iJmpReturn = setjmp(jmpEnv)) != 0)
        {
        fJmpEnvSet = FALSE;
        FreeJJJGlobals();
        return((LONG)iJmpReturn);
        }
    fJmpEnvSet = TRUE;

      /* lcbDestStop == libStart + lcbDestMax */
    if (lcbDestMax != NIL && (LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestStop)
        fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestStop;

    fhDestGlobal = fhDest;
    fhSrcGlobal = fhSrc;
    lcbSkipOut = libStart;
    fpbBufDest = NULL;

    if (!UnpackJJJ1())
        {
        fJmpEnvSet = FALSE;
        FreeJJJGlobals();
        return((LONG)rcGenericDecompError);
        }

    fJmpEnvSet = FALSE;

    FreeJJJGlobals();

    if (fWriteError)
        return((LONG)rcWriteError);
    else
        return(lcbDest - libStart);
}


#ifdef COMPLEX
/*
**  LONG Lcb_JJJ1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
**                                                               LONG libStart)
*/
LONG Lcb_JJJ1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
                                                                 LONG libStart)
{
    int iJmpReturn;

    if (lcbBuf <= 0L)
        return((LONG)rcGenericDecompError);

    if (!FAllocateJJJGlobals(libStart + lcbBuf, FALSE))
        return((LONG)rcOutOfMemory);

    if ((iJmpReturn = setjmp(jmpEnv)) != 0)
        {
        fJmpEnvSet = FALSE;
        fpbBufDest = NULL;
        FreeJJJGlobals();
        return((LONG)iJmpReturn);
        }
    fJmpEnvSet = TRUE;

      /* lcbDestStop == libStart + lcbBuf */
    if ((LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestStop)
        fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestStop;

    lcbSkipOut = libStart;
    fpbBufDest = fpbBuf;
    fhDestGlobal = -1;
    fhSrcGlobal = fhSrc;

    if (!UnpackJJJ1())
        {
        fJmpEnvSet = FALSE;
        fpbBufDest = NULL;
        FreeJJJGlobals();
        return((LONG)rcGenericDecompError);
        }

    fJmpEnvSet = FALSE;
    fpbBufDest = NULL;
    FreeJJJGlobals();

    if (fWriteError)
        return((LONG)rcWriteError);
    else
        return(lcbDest - libStart);
}
#endif /* COMPLEX */


USHORT  usIHold = 0, cbIHold = 0;
BOOL    fHitEOF = FALSE;

int  ReadHuffman(CODETABLE far *fpct, BYTE far *fpbLookup)
{
    USHORT  b, ndx, ent;

    if (cbIHold < 8)
        {
        if (!fHitEOF)
            {
            if ((b = ReadByte(fhSrcGlobal)) == EOF)
                {
                fHitEOF = (BOOL)TRUE;
                ent = fpbLookup[((usIHold << (8 - cbIHold)) & 255)];
                if (cbIHold >= fpct[ent].cbCode)
                    {
                    cbIHold -= fpct[ent].cbCode;
                    return(ent);
                    }
                return(EOF);
                }
            usIHold = (usIHold << 8) | b;
            cbIHold += 8;
            }
        else
            {
            ent = fpbLookup[((usIHold << (8 - cbIHold)) & 255)];
            if (cbIHold >= fpct[ent].cbCode)
                {
                cbIHold -= fpct[ent].cbCode;
                return(ent);
                }
            return(EOF);
            }
        }

    ndx = usIHold >> (cbIHold - 8);
    ent = fpbLookup[ndx & 255];
    if (fpct[ent].cbCode <= 8)
        {
        cbIHold -= fpct[ent].cbCode;
        return(ent);
        }

    // We have to walk the linked list
    cbIHold -= 8;
    if ((b = ReadByte(fhSrcGlobal)) == EOF)
        fHitEOF = (BOOL)TRUE;
    else
        {
        usIHold = (usIHold << 8) | b;
        cbIHold += 8;
        }

    while(1)
        {
        if (cbIHold + 8 < fpct[ent].cbCode)
            return(EOF);
        ndx = fpct[ent].cbCode - 8;
        if (((usIHold >> (cbIHold - ndx)) & iPowers[ndx]) ==
                (fpct[ent].usCode&iPowers[ndx]))
            {
            cbIHold -= ndx;
            return(ent);
            }
        ent = fpct[ent].nextCode;
        }
}


int  ReadBits(int bitcnt)
{
    int  b;

    if ((int) cbIHold < bitcnt)
        if (!fHitEOF)
            {
            if ((b = ReadByte(fhSrcGlobal)) == EOF)
                {
                fHitEOF = (BOOL)TRUE;
                return(EOF);
                }
            usIHold = (usIHold<<8) | b;
            cbIHold += 8;
            }
        else
            return(EOF);

    cbIHold -= bitcnt;
    return((usIHold >> cbIHold) & iPowers[bitcnt]);
}


void  ReadHTable(CODETABLE far *fpct, int usct, int Method)
{
    int   cnt, b;
    BYTE  byte;

    switch (Method)
        {
    case NOTABLE: // Build an evensized huffman table
        b = 0;
        cnt = usct;
        while (cnt >>= 1)
            b++;
        for (cnt = 0; cnt < usct; cnt++)
            fpct[cnt].cbCode = (BYTE) b;
        break;

    case COMPRESSNONE:
        for (cnt = 0; cnt < usct; cnt += 2)
            {
            b = ReadBits(8);
            fpct[cnt  ].cbCode = (BYTE) ((int) b>>4);
            fpct[cnt+1].cbCode = (BYTE) ((int) b&15);
            }
        break;

    case COMPRESS1BIT:
        fpct[0].cbCode = byte = (BYTE) ReadBits(4);
        for (cnt = 1; cnt < usct; cnt++)
            {
            if (!ReadBits(1))
                fpct[cnt].cbCode = byte;
            else if (!ReadBits(1))
                fpct[cnt].cbCode = ++byte;
            else
                fpct[cnt].cbCode = byte = (BYTE) ReadBits(4);
            }
        break;

    case COMPRESS2BIT:
        fpct[0].cbCode = byte = (BYTE) ReadBits(4);
        for (cnt = 1; cnt < usct; cnt++)
            {
            if ((b=ReadBits(2)) != 3)
                fpct[cnt].cbCode = byte += (b-1);
            else
                fpct[cnt].cbCode = byte = (BYTE) ReadBits(4);
            }
        break;
        }
}


void  BuildHLookup(CODETABLE far *fpct, BYTE far *fpbLookup, int usct)
{
    int  usLookup = 0, cnt = 0, bCurNdx;
    int  bCurCode = 0, bCurLen = 100;
    int  iTemp; // HACK!!! bug in C600x requires expr to be broken down!
                // Otherwise it uses a WORD PTR instead of a BYTE PTR and
                // this GP faults as the 2nd byte often hangs off the edge
                // of a segment!!!

    for (cnt = 0; cnt < usct; cnt++)
        {
        if ((fpct[cnt].cbCode < (BYTE)bCurLen) && fpct[cnt].cbCode)
            {
            bCurLen = fpct[cnt].cbCode;
            bCurNdx = cnt;
            }
        }

    bCurCode = fpct[bCurNdx].usCode;
    if (bCurLen > 8)
        {
        bCurCode >>= (bCurLen - 8);
        bCurLen    = 8;
        }

    cnt = 0;
    while (1)
        {
        while (((cnt>>(8-bCurLen)) == bCurCode) && cnt < 256)
            fpbLookup[cnt++] = (BYTE) bCurNdx;

        iTemp = fpct[bCurNdx].nextCode;

        if (cnt == 256)
            break;

        if (fpct[iTemp].cbCode <= 8)
            bCurNdx = fpct[bCurNdx].nextCode;
        else
            {
            while (1)
                {
                bCurNdx = fpct[bCurNdx].nextCode;
                if ((fpct[bCurNdx].usCode>>(fpct[bCurNdx].cbCode-8)) != 
                        (BYTE) bCurCode)
                    break;
                }
            }
        bCurCode= fpct[bCurNdx].usCode;
        if ((bCurLen = fpct[bCurNdx].cbCode) > 8)
            {
            bCurCode >>= (bCurLen-8);
            bCurLen  = 8;
            }
        }
}


/*
**  BOOL UnpackJJJ1(void)
*/
BOOL UnpackJJJ1(void)
{
    int     i, cb, oStart, ibBufCur;
    USHORT  b, cnt, in;
    USHORT  usFlags;
    LONG    lcbOut;
    int     cType;
    int     b8Bit, b6Bit, b4aBit, b4bBit, b5Bit;
    int     isPtr = FALSE;
    USHORT  cCyclesUntilBreak = 1;

    vfUserCancel = FALSE;

    ibBufCur = cbBufMax - cbStrMax;
    usFlags = 0;
    lcbOut = 0;

    // Get the code table compression info
    b4aBit  = b4bBit = ReadByte(fhSrcGlobal);
    b5Bit   = b6Bit  = ReadByte(fhSrcGlobal);
    b8Bit            = ReadByte(fhSrcGlobal);

    b4aBit >>= 4;
    b5Bit  >>= 4;
    b8Bit  >>= 4;

    b4bBit &= 15;
    b6Bit  &= 15;

    _fmemset(ringBuf, ' ', cbBufMax - cbStrMax);

    cbIHold = 0;      //Reset globals
    fHitEOF = FALSE;

    ReadHTable(fpct4a, 16, b4aBit);
    BuildCodeTable(fpct4a, 16);
    BuildHLookup(fpct4a, fpbLookup4a, 16);

    ReadHTable(fpct4b, 16, b4bBit);
    BuildCodeTable(fpct4b, 16);
    BuildHLookup(fpct4b, fpbLookup4b, 16);

    ReadHTable(fpct5, 32, b5Bit);
    BuildCodeTable(fpct5, 32);
    BuildHLookup(fpct5, fpbLookup5, 32);

    ReadHTable(fpct6, 64, b6Bit);
    BuildCodeTable(fpct6, 64); 
    BuildHLookup(fpct6, fpbLookup6, 64);

    ReadHTable(fpct8, 256, b8Bit);
    BuildCodeTable(fpct8, 256);
    BuildHLookup(fpct8, fpbLookup8, 256);

    while (TRUE)
        {
        if (--cCyclesUntilBreak == 0)
            {
            if (vpfnYield != NULL)
                {
                cCyclesUntilBreak = 300;
                (*vpfnYield)(0);
                }
            else
                cCyclesUntilBreak = 30000;

            if (vfUserCancel)
                {
                if (fJmpEnvSet)
                    longjmp(jmpEnv, rcGenericDecompError);
                else
                    return((BOOL)FALSE);
                }
            }

        if (isPtr)
            {
            if ((cType = ReadHuffman(fpct4b, fpbLookup4b)) == EOF)
                break;
            }
        else
            {
            if ((cType = ReadHuffman(fpct4a, fpbLookup4a)) == EOF)
               break;
            }

        if (cType) // It's a pointer
            {
            isPtr = FALSE;

            /* extract the buffer offset and count to unpack */
            if ((oStart = ReadHuffman(fpct6, fpbLookup6)) == EOF)
                break;
            if ((i = ReadBits(6)) == EOF)
                break;
            oStart  = (oStart << 6) | i;
            oStart  = (ibBufCur - oStart + cbBufMax) & (cbBufMax - 1);

            cb = cType + cbIndex - 1;

            for (i = 0; i <= cb; i++)
                {
                WriteByte((BYTE)(b = ringBuf[(oStart + i) & (cbBufMax - 1)]));
                if (fDestFull)
                    return((BOOL)TRUE);
                lcbOut++;
                ringBuf[ibBufCur++] = (BYTE)b;
                ibBufCur &= cbBufMax - 1;
                }
            }
        else  // It's a literal count
            {
            if ((b = ReadHuffman(fpct5, fpbLookup5) + 1) == cbLitMax)
                isPtr = FALSE;
            else
                isPtr = TRUE;

            for (cnt = 0; cnt < b; cnt++)
                {
                if ((in = ReadHuffman(fpct8, fpbLookup8)) == EOF)
                    break;

                WriteByte((BYTE)in);
                if (fDestFull)
                    return((BOOL)TRUE);
                lcbOut++;
                ringBuf[ibBufCur++] = (BYTE)in;
                ibBufCur &= cbBufMax - 1;
                }
            if (cnt != b)
                break;
            }
     } 

     if (!eof(fhSrcGlobal))
         return((BOOL)TRUE);  // not an error condition if splitting file

     WriteOutBuff((BYTE)'\0');
     return((BOOL)TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\lzss\lzshare.c ===
/* TS = none */
/*
**  LZSHARE.C --  Shared code, variables, and defines for
**                 LZ compression/decompression module.
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <io.h>
#include <fcntl.h>
#include <malloc.h>
#include <dos.h>

#include "..\sutkcomp.h"
#include "lz.h"

#ifdef WIN_VER
HANDLE hRingBuf = NULL;
#endif /* WIN_VER */


USHORT  iMatchCur = 0;                  /* of longest match. These are */
USHORT  cbMatchCur = 0;                 /* set by the InsertNode() procedure. */

USHORT  cbStrMax = (16 + cbIndex);

ND *  rgRoot = NULL;                       // array of root pointers
ND *  rgND   = NULL;                       // node pointers themselves
ND    nilND  = { NULL };

  /* ring buffer of size cbBufMax, with extra cbStrMax-1 bytes */
  /* to facilitate string comparison */
BYTE  far *  ringBuf = NULL;


/*
**  BOOL  FAllocateLZGlobals(LONG lcbDestMax, fCompressing)
**
**  LZGlobal arrays take about 45K so I wanted to allocate and free them rather
**  than leave them around when not needed.
**
**  rgRoot and rgND are only needed when compressing, so they are only allocated
**  if fCompressing is TRUE.
*/
BOOL  FAllocateLZGlobals(LONG lcbDestMax, BOOL fCompressing)
{
    if (fCompressing)
        {
        rgND = (ND *)(malloc((cbBufMax + 1) * sizeof(ND)));
        rgRoot = (ND *)(malloc(256 * sizeof(ND)));
        if (rgND == NULL || rgRoot == NULL)
            {
            FreeLZGlobals();
            return(FALSE);
            }
        }

#define cbBuf ((cbBufMax + cbStrMax - 1) * sizeof(BYTE))
#ifndef WIN_VER
    ringBuf = (BYTE far *)_fmalloc(cbBuf);
#else  /* WIN_VER */
    GlobalCompact((DWORD)cbBuf);
    if ((hRingBuf = GlobalAlloc(GHND, (DWORD)cbBuf)) != NULL)
        ringBuf = (BYTE far *)GlobalLock(hRingBuf);
    else
        ringBuf = NULL;
#endif /* WIN_VER */
#undef cbBuf

    if (ringBuf == NULL)
        {
        FreeLZGlobals();
        return(FALSE);
        }

    if (!FAllocateReadWriteGlobals(lcbDestMax))
        {
        FreeLZGlobals();
        return(FALSE);
        }

    return((BOOL)TRUE);
}


/*
**  void  FreeLZGlobals(void)
*/
void FreeLZGlobals(void)
{
    FreeReadWriteGlobals();
    if (rgND != NULL)
        {
        free(rgND);
        rgND = NULL;
        }
    if (rgRoot != NULL)
        {
        free(rgRoot);
        rgRoot = NULL;
        }
#ifndef WIN_VER
    if (ringBuf != NULL)
        {
        _ffree(ringBuf);
        ringBuf = NULL;
        }
#else  /* WIN_VER */
    if (hRingBuf != NULL)
        {
        GlobalUnlock(hRingBuf);
        GlobalFree(hRingBuf);
        hRingBuf = NULL;
        ringBuf = NULL;
        }
#endif /* WIN_VER */
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\zk1\zk1.h ===
/* TS = none */
/*
**  ZK1.H -- Defines and externs for ZK1 compression/decompression
*/

#include "..\lzss\lz.h"

#define  cbStrMax   (16 + cbIndex)  /* upper limit for match_length */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\test\example2.c ===
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include <fcntl.h>
#include <direct.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <dos.h>
#include <malloc.h>

#include "sutkcomp.h"


/* ************************************************************** */
LONG MyWrite(int fhDest, BYTE far * fpbBuf, LONG lcbBuf)
{
	BYTE pbBuf[100];
	LONG lcbBufSav = lcbBuf;

	while (lcbBuf > 0L)
		{
		unsigned int cbWrite = (lcbBuf >= 100L) ? 100 : (unsigned int)lcbBuf;
		unsigned int ib;

		for (ib = cbWrite; ib > 0; )
			pbBuf[--ib] = *(fpbBuf + ib);

		if (write(fhDest, pbBuf, cbWrite) != (int)cbWrite)
			return(-1L);

		fpbBuf += cbWrite;
		lcbBuf -= (LONG)cbWrite;
		}

	return(lcbBufSav);
}


/* ************************************************************** */
int main(int argc, char * argv[])
{
	int        fhDest     = -1;
	int        fhSrc      = -1;
	SHORT      wReturn;
	LONG       lcbDecomp;
	LONG       lcbSkip    = 0L;
	long       libHeader;
	BYTE far * fpbBuf     = NULL;

	if ((fhSrc = open("input", O_RDONLY | O_BINARY)) == -1)
		{
		printf("unable to open source file 'input'\n");
		goto LExit;
		}

	if ((wReturn = WReadHeaderInfo(fhSrc)) < rcNoError)
		{
		printf("WReadHeaderInfo() failed; code = %d\n", wReturn);
		goto LExit;
		}

	/* need to return fhSrc either to the point after header or
	** to the beginning of file between successive calls to
	** LcbDecompressToBuffer().  If seeking to beginning, then
	** last arg to LcbDecompressToBuffer is FALSE.
	*/
	if ((libHeader = tell(fhSrc)) == -1L)
		{
		printf("unable to tell() on src\n");
		goto LExit;
		}

	if ((fhDest = open("output", O_TRUNC | O_BINARY | O_CREAT | O_WRONLY,
			S_IREAD | S_IWRITE)) == -1)
		{
		printf("unable to open destination file 'output'\n");
		goto LExit;
		}

	if ((fpbBuf = (BYTE far *)_fmalloc((size_t)65504)) == NULL)
		{
		printf("unable to alloc buffer of 65504 bytes from far heap\n");
		goto LExit;
		}

	while (TRUE)
		{
		/* need to return fhSrc either to the point after header or
		** to the beginning of file between successive calls to
		** LcbDecompressToBuffer().  If seeking to beginning, then
		** last arg to LcbDecompressToBuffer is FALSE.
		*/
		lcbDecomp = LcbDecompressToBuffer(fhSrc, fpbBuf, 65504L, lcbSkip,
				(BOOL)TRUE);

		if (lcbDecomp < rcNoError)
			{
			printf("LcbDecompressToBuffer() failed; code = %ld\n", lcbDecomp);
			goto LExit;
			}

		if (lcbDecomp == 0L)
			break;

		if (MyWrite(fhDest, fpbBuf, lcbDecomp) != lcbDecomp)
			{
			printf("unable to write buffer to file 'output'\n");
			goto LExit;
			}

		lcbSkip += lcbDecomp;

		/* need to return fhSrc either to the point after header or
		** to the beginning of file between successive calls to
		** LcbDecompressToBuffer().  If seeking to beginning, then
		** last arg to LcbDecompressToBuffer is FALSE.
		*/
		if (lseek(fhSrc, libHeader, SEEK_SET) == -1L)
			{
			printf("unable to seek src\n");
			goto LExit;
			}
		}

LExit:
	if (fhSrc != -1)
		close(fhSrc);
	if (fhSrc != -1)
		close(fhDest);
	if (fpbBuf != NULL)
		_ffree(fpbBuf);

	exit(0);
	return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\tools\tlshare.c ===
/* TS = none */
/*
**  TLSHARE.C  --  Shared code for Compression/Decompression Tools.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "..\sutkcomp.h"
#include "strings.h"

  /* forward declarations */
void  ErrorMsgRc(SHORT rc);
void  ExitErrorMsgRc(SHORT rc);
void  MSCopyright(BOOL fCompress);
#ifdef COMPLEX
BOOL  FUserConfirmsYN(void);
void  DividePathIntoBaseExt(SZ szPath, SZ *pszBase, SZ *pszExt);
void  GetDollarSzFromSzSrc(SZ szSrcFile, SZ szDstFile);

BOOL  vfForceOverwrite;
#endif /* COMPLEX */

/*
**  void  ExitErrorMsgRc(SHORT rc)
**
**  Prints an error message that corresponds to the given error code,
**  then exits.
**  See ..\retcodes.h for a list of the error return codes used.
*/
void ExitErrorMsgRc(SHORT rc)
{
    ErrorMsgRc(rc);
    exit((SHORT)(-rc));
}


/*
**  void  ErrorMsgRc(SHORT rc)
**
**  Prints an error message that corresponds to the given error code.
**  See ..\retcodes.h for a list of the error return codes used.
*/
void ErrorMsgRc(SHORT rc)
{
    printf(szError);
    switch (rc)
        {
    default:
        printf(szInternalError);
        break;
    case rcNoHeader:
        printf(szNoHeader);
        break;
    case rcUnknownAlgType:
        printf(szUnknownAlgType);
        break;
    case rcBadHeader:
        printf(szBadHeader);
        break;
    case rcFilenamesTooLong:
        printf(szFilenameTooLong);
        break;
    case rcReadError:
        printf(szReadError);
        break;
    case rcReadSeekError:
        printf(szReadSeekError);
        break;
    case rcWriteError:
        printf(szWriteError);
        break;
    case rcWriteSeekError:
        printf(szWriteSeekError);
        break;
    case rcDestPatchError:
        printf(szDestPatchError);
        break;
    case rcCompChecksumBad:
        printf(szCompChecksumBad);
        break;
    case rcDecompChecksumBad:
        printf(szDecompChecksumBad);
        break;
    case rcCompLengthBad:
        printf(szCompLengthBad);
        break;
    case rcDecompLengthBad:
        printf(szDecompLengthBad);
        break;
    case rcGenericCompError:
        printf(szGenericCompError);
        break;
    case rcGenericDecompError:
        printf(szGenericDecompError);
        break;
    case rcSplitSizeTooSmall:
        printf(szSplitSizeTooSmall);
        break;
    case rcOutOfMemory:
        printf(szOutOfMemory);
        break;
    case rcZeckSplitFile:
        printf(szZeckSplitFile);
        break;
        }

    printf("\n");
}


#ifdef COMPLEX
/*
**  BOOL  FUserConfirmsYN(void)
**
**  Assumes the user has already been asked a question.  This proc waits
**  for the answer, makes sure it is valid, flushes excess input characters,
**  and returns TRUE if they answered in the affirmative and FALSE if they
**  answered in the negative.
*/
BOOL  FUserConfirmsYN()
{
    CHAR  chRead;
    CHAR  chFlush;

    while (TRUE)
        {
        chRead = chFlush = (CHAR)getchar();
        while (chFlush != '\n')      /* flush input so next getchar will work */
            chFlush = (CHAR)getchar();
        printf("\n");

        switch (chRead)
            {
        default:
            printf(szYorN);
            break;
        case 'Y':
        case 'y':
        case '\n':
            return((BOOL)TRUE);
        case 'N':
        case 'n':
            return(FALSE);
            }
        }
}
#endif /* COMPLEX */


#ifdef COMPLEX
void DividePathIntoBaseExt(SZ szPath, SZ * pszBase, SZ * pszExt)
{
    CHAR  *pchFind;

    *pszBase = szPath;
    *pszExt = NULL;

    pchFind = strrchr(szPath, ':');
    if (pchFind != NULL)
        *pszBase = ++pchFind;

    pchFind = strrchr(szPath, '\\');
    if (pchFind != NULL)
        *pszBase = ++pchFind;

    pchFind = strchr(*pszBase, '.');
    if (pchFind != NULL)
        *pszExt = ++pchFind;
}
#endif /* COMPLEX */


/*
**  void  MSCopyright(BOOL fCompress)
**
**  Print copyright message whenever utility is run.
*/
void MSCopyright(BOOL fCompress)
{
    if (fCompress)
        printf(szCompCopyright1);
    else
        printf(szDecompCopyright1);
    printf(szCopyright2);
    printf(szCopyright3);
}


#ifdef COMPLEX
/*
**  void  GetDollarSzFromSzSrc(SZ szSrcFile, SZ szBaseFile)
**
**  Get a suitable name for the output files from the source name,
**  using the Languages Group's way of tagging compressed files.
**         If there's no extension, make '._' the extension.
**         If there's room to append an underscore to the extension, append it.
**         Else make the last character of the extension an underscore.
*/
void GetDollarSzFromSzSrc(SZ szSrcFile, SZ szDstFile)
{
    int  cch;
    CHAR *pchExt;
    CHAR *pchBack;

    strcpy(szDstFile, szSrcFile);
    cch = strlen(szDstFile);
    pchExt  = strchr(szDstFile, '.');
    pchBack = strchr(szDstFile, '\\');

    if (pchBack != NULL && pchExt != NULL && pchBack > pchExt)
        pchExt = NULL;

    if (pchExt == NULL)
        strcat(szDstFile, "._");
    else if (strlen(pchExt) >= 4)           /* pch includes the decimal point */
        {
        szDstFile[cch - 1] = '_';
        pchExt[3] = '_';
        }
    else
        strcat(szDstFile, "_");
}
#endif /* COMPLEX */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\tools\decomptl.c ===
/* TS = none */
/*
**  DECOMPTL.C  --  Decompression Tool for Setup Toolkits.
*/

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include <fcntl.h>
#include <direct.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>
#ifndef OS2_VER
#include <dos.h>
#endif /* !OS2_VER */
#include "..\sutkcomp.h"
#include "strings.h"


  /* forward declarations */
int   main(int argc, char ** argv);
void  Usage(SHORT wExitCode);
void  UsageMessageOnly(void);
int   FhOpenSrc(SZ szSrcPath, SZ szSrcFileName);

#ifdef COMPLEX
void  GetSzSrcFileFromUser(SZ * pszSrcFile);
void  GetSzDestFileFromUser(SZ szDestFile, SZ szSrcFile);

extern  void  DividePathIntoBaseExt(SZ szPath, SZ *pszBase, SZ *pszExt);
extern  BOOL  FUserConfirmsYN(void);
extern  void  GetDollarSzFromSzSrc(SZ szSrcFile, SZ szDstFile);

extern  BOOL  vfForceOverwrite;
#endif /* COMPLEX */

extern  void  ExitErrorMsgRc(SHORT rc);
extern  void  ErrorMsgRc(SHORT rc);
extern  void  MSCopyright(BOOL fCompress);

#ifdef ZECKFORMAT
extern  BOOL  vfZeckFormat;
#endif  /* ZECKFORMAT */

#ifdef OS2_VER
#define  ZZNAMEZZ  achName
#else  /* !OS2_VER */
#define  ZZNAMEZZ  name
#endif /* !OS2_VER */



#ifdef XL_EXT_TRANSLATE
/*
**  static  BOOL  FTranslateExcelExtension(SZ szSrcExt)
**
**  If extension is of the form "CP?", use the Excel translation table
**  to fill vszExtension (as if it had been found in the header).
*/
static  BOOL  FTranslateExcelExtension(SZ szSrcExt)
{
    if (*szSrcExt != 'C' && *szSrcExt != 'c')
        return(FALSE);
    if (*(szSrcExt + 1) != 'P' && *(szSrcExt + 1) != 'p')
        return(FALSE);

    switch (*(szSrcExt + 2))
        {
    default:
        return(FALSE);

    case '1':
        strcpy(vszExtension, "1");
        break;

    case '2':
        strcpy(vszExtension, "2");
        break;

    case '3':
        strcpy(vszExtension, "3");
        break;

    case 'c':
    case 'C':
        strcpy(vszExtension, "XLC");
        break;

    case 'e':
    case 'E':
        strcpy(vszExtension, "EXE");
        break;

    case 'f':
    case 'F':
        strcpy(vszExtension, "FON");
        break;

    case 'h':
    case 'H':
        strcpy(vszExtension, "HLP");
        break;

    case 'm':
    case 'M':
        strcpy(vszExtension, "XLM");
        break;

    case 's':
    case 'S':
        strcpy(vszExtension, "XLS");
        break;

    case 't':
    case 'T':
        strcpy(vszExtension, "CBT");
        break;

    case 'v':
    case 'V':
        strcpy(vszExtension, "DRV");
        break;

    case 'w':
    case 'W':
        strcpy(vszExtension, "XLW");
        break;

    case 'y':
    case 'Y':
        strcpy(vszExtension, "SYS");
        break;
        }

    return(TRUE);
}
#endif


int  FhOpenSrc(SZ szSrcPath, SZ szSrcFileName)
{
    CHAR   rgchSrcFile[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    CHAR * pch;

    strcpy(rgchSrcFile, szSrcPath);

    if ((pch = strrchr(rgchSrcFile, '\\')) == NULL)
        {
        if (rgchSrcFile[1] == ':')
            rgchSrcFile[2] = '\0';
        else
            rgchSrcFile[0] = '\0';
        }
    else
        *(pch + 1) = '\0';

    strcat(rgchSrcFile, szSrcFileName);
    strcpy(szSrcPath, rgchSrcFile);

    return(open(rgchSrcFile, O_RDONLY | O_BINARY));
}


#ifdef COMPLEX
void  GetSzSrcFileFromUser(SZ * pszSrcFile)
{
    if ((*pszSrcFile = (SZ)malloc(80 * sizeof(CHAR))) == NULL)
        ExitErrorMsgRc(rcOutOfMemory);

LAskForSrcName:
    printf(szEnterSrcName);
    if (gets(*pszSrcFile) == NULL)
        {
        printf(szGetsFailure);
        exit(26);
        }

    *(*pszSrcFile + 79) = '\0';
    while (strlen(*pszSrcFile) && isspace(**pszSrcFile))
        memmove(*pszSrcFile, *pszSrcFile + 1, 79);

    if (!strlen(*pszSrcFile))
        goto LAskForSrcName;
}
#endif /* COMPLEX */


#ifdef COMPLEX
void  GetSzDestFileFromUser(SZ szDestFile, SZ szSrcFile)
{
    while (1)
        {
        printf(szEnterDestName);
        if (gets(szDestFile) == NULL)
            {
            printf(szGetsFailure);
            exit(26);
            }

        *(szDestFile + 79) = '\0';
        while (strlen(szDestFile) && isspace(*szDestFile))
            memmove(szDestFile, szDestFile + 1, 79);

        if (stricmp(szSrcFile, szDestFile))
            return;

        printf(szSrcDestDifferent);
        }
}
#endif /* COMPLEX */


/*
**  int  main(int argc, char * argv[])
**
**  Main decompress routine.
*/
int main(int argc, char * argv[])
{
    int     iArg;
    SZ      szSrcFile = NULL;
    BOOL    fForceAppend = FALSE;
    BOOL    fComputeOnly = FALSE;
    BOOL    fFileFound;
#ifdef COMPLEX
    SZ      szSrcBase;
    SZ      szSrcExt;
    SHORT   cch;
    struct  stat  statBuf;
#endif /* COMPLEX */
#ifdef DOLLAR_SUFFIX
    CHAR    chLast;
#endif /* DOLLAR_SUFFIX */
    int     fhDest;
    int     fhSrc;
    CHAR    rgchSrcFile[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    CHAR    rgchDestFile[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    CHAR    rgchDestFileSav[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    LONG    lcbDecompressed;
    SHORT   wReturn;
    SHORT   wExitCode = 0;

#ifdef OS2_VER
    HDIR    hdir;
    USHORT  usSearchCount;
    FILEFINDBUF     ffindBuf;
    FILESTATUS      fsSrc;
#else  /* !OS2_VER */
    struct  find_t  ffindBuf;
    USHORT  usDate;
    USHORT  usTime;
#endif /* !OS2_VER */

#ifdef DOLLAR_SUFFIX
    BOOL    fUsingDollarSignedSrc = FALSE;
#endif /* DOLLAR_SUFFIX */

#ifdef COMPLEX
    vfForceOverwrite = FALSE;
#endif /* COMPLEX */

    MSCopyright(FALSE);

    for (iArg = 1; iArg < argc
            && (argv[iArg][0] == '-' || argv[iArg][0] == '/'); iArg++)
        {
        switch (argv[iArg][1])
            {
        default:
            Usage(20);

        case 'a':
        case 'A':
            fForceAppend = (BOOL)TRUE;
            break;

#ifdef COMPLEX
        case 'f':
        case 'F':
            vfForceOverwrite = (BOOL)TRUE;
            break;
#endif /* COMPLEX */

        case '?':
        case 'h':
        case 'H':
            Usage(0);

#ifdef COMPLEX
        case 'q':
        case 'Q':
            fComputeOnly = (BOOL)TRUE;
            break;
#endif /* COMPLEX */
            }
        }

#ifdef COMPLEX
      /* there can be at most two filenames after flags */
    if (iArg < argc - 2)
#else  /* !COMPLEX */
      /* there must be two filenames after flags */
    if (iArg != argc - 2)
#endif /* !COMPLEX */
        Usage(19);

    if (iArg < argc)
        {
        szSrcFile = argv[iArg++];
        if (!strcmp(szSrcFile, "?"))
            Usage(0);
        }

    if (iArg < argc)
        strcpy(rgchDestFile, argv[iArg]);
#ifdef COMPLEX
    else
        strcpy(rgchDestFile, "");

    if (szSrcFile == NULL)
        {
        UsageMessageOnly();
        GetSzSrcFileFromUser(&szSrcFile);
        if (!fComputeOnly)
            GetSzDestFileFromUser(rgchDestFile, szSrcFile);
        }
#endif /* COMPLEX */

    strcpy(rgchSrcFile, szSrcFile);

    strcpy(rgchDestFileSav, rgchDestFile);
#ifdef COMPLEX
      /* it may LOOK like a filename, but add a slash if it's really a dir */
    if ((cch = strlen(rgchDestFile)) != 0 && rgchDestFile[cch - 1] != '\\'
            && (cch != 2 || rgchDestFile[1] != ':') && !access(rgchDestFile, 00)
            && !stat(rgchDestFile, &statBuf) && (statBuf.st_mode & S_IFDIR))
        strcat(rgchDestFileSav, "\\");
#endif /* COMPLEX */

#ifdef DOLLAR_SUFFIX
    chLast = *(rgchSrcFile + strlen(rgchSrcFile) - 1);
    if (chLast == '_' || chLast == '$' || chLast == '*' || chLast == '?')
        fUsingDollarSignedSrc = (BOOL)TRUE;
#endif /* DOLLAR_SUFFIX */

#ifdef OS2_VER
    usSearchCount = 1;
    hdir = HDIR_CREATE;
    fFileFound = (BOOL)(!DosFindFirst(rgchSrcFile, &hdir,
            FILE_NORMAL | FILE_READONLY, &ffindBuf, sizeof(FILEFINDBUF),
            &usSearchCount, 0L));
#else  /* !OS2_VER */
    fFileFound = (BOOL)(!_dos_findfirst(rgchSrcFile, _A_NORMAL | _A_RDONLY,
            &ffindBuf));
#endif /* !OS2_VER */

    if (!fFileFound)
        {
#ifdef DOLLAR_SUFFIX
        fUsingDollarSignedSrc = (BOOL)TRUE;
        GetDollarSzFromSzSrc(szSrcFile, rgchSrcFile);

LTryFindFirstFile:

#ifdef OS2_VER
        DosFindClose(hdir);
        usSearchCount = 1;
        hdir = HDIR_CREATE;
        fFileFound = (BOOL)(!DosFindFirst(rgchSrcFile, &hdir,
                FILE_NORMAL | FILE_READONLY, &ffindBuf, sizeof(FILEFINDBUF),
                &usSearchCount, 0L));
#else  /* !OS2_VER */
        fFileFound = (BOOL)(!_dos_findfirst(rgchSrcFile, _A_NORMAL | _A_RDONLY,
                &ffindBuf));
#endif /* !OS2_VER */

        if (!fFileFound)
            if (*(rgchSrcFile + strlen(rgchSrcFile) - 1) == '_')
                {
                *(rgchSrcFile + strlen(rgchSrcFile) - 1) = '$';
                goto LTryFindFirstFile;
                }
            else
#endif /* DOLLAR_SUFFIX */
                {
                printf(szNoSrcFile);
                exit(21);
                }
        }

#ifdef COMPLEX
    while (fFileFound)
#endif /* !COMPLEX */
        {
        BOOL  fAppend = fForceAppend;

        if ((fhSrc = FhOpenSrc(rgchSrcFile, ffindBuf.ZZNAMEZZ)) == -1)
            {
            printf(szCantOpenInput, rgchSrcFile);
            goto LFindNextFile;
            }

        printf("%s\n", rgchSrcFile);

        if ((wReturn = WReadHeaderInfo(fhSrc)) < rcNoError)
            {
            ErrorMsgRc(wReturn);
            wExitCode = -wReturn;
            goto LFindNextFile;
            }

#ifdef COMPLEX
        if (fComputeOnly)
            {
            lcbDecompressed = LcbCalculateDecompressedLength(fhSrc, (BOOL)TRUE);
            close(fhSrc);
            if (lcbDecompressed < (LONG)rcNoError)
                {
                ErrorMsgRc((SHORT)lcbDecompressed);
                wExitCode = (SHORT)(-lcbDecompressed);
                }
            else
                printf(szDecompSize, lcbDecompressed);
            goto LFindNextFile;
            }
#endif /* COMPLEX */

        strcpy(rgchDestFile, rgchDestFileSav);
#ifdef COMPLEX
        cch = strlen(rgchDestFile);
        if (!cch || rgchDestFile[cch-1] == '\\' || rgchDestFile[cch-1] == ':')
            {
            DividePathIntoBaseExt(ffindBuf.ZZNAMEZZ, &szSrcBase, &szSrcExt);

#ifdef XL_EXT_TRANSLATE
            if (vszExtension[0] == '\0')
                FTranslateExcelExtension(szSrcExt);
#endif

            if (szSrcExt != NULL)
                *(szSrcExt - 1) = '\0';

            if (vszBaseName[0] != '\0')
                strcat(rgchDestFile, vszBaseName);
            else
                strcat(rgchDestFile, szSrcBase);

            if (vszExtension[0] != '\0')
                {
                strcat(rgchDestFile, ".");
                if (*vszExtension != ' ')
                    strcat(rgchDestFile, vszExtension);
                }
            else if (szSrcExt != NULL)
                {
                strcat(rgchDestFile, ".");
                strcat(rgchDestFile, szSrcExt);
                }

            if (szSrcExt != NULL)
                *(szSrcExt - 1) = '.';
            }
#endif /* COMPLEX */

        if (!fForceAppend && !access(rgchDestFile, 00))
            {
#ifdef COMPLEX
            if (!vfForceOverwrite)
                {
                printf(szFileExists, rgchDestFile);

                printf(szAppendQ);
                if ((fAppend = FUserConfirmsYN()))
                    goto LAppendToExistingFile;

                printf(szOverwriteYN);
                }
            if (vfForceOverwrite || FUserConfirmsYN())
                {
#endif /* COMPLEX */
                chmod(rgchDestFile, S_IREAD | S_IWRITE);
                remove(rgchDestFile);
                if (!access(rgchDestFile, 00))
                    {
                    printf(szCantOverwrite, rgchDestFile);
                    close(fhSrc);
                    goto LFindNextFile;
                    }
#ifdef COMPLEX
                }
            else
                {
                close(fhSrc);
                goto LFindNextFile;
                }
#endif /* COMPLEX */
            }

#ifdef COMPLEX
LAppendToExistingFile:
#endif /* COMPLEX */
        if (fAppend)
            {
            fhDest = open(rgchDestFile, O_APPEND | O_BINARY | O_CREAT |O_WRONLY,
                    S_IREAD | S_IWRITE);
            if (lseek(fhDest, 0L, 2) == -1L)
                {
                close(fhSrc);
                close(fhDest);
                ErrorMsgRc(rcWriteSeekError);
                wExitCode = -rcWriteSeekError;
                goto LFindNextFile;
                }
            }
        else
            fhDest = open(rgchDestFile, O_TRUNC | O_BINARY | O_CREAT | O_WRONLY,
                    S_IREAD | S_IWRITE);

        if (fhDest == -1)
            {
            close(fhSrc);
            printf(szCantOpenOutput, rgchDestFile);
            goto LFindNextFile;
            }

#ifdef OS2_VER
        if (DosQFileInfo((HFILE)fhSrc, (USHORT)0x0001, &fsSrc,
                (USHORT)(sizeof(fsSrc))))
#else /* not OS2_VER */
        if (_dos_getftime(fhSrc, &usDate, &usTime))
#endif /* OS2_VER */
            {
            ErrorMsgRc(rcReadError);
            wExitCode = -rcReadError;
            goto LFindNextFile;
            }

        lcbDecompressed = LcbDecompressToFile(fhSrc, fhDest, NIL,0L,(BOOL)TRUE);

#ifdef OS2_VER
        if (DosSetFileInfo((HFILE)fhDest, (USHORT)0x0001, &fsSrc,
                (USHORT)(sizeof(fsSrc))))
#else /* not OS2_VER */
        if (_dos_setftime(fhDest, usDate, usTime))
#endif /* OS2_VER */
            {
            ErrorMsgRc(rcWriteError);
            wExitCode = -rcWriteError;
            goto LFindNextFile;
            }

        close(fhSrc);
        close(fhDest);

        if (lcbDecompressed < rcNoError)
            {
#ifdef ZECKFORMAT
            if (vfZeckFormat && lcbDecompressed == rcDecompLengthBad)
                ExitErrorMsgRc(rcZeckSplitFile);
#endif /* ZECKFORMAT */
            ErrorMsgRc((SHORT)lcbDecompressed);
            wExitCode = (SHORT)(-lcbDecompressed);
            goto LFindNextFile;
            }
        else
            printf(szWroteBytes, lcbDecompressed, rgchDestFile);

LFindNextFile:

#ifdef COMPLEX
#ifdef OS2_VER
        usSearchCount = 1;
        fFileFound = (BOOL)(!DosFindNext(hdir, &ffindBuf, sizeof(FILEFINDBUF),
                &usSearchCount));
#else  /* !OS2_VER */
        fFileFound = (BOOL)(!_dos_findnext(&ffindBuf));
#endif /* !OS2_VER */

#ifdef DOLLAR_SUFFIX
        if (!fFileFound && !fUsingDollarSignedSrc)
            {
            fUsingDollarSignedSrc = (BOOL)TRUE;
            GetDollarSzFromSzSrc(szSrcFile, rgchSrcFile);

LTryFindNextFile:
#ifdef OS2_VER
            DosFindClose(hdir);
            usSearchCount = 1;
            hdir = HDIR_CREATE;
            fFileFound = (BOOL)(!DosFindFirst(rgchSrcFile, &hdir,
                    FILE_NORMAL | FILE_READONLY, &ffindBuf, sizeof(FILEFINDBUF),
                    &usSearchCount, 0L));
#else  /* !OS2_VER */
            fFileFound = (BOOL)(!_dos_findfirst(rgchSrcFile,
                    _A_NORMAL | _A_RDONLY, &ffindBuf));
#endif /* !OS2_VER */
            if (!fFileFound && *(rgchSrcFile + strlen(rgchSrcFile) - 1) == '_')
                {
                *(rgchSrcFile + strlen(rgchSrcFile) - 1) = '$';
                goto LTryFindNextFile;
                }
            }
#endif /* DOLLAR_SUFFIX */
#else  /* !COMPLEX */
            ;
#endif /* !COMPLEX */
        } /* while (!fFileFound) */

#ifdef OS2_VER
    DosFindClose(hdir);
#endif /* OS2_VER */

    exit(wExitCode);
    return(wExitCode);
}


/*
**  void  UsageMessageOnly(void)
**
**  Print usage message when command line args are bad.
*/
void UsageMessageOnly(void)
{
    printf(szDecompUsage1);
    printf(szDecompUsage2);
#ifdef COMPLEX
    printf(szDecompUsage3);
    printf(szDecompUsage4);
    printf(szDecompUsage5);

    printf(szDecompUsage6);
    printf(szDecompUsage7);
    printf(szDecompUsage8);
    printf(szDecompUsage9);
    printf(szDecompUsage10);
#endif /* COMPLEX */
}


/*
**  void  Usage(SHORT wExitCode)
**
**  Print usage message when command line args are bad then exit.
*/
void Usage(SHORT wExitCode)
{
    UsageMessageOnly();
    exit(wExitCode);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\zk1\zk1comp.c ===
/* TS = none */
/*
**  ZK1COMP.C  --  Zeck Compression module - first implementation
**
**  This comes to us from Languages via Excel and is used many places.
**  Still, I altered some of the code to fit my API.  Original sources
**  can be found in \\odin\slm!src\setup\compress.
*/

/*                    Zeck Data Compression Program
**                      (C) Copyright 1989 by Microsoft
**                           Written By Steven Zeck
*/

#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <io.h>
#include <fcntl.h>
#include <stdio.h>

#include "..\sutkcomp.h"

#ifdef OS2SU
#include <doscalls.h>
#endif

#include "zk1.h"

#include "setjmp.h"

extern BOOL    fJmpEnvSet;
extern jmp_buf jmpEnv;



/*
**  LONG Lcb_ZK1_CompressToFile(int fhSrc, int fhDest, LONG lcbDestMax)
**
**  Note - this is basically SteveZ's encode() routine.
**
**  Assumes that the header has already been written.
*/
LONG Lcb_ZK1_CompressToFile(int fhSrc, int fhDest, LONG lcbDestMax)
{
    USHORT   us;
    SHORT    ch, cbLen, ibCharCur, ibStringCur, cbMatchLast, ibCodeBuf;
    BYTE     rgbCodeBuf[cbStrMax], mask;
    LONG     libSrcStart = tell(fhSrc);
    LONG     libDestStart = tell(fhDest);
    LONG     lReturn;
    int      iJmpReturn;

    if (!FAllocateLZGlobals(lcbDestMax, (BOOL)TRUE))
        return((LONG)rcOutOfMemory);

    if ((iJmpReturn = setjmp(jmpEnv)) != 0)
        {
        FreeLZGlobals();
        fJmpEnvSet = FALSE;
        return((LONG)iJmpReturn);
        }
    fJmpEnvSet = TRUE;

    if (lcbDestMax != NIL && (LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestMax)
        fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestMax;

    fhDestGlobal = fhDest;
    lcbSkipOut = 0L;
    fpbBufDest = NULL;

    LZInitTree();

      /* rgbCodeBuf[1..16] saves eight units of code, and
      ** rgbCodeBuf[0] works as eight flags, "1" representing that the unit
      ** is an unencoded letter (1 byte), "0" a position-and-length pair
      ** (2 bytes).  Thus, eight units require at most 16 bytes of code.
      */
    rgbCodeBuf[0] = 0;
    ibCodeBuf = mask = 1;

      /* Clear the buffer with any character that will appear often. */
    ibStringCur = 0;
    _fmemset(ringBuf, ' ', (ibCharCur = cbBufMax - cbStrMax));

      /* Read cbStrMax bytes into the last cbStrMax bytes of the buffer */
    for (cbLen = 0; cbLen < cbStrMax && (ch = ReadByte(fhSrc)) != EOF; cbLen++)
        ringBuf[ibCharCur + cbLen] = (BYTE)ch;

      /* Insert the cbStrMax strings,
      ** each of which begins with one or more 'space' characters.  Note
      ** the order in which these strings are inserted.  This way,
      ** degenerate trees will be less likely to occur.
      */
    for (us = 1; us <= cbStrMax; us++)
        LZInsertNode(ibCharCur - us);

      /* Finally, insert the whole string just read.  The
      ** global variables cbMatchCur and iMatchCur are set.
      */
    LZInsertNode(ibCharCur);

    do  {
            /* cbMatchCur may be spuriously long near the end of text. */
        if (cbMatchCur > (USHORT)cbLen)
            cbMatchCur = (USHORT)cbLen;

        if (cbMatchCur <= cbIndex)
            {   /* Not long enough match. Send one byte. */
                /* 'send one byte' flag.  Send uncoded. */
            cbMatchCur = 1;
            rgbCodeBuf[0] |= mask;
            rgbCodeBuf[ibCodeBuf++] = ringBuf[ibCharCur];
            }
        else
            {   /* Send position and length pair. Note cbMatchCur > cbIndex. */
            rgbCodeBuf[ibCodeBuf++] = (BYTE)iMatchCur;
            rgbCodeBuf[ibCodeBuf++] = (BYTE)((iMatchCur >> 4 & 0xf0) |
                                                  (cbMatchCur - (cbIndex + 1)));
            }

        if ((mask <<= 1) == 0)   /* Shift mask left one bit. */
            {
                /* Send at most 8 units of code together */
            for (us = 0; us < (USHORT)ibCodeBuf; us++)
                {
                WriteByte(rgbCodeBuf[us]);
                if (fWriteError || fDestFull)
                    goto LExit;
                }

            rgbCodeBuf[0] = 0;
            ibCodeBuf = mask = 1;
            }
        cbMatchLast = cbMatchCur;

        for (us = 0; us < (USHORT)cbMatchLast && (ch = ReadByte(fhSrc)) != EOF;
                                                                           us++)
            {
            LZDeleteNode(ibStringCur);      /* Delete old strings and */
            ringBuf[ibStringCur] = (BYTE)ch;        /* read new bytes */

              /* If the position is near the end of buffer, extend the
              ** buffer to make string comparison easier.
              */
            if (ibStringCur < cbStrMax - 1)
                ringBuf[ibStringCur + cbBufMax] = (BYTE)ch;

              /* ring buffer, increment the position modulo N. */
            ibStringCur = ibStringCur+1 & (cbBufMax - 1);
            ibCharCur = ibCharCur+1 & (cbBufMax - 1);

              /* Register the string in ringBuf[r..r+cbStrMax-1] */
            LZInsertNode(ibCharCur);
            }

        while (us++ < (USHORT)cbMatchLast)         /* After the end of text, */
            {
            LZDeleteNode(ibStringCur);        /* no need to read, but */

            ibStringCur = ibStringCur+1 & (cbBufMax - 1);
            ibCharCur = ibCharCur+1 & (cbBufMax - 1);
            if (--cbLen)
                LZInsertNode(ibCharCur);          /* buffer may not be empty. */
            }
         } while (cbLen > 0); /* length of string to be processed is zero */

    if (ibCodeBuf > 1)                 /* Send remaining code. */
        {
        for (us = 0; us < (USHORT)ibCodeBuf; us++)
            {
            WriteByte(rgbCodeBuf[us]);
            if (fWriteError || fDestFull)
                goto LExit;
            }
        }

    WriteOutBuff(0);

LExit:
    fJmpEnvSet = FALSE;
    FreeLZGlobals();

    if (fWriteError)
        return((LONG)rcWriteError);

    if (lcbDestMax == NIL || fhDest == -1)
        return(lcbDest);

      /* fix fhSrc because we split */
    lReturn = lcbDest;             /* lcbDest gets altered by the Decomp call */

      /* reset fhDest (after header) */
    if (lseek(fhDest, libDestStart, SEEK_SET) == -1L)
        return((LONG)rcWriteSeekError);

      /* lcbDest = uncompressed length of this current piece */
    lcbDest = Lcb_ZK1_DecompressToFile(fhDest, -1, NIL, 0L);
    if (lcbDest < rcNoError)
        return(lcbDest);

      /* reset fhSrc */
    if (lseek(fhSrc, libSrcStart + lcbDest, SEEK_SET) == -1L)
        return((LONG)rcReadSeekError);

    return(lReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\tools\strings.h ===
/* TS = none */

/* REVIEW - we could save some space by not repeating some strings */
#define szError             "  Error -- "
#define szWarning           "\n  Warning -- "

/* ERROR MESSAGES AND OTHER STRINGS */
#define szNoChecksum        szWarning "Checksum not currently supported\n"
#define szNoQWithS          szWarning "'-q' flag causes Compress to ignore '-s' flag\n"
#define szNoDestWith$       szWarning "'-$' flag causes Compress to ignore output filename\n"
#define szCantOpenInput     szError "cannot open input file:  %s\n\n"
#define szCantOpenOutput    szError "cannot open output file:  %s\n\n"
#define szFileExists        szWarning "the file '%s' exists.\n"
#define szAppendQ           "    Should I append to that file?  Yes or No? "
#define szOverwriteYN       "    Should I try to overwrite it?  Yes or No? "
#define szCantOverwrite     szWarning "unable to overwrite '%s'\n"
#define szAlreadyCompressed szWarning "the file '%s' may already be compressed.\n\tShould I proceed?  Yes or No? "
#define szFilenameTooLongSz szError "filename '%s.%s' is too long\n\n"
#define szBytesCompressed   "   %1ld bytes compresses to %1ld bytes,  "
#define szPercentSavings    "Savings: %1d percent\n"
#define szNoSavings         "No Savings\n"
#define szWroteBytes        "      Wrote %6ld bytes to output file '%s'\n"
#define szNoOutputNames     szError "ran out of output file names (Max == 10)\n\n"
#define szDecompSize        "Decompression would result in a file of %1ld bytes.\n"
#define szNoDestInHeader    szError "no destination file name in source file header.\n\n\t\tYou need to supply one on the command line.\n"
#define szSrcDestDifferent  szError "source and destination files must be different.\n\n"
#define szTailBytes         "\n      Writing the remaining %1ld source bytes to the file '%s'\n"
#define szDestDirWild       "Destination must be a directory in a wildcard compress.\n"
#define szDestDirTree       "Destination must be a directory in a treecopy compress.\n"
#define szTotals            "\nTotals: "
#define szEnterSrcName      "\n\n    Enter the name and/or path for the compressed file: "
#define szGetsFailure       szError "gets() failed.\n"
#define szEnterDestName     "    Enter the name and/or path for the decompressed file: "
#define szNoSrcFile         "No Source file found\n"


/* These strings match up with error return codes in retcodes.h */
#define szYorN              "Please enter Y or N "
#define szInternalError     "Internal error\n"
#define szNoHeader          "No header in file (file might not be compressed)\n"
#define szUnknownAlgType    "Unknown compression algorithm\n"
#define szBadHeader         "Bad header in file\n"
#define szFilenameTooLong   "File name too long\n"
#define szReadError         "Read error\n"
#define szReadSeekError     "Error seeking for read\n"
#define szWriteError        "Write error\n"
#define szWriteSeekError    "Error seeking for write\n"
#define szDestPatchError    "Cannot patch header in output file\n"
#define szCompChecksumBad   "Compression checksums do not match\n"
#define szDecompChecksumBad "Decompression checksums do not match\n"
#define szCompLengthBad     "Compressed file length mismatch\n"
#define szDecompLengthBad   "Decompressed file length mismatch\n"
#define szGenericCompError  "Internal error during compression\n"
#define szGenericDecompError  "Internal error during decompression\n"
#define szSplitSizeTooSmall "Split size is too small to hold header\n"
#define szOutOfMemory       "Out of memory\n"
#define szZeckSplitFile     "Cannot recombine old format split files; only first file decompressed\n"


/* COPYRIGHT NOTICES */
#define szCompCopyright1   "Microsoft (R) Compression Utility - "
#define szDecompCopyright1 "Microsoft (R) Decompression Utility - "
#define szCopyright2  "Version 1.11\n"
#define szCopyright3  "Copyright (c) Microsoft Corp 1989 - 1992.  All rights reserved.\n\n"


/* USAGE MESSAGE FOR COMPRESSION */
#define szCompUsage1  "Usage: compress [-aAlg -bceflq$ -sSize -tText -zSize] srcArg [destArg]\n"
#define szCompUsage2  "   -a -- Choices for compression algorithm are:  [default = %1d]\n"
#define szCompUsage3  "     %2d - Straight Copying with Header attached.\n"
#define szCompUsage4  "     %2d - Copying while XORing each byte with 0xff.\n"
#define szCompUsage5  "     %2d - the Steven Zeck algorithm.\n"
#define szCompUsageJJJ1 "     %2d - Jeff Johnson's algorithm (LZSS + Huffman).\n"
#define szCompUsage6  "   -be will include each file basename/extension in the header.\n"
#define szCompUsageX  "   -c will include a checksum of each file in the header.\n"
#define szCompUsage7  "   -f will force overwriting and recompression of files.\n"
#define szCompUsage8  "   -l will NOT include each file length in the header.\n"
#define szCompUsage9  "   -q will compute compressed file lengths (no output) (ignores -sz flags).\n"
#define szCompUsage10  "   -s will split output into Size x 512 byte pieces naming each piece\n"
#define szCompUsage11  "      with a sequentially higher numerical base name.\n"
#define szCompUsage12  "   -t will include following Text in the header.\n"
#define szCompUsage13  "      Text that includes spaces should be double-quoted.\n"
#define szCompUsage14  "   -z will split off and compress just one piece, and leave the\n"
#define szCompUsage15  "      remainder uncompressed in a second file.\n"
#define szCompUsage16  "   -$ will turn OFF underscore renaming.  Specific destArg will override.\n"
#define szCompUsage17  "\n   srcArg can be a filename, a wildcard pattern, or a directory.  The\n"
#define szCompUsage18  "   latter will cause a tree walk operation.  destArg can be a directory,\n"
#define szCompUsage19  "   a specific filebase, or omitted in which case digits are appended.\n"
#define szCompUsage20  "   -x excludes OS/2 EAs from the header of the compressed file.\n"

/* USAGE MESSAGE FOR DECOMPRESSION */
#ifdef COMPLEX
#define szDecompUsage1  "Usage: decomp [-afq] [srcArg [destArg]]\n"
#else  /* !COMPLEX */
#define szDecompUsage1  "Usage: decomp [-a] srcArg destArg\n"
#endif /* !COMPLEX */

#define szDecompUsage2  "   -a will append to the destination file, if it exists.\n"
#define szDecompUsage3  "   -f will force overwriting if destination file exists.\n"
#define szDecompUsage4  "      (Files cannot be decompressed in place.)\n"
#define szDecompUsage5  "   -q will calculate size of uncompressed file (no output).\n\n"
#define szDecompUsage6  "   srcArg can be a specific file or a wildcard pattern.  Either can be\n"
#define szDecompUsage7  "   preceeded by a path.  destArg can be a specific file, a directory,\n"
#define szDecompUsage8  "   or omitted.  In the last two cases, decomp will try to create a\n"
#define szDecompUsage9  "   destination filename using information in the src file header\n"
#define szDecompUsage10  "   or the src filename itself if the header is missing information.\n"
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\tools\comptool.c ===
/* TS = none */
/*
**  COMPTOOL.C  --  Compression Tool for Setup Toolkits.
*/


#include <stdio.h>
#include <stdlib.h>
#ifdef EAS
#include <malloc.h>
#endif /* EAS */
#include <io.h>
#include <string.h>
#include <fcntl.h>
#include <direct.h>
#include <ctype.h>
#include <sys\types.h>
#include <sys\stat.h>
#ifndef OS2_VER
#include <dos.h>
#endif /* !OS2_VER */
#include "..\sutkcomp.h"
#include "strings.h"


  /* forward declarations */
int           main(int argc, char ** argv);
void          MakeDirs(SZ rgchDestArg);
void          CopyAndFixSzDir(SZ rgchArg, SZ szArg);
BOOL          FWildcardPath(SZ rgchSrcArg);
BOOL          FDirectory(SZ rgchSrcArg);
void          RecurseOnDir(SZ rgchSrcDir, SZ rgchDestDir);
void          HandleDirFiles(SZ rgchSrcArg, SZ rgchDestDir);
void          HandleOneFile(SZ rgchSrcFile, SZ rgchDestArg);
void          Usage(SHORT wExitCode);
BOOL          FEnsureSzBaseDoesNotExist(SZ szBaseFile);
BOOL          FIncrementSzBase(SZ szBaseFile);
#ifdef EAS
#ifdef OS2_VER
BOOL QueryEAs(CHAR * pszPath, CHAR ** pEABuf);
#endif /* !OS2_VER */
#endif /* EAS */

extern  void  ExitErrorMsgRc(SHORT rc);
extern  BOOL  FUserConfirmsYN(void);
extern  void  DividePathIntoBaseExt(SZ szPath, SZ *pszBase, SZ *pszExt);
extern  void  MSCopyright(BOOL fCompress);
extern  void  GetDollarSzFromSzSrc(SZ szSrcFile, SZ szDstFile);

extern  BOOL  vfForceOverwrite;

BOOL          fDollarSuffix = (BOOL)TRUE;

#ifdef JJJ1
#define  wAlgTypeDefault  3
#else

#ifdef ZK1
#define  wAlgTypeDefault  2
#else

#ifdef NC_XOR1
#define  wAlgTypeDefault  1
#else

Force_a_compile_error__need_to_define_at_least_one_alg_type

#endif /* NC_XOR1 */
#endif /* ZK1 */
#endif /* JJJ1 */

struct  _SDL
    {
    SZ             szSubdir;
    struct _SDL *  psdlNext;
    };
typedef  struct _SDL  SDL;


  /* have our own globals because WReadHeaderInfo resets its globals */
USHORT  wAlgType = wAlgTypeDefault;
BOOL	fIncludeSrcLength = TRUE;
BOOL    fIncludeChecksum = FALSE;
BOOL    fIncludeBase = FALSE;
BOOL    fIncludeExt = FALSE;
#ifdef EAS
BOOL    fIncludeEAs = TRUE;
#endif /* EAS */

USHORT  cbText = 0;
SZ      szText = NULL;

BOOL    fComputeOnly = FALSE;
BOOL    fOnePieceOnly = FALSE;
LONG    lcbSize = NIL;

int     cFiles = 0;
LONG    lcbSrcTotal = 0L;
LONG    lcbDestTotal = 0L;


/*
**  int  main(int argc, char * argv[])
**
**  Main compress routine.
*/
int main(int argc, char * argv[])
{
    int     iArg;
    CHAR    rgchSrcArg[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];
    CHAR    rgchDestArg[_MAX_PATH + _MAX_FNAME + _MAX_EXT + 1];

    MSCopyright((BOOL)TRUE);

    vfForceOverwrite = FALSE;

    if (argc < 2)
        Usage(19);

      /* Parse command line arguments */
    for (iArg = 1; iArg < argc
            && (argv[iArg][0] == '-' || argv[iArg][0] == '/'); iArg++)
        {
        switch (argv[iArg][1])
            {
        default:
            Usage(20);

        case 'a':
        case 'A':
            wAlgType = atoi(&(argv[iArg][2]));
            break;

        case 'b':
        case 'B':
            fIncludeBase = (BOOL)TRUE;
            break;

        case 'c':
        case 'C':
            /* REVIEW */
#if 1
            printf(szNoChecksum);
#else
            fIncludeChecksum = (BOOL)TRUE;
#endif
            break;

        case 'e':
        case 'E':
            fIncludeExt = (BOOL)TRUE;
            break;

        case 'f':
        case 'F':
            vfForceOverwrite = (BOOL)TRUE;
            break;

        case '?':
        case 'h':
        case 'H':
            Usage(0);

        case 'l':
        case 'L':
	    fIncludeSrcLength = (BOOL)FALSE;
            break;

        case 'q':
        case 'Q':
            fComputeOnly = (BOOL)TRUE;
            break;

        case 's':
        case 'S':
            lcbSize = atol(argv[iArg] + 2);
            lcbSize *= (ULONG)512;       /* user enters 512 bytes */
            break;

        case 't':
        case 'T':
            cbText = strlen(argv[iArg]) - 2;                     /* skip flag */
            szText = argv[iArg] + 2;
            break;

#ifdef EAS
        case 'x':
        case 'X':
            fIncludeEAs = FALSE;
            break;
#endif /* EAS */

        case 'z':
        case 'Z':
            fOnePieceOnly = (BOOL)TRUE;
            lcbSize = atol(argv[iArg] + 2);
            lcbSize *= (ULONG)512;       /* user enters 512 bytes */
            break;

        case '$':
            fDollarSuffix = FALSE;
            break;
            }
        }

    if (lcbSize != NIL && fComputeOnly)
        printf(szNoQWithS);

      /* there needs to be at least one and at most two filenames after flags */
    if (iArg != argc - 1 && iArg != argc - 2)
        Usage(19);

    CopyAndFixSzDir(rgchSrcArg, argv[iArg++]);

    if (iArg < argc)
        CopyAndFixSzDir(rgchDestArg, argv[iArg]);
    else
        rgchDestArg[0] = '\0';

      /* info is passed as global vars */
    if (FWildcardPath(rgchSrcArg))
        {
        if (!fComputeOnly)
            MakeDirs(rgchDestArg);
        if (fComputeOnly || FDirectory(rgchDestArg))
            HandleDirFiles(rgchSrcArg, rgchDestArg);
        else
            printf(szDestDirWild);
        }
    else if (FDirectory(rgchSrcArg))
        {
        if (!fComputeOnly)
            MakeDirs(rgchDestArg);
        if (fComputeOnly || FDirectory(rgchDestArg))
            RecurseOnDir(rgchSrcArg, rgchDestArg);
        else
            printf(szDestDirTree);
        }
    else
        HandleOneFile(rgchSrcArg, rgchDestArg);

    if (cFiles > 1)
        {
        printf(szTotals);
        printf(szBytesCompressed, lcbSrcTotal, lcbDestTotal);
        printf(szPercentSavings, 
                ((200 * (lcbSrcTotal - lcbDestTotal) / lcbSrcTotal) + 1 ) / 2);
        }

    exit(0);
    return(0);
}


void  MakeDirs(SZ rgchDestArg)
{
    int  ichMac = strlen(rgchDestArg) - 1;
    SZ   pchSlash;

    if (ichMac >= 0 && rgchDestArg[ichMac] != '\\'
            && rgchDestArg[ichMac] != ':')
        strcat(rgchDestArg, "\\");

    pchSlash = strchr(rgchDestArg + 1, '\\');
    while (pchSlash != NULL)
        {
        *pchSlash = '\0';

        if (!fComputeOnly)
            mkdir(rgchDestArg);

        *pchSlash = '\\';
        pchSlash = strchr(pchSlash + 1, '\\');
        }
}


void  CopyAndFixSzDir(SZ rgchArg, SZ szArg)
{
    if (szArg == NULL || *szArg == '\0')
        rgchArg[0] = '\0';
    else
        {
        int   ichMac = strlen(szArg) - 1;

        strcpy(rgchArg, szArg);
        if (FDirectory(rgchArg) && rgchArg[ichMac] != '\\'
                && rgchArg[ichMac] != ':')
            strcat(rgchArg, "\\");
        }
}


BOOL  FWildcardPath(SZ rgchSrcArg)
{
    if (strcspn(rgchSrcArg, "?*") != strlen(rgchSrcArg))
        return((BOOL)TRUE);
    return(FALSE);
}


BOOL  FDirectory(SZ rgchSrcArg)
{
    int     ichMac;
    struct  stat  statBuf;

    if (rgchSrcArg == NULL || *rgchSrcArg == '\0')
        return((BOOL)TRUE);

    ichMac = strlen(rgchSrcArg) - 1;
    if (*(rgchSrcArg + ichMac) == '\\' || *(rgchSrcArg + ichMac) == ':')
        return((BOOL)TRUE);
    if (!stat(rgchSrcArg, &statBuf) && (statBuf.st_mode & S_IFDIR))
        return((BOOL)TRUE);
    return(FALSE);
}


#ifdef OS2_VER
#define  ZZNAMEZZ  achName
#else  /* !OS2_VER */
#define  ZZNAMEZZ  name
#endif /* !OS2_VER */


void  RecurseOnDir(SZ rgchSrcDir, SZ rgchDestDir)
{
    int     cchSrcSav = strlen(rgchSrcDir);
    int     cchDestSav = strlen(rgchDestDir);
    BOOL    fDirFound;
    SDL *   psdlHead = NULL;
#ifdef OS2_VER
    HDIR    hdir;
    USHORT  usSearchCount;
    FILEFINDBUF     ffindBuf;
#else  /* !OS2_VER */
    struct  find_t  ffindBuf;
#endif /* !OS2_VER */

    strcat(rgchSrcDir, "*.*");
#ifdef OS2_VER
    hdir = HDIR_CREATE;
    usSearchCount = 1;
    fDirFound = (BOOL)(!DosFindFirst(rgchSrcDir, &hdir,
            FILE_NORMAL | FILE_DIRECTORY, &ffindBuf, sizeof(FILEFINDBUF),
            &usSearchCount, 0L));
#else  /* !OS2_VER */
    fDirFound = (BOOL)(!_dos_findfirst(rgchSrcDir, _A_SUBDIR, &ffindBuf));
#endif /* !OS2_VER */

    while (fDirFound)
        {
        if (strcmp(ffindBuf.ZZNAMEZZ, ".") && strcmp(ffindBuf.ZZNAMEZZ, ".."))
            {
#ifdef OS2_VER
            if (ffindBuf.attrFile & FILE_DIRECTORY)
#else  /* !OS2_VER */
            struct  stat  statBuf;

            strcpy(rgchSrcDir + cchSrcSav, ffindBuf.ZZNAMEZZ);
            if (!stat(rgchSrcDir, &statBuf) && (statBuf.st_mode & S_IFDIR))
#endif /* !OS2_VER */
                {
                SDL *  psdl = (SDL *)malloc(sizeof(SDL));

                psdl->szSubdir = strdup(ffindBuf.ZZNAMEZZ);
                psdl->psdlNext = psdlHead;
                psdlHead = psdl;
                }
            }

#ifdef OS2_VER
        usSearchCount = 1;
        fDirFound = (BOOL)(!DosFindNext(hdir, &ffindBuf, sizeof(FILEFINDBUF),
                &usSearchCount));
#else  /* !OS2_VER */
        fDirFound = (BOOL)(!_dos_findnext(&ffindBuf));
#endif /* !OS2_VER */
        }
#ifdef OS2_VER
    DosFindClose(hdir);
#endif /* OS2_VER */

    strcpy(rgchSrcDir + cchSrcSav, "*.*");
    rgchDestDir[cchDestSav] = '\0';
    HandleDirFiles(rgchSrcDir, rgchDestDir);

    while (psdlHead != NULL)
        {
        SDL *  psdlSav = psdlHead;

        strcat(strcpy(rgchSrcDir + cchSrcSav, psdlHead->szSubdir), "\\");

        strcpy(rgchDestDir + cchDestSav, psdlHead->szSubdir);
        if (!fComputeOnly)
            mkdir(rgchDestDir);
        strcat(rgchDestDir, "\\");

        RecurseOnDir(rgchSrcDir, rgchDestDir);

        psdlHead = psdlHead->psdlNext;
        free(psdlSav->szSubdir);
        free(psdlSav);
        }
}


void  HandleDirFiles(SZ rgchSrcArg, SZ rgchDestDir)
{
    int     cchSrcSav = strlen(rgchSrcArg);
    int     cchDestSav = strlen(rgchDestDir);
    BOOL    fFileFound;
#ifdef OS2_VER
    HDIR    hdir;
    USHORT  usSearchCount;
    FILEFINDBUF     ffindBuf;
#else  /* !OS2_VER */
    struct  find_t  ffindBuf;
#endif /* !OS2_VER */

      /* only count chars in SrcPath (includes backslash) */
    while (cchSrcSav && *(rgchSrcArg + cchSrcSav - 1) != '\\'
            && *(rgchSrcArg + cchSrcSav - 1) != ':')
        cchSrcSav--;

#ifdef OS2_VER
    hdir = HDIR_CREATE;
    usSearchCount = 1;
    fFileFound = (BOOL)(!DosFindFirst(rgchSrcArg, &hdir,
            FILE_NORMAL | FILE_READONLY, &ffindBuf, sizeof(FILEFINDBUF),
            &usSearchCount, 0L));
#else  /* !OS2_VER */
    fFileFound = (BOOL)(!_dos_findfirst(rgchSrcArg, _A_NORMAL | _A_RDONLY,
            &ffindBuf));
#endif /* !OS2_VER */

    while (fFileFound)
        {
        strcpy(rgchSrcArg + cchSrcSav, ffindBuf.ZZNAMEZZ);
        rgchDestDir[cchDestSav] = '\0';

        HandleOneFile(rgchSrcArg, rgchDestDir);

#ifdef OS2_VER
        usSearchCount = 1;
        fFileFound = (BOOL)(!DosFindNext(hdir, &ffindBuf, sizeof(FILEFINDBUF),
                &usSearchCount));
#else  /* !OS2_VER */
        fFileFound = (BOOL)(!_dos_findnext(&ffindBuf));
#endif /* !OS2_VER */
        }
#ifdef OS2_VER
    DosFindClose(hdir);
#endif /* OS2_VER */
}


void  HandleOneFile(SZ rgchSrcFile, SZ rgchDestArg)
{
    SZ      szSrcBase;
    SZ      szSrcExt;
    int     fhSrc;
    int     fhDest;
    LONG    lcbSrc;
    LONG    lcbDest;
    LONG    lcbCompressed = 0L;
    BOOL    fDotRemoved = FALSE;
#ifdef OS2_VER
    FILESTATUS  fsSrc;
#else  /* !OS2_VER */
    USHORT  usDate;
    USHORT  usTime;
#endif /* !OS2_VER */

    printf("%s\n", rgchSrcFile);

    if (FDirectory(rgchDestArg))
        {
        CHAR *  szSrcFileName = strrchr(rgchSrcFile, '\\');

        if (szSrcFileName == NULL)
            szSrcFileName = strrchr(rgchSrcFile, ':');

        if (szSrcFileName == NULL)
            szSrcFileName = rgchSrcFile;
        else
            szSrcFileName++;

        if (fDollarSuffix)
            GetDollarSzFromSzSrc(szSrcFileName,
                    rgchDestArg + strlen(rgchDestArg));
        else
            strcat(rgchDestArg, szSrcFileName);

        if (!stricmp(rgchDestArg, rgchSrcFile))
            FIncrementSzBase(rgchDestArg);
        }

    if ((fhSrc = open(rgchSrcFile, O_RDONLY | O_BINARY)) == -1)
        {
        printf(szCantOpenInput, rgchSrcFile);
        exit(21);
        }

    if (WReadHeaderInfo(fhSrc) >= wAlgTypeNoCompress)
        {
        FFreeHeaderInfo();

        if (!vfForceOverwrite)
            printf(szAlreadyCompressed, rgchSrcFile);

        if (vfForceOverwrite || FUserConfirmsYN())
            lseek(fhSrc, 0L, SEEK_SET);
        else
            {
            close(fhSrc);
            exit(22);
            }
        }

    DividePathIntoBaseExt(rgchSrcFile, &szSrcBase, &szSrcExt);
    if (szSrcExt != NULL)
        {
        *(szSrcExt - 1) = '\0';        /* remove the '.' between base and ext */
        fDotRemoved = TRUE;
        }
    else
        szSrcExt = "";

    lcbSrc = filelength(fhSrc);
    if (lcbSrc == -1L)
        ExitErrorMsgRc(rcReadSeekError);

      /* set global variables */
    if (strlen(szSrcBase) > _MAX_FNAME - 1 || strlen(szSrcExt) > _MAX_EXT - 1)
        {
        printf(szFilenameTooLongSz, szSrcBase, szSrcExt);
        exit(4);
        }

    if (fIncludeSrcLength)
        vlcbSrcLength = 0L;

    if (fIncludeChecksum)
        vfChecksum = (BOOL)TRUE;

    if (fIncludeBase)
        strcpy(vszBaseName, szSrcBase);

    if (fIncludeExt)
        {
        if (*szSrcExt == '\0')    /* use a space to indicate a null extension */
            strcpy(vszExtension, " ");
        else
            strcpy(vszExtension, szSrcExt);
        }

#ifdef EAS
#ifdef OS2_VER
    if (fIncludeEAs)
        {
        vuscbEAs = 0;

        if (fDotRemoved)
            *(szSrcExt - 1) = '.';

        if (!QueryEAs(rgchSrcFile, &vrgbEAs))
            printf("Unable to read in file's EAs.\n");

        if (fDotRemoved)
            *(szSrcExt - 1) = '\0';

        if (vrgbEAs)
            vuscbEAs = (USHORT)(*((LONG far *)vrgbEAs));
        }
#endif /* !OS2_VER */
#endif /* EAS */

    if (fDotRemoved)
        *(--szSrcExt) = '.';              /* replace what we took out earlier */

    if (cbText > 0)
        {
        vcbText = cbText;
        vszText = szText;
        }

    if (fComputeOnly)
        {
        lcbCompressed = LcbCalculateCompressedLength(wAlgType, fhSrc, NIL);
        close(fhSrc);
        if (lcbCompressed < rcNoError)
            ExitErrorMsgRc((SHORT)lcbCompressed);
        else
            {
            printf(szBytesCompressed, lcbSrc, lcbCompressed);
            ++cFiles;
            lcbSrcTotal += lcbSrc;
            lcbDestTotal += lcbCompressed;
            if (lcbCompressed < lcbSrc)
                printf(szPercentSavings, 
                          ((200 * (lcbSrc - lcbCompressed) / lcbSrc) + 1 ) / 2);
            else
                printf(szNoSavings);
            return;
            }
        }

#ifdef OS2_VER
    if (DosQFileInfo((HFILE)fhSrc, (USHORT)0x0001, &fsSrc,
                                                       (USHORT)(sizeof(fsSrc))))
#else /* not OS2_VER */
    if (_dos_getftime(fhSrc, &usDate, &usTime))
#endif /* OS2_VER */
        ExitErrorMsgRc(rcReadError);

    /* LOOP TO DO COMPRESSION */
    do     /* while (!eof(fhSrc)) */
        {
        if (!FEnsureSzBaseDoesNotExist(rgchDestArg))
            {
            close(fhSrc);
            exit(24);
            }

        if ((fhDest = open(rgchDestArg, O_RDWR | O_CREAT | O_BINARY | O_TRUNC,
                                                     S_IREAD | S_IWRITE)) == -1)
            {
            close(fhSrc);
            printf(szCantOpenOutput, rgchDestArg);
            exit(23);
            }

        lcbDest = LcbCompressToFile(wAlgType, fhSrc, fhDest, lcbSize);

#ifdef OS2_VER
        if (DosSetFileInfo((HFILE)fhDest, (USHORT)0x0001, &fsSrc,
                                                       (USHORT)(sizeof(fsSrc))))
#else /* not OS2_VER */
        if (_dos_setftime(fhDest, usDate, usTime))
#endif /* OS2_VER */
            ExitErrorMsgRc(rcWriteError);

        close(fhDest);

        if (lcbDest < rcNoError)
            {
            close(fhSrc);
            remove(rgchDestArg);
            ExitErrorMsgRc((SHORT)lcbDest);
            }

        printf(szWroteBytes, lcbDest, rgchDestArg);
        lcbCompressed += lcbDest;

        if (!eof(fhSrc))
            {
            if (!FIncrementSzBase(rgchDestArg))
                {
                close(fhSrc);
                exit(25);
                }
            }

        }  while (!eof(fhSrc) && !fOnePieceOnly);


    if (!eof(fhSrc))
        {
        LONG    lcbTail = lcbSrc - tell(fhSrc);
        BYTE    rgbBuffer[128];
        SHORT   cbSize;

        lcbSrc -= lcbTail;               /* uncompressed bytes of first piece */

        printf(szBytesCompressed, lcbSrc, lcbCompressed);
        ++cFiles;
        lcbSrcTotal += lcbSrc;
        lcbDestTotal += lcbCompressed;
        if (lcbCompressed >= lcbSrc)
            printf(szNoSavings);
        else
            printf(szPercentSavings,
                          ((200 * (lcbSrc - lcbCompressed) / lcbSrc) + 1 ) / 2);

        if (!FEnsureSzBaseDoesNotExist(rgchDestArg))
            {
            close(fhSrc);
            exit(24);
            }

        printf(szTailBytes, lcbTail, rgchDestArg);

        if ((fhDest = open(rgchDestArg, O_RDWR | O_CREAT | O_BINARY | O_TRUNC,
                                                     S_IREAD | S_IWRITE)) == -1)
            {
            close(fhSrc);
            printf(szCantOpenOutput, rgchDestArg);
            exit(23);
            }

        if ((cbSize = read(fhSrc, rgbBuffer, 128)) <= 0)
            {
            close(fhSrc);
            ExitErrorMsgRc(rcReadError);
            }

        while (cbSize > 0)
            {
            if (write(fhDest, rgbBuffer, cbSize) != cbSize)
                {
                close(fhSrc);
                close(fhDest);
                ExitErrorMsgRc(rcWriteError);
                }
            cbSize = read(fhSrc, rgbBuffer, 128);
            }

#ifdef OS2_VER
        if (DosSetFileInfo((HFILE)fhDest, (USHORT)0x0001, &fsSrc,
                                                       (USHORT)(sizeof(fsSrc))))
#else /* not OS2_VER */
        if (_dos_setftime(fhDest, usDate, usTime))
#endif /* OS2_VER */
            ExitErrorMsgRc(rcWriteError);

        close(fhDest);
        }
    else
        {
        printf(szBytesCompressed, lcbSrc, lcbCompressed);
        ++cFiles;
        lcbSrcTotal += lcbSrc;
        lcbDestTotal += lcbCompressed;
        if (lcbCompressed >= lcbSrc)
            printf(szNoSavings);
        else
            printf(szPercentSavings,
                          ((200 * (lcbSrc - lcbCompressed) / lcbSrc) + 1 ) / 2);
        }

    close(fhSrc);
}


/*
**  void  Usage(void)
**
**  Print usage message when command line args are bad.
*/
void Usage(SHORT wExitCode)
{
    printf(szCompUsage1);
    printf(szCompUsage2, wAlgTypeDefault);
#ifdef NC_XOR1
    printf(szCompUsage3, wAlgTypeNoCompress);
    printf(szCompUsage4, wAlgTypeXOR1);
#endif
#ifdef ZK1
    printf(szCompUsage5, wAlgTypeZK1);
#endif
#ifdef JJJ1
    printf(szCompUsageJJJ1, wAlgTypeJJJ1);
#endif
    printf(szCompUsage6);
    printf(szCompUsage7);
    printf(szCompUsage8);
    printf(szCompUsage9);
    printf(szCompUsage10);
    printf(szCompUsage11);
    printf(szCompUsage12);
    printf(szCompUsage13);
    printf(szCompUsage14);
    printf(szCompUsage15);
    printf(szCompUsage16);
    printf(szCompUsage17);
    printf(szCompUsage18);
    printf(szCompUsage19);
#ifdef EAS
    printf(szCompUsage20);
#endif /* EAS */

    exit(wExitCode);
}


/*
**  BOOL  FEnsureSzBaseDoesNotExist(SZ szBaseFile)
*/
BOOL FEnsureSzBaseDoesNotExist(SZ szBaseFile)
{
    if (access(szBaseFile, 00))
        return((BOOL)TRUE);

    if (!vfForceOverwrite)
        {
        printf(szFileExists, szBaseFile);
        printf(szOverwriteYN);
        }

    if (vfForceOverwrite || FUserConfirmsYN())
        {
        chmod(szBaseFile, S_IWRITE | S_IREAD);
        remove(szBaseFile);
        if (access(szBaseFile, 00))
            return((BOOL)TRUE);
        printf(szCantOverwrite, szBaseFile);
        if (!FIncrementSzBase(szBaseFile))
            return(FALSE);
        }
    else
        if (!FIncrementSzBase(szBaseFile))
            return(FALSE);

    return(FEnsureSzBaseDoesNotExist(szBaseFile));
}


/*
**  BOOL  FIncrementSzBase(SZ szBaseFile)
**
**  If the last character of szBaseFile (not counting the extension) is
**  a digit, then we can increment the filename.  Otherwise, change it to
**  a two.
*/
BOOL FIncrementSzBase(SZ szBaseFile)
{
    char *pchBase;
    char *pchExt;
    char *pchDigit;
    char  szNewName[13];

    DividePathIntoBaseExt(szBaseFile, &pchBase, &pchExt);
    if (pchExt != NULL)
        *(--pchExt) = '\0';             /* erase the '.' between base and ext */

    if (strlen(pchBase) >= 8)
        pchDigit = pchBase + 7;
    else
        pchDigit = pchBase + strlen(pchBase) - 1;

    if (!isdigit(*pchDigit))
        {
        if (strlen(pchBase) >= 8)
            {
            *pchDigit = '2';
            if (pchExt != NULL)
                *pchExt = '.';
            }
        else
            {
            strcpy(szNewName, pchBase);
            if (pchExt != NULL)
                {
                strcat(szNewName, "2.");
                strcat(szNewName, pchExt + 1);
                }
            else
                strcat(szNewName, "2");
            strcpy(pchBase, szNewName);
            }
        return((BOOL)TRUE);
        }

    if (*pchDigit == '9')
        {
        printf(szNoOutputNames);
        return(FALSE);
        }

    (*pchDigit)++;
    if (pchExt != NULL)
        *pchExt = '.';

    return((BOOL)TRUE);
}


#ifdef EAS
#ifdef OS2_VER

#define MAX_GEA         300 /* Max size for a GEA List              */
#define Ref_ASCIIZ      1   /* Reference type for DosEnumAttribute  */
#define GetInfoLevel1   1   /* Get info from SFT */
#define GetInfoLevel3   3   /* Get FEAlist given the GEAlist */

BOOL QueryEAs(CHAR * pszPath, CHAR ** pEABuf)
{
    struct FSPlus
        {
        FILESTATUS fs;
        long       easize;
        } fsp;
    USHORT usRet;
    ULONG  ulCurFEA, dAlloc;

    CHAR * pAlloc, * pAlloc2;
    CHAR * pRetBuf;

    ULONG  ulEntryNum = 1; /* count of current EA to read (1-relative)        */
    ULONG  ulEnumCnt;      /* Number of EAs for Enum to return, always 1      */

    FEA *  pFEA;           /* Used to read from Enum's return buffer          */
    GEALIST * pGEAList;    /* Ptr used to set up buffer for DosQPathInfo call */
    EAOP   eaopGet;        /* Used to call DosQPathInfo                       */

    *pEABuf = NULL;

    usRet = DosQPathInfo(pszPath, FIL_QUERYEASIZE, (char *)&fsp, sizeof(fsp),
                        0L);
    if (usRet)
        {
        printf("Can't even query the EAs size. Error: %u\n",usRet);
        printf("File name: '%s'\n",pszPath);
        return FALSE;
        }

    if (fsp.easize == 4L)
        return TRUE;

    pRetBuf = malloc((USHORT)fsp.easize);
    if (!pRetBuf)
        {
        printf("Couldn't allocated %ld bytes on the far heap...\n",fsp.easize);
        return FALSE;
        }
    *pEABuf = pRetBuf;

    ulCurFEA = fsp.easize - 4;

    pAlloc  = malloc(MAX_GEA);
    pAlloc2 = malloc(MAX_GEA);
    if (!pAlloc || !pAlloc2)
        {
        free(pRetBuf);
        pRetBuf = NULL;
        printf("Couldn't allocated the 500 bytes of local memory needed...\n");
        return FALSE;
        }

    pFEA = (FEA *)pAlloc;
    while (TRUE)
        {
        ulEnumCnt = 1;
        if (DosEnumAttribute(Ref_ASCIIZ, pszPath, ulEntryNum, pAlloc, MAX_GEA,
                          &ulEnumCnt, (LONG)GetInfoLevel1, 0L))
            break;

        if (ulEnumCnt != 1)
            break;

        ulEntryNum++;

        dAlloc = (ULONG)(pFEA->cbName + 1 + pFEA->cbValue + sizeof(FEA));
        ulCurFEA -= dAlloc;

        pGEAList = (GEALIST *)pAlloc2;

        pGEAList->cbList = sizeof(GEALIST) + pFEA->cbName;
        pGEAList->list[0].cbName = pFEA->cbName;
        strcpy(pGEAList->list[0].szName, pAlloc + sizeof(FEA));

        eaopGet.fpGEAList = (GEALIST far *)pAlloc2;
        eaopGet.fpFEAList = (FEALIST far *)&pRetBuf[ulCurFEA];

        eaopGet.fpFEAList->cbList = dAlloc + sizeof(ULONG);

        usRet = DosQPathInfo(pszPath, GetInfoLevel3, (PVOID)&eaopGet,
                    sizeof(EAOP), 0L);
        if (usRet)
            {
            printf("Error on reading EA from disk\n");
            free(pAlloc);
            free(pAlloc2);
            return FALSE;
            }
        }
    free(pAlloc);
    free(pAlloc2);

    if (ulCurFEA != 0)
        {
        printf("Checksum problems...\n");
        return FALSE;
        }
    eaopGet.fpFEAList->cbList = fsp.easize;

    return(TRUE);
}
#endif /* !OS2_VER */
#endif /* EAS */
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\appcomp\zk1\zk1deco.c ===
/* TS = none */
/*
**  ZK1DECO.C  --  Zeck Decompression module - first implementation
**
**  This comes to us from Languages via Excel and is used many places.
**  Still, I altered some of the code to fit my API.  Original sources
**  can be found in \\odin\slm!src\setup\compress.
*/

/*                    Zeck Data Compression Program
**                      (C) Copyright 1989 by Microsoft
**                           Written By Steven Zeck
**
**  This program will compress files using the Zeck compress algorithm.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#include <io.h>
#include <fcntl.h>

#include "..\sutkcomp.h"

#ifdef OS2SU
#include <doscalls.h>
#endif

#include "zk1.h"

#include "setjmp.h"

extern BOOL vfUserCancel;
extern PFNWFROMW vpfnYield;

extern BOOL    fJmpEnvSet;
extern jmp_buf jmpEnv;

  /* forward declarations */
BOOL  UnpackZK1(void);


/*
**  LONG  Lcb_ZK1_DecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
**                                                                LONG libStart)
*/
LONG Lcb_ZK1_DecompressToFile(int fhSrc, int fhDest, LONG lcbDestMax,
                                                                  LONG libStart)
{
    int iJmpReturn;

    if (lcbDestMax != NIL)
        return((LONG)rcGenericDecompError);

    if (!FAllocateLZGlobals((lcbDestMax == NIL) ? NIL : (libStart + lcbDestMax),
                                                                         FALSE))
        return((LONG)rcOutOfMemory);

    if ((iJmpReturn = setjmp(jmpEnv)) != 0)
        {
        FreeLZGlobals();
        fJmpEnvSet = FALSE;
        return((LONG)iJmpReturn);
        }
    fJmpEnvSet = TRUE;

      /* lcbDestStop == libStart + lcbDestMax */
    if (lcbDestMax != NIL && (LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestStop)
        fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestStop;

    fhDestGlobal = fhDest;
    fhSrcGlobal = fhSrc;
    lcbSkipOut = libStart;
    fpbBufDest = NULL;

    if (!UnpackZK1())
        {
        fJmpEnvSet = FALSE;
        FreeLZGlobals();
        return((LONG)rcGenericDecompError);
        }

    fJmpEnvSet = FALSE;
    FreeLZGlobals();

    if (fWriteError)
        return((LONG)rcWriteError);
    else
        return(lcbDest - libStart);
}


/*
**  LONG Lcb_ZK1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
**                                                               LONG libStart)
*/
LONG Lcb_ZK1_DecompressToBuffer(int fhSrc, BYTE far * fpbBuf, LONG lcbBuf,
                                                                 LONG libStart)
{
    int iJmpReturn;

    if (lcbBuf <= 0L)
        return((LONG)rcGenericDecompError);

    if (!FAllocateLZGlobals(libStart + lcbBuf, FALSE))
        return((LONG)rcOutOfMemory);

    if ((iJmpReturn = setjmp(jmpEnv)) != 0)
        {
        fpbBufDest = NULL;
        FreeLZGlobals();
        fJmpEnvSet = FALSE;
        return((LONG)iJmpReturn);
        }
    fJmpEnvSet = TRUE;

      /* lcbDestStop == libStart + lcbBuf */
    if ((LONG)(fpbOutBufEnd - fpbOutBuf) > lcbDestStop)
        fpbOutBufEnd = fpbOutBuf + (SHORT)lcbDestStop;

    lcbSkipOut = libStart;
    fpbBufDest = fpbBuf;
    fhDestGlobal = -1;
    fhSrcGlobal = fhSrc;

    if (!UnpackZK1())
        {
        fJmpEnvSet = FALSE;
        fpbBufDest = NULL;
        FreeLZGlobals();
        return((LONG)rcGenericDecompError);
        }

    fJmpEnvSet = FALSE;
    fpbBufDest = NULL;
    FreeLZGlobals();

    if (fWriteError)
        return((LONG)rcWriteError);
    else
        return(lcbDest - libStart);
}


/*
**  BOOL UnpackZK1(void)
**
*/
BOOL UnpackZK1(void)
{
    int     i, cb, oStart, ibBufCur;
    USHORT  b;
    USHORT  usFlags;
    LONG    lcbOut;
    USHORT  cCyclesUntilBreak = 1;

    _fmemset(ringBuf, ' ', cbBufMax - cbStrMax);
    ibBufCur = cbBufMax - cbStrMax;
    usFlags = 0;
    lcbOut = 0;

    while (TRUE)
        {
        if (--cCyclesUntilBreak == 0)
            {
            if (vpfnYield != NULL)
                {
                (*vpfnYield)(0);
                cCyclesUntilBreak = 300;
                }
            else
                cCyclesUntilBreak = 30000;

            if (vfUserCancel)
                {
                if (fJmpEnvSet)
                    longjmp(jmpEnv, rcGenericDecompError);
                else
                    return((BOOL)FALSE);
                }
            }

        b = ReadByte(fhSrcGlobal);
        if (b == EOF)
            break;

          /* high order byte counts the # bits used in the low order byte */
        if (((usFlags >>= 1) & 0x100) == 0)
            {
            usFlags = b | 0xff00; /* set bit mask describing the next 8 bytes */
            b = ReadByte(fhSrcGlobal);
            if (b == EOF)
                break;
            }

        if (usFlags & 1)
            {
              /* just store the literal character into the buffer */
            WriteByte((BYTE)b);
            if (fDestFull)
                return((BOOL)TRUE);
            lcbOut++;
            ringBuf[ibBufCur++] = (BYTE)b;
            ibBufCur &= cbBufMax - 1;
            }
        else
            {
              /* extract the buffer offset and count to unpack */
            cb = ReadByte(fhSrcGlobal);
            if (cb == EOF)
                break;

            oStart = (cb & 0xf0) << 4 | b;
            cb     = (cb & 0x0f) + cbIndex;

            for (i = 0; i <= cb; i++)
                {
                b = ringBuf[(oStart + i) & (cbBufMax - 1)];
                WriteByte((BYTE)b);
                if (fDestFull)
                    return((BOOL)TRUE);
                lcbOut++;
                ringBuf[ibBufCur++] = (BYTE)b;
                ibBufCur &= cbBufMax - 1;
                }
            }
        }
    
    if (!eof(fhSrcGlobal))
        return((BOOL)TRUE);  /* okay if splitting */

    WriteOutBuff((BYTE)'\0');
    return((BOOL)TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\bell.asm ===
;***
;* File:    bell.asm
;* Author:  Dave Sewell
;* Date:    7-20-88
;* Description:
;*	Sound the bell using a DOS call below 12 so this can be called from
;*	the critical error handler.
;***

%		.MODEL memmodel, language

                IF  @CodeSize
                    .CODE   CWORTHY_TEXT
                ELSE
                    .CODE
                ENDIF

Bell		    PROC
;* extern void Bell(void);

    	    	mov	    dl, 7
        		mov	    ah, 6
		        INT	    21H
        		ret

Bell	    	ENDP
                
        		END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\calldvr.asm ===
;***
;* $Workfile:   calldvr.asm  $
;* $Revision:   1.1  $
;*   $Author:   Dave Sewell  $
;*     $Date:   27 Jun 1989 14:55:26  $
;***

                TITLE   Call device driver routine
                PAGE    66, 132

COMMENT @
    calldvr.asm : Alan Butt : January 8, 1989 : Expansion Box Project

    This function calls a device driver

    Inputs:
        rhp     Far pointer to the request header
        header  Far pointer to the device driver header

    Outputs:    None
        The called driver may make changes to rhp
;   extern void call_driver(void far *rhp, struct device_header far *header);

@

device_header   STRUC                   ; Device header structure
    next_header dd  ?                   ; Link to next driver
    attribute   dw  ?                   ; Device driver attribute word
    strategy    dw  ?                   ; Offset to strategy entry point
    inter       dw  ?                   ; Offset to interrupt entry point
    name_num    db  8 DUP (?)           ; Device name or number of units
device_header   ENDS


%               .MODEL  memmodel, language

                .DATA

addr            dd      ?

                .CODE

call_driver     PROC    rhp:FAR PTR, header:FAR PTR device_header

                les     bx, header      ; Get address of strategy routine
                mov     bx, es:[bx].strategy
                mov     WORD PTR addr, bx
                mov     WORD PTR addr + 2, es

                les     bx, rhp         ; point to the rhp and
                call    addr            ; call the strategy routine

                les     bx, header      ; Get address of interrupt routine
                mov     bx, es:[bx].inter
                mov     WORD PTR addr, bx
                mov     WORD PTR addr + 2, es

                call    addr            ; Call the interrupt routine

                ret

call_driver     ENDP

                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\crctab.asm ===
;***
;* $Workfile:   crctab.asm  $
;* $Revision:   1.2  $
;*   $Author:   Dave Sewell  $
;*     $Date:   04 May 1990  9:12:00  $
;***

                TITLE   CRC table
                PAGE    66, 132

COMMENT @
    crctab.asm : Alan Butt : May 1, 1989 : Expansion Box Project

    This module contains the CRC table and related variables that are common
    to both the serial and parallel communications.
@

%               .MODEL  memmodel, language

                .DATA

                PUBLIC C crctab
                PUBLIC C crc_errors

                EVEN

crctab  DW 00000H, 01021H, 02042H, 03063H, 04084H, 050a5H, 060c6H, 070e7H
        DW 08108H, 09129H, 0a14aH, 0b16bH, 0c18cH, 0d1adH, 0e1ceH, 0f1efH
        DW 01231H, 00210H, 03273H, 02252H, 052b5H, 04294H, 072f7H, 062d6H
        DW 09339H, 08318H, 0b37bH, 0a35aH, 0d3bdH, 0c39cH, 0f3ffH, 0e3deH
        DW 02462H, 03443H, 00420H, 01401H, 064e6H, 074c7H, 044a4H, 05485H
        DW 0a56aH, 0b54bH, 08528H, 09509H, 0e5eeH, 0f5cfH, 0c5acH, 0d58dH
        DW 03653H, 02672H, 01611H, 00630H, 076d7H, 066f6H, 05695H, 046b4H
        DW 0b75bH, 0a77aH, 09719H, 08738H, 0f7dfH, 0e7feH, 0d79dH, 0c7bcH
        DW 048c4H, 058e5H, 06886H, 078a7H, 00840H, 01861H, 02802H, 03823H
        DW 0c9ccH, 0d9edH, 0e98eH, 0f9afH, 08948H, 09969H, 0a90aH, 0b92bH
        DW 05af5H, 04ad4H, 07ab7H, 06a96H, 01a71H, 00a50H, 03a33H, 02a12H
        DW 0dbfdH, 0cbdcH, 0fbbfH, 0eb9eH, 09b79H, 08b58H, 0bb3bH, 0ab1aH
        DW 06ca6H, 07c87H, 04ce4H, 05cc5H, 02c22H, 03c03H, 00c60H, 01c41H
        DW 0edaeH, 0fd8fH, 0cdecH, 0ddcdH, 0ad2aH, 0bd0bH, 08d68H, 09d49H
        DW 07e97H, 06eb6H, 05ed5H, 04ef4H, 03e13H, 02e32H, 01e51H, 00e70H
        DW 0ff9fH, 0efbeH, 0dfddH, 0cffcH, 0bf1bH, 0af3aH, 09f59H, 08f78H
        DW 09188H, 081a9H, 0b1caH, 0a1ebH, 0d10cH, 0c12dH, 0f14eH, 0e16fH
        DW 01080H, 000a1H, 030c2H, 020e3H, 05004H, 04025H, 07046H, 06067H
        DW 083b9H, 09398H, 0a3fbH, 0b3daH, 0c33dH, 0d31cH, 0e37fH, 0f35eH
        DW 002b1H, 01290H, 022f3H, 032d2H, 04235H, 05214H, 06277H, 07256H
        DW 0b5eaH, 0a5cbH, 095a8H, 08589H, 0f56eH, 0e54fH, 0d52cH, 0c50dH
        DW 034e2H, 024c3H, 014a0H, 00481H, 07466H, 06447H, 05424H, 04405H
        DW 0a7dbH, 0b7faH, 08799H, 097b8H, 0e75fH, 0f77eH, 0c71dH, 0d73cH
        DW 026d3H, 036f2H, 00691H, 016b0H, 06657H, 07676H, 04615H, 05634H
        DW 0d94cH, 0c96dH, 0f90eH, 0e92fH, 099c8H, 089e9H, 0b98aH, 0a9abH
        DW 05844H, 04865H, 07806H, 06827H, 018c0H, 008e1H, 03882H, 028a3H
        DW 0cb7dH, 0db5cH, 0eb3fH, 0fb1eH, 08bf9H, 09bd8H, 0abbbH, 0bb9aH
        DW 04a75H, 05a54H, 06a37H, 07a16H, 00af1H, 01ad0H, 02ab3H, 03a92H
        DW 0fd2eH, 0ed0fH, 0dd6cH, 0cd4dH, 0bdaaH, 0ad8bH, 09de8H, 08dc9H
        DW 07c26H, 06c07H, 05c64H, 04c45H, 03ca2H, 02c83H, 01ce0H, 00cc1H
        DW 0ef1fH, 0ff3eH, 0cf5dH, 0df7cH, 0af9bH, 0bfbaH, 08fd9H, 09ff8H
        DW 06e17H, 07e36H, 04e55H, 05e74H, 02e93H, 03eb2H, 00ed1H, 01ef0H

crc_errors      dw      0



                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\criterr.c ===
/***
* $Workfile:   criterr.c  $
* $Revision:   1.2  $
*   $Author:   Dave Sewell  $
*     $Date:   23 Aug 1990 12:38:46  $
***/

/*  criterr.c : Alan Butt : Febuary 24, 1989 : Expansion Box Project

    This module contains the C-code portion of the critical error handler.

*/

#include <bios.h>
#include <string.h>
#include <ctype.h>

#include "dc.h"

int pascal criterr(int ax, int err_code, struct device_header far *driver)
{
#define NUM_ERRS    16

    static char *errormsg[NUM_ERRS] = {
        write_protect_error,
        unknown_unit_error,
        drive_not_ready_error,
        unknown_command_error,
        data_error,
        bad_request_struct,
        seek_error,
        unknown_media_type,
        sector_not_found,
        printer_out_of_paper,
        write_fault,
        read_fault,
        general_failure,
        unknown_error,
        unknown_error,
        invalid_disk_change
    };

    /***
    * NOTE: Critical error handlers do not use the processes stack.  Instead
    * they use MS-DOS's AuxStack.  This stack is not very big so we need to
    * be careful to not overflow it.  Hence, the buffers below are static
    * rather than on the stack
    ***/

    static char save_buff[2 * 4 * 80];
    static char device_name[9];
    static char msg[70];

    int c;
    char *err, *operation;
    int msg_len;
    int box_start;
    byte save_row, save_column;

    err = err_code >= NUM_ERRS ? unknown_error : errormsg[err_code];

    if (ax & 0x8000) {                  // if char device or bad FAT
        if (driver->attribute & ATT_CHARACTER) {
            strtcpyf(device_name, driver->name_num, sizeof(device_name));
            operation = "";
        }
        else {
            err = bad_image_of_FAT;
            goto block_dev_err;
        }
    }
    else {
block_dev_err:
        operation = ax & 0x0100 ? writing_to_drive : reading_from_drive;
        device_name[0] = (char) ((ax & 0x00ff) + 'A');
        device_name[1] = '\0';
    }

    strcpy(msg, err);
    strcat(msg, operation);
    strcat(msg, " ");
    strcat(msg, device_name);

    push_attribute(LIST_REVERSE);
    save_row = cursor_row;
    save_column = cursor_column;

    msg_len = pstrlen(msg);
    if (msg_len < (int)pstrlen(abort_or_retry)) msg_len = pstrlen(abort_or_retry);
    box_start = ((80 - msg_len) >> 1);
    save_zone(coord(11, 0), boxsize(4, 80), save_buff);
    draw_box(coord(11, box_start),  boxsize(4, msg_len + 4),
             DOUBLE, LIST_REVERSE);
    justify_str(coord(12, box_start + 2), msg_len, LIST_REVERSE, msg, 0);
    justify_str(coord(13, box_start + 2), msg_len, LIST_REVERSE, abort_or_retry, 0);
    locate(coord(13, (box_start + 2 + (msg_len - pstrlen(abort_or_retry)) / 2 + pstrlen(abort_or_retry))) );
    cursor_on();

    for (;;) {
        c = paragon_bios_keybrd(_KEYBRD_READ) & 0xFF;
                                        // Can't call read_raw_key() because
                                        // read_raw_key calls the background
                                        // function which may call DOS (the
                                        // clock() routine does!).

        if (c == 'a' || c == 'A') {     // Abort case
            quit();                     // perform any cleanup routines
            restore_screen();           // and restore the screen
            return 2;
        }

        if ( toupper(c) == 'R' || toupper(c) == 'I') { // Retry or ignore case
            restore_zone(coord(11, 0), boxsize(4, 80), save_buff);
            cursor_off();
            locate(coord(save_row, save_column));
            pop_attribute();
            return toupper(c) == 'R' ? 1 : 0;
        }

        Bell();                         // Any other character typed
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\ctype.asm ===
;***
;* $Workfile:   calcreq.asm  $
;* $Revision:   1.0  $
;*   $Author:   Dave Sewell  $
;*     $Date:   13 Oct 1989 11:28:00  $
;*
;*****************************************************************************

%               .MODEL memmodel

                .CODE

;int _fastcall fc_toupper(int value);

@fc_toupper     PROC
                PUBLIC  @fc_toupper

                cmp     al, 'a'
                jb      upper_done

                cmp     ax, 'z'
                ja      upper_done

                sub     al, 'a' - 'A'

upper_done:     ret

@fc_toupper        ENDP


@isdigit        PROC
                PUBLIC  @isdigit

                cmp     al, '0'
                jb      false

                cmp     al, '9'
                ja      false

true:           mov     ax, 1
                ret

false:          xor     ax, ax
                ret

@isdigit        ENDP

            
                END
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\choice\choice.asm ===
;   Created by Ericst on 5/14/92.
;   Modified by Ericst on 8/25/92 to use 1 for first choice instead of 0
;   Modified by Ericst on 8/31/92 to change /T syntax from /Tnn,c to /Tc,nn
;       to be consistent with select-boot timeout syntax
;       Also fixed bug 1018 (timeout doesn't work with 12 seconds.
;
;   CHOICE [/c choices] [/N] [/S] [/T:c,nn] [text]
;	/c[:]choices	Specifies allowable response keys.  The
;			default is "yn".  Keys are not case sensitive
;			unless /S is specified.  If choices are specified
;			more than once, no error is generated and the last
;			set of choices are used.
;	/N		Causes CHOICE to Not display choices (and ?) at the end of
;			the string, enclosed in square brackets.
;	/S		Case sensitive.  Default is case insensitive.
;       /T[:]c,nn       Timeout after nn seconds and take choice c.
;			c must be in choices. If c is not
;			in choices an error message is displayed.
;	text		Specifies a string to be displayed.  If no text
;			is specified, only the choices are displayed (unless
;			/N is specified).  The string can be enclosed in
;			quotes ("), or may simply be terminated by end of
;			the line, or by a switch.
;
;    When one of the choices is entered, the index of the choice is
;    returned in ERRORLEVEL, where 1 means the first letter in choices
;    was pressed, 2 means the second, and so on.  CHOICE beeps if any
;    choice other than those in choices is specified. CHOICE returns 255
;    if a problem is encountered (bad arg, etc.), or if user
;    runs with /? switch.  No control-break handler is provided, so
;    user pressing control-c results in errorlevel 0.

.MODEL tiny
.code
org	100h
public	start
start:
	jmp begin
include  choice.inc
begin:
	cld				; force string ops to be forward.
; ************************************************************************
; ***	Verify MS-DOS version is 4.0 or later			       ***
; ************************************************************************
	mov	al,01h			; version number, not OEM flag
	mov	ah,30h			; Get Version Function
	int	21h
	cmp	al, 3			; This program requires 4.0 or later
	jg     GetTable

WrongVersion:
	 strout  BADVERMSG
	 mov	al, ERROREXIT
	 jmp	ChoiceDone

; ************************************************************************
; ***	Get Upper Case Table address/bias			       ***
; ************************************************************************
GetTable:
	push	es
	mov	ax,GETUPPERTABLE
        mov     bx,-1                   ; current code page
        mov     cx,5                    ; size of info for upper case table
        mov     dx,bx                   ; current country id
        push    cs

	mov	di,offset UCaseTbl ; point at buffer for table
        int     21h
                                        ; assume no error
        inc     di                      ; point at start of table
        les     di,[di]                 ; load table address
        mov     bx,es:[di]              ; load table size
        mov     ax,256                  ; compute table size bias
        sub     ax,bx
	mov	UCaseTblBias,ax 	; save it for later
	add	di,2			; Shift UcaseTbl Address so that
	mov	word ptr UCaseTbl,di	; it is at UCaseTbl (instead of
	mov	word ptr UCaseTbl+2,es	; UCaseTbl + 1; before shift, UCaseTbl
	pop	es			; points to table ID which is always 2).

;  ********************************************************************
;  ***	 Parse command line					    ***
;  ***	 Set Show=FALSE if /N,					    ***
;  ***	 Set Choices to choices from /C, if specified		    ***
;  ***	 Set CaseSense=True if /S				    ***
;  ***	 Set TimeOut=<secs>&TimeOutDefault=char to timeout too if   ***
;  ***	     /T is specified					    ***
;  ***	 Set PROMPT to user specified prompt, if specified.	    ***
;  ********************************************************************
	 mov	si,081h 	      ; Offset of command line in PSP
; While !(end of line) do
Parse1:
	 lodsb			      ; get first char
	 cmp	al, CR		      ; end of line?
	 je	ParseDone	      ; if so, Exit parse loop
	 cmp	al, SWITCHCHAR	      ; is it a switch?
	 je	IsSwitch
	 cmp	al, Blank	      ; if blank, ignore
	 je	Parse1
	 cmp	al, Tab 	      ; if tab, ignore
	 je	Parse1
					; Prompt: parse it off
	 mov	di, offset PROMPT	; di points to prompt
	 cmp	BYTE PTR [di], NUL	; Prompt already specified?
	 jne	MultPromptErr
					; Set dl depending on Quoted or not.
	 cmp	al, QUOTE		; Terminator for Quoted String: CR and
	 jne	NoQuote 		; QUOTE (set dl to QUOTE).
	 mov	dl, QUOTE
	 jmp	prompt1
NoQuote:
	 mov	dl, SWITCHCHAR		; Terminator for unquoted String:CR and
	 stosb				; SWITCHCHAR (set dl to SWITCHCHAR)
;  Repeat
Prompt1:
	 mov	al, [si]		; want SI to point to term if we exit
	 cmp	al, CR			; End of line? If so, leave si pointing
	 je	Parse1			;    at it. No need to increment.
	 cmp	al, dl			; If an end-quote we'll need to inc
	 je	Terminator		;
	 stosb				; save the char.
	 inc	si			; get next char
	 jmp	Prompt1
; Until (terminator char found)

Terminator:				; encountered end-quote or switch char
	 cmp	al, SWITCHCHAR		; if a switch leave si pointing to it.
	 je	Parse1			; If a quote, si should point to next
	 inc	si			;     character after the quote.
	 jmp	Parse1			; parse next field.

MultPromptErr:
	strout	 MULTPROMPTERRMSG
	strout	 SYNTAXMSG
	mov	al, ERROREXIT
	jmp	ChoiceDone

IsSwitch:			  ; Case Switch of:
	 lodsb			  ; get switch char
	 call ToUpper		  ; Case Switch of:
	 cmp	al,HELPSWITCH	  ; /?
	 je	IsHelpSwitch
	 cmp	al,CHOICESWITCH   ; /c choices
	 je	IsChoiceSwitch
	 cmp	al,DISPLAYSWITCH  ; /N
	 je	IsDisplaySwitch
         cmp    al,TIMEOUTSWITCH  ; /Tc,nn
	 je	IsTimeoutSwitch
	 cmp	al,CASESWITCH	  ; /S
	 je	IsCaseSwitch

	 strout BADSWITCHMSG	 ; invalid switch
	 strout SYNTAXMSG
	 mov	al, ERROREXIT
	 jmp	ChoiceDone	  ; End CASE switch.

IsHelpSwitch:			  ; /?
	 strout  HELPMSG0
	 strout  SYNTAXMSG
	 strout  HELPMSG1
	 mov	al, ERROREXIT
	 jmp	ChoiceDone

IsChoiceSwitch: 		  ; Set of choices, get them.
	 mov	di, offset choices
GetChoices:
	 mov	al, [si]
	 cmp	al, CHOICESDELIM     ; expect choicedelim or first choice
	 jne	ChoiceSw1
	 inc	si
	 mov	al, [si]

ChoiceSw1:
	 cmp	al, BLANK
	 je	ChoiceSwDone
	 cmp	al, TAB
	 je	ChoiceSwDone
	 cmp	al, CR
	 je	ChoiceSwDone
	 cmp	al, SWITCHCHAR
	 je	ChoiceSwDone
	 stosb			  ; save choice
	 inc	si		  ; loop until switch or delim found.
	 mov	al, [si]
	 jmp	ChoiceSw1	  ; get next choice.

ChoiceSwDone:			  ; Have all choices now.
	 mov	al, NUL 	  ; mark end in case of 1 char choice.
	 mov	[di],al
	 cmp	di, offset choices ; At least 1 choice specified?
	 jne	Parse1
	 strout  NEEDCHOICE	  ; No choices specified.
	 mov	al, ERROREXIT
	 jmp	ChoiceDone

IsDisplaySwitch:		  ; Display options Switch
	 mov	Show, FALSE
	 jmp	Parse1

IsTimeoutSwitch:		  ; Timeout Switch
         mov    al, [si]          ; in form /T[:]c,n[n]
	 cmp	al, TIMEDELIM
         jne    GetDefChar
         inc    si                ; skip over ':'
         mov    al, [si]

GetDefChar:
         cmp    al, CR                ; whitespace & Switch not allowed
         je     BadTimeOut
         cmp    al, SWITCHCHAR
         je     BadTimeOut
         cmp    al, Blank
         je     BadTimeOut
         cmp    al, Tab
         je     BadTimeOut
	 mov	TimeOutDefault, al   ; save default char
	 inc	si
	 mov	al, [si]
         cmp    al, TIMEDEFDELIM  ;   Delim for timeout?
         jne    BadTimeOut
         inc    si                ;   skip over delim
	 mov	al, [si]
	 cmp	al, '0' 	  ;   Ensure it's a digit
	 jb	BadTimeOut
	 cmp	al, '9'
         ja     BadTimeOut
	 and	ax, 0fh 	  ;   Conver to binary
	 mov	TimeOut, al	  ;   save (incase 1 digit)
	 inc	si		  ;   Check for another digit
         mov    al, [si]
         cmp    al, '0'
         jb     Parse1            ;   Not part of timeout switch
	 cmp	al, '9'
         ja     Parse1            ;   Not part of timeout switch
         mov    al,TimeOut
	 mov	dx, 10		  ;   num=1st dig *10 + 2nd dig
         mul    dl
         mov    bl, [si]
         and    bl, 0fh
         add    al, bl
         mov    TimeOut, al       ; save timeout
         inc    si
         jmp    Parse1

BadTimeOut:
	 strout  BADTIMEOUTMSG
	 mov	al, ERROREXIT
	 jmp	ChoiceDone

IsCaseSwitch:			   ; Case Sensitive Switch
	 mov	CaseSense,TRUE
	 jmp	Parse1

ParseDone:

;  ********************************************************************
;  ***	Done Parsing Command Line. Unless specified otherwise,	    ***
;  ***	convert choices and default to Upper Case		    ***
;  ********************************************************************
	cmp [CaseSense],TRUE	   ;  If CaseSense is set, skip upper casing
	je DoneUpCasing

	mov al, TimeOutDefault	; Convert Timeout Default to upper case
	call ToUpper
	mov TimeOutDefault, al
	mov si, offset Choices	 ; Now convert the choices to upcase
ChoiceUCase1:
	cmp BYTE PTR [si], NUL
	je  DoneUpCasing
	mov al, [si]
	call ToUpper
	mov [si], al
	inc si
	jmp ChoiceUCase1

DoneUpCasing:
;  ********************************************************************
;  *** if /t (timeout) was specified, verify specified default is   ***
;  *** in Choices						    ***
;  ********************************************************************
	mov di, offset Choices
	mov cx, MAXPROMPT	    ; search entire buffer (it is 0 filled)
	mov al, TimeOutDefault
	repnz scasb
	jz TimeOutValid
	strout	BADTIMEOUTCHARMSG   ; char not in choices.
	mov    al, ERROREXIT
	jmp    ChoiceDone

TimeOutValid:
;  ********************************************************************
;  ***	Display prompt, if any					    ***
;  ***	if /N (No Display Choices) was not specified, display	    ***
;  ***	choices with leading space if any prompt), enclosed in [],  ***
;  ***	separated by commas, followed by '?'			    ***
;  ********************************************************************
	strout	 prompt
	cmp	[Show],TRUE	      ; /N not specified
	jne	PromptDone
	mov	di, offset Choices
;	putchr	BLANK
	putchr	CHOICEBEG	    ; display leading [
ChoiceOut:
	putchr	[di]
	inc	di
	cmp	BYTE PTR [di], NUL  ; more?
	je	Choice20
	putchr	CHOICEDELIM
	jmp	ChoiceOut

Choice20:
	putchr	CHOICEEND	    ; put on final ]?
	putchr	QUESTION

PromptDone:

;  ********************************************************************
;  ***	 If TimeOut specified, wait for timeout or keypress and     ***
;  ***	     set Key to timeout default value if timeout occurs.    ***
;  ********************************************************************
	cmp TimeOut, 0
	je  TimeOutDone

	mov ah, 2ch	    ; Get Start Seconds
	int 21h
	mov LastSecs, dh

CheckKeyPress:
	mov ah, 0bh	    ; check for keypress
	int 21h
	and ax, 0001h
	or ax,0
	jnz TimeOutDone     ; key was pressed

TimeOutLoop1:
	mov ah, 2ch	    ; Get Seconds
	int 21h
	cmp [LastSecs], dh
	je CheckKeyPress
	mov LastSecs,dh
	dec TimeOut		; second elapsed
	jnz CheckKeyPress	; check for another key
	mov al, TimeOutDefault	; Timed out. simulate reading of char
	jmp GetKey01
TimeOutDone:

;  ********************************************************************
;  ***	  If no TimeOut occurred, THEN				    ***
;  ***	      LOOP						    ***
;  ***		 wait for keypress.				    ***
;  ***		 if key is not valid print BEL char & set Key=0	    ***
;  ***	      UNTIL key !=0					    ***
;  ***	  ENDIF 						    ***
;  ********************************************************************
GetKey0:
	    getchr
GetKey01:				; Jump here if Timed Out
	    mov di, offset CHOICES	; search for key in choices

GetKey1:    cmp [CaseSense], TRUE	; Unless CaseSense, convert to ucase
	    je	GetKey2
	    call ToUpper		; convert to al upper case
GetKey2:
	    cmp BYTE PTR [di], NUL
	    je	Badkey
	    scasb
	    je	GotKey
	    jmp GetKey2
Badkey:
	    putchr BEL
	    jmp GetKey0

GotKey:
	    putchr  al
	    putchr  CR
	    putchr  LF
	    sub di, offset choices	; convert to offset
	    mov ax, di

;  ********************************************************************
;  ***	Exit (offset of Key in Choices) 			    ***
;  ********************************************************************

ChoiceDone:
	    mov ah, 04Ch
	    int 21h	; Exit

;  ********************************************************************
;  ***	MyStrOut
;  ***	Input Args:    bx address of string
;  ***	Destroys:      nothing
;  ***	Returns:       nothing
;  ********************************************************************

MyStrOut PROC USES ax di dx
    mov     ah, 02h		    ; Display Char function. Can't use 09
				    ; because we need to print $'s.
    xor     di,di		    ; di is offset of chars to print
MyStrOutLoop1:
    mov     dl, [bx+di]
    cmp     dl, NUL
    je	    MyStrOutDone
    int     21h
    inc     di
    jmp     MyStrOutLoop1
MyStrOutDone:
    ret
MyStrOut ENDP

;  ********************************************************************
;  ***	ToUpper converts charcter in al to upper case		    ***
;  ***	For extended characters, uses uppercase table		    ***
;  ***	Call with:						    ***
;  ***	    al = char to uppcase				    ***
;  ***	destroys: ah & converts al to uppercase 		    ***
;  ********************************************************************
ToUpper PROC uses bx di es
	cmp al,'a'
	jb  ToUpperDone
	cmp al,'z'
	ja  NotAlpha
	sub al, 20h	; convert to uppercase
	jmp ToUpperDone
NotAlpha:
	cmp	al,80h			; if DL is extended char, get mapping
	jb	ToUpperDone		; AL not extended char
	les	di,dword ptr UCaseTbl	   ; get the table
	mov	bx, ax
	xor	bh,bh
	sub	bx, UCaseTblBias	; get the index
	mov	al,es:[di+bx]		; get the char

ToUpperDone:
	ret
ToUpper ENDP

END  start
=== C:/Users/treeman/Desktop/windows nt source code\dos-6.0\c6ers\interlnk\boxfunc.h ===
/***
* $Workfile:   boxfunc.h  $
* $Revision:   1.3  $
*   $Author:   Dave Sewell  $
*     $Date:   04 May 1990  9:13:02  $
***/

extern void _cdecl reset_disk(void);
extern void make_server_id(void);
extern int bios_handler(word count);
extern int prn_write_handler(word count);
extern int prn_cmd_handler(word count);
extern void _pascal hook_int2f(void);
extern void _pascal unhook_int2f(void);
extern int _fastcall is_il_drive(unsigned drive_num);
/* File calldvr.asm */
extern void pascal call_driver(void far *rhp, struct device_header far *header);
/* File crctab.asm */
/* File setcerr.asm */
extern void pascal set_critical_error(void);
/* File criterr.c */ 
extern  int pascal criterr(int ax,int err_code,struct device_header far *driver);
/* File devinfo.c */ 
extern void _pascal read_volume_label(int dev);
extern  void load_device_information(void );
extern  struct device_header far *find_char_device(char *name);
extern  int open_file(int dev, char *filename);
/* File handler.c */ 
extern  void communication_error(char value);
extern  void master_id_error(char *handler);
extern  void invalid_device_error(int device);
extern  int unknown_handler(unsigned short count);
extern  int server_info_handler(unsigned short count);
extern  int init_handler(unsigned short count);
extern  int media_check_handler(unsigned short count);
extern  int build_bpb_handler(unsigned short count);
extern  int read_handler(unsigned short count);
extern  int write_handler(