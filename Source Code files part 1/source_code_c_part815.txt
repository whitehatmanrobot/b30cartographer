Function ordinal number.
	WsDecision_t	iMaxWt = WSDECISION_TAKEN; // Highest weighted edge encountered.
	UINT	uiRet = 0;		// Return index.
	for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
	{
		if (uiFxn == uiIndex
         || WsDecision[uiIndex][uiFxn] == WSDECISION_TAKEN)
			continue;
		if (WsDecision[uiIndex][uiFxn] > iMaxWt
         || iMaxWt == WSDECISION_TAKEN )
		{
			iMaxWt = WsDecision[uiIndex][uiFxn];
			uiRet = uiFxn;
		}
		else if (WsDecision[uiIndex][uiFxn] == iMaxWt)
		{
			/* Need tiebreak.  If 'uiFxn' has already been selected,
			 * we know it is important, so choose it.  Otherwise,
			 * and in the case where more than one of the tied
			 * functions has already been selected, choose based
			 * on the diagonal value.
			 */
			if ((WsrFxn[uiFxn].wsrfxn_fCandidate == FALSE) &&
				(WsrFxn[uiRet].wsrfxn_fCandidate))
				/* Choose 'uiFxn', it's been selected before */
				uiRet = uiFxn;
         else
			if (WsDecision[uiFxn][uiFxn] > WsDecision[uiRet][uiRet])
            uiRet = uiFxn;
		}
	}
	WsDecision[uiIndex][uiRet] = WsDecision[uiRet][uiIndex] = WSDECISION_TAKEN;
	return(uiRet);
}
#else // SLOWMO

/*
 *
 ***LP wsRedChooseEdgeOpt
 *
 *
 * Effects:
 *
 *	"Selects" a function from the candidate pool, based on weighted
 *	edge from 'index' function to a candidate function. Allocates a sorted
 * index (highest to lowest) to each function's edges on demand. Uses the
 * current highest value (with a few checks) as the selection. This
 * optimized algorithm produces identical results for the important high
 * usage high overlap functions, but diverges in the results for low usage
 * (2 or 1 hits) low overlap functions. Differences are not significant
 * from a performance perspective - a better algorithm would give marginally
 * better results.
 *
 *
 *
 * Returns:
 *
 *	Ordinal number of selected function.
 *
 */

UINT
wsRedChooseEdgeOpt(UINT uiIndex)
{
	UINT        uiRet;
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];

   // Allocate and sort edges list if it doesn't already exist for this function
   if (wsRedChooseEdgeOptAlloc( uiIndex ))
   {
		wsRedExit( ERROR, PRINT_MSG, MSG_NO_MEM,
         (cFxnsTot - 1) * sizeof(*pWsrFxn->pnEdges), "WsrFxn[].pnEdges" );
   }

   // Check remaining edges
   uiRet = wsRedChooseEdgeOptNextEdge( uiIndex, FALSE );

   if (uiRet == cFxnsTot)
   // What should we do here? The algorithm we're copying falls through
   // and arbitrarily returns 0. It seems we should pick the most overlapped
   // non-Candidate, or the heaviest Candidate and restart from there.
   {
   	WsDecision_t	iMaxWt;
      static UINT    nFxnOrdStart = 0; // Remember last value to restart there
      static UINT    nFxnTotStart = 0; // Remember last value to restart there
      UINT           nSelIndex;
      UINT           nFxn;

      // Search for most overlapped non-Candidate that's not uiIndex ('uiIndex' should be empty by now)
      iMaxWt = WSDECISION_TAKEN;
      for (nFxn = nFxnOrdStart; nFxn < cFxnOrder; ++nFxn)
      {
         UINT        nLocalIndex = FxnOrder[nFxn];
         UINT        nRetCheck;

			if (!WsrFxn[nLocalIndex].nEdgesLeft)
         {
            if (nFxnOrdStart == nFxn)  // Haven't found available edge yet?
               ++nFxnOrdStart;   // All non-Candidates already have been allocated, so they can be skipped next time
            continue;
         }
         // Get the first available value remaining
         nRetCheck = wsRedChooseEdgeOptNextEdge( nLocalIndex, TRUE );
         if (nRetCheck != cFxnsTot
            && nRetCheck != uiIndex)
         {
            // See if this one's heavier
            if (WsDecision[nLocalIndex][nRetCheck] > iMaxWt
               || iMaxWt == WSDECISION_TAKEN)
            {
               nSelIndex = nLocalIndex;
               iMaxWt = WsDecision[nSelIndex][nRetCheck];
               uiRet = nRetCheck;
            }
            else if (WsDecision[nLocalIndex][nRetCheck] == iMaxWt // On tie, use heaviest function
               && WsDecision[nRetCheck][nRetCheck] > WsDecision[uiRet][uiRet])   // Assume uiRet != cFxnsTot by now
            {
               nSelIndex = nLocalIndex;
               uiRet = nRetCheck;
            }
         }
      }
      if (uiRet != cFxnsTot)  // Found an overlapped non-Candidate?
      {
         WsDecision[nSelIndex][uiRet] = WsDecision[uiRet][nSelIndex] = WSDECISION_TAKEN;
         return uiRet;
      }
      else  // Didn't find an overlapped non-Candidate?
      {
         // Search for heaviest Candidate - assume at least two are left: see wsRedReorder()
         iMaxWt = WSDECISION_TAKEN;
         for (nFxn = nFxnTotStart; nFxn < cFxnsTot; ++nFxn)
         {
            if (!WsrFxn[nFxn].wsrfxn_fCandidate)
            {
               if (nFxnTotStart == nFxn)  // Haven't found unused value yet?
                  ++nFxnTotStart;   // If it's not a candidate now, it won't be again either
               continue;
            }
            if (nFxn == uiIndex)
               continue;
            if (WsDecision[nFxn][nFxn] > iMaxWt
               || iMaxWt == WSDECISION_TAKEN)
            {
               iMaxWt = WsDecision[nFxn][nFxn];
               uiRet = nFxn;
            }
         }
      }
   }

	WsDecision[uiIndex][uiRet] = WsDecision[uiRet][uiIndex] = WSDECISION_TAKEN;
	return uiRet;
}

// Comparison function for qsort - uses external nFxnToSort for static index
INT
__cdecl
wsRedChooseEdgeOptCmp ( const UINT *pn1, const UINT *pn2 )
{
   WsDecision_t   Val1 = WsDecision[nFxnToSort][*pn1],
                  Val2 = WsDecision[nFxnToSort][*pn2];
   return Val1 > Val2 ? -1 // higher values preferred
      : Val1 < Val2 ? 1
      // If the same, prefer the highest valued diagonal
      : (Val1 = WsDecision[*pn1][*pn1]) > (Val2 = WsDecision[*pn2][*pn2]) ? -1   
      : Val1 < Val2 ? 1
      // Prefer prior function if no other differences
      : *pn1 < *pn2 ? -1
      : 1;
}

// Allocate and sort edges list for a function if not already allocated
// Return TRUE on failure to allocate, FALSE if successful (even if list is empty)
// Creates sorted index list from all non-zero unused WsDecision entries for this row
//  except for the diagonal. Sorts from greatest to lowest: see wsRedChooseEdgeOptCmp().
//  If no such entries exist, marks the function edges as allocated, but with none
//  left to scan; doesn't actually allocate any memory.
BOOL
wsRedChooseEdgeOptAlloc( UINT uiIndex )
{
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];

   if (pWsrFxn->nEdgesAlloc == 0
      && pWsrFxn->pnEdges == NULL)
   {
      UINT     nEdgeTot, nFxn;
      // Allocate maximum size initially
      pWsrFxn->pnEdges = malloc( (cFxnsTot - 1) * sizeof(*pWsrFxn->pnEdges) );
      if (pWsrFxn->pnEdges == NULL) // No more memory?
         return TRUE;
      // Fill in array
      for (nEdgeTot = nFxn = 0; nFxn < cFxnsTot; ++nFxn)
      {
         if (nFxn == uiIndex) // Skip diagonal
            continue;
         if (WsDecision[uiIndex][nFxn] > 0  // Edge still available? No point in considering 0
            && WsDecision[uiIndex][nFxn] != WSDECISION_TAKEN)
            pWsrFxn->pnEdges[nEdgeTot++] = nFxn;
      }
      if (nEdgeTot > 0) // Edges available?
      {
         if (nEdgeTot != (cFxnsTot - 1))  // Extra space allocated?
         {
            // Make it smaller
            UINT     *pNewAlloc = realloc( pWsrFxn->pnEdges, nEdgeTot * sizeof(*pWsrFxn->pnEdges) );
            if (pNewAlloc != NULL)
               pWsrFxn->pnEdges = pNewAlloc;
         }
         // Fill in remaining structure members
         pWsrFxn->nEdgesAlloc = pWsrFxn->nEdgesLeft = nEdgeTot;
         // Sort highest to lowest
         nFxnToSort = uiIndex;   // Set static for sort function
         qsort( pWsrFxn->pnEdges, nEdgeTot, sizeof(*pWsrFxn->pnEdges),
            (int (__cdecl *)(const void *, const void *))wsRedChooseEdgeOptCmp );
      }
      else  // pWsrFxn->nEdgesAlloc == NULL
      {
         // Set structure members to indicate nothing left
         pWsrFxn->nEdgesAlloc = 1;  // non-zero indicates some allocation happened
         pWsrFxn->nEdgesLeft = 0;
         free( pWsrFxn->pnEdges );  // Eliminate allocation - nothing left to check
         pWsrFxn->pnEdges = NULL;
      }
   }
   return FALSE;
}

// Get next edge for given function; highest overlap of most-used function
// Returns "cFxnsTot" if no edge exists; otherwise the function index of next edge
// Side-effect: optimizes search for next pass; frees edge index if no longer needed
// Since choosing an edge marks WsDecision entries as used (WSDECISION_TAKEN), we
//  must step over any of these entries. Once these entries and the first unused entry
//  have been selected, we don't need to consider them anymore. However, if
//  'bNoSelectOpt' is TRUE, only optimize leading skipped entries (not the selected
//  entry, since it may not be taken).
UINT
wsRedChooseEdgeOptNextEdge( UINT uiIndex, BOOL bNoSelectOpt )
{
   wsrfxn_t *  pWsrFxn = &WsrFxn[uiIndex];
   UINT        uiRet = cFxnsTot;

   if (pWsrFxn->nEdgesLeft > 0)
   {
      UINT           nMaxIx,
                     nNextIx = pWsrFxn->nEdgesAlloc - pWsrFxn->nEdgesLeft;
      WsDecision_t   iMax, iNext;
      UINT           nRetCheck;

      // Get the first available value remaining
      while ((iMax = WsDecision[uiIndex][nRetCheck = pWsrFxn->pnEdges[nMaxIx = nNextIx++]])
          == WSDECISION_TAKEN
         && nNextIx < pWsrFxn->nEdgesAlloc);
      // Check next available value for equivalence
      if (iMax != WSDECISION_TAKEN)
      {
         UINT     nMaxIxNext = nMaxIx; // Save index of next used entry

         uiRet = nRetCheck;
         for (; nNextIx < pWsrFxn->nEdgesAlloc; ++nNextIx)
         {
            nRetCheck = pWsrFxn->pnEdges[nNextIx];
            iNext = WsDecision[uiIndex][nRetCheck];
            if (iNext != WSDECISION_TAKEN)
            {
               if (iNext != iMax // only need to check for equality since already sorted
                  || !WsrFxn[uiRet].wsrfxn_fCandidate)   // Already selected - choose this one
                  break;
               else
               {
			         /* Need tiebreak.  If 'nRetCheck' has already been selected,
			          * we know it is important, so choose it.  Otherwise,
			          * and in the case where more than one of the tied
			          * functions have already been selected, choose based
			          * on the diagonal value (i.e. keep previous choice since
                   * sort already accounts for diagonal if equal vertices).
			          */
			         if (!WsrFxn[nRetCheck].wsrfxn_fCandidate)
				      // Choose 'nRetCheck' - it's been selected before
                  {
				         uiRet = nRetCheck;
                     nMaxIxNext = nMaxIx - 1;   // First used entry will be checked again; don't skip it
                  }
               }
            }
            else if (nMaxIxNext == (nNextIx - 1))  // Skip unavailable values after first used entry only
               ++nMaxIxNext;
         }
         if (!bNoSelectOpt && nMaxIxNext != nMaxIx)
            nMaxIx = nMaxIxNext; // Skip over first used entry and unused entries after it
      }
      else if (bNoSelectOpt)  // This is the last one, so step over it anyway
         ++nMaxIx;
      // Adjust the optimization indexes
      pWsrFxn->nEdgesLeft = pWsrFxn->nEdgesAlloc - nMaxIx - (bNoSelectOpt ? 0 : 1);
      if (pWsrFxn->nEdgesLeft == 0)
      {
         free( pWsrFxn->pnEdges );  // Eliminate allocation - nothing left to check
         pWsrFxn->pnEdges = NULL;
      }
#ifdef YOUVE_REALLY_GOT_MEMORY_PROBLEMS
      else if (pWsrFxn->nEdgesLeft < pWsrFxn->nEdgesAlloc / 2  // Periodically get rid of some unused memory
         && pWsrFxn->nEdgesLeft > 50)
      {
         // Move edges to lower part of allocation and reallocate
         UINT *      pNewAlloc;
         nNextIx = pWsrFxn->nEdgesAlloc - pWsrFxn->nEdgesLeft;
         MoveMemory( pWsrFxn->pnEdges, &pWsrFxn->pnEdges[nNextIx], pWsrFxn->nEdgesLeft * sizeof(*pWsrFxn->pnEdges) );
         pNewAlloc = realloc( pWsrFxn->pnEdges, pWsrFxn->nEdgesLeft * sizeof(*pWsrFxn->pnEdges) );
         if (pNewAlloc != NULL)
            pWsrFxn->pnEdges = pNewAlloc;
         pWsrFxn->nEdgesAlloc = pWsrFxn->nEdgesLeft;
      }
#endif   // YOUVE_REALLY_GOT_MEMORY_PROBLEMS
   }
   return uiRet;
}

#endif   // SLOWMO

/*
 *
 ***LP wsRedOutput
 *
 *
 * Effects:
 *
 * Prints the reordered list of functions, and writes each module's
 * ordered list of function ordinals to the module's associated WSR file.
 * If only one module is being processed, then we also write the ordered
 * list of function names to a WLK file.
 *
 * Returns:
 *
 *	Void.  If an error is encountered, exits through wsRedExit()
 *	with ERROR.
 */

VOID
wsRedOutput()
{
	UINT		uiFxn;
   UINT     uiFxnOrd;
	wsrfxn_t 	*pWsrFxn;
								  // fxn names for linker reordering

	// Open one WSR file per module.  If only one module is reduced,
	// then also open a WLK file.  Handle to WLK file is set in
	// wsRedOpenWSR().
	wsRedOpenWSR(&hFileWLK);

   WsIndicator( WSINDF_NEW, "Saving Results", cTmiFxns );
   for (uiFxn = 0; uiFxn < cFxnsTot; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		pWsrFxn = &(WsrFxn[uiFxnOrd = FxnOrder[uiFxn]]);

		/* Print the function information. */
#ifdef DEBUG
      if (fVerbose)
#ifndef TMIFILEHACK
		if (fFxnSizePresent == FALSE)
			printf("    %s: %s\n",
				pWsrMod->wsrmod_un.wsrmod_pchModName,
				pWsrFxn->wsrfxn_pchFxnName);
		else
#endif /* !TMIFILEHACK */
			printf("    (0x%08lx bytes) %s: %s\n",
				pWsrFxn->wsrfxn_cbFxn,
				pWsrMod->wsrmod_un.wsrmod_pchModName,
				pWsrFxn->wsrfxn_pchFxnName);
#endif   // DEBUG

		/* Write the function's ordinal number to its
		 * module's associated WSR output file.
		 */
		fprintf(pWsrMod->wsrmod_hFileWSR, "%ld\n",
				uiFxnOrd);

		/* Write the function name to the WLK file, for linker use. */
		if (hFileWLK != NULL &&
			strcmp("???", pWsrFxn->wsrfxn_pchFxnName) &&
			strcmp("_penter", pWsrFxn->wsrfxn_pchFxnName))
			fprintf(hFileWLK, "%s\n", pWsrFxn->wsrfxn_pchFxnName);

	}

	for (uiFxn = cFxnsTot; uiFxn < cTmiFxns; uiFxn++)
	{
      WsIndicator( WSINDF_PROGRESS, NULL, uiFxn );
		pWsrFxn = &(WsrFxn[FxnOrder[0]]);

		/* Write the function's ordinal number to its
		 * module's associated WSR output file.
		 */
		fprintf(pWsrMod->wsrmod_hFileWSR, "%ld\n",
				uiFxn);


	}
	/* Close the WSR files. */
	fclose(pWsrMod->wsrmod_hFileWSR);
	pWsrMod->wsrmod_hFileWSR = NULL;
   WsIndicator( WSINDF_FINISH, NULL, 0 );

}

/*
 *
 ***LP wsRedExit
 *
 ***
 * Requires:
 *
 *
 ***
 *
 * Effects:
 *
 *	Frees up resources (as necessary).  Exits with the specified
 *	exit code, or returns void if exit code is NOEXIT.
 *
 ***
 * Returns:
 *
 *	Void, else exits.
 */

VOID
wsRedExit(UINT uiExitCode, USHORT fPrintMsg, UINT uiMsgCode, ULONG ulParam1, PSZ pszParam2)
{


   /* Print message, if necessary. */
   if (fPrintMsg)
   {
      printf(pchMsg[uiMsgCode], szProgName, pszVersion, ulParam1, pszParam2);
   }

   // Special case:  do NOT exit if called with NOEXIT.
   if (uiExitCode == NOEXIT)
      return;

   wsRedCleanup();   // mdg 98/4
   exit(uiExitCode);
}

VOID wsRedCleanup(VOID)
{
	UINT	x;

   free( pWsrMod->wsrmod_un.wsrmod_pchModName );
   pWsrMod->wsrmod_un.wsrmod_pchModName = NULL;
   for (x = 0; x < cFxnsTot; x++) {
      free( WsrFxn[x].wsrfxn_pchFxnName );
      WsrFxn[x].wsrfxn_pchFxnName = NULL;
#ifndef  SLOWMO
      if (WsrFxn[x].pnEdges != NULL)
      {
         free( WsrFxn[x].pnEdges );
         WsrFxn[x].pnEdges = NULL;
      }
#endif   // SLOWMO
   }
   for (x=0;x < 5 ; x++ ) {
		UnlockAndFreeMem(hMem[x]);
	}

	/* Close the WLK file. */
   if (NULL != hFileWLK)
	   fclose(hFileWLK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\pos.h ===
BOOL GetLastPosition(RECT *prc);
BOOL SetLastPosition(RECT *prc);

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\pos.c ===
#include "xerox.h"
#include "pos.h"

BOOL GetLastPosition(
RECT *prc)
{
    HKEY hKey;
    DWORD dwType = 0;
    DWORD cb;

    if (ERROR_SUCCESS !=
            RegOpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Xerox", &hKey)) {
        return(FALSE);
    }
    RegQueryValueEx(hKey, "Position", 0, &dwType, (LPSTR)prc, &cb);
    if (dwType != REG_BINARY || cb != sizeof(RECT)) {
        RegCloseKey(hKey);
        return(FALSE);
    }
    RegCloseKey(hKey);
    return(TRUE);
}



BOOL SetLastPosition(
RECT *prc)
{
    HKEY hKey;

    if (ERROR_SUCCESS !=
            RegCreateKey(HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Xerox", &hKey)) {
        return(FALSE);
    }
    RegSetValueEx(hKey, "Position", 0, REG_BINARY, (LPSTR)prc, sizeof(RECT));
    RegCloseKey(hKey);
    return(TRUE);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\group.h ===
typedef struct tagTITLELIST {
    struct tagTITLELIST *next;
    LPSTR pszTitle;
    LPSTR pszClass;
} TITLELIST, *PTITLELIST;

typedef struct tagGROUP {
    struct tagGROUP *next;
    LPSTR pszName;
    PTITLELIST ptl;
} GROUP, *PGROUP;


BOOL GroupListInit(HWND hwnd, BOOL fIsCB);
BOOL DeleteGroupDefinition(LPSTR szName);
BOOL AddGroupDefinition(LPSTR szName, HWND hwndList);
BOOL SelectGroupDefinition(LPSTR szName, HWND hwndList, BOOL DisplayMissingWin);
LPSTR GetCurrentGroup(VOID);
VOID SetNoCurrentGroup(HWND, LPSTR);
PGROUP FindGroup(LPSTR szName);
int CountGroups(VOID);
VOID SaveGroups(VOID);
VOID FreeGroups(VOID);
VOID LoadGroups(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\group.c ===
#include "xerox.h"
#include "group.h"

PGROUP pGroups = NULL;
LPSTR pszCurrentGroup = NULL;

/*
 * Adds the names of all defined groups to the listbox/combo box given.
 *
 * Returns TRUE if success and there are >0 groups defined.
 */
BOOL GroupListInit(
HWND hwnd,
BOOL fIsCB)
{
    UINT addStringMsg = LB_ADDSTRING;
    PGROUP pGroup;

    if (pGroups == NULL) {
        return(FALSE);
    }
    if (fIsCB) {
        addStringMsg = CB_ADDSTRING;
    }
    pGroup = pGroups;
    while (pGroup) {
        SendMessage(hwnd, addStringMsg, 0, (LONG_PTR)pGroup->pszName);
        pGroup = pGroup->next;
    }
    return(TRUE);
}



BOOL DeleteGroupDefinition(
LPSTR szName)
{
    PGROUP pGroup, pGroupPrev;
    PTITLELIST ptl;

    pGroupPrev = NULL;
    pGroup = pGroups;
    while (pGroup) {
        if (!_stricmp(pGroup->pszName, szName)) {
            if (pGroupPrev == NULL) {
                pGroups = pGroup->next;
            } else {
                pGroupPrev->next = pGroup->next;
            }
            while (pGroup->ptl != NULL) {
                ptl = pGroup->ptl;
                pGroup->ptl = ptl->next;
                Free(ptl->pszTitle);
                Free(ptl->pszClass);
                Free(ptl);
            }
            Free(pGroup);
            if (pGroups != NULL) {
                pszCurrentGroup = pGroups->pszName;
            } else {
                pszCurrentGroup = NULL;
            }
            return(TRUE);
        }
        pGroupPrev = pGroup;
        pGroup = pGroup->next;
    }
    return(FALSE);
}


BOOL AddGroupDefinition(
LPSTR szName,
HWND hwndList)
{
    PGROUP pGroup, pGroupEnd;
    PTITLELIST ptl;
    HWND hwnd;
    int cItems, cb;
    char szClass[MAX_STRING_BYTES];

    /*
     *  Don't allow duplicate groups.
     *  This is how an existing group can be replaced.
     */
    DeleteGroupDefinition(szName);

    pGroup = Alloc(sizeof(GROUP));
    if (pGroup == NULL) {
        return(FALSE);
    }
    pGroup->pszName = Alloc(strlen(szName) + 1);
    if (pGroup->pszName == NULL) {
        Free(pGroup);
        return(FALSE);
    }
    strcpy(pGroup->pszName, szName);

    pGroup->ptl = NULL;
    cItems = (int)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
    while (cItems--) {
        ptl = Alloc(sizeof(TITLELIST));
        if (ptl != NULL) {
            cb = (int)SendMessage(hwndList, LB_GETTEXTLEN, cItems, 0);
            if (cb) {
                ptl->pszTitle = Alloc(cb + 1);
                if (ptl->pszTitle != NULL) {
                    SendMessage(hwndList, LB_GETTEXT, cItems, (LONG_PTR)ptl->pszTitle);
                    hwnd = (HWND)SendMessage(hwndList, LB_GETITEMDATA, cItems, 0);
                    GetClassName(hwnd, szClass, sizeof(szClass));
                    ptl->pszClass = Alloc(strlen(szClass) + 1);
                    if (ptl->pszClass != NULL) {
                        strcpy(ptl->pszClass, szClass);
                        ptl->next = pGroup->ptl;
                        pGroup->ptl = ptl;
                    } else {
                        Free(ptl->pszTitle);
                        Free(ptl);
                    }

                } else{
                    Free(ptl);
                }
            } else {
                Free(ptl);
            }
        }
    }
    if (pGroup->ptl == NULL) {
        Free(pGroup);
        return(FALSE);
    }

    /*
     *  Put it on the end of the list.  This is an awkward attempt
     *  at making the initial group the first group defined.  Probably
     *  should save this info in the registry.
     */
    pGroup->next = NULL;

    if (pGroups != NULL) {
        pGroupEnd = pGroups;
        while (pGroupEnd->next != NULL) {
            pGroupEnd = pGroupEnd->next;
        }
        pGroupEnd->next = pGroup;
    } else {
        pGroups = pGroup;
    }

    pszCurrentGroup = pGroup->pszName;
    return(TRUE);
}





BOOL SelectGroupDefinition(
LPSTR szName,
HWND hwndList,
BOOL DisplayMissingWin)
{
    PGROUP pGroup;
    HWND hwndAdd;
    PTITLELIST ptl;

    if (szName == NULL) {
        return(FALSE);
    }
    pGroup = FindGroup(szName);
    if (pGroup == NULL) {
        return(FALSE);
    }
    while (SendMessage(hwndList, LB_GETCOUNT, 0, 0)) {
        SendMessage(hwndList, LB_DELETESTRING, 0, 0);
    }
    ptl = pGroup->ptl;
    while (ptl) {
        hwndAdd = FindWindow(ptl->pszClass, ptl->pszTitle);
        if (DisplayMissingWin || (hwndAdd != NULL)) {
            if (hwndAdd == NULL) {
                hwndAdd = INVALID_HANDLE_VALUE;
            }
            AddLBItemhwnd(hwndList, ptl->pszTitle, (LONG_PTR)hwndAdd);
        }

        ptl = ptl->next;
    }
    pszCurrentGroup = pGroup->pszName;
    return(TRUE);
}



LPSTR GetCurrentGroup()
{
    return(pszCurrentGroup);
}

VOID SetNoCurrentGroup(HWND hwnd, LPSTR szTitle)
{
   SetWindowText(hwnd, szTitle);
   pszCurrentGroup = NULL;
}


PGROUP FindGroup(
LPSTR szName)
{
    PGROUP pGroup;

    pGroup = pGroups;
    while (pGroup) {
        if (!_stricmp(szName, pGroup->pszName)) {
            return(pGroup);
        }
        pGroup = pGroup->next;
    }
    return(NULL);
}



int CountGroups()
{
    PGROUP pGroup;
    int c = 0;

    pGroup = pGroups;
    while (pGroup) {
        c++;
        pGroup = pGroup->next;
    }
    return(c);
}


VOID SaveGroups()
{
    DWORD cbSave = 1; // for last NULL terminator.
    int cTitles;
    PGROUP pGroup;
    LPSTR pBuf, psz;
    LPWORD pw;
    HKEY hKey;
    PTITLELIST ptl;

    if (ERROR_SUCCESS !=
            RegCreateKey(HKEY_CURRENT_USER,
                    "Software\\Microsoft\\Xerox", &hKey)) {
        return;
    }

    pGroup = pGroups;
    while (pGroup) {
        cbSave += strlen(pGroup->pszName) + 1;
        ptl = pGroup->ptl;
        while (ptl) {
            cbSave += strlen(ptl->pszTitle) + 2 + strlen(ptl->pszClass) + 2;
            ptl = ptl->next;
        }
        pGroup = pGroup->next;
    }
    if (cbSave == 0) {
        return;
    }
    pBuf = psz = Alloc(cbSave);
    if (pBuf == NULL) {
        return;
    }
    RegSetValueEx(hKey, "Groups", 0, REG_MULTI_SZ, "\0\0", 2);
    pGroup = pGroups;
    while (pGroup) {
        strcpy(psz, pGroup->pszName);
        psz += strlen(psz) + 1;
        ptl = pGroup->ptl;
        while (ptl) {
            *psz++ = '\t';
            strcpy(psz, ptl->pszTitle);
            psz += strlen(psz) + 1;
            *psz++ = '\t';
            strcpy(psz, ptl->pszClass);
            psz += strlen(psz) + 1;
            ptl = ptl->next;
        }
        pGroup = pGroup->next;
    }
    *psz = '\0';    // double NULL terminate last string.
    RegSetValueEx(hKey, "Groups", 0, REG_MULTI_SZ, pBuf, cbSave);
    RegCloseKey(hKey);
    Free(pBuf);
}


VOID FreeGroups()
{
    PTITLELIST ptl;
    PGROUP pGroup;

    pszCurrentGroup = NULL;
    while (pGroups) {
        while (pGroups->ptl) {
            ptl = pGroups->ptl;
            Free(ptl->pszTitle);
            Free(ptl->pszClass);
            pGroups->ptl = ptl->next;
            Free(ptl);
        }
        pGroup = pGroups;
        pGroups = pGroups->next;
        Free(pGroup);
    }
}


VOID LoadGroups()
{
    int cTitles;
    HKEY hKey;
    DWORD cbLoad = 0;
    DWORD dwType;
    LPSTR pBuf, psz;
    PTITLELIST ptl;
    PGROUP pGroup, pGroupEnd = NULL;

    FreeGroups();
    if (ERROR_SUCCESS !=
            RegOpenKey(HKEY_CURRENT_USER, "Software\\Microsoft\\Xerox", &hKey)) {
        return;
    }
    RegQueryValueEx(hKey, "Groups", 0, &dwType, NULL, &cbLoad);
    if (dwType != REG_MULTI_SZ) {
        RegCloseKey(hKey);
        return;
    }
    if (cbLoad) {
        pBuf = psz = Alloc(cbLoad);
        if (pBuf == NULL) {
            return;
        }
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, "Groups", 0, &dwType, pBuf, &cbLoad)) {
            Free(pBuf);
            return;
        }
        while (*psz) {
            pGroup = Alloc(sizeof(GROUP));
            if (pGroup == NULL) {
                Free(pBuf);
                return;
            }
            pGroup->pszName = Alloc(strlen(psz) + 1);
            if (pGroup->pszName == NULL) {
                Free(pBuf);
                Free(pGroup);
                return;
            }
            strcpy(pGroup->pszName, psz);
            pGroup->ptl = NULL;
            psz += strlen(psz) + 1;
            while (*psz == '\t') {
                psz++;
                ptl = Alloc(sizeof(TITLELIST));
                if (ptl == NULL) {
                    Free(pBuf);
                    return;
                }
                ptl->pszTitle = Alloc(strlen(psz));
                if (ptl->pszTitle == NULL) {
                    Free(pBuf);
                    Free(ptl);
                    return;
                }
                strcpy(ptl->pszTitle, psz);
                psz += strlen(psz) + 2;
                ptl->pszClass = Alloc(strlen(psz));
                if (ptl->pszClass == NULL) {
                    Free(pBuf);
                    Free(ptl);
                    return;
                }
                strcpy(ptl->pszClass, psz);
                psz += strlen(psz) + 1;
                ptl->next = pGroup->ptl;
                pGroup->ptl = ptl;
            }

            /*
             *  Restore groups to origional order.
             */
            if (pGroupEnd == NULL) {
                pGroups = pGroup;
                pGroupEnd = pGroup;
            } else {
                pGroupEnd->next = pGroup;
                pGroupEnd = pGroup;
            }
            pGroup->next = NULL;
        }
        Free(pBuf);

        /*
         *  Set default current group to first in list.
         */
        if (pGroups != NULL) {
            pszCurrentGroup = pGroups->pszName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\util.h ===
PVOID   Alloc(SIZE_T);
SIZE_T  GetAllocSize(PVOID);
BOOL    Free(PVOID);

INT       AddItem(HWND, INT, LPSTR, LONG_PTR, BOOL);
INT       AddItemhwnd(HWND, LPSTR, LONG_PTR, BOOL);
LONG_PTR FindData(HWND, LONG_PTR, BOOL);

// Useful macros

#define AddLBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, FALSE))

#define AddCBItem(hDlg, ControlID, string, data) \
        (AddItem(hDlg, ControlID, string, data, TRUE))

#define AddLBItemhwnd(hwnd, string, data) \
        (AddItemhwnd(hwnd, string, data, FALSE))

#define AddCBItemhwnd(hwnd, string, data) \
        (AddItemhwnd(hwnd, string, data, TRUE))

#define FindLBData(hwnd, data) \
        (FindData(hwnd, data, FALSE))

#define FindCBData(hwnd, data) \
        (FindData(hwnd, data, TRUE))
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\util.c ===
/****************************************************************************

   PROGRAM: UTIL.C

   PURPOSE: System utility routines

****************************************************************************/

#include "xerox.h"
#include <string.h>


/****************************************************************************

   FUNCTION: Alloc

   PURPOSE: Allocates memory to hold the specified number of bytes

   RETURNS : Pointer to allocated memory or NULL on failure

****************************************************************************/

PVOID
Alloc(
    SIZE_T   Bytes
    )
{
    HANDLE  hMem;
    PVOID   Buffer;

    hMem = LocalAlloc(LMEM_MOVEABLE, Bytes + sizeof(hMem));

    if (hMem == NULL) {
        return(NULL);
    }

    // Lock down the memory
    //
    Buffer = LocalLock(hMem);
    if (Buffer == NULL) {
        LocalFree(hMem);
        return(NULL);
    }

    //
    // Store the handle at the start of the memory block and return
    // a pointer to just beyond it.
    //

    *((PHANDLE)Buffer) = hMem;

    return (PVOID)(((PHANDLE)Buffer)+1);
}


/****************************************************************************

   FUNCTION:  GetAllocSize

   PURPOSE: Returns the allocated size of the specified memory block.
            The block must have been previously allocated using Alloc

   RETURNS : Size of memory block in bytes or 0 on error

****************************************************************************/

SIZE_T
GetAllocSize(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    return(LocalSize(hMem) - sizeof(hMem));
}


/****************************************************************************

   FUNCTION: Free

   PURPOSE: Frees the memory previously allocated with Alloc

   RETURNS : TRUE on success, otherwise FALSE

****************************************************************************/

BOOL
Free(
    PVOID   Buffer
    )
{
    HANDLE  hMem;

    hMem = *(((PHANDLE)Buffer) - 1);

    LocalUnlock(hMem);

    return(LocalFree(hMem) == NULL);
}


/****************************************************************************

    FUNCTION: AddItem

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItem(
    HWND      hDlg,
    INT       ControlID,
    LPSTR     String,
    LONG_PTR  Data,
    BOOL      fCBox
    )
{
    HWND    hwnd;
    INT     iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    hwnd = GetDlgItem(hDlg, ControlID);

    iItem = (INT)SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return(iItem);
}


/****************************************************************************

    FUNCTION: AddItemhwnd

    PURPOSE:  Adds the item string and data to the specified control
              The control is assumed to be a list-box unless fCBox == TRUE
              in which case the control is assumed to be a ComboBox

    RETURNS:  Index at which the item was added or < 0 on error

****************************************************************************/
INT
AddItemhwnd(
    HWND       hwnd,
    LPSTR      String,
    LONG_PTR   Data,
    BOOL       fCBox
    )
{
    INT     iItem;
    USHORT  AddStringMsg = LB_ADDSTRING;
    USHORT  SetDataMsg = LB_SETITEMDATA;

    if (fCBox) {
        AddStringMsg = CB_ADDSTRING;
        SetDataMsg = CB_SETITEMDATA;
    }

    iItem = (INT)SendMessage(hwnd, AddStringMsg, 0, (LONG_PTR)String);

    if (iItem >= 0) {
        SendMessage(hwnd, SetDataMsg, iItem, Data);
    }

    return(iItem);
}


/****************************************************************************

    FUNCTION: FindData

    PURPOSE:  Searches for the specified data in a combo box or lbox.

    RETURNS:  Index of matching item or < 0 on error

****************************************************************************/
LONG_PTR
FindData(
    HWND     hwnd,
    LONG_PTR data,
    BOOL     fCBox
    )
{
    INT     cItems;
    USHORT  GetCountMsg = LB_GETCOUNT;
    USHORT  GetDataMsg = LB_GETITEMDATA;

    if (fCBox) {
        GetCountMsg = CB_GETCOUNT;
        GetDataMsg = CB_GETITEMDATA;
    }

    cItems = (INT)SendMessage(hwnd, GetCountMsg, 0, 0);

    if (cItems >= 0) {

        INT      iItem;
        LONG_PTR ItemData;

        for (iItem =0; iItem < cItems; iItem ++) {
            ItemData = SendMessage(hwnd, GetDataMsg, iItem, 0);
            if (data == ItemData) {
                return(iItem);
            }
        }
    }
    return(-1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\yapt\yapt.h ===
#include <windows.h>

#define READ          0
#define WRITE         1
#define SEQ           0
#define RAND          1

#define FILE_SIZE     20 * 1024 * 1024
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\yapt\makefile.inc ===
copyexe:
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\xerox.h ===
#ifndef RC_INVOKED
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#endif

#include <windows.h>

#ifndef RC_INVOKED
#include <port1632.h>
#endif

#include "dlg.h"

typedef PVOID   *PPVOID;

// Resource ids
#define IDM_MAINMENU                    3000
#define IDM_ABOUT                       3001
#define IDM_TARGETADD                   3002
#define IDM_TARGETDELETE                3003
#define IDI_APPICON                     3005
#define IDM_GROUPADD                    3006
#define IDM_GROUPDELETE                 3007
#define IDM_GROUPSELECT                 3008
#define IDR_ACCEL                       3009
#define IDM_GROUPRSTWIN                 3010
#define IDM_GROUPMINWIN                 3011
#define IDM_REFRESHITEMS                3012

// Define the maximum number of selected windows
#define MAX_WINDOWS             255

// Define the maximum length of a resource string
#define MAX_STRING_LENGTH       255
#define MAX_STRING_BYTES        (MAX_STRING_LENGTH + 1)

#ifndef RC_INVOKED
#include "util.h"
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\zoomin\zoomin.c ===
/****************************************************************************/
/*                                                                          */
/*                         Microsoft Confidential                           */
/*                                                                          */
/*                 Copyright (c) Microsoft Corp.  1987, 1990                */
/*                           All Rights Reserved                            */
/*                                                                          */
/****************************************************************************/
/****************************** Module Header *******************************
* Module Name: zoomin.c
*
* Microsoft ZoomIn utility.  This tool magnifies a portion of the screen,
* allowing you to see things at a pixel level.
*
* History:
* 01/01/88 ToddLa Created.
* 01/01/92 MarkTa Ported to NT.
* 03/06/92 ByronD Cleanup.
*
****************************************************************************/

#include "zoomin.h"


TCHAR szAppName[] = TEXT("ZoomIn");     // Aplication name.
HINSTANCE ghInst;                       // Instance handle.
HWND ghwndApp;                          // Main window handle.
HANDLE ghaccelTable;                    // Main accelerator table.
INT gnZoom = 4;                         // Zoom (magnification) factor.
HPALETTE ghpalPhysical;                 // Handle to the physical palette.
INT gcxScreenMax;                       // Width of the screen (less 1).
INT gcyScreenMax;                       // Height of the screen (less 1).
INT gcxZoomed;                          // Client width in zoomed pixels.
INT gcyZoomed;                          // Client height in zoomed pixels.
BOOL gfRefEnable = FALSE;               // TRUE if refresh is enabled.
INT gnRefInterval = 20;                 // Refresh interval in 10ths of seconds.
BOOL gfTracking = FALSE;                // TRUE if tracking is in progress.
POINT gptZoom = {100, 100};             // The center of the zoomed area.
BOOL gShowGrid = FALSE;                 // Show a grid so you can see the pixels



/************************************************************************
* WinMain
*
* Main entry point for the application.
*
* Arguments:
*
* History:
*
************************************************************************/

INT
WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR     lpCmdLine,
    INT       nCmdShow
    )
{
    MSG msg;

    if (!InitInstance(hInst, nCmdShow))
        return FALSE;

    /*
     * Polling messages from event queue
     */

    while (GetMessage(&msg, NULL, 0, 0)) {
        if (!TranslateAccelerator(ghwndApp, ghaccelTable, &msg)) {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
    }

    return (INT)msg.wParam;
}



/************************************************************************
* InitInstance
*
* Instance initialization for the app.
*
* Arguments:
*
* History:
*
************************************************************************/

BOOL
InitInstance(
    HINSTANCE hInst,
    INT cmdShow
    )
{
    WNDCLASS wc;
    INT dx;
    INT dy;
    DWORD flStyle;
    RECT rc;

    ghInst = hInst;

    /*
     * Register a class for the main application window.
     */
    wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wc.hIcon          = LoadIcon(hInst, TEXT("zoomin"));
    wc.lpszMenuName   = MAKEINTRESOURCE(IDMENU_ZOOMIN);
    wc.lpszClassName  = szAppName;
    wc.hbrBackground  = GetStockObject(BLACK_BRUSH);
    wc.hInstance      = hInst;
    wc.style          = CS_VREDRAW | CS_HREDRAW;
    wc.lpfnWndProc    = AppWndProc;
    wc.cbWndExtra     = 0;
    wc.cbClsExtra     = 0;

    if (!RegisterClass(&wc))
        return FALSE;

    if (!(ghaccelTable = LoadAccelerators(hInst, MAKEINTRESOURCE(IDACCEL_ZOOMIN))))
        return FALSE;

    if (!(ghpalPhysical = CreatePhysicalPalette()))
        return FALSE;

    /* Get the size of the screen.
    ** In NT 4.0 sp3 and NT 5.0 new system metrics would get the
    ** desktop area which may go across multiple monitors.  If that
    ** doesn't work, fall back to the old method.
    */

#ifdef SM_CXVIRTUALSCREEN
    if( GetSystemMetrics(SM_CXVIRTUALSCREEN) )
    {
        gcxScreenMax= GetSystemMetrics(SM_CXVIRTUALSCREEN) -1;
        gcyScreenMax= GetSystemMetrics(SM_CYVIRTUALSCREEN) -1;
    }
    else
#endif
    {
        gcxScreenMax= GetSystemMetrics(SM_CXSCREEN) - 1;
        gcyScreenMax= GetSystemMetrics(SM_CYSCREEN) - 1;
    }

    flStyle = WS_CAPTION | WS_OVERLAPPED | WS_SYSMENU | WS_THICKFRAME |
            WS_MINIMIZEBOX | WS_VSCROLL;
    dx = 44 * gnZoom;
    dy = 36 * gnZoom;

    SetRect(&rc, 0, 0, dx, dy);
    AdjustWindowRect(&rc, flStyle, TRUE);

    ghwndApp = CreateWindow(szAppName, szAppName, flStyle,
            CW_USEDEFAULT, 0, rc.right - rc.left, rc.bottom - rc.top,
            NULL, NULL, hInst, NULL);

    if (!ghwndApp)
        return FALSE;

    ShowWindow(ghwndApp, cmdShow);

    return TRUE;
}



/************************************************************************
* CreatePhysicalPalette
*
* Creates a palette for the app to use.  The palette references the
* physical palette, so that it can properly display images grabbed
* from palette managed apps.
*
* History:
*
************************************************************************/

HPALETTE
CreatePhysicalPalette(
    VOID
    )
{
    PLOGPALETTE ppal;
    HPALETTE hpal = NULL;
    INT i;

    ppal = (PLOGPALETTE)LocalAlloc(LPTR,
            sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * NPAL);
    if (ppal) {
        ppal->palVersion = 0x300;
        ppal->palNumEntries = NPAL;

        for (i = 0; i < NPAL; i++) {
            ppal->palPalEntry[i].peFlags = (BYTE)PC_EXPLICIT;
            ppal->palPalEntry[i].peRed   = (BYTE)i;
            ppal->palPalEntry[i].peGreen = (BYTE)0;
            ppal->palPalEntry[i].peBlue  = (BYTE)0;
        }

        hpal = CreatePalette(ppal);
        LocalFree(ppal);
    }

    return hpal;
}



/************************************************************************
* AppWndProc
*
* Main window proc for the zoomin utility.
*
* Arguments:
*   Standard window proc args.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
AppWndProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    PRECT prc;
    HCURSOR hcurOld;

    switch (msg) {
        case WM_CREATE:
            SetScrollRange(hwnd, SB_VERT, MIN_ZOOM, MAX_ZOOM, FALSE);
            SetScrollPos(hwnd, SB_VERT, gnZoom, FALSE);
            break;

        case WM_TIMER:
            /*
             * Update on every timer message.  The cursor will be
             * flashed to the hourglash for some visual feedback
             * of when a snapshot is being taken.
             */
            hcurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
            DoTheZoomIn(NULL);
            SetCursor(hcurOld);
            break;

        case WM_PAINT:
            BeginPaint(hwnd, &ps);
            DoTheZoomIn(ps.hdc);
            EndPaint(hwnd, &ps);
            return 0L;

        case WM_SIZE:
            CalcZoomedSize();
            break;

        case WM_LBUTTONDOWN:
            gptZoom.x= (SHORT) LOWORD(lParam);
            gptZoom.y= (SHORT) HIWORD(lParam);
            ClientToScreen(hwnd, &gptZoom);
            DrawZoomRect();
            DoTheZoomIn(NULL);

            SetCapture(hwnd);
            gfTracking = TRUE;

            break;

        case WM_MOUSEMOVE:
            if (gfTracking) {
                DrawZoomRect();
                gptZoom.x= (SHORT) LOWORD(lParam);
                gptZoom.y= (SHORT) HIWORD(lParam);
                ClientToScreen(hwnd, &gptZoom);
                DrawZoomRect();
                DoTheZoomIn(NULL);
            }

            break;

        case WM_LBUTTONUP:
            if (gfTracking) {
                DrawZoomRect();
                ReleaseCapture();
                gfTracking = FALSE;
            }

            break;

        case WM_VSCROLL:
            switch (LOWORD(wParam)) {
                case SB_LINEDOWN:
                    gnZoom++;
                    break;

                case SB_LINEUP:
                    gnZoom--;
                    break;

                case SB_PAGEUP:
                    gnZoom -= 2;
                    break;

                case SB_PAGEDOWN:
                    gnZoom += 2;
                    break;

                case SB_THUMBPOSITION:
                case SB_THUMBTRACK:
                    gnZoom = HIWORD(wParam);
                    break;
            }

            gnZoom = BOUND(gnZoom, MIN_ZOOM, MAX_ZOOM);
            SetScrollPos(hwnd, SB_VERT, gnZoom, TRUE);
            CalcZoomedSize();
            DoTheZoomIn(NULL);
            break;

        case WM_KEYDOWN:
            switch (wParam) {
                case VK_UP:
                case VK_DOWN:
                case VK_LEFT:
                case VK_RIGHT:
                    MoveView((INT)wParam, GetKeyState(VK_SHIFT) & 0x8000, GetKeyState(VK_CONTROL) & 0x8000);
                    break;
            }

            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case MENU_EDIT_COPY:
                    CopyToClipboard();
                    break;

                case MENU_EDIT_REFRESH:
                    DoTheZoomIn(NULL);
                    break;

                case MENU_OPTIONS_REFRESHRATE:
                    DialogBox(ghInst, MAKEINTRESOURCE(DID_REFRESHRATE), hwnd, RefreshRateDlgProc);

                    break;

                case MENU_HELP_ABOUT:
                    DialogBox(ghInst, MAKEINTRESOURCE(DID_ABOUT), hwnd, AboutDlgProc);

                    break;

                case MENU_OPTIONS_SHOWGRID:
                    {
                        HMENU hMenu = GetSubMenu(GetMenu(ghwndApp), 1);
                        gShowGrid = !gShowGrid;
                        InvalidateRect(ghwndApp, NULL, FALSE);
                        CheckMenuItem(hMenu,
                                      GetMenuItemID(hMenu, 1),
                                      gShowGrid ? MF_CHECKED : MF_UNCHECKED);
                    }
                    break;

                default:
                     break;
            }

            break;

        case WM_CLOSE:
            if (ghpalPhysical)
                DeleteObject(ghpalPhysical);

            DestroyWindow(hwnd);

            break;

        case WM_DESTROY:
            PostQuitMessage(0);
            break;

        default:
            return DefWindowProc(hwnd, msg, wParam, lParam);
    }

    return 0L;
}



/************************************************************************
* CalcZoomedSize
*
* Calculates some globals.  This routine needs to be called any
* time that the size of the app or the zoom factor changes.
*
* History:
*
************************************************************************/

VOID
CalcZoomedSize(
    VOID
    )
{
    RECT rc;

    GetClientRect(ghwndApp, &rc);

    gcxZoomed = (rc.right / gnZoom) + 1;
    gcyZoomed = (rc.bottom / gnZoom) + 1;
}



/************************************************************************
* DoTheZoomIn
*
* Does the actual paint of the zoomed image.
*
* Arguments:
*   HDC hdc - If not NULL, this hdc will be used to paint with.
*             If NULL, a dc for the apps window will be obtained.
*
* History:
*
************************************************************************/

VOID
DoTheZoomIn(
    HDC hdc
    )
{
    BOOL fRelease;
    HPALETTE hpalOld = NULL;
    HDC hdcScreen;
    INT x;
    INT y;

    if (!hdc) {
        hdc = GetDC(ghwndApp);
        fRelease = TRUE;
    }
    else {
        fRelease = FALSE;
    }

    if (ghpalPhysical) {
        hpalOld = SelectPalette(hdc, ghpalPhysical, FALSE);
        RealizePalette(hdc);
    }

    /*
     * The point must not include areas outside the screen dimensions.
     */
    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2));
    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2));

    hdcScreen = GetDC(NULL);
    SetStretchBltMode(hdc, COLORONCOLOR);
    StretchBlt(hdc, 0, 0, gnZoom * gcxZoomed, gnZoom * gcyZoomed,
            hdcScreen, x - gcxZoomed / 2,
            y - gcyZoomed / 2, gcxZoomed, gcyZoomed, SRCCOPY);

    if (gShowGrid && gnZoom > 1)  // don't bother if we're 1 to 1
    {
        int i = 0, j = 0;
        // use gray for now.  later we could get fancy about the colors
        // so that the line is visible when the pixels are gray
        HGDIOBJ hBrush = CreatePen(PS_SOLID, 1, GetSysColor(COLOR_GRAYTEXT));
        HGDIOBJ hOld = SelectObject(hdc, hBrush);

        // first draw the vertical lines...
        while (i < gcxZoomed*gnZoom)
        {
            MoveToEx(hdc, i, 0, NULL);
            LineTo(hdc, i, gcyZoomed*gnZoom);
            i += gnZoom;
        }

        // ... then draw the horizontal lines
        while (j < gcyZoomed*gnZoom)
        {
            MoveToEx(hdc, 0, j, NULL);
            LineTo(hdc, gcxZoomed*gnZoom, j);
            j += gnZoom;
        }
        DeleteObject(SelectObject(hdc, hOld));
    }

    ReleaseDC(NULL, hdcScreen);

    if (hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);

    if (fRelease)
        ReleaseDC(ghwndApp, hdc);
}



/************************************************************************
* MoveView
*
* This function moves the current view around.
*
* Arguments:
*   INT nDirectionCode - Direction to move.  Must be VK_UP, VK_DOWN,
*                        VK_LEFT or VK_RIGHT.
*   BOOL fFast         - TRUE if the move should jump a larger increment.
*                        If FALSE, the move is just one pixel.
*   BOOL fPeg          - If TRUE, the view will be pegged to the screen
*                        boundary in the specified direction.  This overides
*                        the fFast parameter.
*
* History:
*
************************************************************************/

VOID
MoveView(
    INT nDirectionCode,
    BOOL fFast,
    BOOL fPeg
    )
{
    INT delta;

    if (fFast)
        delta = FASTDELTA;
    else
        delta = 1;

    switch (nDirectionCode) {
        case VK_UP:
            if (fPeg)
                gptZoom.y = gcyZoomed / 2;
            else
                gptZoom.y -= delta;

            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax);

            break;

        case VK_DOWN:
            if (fPeg)
                gptZoom.y = gcyScreenMax - (gcyZoomed / 2);
            else
                gptZoom.y += delta;

            gptZoom.y = BOUND(gptZoom.y, 0, gcyScreenMax);

            break;

        case VK_LEFT:
            if (fPeg)
                gptZoom.x = gcxZoomed / 2;
            else
                gptZoom.x -= delta;

            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax);

            break;

        case VK_RIGHT:
            if (fPeg)
                gptZoom.x = gcxScreenMax - (gcxZoomed / 2);
            else
                gptZoom.x += delta;

            gptZoom.x = BOUND(gptZoom.x, 0, gcxScreenMax);

            break;
    }

    DoTheZoomIn(NULL);
}



/************************************************************************
* DrawZoomRect
*
* This function draws the tracking rectangle.  The size and shape of
* the rectangle will be proportional to the size and shape of the
* app's client, and will be affected by the zoom factor as well.
*
* History:
*
************************************************************************/

VOID
DrawZoomRect(
    VOID
    )
{
    HDC hdc;
    RECT rc;
    INT x;
    INT y;

    x = BOUND(gptZoom.x, gcxZoomed / 2, gcxScreenMax - (gcxZoomed / 2));
    y = BOUND(gptZoom.y, gcyZoomed / 2, gcyScreenMax - (gcyZoomed / 2));

    rc.left   = x - gcxZoomed / 2;
    rc.top    = y - gcyZoomed / 2;
    rc.right  = rc.left + gcxZoomed;
    rc.bottom = rc.top + gcyZoomed;

    InflateRect(&rc, 1, 1);

    hdc = GetDC(NULL);

    PatBlt(hdc, rc.left,    rc.top,     rc.right-rc.left, 1,  DSTINVERT);
    PatBlt(hdc, rc.left,    rc.bottom,  1, -(rc.bottom-rc.top),   DSTINVERT);
    PatBlt(hdc, rc.right-1, rc.top,     1,   rc.bottom-rc.top,   DSTINVERT);
    PatBlt(hdc, rc.right,   rc.bottom-1, -(rc.right-rc.left), 1, DSTINVERT);

    ReleaseDC(NULL, hdc);
}



/************************************************************************
* EnableRefresh
*
* This function turns on or off the auto-refresh feature.
*
* Arguments:
*   BOOL fEnable - TRUE to turn the refresh feature on, FALSE to
*                  turn it off.
*
* History:
*
************************************************************************/

VOID
EnableRefresh(
    BOOL fEnable
    )
{
    if (fEnable) {
        /*
         * Already enabled.  Do nothing.
         */
        if (gfRefEnable)
            return;

        if (SetTimer(ghwndApp, IDTIMER_ZOOMIN, gnRefInterval * 100, NULL))
            gfRefEnable = TRUE;
    }
    else {
        /*
         * Not enabled yet.  Do nothing.
         */
        if (!gfRefEnable)
            return;

        KillTimer(ghwndApp, IDTIMER_ZOOMIN);
        gfRefEnable = FALSE;
    }
}



/************************************************************************
* CopyToClipboard
*
* This function copies the client area image of the app into the
* clipboard.
*
* History:
*
************************************************************************/

VOID
CopyToClipboard(
    VOID
    )
{
    HDC hdcSrc;
    HDC hdcDst;
    RECT rc;
    HBITMAP hbm;

    if (OpenClipboard(ghwndApp)) {
        EmptyClipboard();

        if (hdcSrc = GetDC(ghwndApp)) {
            GetClientRect(ghwndApp, &rc);
            if (hbm = CreateCompatibleBitmap(hdcSrc,
                    rc.right - rc.left, rc.bottom - rc.top)) {
                if (hdcDst = CreateCompatibleDC(hdcSrc)) {
                    /*
                     * Calculate the dimensions of the bitmap and
                     * convert them to tenths of a millimeter for
                     * setting the size with the SetBitmapDimensionEx
                     * call.  This allows programs like WinWord to
                     * retrieve the bitmap and know what size to
                     * display it as.
                     */
                    SetBitmapDimensionEx(hbm,
                            (DWORD)(((DWORD)(rc.right - rc.left)
                            * MM10PERINCH) /
                            (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSX)),
                            (DWORD)(((DWORD)(rc.bottom - rc.top)
                            * MM10PERINCH) /
                            (DWORD)GetDeviceCaps(hdcSrc, LOGPIXELSY)), NULL);

                    SelectObject(hdcDst, hbm);
                    BitBlt(hdcDst, 0, 0,
                            rc.right - rc.left, rc.bottom - rc.top,
                            hdcSrc, rc.left, rc.top, SRCCOPY);
                    DeleteDC(hdcDst);
                    SetClipboardData(CF_BITMAP, hbm);
                }
                else {
                    DeleteObject(hbm);
                }
            }

            ReleaseDC(ghwndApp, hdcSrc);
        }

        CloseClipboard();
    }
    else {
        MessageBeep(0);
    }
}



/************************************************************************
* AboutDlgProc
*
* This is the About Box dialog procedure.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (msg) {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
            EndDialog(hwnd, IDOK);
            return TRUE;

        default:
            return FALSE;
    }
}



/************************************************************************
* RefreshRateDlgProc
*
* This is the Refresh Rate dialog procedure.
*
* History:
*
************************************************************************/

INT_PTR
APIENTRY
RefreshRateDlgProc(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL fTranslated;

    switch (msg) {
        case WM_INITDIALOG:
            SendDlgItemMessage(hwnd, DID_REFRESHRATEINTERVAL, EM_LIMITTEXT,
                    3, 0L);
            SetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL, gnRefInterval, FALSE);
            CheckDlgButton(hwnd, DID_REFRESHRATEENABLE, gfRefEnable ? 1 : 0);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case IDOK:
                    gnRefInterval = GetDlgItemInt(hwnd, DID_REFRESHRATEINTERVAL,
                            &fTranslated, FALSE);

                    /*
                     * Stop any existing timers then start one with the
                     * new interval if requested to.
                     */
                    EnableRefresh(FALSE);
                    EnableRefresh(
                            IsDlgButtonChecked(hwnd, DID_REFRESHRATEENABLE));

                    EndDialog(hwnd, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hwnd, IDCANCEL);
                    break;
            }

            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\yapt\yapt.c ===
/*++

Copyright (c) 1994  Microsoft Corporation

Module Name:

    yapt.c

Abstract:

    This module contains the code for the Yet Another Performance Tool utility.

Author:

    Chuck Park (chuckp) 07-Oct-1994

Revision History:


--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <windowsx.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>
#include <assert.h>

#include "yapt.h"


//
// Test proc. declarations
//

BOOLEAN
ReadSequential(
    ULONG Iterations
    );

BOOLEAN
WriteSequential(
    ULONG Iterations
    );

BOOLEAN
ReadRandom(
    ULONG Iterations
    );

BOOLEAN
WriteRandom(
    ULONG Iterations
    );

//
// Common util. functions
//

BOOLEAN
CreateTestFile(
    );

ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    );


BOOL
GetSectorSize(
    PDWORD SectorSize,
    PCHAR  DrvLetter
    );

VOID
LogError(
    PCHAR ErrString,
    DWORD UniqueId,
    DWORD ErrCode
    );

BOOLEAN
ParseCmdLine(
    INT Argc,
    CHAR *Argv[]
    );

BOOLEAN
ValidateOption(
    CHAR Switch,
    CHAR *Value
    );

VOID
VerifyFileName(
    IN CHAR *FileName
    );

VOID
Usage(
    VOID
    );

VOID
__cdecl
Log(
    ULONG LogLevel,
    PCHAR String,
    ...
    );

DWORD
YaptSetFileCompression(
    IN HANDLE FileHandle,
    IN USHORT CompressionFormat
    );

//
// Default parameters
//

#define DEFAULT_BUFFER_SIZE 65536
#define DEFAULT_FILE_SIZE   (20*1024*1024);

ULONG  SectorSize = 512;
ULONG  BufferSize = DEFAULT_BUFFER_SIZE;
ULONG  FileSize   = DEFAULT_FILE_SIZE;
ULONG  QueueSize  = 0;
UCHAR FileName[MAX_PATH] = "test.dat";
UCHAR  Test       = READ;
UCHAR  Access     = SEQ;
ULONG  Verbose    = 0;
ULONG  Iterations = 10;
UCHAR  ReuseFile  = TRUE;
UCHAR  Yes        = FALSE;
BOOLEAN ReadOnly  = FALSE;


INT
_cdecl main (
    INT Argc,
    CHAR *Argv[]
    )
{
    UCHAR testCase;

    //
    // Parse cmd line
    //

    if (!ParseCmdLine(Argc,Argv)) {
        return 1;
    }

    //
    // Create the test file
    //

    if (!CreateTestFile()) {
        return 2;
    }

    //
    // Call appropriate test routine.
    //

    testCase = (Test << 1) | Access;
    switch (testCase) {
        case 0:

           if (!ReadSequential(Iterations)) {
               return 3;
           }
            break;

        case 1:

            //
            // Read random
            //

            if (!ReadRandom(Iterations)) {
                return 3;
            }

            break;

        case 2:

            if (!WriteSequential(Iterations)) {
                return 3;
            }

            break;

        case 3:

            //
            // Write random
            //

            if (!WriteRandom(Iterations)) {
                return 3;
            }

            break;

        default:
            printf("Invalid test case\n");
            return 3;
    }



    return 0;

}

BOOLEAN
CreateTestFile(
    VOID
    )
{
    PUCHAR     buffer;
    HANDLE     port = INVALID_HANDLE_VALUE;
    HANDLE     fileHandle;
    OVERLAPPED overlapped,*overlapped2;
    DWORD      bytesTransferred,bytesTransferred2;
    DWORD_PTR  key;
    ULONG      numberWrites, numberQueued;
    BOOL       status;
    ULONG      i;

    DWORD      currentSize;

    buffer = VirtualAlloc(NULL,
                          DEFAULT_BUFFER_SIZE,
                          MEM_COMMIT,
                          PAGE_READWRITE);

    if ( !buffer ) {
        printf("Error allocating buffer %x\n",GetLastError());
        return FALSE;
    }

    if(ReuseFile) {

        fileHandle = CreateFile(FileName,
                                ReadOnly ? GENERIC_READ :
                                           (GENERIC_READ | GENERIC_WRITE),
                                0,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                                NULL);



        if(fileHandle != INVALID_HANDLE_VALUE) {

            Log(1, "Using existing test file %s\n", FileName);
            goto InitializeTestFile;

        } else {

            Log(1, "Error %d opening existing test file\n", GetLastError());
        }

    } else {

        DeleteFile(FileName);

    }

    fileHandle = CreateFile(FileName,
                            GENERIC_READ | GENERIC_WRITE,
                            0,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                            NULL);

InitializeTestFile:

    if ( fileHandle == INVALID_HANDLE_VALUE ) {
        printf("Error opening file %s %d\n",FileName,GetLastError());
        return FALSE;
    }

    currentSize = GetFileSize(fileHandle, NULL);

    if(currentSize >= FileSize) {

        goto EndCreateTestFile;

    } else if(ReadOnly) {

        FileSize = currentSize;
        goto EndCreateTestFile;
    }

    //
    // Uncompress the file - compressed files will always do cached I/O even
    // if you tell them not to.  If this fails assume it's because the
    // underlying file system doesn't handle compression.
    //

    Log(1, "Trying to decompress %s\n", FileName);

    YaptSetFileCompression(fileHandle, COMPRESSION_FORMAT_NONE);

    port = CreateIoCompletionPort(fileHandle,
                                  NULL,
                                  (DWORD_PTR)fileHandle,
                                  0);
    if ( !port ) {
        printf("Error creating completion port %d\n",GetLastError());
        return FALSE;
    }

    Log(1,"Creating test file %s",FileName);

    memset(&overlapped, 0, sizeof(overlapped));

    numberWrites = FileSize / BufferSize;
    if (!QueueSize || QueueSize > FileSize) {
        QueueSize = FileSize;
    }
    numberQueued = QueueSize / BufferSize;

    for (i = 0; i < numberQueued; i++) {

retryWrite:
        status = WriteFile(fileHandle,
                           buffer,
                           BufferSize,
                           &bytesTransferred,
                           &overlapped);

        if ( !status && GetLastError() != ERROR_IO_PENDING ) {
            if (GetLastError() == ERROR_INVALID_USER_BUFFER ||
                GetLastError() == ERROR_NOT_ENOUGH_QUOTA  ||
                GetLastError() == ERROR_WORKING_SET_QUOTA ||
                GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

                goto retryWrite;
            }
            printf("Error creating test file %x\n",GetLastError());
            return FALSE;
        }

        Log(2,".");
        overlapped.Offset += BufferSize;
    }

    for (i = 0; i < numberWrites; i++ ) {
        status = GetQueuedCompletionStatus(port,
                                           &bytesTransferred2,
                                           &key,
                                           &overlapped2,
                                           (DWORD)-1);
        if ( !status ) {
            printf("Error on completion during test file create %x\n",GetLastError());
            return FALSE;
        }

        if (numberQueued < numberWrites) {
            numberQueued++;

            for (;;) {
                status = WriteFile(fileHandle,
                                   buffer,
                                   BufferSize,
                                   &bytesTransferred,
                                   &overlapped);

                if ( !status && GetLastError() != ERROR_IO_PENDING ) {
                    if (GetLastError() == ERROR_INVALID_USER_BUFFER ||
                        GetLastError() == ERROR_NOT_ENOUGH_QUOTA  ||
                        GetLastError() == ERROR_WORKING_SET_QUOTA ||
                        GetLastError() == ERROR_NOT_ENOUGH_MEMORY) {

                        continue;
                    }
                    printf("Error creating test file %x\n",GetLastError());
                    return FALSE;
                }

                break;
            }

            Log(2,".");
            overlapped.Offset += BufferSize;
        }
    }

    Log(1,".. Complete.\n\n");

EndCreateTestFile:

    if(port != INVALID_HANDLE_VALUE) CloseHandle(port);
    if(fileHandle != INVALID_HANDLE_VALUE) CloseHandle(fileHandle);

    VirtualFree(buffer,
                DEFAULT_BUFFER_SIZE,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
ReadSequential(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    DOUBLE     iops;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;
    ULONG      totalIO = 0;


    printf("Starting Sequential Reads of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        if (!QueueSize || QueueSize > FileSize) {
            QueueSize = FileSize;
        }

        for (j = 0; j < QueueSize / BufferSize; j++) {
            do {

                status = ReadFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesRead,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in ReadFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            totalIO++;
            overlapped.Offset += BufferSize;
        }

        for (j = 0; j < FileSize / BufferSize; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesRead2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

            if (outstandingRequests < FileSize / BufferSize) {
                do {

                    status = ReadFile(file,
                                      buffer,
                                      BufferSize,
                                      &bytesRead,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_WORKING_SET_QUOTA ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            Log(0,"Error in ReadFile: %x\n",errCode);
                            VirtualFree(buffer,
                                        BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            return FALSE;
                        }

                    }

                } while (!status);

                totalIO++;
                outstandingRequests++;
                overlapped.Offset += BufferSize;
            }
        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        
        Log(1,"Iteration %2d -> %4.3f MB/S\n",
                Iterations - remaining,
                (FileSize / testTime)/(1024*1024));
    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    iops = totalIO / seconds;
    printf("\nAverage Throughput %4.3f IO/S %4.3f\n",
            thruPut/(1024*1024),
            iops);
        

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
ReadRandom(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    DOUBLE     iops;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesRead,
               bytesRead2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;
    ULONG      min = FileSize,max = 0;
    ULONG      totalIO = 0;


    printf("Starting Random Reads of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;
    srand((unsigned)time(NULL));

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      ReadOnly ? GENERIC_READ : (GENERIC_READ | GENERIC_WRITE),
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        if (!QueueSize || QueueSize > FileSize) {
            QueueSize = FileSize;
        }

        for (j = 0; j < QueueSize / BufferSize; j++) {
            do {

                status = ReadFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesRead,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in ReadFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            totalIO++;
            overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
            if (overlapped.Offset > max) {
                max = overlapped.Offset;
            }
            if (overlapped.Offset < min) {
                min = overlapped.Offset;
            }
        }

        for (j = 0; j < FileSize / BufferSize; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesRead2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

            if (outstandingRequests < FileSize / BufferSize) {
                do {

                    status = ReadFile(file,
                                      buffer,
                                      BufferSize,
                                      &bytesRead,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_WORKING_SET_QUOTA ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            Log(0,"Error in ReadFile: %x\n",errCode);
                            VirtualFree(buffer,
                                        BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            return FALSE;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                totalIO++;
                overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
                if (overlapped.Offset > max) {
                    max = overlapped.Offset;
                }
                if (overlapped.Offset < min) {
                    min = overlapped.Offset;
                }
            }
        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    iops = totalIO / seconds;
    thruPut = FileSize * Iterations / seconds;
    printf("\nAverage Throughput %4.3f MB/S. IO/S %4.3f\n",
            thruPut/(1024*1024),
            iops);
        
    Log(2,"Min = %Lu, Max = %Lu, FileSize = %Lu\n",min,max,FileSize);

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
WriteSequential(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    DOUBLE     iops;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWritten,
               bytesWritten2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;
    ULONG      totalIO = 0;


    if(ReadOnly) {
        printf("Can't run write tests on a read only file\n");
        return FALSE;
    }

    printf("Starting Sequential Writes of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        if (!QueueSize || QueueSize > FileSize) {
            QueueSize = FileSize;
        }

        for (j = 0; j < QueueSize / BufferSize; j++) {
            do {

                status = WriteFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesWritten,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in WriteFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            totalIO++;
            overlapped.Offset += BufferSize;
        }

        for (j = 0; j < FileSize / BufferSize; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesWritten2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

            if (outstandingRequests < FileSize / BufferSize) {
                do {

                    status = WriteFile(file,
                                      buffer,
                                      BufferSize,
                                      &bytesWritten,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_WORKING_SET_QUOTA ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            Log(0,"Error in WriteFile: %x\n",errCode);
                            VirtualFree(buffer,
                                        BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            return FALSE;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                totalIO++;
                overlapped.Offset += BufferSize;
            }
        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    iops = totalIO / seconds;
    printf("\nAverage Throughput %4.3f IO/S %4.3f\n",
            thruPut/(1024*1024),
            iops);
        
    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


BOOLEAN
WriteRandom(
    ULONG Iterations
    )
{
    ULONG      j,
               outstandingRequests,
               remaining = Iterations;
    ULONG      start,end;
    DOUBLE     testTime,thruPut = 0.0,seconds = 0;
    DOUBLE     iops;
    HANDLE     file,
               port;
    OVERLAPPED overlapped,
               *overlapped2;
    DWORD      bytesWritten,
               bytesWritten2,
               errCode,
               version;
    DWORD_PTR  completionKey;
    BOOL       status;
    PUCHAR     buffer;
    ULONG      min = FileSize,max = 0;
    ULONG      totalIO = 0;

    if(ReadOnly) {
        printf("Can't run write tests on a read only file\n");
        return FALSE;
    }

    printf("Starting Random Writes of %d Meg file, using %d K I/O size\n", FileSize / 1024*1024, BufferSize / 1024);

    version = GetVersion() >> 16;

    buffer = VirtualAlloc(NULL,
                          BufferSize + SectorSize - 1,
                          MEM_COMMIT | MEM_RESERVE,
                          PAGE_READWRITE);

    (ULONG_PTR)buffer &= ~((ULONG_PTR)SectorSize - 1);

    if ( !buffer ) {
        Log(0,"Error allocating buffer: %x\n",GetLastError());
        return FALSE;
    }

    file = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      0,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED | FILE_FLAG_NO_BUFFERING,
                      NULL );

    if ( file == INVALID_HANDLE_VALUE ) {
        Log(0,"Error opening Target file: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    port = CreateIoCompletionPort(file,
                                  NULL,
                                  (DWORD_PTR)file,
                                  0);
    if ( !port ) {
        Log(0,"Error creating completion port: %x\n",GetLastError());
        VirtualFree(buffer,
                    BufferSize + SectorSize - 1,
                    MEM_DECOMMIT);
        return FALSE;
    }

    while (remaining--) {

        start = GetTickCount();

        memset(&overlapped,0,sizeof(overlapped));

        outstandingRequests = 0;

        if (!QueueSize || QueueSize > FileSize) {
            QueueSize = FileSize;
        }

        for (j = 0; j < QueueSize / BufferSize; j++) {
            do {

                status = WriteFile(file,
                                  buffer,
                                  BufferSize,
                                  &bytesWritten,
                                  &overlapped);

                errCode = GetLastError();

                if (!status) {
                    if (errCode == ERROR_IO_PENDING) {
                        break;
                    } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                               errCode == ERROR_INVALID_USER_BUFFER ||
                               errCode == ERROR_WORKING_SET_QUOTA ||
                               errCode == ERROR_NOT_ENOUGH_MEMORY) {
                        //
                        // Allow this to retry.
                        //

                    } else {
                        Log(0,"Error in WriteFile: %x\n",errCode);
                        VirtualFree(buffer,
                                    BufferSize + SectorSize - 1,
                                    MEM_DECOMMIT);
                        return FALSE;
                    }

                }

            } while (!status);

            outstandingRequests++;
            totalIO++;
            overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
            if (overlapped.Offset > max) {
                max = overlapped.Offset;
            }
            if (overlapped.Offset < min) {
                min = overlapped.Offset;
            }
        }

        for (j = 0; j < FileSize / BufferSize; j++) {

            status = GetQueuedCompletionStatus(port,
                                               &bytesWritten2,
                                               &completionKey,
                                               &overlapped2,
                                               (DWORD)-1);

            if (!status) {
                Log(0,"GetQueuedCompletionStatus error: %x\n",GetLastError());
                VirtualFree(buffer,
                            BufferSize + SectorSize - 1,
                            MEM_DECOMMIT);
                return FALSE;
            }

            if (outstandingRequests < FileSize / BufferSize) {
                do {

                    status = WriteFile(file,
                                      buffer,
                                      BufferSize,
                                      &bytesWritten,
                                      &overlapped);

                    errCode = GetLastError();

                    if (!status) {
                        if (errCode == ERROR_IO_PENDING) {
                            break;
                        } else if (errCode == ERROR_NOT_ENOUGH_QUOTA ||
                                   errCode == ERROR_INVALID_USER_BUFFER ||
                                   errCode == ERROR_WORKING_SET_QUOTA ||
                                   errCode == ERROR_NOT_ENOUGH_MEMORY) {
                            //
                            // Allow this to retry.
                            //

                        } else {
                            Log(0,"Error in WriteFile: %x\n",errCode);
                            VirtualFree(buffer,
                                        BufferSize + SectorSize - 1,
                                        MEM_DECOMMIT);
                            return FALSE;
                        }

                    }

                } while (!status);

                outstandingRequests++;
                totalIO++;
                overlapped.Offset = GetRandomOffset(0,FileSize - BufferSize);
                if (overlapped.Offset > max) {
                    max = overlapped.Offset;
                }
                if (overlapped.Offset < min) {
                    min = overlapped.Offset;
                }
            }
        }

        end = GetTickCount();
        testTime = end - start;
        testTime /= 1000.0;
        seconds += testTime;
        Log(1,"Iteration %2d -> %4.3f MB/S\n",Iterations - remaining,(FileSize / testTime)/(1024*1024));

    }

    CloseHandle(port);
    CloseHandle(file);

    thruPut = FileSize * Iterations / seconds;
    iops = totalIO / seconds;
    printf("\nAverage Throughput %4.3f IO/S %4.3f\n",
            thruPut/(1024*1024),
            iops);
        
    Log(2,"Min = %Lu, Max = %Lu, FileSize = %Lu\n",min,max,FileSize);

    VirtualFree(buffer,
                BufferSize + SectorSize - 1,
                MEM_DECOMMIT);

    return TRUE;
}


ULONG
GetRandomOffset(
    ULONG    min,
    ULONG    max
    )
{

    INT base = rand();
    ULONG retval = ((max - min) / RAND_MAX) * base;
    retval += SectorSize - 1;
    retval &= ~(SectorSize - 1);
    if (retval < min) {
        return min;
    } else if (retval > max ){
        return max & ~(SectorSize - 1);
    } else{
        return retval;
    }

}

BOOLEAN
ParseCmdLine(
    INT Argc,
    CHAR *Argv[]
    )
{

    INT i;
    CHAR *switches = " ,-";
    CHAR swtch,*value,*str;
    BOOLEAN gotSwitch = FALSE;


    if (Argc <= 1) {

        //
        // Using defaults
        //

        return TRUE;
    }

    for (i = 1; i < Argc; i++) {
        str = Argv[i];
        value = strtok(str, switches);
        if (gotSwitch) {
            if (!ValidateOption(swtch,value)) {
                Usage();
                return FALSE;
            } else {
                gotSwitch = FALSE;
            }
        } else {
            gotSwitch = TRUE;
            swtch = value[0];
            if (value[1] || swtch == '?') {
                Usage();
                return FALSE;
            }
        }
    }
    if (gotSwitch) {

        Usage();
        return FALSE;
    } else {
        return TRUE;
    }

}

BOOLEAN
ValidateOption(
    CHAR Switch,
    CHAR *Value
    )
{
    Switch = (CHAR)toupper(Switch);
    switch (Switch) {

        case 'F':

            VerifyFileName(Value);
            strcpy(FileName,Value);
            break;

        case 'T':
            if (_stricmp(Value,"READ")==0) {
                Test = READ;
            } else if (_stricmp(Value,"WRITE")==0) {
                Test = WRITE;
            } else {
                return FALSE;
            }

            break;

        case 'A':

            if (_strnicmp(Value,"SEQ",3)==0) {
                Access = SEQ;
            } else if (_strnicmp(Value,"RAND",4)==0) {
                Access = RAND;
            } else {
                return FALSE;
            }

            break;

        case 'B':
            BufferSize = atol(Value);

            //
            // TODO:Adjust buffersize to multiple of a sector and #of K.
            //

            BufferSize *= 1024;
            break;

        case 'S':

            FileSize = atol(Value);

            //
            // TODO: Adjust filesize to multiple of buffersize and #of Meg.
            //

            FileSize *= 1024*1024;
            break;

        case 'Q':
            QueueSize = atol(Value);
            QueueSize *= 1024*1024;
            break;

        case 'V':

            Verbose = atol(Value);
            break;

        case 'I':

            Iterations = atol(Value);
            break;

        case 'R':

            if(tolower(Value[0]) == 'y') {
                ReuseFile = TRUE;
            } else {
                ReuseFile = FALSE;
            }

            break;

        case 'O':

            if(tolower(Value[0]) == 'y') {
                ReadOnly = TRUE;
            } else {
                ReadOnly = FALSE;
            }

            break;

        default:
            return FALSE;
    }
    return TRUE;
}

VOID
Usage(
    VOID
    )
{

    fprintf(stderr,"usage: YAPT (Yet another performance tool)\n"
            "               -f [filename]\n"
            "               -t [Test:Read,Write]\n"
            "               -a [Access Mode:Seq or Random]\n"
            "               -b [buffer size in KB]\n"
            "               -s [filesize]\n"
            "               -i [Iterations]\n"
            "               -v [Verbosity: 0-2]\n"
            "               -r [Reuse test file: yes, no]\n"
            "               -o [Read Only: yes, no]\n"
            "               -q [queuesize in MB]\n"
           );
}

VOID
__cdecl
Log(
    ULONG LogLevel,
    PCHAR String,
    ...
    )
{

    CHAR Buffer[256];

    va_list argp;
    va_start(argp, String);

    if (LogLevel <= Verbose) {
        vsprintf(Buffer, String, argp);
        printf("%s",Buffer);
    }

    va_end(argp);
}

DWORD
YaptSetFileCompression(
    IN HANDLE FileHandle,
    IN USHORT CompressionFormat
    )

{
    DWORD bytesReturned;

    assert(FileHandle != INVALID_HANDLE_VALUE);

    if(!DeviceIoControl(
            FileHandle,
            FSCTL_SET_COMPRESSION,
            &CompressionFormat,
            sizeof(CompressionFormat),
            NULL,
            0,
            &bytesReturned,
            NULL)) {

    }

    return GetLastError();
}

VOID
VerifyFileName(
    IN CHAR *FileName
    )

{
    CHAR input[32];

    if(Yes) return;

    if(((FileName[0] == '\\') || (FileName[0] == '/')) &&
       ((FileName[1] == '\\') || (FileName[1] == '/')) &&
       ((FileName[2] == '.')  || (FileName[2] == '?')) &&
       ((FileName[3] == '\\') || (FileName[3] == '/'))) {

        printf("\n\t%s looks like a raw device\n"
               "\tdo you want to continue?  ", FileName);

        fflush(stdout);

        if(fgets(input, 32, stdin) == NULL) {

            printf("\nQuitting\n");
            exit(-1);
        }

        if(tolower(input[0]) != 'y') {

            printf("\nNegative response - quitting\n");
            exit(-1);
        }

    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\xerox\xerox.c ===
/****************************************************************************

   PROGRAM: xerox.c

   PURPOSE: Copies keyboard input to multiple target windows.

****************************************************************************/

#include "xerox.h"
#include "string.h"
#include "group.h"
#include "pos.h"
#include "stdio.h"


#define cmPaste              0xFFF1
#define VK_V                 0x56      //Virtual Key V
#define KEY_IS_DOWN          0x8000

// #define TESTING

static char pszMainWindowClass[] = "Main Window Class";
char szTitle[] = "Xerox";

HANDLE hInst;
HACCEL hAccel;

HWND    hwndMain;
HWND    hwndList;   // handle of listbox containing targets.


BOOL    InitApplication(HANDLE);
BOOL    InitInstance(HANDLE, INT);

INT_PTR APIENTRY MainWndProc(HWND, UINT, WPARAM, LPARAM);
BOOL    PostToTargets(HWND, UINT, WPARAM, LPARAM);

INT_PTR APIENTRY WindowListDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL    WindowListDlgInit(HWND);
BOOL    CALLBACK WindowListWindowEnum(HWND, LPARAM);
INT     WindowListDlgEnd(HWND, HWND*);

INT_PTR APIENTRY AboutDlgProc(HWND, UINT, WPARAM, LPARAM);
INT_PTR APIENTRY GroupAddDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GroupDeleteDlgProc(HWND hDlg, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY GroupSelectDlgProc(HWND hDlg, UINT msg, WPARAM wParam,LPARAM lParam);


/****************************************************************************

   FUNCTION: WinMain(HANDLE, HANDLE, LPSTR, int)

   PURPOSE: calls initialization function, processes message loop

****************************************************************************/

int
WINAPI
WinMain(
    HINSTANCE hInstance,
    HINSTANCE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
    )
{
    MSG Message;

    if (!hPrevInstance) {
        if (!InitApplication(hInstance)) {
            return (FALSE);
        }
    }

    if (!InitInstance(hInstance, nCmdShow)) {
        return (FALSE);
    }

    while (GetMessage(&Message, NULL, 0, 0)) {
        if (!TranslateAccelerator(hwndMain, hAccel, &Message)) {
            TranslateMessage(&Message);
            DispatchMessage(&Message);
        }
    }

    SaveGroups();
    FreeGroups();
    return ((int)Message.wParam);
}


/****************************************************************************

    FUNCTION: InitApplication(HANDLE)

    PURPOSE: Initializes window data and registers window class

****************************************************************************/

BOOL InitApplication(HANDLE hInstance)
{
    WNDCLASS  wc;


    // Register the main window class

    wc.style = 0;
    wc.lpfnWndProc = MainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPICON));
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName =  (LPSTR)IDM_MAINMENU;
    wc.lpszClassName = pszMainWindowClass;

    return (RegisterClass(&wc));
}


/****************************************************************************

    FUNCTION:  InitInstance(HANDLE, int)

    PURPOSE:  Saves instance handle and creates main window

****************************************************************************/

BOOL InitInstance(HANDLE hInstance, INT nCmdShow)
{
    RECT rc;
    BOOL fLastPosSet;

    LoadGroups();

    // Store instance in global
    hInst = hInstance;

    hAccel = LoadAccelerators(hInst, MAKEINTRESOURCE(IDR_ACCEL));
    fLastPosSet = GetLastPosition(&rc);

    // Create the main window
    hwndMain = CreateWindow(
            pszMainWindowClass,
            szTitle,
            WS_OVERLAPPEDWINDOW,
            fLastPosSet ? rc.left : CW_USEDEFAULT,
            fLastPosSet ? rc.top : CW_USEDEFAULT,
            fLastPosSet ? rc.right - rc.left : CW_USEDEFAULT,
            fLastPosSet ? rc.bottom - rc.top : CW_USEDEFAULT,
            NULL,
            NULL,
            hInstance,
            NULL);

    if (hwndMain == NULL) {
        return(FALSE);
    }

    if (GetCurrentGroup() != NULL) {
        SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
    }

    ShowWindow(hwndMain, nCmdShow);
    UpdateWindow(hwndMain);

    return (TRUE);
}


/****************************************************************************

    FUNCTION: MainWndProc(HWND, UINT, WPARAM, LONG)

    PURPOSE:  Processes messages for main window

    COMMENTS:

****************************************************************************/

INT_PTR
APIENTRY
MainWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HMENU hMenu;
    BOOL Result;
    RECT rcWindow;
    WINDOWPLACEMENT wpWndPlacement;
    HWND hwndAdd, hwndDelete;
    CHAR string[MAX_STRING_BYTES];
    INT  ItemDelete;

    INT     TargetCount;
    INT     Index;
    HWND    hwndTarget;
    WINDOWPLACEMENT wndpl;
    INT  NumberOfItems = 0;
    INT  counter;
    HWND WindowHandleList[MAX_WINDOWS];
    INT  SelectedWindows[MAX_WINDOWS];

    switch (message) {

    case WM_CREATE:

        GetWindowRect(hwnd, &rcWindow);

        if (GetCurrentGroup() != NULL) {
            wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
            SetWindowText(hwnd, string);
        }

        hwndList = CreateWindow(
                "LISTBOX",
                NULL,                   // Title
                WS_CHILD | WS_VISIBLE | LBS_MULTIPLESEL,
                0, 0,                   // x,y
                rcWindow.right - rcWindow.left,
                rcWindow.bottom - rcWindow.top,
                hwnd,                   // owner
                NULL,                   // menu
                hInst,
                NULL);

        //
        // Attach all threads to our input state
        //
#ifndef TESTING
        Result = AttachThreadInput(
                    0,
                    GetCurrentThreadId(),
                    TRUE // Attaching
                    );
        if (!Result) {
        }
#endif // !TESTING
        return(0); // Continue creating window

    case WM_INITMENU:
        hMenu = (HMENU)wParam;
        EnableMenuItem(hMenu, IDM_GROUPRSTWIN, GetCurrentGroup() != NULL ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPMINWIN, GetCurrentGroup() != NULL ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPDELETE, CountGroups() ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_GROUPSELECT, CountGroups() ? MF_ENABLED : MF_GRAYED);
        EnableMenuItem(hMenu, IDM_TARGETDELETE,
                (SendMessage(hwndList, LB_GETCURSEL, 0, 0) != LB_ERR) ?
                MF_ENABLED : MF_GRAYED);
        break;

    case WM_SIZE:

        //
        // Keep the listbox in sync with the main window
        //

        MoveWindow(hwndList, 0, 0, LOWORD(lParam), HIWORD(lParam), TRUE);
        return(0);


    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        /*
         *  Restore the windows of the current group.  Assumes that everything
         *  can be restored.
         */
        case IDM_GROUPRSTWIN:

            TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
            if (TargetCount == LB_ERR) {
                break;
            }

            for (Index = 0; Index < TargetCount; Index ++) {
                hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);

                ShowWindow(hwndTarget, SW_RESTORE);
            }

            SetFocus(hwndMain);
            break;

        /*
         *  Minimize the windows of the current group.  Assumes that everything
         *  can be minimized.
         */
        case IDM_GROUPMINWIN:

            TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
            if (TargetCount == LB_ERR) {
                break;
            }

            for (Index = 0; Index < TargetCount; Index ++) {
                hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);

                ShowWindow(hwndTarget, SW_MINIMIZE);
            }
            break;

        case IDM_TARGETADD:

            hwndAdd = (HWND)DialogBox(hInst,(LPSTR)IDD_WINDOWLIST, hwnd, WindowListDlgProc);

            SetNoCurrentGroup(hwnd, szTitle);
            break;

        case IDM_TARGETDELETE:

            NumberOfItems = (INT)SendMessage(hwndList, LB_GETSELCOUNT, 0, 0);

            if (SendMessage(hwndList, LB_GETSELITEMS, (WPARAM)NumberOfItems, (LPARAM)SelectedWindows) != NumberOfItems)
            {
                break;
            }

            if (NumberOfItems > 0)
            {
                counter = NumberOfItems;
                while ( counter-- > 0) {

                    SendMessage(hwndList, LB_DELETESTRING, (WPARAM)WindowHandleList[counter], 0);
                }
            }
            SendMessage(hwndList, LB_SETSEL, 1, (LPARAM)(max(0, WindowHandleList[0] - 1)));
            SetNoCurrentGroup(hwnd, szTitle);
            break;

        case IDM_GROUPADD:
            //
            // Defines a 'group' of processes to equal the current target list
            //
            if (((LPSTR)DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPADD), hwnd, GroupAddDlgProc)) != NULL) {

                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_GROUPDELETE:
            DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPDELETE), hwnd, GroupDeleteDlgProc);

            if (GetCurrentGroup() == NULL) {
                SetWindowText(hwnd, szTitle);
            } else {
                SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_GROUPSELECT:
            if (DialogBox(hInst, MAKEINTRESOURCE(IDD_GROUPSELECT), hwnd, GroupSelectDlgProc)) {

                wsprintf(string, "%s - (%s)", szTitle, GetCurrentGroup());
                SetWindowText(hwnd, string);
            }
            break;

        case IDM_REFRESHITEMS:
            SelectGroupDefinition(GetCurrentGroup(), hwndList, FALSE);
            break;

        case IDM_ABOUT:
            DialogBox(hInst,(LPSTR)IDD_ABOUT, hwnd, AboutDlgProc);
            break;

        default:
            break;
        }
        break;


    case WM_DESTROY:

        //
        // Detach all threads from our input state
        //
#ifndef TESTING
        Result = AttachThreadInput(
                    0,
                    GetCurrentThreadId(),
                    FALSE // Detaching
                    );
        if (!Result) {
        }
#endif // !TESTING
        GetWindowPlacement( hwndMain, &wpWndPlacement );
        SetLastPosition(&wpWndPlacement.rcNormalPosition);
        PostQuitMessage(0);
        break;

    case WM_PARENTNOTIFY:

       if (LOWORD(wParam) == WM_RBUTTONDOWN) {
         // send cmPaste message.
         PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
       }
       break;

    case WM_NCRBUTTONDOWN:

       // send cmPaste message.
       PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
       break;


    case WM_KEYDOWN:

       //
       // Forward key messages to all targets
       //
       switch (wParam) {
       case VK_INSERT:
          if (GetKeyState(VK_SHIFT) & KEY_IS_DOWN) {
             PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
             return (DefWindowProc(hwnd, message, wParam, lParam));
          }
          break;

       case VK_V:
          if (GetKeyState(VK_CONTROL) & KEY_IS_DOWN) {
             PostToTargets(hwndList,WM_SYSCOMMAND,cmPaste,lParam);
             return (DefWindowProc(hwnd, message, wParam, lParam));
          }
          break;

       }


    case WM_KEYUP:


        //
        // Forward key messages to all targets
        //
#ifndef TESTING
        PostToTargets(hwndList, message, wParam, lParam);
#endif // !TESTING
        // drop through to default processing...

    default:
        return(DefWindowProc(hwnd, message, wParam, lParam));
    }

    return 0;
}


/****************************************************************************

    FUNCTION: PostToTargets(HWND)

    PURPOSE:  Posts a message to all target windows

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
PostToTargets(
    HWND    hwndList,
    UINT    message,
    WPARAM  wparam,
    LPARAM  lparam
    )
{
    INT     TargetCount;
    INT     Index;
    HWND    hwndTarget;
    BOOL    Restarted = FALSE;

RestartPost:
    TargetCount = (INT)SendMessage(hwndList, LB_GETCOUNT, 0, 0);
    if (TargetCount == LB_ERR) {
        return(FALSE);
    }

    for (Index = 0; Index < TargetCount; Index ++) {
        hwndTarget = (HWND)SendMessage(hwndList, LB_GETITEMDATA, Index, 0);
        if ((hwndTarget != INVALID_HANDLE_VALUE) &&
             !PostMessage(hwndTarget, message, wparam, lparam)) {
            if (Restarted) {
                return(FALSE);
            }
            if (!SelectGroupDefinition(GetCurrentGroup(), hwndList, TRUE)) {
                return(FALSE);
            }
            Restarted = TRUE;
            goto RestartPost;
        }
    }

    return(TRUE);
}



/****************************************************************************

    FUNCTION: WindowListDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages

****************************************************************************/

INT_PTR
APIENTRY
WindowListDlgProc(
    HWND   hDlg,
    UINT   message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    INT  NumberOfWindows = 0;
    INT  counter = 0;
    HWND WindowHandleList[MAX_WINDOWS];
    CHAR string[MAX_STRING_BYTES];

    switch (message) {

    case WM_INITDIALOG:

        if (!WindowListDlgInit(hDlg)) {
            // Failed to initialize dialog, get out
            EndDialog(hDlg, FALSE);
        }

        return (TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDLB_WINDOWLIST:
            switch (HIWORD(wParam)) {

            case LBN_DBLCLK:
                break;  // drop through

            default:
                return(0);
            }

            // drop through on double click ...

        case IDOK:
            NumberOfWindows = WindowListDlgEnd(hDlg, WindowHandleList);

            if (NumberOfWindows > 0)
            {
                while ( counter++ < NumberOfWindows) {

                    //
                    // If the window is already in our list, don't add it
                    //
                    if (FindLBData(hwndList, (DWORD_PTR)WindowHandleList[counter - 1]) >= 0) {
                        continue;
                    }

                    //
                    // Don't add ourselves to the list
                    //
                    if (WindowHandleList[counter - 1] == GetParent(hDlg)) {
                        continue;
                    }

                    //
                    // Add the window to the list
                    //
                    if (GetWindowText(WindowHandleList[counter - 1], string, sizeof(string)) > 0) {

                        if (AddLBItemhwnd(hwndList, string, (LONG_PTR)WindowHandleList[counter - 1]) < 0) {
                        }
                    }
                }
            }

            // We're done, drop through to enddialog...

        case IDCANCEL:

            EndDialog(hDlg, FALSE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


/****************************************************************************

    FUNCTION: WindowListDlgInit(HWND)

    PURPOSE:  Initialise the window list dialog

    RETURNS:  TRUE on success, FALSE on failure

****************************************************************************/
BOOL
WindowListDlgInit(
    HWND    hDlg
    )
{
    // Fill the list box with top-level windows and their handles
    EnumWindows(WindowListWindowEnum, (LONG_PTR)hDlg);

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowListWindowEnum

    PURPOSE:  Window enumeration call-back function.
              Adds each window to the window list-box

    RETURNS:  TRUE to continue enumeration, FALSE to stop.

****************************************************************************/
BOOL
CALLBACK
WindowListWindowEnum(
    HWND    hwnd,
    LPARAM  lParam
    )
{
    HWND    hDlg = (HWND)lParam;
    CHAR    string[MAX_STRING_BYTES];

    //
    // Don't add ourselves to the list
    //

    if (hwnd == hDlg) {
        return(TRUE);
    }

    //
    // Don't add our main window to the list
    //

    if (hwnd == hwndMain) {
        return(TRUE);
    }

    if (GetWindowText(hwnd, string, MAX_STRING_BYTES) != 0) {

        // This window has a caption, so add it to the list-box

        AddLBItem(hDlg, IDLB_WINDOWLIST, string, (LONG_PTR)hwnd);
    }

    return(TRUE);
}


/****************************************************************************

    FUNCTION: WindowListDlgEnd(HWND, *HWND)

    PURPOSE:  Cleans up after window list dialog

    RETURNS:  Number of window handles the user has selected or NULL

****************************************************************************/
INT
WindowListDlgEnd(
    HWND    hDlg,
    HWND   *WindowList
    )
{
    HWND    hwndListBox = GetDlgItem(hDlg, IDLB_WINDOWLIST);
    HWND    hwndEdit;
    INT     iItem, NumberOfItems;
    INT     SelectedWindows[MAX_WINDOWS];

    NumberOfItems = (INT)SendMessage(hwndListBox, LB_GETSELCOUNT, 0, 0);

    if (SendMessage(hwndListBox, LB_GETSELITEMS, (WPARAM)NumberOfItems, (LPARAM)SelectedWindows) != NumberOfItems)
    {
        return 0;
    }

    iItem = 0;
    while (iItem++ < NumberOfItems)
    {
        // Read selection from list-box and get its hwnd

        WindowList[iItem-1] = (HWND)SendMessage(hwndListBox, LB_GETITEMDATA, SelectedWindows[iItem - 1], 0);
    }
    return (NumberOfItems);
}



/****************************************************************************

    FUNCTION: AboutDlgProc(HWND, unsigned, WORD, LONG)

    PURPOSE:  Processes messages for About dialog

****************************************************************************/

INT_PTR
APIENTRY
AboutDlgProc(
    HWND    hDlg,
    UINT    message,
    WPARAM  wParam,
    LPARAM  lParam
    )
{

    switch (message) {

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:

            // we're done, drop through to quit dialog....

        case IDCANCEL:
            EndDialog(hDlg, TRUE);
            return TRUE;
            break;

        default:
            // We didn't process this message
            return FALSE;
            break;
        }
        break;

    default:
        // We didn't process this message
        return FALSE;

    }

    // We processed the message
    return TRUE;

    DBG_UNREFERENCED_PARAMETER(lParam);
}


INT_PTR
APIENTRY
GroupAddDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if (GetDlgItemText(hDlg, IDEF_GROUPNAME, szName, sizeof(szName)) > 0) {
                if (!AddGroupDefinition(szName, hwndList)) {
                    EndDialog(hDlg, 0);
                }
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)GetCurrentGroup());
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);

        case IDCB_GROUPLIST:
            switch (HIWORD(wParam)) {
            case CBN_SELCHANGE:
                item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0);
                if (item != CB_ERR) {
                    SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                    SetDlgItemText(hDlg, IDEF_GROUPNAME, szName);
                }
                return(0);
            }
            break;
        }
    }
    return(0);
}



INT_PTR
APIENTRY
GroupDeleteDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if ((item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0)) != CB_ERR) {
                SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                DeleteGroupDefinition(szName);
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)szName);
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);
        }
    }
    return(0);
}


INT_PTR
APIENTRY
GroupSelectDlgProc(
    HWND hDlg,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    char szName[MAX_STRING_BYTES];
    int item;

    switch (msg) {
    case WM_INITDIALOG:
        GroupListInit(GetDlgItem(hDlg, IDCB_GROUPLIST), TRUE);
        if (GetCurrentGroup() != NULL) {
            item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_FINDSTRING, -1, (LPARAM)(LPSTR)GetCurrentGroup());
            SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, item, 0);
        } else {
            SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_SETCURSEL, 0, 0);
        }
        return(TRUE);

    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            if ((item = (int)SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETCURSEL, 0, 0)) != CB_ERR) {
                SendDlgItemMessage(hDlg, IDCB_GROUPLIST, CB_GETLBTEXT, item, (LPARAM)szName);
                SelectGroupDefinition(szName, hwndList, FALSE);
            } else {
                MessageBeep(0);
                return(0);
            }
            EndDialog(hDlg, (INT_PTR)szName);
            return(0);

        case IDCANCEL:
            EndDialog(hDlg, 0);
            return(0);
        }
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\config.h ===
/* configuration for local MSDOS */

#ifndef MSDOS
#define MSDOS	    1
#endif

#ifndef MSC
#define MSC	    1
#endif

#ifndef LARGE
#define LARGE	    1
#endif


// #ifndef DEBUG
// #define DEBUG		0
// #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ync\ync.c ===
#include "string.h"

#include <stdio.h>
#include <conio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>

/*  YNC is a Yes No Cancel program
 *  ===============================================================================
 *  Usage: ync [/c choices] text ...
 *
 *  "choices" is a string of characters, default "ync".
 *  YNC echos its text parameters and the text " [choices]" and waits for the
 *  user to type one of the choices.  When one of the choices is typed, the
 *  index of the choice is returned.
 *
 *  Rtns -1 if no parameters specified or /c but no choices or CONTROL-C input.
 *
 *  Beeps on all other input.
 *
 *  Good for use in make batch files.cd \lib
 *
 *      ync your query?
 *      if errorlevel 2 goto cancel
 *      if errorlevel 1 goto no
 *      :yes
 *      ...
 *      goto continue
 *      :no
 *      ...
 *      goto continue
 *      :cancel
 *      ...
 *      :continue
 *
 *  or
 *      ync /c acr abort cancel, retry
 *      ync /c acr "abort cancel, retry"
 */

#define BEL   0x07
#define LF    0x0a
#define CR    0x0d
#define CTRLC 0x03
char *strYNC = "ync";

// Forward Function Declarations...
void chkusage( int );

void chkusage(argc)
int argc;
{
    if (!argc) {
        printf("Usage: ync [/c choices] text ...\n");
        exit (-1);
        }
}

__cdecl main(argc, argv)
int argc;
char *argv[];
{
    char ch;
    char *s;
    char *pChoices = strYNC;

    ConvertAppToOem( argc, argv );
    SHIFT(argc, argv)
    chkusage(argc);
    while (argc) {
        s = argv[0];
        if (fSwitChr(*s++)) {
            if (*s == 'c' || *s == 'C') {
                SHIFT(argc, argv);
                chkusage(argc);
                pChoices = argv[0];
                }
            else
                printf("ync: invalid switch - %s\n", argv[0]);
            }
        else {
            _cputs(*argv);
            _putch(' ');
            }
        SHIFT(argc, argv);
    }

    _putch('[');
    _cputs(pChoices);
    _putch(']');
    while (!(s = strchr(pChoices, ch = (char)_getch()))) {
        if (ch == CTRLC) {
            exit(-1);
        } else {
            _putch(BEL);
        }
    }

    _putch(ch);
    _putch(LF);
    _putch(CR);

    return( (int)(s - pChoices) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\dir.h ===
/* dir.h - structure of a directory entry */

struct dirType {
    char	name[8];		/* 00  packed FCB filename	     */
    char	ext[3]; 		/* 08  packed FCB extention	     */
    char	attr;			/* 0B  attribute		     */
    char	pad[10];		/* 0C  reserved space		     */
    unsigned	time;			/* 16  time of last modification     */
    unsigned	date;			/* 18  date of last modification     */
    unsigned	clusFirst;		/* 1A  first cluster on disk	     */
    long	size;			/* 1C  file size		     */
};


/* the following is what gets returned on FCB search calls */

struct srchdirType {
    char	drv;			/* 00  drive			     */
    char	name[8];		/* 01  packed FCB filename	     */
    char	ext[3]; 		/* 09  packed FCB extention	     */
    char	attr;			/* 0C  attribute		     */
    char	pad[10];		/* 0D  reserved space		     */
    unsigned	time;			/* 17  time of last modification     */
    unsigned	date;			/* 19  date of last modification     */
    unsigned	clusFirst;		/* 1B  first cluster on disk	     */
    long	size;			/* 1D  file size		     */
};


struct esrchdirType {
    char	eflg;			/* 00  must be 0xFF for extended     */
    char	pad1[5];		/* 01  padding			     */
    char	sattr;			/* 06  search attribute 	     */
    char	drv;			/* 07  drive			     */
    char	name[8];		/* 08  packed FCB filename	     */
    char	ext[3]; 		/* 10  packed FCB extention	     */
    char	attr;			/* 13  attribute		     */
    char	pad[10];		/* 14  reserved space		     */
    unsigned	time;			/* 1E  time of last modification     */
    unsigned	date;			/* 20  date of last modification     */
    unsigned	clusFirst;		/* 22  first cluster on disk	     */
    long	size;			/* 24  file size		     */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\zoomin\zoomin.h ===
/****************************************************************************/
/*                                                                          */
/*                         Microsoft Confidential                           */
/*                                                                          */
/*                 Copyright (c) Microsoft Corp.  1987-1992                 */
/*                           All Rights Reserved                            */
/*                                                                          */
/****************************************************************************/
/****************************** Module Header *******************************
* Module Name: zoomin.h
*
* Main header file for the ZoomIn utility.
*
* History:
*
****************************************************************************/

#include <windows.h>

#define MIN_ZOOM    1
#define MAX_ZOOM    32

#define FASTDELTA   8

#define BOUND(x,min,max) ((x) < (min) ? (min) : ((x) > (max) ? (max) : (x)))

#define MM10PERINCH 254                     // Tenths of a millimeter per inch.

#define NPAL        256                     // Number of palette entries.


#define MENU_HELP_ABOUT             100

#define MENU_EDIT_COPY              200
#define MENU_EDIT_REFRESH           201

#define MENU_OPTIONS_REFRESHRATE    300
#define MENU_OPTIONS_SHOWGRID       301


#define DID_ABOUT                   1000

#define DID_REFRESHRATE             1100
#define DID_REFRESHRATEENABLE       1101
#define DID_REFRESHRATEINTERVAL     1102


#define IDMENU_ZOOMIN               2000


#define IDACCEL_ZOOMIN              3000


#define IDTIMER_ZOOMIN              4000


BOOL InitInstance(HINSTANCE hInst, INT cmdShow);
HPALETTE CreatePhysicalPalette(VOID);
INT_PTR APIENTRY AppWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
VOID CalcZoomedSize(VOID);
VOID DoTheZoomIn(HDC hdc);
VOID MoveView(INT nDirectionCode, BOOL fFast, BOOL fPeg);
VOID DrawZoomRect(VOID);
VOID EnableRefresh(BOOL fEnable);
VOID CopyToClipboard(VOID);
INT_PTR APIENTRY AboutDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY RefreshRateDlgProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\cvtoem.h ===
// cvtoem.h header file.

void
ConvertAppToOem( unsigned argc, char* argv[] );

char*
getenvOem( char* p );

int
putenvOem( char* p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\fcb.h ===
/* fcb.h - structure of a 1.0 fcb */

struct EFCBType {
    char	eflg;			/* 00  must be 0xFF for extended FCB */
    char	pad[5]; 		/* 01  padding			     */
    char	attr;			/* 06  enabling attribute	     */
    char	drv;			/* 07  drive code		     */
    char	nam[8]; 		/* 08  file name		     */
    char	ext[3]; 		/* 10  file name extension	     */
    int 	cb;			/* 13  current block number	     */
    int 	lrs;			/* 15  logical record size	     */
    long	lfs;			/* 17  logical file size	     */
    unsigned	dat;			/* 1B  create/change date	     */
    unsigned	tim;			/* 1D  create/change time	     */
    char	sys[8]; 		/* 1F  reserved 		     */
    unsigned char cr;			/* 27  current record number	     */
    long	rec;			/* 28  random record number	     */
};

struct FCB {
    char	drv;			/* 00  drive code		     */
    char	nam[8]; 		/* 01  file name		     */
    char	ext[3]; 		/* 09  file name extension	     */
    int 	cb;			/* 0C  current block number	     */
    int 	lrs;			/* 0E  logical record size	     */
    long	lfs;			/* 10  logical file size	     */
    unsigned	dat;			/* 14  create/change date	     */
    unsigned	tim;			/* 16  create/change time	     */
    char	sys[8]; 		/* 18  reserved 		     */
    unsigned char cr;			/* 20  current record number	     */
    long	rec;			/* 21  random record number	     */
};

#define FCBSIZ sizeof(struct FCB)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\newstat.h ===
#if _OS2_20_ == 0
#include <sys\stat.h>

#else
#pragma error( "Using newstat.h" )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\exe.h ===
/* exe.h - structure of an exe file header */
/* Include some new .exe file info from \link\newexe.h */

#define EMAGIC          0x5A4D          /* Old magic number */
#define ENEWEXE         sizeof(struct exe_hdr)
                                        /* Value of E_LFARLC for new .EXEs */
#define ENEWHDR         0x003C          /* Offset in old hdr. of ptr. to new */
#define ERESWDS         0x0010          /* No. of reserved words (OLD) */
#define ERES1WDS        0x0004          /* No. of reserved words in e_res */
#define ERES2WDS        0x000A          /* No. of reserved words in e_res2 */
#define ECP             0x0004          /* Offset in struct of E_CP */
#define ECBLP           0x0002          /* Offset in struct of E_CBLP */
#define EMINALLOC       0x000A          /* Offset in struct of E_MINALLOC */

#define E_MAGIC(x)      (x).e_magic
#define E_CBLP(x)       (x).e_cblp
#define E_CP(x)         (x).e_cp
#define E_CRLC(x)       (x).e_crlc
#define E_CPARHDR(x)    (x).e_cparhdr
#define E_MINALLOC(x)   (x).e_minalloc
#define E_MAXALLOC(x)   (x).e_maxalloc
#define E_SS(x)         (x).e_ss
#define E_SP(x)         (x).e_sp
#define E_CSUM(x)       (x).e_csum
#define E_IP(x)         (x).e_ip
#define E_CS(x)         (x).e_cs
#define E_LFARLC(x)     (x).e_lfarlc
#define E_OVNO(x)       (x).e_ovno
#define E_RES(x)        (x).e_res
#define E_OEMID(x)      (x).e_oemid
#define E_OEMINFO(x)    (x).e_oeminfo
#define E_RES2(x)       (x).e_res2
#define E_LFANEW(x)     (x).e_lfanew

#define NEMAGIC         0x454E          /* New magic number */
#define NTMAGIC         0x4550          /* NT magic number */
#define NERESBYTES      8               /* Eight bytes reserved (now) */
#define NECRC           8               /* Offset into new header of NE_CRC */
#define NEDEFSTUBMSG	0x4E	    /* Offset into file of default stub msg */

#define NE_MAGIC(x)     (x).ne_magic
#define NE_VER(x)       (x).ne_ver
#define NE_REV(x)       (x).ne_rev
#define NE_ENTTAB(x)    (x).ne_enttab
#define NE_CBENTTAB(x)  (x).ne_cbenttab
#define NE_CRC(x)       (x).ne_crc
#define NE_FLAGS(x)     (x).ne_flags
#define NE_AUTODATA(x)  (x).ne_autodata
#define NE_HEAP(x)      (x).ne_heap
#define NE_STACK(x)     (x).ne_stack
#define NE_CSIP(x)      (x).ne_csip
#define NE_SSSP(x)      (x).ne_sssp
#define NE_CSEG(x)      (x).ne_cseg
#define NE_CMOD(x)      (x).ne_cmod
#define NE_CBNRESTAB(x) (x).ne_cbnrestab
#define NE_SEGTAB(x)    (x).ne_segtab
#define NE_RSRCTAB(x)   (x).ne_rsrctab
#define NE_RESTAB(x)    (x).ne_restab
#define NE_MODTAB(x)    (x).ne_modtab
#define NE_IMPTAB(x)    (x).ne_imptab
#define NE_NRESTAB(x)   (x).ne_nrestab
#define NE_CMOVENT(x)   (x).ne_cmovent
#define NE_ALIGN(x)     (x).ne_align
#define NE_IPHI(x)      (x).ne_iphi
#define NE_SPHI(x)      (x).ne_sphi
#define NE_RES(x)       (x).ne_res

#define NE_USAGE(x)     (WORD)*((WORD *)(x)+1)
#define NE_PNEXTEXE(x)  (WORD)(x).ne_cbenttab
#define NE_ONEWEXE(x)   (WORD)(x).ne_crc
#define NE_PFILEINFO(x) (WORD)((DWORD)(x).ne_crc >> 16)

/*
 *  Format of NE_FLAGS(x):
 *
 *  p                                   Not-a-process
 *   x                                  Unused
 *    e                                 Errors in image
 *     xxxxx                            Unused
 *          f                           Floating-point instructions
 *           3                          386 instructions
 *            2                         286 instructions
 *             0                        8086 instructions
 *              P                       Protected mode only
 *               x                      Unused
 *                i                     Instance data
 *                 s                    Solo data
 */
#define NENOTP          0x8000          /* Not a process */
#define NEIERR          0x2000          /* Errors in image */
#define NEFLTP          0x0080          /* Floating-point instructions */
#define NEI386          0x0040          /* 386 instructions */
#define NEI286          0x0020          /* 286 instructions */
#define NEI086          0x0010          /* 8086 instructions */
#define NEPROT          0x0008          /* Runs in protected mode only */
#define NEINST          0x0002          /* Instance data */
#define NESOLO          0x0001          /* Solo data */


struct exeType {
    char	signature[2];		/* zibo's signature                  */
    unsigned	cbPage; 		/* bytes in image mod 512	     */
    unsigned	cPage;			/* size of file in 512 byte pages    */
    unsigned	cReloc; 		/* number of relocation items	     */
    unsigned	cParDir;		/* number of paragraphs before image */
    unsigned	cMinAlloc;		/* minimum number of paragrapsh      */
    unsigned	cMaxAlloc;		/* maximum number of paragrapsh      */
    unsigned	sStack; 		/* segment of stack in image	     */
    unsigned	oStack; 		/* offset of stack in image	     */
    unsigned	chksum; 		/* checksum of file		     */
    unsigned	oEntry; 		/* offset of entry point	     */
    unsigned	sEntry; 		/* segment of entry point	     */
    unsigned	oReloc; 		/* offset in file of reloc table     */
    unsigned	iOverlay;		/* overlay number		     */
};

struct exe_hdr                          /* DOS 1, 2, 3 .EXE header */
  {
    unsigned short      e_magic;        /* Magic number */
    unsigned short      e_cblp;         /* Bytes on last page of file */
    unsigned short      e_cp;           /* Pages in file */
    unsigned short      e_crlc;         /* Relocations */
    unsigned short      e_cparhdr;      /* Size of header in paragraphs */
    unsigned short      e_minalloc;     /* Minimum extra paragraphs needed */
    unsigned short      e_maxalloc;     /* Maximum extra paragraphs needed */
    unsigned short      e_ss;           /* Initial (relative) SS value */
    unsigned short      e_sp;           /* Initial SP value */
    unsigned short      e_csum;         /* Checksum */
    unsigned short      e_ip;           /* Initial IP value */
    unsigned short      e_cs;           /* Initial (relative) CS value */
    unsigned short      e_lfarlc;       /* File address of relocation table */
    unsigned short      e_ovno;         /* Overlay number */
    unsigned short      e_res[ERES1WDS];/* Reserved words */
    unsigned short      e_oemid;        /* OEM identifier (for e_oeminfo) */
    unsigned short      e_oeminfo;      /* OEM information; e_oemid specific */
    unsigned short      e_res2[ERES2WDS];/* Reserved words */
    long                e_lfanew;       /* File address of new exe header */
  };

struct new_exe                          /* New .EXE header */
  {
    unsigned short      ne_magic;       /* Magic number NE_MAGIC */
    unsigned char       ne_ver;         /* Version number */
    unsigned char       ne_rev;         /* Revision number */
    unsigned short      ne_enttab;      /* Offset of Entry Table */
    unsigned short      ne_cbenttab;    /* Number of bytes in Entry Table */
    long                ne_crc;         /* Checksum of whole file */
    unsigned short      ne_flags;       /* Flag word */
    unsigned short      ne_autodata;    /* Automatic data segment number */
    unsigned short      ne_heap;        /* Initial heap allocation */
    unsigned short      ne_stack;       /* Initial stack allocation */
    long                ne_csip;        /* Initial CS:IP setting */
    long                ne_sssp;        /* Initial SS:SP setting */
    unsigned short      ne_cseg;        /* Count of file segments */
    unsigned short      ne_cmod;        /* Entries in Module Reference Table */
    unsigned short      ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short      ne_segtab;      /* Offset of Segment Table */
    unsigned short      ne_rsrctab;     /* Offset of Resource Table */
    unsigned short      ne_restab;      /* Offset of resident name table */
    unsigned short      ne_modtab;      /* Offset of Module Reference Table */
    unsigned short      ne_imptab;      /* Offset of Imported Names Table */
    long                ne_nrestab;     /* Offset of Non-resident Names Table */
    unsigned short      ne_cmovent;     /* Count of movable entries */
    unsigned short      ne_align;       /* Segment alignment shift count */
    unsigned short      ne_iphi;        /* High word of initial IP */
    unsigned short      ne_sphi;        /* High word of initial SP */
    char                ne_res[NERESBYTES];
                                        /* Pad structure to 64 bytes */
  };


enum exeKind {
    IOERROR,				/* Error, file cannot be accessed    */
    NOTANEXE,				/* Error, file is not an .EXE file   */
    OLDEXE,				/* "oldstyle" DOS 3.XX .exe	     */
    NEWEXE,				/* "new" .exe, OS is unknown	     */
    WINDOWS,				/* Windows executable		     */
    DOS4,				/* DOS 4.XX .EXE		     */
    DOS286,				/* 286DOS .EXE			     */
    // changed BOUND to BOUNDEXE since BOUND is defined as a macro in new OS/2
    // include files - davewe 8/24/89
    BOUNDEXE,				/* 286DOS .EXE, bound		     */
    DYNALINK,                /* Dynamlink link module         */
    NTEXE               /* NT executable */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\re.h ===
/*  re.h - common include files for regular expression compilers
 */

RE_OPCODE *REip;            /* instruction pointer to compiled    */
struct patType *REPat;          /* pointer to pattern being compiled  */
int REArg;              /* count of tagged args parsed	      */

/* defined actions for parsing */

#define ACTIONMIN   0

#define PROLOG	    0
#define LEFTARG     1
#define RIGHTARG    2
#define SMSTAR	    3
#define SMSTAR1     4
#define STAR	    5
#define STAR1	    6
#define ANY	    7
#define BOL	    8
#define EOL	    9
#define NOTSIGN     10
#define NOTSIGN1    11
#define LETTER	    12
#define LEFTOR	    13
#define ORSIGN	    14
#define RIGHTOR     15
#define CCLBEG	    16
#define CCLNOT	    17
#define RANGE	    18
#define EPILOG	    19
#define PREV	    20

#define ACTIONMAX   20

/*  function forward declarations */

char             fREMatch (struct patType *,char *,char *,char );
struct patType * RECompile (char *, flagType, flagType);
char             REGetArg (struct patType *,int ,char *);
char             RETranslate (struct patType *,char *,char *);
int              RETranslateLength (struct patType *,char *);
int              RELength (struct patType *,int );
char *           REStart (struct patType *);

typedef UINT_PTR ACT (unsigned int, UINT_PTR, unsigned char, unsigned char);
typedef ACT *PACT;

UINT_PTR    CompileAction(unsigned int, UINT_PTR, unsigned char, unsigned char);
UINT_PTR    EstimateAction(unsigned int, UINT_PTR, unsigned char, unsigned char);
UINT_PTR    NullAction(unsigned int, UINT_PTR, unsigned char, unsigned char);

int     RECharType (char *);
int     RECharLen (char *);
int     REClosureLen (char *);
char *  REParseRE (PACT, char *,int *);
char *  REParseE (PACT,char *);
char *  REParseSE (PACT,char *);
char *  REParseClass (PACT,char *);
char *  REParseAny (PACT,char *);
char *  REParseBOL (PACT,char *);
char *  REParsePrev (PACT, char *);
char *  REParseEOL (PACT,char *);
char *  REParseAlt (PACT,char *);
char *  REParseNot (PACT,char *);
char *  REParseAbbrev (PACT,char *);
char *  REParseChar (PACT,char *);
char *  REParseClosure (PACT,char *);
char *  REParseGreedy (PACT,char *);
char *  REParsePower (PACT,char *);
char    REClosureChar (char *);
char    Escaped (char );

void    REStackOverflow (void);
void    REEstimate (char *);

#ifdef DEBUG
void REDump (struct patType *p);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\times.h ===
/* times.h - format of time stamp */

#define STAMP	    "%2d:%02d:%02d %2d %3s %4d"
#define STAMPLEN    20
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\parse.h ===
/* parse.h - support tops-20 comnd jsys on MSDOS */

#include <setjmp.h>

/* flags in pair.flags. Not examined by tbLook				     */
#define PINVIS	0x4000			/* invisible in HELP, but recognized */
#define PABBREV 0x2000			/* abbreviation. Value is pointer    */

/* parse support */
extern struct tbPairType *valParse;
extern jmp_buf ParseAC;
extern jmp_buf PromptAC;
extern char bufField[MAXARG];

#define SETPROMPT(p,b) setjmp(PromptAC);initParse(b,p);setjmp(ParseAC)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\remi.h ===
/*
 *  History:
 *
 *	??-???-???? ?? Created
 *	15-Sep-1988 bw Added REM_*, changed REMatch parameters.
*/

#define MAXPATARG   10			/* 0 is entire 1-9 are valid	     */

/* Return codes from REMatch */

#define REM_MATCH   0		    /* A match was found		    */
#define REM_NOMATCH 1		    /* No match was found		    */
#define REM_UNDEF   2		    /* An undefined Op-code was encountered */
#define REM_STKOVR  3		    /* The stack overflowed		    */
#define REM_INVALID 4		    /* A parameter was invalid		    */

typedef unsigned char RE_OPCODE;

/* structure of compiled pattern */

struct patType {
    flagType fCase;			/* TRUE => case is significant	     */
    flagType fUnix;			/* TRUE => use unix replacement      */
    char *pArgBeg[MAXPATARG];		/* beginning of tagged strings	     */
    char *pArgEnd[MAXPATARG];		/* end of tagged strings	     */
    RE_OPCODE code[1];			/* pseudo-code instructions	     */
};

/*  if RECompile fails and RESize == -1, then the input pattern had a syntax
 *  error.  If RESize != -1, then we were not able to allocate enough memory
 *  to contain the pattern pcode
 */
int		 RESize;		/* estimated size of pattern	     */

int		 REMatch(struct patType  *,char  *,char  *,RE_OPCODE *[], unsigned, flagType );
struct patType	*RECompile(char  *, flagType, flagType);
char		 REGetArg(struct patType  *,int ,char  *);
char		 RETranslate(struct patType  *,char  *,char  *);
int		 RELength(struct patType  *,int );
char		*REStart(struct patType  *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\rm.h ===
/* rm.h - include file for rm and undel facility
 *
 * Revision History:
 *  ??-???-???? ?? Created
 *  27-Dec-1989 SB Added new index file header stuff
 *
 * Index file format:
 *  The indexed file is composed of records of length RM_RECLEN.
 *	The old index file was composed of entries each the size of a record
 *  and composed of filename padded by NULs. The hash function mapped the
 *  Nth record (i.e. Nth INDEXED entry) to 'deleted.xxx', where, 'xxx' is (N+1)
 *  padded by leading zeroes.
 *	The new index file has an header record, rm_header, followed by entries
 *  of one or more records padded by NULs. Longfilenames occupy multiple
 *  records. The hash function maps the entry starting at Nth record to
 *  'deleted.xxx' where xxx is (N+1) padded by leading zeroes. This works out
 *  to be basically the same as that for the old format. The differences are :-
 *	-No entry is mapped to 'deleted.000'
 *	-Entries for filenames longer than (RM_RECLEN-1) bytes cause gaps in
 *	    mapping.
 *
 * Notes:
 *  RM/EXP/UNDEL work as follows:-
 *	    'RM foo' saves a copy of 'foo' and places it in an hidden
 *	sub-directory of RM_DIR (of foo) as file 'deleted.xxx', where, xxx is
 *	determined from the index file RM_IDX in RM_DIR. An entry is made in
 *	the index file for this.
 *	    'UNDEL foo' reads the index file in RM_DIR and determines xxx for
 *	foo and renames 'deleted.xxx' as foo. The entry for foo in the index
 *	file is filled with NULLs.
 *	    'EXP' picks up the index file from RM_DIR and deletes 'deleted.xxx'
 *	for each entry in the index file. It then deletes the index file and
 *	RM_DIR.
 *
 *  The new index file format can coexist with the old one because :-
 *	The header has a starting NULL which causes it to be ignored by
 *	    the old utilities,
 *	When the old utilities attempt to read in a long filename entry they
 *	fail without harm as the hashed 'deleted.xx' does not exist.
 */

#define RM_DIR	    "deleted."
#define RM_IDX	    "index."
#define RM_RECLEN   16

/* The header record in the index file has
 *	'\0IXn.nn\0' padded to RM_RECLEN bytes
 */

#define RM_SIG	    (char)0x00
#define RM_MAGIC    "IX"	  /* IX - IndeXed file */
#define RM_VER	    "1.01"
#define RM_NULL     "\0"

/* Forms header for Index file using RM_MAGIC, RM_VER and RM_NULL */

extern char rm_header[RM_RECLEN];

/* Function prototypes */

    // Converts Index file to the new format
int convertIdxFile (int fhidx, char *dir);

    // Determines if the record is a new index file header
flagType fIdxHdr (char *rec);

    // Reads an Index file record
int readIdxRec (int fhIdx, char *rec);

    // Reads index file records and returns INDEXED entry
int readNewIdxRec (int fhIdx, char *szRec, unsigned int cbMax);

    // Writes an new index file header
int writeIdxHdr (int fhIdx);

    // Writes an index file record
int writeIdxRec (int fhIdx, char *rec);

    // Indexes an entry into the Index file
int writeNewIdxRec (int fhIdx, char *szRec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\curdir.c ===
/* return text of current directory
 *
 *  Modifications:
 *
 *	29-Oct-1986 mz	Lower case output
 *	09-Dec-1986 bw	Added DOS 5 support.
 *	30-Oct-1987 bw	Change 'DOS5' to 'OS2'
 *	20-Nov-1987 bw	Set errno to 19 for invalid drive
 *	03-Mar-1989 bw	Set C RTL _doserrno in OS/2.
 *	05-Jul-1989 bw	use MAX_PATH
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */
#define INCL_DOSERRORS

#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

int
curdir( char *buf, BYTE drive )
{
    // New method (temporary)
    DWORD dwLength;

    assert( !drive );

    dwLength = GetCurrentDirectory( MAX_PATH, (LPSTR)buf );

    if( !dwLength ) {
        return( 1 );
    }

    return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\ttypes.h ===
/* ttypes.h - type definitions for tools library
 *
 *  HISTORY:
 *   29-May-87	danl	remove strcmpi
 *			int strcmpi (char *, char *);
 */

#include <time.h>

#define     lmax(x,y)   max(x,y)
#define     lmin(x,y)   min(x,y)

/* assembly routines */
flagType int25 (char, char far *, unsigned int, unsigned int);
flagType int26 (char, char far *, unsigned int, unsigned int);
void cursor (int, int);
void Move (void far *, void far *, unsigned int);
void Fill (char far *, char, unsigned int);
char *strbscan (char const *, char const *);
char *strbskip (char const *, char const *);
char *strncrlfend (char *, int);
flagType strpre (char *, char *);
char *fcopy (char *, char *);
long getlpos ();
void getlinit ( char far *, int, int);
int getl (char *, int);


/* c routines */
#define lower(x)    (_strlwr(x))
#define upper(x)    (_strupr(x))
#define MakeStr(x)  (_strdup(x))
#define strend(x)   ((x)+strlen(x))

char  *error(void);
long fexpunge(char  *,FILE *);
char  *fcopy(char  *,char  *);
char * __cdecl fgetl(char  *,int ,FILE  *);
int fputl(char  *,int ,FILE  *);
int ffirst(char  *,int ,struct findType  *);
int fnext(struct findType  *);
void findclose(struct findType *);

typedef flagType (*__action_routine__)( char *, va_list );

flagType __cdecl forsemi( char *p, __action_routine__ proc, ...  );

__int64 freespac(int );
__int64 sizeround( __int64 ,int );
char * fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );
int mapenv(char  *,char  *);
char  *ismark(char  *);
FILE  *swopen(char  *,char  *);
int swclose(FILE  *);
int swread(char  *,int ,FILE  *);
char  *swfind(char  *,FILE *,char  *);
char *getenvini(char  *,char  *);
char fPathChr(int );
char fSwitChr(int );
flagType fPFind(char    *,  va_list);
flagType findpath(char  *,char  *, flagType );
FILE  *pathopen(char  *,char  *,char  *);
int forfile(char  *, int ,void ( *)(char *, struct findType *, void *), void * );
int rootpath(char  *,char  *);
int sti(char  *,int );
int ntoi(char  *,int );
int __cdecl strcmps( const char  *, const char  * );
int __cdecl strcmpis( const char  *, const char  * );
int upd(char  *,char  *,char  *);
int drive(char  *,char  *);
int extention(char  *,char  *);
int filename(char  *,char  *);
int filenamx(char  *,char  *);
int fileext(char *, char *);
int path(char  *,char  *);
int curdir(char  *, BYTE );
int getattr(char  *);
int fdelete(char  *);
char *fmove(char  *, char *);
char *fappend(char  *, HANDLE);
time_t ctime2l(char *);
struct tm *ctime2tm(char *);
long date2l(int, int, int, int, int, int);
VECTOR *VectorAlloc(int);
flagType fAppendVector(VECTOR **, void *);
int pipe( int [] );
int pgetl( char *, int, int );
enum exeKind exeType ( char * );
char *strExeType( enum exeKind );
flagType fMatch (char *, char *);

extern char * (__cdecl *tools_alloc) (unsigned int);

int Connect (char *path, char *con, char *sub);
flagType fDisconnect (int drive);
char *pathcat (char *pDst, char *pSrc);
int setattr (char *pname, int attr);

/*  swchng.c */
flagType swchng (char *strSwFile, char *strTag, char *strLHS, char *strRHS, flagType fNoUndel);
int swchnglhs (char *strSwFile, char *strTag, char *strLHS, char *strRHS);

/*  heapdump.c */
int     heapdump ( FILE *fp, int iFormat );

/*  heapchk.c */
int     heapinfo (void);


/*  pname.c */
char *pname (char *);
unsigned short IsMixedCaseSupported (char *);


// cvtoem.c

void
ConvertAppToOem( unsigned argc, char* argv[] );


char*
getenvOem( char* p );

int
putenvOem( char* p );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\cvtoem.c ===
#include <stdlib.h>
#include "windows.h"


void
ConvertAppToOem( unsigned argc, char* argv[] )
/*++

Routine Description:

    Converts the command line from ANSI to OEM, and force the app
    to use OEM APIs

Arguments:

    argc - Standard C argument count.

    argv - Standard C argument strings.

Return Value:

    None.

--*/

{
    unsigned i;
    LPSTR pSrc;
    LPSTR pDst;
    WCHAR Wide;

    for( i=0; i<argc; i++ ) {
        pSrc = argv[i];
        pDst = argv[i];

        do {

            //
            // Convert ansi to Unicode and then
            // Unicode to OEM
            //

            MultiByteToWideChar(
                CP_ACP,
                MB_PRECOMPOSED,
                pSrc++,
                1,
                &Wide,
                1
                );

            WideCharToMultiByte(
                CP_OEMCP,
                0,
                &Wide,
                1,
                pDst++,
                1,
                "_",
                NULL
                );

        } while (*pSrc);

    }
    SetFileApisToOEM();
}




char*
getenvOem( char* p )
/*++

Routine Description:

    Get an environment variable and convert it to OEM.


Arguments:

    p - Pointer to a variable name


Return Value:

   Returns the environment variable value.

--*/

{
    char* OemBuffer;
    char* AnsiValue;

    OemBuffer = NULL;
    AnsiValue = getenv( p );

    if( AnsiValue != NULL ) {
        OemBuffer = _strdup( AnsiValue );
        if( OemBuffer != NULL ) {
            CharToOem( OemBuffer, OemBuffer );
        }
    }
    return( OemBuffer );
}


int
putenvOem( char* p )
/*++

Routine Description:

    Add, remove or modify an environment variable.
    The variable and its value are assumed to be OEM, and they are
    set in the environment as ASNI string.


Arguments:

    p - Pointer to an OEM string that defines the variable.


Return Value:

   Returns 0 if successful, -1 if not.

--*/

{
    char* AnsiBuffer;
    int   rc;

    if( p == NULL ) {
        return( _putenv( p ) );
    }

    AnsiBuffer = _strdup( p );
    if( AnsiBuffer != NULL ) {
        OemToCharBuffA( AnsiBuffer, AnsiBuffer, strlen(AnsiBuffer));
    }
    rc = _putenv( AnsiBuffer );
    if( AnsiBuffer != NULL ) {
        free( AnsiBuffer );
    }
    return( rc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\inc\tools.h ===
/*
 *  tools.h - Header file for accessing TOOLS.LIB routines
 *  includes stdio.h and ctype.h
 *
 *   4/14/86  daniel lipkie  added U_* flags for upd return values
 *
 *	31-Jul-1986 mz	Add Connect definitions
 *	02-Dec-1986 bw	Added DOS5 FindFirst buffer definition & A_ALL constant
 *	21-Jan-1987 bw	Add DWORD define
 *			Add PIPE_READ / PIPE_WRITE values
 *			Add new rspawn return typedef
 *	27-Jan-1987 bw	Make DOS 3 findType available to DOS 5
 *	18-Aug-1987 bw	change .max to .vmax to make C 5.x happy
 *	08-Mar-1988 bw	Copy WORD() and DWORD() to MAKE*()
 *	10-Mar-1988 mz	Add LOADDS/EXPORT definitions
 *	12-May-1988 mz	Add VECTOR typedef
 *	19-Aug-1988 mz	Conditionally define TRUE/FALSE
 *
 *	03-Aug-1990 davegi  Changed findType.attr & findType date/time stamps
 *			    from unsigned to unsigned short (OS/2 2.0)
 *
 *	02-Oct-1990 w-barry Modified the findType structure to use
 *			    FILEFINDBUF4 structure.
 *
 *      16-Nov-1990 w-barry Updated the FILE_XXXXX defines to the Win32
 *                          standard.
 *
 *      21-Nov-1990 w-barry Redefined FindType to use the Win32 structure.
 *
 */

#include "config.h"

#if !defined (FALSE)
    #define FALSE	0
#endif

#if !defined (TRUE)
    #define TRUE	(!FALSE)
#endif

#if MSDOS
    #define     PSEPSTR "\\"
    #define     PSEPCHR '\\'
#else
    #define     PSEPSTR "/"
    #define     PSEPCHR '/'
#endif

#if !defined( _FLAGTYPE_DEFINED_ )
typedef char flagType;
#endif
typedef long ptrType;

#define SETFLAG(l,f)	((l) |= (f))
#define TESTFLAG(v,f)	(((v)&(f))!=0)
#define RSETFLAG(l,f)	((l) &= ~(f))

#define SHIFT(c,v)	{c--; v++;}

#if !defined(CW)
    #define WORD(h,l)	((LOW((h))<<8)|LOW((l)))
    #define DWORD(h,l)	((DLOW(h)<<16|DLOW(l)))
    #if !defined(MAKEWORD)
        #define MAKEWORD(l, h)	 ((LOW((h))<<8)|LOW((l)))
    #endif
    #if !defined(MAKELONG)
        #define MAKELONG(l, h)	((DLOW(h)<<16|DLOW(l)))
    #endif
#endif

#define LOW(w)		((int)(w)&0xFF)
#define HIGH(w) 	LOW((int)(w)>>8)
#define DLOW(l) 	((long)(l)&0xFFFF)
#define DHIGH(l)	DLOW((long)(l)>>16)
#define POINTER(seg,off) ((((long)(seg))<<4)+ (long)(off))

#define FNADDR(f)	(f)

#define SELECT		if(FALSE){
#define CASE(x) 	}else if((x)){
#define OTHERWISE	}else{
#define ENDSELECT	}

#define MAXARG	    128 		/* obsolete and begin deleted */
#define MAXLINELEN  1024		/* longest line of input */
#define MAXPATHLEN  260 		/* longest filename acceptable */

#define PIPE_READ   0
#define PIPE_WRITE  1

#define FILE_ATTRIBUTE_VOLUME_LABEL     0x00


/*
 *  This is the value returned by rspawnl.  The PID field will always hold
 *  the process ID of the background process.  The in* fields will hold the
 *  handles of the pipe attached to the new processes stdin, and the out*
 *  fields correspond to stdout.  If input/output from/to a pipe has not been
 *  requested, the fields will be -1.  The fields are ordered read-write
 *  to allow a call pipe(&val.inReadHndl) or pipe(&val.outreadHndl).
*/
struct spawnInfo {
    unsigned PID;
    int inReadHndl;
    int inWriteHndl;
    int outReadHndl;
    int outWriteHndl;
};


/* buffer description for findfirst and findnext
   When DOS 3 and DOS 5 version have the same field name, the field contains
   the same information
   DOS 5 version includes the directory handle
*/
/***
 *
 * Old Style def'n
 *

struct findType {
    unsigned	    type ;
    unsigned	    dir_handle ;
    unsigned short  create_date ;
    unsigned short  create_time ;
    unsigned short  access_date ;
    unsigned short  access_time ;
    unsigned short  date ;
    unsigned short  time ;
    long	        length ;
    long	        alloc ;
    unsigned long   attr ;
    unsigned char nam_len ;
    char name[MAXPATHLEN] ;
};

 *
 * ...end old def'n.
 *
**/


/*
 * NT Def'n
 */
//struct findType {
//    unsigned		type;		/* type of object being searched    */
//    unsigned		dir_handle;	/* Dir search handle for FindNext   */
//    FILEFINDBUF4	fbuf;		/* Aligned structure for Cruiser and NT */
//};

struct findType {
    unsigned        type;       /* type of object being searched    */
    HANDLE          dir_handle; /* Dir search handle for FindNext   */
    long            attr;       /* File attributes                  */
    WIN32_FIND_DATA fbuf;       /* Aligned structure for Cruiser and NT */
};

#define DWORD_SHIFT     (sizeof(DWORD) * 8)
#define FILESIZE(wfd)   (((DWORDLONG)(wfd).nFileSizeHigh << DWORD_SHIFT) + (wfd).nFileSizeLow)

#define FT_DONE     0xFF		/* closed handle */
#define FT_FILE     0x00		/* enumerating files */
#define FT_SERV     0x01		/* enumerating servers */
#define FT_SHAR     0x02		/* enumerating shares */
#define FT_MASK     0xFF		/* mask for type */

#define FT_MIX	    0x8000		/* mixed case supported flag */

struct DOS3findType {
    char reserved[21];          /* reserved for start up	     */
    char attr;              /* attribute found		     */
    unsigned time;          /* time of last modify		     */
    unsigned date;          /* date of last modify		     */
    long length;            /* file size			     */
    char name[13];          /* asciz file name		     */
};

typedef struct findType FIND;
typedef FIND near * NPFIND;


// These attributes are redef'd from the previous hard coded versions.
/* attributes */
//#define A_RO	FILE_ATTRIBUTE_READONLY		/* read only	     */
//#define A_H	FILE_ATTRIBUTE_HIDDEN		/* hidden	     */
//#define A_S	FILE_ATTRIBUTE_SYSTEM		/* system	     */
//#define A_V	FILE_ATTRIBUTE_VOLUME_LABEL	/* volume id	     */
//#define A_D	FILE_ATTRIBUTE_DIRECTORY	/* directory	     */
//#define A_A	FILE_ATTRIBUTE_ARCHIVE		/* archive	     */

#define A_MOD	( FILE_ATTRIBUTE_READONLY + FILE_ATTRIBUTE_HIDDEN + FILE_ATTRIBUTE_SYSTEM + FILE_ATTRIBUTE_ARCHIVE)	/* changeable attributes	     */
//#define A_ALL	(A_RO|A_H|A_S|A_V|A_D|A_A)
#define A_ALL	( FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_ARCHIVE | FILE_ATTRIBUTE_DIRECTORY | FILE_ATTRIBUTE_VOLUME_LABEL )


#define HASATTR(a,v)	TESTFLAG(a,v)	/* true if a has attribute v	     */

extern char XLTab[], XUTab[];

struct vectorType {
    int vmax;               /* max the vector can hold	     */
    int count;              /* count of elements in vector	     */
    UINT_PTR elem[1];           /* elements in vector		     */
};

typedef struct vectorType VECTOR;

#include "parse.h"
#include "exe.h"
#include "fcb.h"
#include "dir.h"
#include "times.h"
#include "ttypes.h"

/* return flags for upd */
#define U_DRIVE 0x8
#define U_PATH	0x4
#define U_NAME	0x2
#define U_EXT	0x1

/*  Connect definitions */

#define REALDRIVE	0x8000
#define ISTMPDRIVE(x)	(((x)&REALDRIVE)==0)
#define TOKTODRV(x)	((x)&~REALDRIVE)

/*  Heap Checking return codes */

#define HEAPOK           0
#define HEAPBADBEGIN    -1
#define HEAPBADNODE     -2
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\ctime2l.c ===
/* routines for converting from ASCII time to long int */
#include <time.h>
#include <stdio.h>
#include <string.h>
//void __cdecl __tzset(void);

/*  Intended to be the "inverse" of the asctime function of the C library
 *
 *  ctime2l  - takes ascii string in the format returned by ctime
 *             representing local time and returns a time_t that is the
 *             elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *  ctime2tm - takes ascii string in the format returned by ctime and
 *             fills a struct tm
 *  date2l   - takes a date representing local time and returns a time_t that
 *             is the elapsed seconds since 00:00:00 Jan 1, 1970 Greenwich Mean Time
 *
 *  Modifications:
 *
 *      08-Sep-1986 mz  Extend time formats accepted to include:
 *          day mon dd hh:mm:ss yyyy
 *          mm/dd/yy                    (presume 00:00:00)
 *          hh:mm:ss                    (presume hh:mm:ss today)
 *          hh:mm                       (presume hh:mm:00 today)
 *          +hh:mm:ss                   (hh:mm:ss from now)
 *          +hh:mm                      (hh:mm from now)
 *          +hh                         (hh from now)
 *          yesterday                   (at midnight)
 *          tomorrow                    (at midnight)
 *          now
 *
 *      18-Oct-1990 w-barry Removed 'dead' code.
 */


static int dayinmon[12] = {31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};
static char *strMon[12] = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul",
    "Aug", "Sep", "Oct", "Nov", "Dec"};
static char *strDay[7] =  {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
static struct tm tb;

// djg extern long timezone;
// djg extern int daylight;
//extern int _days[];
int _days[] = {
	-1, 30, 58, 89, 119, 150, 180, 211, 242, 272, 303, 333, 364
};
static int istr(char *p, char **q, int len);

/****************************************************************************/
/* start of copy of code in C lib                                           */
/****************************************************************************/

#define DaySec  (24*60*60L)
#define YearSec (365*DaySec)
#define DecSec  315532800L      /* secs in 1970-1979 */
#define Day1    4               /* Jan. 1, 1970 was a Thursday */
#define Day180  2               /* Jan. 1, 1980 was a Tuesday */


/*
 *  _isindst - Tells whether Xenix-type time value falls under DST
 *
 *  This is the rule for years before 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the last Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  This is the rule for years starting with 1987:
 *  a time is in DST iff it is on or after 02:00:00 on the first Sunday
 *  in April and before 01:00:00 on the last Sunday in October.
 *
 *  ENTRY   tb  - 'time' structure holding broken-down time value
 *
 *  RETURN  1 if time represented is in DST, else 0
 */

void __cdecl __tzset(void)
{
    static int first_time = 0;

    if ( !first_time ) {
        _tzset();
         first_time++;
    }
}

static int _isindst(register struct tm *tb)
{
    int mdays;
    register int yr;
    int lastsun;

    /* If the month is before April or after October, then we know immediately
     * it can't be DST. */

    if (tb->tm_mon < 3 || tb->tm_mon > 9)
        return(0);

    /* If the month is after April and before October then we know immediately
     * it must be DST. */

    if (tb->tm_mon > 3 && tb->tm_mon < 9)
        return(1);
    /*
     * Now for the hard part.  Month is April or October; see if date
     * falls between appropriate Sundays.
     */

    /*
     * The objective for years before 1987 (after 1986) is to determine
     * if the day is on or after 2:00 am on the last (first) Sunday in April,
     * or before 1:00 am on the last Sunday in October.
     *
     * We know the year-day (0..365) of the current time structure. We must
     * determine the year-day of the last (first) Sunday in this month,
     * April or October, and then do the comparison.
     *
     * To determine the year-day of the last Sunday, we do the following:
     *        1. Get the year-day of the last day of the current month (Apr or Oct)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     *
     * To determine the year-day of the first Sunday, we do the following:
     *        1. Get the year-day of the 7th day of the current month (April)
     *        2. Determine the week-day number of #1,
     *      which is defined as 0 = Sun, 1 = Mon, ... 6 = Sat
     *        3. Subtract #2 from #1
     */

    yr = tb->tm_year + 1900;    /* To see if this is a leap-year */

    /* First we get #1. The year-days for each month are stored in _days[]
     * they're all off by -1 */

    if (yr > 1986 && tb->tm_mon == 3)
        mdays = 7 + _days[tb->tm_mon];
    else
        mdays = _days[tb->tm_mon+1];

    /* if this is a leap-year, add an extra day */
    if (!(yr & 3))
        mdays++;

    /* mdays now has #1 */

    yr = tb->tm_year - 70;

    /* Now get #2.  We know the week-day number of the beginning of the epoch,
     * Jan. 1, 1970, which is defined as the constant Day1.  We then add the
     * number of days that have passed from Day1 to the day of #2
     *      mdays + 365 * yr
     * correct for the leap years which intervened
     *      + (yr + 1)/ 4
     * and take the result mod 7, except that 0 must be mapped to 7.
     * This is #2, which we then subtract from #1, mdays
     */

    lastsun = mdays - ((mdays + 365*yr + ((yr+1)/4) + Day1) % 7);

    /* Now we know 1 and 3; we're golden: */

    return (tb->tm_mon==3
        ? (tb->tm_yday > lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour >= 2))
        : (tb->tm_yday < lastsun ||
        (tb->tm_yday == lastsun && tb->tm_hour < 1)));
}

static time_t _dtoxtime(yr, mo, dy, hr, mn, sc)
int yr;
int mo, dy, hr, mn, sc;
{
    int mdays;
    time_t scount;

    scount = ((yr+3)/4)*(time_t)DaySec;

    /* This is no good beyond the year 2099 */

    mdays = _days[mo-1];
    if (!(yr % 4) && (mo > 2))
        mdays++;
    scount += (yr*365 + dy + mdays)*(time_t)DaySec + (time_t)hr*3600L + mn*60L +
                sc + (time_t)DecSec;
    tb.tm_yday = mdays + dy;
    __tzset();
    scount += _timezone;
    tb.tm_year = yr + 80;
    tb.tm_mon = mo - 1;
    tb.tm_hour = hr;
    if (_daylight && _isindst(&tb))
        scount -= 3600L;
    return(scount);
}


/****************************************************************************/
/* end of copy of code in C lib                                             */
/****************************************************************************/

static int istr(p, q, len)
char *p;
char **q;
int len;
{
    int i;

    for (i=0; i < len; i++)
        if (_strcmpi(p, *q++)== 0)
            break;
    return i;
}

static leapyear(i)
{
    return (!i%4 && i%100);
}

static int yday(year, mon, day)
int year, mon, day;
{
    int i, j;

    /* year = 1986 is 86 */
    /* mon (0..11)       */
    j = day -1;
    for (i=0; i < mon; i++)
        j += dayinmon[i];
    if (mon > 2 && leapyear(year))
        j++;
    return j;
}

time_t date2l(year, month, day, hour, min, sec)
int year, month, day, hour, min, sec;
{
    /* month is (1..12) */
    return _dtoxtime (year - 1980, month, day, hour, min, sec);
}

struct tm *ctime2tm(p)
char *p;
{
    char day[4], mon[4];
    int date, year, hour, min, sec, month;
    time_t now;

    if (sscanf (p, " %3s %3s %2d %2d:%2d:%2d %4d ",
                   day, mon, &date, &hour, &min, &sec, &year) == 7) {
        tb.tm_sec = sec;
        tb.tm_min = min;
        tb.tm_hour = hour;
        tb.tm_mday = date;
        tb.tm_year = year-1900;
        tb.tm_mon  = istr(mon, strMon, 12);
        tb.tm_wday = istr(day, strDay, 7);
        tb.tm_yday = yday(tb.tm_year, tb.tm_mon, tb.tm_mday);
        tb.tm_isdst = (_daylight && _isindst(&tb) ? 1 : 0);
        return &tb;
        }

    if (*p == '+' && sscanf (p+1, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
        time (&now);
        now += 3600L * hour + 60L * min + sec;
        tb = *localtime (&now);
        return &tb;
        }
    if (*p == '+' && sscanf (p+1, " %2d:%2d ", &hour, &min) == 2) {
        time (&now);
        now += 3600L * hour + 60L * min;
        tb = *localtime (&now);
        return &tb;
        }
    if (*p == '+' && sscanf (p+1, " %2d ", &hour) == 1) {
        time (&now);
        now += 3600L * hour;
        tb = *localtime (&now);
        return &tb;
        }

    if (sscanf (p, " %2d:%2d:%2d ", &hour, &min, &sec) == 3) {
        time (&now);
        tb = *localtime (&now);
        tb.tm_sec = sec;
        tb.tm_min = min;
        tb.tm_hour = hour;
        return &tb;
        }
    if (sscanf (p, " %2d:%2d ", &hour, &min) == 2) {
        time (&now);
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = min;
        tb.tm_hour = hour;
        return &tb;
        }

    if (sscanf (p, " %2d/%2d/%2d ", &month, &date, &year) == 3) {
        if (year < 70)
            year += 2000;
        if (year < 100)
            year += 1900;
        now = _dtoxtime (year - 1980, month, date, 0, 0, 0);
        tb = *localtime (&now);
        return &tb;
        }

    if (!strcmp (p, "yesterday")) {
        time (&now);
        now -= 24 * 3600L;
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = 0;
        tb.tm_hour = 0;
        return &tb;
        }
    if (!strcmp (p, "now")) {
        time (&now);
        tb = *localtime (&now);
        return &tb;
        }
    if (!strcmp (p, "tomorrow")) {
        time (&now);
        now += 24 * 3600L;
        tb = *localtime (&now);
        tb.tm_sec = 0;
        tb.tm_min = 0;
        tb.tm_hour = 0;
        return &tb;
        }

    return NULL;
}

time_t ctime2l(p)
char *p;
{
    if (ctime2tm(p) == NULL)
        return -1L;
    return date2l (tb.tm_year +1900, tb.tm_mon + 1, tb.tm_mday, tb.tm_hour,
        tb.tm_min, tb.tm_sec);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\error.c ===
/* error.c - return text of error corresponding to the most recent DOS error
 *
 *  Modifications:
 *
 *	05-Jul-1989 bw	    Use MAX_PATH
 */


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>

char *error ()
{
    char * pRet;

    if (errno < 0 || errno >= sys_nerr)
	return "unknown error";
    else
	switch (errno)
	{
	    case 19: pRet = "Invalid drive"; break;
	    case 33: pRet = "Filename too long"; break;

	    default: pRet = sys_errlist[errno];
	}

    return pRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\dodel.c ===
/* delnode - removes a node and its descendants */


#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>
#include <direct.h>
#include <errno.h>

void
fDoDel (
    char	    *name,
    struct findType *pBuf,
    void	    *dummy
    )
{
    char *p;

    //
    // if it is a file, attempt to delete it
    //
    if (!TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_DIRECTORY)) {

        //
        // if file is read-only, make it writable
        //
        if (TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            if(!SetFileAttributes(name, pBuf->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                return;
            }
        }
        _unlink (name);

    } else if( strcmp( pBuf->fbuf.cFileName, "." ) &&
               strcmp( pBuf->fbuf.cFileName, ".." ) ) {

        //
        // if directory is read-only, make it writable
        //
        if (TESTFLAG(pBuf->fbuf.dwFileAttributes, FILE_ATTRIBUTE_READONLY)) {
            if(!SetFileAttributes(name, pBuf->fbuf.dwFileAttributes & ~FILE_ATTRIBUTE_READONLY)) {
                return;
            }
        }

        //
        // clear out subdir first
        //
        p = strend( name );
        pathcat( name, "*.*" );
        forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL);
        //if (!forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL)) {
        //    return;
        //}
        *p = 0;
        _rmdir (name);
    }

    dummy;
}

flagType delnode (name)
char *name;
{
    return (flagType)forfile(name, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY, fDoDel, NULL) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fappend.c ===
/* fappend.c - fast append of one file to another
 *
 * Modifications
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      29-Nov-1990 w-barry Modified for Win32
 */


#include <fcntl.h>
#include <io.h>
#include <dos.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

char *fappend( char *src, HANDLE dstfh )
{
    HANDLE srcfh;
    char *result;

    if( ( srcfh = CreateFile( src, GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL ) ) != (HANDLE)-1 ) {
        SetFilePointer( dstfh, 0L, 0L, FILE_END );
        result = fastcopy( srcfh, dstfh );
        CloseHandle( srcfh );
    } else {
	result = "Unable to open source";
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fcopy.c ===
/* fcopy.c - fast copy between two file specs
 *
 *      09-Dec-1986 bw  Added DOS 5 support
 *      30-Oct-1987 bw  Change 'DOS5' to 'OS2'
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      16-Nov-1990 w-barry Changed DosGetFileInfo to the Win32 equivalent
 *                          of GetFileAttributes and SetFileAttributes
 *
 */

#define INCL_DOSFILEMGR


#include <stdlib.h>
#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <windows.h>
#include <tools.h>

static
char    fcopyErrorText[128];


/* fcopy (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fcopy (char *src, char *dst)
{
    HANDLE srcfh = INVALID_HANDLE_VALUE;
    HANDLE dstfh = INVALID_HANDLE_VALUE;
    char *result;
    FILETIME CreationTime, LastAccessTime, LastWriteTime;

    if (GetFileAttributes(src) == FILE_ATTRIBUTE_DIRECTORY) {
        result = "Unable to open source";
        goto done;
    }
    if ( ( srcfh = CreateFile( src,
                               GENERIC_READ,
                               FILE_SHARE_READ,
                               NULL,
                               OPEN_EXISTING,
                               0,
                               NULL ) ) == INVALID_HANDLE_VALUE ) {

        sprintf( fcopyErrorText, "Unable to open source, error code %d", GetLastError() );
        result = fcopyErrorText;
        // result = "Unable to open source";
        goto done;
    }

    if (!GetFileTime(srcfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to get time of source";
        goto done;
    }

    if ( ( dstfh = CreateFile( dst,
                               GENERIC_WRITE,
                               FILE_SHARE_WRITE,
                               NULL,
                               CREATE_ALWAYS,
                               FILE_ATTRIBUTE_NORMAL, srcfh ) ) == INVALID_HANDLE_VALUE) {

        sprintf( fcopyErrorText, "Unable to create destination, error code %d", GetLastError() );
        result = fcopyErrorText;
        // result = "Unable to create destination";
        goto done;
    }

    result = fastcopy( srcfh, dstfh );

    if ( result != NULL ) {
        if (dstfh != INVALID_HANDLE_VALUE) {
            CloseHandle( dstfh );
            dstfh = INVALID_HANDLE_VALUE;
        }

        DeleteFile( dst );
        goto done;
    }

    if (!SetFileTime(dstfh, &CreationTime, &LastAccessTime, &LastWriteTime)) {
        result = "Unable to set time of destination";
        goto done;
    }

    done:

    if (srcfh != INVALID_HANDLE_VALUE) {
        CloseHandle( srcfh );
    }
    if (dstfh != INVALID_HANDLE_VALUE) {
        CloseHandle( dstfh );
    }

    return result;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fdelete.c ===
/* fdelete.c - perform undeleteable delete
 *
 *      5/10/86     dl  Use frenameNO instead of rename
 *      29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *      06-Jan-1987 mz  Use rename instead of frenameNO
 *      02-Sep-1988 bw  Keep original file if index file update fails.
 *                      Overwrite existing DELETED.XXX if necessary.
 *      22-Dec-1989 SB  Changes for new Index file format
 *      17-Oct-1990 w-barry Temporarily replace C-runtime 'rename' with
 *                          local varient - until DosMove fully implemented
 *                          on NT.
 */


#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>
#include <io.h>
#include <string.h>
#include <direct.h>
#include <malloc.h>


/*
 * Function declarations...
 */

char rm_header[RM_RECLEN] = { RM_NULL RM_MAGIC RM_VER};

/* fdelete returns:
 *  0 if fdelete was successful
 *  1 if the source file did not exist
 *  2 if the source was read-only or if the rename failed
 *  3 if the index was not accessible, could not be updated, or corrupted
 *
 * The delete operation is performed by indexing the file name in a separate
 * directory and then renaming the selected file into that directory.
 */
int fdelete(p)
char *p;                                /* name of file to be deleted */
{
    char *dir;                          /* deleted directory */
    char *idx;                          /* deleted index */
    char *szRec;                        /* deletion entry in index */
    int attr, fhidx;
    int erc;

    dir = idx = szRec = NULL;
    fhidx = -1;
    if ((dir = (*tools_alloc) (MAX_PATH)) == NULL ||
        (idx = (*tools_alloc) (MAX_PATH)) == NULL ||
        (szRec = (*tools_alloc) (MAX_PATH)) == NULL) {
        erc = 3;
        goto cleanup;
    }

    /* See if the file exists */
    if ( ( attr = GetFileAttributes( p ) ) == -1) {
        erc = 1;
        goto cleanup;
    }

    /* what about read-only files? */
    if (TESTFLAG (attr, FILE_ATTRIBUTE_READONLY)) {
        erc = 2;
        goto cleanup;
    }

    /*  Form an attractive version of the name
     */
    pname (p);

    /* generate deleted directory name, using defaults from input file
     */
    upd (p, RM_DIR, dir);

    /* generate index name */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);

    /* make sure directory exists (reasonably) */
    if ( _mkdir (dir) == 0 )
        SetFileAttributes(dir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);

    /* extract filename/extention of file being deleted */
    fileext (p, szRec);

    /* try to open or create the index */
    if ((fhidx = _open (idx, O_CREAT | O_RDWR | O_BINARY,
                        S_IWRITE | S_IREAD)) == -1) {
        erc = 3;
        goto cleanup;
    }

    if (!convertIdxFile (fhidx, dir)) {
        erc = 3;
        goto cleanup;
    }

    /* determine new name */
    sprintf (strend (dir), "\\deleted.%03x",
             _lseek (fhidx, 0L, SEEK_END) / RM_RECLEN);

    /* move the file into the directory */
    _unlink (dir);

    if (rename(p, dir) == -1) {
        erc = 2;
        goto cleanup;
    }

    /* index the file */
    if (!writeNewIdxRec (fhidx, szRec)) {
        rename( dir, p );
        erc = 2;
        goto cleanup;
    }
    erc = 0;
    cleanup:
    if (fhidx != -1)
        _close(fhidx);
    if (dir != NULL)
        free (dir);
    if (idx != NULL)
        free (idx);
    if (szRec != NULL)
        free (szRec);
    return erc;
}

/* writeIdxRec - Write an index record
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int writeIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return _write (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}

/* readIdxRec - Read an index record
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int readIdxRec (fhIdx, rec)
int fhIdx;
char *rec;
{
    return _read (fhIdx, rec, RM_RECLEN) == RM_RECLEN;
}


/* convertIdxFile - convert index file to new Index File format.
 *
 * Note: If new index file then we do nothing.
 *
 * Returns:  1  if successful
 *           0  if it fails
 */
int convertIdxFile (fhIdx, dir)
int fhIdx;
char *dir;
{
    char firstRec[RM_RECLEN];       /* firstRec */
    int iRetCode = TRUE;
    char *oldName, *newName;

    oldName = newName = NULL;
    if ((oldName = (*tools_alloc) (MAX_PATH)) == NULL ||
        (newName = (*tools_alloc) (MAX_PATH)) == NULL) {
        iRetCode = FALSE;
        goto cleanup;
    }

    /* If index file is just created then write header */
    if (_lseek (fhIdx, 0L, SEEK_END) == 0L)
        writeIdxHdr (fhIdx);
    else {
        /* Go to the beginning */
        if (_lseek (fhIdx, 0L, SEEK_SET) == -1) goto cleanup;

        /* If New Index format then we are done */
        if (!readIdxRec (fhIdx, firstRec))
            goto cleanup;
        if (fIdxHdr (firstRec))
            goto cleanup;
        else {
            if (!writeIdxHdr (fhIdx)) {
                iRetCode = FALSE;
                goto cleanup;
            }
            strcpy (oldName, dir);
            strcpy (newName, dir);
            pathcat (oldName, "\\deleted.000");
            sprintf (strend (newName), "\\deleted.%03x",
                     _lseek (fhIdx, 0L, SEEK_END) / RM_RECLEN);
            if ( rename( oldName, newName ) || !writeIdxRec (fhIdx, firstRec)) {
                iRetCode = FALSE;
                goto cleanup;
            }
        }
    }
    cleanup:
    if (oldName != NULL)
        free (oldName);
    if (newName != NULL)
        free (newName);
    return iRetCode;
}

/* fIdxHdr - Is the Index record a new index format header
 */
flagType fIdxHdr (rec)
char*rec;
{
    return (flagType)(rec[0] == RM_SIG
                      && !strncmp(rec+1, RM_MAGIC, strlen(RM_MAGIC)));
}

/* writeIdxHdr - Write an header record into a header file
 *
 * Returns: 1 when no error
 *          0 when it fails
 */
int writeIdxHdr (fhIdx)
int fhIdx;
{
    /* Seek to the beginning of the file */
    if (_lseek (fhIdx, 0L, SEEK_SET) == -1) 
        return 0;

    /* Use rm_header[] from rm.h */
    return writeIdxRec (fhIdx, rm_header);
}

/* writeNewIdxRec - creates entry for file in new index file format.
 *
 * Returns: 1   if successful
 *          0   if it fails
 */
int writeNewIdxRec (fhIdx, szRec)
int fhIdx;
char *szRec;
{
    char rec[RM_RECLEN];
    int cbLen;

    cbLen = strlen(szRec) + 1; // Include NUL at end
    while (cbLen > 0) {
        memset( rec, 0, RM_RECLEN );
        strncat (rec, szRec, RM_RECLEN-1);
        szRec += RM_RECLEN;
        if (!writeIdxRec (fhIdx, rec))
            return FALSE;
        cbLen -= RM_RECLEN;
    }
    return TRUE;
}

/* readNewIdxRec - reads in records in new index file corresponding to
 *                 one index entry.
 *
 * Note: It returns the file name read in szRec.
 *
 * Returns: TRUE    if successful
 *          FALSE   if it fails
 */
int readNewIdxRec (
                  int fhIdx,
                  char *szRec,
                  unsigned int cbMax
                  ) {
    char rec[RM_RECLEN];            /* read at one go */
    unsigned int cb = 0;

    /* Read the entry */
    do {
        if (!readIdxRec (fhIdx, rec))
            return FALSE;
        strncpy (szRec, rec, RM_RECLEN);
        szRec += RM_RECLEN;
        cb += RM_RECLEN;
    } while (!memchr (rec, '\0', RM_RECLEN) && (cb < cbMax));

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fexpunge.c ===
/* fexpunge.c - remove all deleted objects from the index
 *
 *  HISTORY:
 *
 *	??-???-???? ??	 Original Version
 *	06-Sep-1988 bw	 Issue error is directory removal fails
 *	20-Dec-1989 SB	 Change for new Index file format, added NOTES
 *      17-Oct-1990 w-barry Removed calls to _stat function until _stat works
 *                          on Nt
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 * NOTES:
 *  The old-format index file was composed of elements of size RM_RECLEN having
 *  the following syntax :-
 *
 *     <element> := <valid-element> | <deleted-element>
 *     <valid-element> := <8.3filename> <padding>
 *     <deleted-element> := <padding>
 *	   where,
 *	       <padding> is series of (RM_RECLEN - sizeof(8.3filename) 0x00's
 *
 *  If the first RM_RECLEN bytes of the index file match the new index file
 *  header then the index file has new-format.
 *
 *  The new-format index file is composed of elements of size (n * RM_RECLEN)
 *  having the following syntax :-
 *
 *	<header>	  := <0x00> <magic> <version> <0x00> <first-padding>
 *	<valid-element>   := <longfilename> <padding>
 *	<deleted-element> := <padding>
 *	    where,
 *		<padding> is a series is 0x00 to round off to RM_RECLEN length
 *		<magic> is RM_MAGIC (currently IX)
 *		<version> is RM_VERSION (currently 1.01)
 *  When <longfilename> is a multiple of RM_RECLEN then an extra padding record
 *  is added to make it a NULL terminated string.
 *
 */


#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <rm.h>
#include <string.h>
#include <time.h>
#include <direct.h>
#include <malloc.h>

/* we open the index corresponding to the named directory and release all
 * the deleted files present.  At the end, we remove the index and the deleted
 * directory */
long fexpunge (pDir, list)
char *pDir;
FILE *list;
{
    int fhidx;
    char *dir;              /* deleted dir */
    char *szRec;            /* name of file deleted */
    char *idx;              /* name of index */
    char *file;
    long totbytes;
    struct _stat statbuf;

    totbytes = 0L;
    dir = idx = file = szRec = NULL;
    if ((dir = (*tools_alloc) (MAX_PATH)) == NULL ||
        (idx = (*tools_alloc) (MAX_PATH)) == NULL ||
        (file = (*tools_alloc) (MAX_PATH)) == NULL ||
        (szRec = (*tools_alloc) (MAX_PATH)) == NULL) {
        if (list)
            fprintf (list, "Unable to allocate storage\n");
        goto done;
    }

    /* generate deleted directory name from dir */
    strcpy (dir, pDir);
    pathcat (dir, RM_DIR);
    /* generate index name from deleted directory */
    strcpy (idx, dir);
    pathcat (idx, RM_IDX);
    /* try to open index.  If it fails, no problem */
    if ((fhidx = _open (idx, O_RDWR | O_BINARY)) != -1) {
        if (list)
            fprintf (list, "Expunging files in %s\n", pDir);

        readIdxRec (fhidx, szRec);
        if (fIdxHdr (szRec))
            if (!readNewIdxRec (fhidx, szRec, MAX_PATH))
                goto done;
        do {
            /* For each file that was RMed and not UNDELed */
            if (szRec[0] != '\0') {
                /* The name starts earlier than current position in the index
                 * file. The deleted file index is derived from the current
                 * offset and the length of the string.
                 */
                sprintf (file, "%s\\deleted.%03x", dir, (_lseek (fhidx, 0L, SEEK_CUR)
                                                         - strlen (szRec)) / RM_RECLEN);


                if (_stat (file, &statbuf) == -1) {
                    if (list)
                        fprintf (list, " (%s - %s)\n", file, error ());
                } else {
                    _unlink (file);
                    totbytes += statbuf.st_size;
                    if (list) {
                        char *pTime = ctime (&statbuf.st_mtime);

                        /* ctime() returns a string which has a \n at
                         * fixed offset of 24. [ANSI draft]. We don't need
                         * it because we put the File Name before \n
                         */
                        *(pTime + 24) = '\0';
                        upd (dir, szRec, file);
                        fprintf (list, "%8ld %s  %s\n", statbuf.st_size, pTime,
                                 file);
                        fflush (list);
                    }
                }
            }
        } while (readNewIdxRec (fhidx, szRec, MAX_PATH));

        _close (fhidx);
        _unlink (idx);
        if (_rmdir (dir))
            fprintf (list, "ERROR: Unable to remove directory %s - %s\n", dir, error ());
        if (list)
            fprintf (list, "%ld bytes freed\n", totbytes);
    } else
        if (!_stat (dir, &statbuf))
        fprintf (list, "Warning: Cannot open %s - %s\n", idx, error ());
    done:
    if (dir)
        free (dir);
    if (idx)
        free (idx);
    if (file)
        free (file);
    if (szRec)
        free (szRec);
    return totbytes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\exetype.c ===
/*
 *  exeType( filename ) -   Return the type of .EXE, based on a quick
 *			    examination of the header.	If it is a new .EXE
 *			    and the OS ( Windows, DOS 4.X, 286DOS ) cannot
 *			    be guessed accurately, just return "new exe".
 *
 *  The algorithm is:
 *
 *	if ( File is too short for old-style header )	==> NOT AN EXE
 *	if ( MZ signature not found )			==> NOT AN EXE
 *	if ( Offset of relocation table != 0x40 )	==> Old-style .EXE
 *	if ( File is too short for new-style header )	==> NOT AN EXE
 *	if ( New Magic number is wrong )		==> Old-stype .EXE
 *	if ( Dynalink flag set )			==> Dyna-link lib
 *	if ( minalloc in old header is 0xFFFF ) 	==> 286DOS .EXE
 *	if ( Import table is empty )			==> DOS 4 .EXE
 *	if ( Resource Table is not empty )		==> Windows .EXE
 *	if ( Stub loader is present )
 *	   if ( "This" is at 0x4E )			==> 286DOS .EXE
       else 					==> Bound .EXE
 *	else						==> New-style .EXE
 *
 *--------------------------------------------------------------------------
 *  strExeType( number ) - number is a value returned from exeType, and
 *			   a standard string associated with that type
 *			   is returned.
*/
#include <fcntl.h>
#include <io.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <share.h>
#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>


enum exeKind exeType( f )
char * f;
{
    struct exe_hdr oldhdr;
    struct new_exe newhdr;
    int fh, br;
    enum exeKind retc;
    char defstubmsg[4];

    errno = 0;
    if ( (fh = _sopen( f, O_RDONLY | O_BINARY, SH_DENYWR )) == -1 )
        return IOERROR;

    br = _read( fh, (char *)&oldhdr, sizeof oldhdr );

    if ( br != sizeof oldhdr || E_MAGIC(oldhdr) != EMAGIC ) {
        retc = NOTANEXE;
    } else {
        if ( E_LFARLC(oldhdr) == ENEWEXE ) {
            if (_lseek( fh, E_LFANEW(oldhdr), SEEK_SET) == -1) {
                retc=NOTANEXE;
            } else {
                br = _read( fh, (char *)&newhdr, sizeof newhdr );

                if ( br != sizeof newhdr ) retc = OLDEXE;
                else if ( NE_MAGIC(newhdr) == NTMAGIC )     
                    retc = NTEXE;
                else if ( NE_MAGIC(newhdr) != NEMAGIC )     
                    retc = OLDEXE;
                else if ( NE_FLAGS(newhdr) & NENOTP )       
                    retc = DYNALINK;
                else if ( E_MINALLOC(oldhdr) == 0xFFFF )    
                    retc = DOS286;
                else if ( NE_ENTTAB(newhdr) - NE_IMPTAB(newhdr) == 0 ) 
                    retc = DOS4;
                else if ( NE_RESTAB(newhdr) - NE_RSRCTAB(newhdr) )
                    retc = WINDOWS;
                else if ( E_LFANEW(oldhdr) != ENEWEXE ) {
                    if (_lseek( fh, (long)NEDEFSTUBMSG, SEEK_SET ) == -1) {
                        retc = NOTANEXE;
                    } else {
                        if (_read( fh, defstubmsg, 4 ) == -1) {
                            retc = NOTANEXE; 
                        } else {
                            if ( !strncmp (defstubmsg, "This", 4)) {
                                retc = DOS286;
                            } else {
                                retc = BOUNDEXE;
                            }
                        }
                    }
                } else {
                    retc = NEWEXE;
                }
            }
        } else {
            retc = OLDEXE;
        }
    }

    _close(fh);
    return retc;
}

char * strExeType (exenum)
enum exeKind exenum;
{
    switch ( exenum ) {
        case IOERROR:   return "???????";   break;
        case NOTANEXE:  return "Not_EXE";   break;
        case OLDEXE:    return "DOS";       break;
        case NEWEXE:    return "New";       break;
        case WINDOWS:   return "Windows";   break;
        case DOS4:      return "Dos4";      break;
        case DOS286:    return "Protect";   break;
        case BOUNDEXE:  return "Bound";     break;
        case DYNALINK:  return "DynaLink";  break;
        case NTEXE:     return "NT";        break;
        default:        return "Unknown";   break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fastcopy.c ===
/*  fastcopy - use multiple threads to whack data from one file to another
 *
 *  Modifications:
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *      21-Nov-1990 w-barry Updated API's to the Win32 set.
 */
#define INCL_DOSPROCESS
#define INCL_DOSSEMAPHORES

#include <stdio.h>
#include <process.h>
#include <windows.h>
#include <tools.h>
#include <malloc.h>

#define BUFSIZE     0xFE00              /*  full segment minus sector         */
#define STACKSIZE   256                 /*  stack size for child thread       */

typedef struct BUF BUF;

struct BUF {
    BOOL  flag;
    DWORD cbBuf;
    BUF  *fpbufNext;
    BYTE  ach[BUFSIZE];
    };

#define LAST    TRUE
#define NOTLAST FALSE

static HANDLE            hevQNotEmpty;
static CRITICAL_SECTION  hcrtQLock;
//static HMTX            hmtxQLock;
//static HEV             hevQNotEmpty;
static BUF              *fpbufHead = NULL;
static BUF              *fpbufTail = NULL;
static HANDLE            hfSrc, hfDst;
static HANDLE            hThread;
static BOOLEAN           fAbort;

/*  forward type definitions
 */

NPSZ  writer( void );
DWORD reader( void );
BUF  *dequeue( void );
void  enqueue( BUF *fpbuf );
char *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm );

NPSZ writer ()
{
    BUF *fpbuf;
    DWORD cbBytesOut;
    BOOL f = !LAST;
    NPSZ npsz = NULL;

    while (f != LAST && npsz == NULL) {
        fpbuf = dequeue ();
        if ((f = fpbuf->flag) != LAST) {
            if( !WriteFile( hfDst, fpbuf->ach, fpbuf->cbBuf, &cbBytesOut, NULL) ) {
                npsz = "WriteFile: error";
            } else if( cbBytesOut != ( DWORD )fpbuf->cbBuf ) {
                npsz = "WriteFile: out-of-space";
            }
        } else {
            npsz = *(NPSZ *)fpbuf->ach;
        }
        LocalFree(fpbuf);
    }
    if ( f != LAST ) {
        fAbort = TRUE;
    }
    WaitForSingleObject( hThread, (DWORD)-1 );
    CloseHandle( hThread );
    CloseHandle(hevQNotEmpty);
    DeleteCriticalSection(&hcrtQLock);
    return npsz;
}


DWORD reader()
{
    BUF *fpbuf;
    BOOL f = !LAST;

    while ( !fAbort && f != LAST) {
        if ( (fpbuf = LocalAlloc(LMEM_FIXED,sizeof(BUF)) ) == 0) {
            printf ("LocalAlloc error %ld\n",GetLastError());
            exit (1);
        }
        f = fpbuf->flag = NOTLAST;
        if ( !ReadFile( hfSrc, fpbuf->ach, BUFSIZE, &fpbuf->cbBuf, NULL) || fpbuf->cbBuf == 0) {
            f = fpbuf->flag = LAST;
            *(NPSZ *)fpbuf->ach = NULL;
        }
        enqueue (fpbuf);
    }
    return( 0 );
}

BUF *dequeue( void )
{
    BUF *fpbuf;

    while (TRUE) {

        if (fpbufHead != NULL) {
            EnterCriticalSection( &hcrtQLock );
            fpbufHead = (fpbuf = fpbufHead)->fpbufNext;
            if( fpbufTail == fpbuf ) {
                fpbufTail = NULL;
            }
            LeaveCriticalSection( &hcrtQLock );
            break;
        }

        /*
           the head pointer is null so the list is empty.
           block on eventsem until enqueue posts (ie. adds to queue)
        */

        WaitForSingleObject( hevQNotEmpty, (DWORD)-1 );
    }
    return fpbuf;
}

void enqueue( BUF *fpbuf )
{
    fpbuf->fpbufNext = NULL;

    EnterCriticalSection( &hcrtQLock );

    if( fpbufTail == NULL ) {
        fpbufHead = fpbuf;
    } else {
        fpbufTail->fpbufNext = fpbuf;
    }
    fpbufTail = fpbuf;
    LeaveCriticalSection( &hcrtQLock );

    SetEvent( hevQNotEmpty );
}

/*  fastcopy - copy data quickly from one handle to another
 *
 *  hfSrcParm       file handle to read from
 *  hfDstParm       file handle to write to
 *
 *  returns         NULL if successful
 *                  pointer to error string otherwise
 */
char *fastcopy( HANDLE hfSrcParm, HANDLE hfDstParm)
{
    DWORD dwReader;

    hfSrc = hfSrcParm;
    hfDst = hfDstParm;


    hevQNotEmpty = CreateEvent( NULL, (BOOL)FALSE, (BOOL)FALSE,NULL );
    if ( hevQNotEmpty == INVALID_HANDLE_VALUE ) {
        return NULL;
    }
    InitializeCriticalSection( &hcrtQLock );

    fAbort = FALSE;
    hThread = CreateThread( 0, STACKSIZE, (LPTHREAD_START_ROUTINE)reader, 0, 0, &dwReader );
    if( hThread == INVALID_HANDLE_VALUE ) {
        return "can't create thread";
    }
    return( writer() );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fgetl.c ===
/*  fgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 *	28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *      18-Oct-1990 w-barry Removed 'dead' code.
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/*
 * returns line from file (no CRLFs); returns NULL if EOF
 */

char * __cdecl
fgetl (buf, len, fh)
char *buf;
int len;
FILE *fh;
{
    int c;
    char *pch;
    int cchline;

    pch = buf;
    cchline = 0;

    while (TRUE) {
        c = getc (fh);

        //
        //  if there are no more characters, end the line
        //

        if (c == EOF)
            break;

        //
        //  if we see a \r, we ignore it
        //

        if (c == '\r')
            continue;

        //
        //  if we see a \n, we end the line
        //

        if (c == '\n')
            break;

        //
        //  if the char is not a tab, store it
        //

        if (c != '\t') {
            *pch++ = (char) c;
            cchline++;
        }

        //
        //  otherwise, expand the tab (up to length of buffer)
        //

        else {
            c = (int) min (8 - ((pch - buf) & 0x7), len - 1 - cchline);
            memset (pch, ' ', c);
            pch += c;
            cchline += c;
        }

        //
        //  if the line is too long, end it now
        //

        if (cchline >= len - 1)
            break;
    }

    //
    //	end the line
    //

    *pch = 0;

    //
    //	return NULL at EOF with nothing read
    //

    return ((c == EOF) && (pch == buf)) ? NULL : buf;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fmove.c ===
/* fmove.c - fast copy between two file specs
 *
 *   5/10/86  daniel lipkie     Added frenameNO.  fmove uses frenameNO
 * 17-Oct-90  w-barry           Switched 'C'-runtime function 'rename' for
 *                              private version 'rename' until DosMove
 *                              is completely implemented.
 *
 */

#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <malloc.h>
#include <dos.h>
#include <io.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <errno.h>


/* extern int errno; */

#define IBUF    10240


/* frenameNO (newname, oldname) renames a file from the oldname to the
 * newname.  This interface parallels the C rename function in the
 * pre version 4.0 of C.  The rename function changed the order of the
 * params with version 4.0.  This interface isolates the change.
 * pre-4.0: rename (newname, oldname)
 * 4.0:     rename (oldname, newname);
 */
int frenameNO(strNew, strOld)
char *strNew, *strOld;
{
    return( rename(strOld, strNew) ); /* assumes we are compiling with 4.0 lib */
}

/* fmove (source file, destination file) copies the source to the destination
 * preserving attributes and filetimes.  Returns NULL if OK or a char pointer
 * to the corresponding text of the error
 */
char *fmove (src,dst)
char *src, *dst;
{
    char     *result;
    HANDLE   hSrc;
    int      Res;


    /*  Try a simple rename first
     */
    if ( !rename(src, dst) )
        return NULL;

    if ( GetFileAttributes(src) == 0xFFFFFFFF ) {
        return "Source file does not exist";
    }

    /*  Try to fdelete the destination
     */

    /* We used to fdelete(dst) unconditionally here.
       In case src and dst are the same file, but different filenames (e.g. UNC name vs. local name),
          fdelete(dst) will delete src.
       To fix this, we will lock the src before deleting dst.
    */

    hSrc = CreateFile(
                     src,
                     GENERIC_READ,
                     0,              /* don't share src */
                     NULL,
                     OPEN_EXISTING,
                     0,
                     NULL
                     );

    Res = fdelete (dst);

    if (hSrc != INVALID_HANDLE_VALUE) {
        CloseHandle(hSrc);
    }

    if (Res > 2) {
        return "Unable to delete destination";
    }

    /*  Destination is gone.  See if we can simply rename again
     */
    if (rename(src, dst) == -1) {
        /*  If the error isn't different device then just return
         *  the error
         */
        if (errno != EXDEV) {
            return error ();
        } else
            /*  Try a copy across devices
             */
            if ((result = fcopy (src, dst)) != NULL)
            return result;

        /*  Cross-device copy worked.  Must delete source
         */
        fdelete (src);
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\find.c ===
/* find.c - MSDOS find first and next matching files
 */

/*  ffirst - begin find enumeration given a pattern
 *
 *  file    char pointer to name string with pattern in last component.
 *  attr    inclusive attributes for search
 *  fbuf    pointer to buffer for find stuff
 *
 *  returns (DOS) TRUE if error, FALSE if success
 *              (OS2) error code or STATUS_OK
 */

/*  fnext - continue find enumeration
 *
 *  fbuf    pointer to find buffer
 *
 *  returns (DOS) TRUE if error, FALSE if success
 *              (OS2) error code or STATUS_OK
 */

/*  findclose - release system resources upon find completion
 *
 *  Allows z runtime and filesystem to release resources
 *
 *  fbuf    pointer to find buffer
 */

#define INCL_DOSERRORS
#define INCL_DOSMODULEMGR


#include <malloc.h>
#include <string.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <tools.h>


//
//  Under OS/2, we always return entries that are normal, archived or
//  read-only (god knows why).
//
//  SRCHATTR contains those attribute bits that are used for matching.
//
#define SRCHATTR    (FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_DIRECTORY)
BOOL AttributesMatch( NPFIND fbuf );

#define NO_MORE_FILES       FALSE
#define STATUS_OK            TRUE

BOOL     usFileFindNext (NPFIND fbuf);

/*  returns error code or STATUS_OK
 */
ffirst (file, attr, fbuf)
char *file;
int attr;
NPFIND fbuf;
{
    DWORD erc;

    fbuf->type = FT_DONE;

    {   NPSZ p = file;

        UNREFERENCED_PARAMETER( attr );

        /*  We need to handle the following cases:
         *
         *  [D:]\\pattern
         *  [D:]\\machine\pattern
         *  [D:]\\machine\share\pattern
         *  [D:]path\pattern
         */

        /*  skip drive
         */
        if (p[0] != 0 && p[1] == ':')
            p += 2;

    }

    {
        fbuf->type = FT_FILE;
        fbuf->attr = attr;
        erc = ( ( fbuf->dir_handle = FindFirstFile( file, &( fbuf->fbuf ) ) ) == (HANDLE)-1 ) ? 1 : 0;
        if ( (erc == 0) && !AttributesMatch( fbuf ) ) {
            erc = fnext( fbuf );
        }
    }

    if ( fbuf->dir_handle != (HANDLE)-1 ) {
        if (!IsMixedCaseSupported (file)) {
            _strlwr( fbuf->fbuf.cFileName );
        } else {
            SETFLAG( fbuf->type, FT_MIX );
        }
    }

    return erc;
}

fnext (fbuf)
NPFIND fbuf;
{
    int erc;

    switch (fbuf->type & FT_MASK ) {
        case FT_FILE:
            erc = !usFileFindNext (fbuf);
            break;

        default:
            erc = NO_MORE_FILES;
    }

    if ( erc == STATUS_OK && !TESTFLAG( fbuf->type, FT_MIX ) ) {
        _strlwr (fbuf->fbuf.cFileName);
    }
    return erc;
}

void findclose (fbuf)
NPFIND fbuf;
{
    switch (fbuf->type & FT_MASK ) {
        case FT_FILE:
            FindClose( fbuf->dir_handle );
            break;


    }
    fbuf->type = FT_DONE;
}


BOOL AttributesMatch( NPFIND fbuf )
{
    //
    //  We emulate the OS/2 behaviour of attribute matching. The semantics
    //  are evil, so I provide no explanation.
    //
    fbuf->fbuf.dwFileAttributes &= (0x000000FF & ~(FILE_ATTRIBUTE_NORMAL));

    if (! ((fbuf->fbuf.dwFileAttributes & SRCHATTR) & ~(fbuf->attr))) {
        return TRUE;
    } else {
        return FALSE;
    }
}


/*  Find next routines
 */



BOOL usFileFindNext (NPFIND fbuf)
{

    while ( TRUE ) {
        if ( !FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) ) {
            return FALSE;
        } else if ( AttributesMatch( fbuf ) ) {
            return TRUE;
        }
    }
    // return( FindNextFile( fbuf->dir_handle, &( fbuf->fbuf ) ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\freespac.c ===
/* return amount of freespace on a drive
*
*      09-Dec-1986 bw - Added DOS 5 support
*      18-Oct-1990 w-barry Removed 'dead' code.
*      28-Nov-1990 w-barry Switched to Win32 base (replaced DosQueryFSInfo
*                          with GetDiskFreeSpace )
*/


#include <stdio.h>
#include <windows.h>
#include <tools.h>

__int64 freespac( int d )
{
    char root[5];

    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;

    // Constuct a drive string from the given drive number.
    root[0] = (char)( 'a' + d - 1 );
    root[1] = ':';
    root[2] = '\\';
    root[3] = '\0';

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        return (unsigned long)-1L;
    }

    return( (__int64)cBytesPerSec * (__int64)cSecsPerClus * (__int64)cFreeClus );
}

__int64 sizeround( __int64 l, int d )
{
    char root[5];
    DWORD cSecsPerClus, cBytesPerSec, cFreeClus, cTotalClus;
    __int64 BytesPerCluster;

    root[0] = (char)( 'a' + d - 1 );
    root[1] = ':';
    root[2] = '\\';
    root[3] = '\0';

    if ( !GetDiskFreeSpace( root, &cSecsPerClus, &cBytesPerSec, &cFreeClus, &cTotalClus ) ) {
        return (unsigned long)-1L;
    }

    BytesPerCluster = (__int64)cSecsPerClus * (__int64)cBytesPerSec;
    l += BytesPerCluster - 1;
    l /= BytesPerCluster;
    l *= BytesPerCluster;

    return l;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\forfile.c ===
/* forfile (filename, attr, routine) step through file names calling routine
 *  29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *  24-Feb-1987 bw  Do findclose() to make FAPI happy.
 *
 *  30-Jul-1990 davegi Added prototypes for string functions
 */

#include <string.h>
#include <malloc.h>
#include <stdlib.h>
#include <windows.h>
#include <stdio.h>
#include <tools.h>

int
forfile (
        char *pat,
        int attr,
        void (*rtn)(char *, struct findType *, void *),
        void * args
        )
{
    struct findType *fbuf;
    char *buf;

    if ((fbuf = (struct findType *) (*tools_alloc) (sizeof (struct findType))) == NULL)
        return FALSE;

    if (ffirst (pat, attr, fbuf)) {
        free ((char *) fbuf);
        return FALSE;
    }

    if ((buf = (*tools_alloc) (_MAX_DRIVE + _MAX_DIR + _MAX_FNAME + _MAX_EXT + 1)) == NULL) {
        findclose (fbuf);
        free ((char *) fbuf);
        return FALSE;
    }

    drive (pat, buf);
    path (pat, strend (buf));
    pat = strend (buf);

    do {
        /*  Assume the case correct form has been returned by ffirst/fnext
         */
        strcpy (pat, fbuf->fbuf.cFileName);
        (*rtn) (buf, fbuf, args);
    } while (!fnext (fbuf));

    findclose (fbuf);

    free (buf);
    free ((char *) fbuf);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\forsemi.c ===
/* forsemi.c - walk a semicolon separated string */


#include <stdarg.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>


flagType
__cdecl
forsemi (
    char *p,
    __action_routine__ proc,
    ...
    )

{
    char *p1, c;
    flagType f;
    va_list args;

    va_start( args, proc );

    do {
        p1 = strbscan (p, ";");
        c = *p1;
        *p1 = 0;
        f = (*proc)(p, args);
        p = p1;
        *p++ = c;
        if (f)
            return TRUE;
    } while (c);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\fputl.c ===
/*  fputl.c - write a CRLF line to a file
 */


#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* writes a line to file (with trailing CRLFs) from buf, return <> 0 if
 * writes fail
 */
int
fputl (
      char *buf,
      int len,
      FILE *fh
      )
{
    return ((int)fwrite (buf, 1, len, fh) != len || fputs ("\r\n", fh) == EOF) ? EOF : 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\ntoi.c ===
/* convert an arbitrary based number to an integer */

#include <ctype.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* p points to characters, return -1 if no good characters found
 * and base is 2 <= base <= 16
 */
int
ntoi (
     char *p,
     int base
     )
{
    int i, c;
    flagType fFound;

    if (base < 2 || base > 16)
        return -1;
    i = 0;
    fFound = FALSE;
    while (c = *p++) {
        c = tolower (c);
        if (!isxdigit (c))
            break;
        if (c <= '9')
            c -= '0';
        else
            c -= 'a'-10;
        if (c >= base)
            break;
        i = i * base + c;
        fFound = TRUE;
    }
    if (fFound)
        return i;
    else
        return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\mgetl.c ===
/*  mgetl.c - expand tabs and return lines w/o separators
 *
 *  Modifications
 *	05-Aug-1988 mz	Make exact length lines work correctly
 *
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/*
**  Copies next line from pSrc to buf
**  Removes \r and \n, expands tabs
**  If *pSrc == NULL at entry return NULL
**  else copy line to buf and return char * to next char to be processed
**  from pSrc
**
**      p = pInput;
**      while ( ( p = mgetl ( buf, len, p ) ) )
**          process content of buf
**
**  N.B. buf [ 0 ] == 0 on return does NOT mean end of source, merely that
**  a line of no char was read, e.g. ...\n\n seen in pSrc
**
*/

char *
mgetl (
      char *buf,
      int len,
      char *pSrc
      )
{
    register int c;
    register char *p;

    /* remember NUL at end */
    if ( *pSrc == '\0' ) {
        *buf = 0;
        return NULL;
    }
    len--;
    p = buf;
    while (TRUE) {
        c = *pSrc++;
        if (c == '\0' || c == '\n')
            break;
        if (c != '\r')
            if (len == 0) {
                pSrc--;
                break;
            } else
                if (c != '\t') {
                *p++ = (char) c;
                len--;
            } else {
                c = (int)(min (8 - ((p-buf) & 0x0007), len));
                Fill (p, ' ', c);
                p += c;
                len -= c;
            }
    }
    *p = 0;
    return ( pSrc );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\init.c ===
/*  init.c - routines for managing TOOLS.INI-like files
 *
 *  Modifications
 *      15-Jul-87   danl    Start of section is <optionalwhitespace>[...]
 *      05-Aug-1988 mz      Use buffer equate for swgoto.
 *      05-Jul-1989 bw      Use MAXPATHLEN
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

#define BUFLEN 256

static char *space = "\t ";

/*  fMatchMark - see if a tag in in a mark set
 *
 *  We treat the mark set as a collection of whitespace-separated names
 *
 *  pMark       pointer to mark set (contents modified)
 *  pTag        tag to find
 *
 *  returns     TRUE if match was found
 */
static
flagType
fMatchMark (
           char *pMark,
           char *pTag
           )
{
    char *p, c;

    while (*pMark != 0) {
        pMark = strbscan (p = strbskip (pMark, space), space);
        c = *pMark;
        *pMark = 0;
        if (!_stricmp (p, pTag))
            return TRUE;
        *pMark = c;
    }
    return FALSE;
}


/* returns pointer to tag if line is marker; NULL otherwise */
char *
ismark (
       register char *buf
       )
{
    register char *p;

    buf = strbskip (buf, space);
    if (*buf++ == '[')
        if (*(p = strbscan (buf, "]")) != '\0') {
            *p = 0;
            return buf;
        }
    return NULL;
}

flagType
swgoto (
       FILE *fh,
       char *tag
       )
{
    char buf[BUFLEN];

    if (fh) {
        while (fgetl (buf, BUFLEN, fh) != 0) {
            register char *p;

            if ((p = ismark (buf)) != NULL) {
                if (fMatchMark (p, tag))
                    return TRUE;
            }
        }
    }
    return FALSE;
}

/* returns fh of file if tag found, else NULL */
FILE *
swopen (
       char *file,
       char *tag
       )
{
    FILE *fh;
    char buf[MAX_PATH];
    char buftmp[MAX_PATH]= {0};

    strncat(buftmp, file, MAX_PATH-1);

    if ((fh = pathopen (buftmp, buf, "rb")) == NULL)
        return NULL;

    if (swgoto (fh, tag))
        return fh;

    fclose (fh);
    return NULL;
}

/* close a switch file */
swclose (
        FILE *fh
        )
{
    return fclose (fh);
}

/* read a switch line; return NULL if end of file.  Skips leading spaces
 * and lines that begin with ; and blank lines
 */
swread (
       char *buf,
       int len,
       FILE *fh
       )
{
    register char *p;

    while (fgetl (buf, len, fh) != 0)
        if (ismark (buf) != NULL)
            return 0;
        else {
            p = strbskip (buf, space);
            if (*p != 0 && *p != ';') {
                strcpy (buf, p);
                return -1;
            }
        }
    return 0;
}

/* Reads lines from the file fh looking in the section pstrTag for one with
 * "entry=" and if there are non-white space characters following the '='
 * a copy of these characters is returned else NULL is returned.
 *
 * If fh == 0 then the file $USER:\TOOLS.INI is used as the switch file
 *
 * If a non-NULL value is returned, it should eventually be free'd.
 *
 * N.B. if there are only white space characters, space and tab, following
 * the '=', NULL is returned
 *
 */
char *
swfind (
       char *pstrEntry,
       FILE *fh,
       char *pstrTag
       )
{
    char *p;
    char *q;
    FILE *fhIn = fh;
    char buf[BUFLEN];

    q = NULL;
    if (fh != NULL || (fh = swopen ("$INIT:\\TOOLS.INI", pstrTag))) {
        while (swread (buf, BUFLEN, fh) != 0 && !ismark(buf) ) {
            if ( *(p = strbscan (buf, "=" )) ) {
                *p++ = '\0';
                if (!strcmpis (buf, pstrEntry)) {
                    if (*(p = strbskip (p, space)))
                        q = _strdup (p);
                    break;
                }
            }
        }
    }
    if (fhIn == NULL && fh != NULL)
        swclose (fh);
    return q;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\match.c ===
#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>

flagType
fMatch (
       char *pat,
       char *text
       )
{
    switch (*pat) {
        case '\0':
            return (flagType)( *text == '\0' );
        case '?':
            return (flagType)( *text != '\0' && fMatch (pat + 1, text + 1) );
        case '*':
            do {
                if (fMatch (pat + 1, text))
                    return TRUE;
            } while (*text++);
            return FALSE;
        default:
            return (flagType)( toupper (*text) == toupper (*pat) && fMatch (pat + 1, text + 1) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\pathchr.c ===
/* pathchr.c - return configuration dependent info on MSDOS
 *
 *  09-Dec-1986 bw - Added DOS 5 support
 *  27-Jan-1987 bw - Make bindable by removing DOSQSWITCHAR call
 *  27-Apr-1987 bw - Make unbindable again.
 *  29-May-1987 bw - Remove DOSQSWITCHAR completely ( it's gone from OS/2 )
 *  08-Aug-1989 bw - Make '-' and '/' switches.
 *  18-Oct-1990 w-barry Removed 'dead' code.
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>


char
fPathChr(
        int c
        )
{
    return (char)( c == '\\' || c == '/' );
}

char
fSwitChr(
        int c
        )
{
    return (char)( c == '/' || c == '-' );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\pathcat.c ===
/***	pathcat.c - concatenate a string onto another, handing path seps
 *
 *	Modifications
 *	    23-Nov-1988 mz  Created
 */


#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>

/**	pathcat - handle concatenation of path strings
 *
 *	Care must be take to handle:
 *	    ""	    XXX     =>	XXX
 *	    A	    B	    =>	A\B
 *	    A\      B	    =>	A\B
 *	    A	    \B	    =>	A\B
 *	    A\      \B	    =>	A\B
 *
 *	pDst	char pointer to location of 'A' above
 *	pSrc	char pointer to location of 'B' above
 *
 *	returns pDst
 */
char *
pathcat (
        char *pDst,
        char *pSrc
        )
{
    /*	If dest is empty and src begins with a drive
     */
    if (*pDst == '\0')
        return strcpy (pDst, pSrc);

    /*	Make destination end in a path char
     */
    if (*pDst == '\0' || !fPathChr (strend (pDst)[-1]))
        strcat (pDst, PSEPSTR);

    /*	Skip leading path separators on source
     */
    while (fPathChr (*pSrc))
        pSrc++;

    return strcat (pDst, pSrc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\pname.c ===
/***	pname.c - form a "pretty" version of a user file name
 *
 *	OS/2 v1.2 and later will allow filenames to retain the case
 *	when created while still being case insensitive for all operations.
 *	This allows the user to create more visually appealing file names.
 *
 *	All runtime routines should, therefore, preserve the case that was
 *	input.	Since the user may not have input in the case that the entries
 *	were created, we provide a service whereby a pathname is adjusted
 *	to be more visually appealing.	The rules are:
 *
 *	if (real mode)
 *	    lowercase it
 *	else
 *	if (version is <= 1.1)
 *	    lowercase it
 *	else
 *	if (filesystem is FAT)
 *	    lowercase it
 *	else
 *	    for each component starting at the root, use DosFindFirst
 *		to retrieve the original case of the name.
 *
 *	Modifications:
 *	    10-Oct-1989 mz  First implementation
 *
 *	    03-Aug-1990 davegi	Removed dynamic linking to DosQueryPathInfo
 *				on the assumption that it will always be
 *				there on a 32-bit OS/2 (OS/2 2.0)
 *          18-Oct-1990 w-barry Removed 'dead' code.
 *          24-Oct-1990 w-barry Changed PFILEFINDBUF3 to FILEFINDBUF3 *.
 *
 */

#define INCL_ERRORS
#define INCL_DOSFILEMGR
#define INCL_DOSMODULEMGR


#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <malloc.h>
#include <windows.h>
#include <tools.h>

//
//  Form pretty name in place.  There must be sufficient room to handle
//  short-name expansion
//

char *
pname (
      char *pszName
      )
{
    HANDLE handle;
    WIN32_FIND_DATA findbuf;
    char PrettyName[MAX_PATH];
    char *Name = pszName;
    char *Pretty = PrettyName;
    char *ComponentEnd;
    char SeparatorChar;
    char *Component;

    if (!IsMixedCaseSupported (pszName))
        return _strlwr (pszName);

    //
    //  Walk forward through the name, copying components.  As 
    //  we process a component, we let the underlying filesystem
    //  tell us the correct case and expand short to long name
    //

    //
    //  If there's a drive letter copy it
    //
    
    if (Name[0] != '\0' && Name[1] == ':') {
        *Pretty++ =  *Name++;
        *Pretty++ =  *Name++;
    }

    
    while (TRUE) {
        
        //
        //  If we're at a separator
        //      Copy it
        //
        
        if (*Name == '/' || *Name == '\\' || *Name == '\0') {
            if (Pretty >= PrettyName + MAX_PATH) {
                break;
            }
            *Pretty++ = *Name++;
            if (Name[-1] == '\0') {
                strcpy( pszName, PrettyName );
                break;
            }
            continue;
        }

        //
        //  We're pointing to the first character of a component.
        //  Find the terminator, save it and terminate the component.
        //

        ComponentEnd = strbscan( Name, "/\\" );
        SeparatorChar = *ComponentEnd;
        *ComponentEnd = '\0';

        //
        //  If there's no meta chars and it's not . and not .. and if we can find it
        //
          
        if ( *strbscan( Name, "*?" ) == 0 &&
             strcmp( Name, "." ) &&
             strcmp( Name, ".." ) &&
             (handle = FindFirstFile( pszName, &findbuf )) != INVALID_HANDLE_VALUE) {

            Component = findbuf.cFileName;

            FindClose( handle );
        } else {
            Component = Name;
        }

        //
        //  Pretty points to where the next component name should be placed
        //  Component points to the appropriate text.  If there's not enough
        //  room, we're done 
        //

        if (Pretty + strlen( Component ) + 1 > Pretty + MAX_PATH) {
            break;
        }

        //
        //  Copy the component in, advance destination and source
        //
        
        strcpy( Pretty, Component );
        Pretty += strlen( Pretty );
        Name = ComponentEnd;
        *Name = SeparatorChar;
    }

    return pszName;
}

/*	IsMixedCaseSupported - determine if a file system supports mixed case
 *
 *	We presume that all OS's prior to OS/2 1.2 or FAT filesystems
 *	do not support mixed case.  It is up to the client to figure
 *	out what to do.
 *
 *	We presume that non FAT filesystems on 1.2 and later DO support mixed
 *	case
 *
 *	We do some caching to prevent redundant calls to the file systems.
 *
 *	returns     TRUE    (MCA_SUPPORT) if it is supported
 *		    FALSE   (MCA_NOTSUPP) if unsupported
 *
 */
#define MCA_UNINIT	123
#define MCA_SUPPORT	TRUE
#define MCA_NOTSUPP	FALSE

static  WORD mca[27] = { MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT,
    MCA_UNINIT, MCA_UNINIT, MCA_UNINIT};


WORD
QueryMixedCaseSupport (
                      char *psz
                      )
{
    UNREFERENCED_PARAMETER( psz );

    return MCA_SUPPORT;


    //BYTE*   pUpdPath;
    //
    //UNREFERENCED_PARAMETER( psz );
    //
    ///*  If OS/2 before 1.2, presume no mixed case support
    // */
    //if (_osmajor < 10 || (_osmajor == 10 && _osminor < 2))
    //return MCA_NOTSUPP;
    //
    //pUpdPath = (*tools_alloc) (MAX_PATH);
    //if (pUpdPath == NULL)
    //return MCA_NOTSUPP;
    //
    //return MCA_NOTSUPP;
}

WORD
IsMixedCaseSupported (
                     char *psz
                     )
{
    WORD mcaSupp;
    DWORD  ulDrvOrd;
    BOOL fUNC;

    fUNC = (BOOL)( ( fPathChr( psz[0] ) && fPathChr( psz[1] ) ) ||
                   ( psz[0] != 0 && psz[1] == ':' &&
                     fPathChr( psz[2] ) && fPathChr( psz[3] ) ) );

    /*	Obtain drive ordinal and return cached value if valid
     */
    if (!fUNC) {
        if (psz[0] != 0 && psz[1] == ':') {
            ulDrvOrd = (tolower(psz[0]) | 0x20) - 'a' + 1;
        } else {
            char buf[MAX_PATH];

            GetCurrentDirectory( MAX_PATH, buf );
            ulDrvOrd = (tolower(buf[0]) | 0x20 ) - 'a' + 1;
        }

        if (mca[ulDrvOrd] != MCA_UNINIT) {
            return mca[ulDrvOrd];
        }
    }

    /*	Get support value
     */
    mcaSupp = QueryMixedCaseSupport (psz);

    if (!fUNC)
        mca[ulDrvOrd] = mcaSupp;

    return mcaSupp;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\pathopen.c ===
/* reasonable imitation of logical names
 *
 *      4/14/86     dl  findpath: test for trailing && leading \ before
 *                          appending a \
 *      29-Oct-1986 mz  Use c-runtime instead of Z-alike
 *      03-Sep-1987 dl  fPFind: rtn nonzero iff exists AND is ordinary file
 *                      i.e., return false for directories
 *      11-Sep-1987 mz  Remove static declaration from findpath
 *      01-Sep-1988 bw  Allow $filenam.ext as a filename in findpath
 *      23-Nov-1988 mz  Use pathcat, allow $(VAR)
 *
 *      30-Jul-1990 davegi  Removed unreferenced local vars
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <windows.h>
#include <tools.h>
#include <sys/types.h>
#include <sys\stat.h>
#include <stdlib.h>
#include <string.h>

/* iterative routine takes args as pbuf, pfile */
flagType
fPFind (
       char *p,
       va_list ap
       )
{
    //
    //  pArg is a pointer to an argument list. The first argument is a
    //  pointer to the file name. The second argument is a pointer to
    //  a buffer.
    //
    char    *pa[2];

    pa[1] = (char *)va_arg(ap, PCHAR);
    pa[0] = (char *)va_arg(ap, PCHAR);

    va_end(ap);

    /*  p == dir from env variable expansion or null
     *  pa[1] == file name
     *  pa[0] == buffer for getting p\pa[1] or pa[1] if p null
     */

    strcpy ((char *)pa[0], p);
    pathcat ((char *) pa[0], (char *) pa[1]);

    {
        HANDLE TmpHandle;
        WIN32_FIND_DATA buffer;

        TmpHandle = FindFirstFile((LPSTR)pa[0],&buffer);

        if (TmpHandle == INVALID_HANDLE_VALUE) {
            return FALSE;
        }

        FindClose(TmpHandle);

        if ((buffer.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            return FALSE;
        }

        //struct stat sbuf;
        //if (stat ((char *)pa[0], &sbuf) == -1)
        //    return FALSE;
        //if ((sbuf.st_mode & S_IFREG) == 0)
        //    return FALSE;
    }
    pname ((char *) pa[0]);
    return TRUE;
}

static char szEmpty[2] = {'\0', '\0'};

/*  $ENV:foo uses pathcat
 *  foo uses strcat
 */
flagType
findpath(
        char *filestr,
        char *pbuf,
        flagType fNew
        )
{
    char *p;
    char c, *pathstr;
    char envVarName[ MAX_PATH ];

    /*  Set pathstr to be text to walk or empty.
     *  Set filestr to be file name to look for.
     */
    pathstr = NULL;

    /*  Are we starting $ENV: or $(ENV)?
     */
    if ( *filestr == '$' ) {
        envVarName[ 0 ] = '\0';

        /*  Are we starting $(ENV)?
         */
        if (filestr[1] == '(') {

            /*  Do we have $(ENV)?
             */
            if (p = strchr (filestr, ')')) {
                filestr += 2;
                strncpy (envVarName, filestr, (unsigned)(p-filestr));
                envVarName[p-filestr] = '\0';
                pathstr = getenvOem (envVarName);
                filestr = ++p;
            }
        } else if (p = strchr (filestr, ':')) {
            /*  Do we have $ENV: ?
             */
            filestr += 1;
            strncpy (envVarName, filestr, (unsigned)(p-filestr));
            envVarName[p-filestr] = '\0';
            pathstr = getenvOem (envVarName);
            filestr = ++p;
        }
    }

    /*  Convert pathstr into true string
     */
    if (pathstr == NULL) {
        pathstr = (char *)szEmpty;
    }

    /*  If we find an existing file in the path
     */
    if (forsemi (pathstr, fPFind, filestr, pbuf)) {
        return TRUE;
    }

    /*  If this is not a new file
     */
    if ( !fNew ) {
        return FALSE;
    }

    /*  File does not exist.  Take first dir from pathstr and use it
     *  as prefix for result
     */
    p = strchr (pathstr, ';');
    if (p) {
        strncpy(pbuf, pathstr, (unsigned)(p - pathstr));
        pbuf[p - pathstr] = '\0';
    } else {
        strcpy(pbuf, pathstr);
    }

    if (*pbuf == 0) {
        strcat (pbuf, filestr);
    } else {
        pathcat (pbuf, filestr);
    }

    return TRUE;
}

FILE *
pathopen (
         char *name,
         char *buf,
         char *mode
         )
{
    return findpath (name, buf, TRUE) ? fopen (buf, mode) : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\reparse.c ===
/*  reparse.c - parse a regular expression
 *
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc reparse.c
 *
 *  Modifications:
 *
 *	22-Jul-1986 mz	Hookable allocator (allow Z to create enough free space)
 *	19-Nov-1986 mz	Add RETranslateLength for Z to determine overflows
 *	18-Aug-1987 mz	Add field width and justification in translations
 *	01-Mar-1988 mz	Add in UNIX-like syntax
 *	14-Jun-1988 mz	Fix file parts allowing backslashes
 *	04-Dec-1989 bp	Let :p accept uppercase drive names
 *	20-Dec-1989 ln	capture trailing periods in :p
 *	23-Jan-1990 ln	Handle escaped characters & invalid trailing \ in
 *			RETranslate.
 *
 *	28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *			    Changed Move to memmove (OS/2 2.0)
 *      19-Oct-1990 w-barry changed cArg to unsigned int from int.
 */
#include <ctype.h>

#include <stdio.h>
#include <malloc.h>
#include <stdlib.h>
#include <string.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#include "re.h"

#if DEBUG
    #define DEBOUT(x)   printf x; fflush (stdout)
#else
    #define DEBOUT(x)
#endif


/*  regular expression compiler.  A regular expression is compiled into pseudo-
 *  machine code.  The principle is portable to other machines and is outlined
 *  below.  We parse by recursive descent.
 *
 *  The pseudo-code is fairly close to normal assembler and can be easily
 *  converted to be real machine code and has been done for the 80*86
 *  processor family.
 *
 *  The basic regular expressions handled are:
 *
 *	letter	    matches a single letter
 *	[class]     matches a single character in the class
 *	[~class]    matches a single character not in the class
 *	^	    matches the beginning of the line
 *	$	    matches the end of the line
 *	?	    matches any character (except previous two)
 *	\x	    literal x
 *	\n	    matches the previously tagged/matched expression (n digit)
 *
 *  Regular expressions are now build from the above via:
 *
 *	x*	    matches 0 or more x, matching minimal number
 *	x+	    matches 1 or more x, matching minimal number
 *	x@	    matches 0 or more x, matching maximal number
 *	x#	    matches 1 or more x, matching maximal number
 *	(x1!x2!...) matches x1 or x2 or ...
 *	~x	    matches 0 characters but prevents x from occuring
 *	{x}	    identifies an argument
 *
 *  The final expression that is matched by the compiler is:
 *
 *	xy	    matches x then y
 *
 *
 *  The actual grammar used is: 		    Parsing action:
 *
 *	TOP ->	re				    PROLOG .re. EPILOG
 *
 *
 *	re ->	{ re } re   |			    LEFTARG .re. RIGHTARG
 *		e re	    |
 *		empty
 *
 *	e ->	se *	    |			    SMSTAR .se. SMSTAR1
 *		se +	    |
 *		se @	    |			    STAR .se. STAR1
 *		se #	    |
 *		se
 *
 *	se ->	( alt )     |
 *		[ ccl ]     |
 *		?	    |			    ANY
 *		^	    |			    BOL
 *		$	    |			    EOL
 *		~ se	    |			    NOTSIGN .se. NOTSIGN1
 *		:x	    |
 *		\n	    |			    PREV
 *		letter				    LETTER x
 *
 *	alt ->	re ! alt    |			    LEFTOR .re. ORSIGN
 *		re				    LEFTOR .re. ORSIGN RIGHTOR
 *
 *	ccl ->	~ cset	    |			    CCLBEG NOTSIGN .cset. CCLEND
 *		cset				    CCLBEG NULL .cset. CCLEND
 *
 *	cset -> item cset   |
 *		item
 *
 *	item -> letter - letter |		    RANGE x y
 *		letter				    RANGE x x
 *
 *  Abbreviations are introduced by :.
 *
 *	:a	[a-zA-Z0-9]				alphanumeric
 *	:b	([<space><tab>]#)			whitespace
 *	:c	[a-zA-Z]				alphabetic
 *	:d	[0-9]					digit
 *	:f	([~/\\ "\[\]\:<|>+=;,.]#)               file part
 *	:h	([0-9a-fA-F]#)				hex number
 *	:i	([a-zA-Z_$][a-zA-Z0-9_$]@)		identifier
 *	:n	([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)	number
 *	:p	(([A-Za-z]\:!)(\\!)(:f(.:f!)(\\!/))@:f(.:f!.!))	path
 *	:q	("[~"]@"!'[~']@')                       quoted string
 *	:w	([a-zA-Z]#)				word
 *	:z	([0-9]#)				integer
 *
 */

extern  char XLTab[256];        /* lower-casing table		     */

/*  There are several classes of characters:
 *
 *  Closure characters are suffixes that indicate repetition of the previous
 *  RE.
 *
 *  Simple RE chars are characters that indicate a particular type of match
 *
 */

/*  Closure character equates
 */
#define CCH_SMPLUS       0               /* plus closure                      */
#define CCH_SMCLOSURE    1               /* star closure                      */
#define CCH_POWER        2               /* n repetitions of previous pattern */
#define CCH_CLOSURE      3               /* greedy closure                    */
#define CCH_PLUS         4               /* greedy plus                       */
#define CCH_NONE         5
#define CCH_ERROR        -1

/*  Simple RE character equates */
#define SR_BOL		0
#define SR_EOL		1
#define SR_ANY		2
#define SR_CCLBEG	3
#define SR_LEFTOR	4
#define SR_CCLEND	5
#define SR_ABBREV	6
#define SR_RIGHTOR	7
#define SR_ORSIGN	8
#define SR_NOTSIGN	9
#define SR_LEFTARG	10
#define SR_RIGHTARG	11
#define SR_LETTER	12
#define SR_PREV 	13

int EndAltRE[] =    { SR_ORSIGN, SR_RIGHTOR, -1};
int EndArg[] =      { SR_RIGHTARG, -1};

char *pAbbrev[] = {
    "a[a-zA-Z0-9]",
    "b([ \t]#)",
    "c[a-zA-Z]",
    "d[0-9]",
    "f([~/\\\\ \\\"\\[\\]\\:<|>+=;,.]#!..!.)",
    "h([0-9a-fA-F]#)",
    "i([a-zA-Z_$][a-zA-Z0-9_$]@)",
    "n([0-9]#.[0-9]@![0-9]@.[0-9]#![0-9]#)",
    "p(([A-Za-z]\\:!)(\\\\!/!)(:f(.:f!)(\\\\!/))@:f(.:f!.!))",
    "q(\"[~\"]@\"!'[~']@')",
    "w([a-zA-Z]#)",
    "z([0-9]#)",
    NULL
};

static char *digits = "0123456789";

static flagType fZSyntax = TRUE;    /* TRUE => use Z syntax for things */

static unsigned int cArg;

/*  RECharType - classify a character type
 *
 *  p		character pointer
 *
 *  returns	type of character (SR_xx)
 */
int
RECharType (
           char *p
           )
{
    if (fZSyntax)
        /*  Zibo syntax
         */
        switch (*p) {
            case '^':
                return SR_BOL;
            case '$':
                if (isdigit (p[1]))
                    return SR_PREV;
                else
                    return SR_EOL;
            case '?':
                return SR_ANY;
            case '[':
                return SR_CCLBEG;
            case '(':
                return SR_LEFTOR;
            case ']':
                return SR_CCLEND;
            case ':':
                return SR_ABBREV;
            case ')':
                return SR_RIGHTOR;
            case '!':
                return SR_ORSIGN;
            case '~':
                return SR_NOTSIGN;
            case '{':
                return SR_LEFTARG;
            case '}':
                return SR_RIGHTARG;
            default:
                return SR_LETTER;
        } else
        /*  Crappy UNIX syntax
         */
        switch (*p) {
            case '^':
                return SR_BOL;
            case '$':
                return SR_EOL;
            case '.':
                return SR_ANY;
            case '[':
                return SR_CCLBEG;
            case ']':
                return SR_CCLEND;
            case '\\':
                switch (p[1]) {
                    case ':':               /*	\:C */
                        return SR_ABBREV;
                    case '(':               /*	\(  */
                        return SR_LEFTARG;
                    case ')':               /*	\)  */
                        return SR_RIGHTARG;
                    case '~':               /*	\~  */
                        return SR_NOTSIGN;
                    case '{':               /*	\{  */
                        return SR_LEFTOR;
                    case '}':               /*	\}  */
                        return SR_RIGHTOR;
                    case '!':               /*	\!  */
                        return SR_ORSIGN;
                }
                if (isdigit (p[1]))         /*	\N  */
                    return SR_PREV;
            default:
                return SR_LETTER;
        }
}

/*  RECharLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int
RECharLen (
          char *p
          )
{
    if (fZSyntax)
        if (RECharType (p) == SR_PREV)      /*	$N  */
            return 2;
        else
            if (RECharType (p) == SR_ABBREV)    /*	:N  */
            return 2;
        else
            return 1;
    else {
        if (*p == '\\')
            switch (p[1]) {
                case '{':
                case '}':
                case '~':
                case '(':
                case ')':
                case '!':
                    return 2;           /*	\C  */
                case ':':               /*	\:C */
                    return 3;
                default:
                    if (isdigit (p[1]))
                        return 2;           /*	\N  */
                    else
                        return 1;
            }
        return 1;
    }
}

/*  REClosureLen - length of character type
 *
 *  p		character pointer to type
 *
 *  returns	length in chars of type
 */
int
REClosureLen (
             char *p
             )
{
    p;

    return 1;
}

/*  REParseRE - parse a general RE up to but not including the pEnd set
 *  of chars.  Apply a particular action to each node in the parse tree.
 *
 *  pAction	Parse action routine to call at particluar points in the
 *		parse tree.  This routine returns an unsigned quantity that
 *		is expected to be passed on to other action calls within the
 *		same node.
 *  p		character pointer to string being parsed
 *  pEnd	pointer to set of char types that end the current RE.
 *		External callers will typically use NULL for this value.
 *		Internally, however, we need to break on the ALT-terminating
 *		types or on arg-terminating types.
 *
 *  Returns:	pointer to delimited character if successful parse
 *		NULL if unsuccessful parse (syntax error).
 *
 */
char *
REParseRE (
          PACT pAction,
          register char *p,
          int *pEnd
          )
{
    int *pe;
    UINT_PTR u;

    DEBOUT (("REParseRE (%04x, %s)\n", pAction, p));

    while (TRUE) {
        /*  If we're at end of input
         */
        if (*p == '\0')
            /*	If we're not in the midst of an open expression
             */
            if (pEnd == NULL)
                /*  return the current parse position
                 */
                return p;
            else {
                /*  End of input, but expecting more, ERROR
                 */
                DEBOUT (("REParse expecting more, ERROR\n"));
                return NULL;
            }

        /*  If there is an open expression
         */
        if (pEnd != NULL)
            /*	Find a matching character
             */
            for (pe = pEnd; *pe != -1; pe++)
                if (RECharType (p) == *pe)
                    return p;

                /*  If we are looking at a left argument
                 */
        if (RECharType (p) == SR_LEFTARG) {
            /*	Parse LEFTARG .re. RIGHTARG
             */
            u = (*pAction) (LEFTARG, 0, '\0', '\0');
            if ((p = REParseRE (pAction, p + RECharLen (p), EndArg)) == NULL)
                return NULL;
            (*pAction) (RIGHTARG, u, '\0', '\0');
            cArg++;
            p += RECharLen (p);
        } else
            /*  Parse .e.
             */
            if ((p = REParseE (pAction, p)) == NULL)
            return NULL;
    }
}

/*  REParseE - parse a simple regular expression with potential closures.
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseE (
         PACT pAction,
         register char *p
         )
{
    DEBOUT (("REParseE (%04x, %s)\n", pAction, p));

    switch (REClosureChar (p)) {
        case CCH_SMPLUS:
            if (REParseSE (pAction, p) == NULL)
                return NULL;
        case CCH_SMCLOSURE:
            return REParseClosure (pAction, p);

        case CCH_PLUS:
            if (REParseSE (pAction, p) == NULL)
                return NULL;
        case CCH_CLOSURE:
            return REParseGreedy (pAction, p);

        case CCH_POWER:
            return REParsePower (pAction, p);

        case CCH_NONE:
            return REParseSE (pAction, p);

        default:
            return NULL;
    }
}

/*  REParseSE - parse a simple regular expression
 *
 *  pAction	Action to apply at special parse nodes
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseSE (
          register PACT pAction,
          register char *p
          )
{
    DEBOUT (("REParseSE (%04x, %s)\n", pAction, p));

    switch (RECharType (p)) {
        case SR_CCLBEG:
            return REParseClass (pAction, p);
        case SR_ANY:
            return REParseAny (pAction, p);
        case SR_BOL:
            return REParseBOL (pAction, p);
        case SR_EOL:
            return REParseEOL (pAction, p);
        case SR_PREV:
            return REParsePrev (pAction, p);
        case SR_LEFTOR:
            return REParseAlt (pAction, p);
        case SR_NOTSIGN:
            return REParseNot (pAction, p);
        case SR_ABBREV:
            return REParseAbbrev (pAction, p);
        default:
            return REParseChar (pAction, p);
    }
}

/*  REParseClass - parse a class membership match
 *
 *  pAction	Action to apply at beginning of parse and at each range
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseClass (
             PACT pAction,
             register char *p
             )
{
    char c;
    UINT_PTR u;

    DEBOUT (("REParseClass (%04x, %s)\n", pAction, p));

    p += RECharLen (p);
    if ((fZSyntax && *p == '~') || (!fZSyntax && *p == '^')) {
        u = (*pAction) (CCLNOT, 0, '\0', '\0');
        p += RECharLen (p);
    } else
        u = (*pAction) (CCLBEG, 0, '\0', '\0');

    while (RECharType (p) != SR_CCLEND) {
        if (*p == '\\')
            p++;
        if (*p == '\0') {
            DEBOUT (("REParseClass expecting more, ERROR\n"));
            return NULL;
        }
        c = *p++;
        if (*p == '-') {
            p++;
            if (*p == '\\')
                p++;
            if (*p == '\0') {
                DEBOUT (("REParseClass expecting more, ERROR\n"));
                return NULL;
            }
            (*pAction) (RANGE, u, c, *p);
            p++;
        } else
            (*pAction) (RANGE, u, c, c);
    }
    return p + RECharLen (p);
}

/*  REParseAny - parse a match-any-character expression
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAny (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseAny (%04x, %s)\n", pAction, p));

    (*pAction) (ANY, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseBOL - parse a beginning-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseBOL (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseBOL (%04x, %s)\n", pAction, p));

    (*pAction) (BOL, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParsePrev - parse a previous-match item
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParsePrev (
            PACT pAction,
            char *p
            )
{
    unsigned int i = *(p + 1) - '0';

    DEBOUT (("REParsePrev (%04x, %s)\n", pAction, p));

    if (i < 1 || i > cArg) {
        DEBOUT (("REParsePrev invalid previous number, ERROR\n"));
        return NULL;
    }

    (*pAction) (PREV, i, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseEOL - parse an end-of-line match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseEOL (
           PACT pAction,
           char *p
           )
{
    DEBOUT (("REParseEOL (%04x, %s)\n", pAction, p));

    (*pAction) (EOL, 0, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseAlt - parse a series of alternatives
 *
 *  pAction	Action to apply before and after each alternative
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAlt (
           PACT pAction,
           register char *p
           )
{
    UINT_PTR u = 0;

    DEBOUT (("REParseAlt (%04x, %s)\n", pAction, p));

    while (RECharType (p) != SR_RIGHTOR) {
        p += RECharLen (p);
        u = (*pAction) (LEFTOR, u, '\0', '\0');
        if ((p = REParseRE (pAction, p, EndAltRE)) == NULL)
            return NULL;
        u = (*pAction) (ORSIGN, u, '\0', '\0');
    }
    (*pAction) (RIGHTOR, u, '\0', '\0');
    return p + RECharLen (p);
}

/*  REParseNot - parse a guard-against match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseNot (
           PACT pAction,
           register char *p
           )
{
    UINT_PTR u;

    DEBOUT (("REParseNot (%04x, %s)\n", pAction, p));

    p += RECharLen (p);
    if (*p == '\0') {
        DEBOUT (("REParseNot expecting more, ERROR\n"));
        return NULL;
    }
    u = (*pAction) (NOTSIGN, 0, '\0', '\0');
    p = REParseSE (pAction, p);
    (*pAction) (NOTSIGN1, u, '\0', '\0');
    return p;
}

/*  REParseAbbrev - parse and expand an abbreviation
 *
 *  Note that since the abbreviations are in Z syntax, we must change syntax
 *  temporarily to Z.  We are careful to do this so that we do not mess up
 *  advancign the pointers.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseAbbrev (
              PACT pAction,
              register char *p
              )
{
    int i;
    flagType fZSTmp;

    DEBOUT (("REParseAbbrev (%04x, %s)\n", pAction, p));

    p += RECharLen (p);

    fZSTmp = fZSyntax;
    fZSyntax = TRUE;
    if (p[-1] == '\0') {
        DEBOUT (("REParseAbbrev expecting abbrev char, ERROR\n"));
        fZSyntax = fZSTmp;
        return NULL;
    }

    for (i = 0; pAbbrev[i]; i++)
        if (p[-1] == *pAbbrev[i])
            if (REParseSE (pAction, pAbbrev[i] + 1) == NULL) {
                fZSyntax = fZSTmp;
                return NULL;
            } else {
                fZSyntax = fZSTmp;
                return p;
            }
    DEBOUT (("REParseAbbrev found invalid abbrev char %s, ERROR\n", p - 1));
    fZSyntax = fZSTmp;
    return NULL;
}

/*  REParseChar - parse a single character match
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseChar (
            PACT pAction,
            register char *p
            )
{
    DEBOUT (("REParseChar (%04x, %s)\n", pAction, p));

    if (*p == '\\')
        p++;
    if (*p == '\0') {
        DEBOUT (("REParseChar expected more, ERROR\n"));
        return NULL;
    }
    (*pAction) (LETTER, 0, *p, '\0');
    return p+1;
}

/*  REParseClosure - parse a minimal match closure.  The match occurs by
 *  matching none, then one, ...
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseClosure (
               PACT pAction,
               register char *p
               )
{
    UINT_PTR u;

    DEBOUT (("REParseaClosure (%04x, %s)\n", pAction, p));

    u = (*pAction) (SMSTAR, 0, '\0', '\0');
    if ((p = REParseSE (pAction, p)) == NULL)
        return NULL;
    (*pAction) (SMSTAR1, u, '\0', '\0');
    return p + REClosureLen (p);
}

/*  REParseGreedy - parse a maximal-match closure.  The match occurs by
 *  matching the maximal number and then backing off as failures occur.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParseGreedy (
              PACT pAction,
              register char *p
              )
{
    UINT_PTR u;

    DEBOUT (("REParseGreedy (%04x, %s)\n", pAction, p));

    u = (*pAction) (STAR, 0, '\0', '\0');
    if ((p = REParseSE (pAction, p)) == NULL)
        return NULL;
    (*pAction) (STAR1, u, '\0', '\0');
    return p + REClosureLen (p);
}

/*  REParsePower -  parse a power-closure.  This is merely the simple pattern
 *  repeated the number of times specified by the exponent.
 *
 *  pAction	Action to apply
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	pointer past parsed text if successful
 *		NULL otherwise (syntax error)
 */
char *
REParsePower (
             PACT pAction,
             char *p
             )
{
    register char *p1;
    int exp;

    DEBOUT (("REParsePower (%04x, %s)\n", pAction, p));

    /*	We have .se. POWER something.  Skip over the .se. and POWER
     *	to make sure that what follows is a valid number
     */
    p1 = REParseSE (NullAction, p);

    if (p1 == NULL)
        /*  Parse of .se. failed
         */
        return NULL;

    /*	skip POWER
     */
    p1 += REClosureLen (p1);

    if (*p1 == '\0') {
        DEBOUT (("REParsePower expecting more, ERROR\n"));
        return NULL;
    }

    /* try to parse off number */
    if (sscanf (p1, "%d", &exp) != 1) {
        DEBOUT (("REParsePower expecting number, ERROR\n"));
        return NULL;
    }

    p1 = strbskip (p1, digits);

    /* iterate the pattern the exponent number of times */
    while (exp--)
        if (REParseSE (pAction, p) == NULL)
            return NULL;
    return p1;
}

/*  NullAction - a do-nothing action.  Used for stubbing out the action
 *  during a parse.
 */
UINT_PTR
NullAction(
          unsigned int  type,
          UINT_PTR      u,
          unsigned char x,
          unsigned char y
          )
{
    type; u; x; y;
    return 0;
}

/*  REClosureChar - return the character that corresponds to the next
 *  closure to be parsed.  We call REParseSE with a null action to merely
 *  advance the character pointer to point just beyond the current simple
 *  regular expression.
 *
 *  p		character pointer to spot where parsing occurs
 *
 *  Returns	closure character if appropriate
 *              CCH_NONE if no closure character found.
 */
char
REClosureChar (
              char *p
              )
{
    p = REParseSE (NullAction, p);
    if (p == NULL)
        return CCH_ERROR;

    if (fZSyntax)
        /*  Zibo syntax
         */
        switch (*p) {
            case '^':
                return CCH_POWER;
            case '+':
                return CCH_SMPLUS;
            case '#':
                return CCH_PLUS;
            case '*':
                return CCH_SMCLOSURE;
            case '@':
                return CCH_CLOSURE;
            default:
                return CCH_NONE;
        } else
        /*  Crappy UNIX syntax
         */
        switch (*p) {
            case '+':
                return CCH_PLUS;
            case '*':
                return CCH_CLOSURE;
            default:
                return CCH_NONE;
        }
}

/*  RECompile - compile a pattern into the machine.  Return a
 *  pointer to the match machine.
 *
 *  p	    character pointer to pattern being compiled
 *
 *  Returns:	pointer to the machine if compilation was successful
 *		NULL if syntax error or not enough memory for malloc
 */
struct patType *
RECompile(
         char *p,
         flagType fCase,
         flagType fZS
         )
{
    fZSyntax = fZS;

    REEstimate (p);

    DEBOUT (("Length is %04x\n", RESize));

    if (RESize == -1)
        return NULL;

    if ((REPat = (struct patType *) (*tools_alloc) (RESize)) == NULL)
        return NULL;

    memset ((char far *) REPat, -1, RESize);
    memset ((char far *) REPat->pArgBeg, 0, sizeof (REPat->pArgBeg));
    memset ((char far *) REPat->pArgEnd, 0, sizeof (REPat->pArgEnd));

    REip = REPat->code;
    REArg = 1;
    REPat->fCase = fCase;
    REPat->fUnix = (flagType) !fZS;

    cArg = 0;

    CompileAction (PROLOG, 0, '\0', '\0');

    if (REParseRE (CompileAction, p, NULL) == NULL)
        return NULL;

    CompileAction (EPILOG, 0, '\0', '\0');

#if DEBUG
    REDump (REPat);
#endif
    return REPat;
}

/*  Escaped - translate an escaped character ala UNIX C conventions.
 *
 *  \t => tab	    \e => ESC char  \h => backspace \g => bell
 *  \n => lf	    \r => cr	    \\ => \
 *
 *  c	    character to be translated
 *
 *  Returns:	character as per above
 */
char
Escaped(
       char c
       )
{
    switch (c) {
        case 't':
            return '\t';
        case 'e':
            return 0x1B;
        case 'h':
            return 0x08;
        case 'g':
            return 0x07;
        case 'n':
            return '\n';
        case 'r':
            return '\r';
        case '\\':
            return '\\';
        default:
            return c;
    }
}

/*  REGetArg - copy argument string out from match.
 *
 *  pat     matched pattern
 *  i	    index of argument to fetch, 0 is entire pattern
 *  p	    destination of argument
 *
 *  Returns:	TRUE if successful, FALSE if i is out of range.
 */
flagType
REGetArg (
         struct patType *pat,
         int i,
         char *p
         )
{
    int l = 0;

    if (i > MAXPATARG)
        return FALSE;
    else
        if (pat->pArgBeg[i] != (char *)-1)
        memmove ((char far *)p, (char far *)pat->pArgBeg[i], l = RELength (pat, i));
    p[l] = '\0';
    return TRUE;
}

/*  RETranslate - translate a pattern string and match structure into an
 *  output string.  During pattern search-and-replace, RETranslate is used
 *  to generate an output string based on an input match pattern and a template
 *  that directs the output.
 *
 *  The input match is any patType returned from RECompile that has been passed
 *  to fREMatch and that causes fREMatch to return TRUE.  The template string
 *  is any set of ascii chars.	The $ character leads in arguments:
 *
 *	$$ is replaced with $
 *	$0 is replaced with the entire match string
 *	$1-$9 is replaced with the corresponding tagged (by {}) item from
 *	    the match.
 *
 *  An alternative method is to specify the argument as:
 *
 *	$([w,]a) where a is the argument number (0-9) and w is an optional field
 *	    width that will be used in a printf %ws format.
 *
 *  buf     pattern matched
 *  src     template for the match
 *  dst     destination of the translation
 *
 *  Returns:	TRUE if translation was successful, FALSE otherwise
 */
flagType
RETranslate (
            struct patType *buf,
            register char *src,
            register char *dst
            )
{
    int i, w;
    char *work;
    char chArg = (char) (buf->fUnix ? '\\' : '$');

    work = (*tools_alloc) (MAXLINELEN);
    if (work == NULL)
        return FALSE;

    *dst = '\0';

    while (*src != '\0') {
        /*  Process tagged substitutions first
         */
        if (*src == chArg && (isdigit (src[1]) || src[1] == '(')) {
            /*	presume 0-width field */
            w = 0;

            /*	skip $ and char */
            src += 2;

            /*	if we saw $n */
            if (isdigit (src[-1]))
                i = src[-1] - '0';
            /*	else we saw $( */
            else {
                /*  get tagged expr number */
                i = atoi (src);

                /*  skip over number */
                if (*src == '-')
                    src++;
                src = strbskip (src, digits);

                /*  was there a comma? */
                if (*src == ',') {
                    /*	We saw field width, parse off expr number */
                    w = i;
                    i = atoi (++src);
                    src = strbskip (src, digits);
                }

                /*  We MUST end with a close paren */
                if (*src++ != ')') {
                    free (work);
                    return FALSE;
                }
            }
            /*	w is field width
             *	i is selected argument
             */
            if (!REGetArg (buf, i, work)) {
                free (work);
                return FALSE;
            }
            sprintf (dst, "%*s", w, work);
            dst += strlen (dst);
        } else
            /* process escaped characters */
            if (*src == '\\') {
            src++;
            if (!*src) {
                free (work);
                return FALSE;
            }
            *dst++ = Escaped (*src++);
        } else
            /*  chArg quotes itself */
            if (*src == chArg && src[1] == chArg) {
            *dst++ = chArg;
            src += 2;
        } else
            *dst++ = *src++;
    }
    *dst = '\0';
    free (work);
    return TRUE;
}

/*  RETranslateLength - given a matched pattern and a replacement string
 *  return the length of the final replacement
 *
 *  The inputs have the same syntax/semantics as in RETranslate.
 *
 *  buf     pattern matched
 *  src     template for the match
 *
 *  Returns:	number of bytes in total replacement, -1 if error
 */
int
RETranslateLength (
                  struct patType *buf,
                  register char *src
                  )
{
    int i, w;
    int length = 0;
    char chArg = (char) (buf->fUnix ? '\\' : '$');

    while (*src != '\0') {
        /*  Process tagged substitutions first
         */
        if (*src == chArg && (isdigit (src[1]) || src[1] == '(')) {
            w = 0;
            src += 2;
            if (isdigit (src[-1]))
                i = src[-1] - '0';
            else {
                i = atoi (src);
                if (*src == '-')
                    src++;
                src = strbskip (src, digits);
                if (*src == ',') {
                    w = i;
                    i = atoi (++src);
                    src = strbskip (src, digits);
                }
                if (*src++ != ')')
                    return -1;
            }
            /*	w is field width
             *	i is selected argument
             */
            i = RELength (buf, i);
            length += max (i, abs(w));
        } else
            /* process escaped characters */
            if (*src == '\\') {
            src += 2;
            length++;
        } else
            /*  chArg quotes itself */
            if (*src == chArg && src[1] == chArg) {
            src += 2;
            length++;
        } else {
            length++;
            src++;
        }
    }
    return length;
}

/*  RELength - return length of argument in match.
 *
 *  pat     matched pattern
 *  i	    index of argument to examine, 0 is entire pattern
 *
 *  Returns:	length of ith argument, -1 if i is out-of-range.
 */
int
RELength (
         struct patType *pat,
         int i
         )
{
    if (i > MAXPATARG)
        return -1;
    else
        if (pat->pArgBeg[i] == (char *)-1)
        return 0;
    else
        return (int)(pat->pArgEnd[i] - pat->pArgBeg[i]);
}

/*  REStart - return pointer to beginning of match.
 *
 *  ppat    matched pattern
 *
 *  Returns:	character pointer to beginning of match
 */
char *
REStart (
        struct patType *pat
        )
{
    return pat->pArgBeg[0] == (char *)-1 ? NULL : pat->pArgBeg[0];
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\strcmps.c ===
/* strcmps - compare strings and ignore spaces */

#include <ctype.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

/* compare two strings, ignoring white space, case is significant, return
 * 0 if identical, <>0 otherwise
 */
__cdecl strcmps (p1, p2)
const char *p1, *p2;
{
    while (TRUE) {
        while (isspace (*p1))
            p1++;
        while (isspace (*p2))
            p2++;
        if (*p1 == *p2)
            if (*p1++ == 0)
                return 0;
            else
                p2++;
        else
            return *p1-*p2;
        }
}

/* compare two strings, ignoring white space, case is not significant, return
 * 0 if identical, <>0 otherwise
 */
__cdecl strcmpis (p1, p2)
const char *p1, *p2;
{
    while (TRUE) {
        while (isspace (*p1))
            p1++;
        while (isspace (*p2))
            p2++;
        if (toupper (*p1) == toupper (*p2))
            if (*p1++ == 0)
                return 0;
            else
                p2++;
        else
            return *p1-*p2;
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\re_mi.c ===
/*  re_mi.c - machine independent regular expression compiler
 *  cl /c /Zep /AM /NT RE /Gs /G2 /Oa /D LINT_ARGS /Fc re_mi.c
 *
 *  Modifications:
 *      09-Mar-1988 mz  Add check in fREMtch for pat == NULL
 *      15-Sep-1988 bw  Change fREMatch to REMatch.  New parameters and
 *                      return type.
 *      23-Nov-1989 bp  Use relative adresses: OFST and PNTR macros
 *
 *      28-Jul-1990 davegi  Changed Fill to memset (OS/2 2.0)
 *
 */

#include <ctype.h>

#include <stdio.h>
#include <malloc.h>
#include <string.h>
#include <stdlib.h>
#include <windows.h>
#include <tools.h>
#include <remi.h>

#include "re.h"

/*  The following are dependent on the low-level representation of the compiled
 *  machine.  The cases that have been implemented are:
 *
 *  Simple interpreted machine
 */

/* pseudo-instruction definitions */

#define I_CALL      0
#define I_RETURN    1
#define I_LETTER    2
#define I_ANY       3
#define I_EOL       4
#define I_BOL       5
#define I_CCL       6
#define I_NCCL      7
#define I_MATCH     8
#define I_JMP       9
#define I_SPTOM     10
#define I_PTOM      11
#define I_MTOP      12
#define I_MTOSP     13
#define I_FAIL      14
#define I_PUSHP     15
#define I_PUSHM     16
#define I_POPP      17
#define I_POPM      18
#define I_PNEQM     19
#define I_ITOM      20
#define I_PREV      21

/* instruction templates and lengths */

#define LLETTER     2
#define LANY        1
#define LBOL        1
#define LEOL        1

/* address part of instruction */

#define LALLIGN     (sizeof(RE_OPCODE UNALIGNED *) - sizeof(RE_OPCODE))

#define ADDR(ip)    (*(RE_OPCODE UNALIGNED * UNALIGNED *)(ip+(sizeof(RE_OPCODE)+LALLIGN)))

/* conversion macros for adresses */

#define OFST(p)     ((RE_OPCODE UNALIGNED *) (((char *) p) - ((char *) REPat)))
#define PNTR(p)     ((RE_OPCODE UNALIGNED *) (((char *) REPat) + ((ULONG_PTR) p)))

#define IMM(ip)     (*(RE_OPCODE UNALIGNED * UNALIGNED *)(ip+sizeof(RE_OPCODE)+LALLIGN+sizeof(RE_OPCODE UNALIGNED *)))

#define PAD1        sizeof(RE_OPCODE)
#define PAD2        (sizeof(RE_OPCODE)+sizeof(RE_OPCODE))

#define LCCL        (sizeof(RE_OPCODE)+LALLIGN+(256/8))
#define LNCCL       (sizeof(RE_OPCODE)+LALLIGN+(256/8))
#define LOFFSET     (LALLIGN + sizeof(RE_OPCODE *))
#define LCALL       (sizeof(RE_OPCODE)+LOFFSET)
#define LJMP        (sizeof(RE_OPCODE)+LOFFSET)
#define LSPTOM      (sizeof(RE_OPCODE)+LOFFSET)
#define LPTOM       (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOP       (sizeof(RE_OPCODE)+LOFFSET)
#define LMTOSP      (sizeof(RE_OPCODE)+LOFFSET)
#define LRETURN     (sizeof(RE_OPCODE)+LALLIGN)
#define LMATCH      (sizeof(RE_OPCODE)+LALLIGN)
#define LFAIL       (sizeof(RE_OPCODE)+LALLIGN)
#define LPUSHM      (sizeof(RE_OPCODE)+LOFFSET)
#define LPOPM       (sizeof(RE_OPCODE)+LOFFSET)
#define LPUSHP      (sizeof(RE_OPCODE)+LALLIGN)
#define LPOPP       (sizeof(RE_OPCODE)+LALLIGN)
#define LPNEQM      (sizeof(RE_OPCODE)+LOFFSET)
#define LITOM       (sizeof(RE_OPCODE)+LOFFSET+PAD1+LOFFSET)
#define LPREV       (sizeof(RE_OPCODE)+sizeof(RE_OPCODE)+PAD2)

/* action templates */

typedef struct {
    RE_OPCODE   i1[LCALL];              /*      CALL    pattern               */
    RE_OPCODE   i2[LFAIL];              /*      FAIL                          */
    } T_PROLOG;                         /* pattern:                           */

typedef struct {
    RE_OPCODE   i1[LPTOM];              /*      PTOM    ArgBeg[cArg]          */
    RE_OPCODE   i2[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i3[LITOM];              /*      ITOM    ArgBeg[cArg],-1       */
    RE_OPCODE   i4[LRETURN];            /*      RETURN                        */
    } T_LEFTARG;                        /* x:                                 */

typedef struct {
    RE_OPCODE   i1[LPTOM];              /*      PTOM    ArgEnd[cArg]          */
    } T_RIGHTARG;

typedef struct {
    RE_OPCODE   i1[LPUSHM];             /*      PUSHM   tmp                   */
    RE_OPCODE   i2[LCALL];              /*      CALL    l1                    */
    RE_OPCODE   i3[LPOPM];              /*      POPM    tmp                   */
    RE_OPCODE   i4[LRETURN];            /*      RETURN                        */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    RE_OPCODE   i6[LPUSHP];             /* l1:  PUSHP                         */
    RE_OPCODE   i7[LCALL];              /*      CALL    y                     */
    RE_OPCODE   i8[LPOPP];              /*      POPP                          */
    RE_OPCODE   i9[LPTOM];              /*      PTOM    tmp                   */
    } T_SMSTAR;                         /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPNEQM];             /*      PNEQM   tmp                   */
    RE_OPCODE   i2[LJMP];               /*      JMP     l1                    */
    } T_SMSTAR1;                        /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPUSHM];             /* l1:  PUSHM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp                   */
    RE_OPCODE   i3[LPUSHP];             /*      PUSHP                         */
    RE_OPCODE   i4[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i5[LPOPP];              /*      POPP                          */
    RE_OPCODE   i6[LPOPM];              /*      POPM    tmp                   */
    RE_OPCODE   i7[LJMP];               /*      JMP     y                     */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    } T_STAR;                           /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LPNEQM];             /*      PNEQM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp                   */
    RE_OPCODE   i3[LJMP];               /*      JMP     l1                    */
    } T_STAR1;                          /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LANY];               /*      ANY                           */
    } T_ANY;

typedef struct {
    RE_OPCODE   i1[LBOL];               /*      BOL                           */
    } T_BOL;

typedef struct {
    RE_OPCODE   i1[LEOL];               /*      EOL                           */
    } T_EOL;

typedef struct {
    RE_OPCODE   i1[LSPTOM];             /*      SPTOM   tmp                   */
    RE_OPCODE   i2[LPTOM];              /*      PTOM    tmp1                  */
    RE_OPCODE   i3[LCALL];              /*      CALL    x                     */
    RE_OPCODE   i4[LMTOP];              /*      MTOP    tmp1                  */
    RE_OPCODE   i5[LJMP];               /*      JMP     y                     */
    RE_OPCODE   tmp[LOFFSET];           /* tmp  DW                            */
    RE_OPCODE   tmp1[LOFFSET];          /* tmp1 DW                            */
    } T_NOTSIGN;                        /* x:   ...                           */

typedef struct {
    RE_OPCODE   i1[LMTOSP];             /*      MTOSP   tmp                   */
    RE_OPCODE   i2[LMTOP];              /*      MTOP    tmp1                  */
    RE_OPCODE   i3[LRETURN];            /*      RETURN                        */
    } T_NOTSIGN1;                       /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LLETTER];            /*      LETTER  c                     */
    } T_LETTER;

typedef struct {
    RE_OPCODE   i1[LPUSHP];             /* ln:  PUSHP                         */
    RE_OPCODE   i2[LCALL];              /*      CALL    cn                    */
    RE_OPCODE   i3[LPOPP];              /*      POPP                          */
    RE_OPCODE   i4[LJMP];               /*      JMP     ln+1                  */
    } T_LEFTOR;                         /* cn:  ...                           */

typedef struct {
    RE_OPCODE   i1[LJMP];               /*      JMP     y                     */
    } T_ORSIGN;

typedef struct {
    RE_OPCODE   i1[LRETURN];            /* cn+1:RETURN                        */
    } T_RIGHTOR;                        /* y:   ...                           */

typedef struct {
    RE_OPCODE   i1[LCCL];               /*      CCL <bits>                    */
    } T_CCL;

typedef struct {
    RE_OPCODE   i1[LMATCH];             /*      MATCH                         */
    } T_EPILOG;

typedef struct {
    RE_OPCODE   i1[LPREV];              /*      PREV    n                     */
    } T_PREV;

typedef union {
    T_PROLOG    U_PROLOG;
    T_LEFTARG   U_LEFTARG;
    T_RIGHTARG  U_RIGHTARG;
    T_SMSTAR    U_SMSTAR;
    T_SMSTAR1   U_SMSTAR1;
    T_STAR      U_STAR;
    T_STAR1     U_STAR1;
    T_ANY       U_ANY;
    T_BOL       U_BOL;
    T_EOL       U_EOL;
    T_NOTSIGN   U_NOTSIGN;
    T_NOTSIGN1  U_NOTSIGN1;
    T_LETTER    U_LETTER;
    T_LEFTOR    U_LEFTOR;
    T_ORSIGN    U_ORSIGN;
    T_RIGHTOR   U_RIGHTOR;
    T_CCL       U_CCL;
    T_EPILOG    U_EPILOG;
    T_PREV      U_PREV;
    } template ;

/* size of each compiled action */

int cbIns[] =  {
/* PROLOG      0    */  sizeof (T_PROLOG      ),
/* LEFTARG     1    */  sizeof (T_LEFTARG     ),
/* RIGHTARG    2    */  sizeof (T_RIGHTARG    ),
/* SMSTAR      3    */  sizeof (T_SMSTAR      ),
/* SMSTAR1     4    */  sizeof (T_SMSTAR1     ),
/* STAR        5    */  sizeof (T_STAR        ),
/* STAR1       6    */  sizeof (T_STAR1       ),
/* ANY         7    */  sizeof (T_ANY         ),
/* BOL         8    */  sizeof (T_BOL         ),
/* EOL         9    */  sizeof (T_EOL         ),
/* NOTSIGN     10   */  sizeof (T_NOTSIGN     ),
/* NOTSIGN1    11   */  sizeof (T_NOTSIGN1    ),
/* LETTER      12   */  sizeof (T_LETTER      ),
/* LEFTOR      13   */  sizeof (T_LEFTOR      ),
/* ORSIGN      14   */  sizeof (T_ORSIGN      ),
/* RIGHTOR     15   */  sizeof (T_RIGHTOR     ),
/* CCLBEG      16   */  sizeof (T_CCL         ),
/* CCLNOT      17   */  sizeof (T_CCL         ),
/* RANGE       18   */  0,
/* EPILOG      19   */  sizeof (T_EPILOG      ),
/* PREV        20   */  sizeof (T_PREV        )
                        };

#if DEBUG
#define DEBOUT(x)   printf x;
#else
#define DEBOUT(x)
#endif

/*  REMatch - enumerate all matches of a pattern onto a string
 *
 *      pat     compiled pattern (gotten from RECompile)
 *      bos     pointer to beginning of string to scan
 *      str     pointer to into bos of place to begin scan
 *      fFor    direction to move on unsuccessful compares (for <msearch> in Z)
 *
 *  REMatch returns 0 if a match was found.  Otherwise it returns a non-zero
 *  error code.
 *
 *  REMatch interprets the compiled patching machine in the pattern.
 */
int
REMatch(
        struct patType *pat,
        char *bos,
        char *str,
        RE_OPCODE *Stack[],
        unsigned MaxREStack,
        flagType fFor
        )
{
    RE_OPCODE UNALIGNED * UNALIGNED *SP;    /* top of stack                      */
    RE_OPCODE UNALIGNED *IP;       /* current instruction to execute    */
    //register RE_OPCODE UNALIGNED *IP;       /* current instruction to execute    */
    register unsigned char *P;              /* pointer to next char to match     */
    RE_OPCODE     C;
    int i, n;
    RE_OPCODE UNALIGNED * UNALIGNED *StackEnd = &Stack[MaxREStack-sizeof(Stack[0])];
    int (__cdecl * pfncomp) (const char *, const char *, size_t);

    if ((REPat = pat) == NULL)
        return REM_INVALID;

    pfncomp = REPat->fCase ? strncmp : _strnicmp;

    /* initialize the machine */
    memset ((char far *) REPat->pArgBeg, -1, sizeof (REPat->pArgBeg));
    REPat->pArgBeg[0] = P = str;

    /* begin this instance of the machine */
    SP = &Stack[-1];
    IP = REPat->code;

    while (TRUE) {
        DEBOUT (("%04x/%04x/%04x ", IP, SP-&Stack[0], P));
        /* execute instruction */
        switch (*IP) {
        /* call a subroutine */
        case I_CALL:
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = IP + LCALL;
            IP = PNTR (ADDR (IP));
            DEBOUT (("CALL %04x\n", IP));
            break;

        /* return from a subroutine */
        case I_RETURN:
            DEBOUT (("RETURN\n"));
            IP = *SP--;
            break;

        /* match a character, fail if no match */
        case I_LETTER:
            C = REPat->fCase ? *P++ : XLTab[*P++];
            DEBOUT (("LETTER %c\n", IP[1]));
            if (C == IP[1])
                IP += LLETTER;
            else
                IP = *SP--;
            break;

        /* match any character, fail if no match */
        case I_ANY:
            DEBOUT (("ANY\n"));
            if (*P++ != '\0')
                IP += LANY;
            else
                IP = *SP--;
            break;

        /* match end of line, fail if no match */
        case I_EOL:
            DEBOUT (("EOL\n"));
            if (*P == '\0')
                IP += LEOL;
            else
                IP = *SP--;
            break;

        /* match beginning of line, fail if no match */
        case I_BOL:
            DEBOUT (("BOL\n"));
            if (P == bos)
                IP += LBOL;
            else
                IP = *SP--;
            break;

        /* handle character class, fail if no match */
        case I_CCL:
            C = REPat->fCase ? *P++ : XLTab[*P++];
            DEBOUT (("CCL %c\n", C));
            if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) != 0)
                IP += LCCL;
            else
                IP = *SP--;
            break;

        /* handle not character class, fail if match */
        case I_NCCL:
            DEBOUT (("NCCL %c\n", C));
            C = REPat->fCase ? *P++ : XLTab[*P++];
            if (C != '\0' && (IP[1 + (C >> 3)] & (1 << (C & 7))) == 0)
                IP += LNCCL;
            else
                IP = *SP--;
            break;

        /* signal a match */
        case I_MATCH:
            DEBOUT (("MATCH\n"));
            REPat->pArgEnd[0] = P;
            return REM_MATCH;

        /* jump to an instruction */
        case I_JMP:
            IP = PNTR (ADDR (IP));
            DEBOUT (("JMP %04x\n", IP));
            break;

        /* save the character pointer in a memory location */
        case I_PTOM:
            DEBOUT (("PTOM %04x\n", PNTR (ADDR(IP))));
            * ((unsigned char * UNALIGNED *) PNTR (ADDR (IP))) = P;
            IP += LPTOM;
            break;

        /* restore the character pointer from a memory location */
        case I_MTOP:
            DEBOUT (("MTOP %04x\n", PNTR (ADDR(IP))));
            P = * ((unsigned char * UNALIGNED*) PNTR (ADDR (IP)));
            IP += LMTOP;
            break;

        /* save the stack pointer in a memory location */
        case I_SPTOM:
            DEBOUT (("SPTOM %04x\n", PNTR (ADDR(IP))));
            * ((RE_OPCODE UNALIGNED * UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = SP;
            IP += LSPTOM;
            break;

        /* restore the stack pointer from a memory location */
        case I_MTOSP:
            DEBOUT (("MTOSP %04x\n", PNTR (ADDR (IP))));
            SP = * ((RE_OPCODE UNALIGNED * UNALIGNED * UNALIGNED *) PNTR (ADDR (IP)));
            IP += LMTOSP;
            break;

        /* push the char pointer */
        case I_PUSHP:
            DEBOUT (("PUSHP\n"));
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = (RE_OPCODE *) P;
            IP += LPUSHP;
            break;

        /* pop the char pointer */
        case I_POPP:
            DEBOUT (("POPP\n"));
            P = (unsigned char *) (*SP--);
            IP += LPOPP;
            break;

        /* push memory */
        case I_PUSHM:
            DEBOUT (("PUSHM %04x\n", PNTR (ADDR (IP))));
            if (SP >= StackEnd)
                return REM_STKOVR;
            *++SP = * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP)));
            IP += LPUSHM;
            break;

        /* pop memory */
        case I_POPM:
            DEBOUT (("POPM %04x\n", PNTR (ADDR (IP))));
            * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = *SP--;
            IP += LPOPM;
            break;

        /* make sure that the char pointer P is != memory, fail if necessary */
        case I_PNEQM:
            DEBOUT (("PNEQM %04x\n", PNTR (ADDR (IP))));
            if (P != * ((unsigned char * UNALIGNED *) PNTR (ADDR (IP))))
                IP += LPNEQM;
            else
                IP = *SP--;
            break;

        /* move an immediate value to memory */
        case I_ITOM:
            DEBOUT (("ITOM %04x,%04x\n", PNTR (ADDR (IP)), IMM(IP)));
            * ((RE_OPCODE UNALIGNED * UNALIGNED *) PNTR (ADDR (IP))) = IMM (IP);
            IP += LITOM;
            break;

        /* indicate a fail on the total match */
        case I_FAIL:
            DEBOUT (("FAIL\n"));
            P = REPat->pArgBeg[0];
            if (fFor)
                if (*P++ == '\0')
                    return REM_NOMATCH;
                else
                    ;
            else
            if (P-- == bos)
                return REM_NOMATCH;
            REPat->pArgBeg[0] = P;
            SP = &Stack[-1];
            IP = REPat->code;
            break;

        /* perform a match with a previously matched item */
        case I_PREV:
            i = IP[1];
            n = (int)(REPat->pArgEnd[i] - REPat->pArgBeg[i]);
            DEBOUT (("PREV %04x\n", i));
            if (REPat->pArgBeg[i] == (char *) -1)
                IP = *SP--;
            else
            if ((*pfncomp) (REPat->pArgBeg[i], P, n))
                IP = *SP--;
            else {
                IP += LPREV;
                P += n;
                }
            break;

        default:
            return REM_UNDEF;

            }
        }
}

void
REStackOverflow ()
{
    printf ("RE emulator stack overflow\n");
    exit (1);
}

/*  CompileAction - drop in the compilation template at a particular node
 *  in the tree.  Continuation appropriate to a node occurs by relying on
 *  passed input and past input (yuk, yuk).
 *
 *  type        type of action being performed
 *  u           previous return value.  Typically points to a previous
 *              template that needs to be linked together.
 *  x           low byte of a range
 *  y           high range of a range.
 *
 *  Returns     variable depending on action required.
 *
 */
UINT_PTR
CompileAction(
              unsigned int  type,
              UINT_PTR      u,
              unsigned char x,
              unsigned char y
              )
{
    register template UNALIGNED *t = (template UNALIGNED *) REip;
    UINT_PTR u1, u2, u3;

    DEBOUT (("%04x CompileAction %04x\n", REip, type));

    REip += cbIns[type];

    switch (type) {

    case PROLOG:
#define ip  ((T_PROLOG UNALIGNED *)(&(t->U_PROLOG)))
        ip->i1[0] = I_CALL;     ADDR(ip->i1) = OFST (REip);
        ip->i2[0] = I_FAIL;
        return 0;
#undef  ip
        break;

    case LEFTARG:
#define ip  ((T_LEFTARG UNALIGNED *)(&(t->U_LEFTARG)))
        ip->i1[0] = I_PTOM;
        ADDR(ip->i1) = OFST ((RE_OPCODE UNALIGNED*) &(REPat->pArgBeg[REArg]));
        ip->i2[0] = I_CALL;     ADDR(ip->i2) = OFST (REip);
        ip->i3[0] = I_ITOM;
        ADDR(ip->i3) = OFST ((RE_OPCODE UNALIGNED *) &(REPat->pArgBeg[REArg]));
        IMM(ip->i3) = (RE_OPCODE UNALIGNED*) -1;
        ip->i4[0] = I_RETURN;
        return (unsigned) REArg++;
#undef  ip
        break;

    case RIGHTARG:
#define ip  ((T_RIGHTARG UNALIGNED *)(&(t->U_RIGHTARG)))
        ip->i1[0] = I_PTOM;
        ADDR(ip->i1) = OFST ((RE_OPCODE UNALIGNED*) &(REPat->pArgEnd[u]));
        return 0;
#undef  ip
        break;

    case SMSTAR:
#define ip  ((T_SMSTAR UNALIGNED *)(&(t->U_SMSTAR)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case SMSTAR1:
#define ip  ((T_SMSTAR UNALIGNED *)u)
#define ip2 ((T_SMSTAR1 UNALIGNED *)(&(t->U_SMSTAR1)))
        ip->i1[0] = I_PUSHM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_CALL;     ADDR(ip->i2) = OFST (ip->i6);
        ip->i3[0] = I_POPM;     ADDR(ip->i3) = OFST (ip->tmp);
        ip->i4[0] = I_RETURN;
        /* DW */
        ip->i6[0] = I_PUSHP;
        ip->i7[0] = I_CALL;     ADDR(ip->i7) = OFST (REip);
        ip->i8[0] = I_POPP;
        ip->i9[0] = I_PTOM;     ADDR(ip->i9) = OFST (ip->tmp);

        ip2->i1[0] = I_PNEQM;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_JMP;     ADDR(ip2->i2) = OFST (ip->i6);
        return 0;
#undef  ip
#undef  ip2
        break;

    case STAR:
#define ip  ((T_STAR UNALIGNED *)(&(t->U_STAR)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case STAR1:
#define ip  ((T_STAR UNALIGNED *)u)
#define ip2 ((T_STAR1 UNALIGNED *)(&(t->U_STAR1)))
        ip->i1[0] = I_PUSHM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_PTOM;     ADDR(ip->i2) = OFST (ip->tmp);
        ip->i3[0] = I_PUSHP;
        ip->i4[0] = I_CALL;     ADDR(ip->i4) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
        ip->i5[0] = I_POPP;
        ip->i6[0] = I_POPM;     ADDR(ip->i6) = OFST (ip->tmp);
        ip->i7[0] = I_JMP;      ADDR(ip->i7) = OFST (REip);

        ip2->i1[0] = I_PNEQM;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_PTOM;    ADDR(ip2->i2) = OFST (ip->tmp);
        ip2->i3[0] = I_JMP;     ADDR(ip2->i3) = OFST (ip->i1);
        return 0;
#undef  ip
#undef  ip2
        break;

    case ANY:
#define ip  ((T_ANY UNALIGNED *)(&(t->U_ANY)))
        ip->i1[0] = I_ANY;
        return 0;
#undef  ip
        break;

    case BOL:
#define ip  ((T_BOL UNALIGNED *)(&(t->U_BOL)))
        ip->i1[0] = I_BOL;
        return 0;
#undef  ip
        break;

    case EOL:
#define ip  ((T_EOL UNALIGNED *)(&(t->U_EOL)))
        ip->i1[0] = I_EOL;
        return 0;
#undef  ip
        break;

    case NOTSIGN:
#define ip  ((T_NOTSIGN UNALIGNED *)(&(t->U_NOTSIGN)))
        return (UINT_PTR)ip;
#undef  ip
        break;

    case NOTSIGN1:
#define ip  ((T_NOTSIGN UNALIGNED *)u)
#define ip2 ((T_NOTSIGN1 UNALIGNED *)(&(t->U_NOTSIGN1)))
        ip->i1[0] = I_SPTOM;    ADDR(ip->i1) = OFST (ip->tmp);
        ip->i2[0] = I_PTOM;     ADDR(ip->i2) = OFST (ip->tmp1);
        ip->i3[0] = I_CALL;     ADDR(ip->i3) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
        ip->i4[0] = I_MTOP;     ADDR(ip->i4) = OFST (ip->tmp1);
        ip->i5[0] = I_JMP;      ADDR(ip->i5) = OFST (REip);

        ip2->i1[0] = I_MTOSP;   ADDR(ip2->i1) = OFST (ip->tmp);
        ip2->i2[0] = I_MTOP;    ADDR(ip2->i2) = OFST (ip->tmp1);
        ip2->i3[0] = I_RETURN;
        return 0;
#undef  ip
#undef  ip2
        break;

    case LETTER:
#define ip  ((T_LETTER UNALIGNED *)(&(t->U_LETTER)))
        if (!REPat->fCase)
            x = XLTab[x];
        ip->i1[0] = I_LETTER;   ip->i1[1] = (RE_OPCODE) x;
        return 0;
#undef  ip
        break;

    case LEFTOR:
#define ip  ((T_LEFTOR UNALIGNED *)(&(t->U_LEFTOR)))
        * (UINT_PTR UNALIGNED *) ip = u;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case ORSIGN:
#define ip  ((T_ORSIGN UNALIGNED *)(&(t->U_ORSIGN)))
        * (UINT_PTR UNALIGNED *) ip = u;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case RIGHTOR:
        u1 = u;
        u2 = (UINT_PTR) t;
        u = * (unsigned UNALIGNED *) u1;
        while (u1 != 0) {
            u3 = * (unsigned UNALIGNED *) u;
            /*  u   points to leftor
             *  u1  points to orsign
             *  u2  points to next leftor
             *  u3  points to previous orsign
             */
#define ip  (&(((template UNALIGNED *)u)->U_LEFTOR))
            ip->i1[0] = I_PUSHP;
            ip->i2[0] = I_CALL; ADDR (ip->i2) = OFST (((RE_OPCODE UNALIGNED *)ip) + sizeof (*ip));
            ip->i3[0] = I_POPP;
            ip->i4[0] = I_JMP;  ADDR (ip->i4) = OFST ((RE_OPCODE UNALIGNED *) u2);
#undef  ip
#define ip  (&(((template UNALIGNED *)u1)->U_ORSIGN))
            ip->i1[0] = I_JMP;  ADDR (ip->i1) = OFST (REip);
#undef  ip
            u2 = u;
            u1 = u3;
            if (u1 != 0) {
                u = * (unsigned UNALIGNED *) u1;
            }
        }
#define ip  ((T_RIGHTOR UNALIGNED *)(&(t->U_RIGHTOR)))
        ip->i1[0] = I_RETURN;
#undef  ip
        return 0;
        break;

    case CCLBEG:
#define ip  ((T_CCL UNALIGNED *)(&(t->U_CCL)))
        memset ((char far *) ip->i1, '\0', sizeof (ip->i1));
        ip->i1[0] = I_CCL;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case CCLNOT:
#define ip  ((T_CCL UNALIGNED *)(&(t->U_CCL)))
        memset ((char far *) ip->i1, '\0', sizeof (ip->i1));
        ip->i1[0] = I_NCCL;
        return (UINT_PTR)ip;
#undef  ip
        break;

    case RANGE:
#define ip  ((T_CCL UNALIGNED *)u)
        for (type = x; type <= y; type++) {
            x = REPat->fCase ? (unsigned char) type : XLTab[type];
            ip->i1[1 + (x >> 3)] |= 1 << (x & 7);
            }
        return 0;
#undef  ip
        break;

    case EPILOG:
#define ip  ((T_EPILOG UNALIGNED *)(&(t->U_EPILOG)))
        ip->i1[0] = I_MATCH;
        return 0;
#undef  ip
        break;

    case PREV:
#define ip ((T_PREV UNALIGNED *)(&(t->U_PREV)))
        ip->i1[0] = I_PREV;
        ip->i1[1] = (RE_OPCODE) u;
        return 0;
#undef ip

    default:
        printf ("Compile Action %d: Error\n", type);
        return 0;
        }
}

#if DEBUG
void REDump( struct patType *p, RE_OPCODE *REipEnd )
{
    RE_OPCODE *REip = p->code;

    while (TRUE) {
        if (REip >= REipEnd)
            return;

        printf ("%04x ", REip);
        switch (*REip) {
        case I_CALL:
            printf ("CALL    %04x\n", PNTR (ADDR (REip)));
            REip += LCALL;
            break;
        case I_RETURN:
            printf ("RETURN\n");
            REip += LRETURN;
            break;
        case I_LETTER:
            printf ("LETTER  '%c'\n", REip[1]);
            REip += LLETTER;
            break;
        case I_ANY:
            printf ("ANY\n");
            REip += LANY;
            break;
        case I_EOL:
            printf ("EOL\n");
            REip += LEOL;
            break;
        case I_BOL:
            printf ("BOL\n");
            REip += LBOL;
            break;
        case I_CCL:
            printf ("CCL\n");
            REip += LCCL;
            break;
        case I_NCCL:
            printf ("NCCL\n");
            REip += LNCCL;
            break;
        case I_MATCH:
            printf ("MATCH\n");
            return;
            break;
        case I_JMP:
            printf ("JMP     %04x\n", PNTR (ADDR (REip)));
            REip += LJMP;
            break;
        case I_SPTOM:
            printf ("SPTOM   %04x\n", PNTR (ADDR (REip)));
            REip += LSPTOM;
            break;
        case I_PTOM:
            printf ("PTOM    %04x\n", PNTR (ADDR (REip)));
            REip += LPTOM;
            break;
        case I_MTOP:
            printf ("MTOP    %04x\n", PNTR (ADDR (REip)));
            REip += LMTOP;
            break;
        case I_MTOSP:
            printf ("MTOSP   %04x\n", PNTR (ADDR (REip)));
            REip += LMTOSP;
            break;
        case I_FAIL:
            printf ("FAIL\n");
            REip += LFAIL;
            break;
        case I_PUSHP:
            printf ("PUSHP\n");
            REip += LPUSHP;
            break;
        case I_PUSHM:
            printf ("PUSHM   %04x\n", PNTR (ADDR (REip)));
            REip += LPUSHM;
            break;
        case I_POPP:
            printf ("POPP\n");
            REip += LPOPP;
            break;
        case I_POPM:
            printf ("POPM    %04x\n", PNTR (ADDR (REip)));
            REip += LPOPM;
            break;
        case I_PNEQM:
            printf ("PNEQM   %04x\n", PNTR (ADDR (REip)));
            REip += LPNEQM;
            break;
        case I_ITOM:
            printf ("ITOM    %04x,%04x\n", PNTR (ADDR (REip)), IMM(REip));
            REip += LITOM;
            break;
        default:
            printf ("%04x ???\n", *REip);
            REip += LOFFSET;
            break;
            }
        }
}
#endif

/*  EstimateAction - sum up the number of bytes required by each individual
 *  parsing action in the tree.  Take the input action and add it up to the
 *  running total.
 *
 *  type        type of action being performed
 *  u           dummy parm
 *  x           dummy parm
 *  y           dummy parm
 *
 *  Returns     0 always
 *
 */
UINT_PTR
EstimateAction(
               unsigned int  type,
               UINT_PTR      u,
               unsigned char x,
               unsigned char y
               )
{
    u; x; y;

    DEBOUT (("%04x EstimateAction %04x\n", RESize, type));

    if ( type > ACTIONMAX )
        printf ("EstimateAction %d: Error\n", type);
    RESize += cbIns[type];
    return 0;
}

/*  REEstimate - estimates the number of bytes required to
 *  compile a specified pattern.
 *
 *  REEstimate sets RESize to the number of bytes required to compile
 *  a pattern.  If there is a syntax error in the pattern, RESize is set
 *  to -1.
 *
 *  p           character pointer to pattern that will be compiled
 */
void
REEstimate(
           char *p
           )
{
    RESize = sizeof (struct patType) - 1;
    REArg = 1;

    EstimateAction (PROLOG, 0, '\0', '\0');

    if (REParseRE (EstimateAction, p, NULL) == NULL || REArg > MAXPATARG)
        RESize = -1;
    else
        EstimateAction (EPILOG, 0, '\0', '\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\root.c ===
/*  root.c - generate a path to a file from the root
 *
 *  Modifications:
 *
 *	30-Jul-1986 mz	Add sensitivity for network names
 *	29-Oct-1986 mz	Use c-runtime instead of Z-alike
 *
 *	30-Jul-1990 davegi   Removed unreferenced local vars
 *      18-Oct-1990 w-barry  Fixed case where '..' is passed in.  Function
 *                           now returns 'x:\' instead of 'x:' where x is a
 *                           drive letter.
 */


#include <stdio.h>
#include <ctype.h>
#include <windows.h>
#include <tools.h>
#if MSC
#include <string.h>
#endif


/*  rootpath - construct a path from the root to the specified file
 *  correctly handling ., .. and current directory/drive references.
 *
 *  src 	source path for input
 *  dst 	destination buffer
 *  returns	TRUE if error detected
 */
rootpath (src, dst)
char *src, *dst;
{

    LPSTR FilePart;
    LPSTR p;
    BOOL  Ok;

    Ok =  (!GetFullPathName( (LPSTR) src,
                             (DWORD) MAX_PATH,
                             (LPSTR) dst,
                             &FilePart ));

    if ( !Ok ) {
        p = src + strlen( src ) - 1;
        if ( *p  == '.' ) {
            if ( p > src ) {
                p--;
                if ( *p != '.' && *p != ':' && !fPathChr(*p) ) {
                    strcat( dst, "." );
                }
            }
        }
    }

    return Ok;

#if 0
    char *beg = dst;
    register char *p, *p1;
    BYTE d;

    p = src;
    if (src[0] && src[1] == ':') {
	*p = ( char )tolower (*p);
	p += 2;
    }
    if (!fPathChr (p[0]) || !fPathChr (p[1])) {
        if (src[0] && src[1] == ':') {
            //
            //  Drive specified.
            //
            dst[0] = src[0];
            dst[1] = ':';
            dst[2] = '\0';
            src += 2;
        } else {
            //
            //  Drive not specified, use current directory
            //
            if (curdir(dst, 0)) {
                return TRUE;
            }
        }
        //
        //  now dst has a drive specification, bump across it
        //
        dst += 2;
        if (src[0] == '.' && (src[1] == '\0' ||
                              (fPathChr(src[1]) && src[2] == '\0'))) {
            //
            //  cur dir, we are done
            //
            return FALSE;
        }

    } else {
        src = p;
    }


    if (fPathChr (*src)) {
	strcpy (dst, src);
    } else {
	d = dst[strlen(dst)-1];
	if (!fPathChr (d)) {
	    strcat (dst, PSEPSTR);
        }
	strcat( dst, src );
    }

    p1 = src = dst;
    while (*src) {

	p1 = strbscan (p=p1, "\\/");
	d = *p1;
	*p1++ = 0;
	if (!strcmp (p, ".")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else
	if (!strcmp (p, "..")) {
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    do {
		if (--dst < src)
		    return TRUE;
	    } while (!fPathChr (*dst));
	    }
	else {
	    strcpy (dst, p);
	    dst += strlen (dst);
	    }
	if (fPathChr (d))
	    d = PSEPCHR;
	if (!(*dst++ = (char)d))
	    break;
    }

    // If '..' was passed in one level above the root dir, beg at this point
    // will contain '<drive_letter>:' which will not be treated as a valid
    // directory - To account for this, add a '\' character.
    //
    // Note: This case does not occur if '<drive_letter>:' is passed in.
    //
    if( strlen( beg ) == 2 ) {
        *( beg + 2 ) = PSEPCHR;
        *( beg + 3 ) = '\0';
    }

    pname (beg);
    return FALSE;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\swchng.c ===
/*
 * HISTORY:
 *  16-Jul-87   danl    added istag fMatchTag
 *  15-Jul-87   danl    swchng: blank line is not end of section
 */

#include <stdio.h>
#include <windows.h>
#include <tools.h>
#include <string.h>

char *haslhs(char *, char *);
extern istag (char *);
extern fMatchTag(char *, char *);
extern int frenameNO(char *strNew, char *strOld);

static char *space = "\t ";
static char LB = '[';
static char RB = ']';
static char chEQ  = '=';

/* pBuf has a left hand side that matches pLHS return a pointer to the
 * "=" in pBuf else return NULL
 */
char *haslhs(
    char *pBuf,
    char *pLHS)
{
    flagType f = FALSE;
    char *p;

    if ((p = strchr(pBuf, chEQ)) == NULL)
        return NULL;
    *p = '\0';
    f = (flagType) !strcmpis(pBuf, pLHS);
    *p = chEQ;
    return (f ? p : NULL);
}

/*  istag returns true if pBuf is a tag line, e.g.
 *      [pTag]
 */
fMatchTag(
    char *pBuf,
    char *pTag)
{
    char *p, *pEnd, c;

    pBuf = strchr (pBuf, LB);
    pEnd = strchr (++pBuf, RB);
    *pEnd = '\0';
    while (*pBuf) {
        pBuf = strbscan (p = strbskip (pBuf, space), space);
        c = *pBuf;
        *pBuf = 0;
        if (!_stricmp (p, pTag)) {
            *pBuf = c;
            *pEnd = RB;
            return TRUE;
            }
        *pBuf = c;
        }
    *pEnd = RB;
    return FALSE;
}

istag (
    char *pBuf)
{
    return (( *(pBuf=strbskip(pBuf, space)) == LB) && (strchr (pBuf, RB) != NULL));
}

/*   Searchs the file strSwFile for
 *      [strTag]
 *          LHS=
 *
 *  and if strRHS is non-empty changes the right hand side to strRHS
 *  else deletes the line LHS=
 *
 *  swchnglhs: The original file is fdeleted for recovery via UNDEL.
 *  swchng   : if fNoUndel, then original file is deleted, no UNDEL possible
 *             else fdeleted for recovery via UNDEL.
 *
 *  LHS=RHS is output right after the start of section and any later
 *  instances of LHS are removed.  N.B. if RHS is "", no LHS= is output
 *
 *  If section doesn't exist in file, it is appended at end
 *
 */
int
swchnglhs (strSwFile, strTag, strLHS, strRHS)
char *strSwFile;
char *strTag;
char *strLHS;
char *strRHS;
{
    return ( swchng (strSwFile, strTag, strLHS, strRHS, FALSE ) );
}

flagType swchng (
    char *strSwFile,
    char *strTag,
    char *strLHS,
    char *strRHS,
    flagType fNoUndel)
{
    FILE *fhin, *fhout;
    char strSwBuf[MAXPATHLEN];
    char strSwTmp[MAXPATHLEN] = {0};
    char strBuf[256];
    char *p;
    flagType fTagFound = FALSE;
    flagType fInTag = FALSE;
    flagType fFound = FALSE;

    strncat(strSwTmp, strSwFile, MAXPATHLEN-1);

    if ((fhin = pathopen (strSwTmp, strSwBuf, "rb")) == NULL) {
        return FALSE;
        }
    upd (strSwBuf, ".$$$", strSwTmp);
    if ((fhout = fopen (strSwTmp, "wb")) == NULL) {
        fclose (fhin);
        return FALSE;
        }

    while (fgetl (strBuf, 256, fhin)) {
        if (fInTag) {
            if ((p = haslhs(strBuf, strLHS))) {
                /*
                **  consume continuation lines, i.e. consume until blank line
                **  or line containing []=
                */
                while (fgetl(strBuf, 256, fhin)) {
                    if ( !*strbskip(strBuf, space) || *strbscan(strBuf, "[]=")) {
                        fputl( strBuf, strlen(strBuf), fhout);
                        break;
                        }
                    }
                break;
                }
            else if (istag(strBuf)) {
                /*
                **  detected start of another section
                */
                fputl( strBuf, strlen(strBuf), fhout);
                break;
                }
            fputl( strBuf, strlen(strBuf), fhout);
            }
        else if (istag (strBuf) && fMatchTag(strBuf, strTag)) {
            /*
            **  found start of section so output section head and
            **      LHS=RHS
            */
            fTagFound = fInTag = TRUE;
            fputl( strBuf, strlen(strBuf), fhout);
            if (*strRHS)
                fFound = TRUE;
                fprintf(fhout, "    %s=%s\r\n", strLHS, strRHS);
            }
        else
            fputl( strBuf, strlen(strBuf), fhout);
        }

    /*
    **  copy rest of input
    */
    while (fgetl (strBuf, 256, fhin))
        fputl( strBuf, strlen(strBuf), fhout);

    if (!fTagFound && *strRHS) {
        fFound = TRUE;
        fprintf(fhout, "\r\n[%s]\r\n    %s=%s\r\n\r\n", strTag, strLHS, strRHS);
        }

    fclose (fhin);
    fclose (fhout);
    if ( fNoUndel )
        _unlink (strSwBuf);
    else
        fdelete (strSwBuf);
    frenameNO (strSwBuf, strSwTmp);
    return fFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\update.c ===
/*
 * update takes a def string and update and fills the
 * update with missing defs the update allowing
 * specification of missing parameters.
 * the parts are: ^{[~:]#:}{%#</|\>}{[~.]#}{.[~./\:]}$
 * maximum size of MAXPATHLEN (80) bytes
 *
 *  Modifications:
 *	 4/14/86    dl	use U_ flags
 *	29-May-1987 mz	treat . and .. specially
 *
 *	30-Jul-1990 davegi  Removed unreferenced local vars
 *			    Added prototypes for string functions
 *
 */

#include <string.h>

#include <stdio.h>
#include <windows.h>
#include <tools.h>

static char szDot[] =	    ".";
static char szDotDot[] =    "..";
static char szColon[] =     ":";
static char szPathSep[] =   "\\/:";


int upd (def, update, dst)
char *def, *update, *dst;
{
    char *p, buf[MAX_PATH];
    int f;

    f = 0;
    p = buf;

    /*	if the update doesn't contain a UNC path then copy drive
     */
    if (!fPathChr (update[0]) || !fPathChr (update[1])) {
	if (drive(update, p) || drive (def, p))
	    SETFLAG(f, U_DRIVE);
	p += strlen (p);
	}

    if (path(update, p) || path (def, p))
        SETFLAG(f, U_PATH);
    p += strlen (p);

    if (filename(update, p) || filename (def, p))
        SETFLAG(f, U_NAME);

    if (strcmp (p, szDot) && strcmp (p, szDotDot)) {
	p += strlen (p);

	if (extention(update, p) || extention (def, p))
	    SETFLAG(f, U_EXT);
	}

    strcpy (dst, buf);

    return f;
}

/* copy a drive from source to dest if present, return TRUE if we found one */
drive (src, dst)
char *src, *dst;
{

    if (src[0] != 0 && src[1] == ':') {
	dst[0] = src[0];
	dst[1] = src[1];
	dst[2] = 0;
	return TRUE;
	}
    else {
	dst[0] = 0;
	return FALSE;
	}
}

/**	FindFilename - find filename in string
 *
 *	Find last /\:-separated component in string
 *
 *	psz	    pointer to string to search
 *
 *	returns     pointer to filename
 */
static char *FindFilename (char *psz)
{
    char *p;

    while (TRUE) {
	p = strbscan (psz, szPathSep);
	if (*p == 0)
	    return psz;
	psz = p + 1;
	}
}

/**	FindExtention - find last dot-preceded portion in filename
 *
 *	psz	    pointer to filename string to search
 *
 *	returns     pointer to . or nul
 */
static char *FindExtention (char *psz)
{
    char *p;

    /*	Find first dot
     */
    p = strbscan (psz, szDot);

    /*	if none present then return EOS
     */
    if (*p == 0)
	return p;

    /*	Keep scanning for next dot
     */
    while (TRUE) {
	psz = p;
	p = strbscan (psz + 1, szDot);
	if (*p == 0)
	    return psz;
	}
}

/*  copy an extention from source to dest if present.  include the period.
    Return TRUE if one found.
 */
extention (src, dst)
char *src, *dst;
{
    register char *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p1 = "";
    else
	p1 = FindExtention (p1);

    strcpy (dst, p1);

    return dst[0] != 0;
}

/*  copy a filename part from source to dest if present.  return true if one
    is found
 */
filename (src, dst)
char *src, *dst;
{
    register char *p, *p1;

    p1 = FindFilename (src);

    /*	p1 points to filename
     */
    if (!strcmp (p1, szDot) || !strcmp (p1, szDotDot))
	p = strend (p1);
    else
	p = FindExtention (p1);

    strcpy (dst, p1);
    dst[p-p1] = 0;

    return dst[0] != 0;
}

/*  copy a filename.ext part from source to dest if present.  return true if one
    is found
 */
fileext  (src, dst)
char *src, *dst;
{
    if ( filename (src, dst) ) {
        dst += strlen (dst);
        extention (src, dst);
        return TRUE;
        }
    return FALSE;
}

/*  copy the paths part of the file description.  return true if found
 */
path (src, dst)
char *src, *dst;
{
    register char *p;

    if (src[0] != 0 && src[1] == ':')
	src += 2;

    /*	src points to potential beginning of path
     */

    p = FindFilename (src);

    /*	p points to beginning of filename
     */

    strcpy (dst, src);
    dst[p - src] = 0;
    return dst[0] != 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\xtab.c ===
#include <windows.h>

/***************************************************************************\

CLASS:	    XLTab and XUTab

PURPOSE:    Translate table for case conversion

HISTORY:    28-Jul-90 davegi
		Coverted from 286 MASM

\***************************************************************************/

BYTE XLTab[ ] = {	// Table for lowercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '[', '\\', ']', '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};    



BYTE XUTab[ ] = {	// Table for uppercase translation

    0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
    0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
    0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
    0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
    
    ' ', '!', '"', '#', '$', '%', '&', 0x27,
    '(', ')', '*', '+', ',', '-', '.', '/',
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', ':', ';', '<', '=', '>', '?',
    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G',
    'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W',
    'X', 'Y', 'Z', '{', '|', '}', '~', 0x7F,
    
    0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
    0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
    0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97,
    0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
    0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7,
    0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
    0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7,
    0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
    0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
    0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
    0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7,
    0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
    0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7,
    0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
    0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
    0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\vector.c ===
/*  vector.c - simple vector management
 *
 *  Modifications:
 *
 *	12-May-1988 mz	Add VECTOR typedef
 *
 */
#include <malloc.h>
#include <stdio.h>
#include <windows.h>
#include <tools.h>

#define DELTA 10

VECTOR *
VectorAlloc (
            int count
            )
{
    register VECTOR *v;

    v = (VECTOR *) (*tools_alloc) (sizeof (*v) + (count-1) * sizeof (void *));
    if (v != NULL) {
        v->vmax  = count;
        v->count = 0;
    }
    return v;
}

flagType
fAppendVector (
              VECTOR **ppVec,
              void *val
              )
{
    register VECTOR *pVec = *ppVec;

    if (pVec == NULL)
        if ((pVec = VectorAlloc (DELTA)) == NULL)
            return FALSE;
        else
            ;
    else
        if (pVec->vmax == pVec->count) {
        register VECTOR *v;

        if ((v = VectorAlloc (DELTA + pVec->vmax)) == NULL)
            return FALSE;
        Move ((char far *)(pVec->elem),
              (char far *)(v->elem),
              sizeof (v->elem[0]) * pVec->count);
        v->count = pVec->count;
        free ((char *) pVec);
        pVec = v;
    }
    pVec->elem[pVec->count++] = (UINT_PTR) val;
    *ppVec = pVec;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\string.c ===
/***************************************************************************\

MEMBER:     strbscan

SYNOPSIS:   Returns pointer to first character from string in set

ALGORITHM:  

ARGUMENTS:  const LPSTR	    - search string
	    const LPSTR	    - set of characters

RETURNS:    LPSTR     - pointer to first matching character

NOTES:	    

HISTORY:    davegi 28-Jul-90
		Rewritten from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/
    
#include    <assert.h>
#include    <process.h>
#include    <stdio.h>
#include    <string.h>
#include    <stdlib.h>
#include    <windows.h>

LPSTR
strbscan (
    const LPSTR	pszStr,
    const LPSTR	pszSet
    ) {

    assert( pszStr );
    assert( pszSet );

    return pszStr + strcspn( pszStr, pszSet );
}    

/***************************************************************************\

MEMBER:     strbskip

SYNOPSIS:   Returns pointer to first character from string not in set

ALGORITHM:  

ARGUMENTS:  LPSTR	    - search string
	    LPSTR	    - set of characters

RETURNS:    LPSTR     - pointer to first non matching character

NOTES:	    

HISTORY:    davegi 28-Jul-90
		Rewritten from 286 MASM

KEYWORDS:   

SEEALSO:    

\***************************************************************************/

LPSTR
strbskip (
    const LPSTR	pszStr,
    const LPSTR	pszSet
    ) {

    assert( pszStr );
    assert( pszSet );

    return pszStr + strspn( pszStr, pszSet );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\ztoolasm.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    move.c

Abstract:

    Move and file routines that were previously in asm
    Done to ease porting of utilities (wzmail)

Author:

    Dave Thompson (Daveth) 7 May-1990


Revision History:


--*/

#include    <stdio.h>
#include    <windows.h>
#include    <tools.h>

#include <memory.h>
#include <string.h>

//
//  Move:  move count bytes src -> dst
//

void
Move (
    void * src,
    void * dst,
    unsigned int count)
    {

    memmove(dst, src, count);
}

//
//  Fill:  fill count bytes of dst with value
//

void
Fill (
    char * dst,
    char value,
    unsigned int count)
    {

    memset(dst, (int) value, count);
}


//
//  strpre - return -1 if s1 is a prefix of s2 - case insensitive
//

flagType
strpre (
    char * s1,
    char * s2)
    {
    if ( _strnicmp ( s1, s2, strlen(s1)) == 0 )
	return -1;
    else
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\ztools\src\zalloc.c ===
/***	zalloc - hoookable ztools allocator
 *
 *	Modifications
 *	15-Dec-1988 mz	Created
 */

#include <malloc.h>

char * (*tools_alloc) (unsigned) = (char * (*)(unsigned))malloc;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\zwapi\zwapi.h ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    zwapi.h

Abstract:

    This is the main header file for the NT nt header file to
    zw header file converter.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include <windows.h>
#include <assert.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>

//
// Global Data
//

int fUsage;
char *OutputFileName;
char *SourceFileName;
char *SourceFilePattern;
char **SourceFileList;
int SourceFileCount;
FILE *SourceFile, *OutputFile;

#define STRING_BUFFER_SIZE 1024
char StringBuffer[STRING_BUFFER_SIZE];


int
ProcessParameters(
    int argc,
    char *argv[]
    );

void
ProcessSourceFile( void );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\zwapi\zwapi.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    zwapi.c

Abstract:

    This is the main module for the NT nt header file to zw
    header file converter.

Author:

    Mark Lucovsky (markl) 28-Jan-1991

Revision History:

--*/

#include "zwapi.h"


char *ReturnType = "NTSTATUS";
char *Decoration = "NTSYSAPI";
char *CallType = "NTAPI";
char *ProcedureNamePrefix = "Nt";
char *EndPrototype = ");";

int
__cdecl main( argc, argv )
int argc;
char *argv[];
{

    fUsage = 0;

    if (!ProcessParameters( argc, argv )) {
        fUsage = 1;
        }

    if (fUsage) {
        fprintf( stderr, "usage: ZWAPI [-?] display this message\n" );
        fprintf( stderr, "             [-o filename ]\n" );
        return 1;
        }

    OutputFile = fopen(OutputFileName,"a");
    if (!OutputFile) {
        fprintf(stderr,"ZWAPI: Unable to open output file %s for write access\n",OutputFileName);
        return 1;
        }

    while ( SourceFileCount-- ) {
        SourceFileName = *SourceFileList++;
        SourceFile = fopen(SourceFileName,"r");
        if (!SourceFile) {
            fprintf(stderr,"ZWAPI: Unable to open source file %s for read access\n",SourceFileName);
            return 1;
            }
        ProcessSourceFile();
        }
    return( 0 );
}


int
ProcessParameters(
    int argc,
    char *argv[]
    )
{
    char c, *p;

    while (--argc) {
        p = *++argv;
        if (*p == '/' || *p == '-') {
            while (c = *++p)
                switch (toupper( c )) {
                    case '?':
                        fUsage = 1;
                        return 0;
                        break;

                    case 'O': {
                        argc--, argv++;
                        OutputFileName = *argv;
                        SourceFileList = &argv[1];
                        SourceFileCount = argc-1;
                        return 1;
                        break;
                    }
                }
            }
        }


    return 0;
}

void
ProcessSourceFile( void )
{
    char *s;
    int CallTypeFound;

    while( s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile) ) {
        if (strstr(s,ReturnType) == s) {
            s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
            if ( s && (strstr(s,CallType) == s)  ) {
                s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile);
                CallTypeFound = TRUE;
                }
            else {
                CallTypeFound = FALSE;
                }

            if ( s && (strstr(s,ProcedureNamePrefix) == s) ) {
                if (!CallTypeFound) {
                    fprintf(stderr, "ZWAPI: '%s' call type missing for %s\n", CallType, s );
                    }

                fprintf(OutputFile,"%s\n%s\n%s\nZw%s",
                        Decoration,
                        ReturnType,
                        CallType,
                        s + strlen(ProcedureNamePrefix)
                       );
                while( s = fgets(StringBuffer,STRING_BUFFER_SIZE,SourceFile) ) {
                    fputs(s,OutputFile);
                    if (strstr(s,EndPrototype)) {
                        break;
                        }
                    }
                }
            }
        }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\autorun.h ===
#pragma once

#define WINDOW_CLASS    TEXT("_WindowsAutorunSetup_")

#define INSTALL_WINNT   0
#define LAUNCH_ARP      1
#define SUPPORT_TOOLS   2
#define EXIT_AUTORUN    3
#define BACK            4
#define MIGRATION_WIZ   5
#define HOMENET_WIZ     6
#define TS_CLIENT       7
#define COMPAT_WEB      8
#define BROWSE_CD       9
#define COMPAT_LOCAL    10
#define COMPAT_TOOLS    11
#define VIEW_RELNOTES   12
#define MAX_OPTIONS     13

#define SCREEN_MAIN     0
#define SCREEN_TOOLS    1
#define SCREEN_COMPAT   2

extern const int c_aiMain[]; // menu string resources
extern const int c_cMain;    // counter of items in array
extern const int c_aiWhistler[];
extern const int c_cWhistler;
extern const int c_aiSupport[];
extern const int c_cSupport;
extern const int c_aiCompat[];
extern const int c_cCompat;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\dataitem.h ===
#pragma once

#include <debug.h>

enum {
    WF_PERUSER          = 0x0001,   // item is per user as opposed to per machine
    WF_ADMINONLY        = 0x0002,   // only show item if user is an admin
    WF_ALTERNATECOLOR   = 0x1000,   // show menu item text in the "visited" color
    WF_DISABLED         = 0x2000,   // Treated normally except cannot be launched
};

class CDataItem
{
public:
    CDataItem();
    ~CDataItem();

    TCHAR * GetTitle()      { return m_szTitle; }

    BOOL SetData( LPTSTR pszTitle, LPTSTR pszCmd, LPTSTR pszArgs, DWORD dwFlags, DWORD dwType);
    BOOL Invoke( HWND hwnd );

    DWORD   m_dwFlags;
    DWORD   m_dwType;

protected:
    TCHAR m_szTitle[128];
    TCHAR m_szCmdLine[128];
    TCHAR m_szArgs[128];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\makefile.inc ===
#
#  Common makefile.inc shared across components in the shell project.
#
#  You may ask yourself: what's the difference b/t common.inc and
#  makefile.inc??  Well, the diff is common.inc follows the semantics
#  of a 'sources' file -- that is, it never contains rules or dependencies,
#  only macro definitions.  It keeps it cleaner.
#
#  The makefile.inc is always used to list any special dependencies
#  and rules.
#


!ifndef SELFREGNAME
SELFREGNAME = selfreg.inf
!endif

#
# We need to delete -DNT from the command line definitions because that
# causes our "Shell.shell32.NT" strings to go south.
#
$(SELFREGNAME) : ..\selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) $*.cln $@
        del $*.cln


!ifdef BUILD_PRIVLIB

# The following is done so we can build a private import lib which
# contains all exports, and a public lib which is shipped with the
# SDK and contains only public exports.  The private import lib
# is a super-set of the public lib.
#
# Your sources file must define the following macros to use this:
#
#   TARGETNAME    = foo
#   DLLDEF        = foo.def             <--- shown here for context
#
#   PASS1_PUBLISH = {$(O)\foop.lib=$(SDK_LIB_PATH)\foop.lib}
#   BUILD_PRIVLIB = 1
#
#   PRIVDEF       = foop.def
#   PRIVDEFSRC    = foo.src
#   PRIVLIB       = foop.lib
#
# The foop.def will automatically be built from PRIVDEFSRC.  TARGETNAME
# is listed above simply for name context.
#

PRIV_LIB = $(O)\$(PRIVLIB)

# Make the public import lib dependent on the private import lib
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).lib : $(PRIV_LIB)

# Rule for making the private import lib.  Makefile.def already has
# a rule to make the public import lib.

$(PRIV_LIB) $(PRIV_LIB:.lib=.exp): $(PRIVDEF) $(LIBRARY_OBJS)
   -lib -out:$(PRIV_LIB) @<<
$(LIBRARIAN_FLAGS: =
)
-def:$(PRIVDEF)
$(LIBRARY_OBJS: =
)
<<NOKEEP

# Makefile.def already has a rule that builds a .def file from a .src
# file.  However, we need to add some exclusive defines which we don't
# want defined for anything else.

$(DLLDEF): $(PRIVDEFSRC)
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $** > $@

# In a def file, the word 'PRIVATE' is a keyword telling the linker
# to not include the export in the import library.  We don't want
# this to happen for the private import library.  However, we
# always want 'ULTRAPRIVATE' to map to 'PRIVATE' regardless of the
# import library.

$(PRIVDEF): $(PRIVDEFSRC)
    $(C_PREPROCESSOR_NAME) -DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $*.dfp
    $(C_PREPROCESSOR_NAME) -DULTRAPRIVATE=PRIVATE $(C_PREPROCESSOR_FLAGS) $*.dfp > $@

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\datasrc.cpp ===
#include <windows.h>
#include <ntverp.h>
#include <winbase.h>    // for GetCommandLine
#include "datasrc.h"
#include "autorun.h"
#include "util.h"
#include "resource.h"
#include "assert.h"

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CDataSource::CDataSource()
{
    m_iItems = 0;
}

CDataSource::~CDataSource()
{
}

CDataItem & CDataSource::operator[](int i)
{
    return m_data[m_piScreen[i]];
}

// Init
//
// For autorun we read all the items out of the resources.
BOOL CDataSource::Init(LPSTR pszCommandLine)
{
    BOOL fRet = FALSE;

    // read the text for the items from the resources
    HINSTANCE hinst = GetModuleHandle(NULL);
    if (hinst)
    {
        for (int i=0; i<MAX_OPTIONS; i++)
        {
            TCHAR szTitle[256];
            TCHAR szConfig[MAX_PATH];
            TCHAR szArgs[MAX_PATH];

            szTitle[0] = szConfig[0] = szArgs[0] = 0;

            if (LoadStringAuto(hinst, IDS_TITLE0+i, szTitle, ARRAYSIZE(szTitle)))
            {
                LoadStringAuto(hinst, IDS_CONFIG0+i, szConfig, ARRAYSIZE(szConfig)); // may be empty
            
                if (INSTALL_WINNT == i) // for INSTALL_WINNT we pass through the command line args to setup.exe
                {
                    // if we can't fit the whole cmdline, copy none rather than truncate
                    if (lstrlen(pszCommandLine) <  ARRAYSIZE(szArgs))
                    {
                        lstrcpyn(szArgs, pszCommandLine, ARRAYSIZE(szArgs));
                    }
                }
                else
                {
                    LoadStringAuto(hinst, IDS_ARGS0+i, szArgs, ARRAYSIZE(szArgs));
                }                    
            }

            m_data[i].SetData(szTitle, szConfig, *szArgs?szArgs:NULL, 0, i);
        }

        // Should we display the "This CD contains a newer version" dialog?
        OSVERSIONINFO ovi;
        ovi.dwOSVersionInfoSize = sizeof ( OSVERSIONINFO );
        if ( !GetVersionEx(&ovi) || ovi.dwPlatformId==VER_PLATFORM_WIN32s )
        {
            // We cannot upgrade win32s systems.
            m_Version = VER_INCOMPATIBLE;
        }
        else if ( ovi.dwPlatformId==VER_PLATFORM_WIN32_WINDOWS )
        {
            if (ovi.dwMajorVersion > 3)
            {
                // we can always upgrade win98+ systems to NT
                m_Version = VER_OLDER;
        
                // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
                m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
            }
            else
            {
                m_Version = VER_INCOMPATIBLE;
            }
        }
        else if ((VER_PRODUCTMAJORVERSION > ovi.dwMajorVersion) ||
                 ((VER_PRODUCTMAJORVERSION == ovi.dwMajorVersion) && ((VER_PRODUCTMINORVERSION > ovi.dwMinorVersion) || ((VER_PRODUCTMINORVERSION == ovi.dwMinorVersion) && (VER_PRODUCTBUILD > ovi.dwBuildNumber)))))
        {
            // For NT to NT upgrades, we only upgrade if the version is lower

            m_Version = VER_OLDER;
    
            // Disable ARP.  ARP is only enabled if the CD and the OS are the same version
            m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
        }
        else if ((VER_PRODUCTMAJORVERSION < ovi.dwMajorVersion) || (VER_PRODUCTMINORVERSION < ovi.dwMinorVersion) || (VER_PRODUCTBUILD < ovi.dwBuildNumber))
        {
            m_Version = VER_NEWER;

            // disable upgrade and ARP buttons and associated things
            m_data[INSTALL_WINNT].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
            m_data[COMPAT_LOCAL].m_dwFlags |= WF_DISABLED|WF_ALTERNATECOLOR;
            m_data[LAUNCH_ARP].m_dwFlags    |= WF_DISABLED|WF_ALTERNATECOLOR;
        }
        else
        {
            m_Version = VER_SAME;
        }

        if (m_Version == VER_SAME)
        {
            m_piScreen = c_aiWhistler;
            m_iItems = c_cWhistler;
        }
        else
        {
            m_piScreen = c_aiMain;
            m_iItems = c_cMain;
        }
        fRet = TRUE;
    }

    return fRet;
}

void CDataSource::SetWindow(HWND hwnd)
{
    m_hwndDlg = hwnd;
}

void CDataSource::Invoke( int i, HWND hwnd )
{
    i = m_piScreen[i];
    // if this item is disalbled then do nothing
    if ( m_data[i].m_dwFlags & WF_DISABLED )
    {
        MessageBeep(0);
        return;
    }

    // otherwise we have already built the correct command and arg strings so just invoke them
    switch (i)
    {
    case INSTALL_WINNT:
    case LAUNCH_ARP:
    case BROWSE_CD:
    case COMPAT_WEB:
    case COMPAT_LOCAL:
    case HOMENET_WIZ:
    case MIGRATION_WIZ:
    case TS_CLIENT:
    case VIEW_RELNOTES:
        m_data[i].Invoke(hwnd);
        break;
    case SUPPORT_TOOLS:
        m_piScreen = c_aiSupport;
        m_iItems = c_cSupport;
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_TOOLS, 0);
        break;

    case COMPAT_TOOLS:
        m_piScreen = c_aiCompat;
        m_iItems = c_cCompat;
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_COMPAT, 0);
        break;

    case BACK:
        if (m_Version == VER_SAME)
        {
            m_piScreen = c_aiWhistler;
            m_iItems = c_cWhistler;
        }
        else
        {
            m_piScreen = c_aiMain;
            m_iItems = c_cMain;
        }
        PostMessage(m_hwndDlg, ARM_CHANGESCREEN, SCREEN_MAIN, 0);
        break;

    default:
        assert(0);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\common.inc ===
##########################################################################
#
#   Microsoft Confidential
#   Copyright (C) Microsoft Corporation 1991-1998
#   All Rights Reserved.
#
##########################################################################

#
# Common include file 'sources' files in the shell project.
#
#
# These definitions are required in your sources file:
#
#     CCSHELL_DIR
#        Path to ccshell root.
#
#     FREEBUILD
#        Set by makefile.def file for you.  One of the following:
#          0      - build debug
#          1      - build retail
#
#
# Definitions used if defined:
#
#     TARGET_WIN95
#        Build component explicitly for the Win95 platform.  If this is
#        not defined, default is NT or both.
#
#     TARGET_BOTH
#        Build component to run on both platforms.
#
#     NO_PRIVATE_HEADERS
#        If set to 1, this is defined as a manifest constant, so the
#        stub headers in shell\inc\stubs do not include the private
#        companion headers.
#
#     BUILD_PRIVLIB
#        Build a private import library too.  See the comments in
#        makefile.inc.
#
#     USE_NT_PRODUCT_VER
#        If defined, this will use the NT team's product version
#        numbers, as opposed to the IE team's numbers.
#
#
# Environment Variables and their meanings
#
#     ATL_DEBUG_QI
#        When set to 1, debug builds will also have _ATL_DEBUG_QI
#        defined.  ATL code spews a bunch of debug stuff during QueryInterface.
#
#     ATL_DEBUG_REFCOUNT
#        When set to 1, debug builds will also have _ATL_DEBUG_REFCOUNT
#        defined.  ATL code spews a bunch of debug stuff during AddRef
#        and Release.
#
#     SHELL_FULL_DEBUG
#        If set to 1, then debug builds will also have FULL_DEBUG defined.
#        Retail builds unaffected.  This is highly encouraged for regular
#        development purposes.  Not to be set or used by the build labs.
#
#     SHELL_BROWSER_INFO
#        If set to 1, then the build process generates .sbr files for everything
#        in the shell that is compiled. These .sbr files are then rolled into one
#        giant bsc file that the MSDEV can use (see the shell\browseinfo dir) to
#        index the source.
#
#     MEASURE_PERF
#        If set to 1, enables performance timing code for both debug and
#        retail builds.  This code squirts the timings for interesting
#        events to the debug terminal.
#
#     USE_LEGO
#        Define lego macros
#

!if !defined(CCSHELL_DIR)
!error  CCSHELL_DIR must be defined in sources file
!endif

#
# Set private paths
#

INCLUDES        = \
    ..;\
    $(CCSHELL_DIR)\inc;\
    $(CCSHELL_DIR)\inc\stubs;\
    $(WINDOWS_INC_PATH);\
    $(BASE_INC_PATH);\
    $(SDK_INC_PATH);\
    $(INCLUDES)

#
# Skip these files when determining dependencies
#
CONDITIONAL_INCLUDES = $(CONDITIONAL_INCLUDES) \
                  atlbase.h  \
                  atlcom.h   \
                  atlconv.h  \
                  atlctl.h   \
                  atlctl.cpp \
                  atliface.h \
                  atlimpl.cpp \
                  atlwin.h   \
                  atlwin.cpp \
                  ia64inst.h \
                  macapi.h   \
                  macname1.h \
                  macname2.h \
                  macocidl.h \
                  macpub.h   \
                  macwin32.h \
                  mainwin.h  \
                  mwversion.h \
                  penwin.h \
                  pshpck16.h \
                  rpcerr.h   \
                  rpcmac.h   \
                  setupx.h   \
                  skbapi.h   \
                  statreg.h  \
                  statreg.cpp \
                  unixstuff.h \
                  version.h  \
                  winwlm.h   \
                  ..\inc16\shellapi.h \
                  \vobs\userx\userx\public\sdk\inc\winbase.h    \
                  \vobs\userx\userx\public\sdk\inc\wingdi.h     \
                  \vobs\userx\userx\public\sdk\inc\winuser.h    \
                  \vobs\userx\userx\public\sdk\inc\shellapi.h   \
                  \vobs\userx\userx\public\sdk\inc\winspool.h   \
                  \vobs\userx\userx\public\sdk\inc\prsht.h      \
                  \vobs\userx\userx\public\sdk\inc\commdlg.h    \
                  \vobs\userx\userx\public\sdk\inc\shlobj.h     \
                  \vobs\userx\userx\public\sdk\inc\commctrl.h   \
                  \vobs\userx\userx\public\sdk\inc\shlguid.h    \
                  \vobs\userx\userx\public\sdk\inc\shlwapi.h    \
                  \vobs\userx\userx\public\sdk\inc\intshcut.h

#
# set this so we know when we are stupid
#
!if "$(BUILD_PASS)" == "PASS2"
VERIFY_SOURCES = 1
!endif

!if !defined(TARGET_WIN95)

LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)

!else

# (use 'chicago' since that is already used in the NT tree)

INCLUDES                = $(INCLUDES);$(CCSHELL_DIR)\inc\win95;
LIBRARY_PLATFORM_PATH   = $(SDK_LIB_DEST)\chicago
ALT_PROJECT_TARGET      = chicago

!endif

#
# Set common options
#

!if !defined(ATL_VER)
ATL_VER=30
!endif

#
# set the WIN32_XXX_VERSION defines properly
#

# assume latesst IE version
WIN32_IE_VERSION=$(LATEST_WIN32_IE_VERSION)

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
WIN32_WINNT_VERSION=0x0400
WIN32_WIN95_VERSION=0x0400
SUBSYSTEM_VERSION=4.00
!else
WIN32_WINNT_VERSION=$(LATEST_WIN32_WINNT_VERSION)
WIN32_WIN95_VERSION=$(LATEST_WIN32_WINNT_VERSION)
SUBSYSTEM_VERSION=$(SUBSYSTEM_VERSION_CURRENT)
!endif

# Defining this allows windows.h to include other headers
NOT_LEAN_AND_MEAN= 1

# Don't link to the runtime libs
USE_NOLIBS      = 1

# Don't link to NTDLL if this runs on both platforms
!ifdef TARGET_BOTH
NO_NTDLL=1
!endif

!if defined(TARGET_WIN95)
#  Don't define WINNT
CHICAGO_PRODUCT = 1

# workaround for makefile.def shortcomming:
#
# makefile.def is too clever for its own good. It think that Win95 builds
# should never define _WIN32_WINNT.  But of course, Millennium picked up
# some NT features, so we have to specify explicitly that we like those
# features or we don't get them.
#
C_DEFINES       = $(C_DEFINES) -D_WIN32_WINNT=$(WIN32_WINNT_VERSION)
!endif

UMTYPE          = windows

#
# Lego options
#
!if defined(USE_LEGO)
NTBBT           = 1
NTPROFILEINPUT  = 1
!endif

#
# Additional compiler flags
#

C_DEFINES       = $(C_DEFINES) -DWIN32 -D_WIN32 -DPOSTSPLIT -DUSE_MIRRORING

!if defined(TARGET_DEMO)
C_DEFINES       = $(C_DEFINES) -DWINNT_6DEMO
!endif

!ifdef USE_ICECAP
C_DEFINES = $(C_DEFINES) -DPRODUCT_PROF
!endif

!if !defined(TARGET_WIN95)
C_DEFINES       = $(C_DEFINES) -DNT

!  if !defined(NOT_UNICODE)
C_DEFINES       = $(C_DEFINES) -DUNICODE -D_UNICODE
!  endif
!endif


# ------ Debug Only Defines --------

!if "$(FREEBUILD)" == "0"
C_DEFINES       = $(C_DEFINES) -DDEBUG
LINKER_NOICF      = 1           # ICF is s-l-o-w

# Check for missing PURE directives in interface decls (debug only)
C_DEFINES       = $(C_DEFINES) -DNO_NOVTABLE

# Define FULL_DEBUG for asserts to break by default
!  if "$(SHELL_FULL_DEBUG)" == "1" || "$(FULL_DEBUG)" == "1"
C_DEFINES       = $(C_DEFINES) -DFULL_DEBUG

# Also turn off compiler optimizations when FULL_DEBUG is set
MSC_OPTIMIZATION= /Odi
!  endif

# Allow someone to have ATL_DEBUG_REFCOUNT and ATL_DEBUG_QI set
# in their environment to turn this on
!  if "$(ATL_DEBUG_REFCOUNT)" == "1"
C_DEFINES       = $(C_DEFINES) -D_ATL_DEBUG_REFCOUNT
!  endif

!  if "$(ATL_DEBUG_QI)" == "1"
C_DEFINES       = $(C_DEFINES) -D_ATL_DEBUG_QI
!  endif

!endif
# ------ End Debug Only Defines --------


!if "$(SHELL_BROWSER_INFO)" == "1"
BROWSER_INFO = 1;
NO_BROWSER_FILE = 1;
USER_ENV_BROWSER_INFO=1
!endif

!if "$(MEASURE_PERF)" == "1"
C_DEFINES       = $(C_DEFINES) -DMEASURE_PERF
!endif

!if "$(NO_PRIVATE_HEADERS)" == "1"
C_DEFINES       = $(C_DEFINES) -DNO_PRIVATE_HEADERS
!endif

!ifdef USE_NT_PRODUCT_VER
# Use the NT product version numbers
C_DEFINES       = $(C_DEFINES) -UNASHVILLE
!else
# Use the IE product version numbers.  (The ntverp.h file checks
# for NASHVILLE.)
C_DEFINES       = $(C_DEFINES) -DNASHVILLE
!endif

# IE40-only features

FEATURE_IE40    = 1

!ifdef FEATURE_IE40
C_DEFINES       = $(C_DEFINES) -DFEATURE_IE40 -DNASH
!endif

# Make warnings equivalent to errors

!if !defined(MSC_WARNING_LEVEL)
MSC_WARNING_LEVEL= /W3
!endif
MSC_WARNING_LEVEL= $(MSC_WARNING_LEVEL) /WX

!if defined(TARGET_WIN95) || defined(TARGET_BOTH)
USE_MAPSYM      = 1
!endif


!if !defined(CLEANINF_FLAGS)
# Cleaninf flags
CLEANINF_FLAGS  = -w
!endif

# Cleaninf utility
CLEANINF        = cleaninf.exe $(CLEANINF_FLAGS)


!ifdef BUILD_PRIVLIB
NTTARGETFILE1   = $(NTTARGETFILE1) $(TARGETPATHLIB)\*\$(PRIVLIB)
!endif

!IF "$(SPVER)" != ""
C_DEFINES=$(C_DEFINES) -DSPVER=$(SPVER)
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\dataitem.cpp ===
#include <windows.h>
#include <shlwapi.h>
#include <commctrl.h>
#include "dataitem.h"
#include "resource.h"
#include "stdio.h"
#include "util.h"

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))
#define EXPLORER_EXE_STRING TEXT("explorer.exe")
#define HTTP_PREFIX_STRING  TEXT("http://")

CDataItem::CDataItem()
{
    m_szTitle[0] = 0;
    m_szCmdLine[0] = 0;
    m_szArgs[0] = 0;
    m_dwFlags = 0;
    m_dwType = 0;
}

CDataItem::~CDataItem()
{
}

BOOL CDataItem::SetData( LPTSTR pszTitle, LPTSTR pszCmd, LPTSTR pszArgs, DWORD dwFlags, DWORD dwType)
{
    BOOL fRet = FALSE;
    
    if (!m_szCmdLine[0] &&  // not init'd yet
        pszTitle && 
        pszCmd)
    {        
        lstrcpyn(m_szTitle, pszTitle, ARRAYSIZE(m_szTitle)); // fine, we control pszTitle
        lstrcpyn(m_szCmdLine, pszCmd, ARRAYSIZE(m_szCmdLine)); // fine, we control pszCmd
        if (pszArgs)
        {
            lstrcpyn( m_szArgs, pszArgs, ARRAYSIZE(m_szArgs)); // fine, we control pszArgs
        }

        m_dwType = dwType;
        m_dwFlags = dwFlags;
        fRet = TRUE;
    }

    return fRet;
}

#define BUFFER_SIZE 1000

BOOL CDataItem::Invoke(HWND hwnd)
{
    BOOL fResult = FALSE;
    if (m_szCmdLine[0])
    {
        TCHAR szExpandedExecutable[BUFFER_SIZE];
        TCHAR szExpandedArgs[BUFFER_SIZE];

        fResult = SafeExpandEnvStringsA(m_szCmdLine, szExpandedExecutable, ARRAYSIZE(szExpandedExecutable));
        if (fResult)
        {
            if (m_szArgs[0])
            {
                fResult = SafeExpandEnvStringsA(m_szArgs, szExpandedArgs, ARRAYSIZE(szExpandedArgs));
            }
            else
            {
                szExpandedArgs[0] = 0;
            }

            if (fResult)
            {
                TCHAR szDirectory[MAX_PATH];
                int cchDirectory = GetModuleFileName(NULL, szDirectory, ARRAYSIZE(szDirectory));
                if (cchDirectory > 0 && cchDirectory < MAX_PATH)
                {
                    if (LocalPathRemoveFileSpec(szDirectory))
                    {
                        if (!strncmp(szExpandedExecutable, EXPLORER_EXE_STRING, ARRAYSIZE(EXPLORER_EXE_STRING))) // explorer paths must be opened
                        {
                            if (szExpandedArgs[0] && !strncmp(szExpandedArgs, HTTP_PREFIX_STRING, ARRAYSIZE(HTTP_PREFIX_STRING) - 1))
                            {
                                // opening a weblink
                                fResult = ((INT_PTR)ShellExecute(hwnd, TEXT("open"), szExpandedArgs, NULL, NULL, SW_SHOWNORMAL) > 32);
                            }
                            else
                            {
                                // opening a folder
                                if (szExpandedArgs[0])
                                {
                                    LocalPathAppendA(szDirectory, szExpandedArgs, ARRAYSIZE(szDirectory));
                                }                            
                                fResult = ((INT_PTR)ShellExecute(hwnd, TEXT("open"), szDirectory, NULL, NULL, SW_SHOWNORMAL) > 32);
                            }
                        }
                        else
                        {
                            fResult = ((INT_PTR)ShellExecute(hwnd, NULL, szExpandedExecutable, szExpandedArgs, szDirectory, SW_SHOWNORMAL) > 32);
                        }
                    }
                }
            }
        }
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\autorun.cpp ===
#include <windows.h>
#include "autorun.h"
#include "resource.h"
#include "dlgapp.h"
#include "util.h"

// FIRST ITEM MUST ALWAYS BE EXIT_AUTORUN
const int c_aiMain[] = {EXIT_AUTORUN, INSTALL_WINNT, SUPPORT_TOOLS, COMPAT_TOOLS}; 
const int c_aiWhistler[] = {EXIT_AUTORUN, INSTALL_WINNT, LAUNCH_ARP, SUPPORT_TOOLS, COMPAT_TOOLS};


// IA64 gets bare options, Server SKUs get minimal options, Professional and Personal get full options
#if defined(_IA64_)
const int c_aiSupport[] = {EXIT_AUTORUN, BROWSE_CD, VIEW_RELNOTES, BACK};
#else
#if BUILD_SERVER_VERSION | BUILD_ADVANCED_SERVER_VERSION | BUILD_DATACENTER_VERSION | BUILD_BLADE_VERSION | BUILD_SMALL_BUSINESS_VERSION
const int c_aiSupport[] = {EXIT_AUTORUN, TS_CLIENT, BROWSE_CD, VIEW_RELNOTES, BACK};
#else
const int c_aiSupport[] = {EXIT_AUTORUN, TS_CLIENT, HOMENET_WIZ, MIGRATION_WIZ, BROWSE_CD, VIEW_RELNOTES, BACK};
#endif
#endif

const int c_aiCompat[] = {EXIT_AUTORUN, COMPAT_LOCAL, COMPAT_WEB, BACK};

const int c_cMain = ARRAYSIZE(c_aiMain);
const int c_cWhistler = ARRAYSIZE(c_aiWhistler);
const int c_cSupport = ARRAYSIZE(c_aiSupport);
const int c_cCompat = ARRAYSIZE(c_aiCompat);

// Code to ensure only one instance of a particular window is running
HANDLE CheckForOtherInstance(HINSTANCE hInstance)
{
    TCHAR   szCaption[128];
    HANDLE  hMutex;

    if (!LoadStringAuto(hInstance, IDS_TITLEBAR, szCaption, 128))
    {
        hMutex = NULL;
    }
    else
    {
        // We create a named mutex with our window caption just as a way to check
        // if we are already running autorun.exe.  Only if we are the first to
        // create the mutex do we continue.

        hMutex = CreateMutex (NULL, FALSE, szCaption);

        if (hMutex && GetLastError() == ERROR_ALREADY_EXISTS)
        {
            // Mutex created but by someone else, activate that window
            HWND hwnd = FindWindow( WINDOW_CLASS, szCaption );
            SetForegroundWindow(hwnd);
            CloseHandle(hMutex);
            hMutex = NULL;
        }

    }

    return hMutex;
}

/**
*  This function is the main entry point into our application.
*
*  @return     int     Exit code.
*/

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLin, int nShowCmd )
{
    HANDLE hMutex = CheckForOtherInstance(hInstance);

    if ( hMutex )
    {
        CDlgApp dlgapp;
        dlgapp.Register(hInstance);
        if ( dlgapp.InitializeData(lpCmdLin) )
        {
            dlgapp.Create(nShowCmd);
            dlgapp.MessageLoop();
        }

        CloseHandle(hMutex);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\datasrc.h ===
#pragma once

#include "autorun.h"
#include "dataitem.h"
#include "util.h"

class CDataSource
{
public:

    CDataItem   m_data[MAX_OPTIONS];
    int         m_iItems;
    RELVER      m_Version;

    CDataSource();
    ~CDataSource();

    BOOL Init(LPSTR pszCommandLine);    // command line arguments from invocation of setup.exe, will be passed to winnt32.exe
    void SetWindow(HWND hwnd);

    CDataItem & operator [] ( int i );
    void Invoke( int i, HWND hwnd );

protected:
    HWND    m_hwndDlg;
    const int     *m_piScreen; //pointer to array of menu items on the screen
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\resource.h ===
//////////////////////////////////////////////////////////////////////////
//
//  resource.h
//
//      This file contains all of the resource ids used by the application.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#ifndef _RESOURCE_H_
#define _RESOURCE_H_

#include <winuser.h>

//
//  icons.
//
#define IDI_WEBAPP             1

//
//  cursors.
//
#define IDC_BRHAND             1

//
//  bitmaps.
//

#define IDB_TOP                20
#define IDB_CENTER             21
#define IDB_BOTTOM             22

#define IDB_FLAG               40
#define IDB_HEADER             50
#define IDB_HEADERSUB          60

#define IDB_YELLOW             70
#define IDB_YELLOW_HOVER       71
#define IDB_YELLOW_DISABLED    72

#define IDB_RED                80
#define IDB_RED_HOVER          81
#define IDB_RED_DISABLED       82

#define IDB_GREEN              90
#define IDB_GREEN_HOVER        91
#define IDB_GREEN_DISABLED     92

#define IDB_BLUE              100
#define IDB_BLUE_HOVER        101
#define IDB_BLUE_DISABLED     102

#define IDB_GRADIENT_TOP      110
#define IDB_GRADIENT_BOTTOM   111
#define IDB_CLOUDSFLAG        112
#define IDB_CLOUDSFLAG_RTL    113

#define IDB_FLAG_256              540
#define IDB_HEADER_256            550
#define IDB_HEADERSUB_256         560

#define IDB_YELLOW_256            570
#define IDB_YELLOW_HOVER_256      571
#define IDB_YELLOW_DISABLED_256   572

#define IDB_RED_256               580
#define IDB_RED_HOVER_256         581
#define IDB_RED_DISABLED_256      582

#define IDB_GREEN_256             590
#define IDB_GREEN_HOVER_256       591
#define IDB_GREEN_DISABLED_256    592

#define IDB_BLUE_256              600
#define IDB_BLUE_HOVER_256        601
#define IDB_BLUE_DISABLED_256     602

#define IDB_GRADIENT_TOP_256      610
#define IDB_GRADIENT_BOTTOM_256   611
#define IDB_CLOUDSFLAG_256        612
#define IDB_CLOUDSFLAG_RTL_256    613


//
//  string table entries.
//
#define IDS_TITLE              1000
#define IDS_TITLEBAR           1001
#define IDS_HEADER             1002

#define IDS_PSCTITLE           1100
#define IDS_PSCDESC            1101
#define IDS_PSCCONFIG          1102
#define IDS_PSCARGS            1103
#define IDS_PSCMENU            1104

#define IDS_TITLE0             1200
#define IDS_TITLE1             1201
#define IDS_TITLE2             1202
#define IDS_TITLE3             1203
#define IDS_TITLE4             1204
#define IDS_TITLE5             1205
#define IDS_TITLE6             1206
#define IDS_TITLE6             1206
#define IDS_TITLE7             1207
#define IDS_TITLE8             1208
#define IDS_TITLE9             1209
#define IDS_TITLE10            1210
#define IDS_TITLE11            1211
#define IDS_TITLE12            1212

#define IDS_CONFIG0            1300
#define IDS_CONFIG1            1301
#define IDS_CONFIG2            1302
#define IDS_CONFIG3            1303
#define IDS_CONFIG4            1304
#define IDS_CONFIG5            1305
#define IDS_CONFIG6            1306
#define IDS_CONFIG7            1307
#define IDS_CONFIG8            1308
#define IDS_CONFIG9            1309
#define IDS_CONFIG10           1310
#define IDS_CONFIG11           1311
#define IDS_CONFIG12           1312

#define IDS_ARGS0              1400
#define IDS_ARGS1              1401
#define IDS_ARGS2              1402
#define IDS_ARGS3              1403
#define IDS_ARGS4              1404
#define IDS_ARGS5              1405
#define IDS_ARGS6              1406
#define IDS_ARGS7              1407
#define IDS_ARGS8              1408
#define IDS_ARGS9              1409
#define IDS_ARGS10             1410
#define IDS_ARGS11             1411
#define IDS_ARGS12             1412

#define IDS_OLDCDROM           2000
#define IDS_NEWCDROM           2001

#define IDS_FONTFACE_TITLE          3000
#define IDS_FONTFACE_HEADER         3001
#define IDS_FONTFACE_MENU           3002
#define IDS_FONTFACE_TITLE_BACKUP   3003
#define IDS_FONTFACE_HEADER_BACKUP  3004
#define IDS_FONTFACE_MENU_BACKUP    3005

#define IDS_FONTCY_TITLE            3100
#define IDS_FONTCY_HEADER           3101
#define IDS_FONTCY_MENU             3102
#define IDS_FONTCY_TITLE_BACKUP     3103
#define IDS_FONTCY_HEADER_BACKUP    3104
#define IDS_FONTCY_MENU_BACKUP      3105

#define IDS_FONTCY_TITLE_LIL         3200
#define IDS_FONTCY_HEADER_LIL        3201
#define IDS_FONTCY_MENU_LIL          3202
#define IDS_FONTCY_TITLE_BACKUP_LIL  3203
#define IDS_FONTCY_HEADER_BACKUP_LIL 3204
#define IDS_FONTCY_MENU_BACKUP_LIL   3205

//
//  commands.
//
#define IDM_SHOWCHECK          500
#define IDM_MENUITEM0          500
#define IDM_MENUITEM1          501
#define IDM_MENUITEM2          502
#define IDM_MENUITEM3          503
#define IDM_MENUITEM4          504
#define IDM_MENUITEM5          505
#define IDM_MENUITEM6          506
#define IDM_MENUITEM7          507

#define MAX_MENUITEMS          (IDM_MENUITEM7 - IDM_MENUITEM0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\dlgapp.h ===
#pragma once

#include "datasrc.h"
#include "util.h"

class CDlgApp
{
    private:
        HINSTANCE       m_hInstance;        // application instance
        HWND            m_hwnd;             // window handle

        CDataSource     m_DataSrc;          // info from ini and registry about display items

        HFONT           m_hfontTitle;
        HFONT           m_hfontHeader;
        HFONT           m_hfontMenu;

        HBRUSH          m_hbrTopPanel;
        HBRUSH          m_hbrCenterPanel;
        HBRUSH          m_hbrBottomPanel;

        COLORREF        m_crTitleText;      
        COLORREF        m_crHeaderText;     
        COLORREF        m_crShadow;      

        COLORREF        m_crDisabledText;   
        COLORREF        m_crNormalText;     

        COLORREF        m_crCenterPanel;    // Color of the center panel - only used for background colors behind text
        COLORREF        m_crBottomPanel;    // Color of the bottom panel - only used for background colors behind text
        
        HCURSOR         m_hcurHand;

        int             m_cxClient;         // width of the client area (changes on maximize / restore)
        int             m_cyClient;         // height of the client area (changes on maximize / restore)
        int             m_cxTopPanel;       // height of the top band of color
        int             m_cyBottomPanel;    // height of the bottom band of color

        int             m_cTitleFontHeight;
        int             m_cHeaderFontHeight;
        int             m_cMenuFontHeight;

        HDC             m_hdcFlag;
        HDC             m_hdcHeader;
        HDC             m_hdcHeaderSub;

        HDC             m_hdcGradientTop;
        HDC             m_hdcGradientTop256;
        HDC             m_hdcGradientBottom;
        HDC             m_hdcGradientBottom256;
        HDC             m_hdcCloudsFlag;
        HDC             m_hdcCloudsFlag256;
        HDC             m_hdcCloudsFlagRTL;
        HDC             m_hdcCloudsFlagRTL256;

        HDC             m_rghdcArrows[2][4][3];    // {hicolor x locolor} x {yellow, red, green, blue} x {normal, hover, disabled}

        TCHAR           m_szTitle[MAX_PATH];   // string displayed at top, usually "Welcome to Microsoft Windows"
        TCHAR           m_szHeader[MAX_PATH];  // string displayed above menu, usually "What do you want to do?"

        BOOL            m_f8by6;            // true if we're 800x600, false if we're 640x480

        DWORD           m_dwScreen;         // screen we're on
        BOOL            m_fHighContrast;    // true if high contrast options should be used
        BOOL            m_fLowColor;        // true if we are in 256 or less color mode.
        HPALETTE        m_hpal;             // palette to use if in palette mode
        int             m_iColors;          // -1, 16, or 256 depending on the color mode we are in.
        int             m_cDesktopWidth;    // width of desktop at app initialization        
        int             m_cDesktopHeight;   // height of desktop at app initialization

        BOOL            m_fTaskRunning;     // true when we have a running task open
        int             m_iSelectedItem;    // the index of the selected menu

    public:
        CDlgApp();
        ~CDlgApp();

        void Register(HINSTANCE hInstance);
        BOOL InitializeData(LPSTR pszCmdLine);
        void Create(int nCmdShow);
        void MessageLoop();

    private:
        static LRESULT CALLBACK s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam);
        static LRESULT CALLBACK s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
        
        // Window Messages
        LRESULT OnCreate(HWND hwnd);
        LRESULT OnDestroy();
        LRESULT OnActivate(WPARAM wParam);
        LRESULT OnPaint(HDC hdc);
        LRESULT OnEraseBkgnd(HDC hdc);
        LRESULT OnLButtonUp(int x, int y, DWORD fwKeys);
        LRESULT OnMouseMove(int x, int y, DWORD fwKeys);
        LRESULT OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg);
        LRESULT OnCommand(int wID);
        LRESULT OnQueryNewPalette();
        LRESULT OnPaletteChanged(HWND hwnd);
        LRESULT OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis);
        LRESULT OnChangeScreen(DWORD dwScreen);

        // helper functions
        void _InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear);
        BOOL _SetColorTable();
        BOOL _CreateFonts(HDC hdc);
        BOOL _CreateBitmaps();
        BOOL _CreateArrowBitmaps();
        BOOL _CreateGradientBitmaps();
        
        BOOL _GetLargestStringWidth(HDC hdc, SIZE* psize);
        BOOL _AdjustToFitFonts();
        BOOL _DrawMenuIcon(HWND hwnd);
        BOOL _DrawMenuIcons(BOOL fEraseBackground);
        void _PaintHeaderBitmap();
        void _CreateMenu();
        void _RedrawMenu();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\dlgapp.cpp ===
//////////////////////////////////////////////////////////////////////////
//
//  dlgapp.cpp
//
//      This file contains the main entry point into the application and
//      the implementation of the CDlgApp class.
//
//  (C) Copyright 1997 by Microsoft Corporation. All rights reserved.
//
//////////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <commctrl.h>
#include <shlwapi.h>    // for string compare functions
#include <debug.h>
#include <tchar.h>
#include <winuser.h>
#pragma hdrstop

#include "autorun.h"
#include "dlgapp.h"
#include "dataitem.h"
#include "resource.h"

WNDPROC         g_fnBtnProc;        // the window proc for a button.

//////////////////////////////////////////////////////////////////////////
// #defines
//////////////////////////////////////////////////////////////////////////

// todo: generate these dynamically
#define FLAG_HEIGHT 43
#define FLAG_WIDTH  47

#define HEADER_HEIGHT 48
#define HEADER_WIDTH  48

#define MENUICON_HEIGHT 29
#define MENUICON_WIDTH  28

//////////////////////////////////////////////////////////////////////////
// Code
//////////////////////////////////////////////////////////////////////////

/**
*  This method is our contstructor for our class. It initialize all
*  of the instance data.
*/
CDlgApp::CDlgApp()
{
    m_fTaskRunning = FALSE;
    m_iSelectedItem = -1;
    g_fnBtnProc = NULL;

    m_hInstance     = NULL;
    m_hwnd          = NULL;

    m_fHighContrast = FALSE;

    m_hfontTitle  = NULL;
    m_hfontHeader = NULL;
    m_hfontMenu   = NULL;

    m_hbrTopPanel   = NULL;
    m_hbrCenterPanel  = NULL;
    m_hbrBottomPanel = NULL;

    m_szTitle[0] = NULL;
    m_szHeader[0] = NULL;
    
    // store desktop width
    RECT rcDesktop;
    SystemParametersInfo(SPI_GETWORKAREA,0, &rcDesktop, FALSE);
    m_cDesktopWidth = rcDesktop.right - rcDesktop.left;
    m_cDesktopHeight = rcDesktop.bottom - rcDesktop.top;
    if (m_cDesktopWidth >= 800)
    {
        m_f8by6 = TRUE;
    }
    else
    {
        m_f8by6 = FALSE;
    }
    
    m_hdcFlag = NULL;
    m_hdcHeader = NULL;
    m_hdcHeaderSub = NULL;
    m_hdcGradientTop = NULL;
    m_hdcGradientTop256 = NULL;
    m_hdcGradientBottom = NULL;
    m_hdcGradientBottom256 = NULL;
    m_hdcCloudsFlag = NULL;
    m_hdcCloudsFlag256 = NULL;
    m_hdcCloudsFlagRTL = NULL;
    m_hdcCloudsFlagRTL256 = NULL;
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                m_rghdcArrows[i][j][k] = NULL;
            }
        }
    }

    m_hcurHand = NULL;

    m_dwScreen = SCREEN_MAIN;
    m_fLowColor = FALSE;
    m_iColors = -1;
    m_hpal = NULL;
}

CDlgApp::~CDlgApp()
{
    DeleteObject(m_hfontTitle);
    DeleteObject(m_hfontHeader);
    DeleteObject(m_hfontMenu);

    DeleteObject(m_hbrTopPanel);
    DeleteObject(m_hbrCenterPanel);
    DeleteObject(m_hbrBottomPanel);

    DeleteDC(m_hdcFlag);
    DeleteDC(m_hdcHeader);
    DeleteDC(m_hdcHeaderSub);
    DeleteDC(m_hdcGradientTop);
    DeleteDC(m_hdcGradientTop256);
    DeleteDC(m_hdcGradientBottom);
    DeleteDC(m_hdcGradientBottom256);
    DeleteDC(m_hdcCloudsFlag);
    DeleteDC(m_hdcCloudsFlag256);
    DeleteDC(m_hdcCloudsFlagRTL);
    DeleteDC(m_hdcCloudsFlagRTL256);
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {
                DeleteDC(m_rghdcArrows[i][j][k]);
            }
        }
    }
}

/**
*  This method will register our window class for the application.
*
*  @param  hInstance   The application instance handle.
*
*  @return             No return value.
*/
void CDlgApp::Register(HINSTANCE hInstance)
{
    WNDCLASS  wndclass;

    m_hInstance = hInstance;
    
    wndclass.style          = CS_OWNDC | CS_DBLCLKS;
    wndclass.lpfnWndProc    = s_WndProc;
    wndclass.cbClsExtra     = 0;
    wndclass.cbWndExtra     = 0;
    wndclass.hInstance      = hInstance;
    wndclass.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_WEBAPP));
    wndclass.hCursor        = LoadCursor(NULL, IDC_ARROW);
    wndclass.hbrBackground  = NULL;
    wndclass.lpszMenuName   = NULL;
    wndclass.lpszClassName  = WINDOW_CLASS;

    RegisterClass(&wndclass);
}

/**
*  This method will initialize the data object.
*
*  @return         No return value.
*/
BOOL CDlgApp::InitializeData(LPSTR pszCommandLine)
{
    HWND hwnd = GetDesktopWindow();
    HDC hdc = GetDC( hwnd );
    m_iColors = GetDeviceCaps( hdc, NUMCOLORS );
    m_fLowColor = ((m_iColors != -1) && (m_iColors <= 256));
    if ( m_fLowColor )
    {
        m_hpal = CreateHalftonePalette(hdc);
    }

    // Initialize the items from the INI file.
    if ( !m_DataSrc.Init(pszCommandLine) )
    {
        // this is a sign from the data source that we should exit
        return FALSE;
    }

    // Are we in accesibility mode?  This call won't work on NT 4.0 because this flag wasn't known.
    HIGHCONTRAST hc;
    hc.cbSize = sizeof(HIGHCONTRAST);
    hc.dwFlags = 0; // avoid random result should SPI fail
    if ( SystemParametersInfo( SPI_GETHIGHCONTRAST, sizeof(HIGHCONTRAST), &hc, 0 ) )
    {
        m_fHighContrast = ( hc.dwFlags & HCF_HIGHCONTRASTON );
    }

    // 210679: go to HighContrast mode if we're in 16-color mode as well
    if ( m_fLowColor && (m_iColors <= 16))
    {
        m_fHighContrast = TRUE;
    }

    // Set the color table based on our HighContrast mode setting.
    _SetColorTable();

    // create the fonts that we need to use.
    _CreateFonts(hdc);

    // create the images
    _CreateBitmaps();
    _CreateArrowBitmaps();
    _CreateGradientBitmaps();


    // load the resource strings that we always need
    LoadStringAuto( m_hInstance, IDS_TITLE, m_szTitle, ARRAYSIZE(m_szTitle) );
    LoadStringAuto( m_hInstance, IDS_HEADER, m_szHeader, ARRAYSIZE(m_szHeader) );

    m_hcurHand = LoadCursor( m_hInstance, MAKEINTRESOURCE(IDC_BRHAND) );

    ReleaseDC( hwnd, hdc );

    return TRUE;
}
#if BUILD_SERVER_VERSION | BUILD_ADVANCED_SERVER_VERSION | BUILD_DATACENTER_VERSION | BUILD_BLADE_VERSION | BUILD_SMALL_BUSINESS_VERSION
#define CENTER_RGB_VALUES   RGB(122,131,137)
#define PANEL_RGB_VALUES    RGB(63,70,76)
#define DISABLED_RGB_VALUES RGB(64, 64, 64)
#else
#define CENTER_RGB_VALUES   RGB(90,126,220)
#define PANEL_RGB_VALUES    RGB(59,52,177)
#define DISABLED_RGB_VALUES RGB(128, 128, 128)
#endif
#define TITLE_RGB_VALUES    RGB(255, 255, 255)
#define HEADER_RGB_VALUES   RGB(214, 223, 245)
#define SHADOW_RGB_VALUES   RGB(52,  98,  189)
#define TEXT_RGB_VALUES     RGB(255, 255, 255)

BOOL CDlgApp::_SetColorTable()
{
    if ( m_fHighContrast )
    {
        // set to high contrast values
        m_hbrTopPanel   = (HBRUSH)(COLOR_BTNFACE+1);
        m_hbrCenterPanel = (HBRUSH)(COLOR_WINDOW+1);
        m_hbrBottomPanel = (HBRUSH)(COLOR_BTNFACE+1);

        m_crNormalText   = GetSysColor(COLOR_WINDOWTEXT);        
        m_crTitleText    = m_crNormalText;
        m_crHeaderText   = m_crNormalText;
        m_crDisabledText = GetSysColor(COLOR_GRAYTEXT);
        m_crCenterPanel  = GetSysColor(COLOR_WINDOW);
        m_crBottomPanel  = GetSysColor(COLOR_WINDOW);
    }
    else
    {
        m_crTitleText    = TITLE_RGB_VALUES;
        m_crHeaderText   = HEADER_RGB_VALUES;
        m_crShadow       = SHADOW_RGB_VALUES;
        m_crNormalText   = TEXT_RGB_VALUES;
        m_crDisabledText = DISABLED_RGB_VALUES;

        m_crCenterPanel  = CENTER_RGB_VALUES;
        m_crBottomPanel  = PANEL_RGB_VALUES;

        if ( m_fLowColor )
        {
            HBITMAP hbmp;
            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_TOP), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrTopPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrTopPanel = (HBRUSH)(COLOR_BTNFACE+1);

            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_BOTTOM), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrBottomPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrBottomPanel = (HBRUSH)(COLOR_BTNFACE+1);

            hbmp = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(IDB_CENTER), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
            if (hbmp)
            {
                m_hbrCenterPanel = CreatePatternBrush(hbmp);
                DeleteObject(hbmp);
            }
            else
                m_hbrCenterPanel = (HBRUSH)(COLOR_WINDOW+1);
                
        }
        else
        {
            m_hbrTopPanel   = CreateSolidBrush( PANEL_RGB_VALUES );
            m_hbrCenterPanel = CreateSolidBrush( CENTER_RGB_VALUES );
            m_hbrBottomPanel= CreateSolidBrush ( PANEL_RGB_VALUES );
        }
    }

    return TRUE;
}

// this is called once for each font that matches the fonts we care about
int CALLBACK FoundFont
(
  ENUMLOGFONTEX *lpelfe,    // logical-font data
  NEWTEXTMETRICEX *lpntme,  // physical-font data
  DWORD FontType,           // type of font
  LPARAM lParam             // application-defined data
)
{
    *((BOOL*)lParam) = TRUE;

    return 0;
}

#define RGFONTDEX_LARGE    0
#define RGFONTDEX_SMALL    1

#define RGFONTDEX_TITLE     0
#define RGFONTDEX_HEADER    1
#define RGFONTDEX_MENU      2

#define RGFONTDEX_FULL      0
#define RGFONTDEX_BACKUP    1


BOOL CDlgApp::_CreateFonts(HDC hdc)
{
    // [in]  array of IDs, arranged by {title, header, menu} x { nice font, backup font}
    const int rgFontID[3][2] = 
    {{IDS_FONTFACE_TITLE, IDS_FONTFACE_TITLE_BACKUP}, 
    {IDS_FONTFACE_HEADER,IDS_FONTFACE_HEADER_BACKUP}, 
    {IDS_FONTFACE_MENU, IDS_FONTFACE_MENU_BACKUP}};

    // [in]  array of heights, arranged by {large x small} x {title, header, menu} x { nice font, backup font}
    const int rgFontHeight[2][3][2] = 
    {{{IDS_FONTCY_TITLE, IDS_FONTCY_TITLE_BACKUP}, 
    {IDS_FONTCY_HEADER, IDS_FONTCY_HEADER_BACKUP}, 
    {IDS_FONTCY_MENU, IDS_FONTCY_MENU_BACKUP}},
    {{IDS_FONTCY_TITLE_LIL, IDS_FONTCY_TITLE_BACKUP_LIL}, 
    {IDS_FONTCY_HEADER_LIL, IDS_FONTCY_HEADER_BACKUP_LIL}, 
    {IDS_FONTCY_MENU_LIL, IDS_FONTCY_MENU_BACKUP_LIL}}};


    // [out] array of pointers to the fonts 
    HFONT* rgpFont[3] = {&m_hfontTitle, &m_hfontHeader, &m_hfontMenu};  
    
    // [out] array of pointers heights of each font
    int* rgpcyFont[3] = {&m_cTitleFontHeight, &m_cHeaderFontHeight, &m_cMenuFontHeight};  

    LOGFONT lf;
    CHARSETINFO csInfo;
    TCHAR szFontSize[6];
    
    for (int i = 0; i < ARRAYSIZE(rgpFont); i++)
    {
        ZeroMemory(&lf,sizeof(lf));
        lf.lfOutPrecision = OUT_DEFAULT_PRECIS;
        lf.lfClipPrecision = CLIP_DEFAULT_PRECIS;
        lf.lfQuality = DEFAULT_QUALITY;
        lf.lfPitchAndFamily = DEFAULT_PITCH|FF_SWISS;
        LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_FULL], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );

        // Set charset
        if (TranslateCharsetInfo((DWORD*)IntToPtr(GetACP()), &csInfo, TCI_SRCCODEPAGE) == 0)
        {
            csInfo.ciCharset = 0;
        }
        lf.lfCharSet = (BYTE)csInfo.ciCharset;

        LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_FULL], szFontSize, ARRAYSIZE(szFontSize) );
        *(rgpcyFont[i]) = _ttoi(szFontSize);
        lf.lfHeight = -(*(rgpcyFont[i]));

        BOOL fFound = FALSE;
        EnumFontFamiliesEx(hdc, &lf, (FONTENUMPROC)FoundFont, (LPARAM)&fFound, 0);
        if (!fFound)
        {
            LoadStringAuto( m_hInstance, rgFontID[i][RGFONTDEX_BACKUP], lf.lfFaceName, ARRAYSIZE(lf.lfFaceName) );
            LoadStringAuto( m_hInstance, rgFontHeight[m_f8by6 ? 0 : 1][i][RGFONTDEX_BACKUP], szFontSize, ARRAYSIZE(szFontSize) );
            *(rgpcyFont[i]) = _ttoi(szFontSize);
            lf.lfHeight = -(*(rgpcyFont[i]));
        }
        *(rgpFont[i]) = CreateFontIndirect(&lf);
    }

    return TRUE;
}

#define BITMAPTYPE_NORMAL           0x0
#define BITMAPTYPE_LOWCOLOR         0x1

BOOL CDlgApp::_CreateBitmaps()
{
    const int rgiBitmapID[3][2] = {{ IDB_FLAG, IDB_FLAG_256},
                           { IDB_HEADER, IDB_HEADER_256} ,
                           { IDB_HEADERSUB, IDB_HEADERSUB_256} }; // [in]
    HDC* rgphdc[3] = {&m_hdcFlag, &m_hdcHeader, &m_hdcHeaderSub}; // [out]
    
    int iBitmapType = (m_fLowColor) ? BITMAPTYPE_LOWCOLOR : BITMAPTYPE_NORMAL;
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;

        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][iBitmapType]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
        GetObject(hbm,sizeof(bm),&bm);
        
        SelectObject( *(rgphdc[i]), hbm );
    }

    return TRUE;
}

BOOL CDlgApp::_CreateArrowBitmaps()
{
    const int rgiBitmapID[2][4][3] = 
    {{{IDB_YELLOW, IDB_YELLOW_HOVER, IDB_YELLOW_DISABLED},    
    {IDB_RED, IDB_RED_HOVER, IDB_RED_DISABLED},
    {IDB_GREEN, IDB_GREEN_HOVER, IDB_GREEN_DISABLED},
    {IDB_BLUE, IDB_BLUE_HOVER, IDB_BLUE_DISABLED}},
    {{IDB_YELLOW_256, IDB_YELLOW_HOVER_256, IDB_YELLOW_DISABLED_256},    
    {IDB_RED_256, IDB_RED_HOVER_256, IDB_RED_DISABLED_256},
    {IDB_GREEN_256, IDB_GREEN_HOVER_256, IDB_GREEN_DISABLED_256},
    {IDB_BLUE_256, IDB_BLUE_HOVER_256, IDB_BLUE_DISABLED_256}}}; // [in]
    
    for (int i = 0; i < ARRAYSIZE(m_rghdcArrows); i++)
    {
        for (int j = 0; j < ARRAYSIZE(m_rghdcArrows[0]); j++)
        {    
            for (int k = 0; k < ARRAYSIZE(m_rghdcArrows[0][0]); k++)
            {    
                HBITMAP hbm;
                BITMAP bm;
                m_rghdcArrows[i][j][k] = CreateCompatibleDC(NULL);

                hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i][j][k]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);
    
                GetObject(hbm,sizeof(bm),&bm);
        
                SelectObject( m_rghdcArrows[i][j][k], hbm );
            }
        }
    }
    return TRUE;
}

BOOL CDlgApp::_CreateGradientBitmaps()
{
    const int rgiBitmapID[8] = {IDB_GRADIENT_TOP, IDB_GRADIENT_TOP_256, IDB_GRADIENT_BOTTOM, IDB_GRADIENT_BOTTOM_256, IDB_CLOUDSFLAG, IDB_CLOUDSFLAG_256, IDB_CLOUDSFLAG_RTL, IDB_CLOUDSFLAG_RTL_256}; // [in]
    HDC* rgphdc[8] = {&m_hdcGradientTop, &m_hdcGradientTop256, &m_hdcGradientBottom, &m_hdcGradientBottom256, &m_hdcCloudsFlag, &m_hdcCloudsFlag256, &m_hdcCloudsFlagRTL, &m_hdcCloudsFlagRTL256}; // [out]    
    
    for (int i = 0; i < ARRAYSIZE(rgphdc); i++)
    {
        HBITMAP hbm;
        BITMAP bm;
        *(rgphdc[i]) = CreateCompatibleDC(NULL);

        hbm = (HBITMAP)LoadImage(m_hInstance, MAKEINTRESOURCE(rgiBitmapID[i]), IMAGE_BITMAP, 0,0, LR_CREATEDIBSECTION);

        GetObject(hbm,sizeof(bm),&bm);
    
        SelectObject( *(rgphdc[i]), hbm );
    }
    return TRUE;
}

BOOL CDlgApp::_GetLargestStringWidth(HDC hdc, SIZE* psize)
{
    SIZE sCurr = {0};
    psize->cx = 0;
    psize->cy = 0;
    for (int i = 0; i < MAX_OPTIONS; i++)
    {
        if (GetTextExtentPoint32(hdc, m_DataSrc[i].GetTitle(), lstrlen(m_DataSrc[i].GetTitle()), &sCurr))
        {
            if (sCurr.cx > psize->cx)
            {
                memcpy(psize, &sCurr, sizeof(SIZE));
            }
        }
    }

    return (psize->cx > 0);
}

#define MENUITEMCX(x)      (m_f8by6 ? 270 : 210)
#define MENUITEMCY(x)      ((m_f8by6 ? 245 : 197) + ((x - 1) * (m_f8by6 ? 45 : 30)))

#define MENUEXITCX(x)      (m_f8by6 ? 75 : 63)
#define MENUEXITCY(x)      (m_f8by6 ? 540 : 406)

BOOL CDlgApp::_AdjustToFitFonts()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {    
        SetMapMode(hdc,MM_TEXT);
        
        // don't check for error, if these fail we're totally screwed anyway
        SIZE sizeLargest, sizeExit = {0};
        _GetLargestStringWidth(hdc, &sizeLargest);
        GetTextExtentPoint32(hdc, m_DataSrc[0].GetTitle(), lstrlen(m_DataSrc[0].GetTitle()), &sizeExit);
        
        for (int i=0; i < MAX_MENUITEMS; i++ )
        {
            DWORD dwType = m_DataSrc[i].m_dwType;        
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            SIZE* psize = (i == 0) ?  &sizeExit: &sizeLargest;
            SetWindowPos(hwnd, NULL, 
                         (i == 0) ? MENUEXITCX(i) : MENUITEMCX(i),
                         (i == 0) ? MENUEXITCY(i) : MENUITEMCY(i),
                         (psize->cx * 3) / 2, (psize->cy * 3) / 2, SWP_NOZORDER );
        }
        ReleaseDC(m_hwnd, hdc);
    }

    return TRUE;
}

#define MENUARROWCX(x) (m_f8by6 ? 232 : 177)
#define MENUARROWCY(x) ((m_f8by6 ? 244 : 194) + ((x - 1)* (m_f8by6 ? 45 : 30)))

#define EXITARROWCX(x) (m_f8by6 ? 42 : 32) 
#define EXITARROWCY(x) (m_f8by6 ? 537 : 403)

#define ARROWBITMAPSTUFF(rgarrows) if (WF_DISABLED & m_DataSrc[i].m_dwFlags) { phdcBitmap = &(rgarrows[2]); } else { phdcBitmap = (m_iSelectedItem == i) ? &(rgarrows[1]) : &(rgarrows[0]); }
#define EXITARROWBITMAPSTUFF(rgarrows) {phdcBitmap = (m_iSelectedItem == i) ? &(rgarrows[1]) : &(rgarrows[0]);}

BOOL CDlgApp::_DrawMenuIcons(BOOL fEraseBackground)
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        for (int i=0; i< m_DataSrc.m_iItems; i++ )
        {
            RECT rect;
            HDC* phdcBitmap;
            DWORD dwType = m_DataSrc[i].m_dwType;
            switch (dwType)
            {
            case INSTALL_WINNT: // special
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][2]);
                break;
            case EXIT_AUTORUN: // exit
                EXITARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][1]);
                break;
            case BACK: // back icon
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][0]);
                break;
            default: // normal icon for everything else
                ARROWBITMAPSTUFF(m_rghdcArrows[m_fLowColor ? 1 : 0][3]);
                break;
            }

            rect.left = (i == 0) ? (EXITARROWCX(i)) : (MENUARROWCX(i));
            rect.top  = (i == 0) ? (EXITARROWCY(i)) : (MENUARROWCY(i));

            rect.right = rect.left + MENUICON_WIDTH; // arrow width
            rect.bottom = rect.top + MENUICON_HEIGHT; // arrow height as well
            BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, *phdcBitmap, 0,0, SRCCOPY );
            _InvalidateRectIntl(m_hwnd, &rect, FALSE);
        }
        ReleaseDC(m_hwnd, hdc);
    }

    // clear any old icons as well
    RECT rect;
    rect.left = MENUARROWCX(0);
    rect.right = rect.left + MENUICON_WIDTH; // arrow width
    rect.top = MENUARROWCY(0);
    rect.bottom = m_cyClient;    
    _InvalidateRectIntl(m_hwnd, &rect, fEraseBackground);

    return TRUE;
}

void CDlgApp::_InvalidateRectIntl(HWND hwnd, RECT* pRect, BOOL fBackgroundClear)
{
    RECT* pRectToUse = pRect; // default to normal case (don't flip)
    RECT rectRTL;
    if (pRect)
    {
        OSVERSIONINFO osvi;
        if (GetVersionEx(&osvi) && 
            (osvi.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
            Mirror_IsWindowMirroredRTL(hwnd)) // right to left on Win9X
        {            
            rectRTL.top = pRect->top; rectRTL.bottom = pRect->bottom;
            rectRTL.right = m_cxClient - pRect->left;
            rectRTL.left = m_cxClient - pRect->right;
            pRectToUse = &rectRTL;
        }
    }
    InvalidateRect(hwnd, pRectToUse, fBackgroundClear);
}

/**
*  This method will create the application window.
*
*  @return         No return value.
*/
void CDlgApp::Create(int nCmdShow)
{
    //
    //  load the window title from the resource.
    //
    TCHAR szTitle[MAX_PATH];
    LoadStringAuto(m_hInstance, IDS_TITLEBAR, szTitle, ARRAYSIZE(szTitle));

    
    DWORD dwStyle = WS_OVERLAPPED | WS_MINIMIZEBOX | WS_CAPTION | WS_SYSMENU | WS_BORDER | WS_CLIPCHILDREN;
        
    if (m_cDesktopWidth >= 800)
    {
        m_cxClient = 800;
        m_cyClient = 600;
    }
    else
    {
        m_cxClient = 640;
        m_cyClient = 480;
    }

    m_hwnd = CreateWindowEx(
            WS_EX_CONTROLPARENT,
            WINDOW_CLASS,
            szTitle,
            dwStyle,
            0,
            0,
            m_cxClient,
            m_cyClient,
            NULL,
            NULL,
            m_hInstance,
            this);


    //  set the client area to a fixed size and center the window on screen
    RECT rect = {0};

    rect.left = (m_cDesktopWidth - m_cxClient) / 2;
    rect.top = (m_cDesktopHeight - m_cyClient) / 2;

    rect.right = m_cDesktopWidth - rect.left;
    rect.bottom = m_cDesktopHeight - rect.top;

    AdjustWindowRect( &rect, dwStyle, FALSE );
    
    SetWindowPos(m_hwnd, HWND_TOP, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, 0);
    ShowWindow(m_hwnd, SW_SHOW);

    m_cxTopPanel = m_f8by6 ? 80 : 64;
    m_cyBottomPanel = m_f8by6 ? 501 : 381;

    m_DataSrc.SetWindow( m_hwnd );

    _InvalidateRectIntl(m_hwnd, NULL, TRUE);
    UpdateWindow(m_hwnd);
}

/**
*  This method is our application message loop.
*
*  @return         No return value.
*/
void CDlgApp::MessageLoop()
{
    MSG msg;
    
    while (GetMessage(&msg, NULL, 0, 0))
    {
        // IsDialogMessage cannot understand the concept of ownerdraw default pushbuttons.  It treats
        // these attributes as mutually exclusive.  As a result, we handle this ourselves.  We want
        // whatever control has focus to act as the default pushbutton.
        if ( (WM_KEYDOWN == msg.message) && (VK_RETURN == msg.wParam) )
        {
            HWND hwndFocus = GetFocus();
            if ( hwndFocus )
            {
                SendMessage(m_hwnd, WM_COMMAND, MAKELONG(GetDlgCtrlID(hwndFocus), BN_CLICKED), (LPARAM)hwndFocus);
            }
            continue;
        }

        if ( IsDialogMessage(m_hwnd, &msg) )
            continue;

        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}

/**
*  This is the window procedure for the container application. It is used
*  to deal with all messages to our window.
*
*  @param      hwnd        Window handle.
*  @param      msg         The window message.
*  @param      wParam      Window Parameter.
*  @param      lParam      Window Parameter.
*
*  @return     LRESULT
*/
LRESULT CALLBACK CDlgApp::s_WndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(hwnd, GWLP_USERDATA);
    
    switch(msg)
    {
    case WM_NCCREATE:
        {
            CDlgApp* pThisCreate = (CDlgApp *)(((LPCREATESTRUCT)lParam)->lpCreateParams);
            SetWindowLongPtr(hwnd, GWLP_USERDATA, (LRESULT)pThisCreate);
        }
        break;

    case WM_CREATE:        
        return pThis->OnCreate(hwnd);

    case WM_DESTROY:
        return pThis->OnDestroy();

    case WM_ACTIVATE:
        return pThis->OnActivate(wParam);

    case WM_PAINT:
        return pThis->OnPaint((HDC)wParam);

    case WM_ERASEBKGND:
        return pThis->OnEraseBkgnd((HDC)wParam);

    case WM_LBUTTONUP:
        return pThis->OnLButtonUp(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_MOUSEMOVE:
        return pThis->OnMouseMove(LOWORD(lParam), HIWORD(lParam), (DWORD)wParam);

    case WM_SETCURSOR:
        return pThis->OnSetCursor((HWND)wParam, LOWORD(lParam), HIWORD(lParam));

    case WM_COMMAND:
    case WM_SYSCOMMAND:
        if ( pThis->OnCommand(LOWORD(wParam)) )
            return 0;
        break;

    case WM_DRAWITEM:
        return pThis->OnDrawItem((UINT)wParam, (LPDRAWITEMSTRUCT)lParam);

    case WM_QUERYNEWPALETTE:
        return pThis->OnQueryNewPalette();

    case WM_PALETTECHANGED:
        return pThis->OnPaletteChanged((HWND)wParam);

    case ARM_CHANGESCREEN:
        return pThis->OnChangeScreen((DWORD)wParam);
    
    }
    
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

/**
*  This method is called on WM_CREATE.
*
*  @param  hwnd    Window handle for the application.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnCreate(HWND hwnd)
{
    m_hwnd = hwnd;
    _CreateMenu();
    _RedrawMenu();
    return 0;
}

void CDlgApp::_CreateMenu()
{
    // Create one window for each button.  These windows will get resized and moved
    // after we call AdjustToFitFonts.
    
    for (int i=0; i<MAX_MENUITEMS; i++)
    {
        HWND hwnd = CreateWindowEx(
                0,
                TEXT("BUTTON"),
                TEXT(""),
                WS_CHILD|WS_VISIBLE|WS_TABSTOP|BS_PUSHBUTTON|BS_MULTILINE|BS_OWNERDRAW,
                0,0,0,0,
                m_hwnd,
                NULL,
                m_hInstance,                            
                NULL );
        
        SetWindowLongPtr(hwnd, GWLP_ID, IDM_MENUITEM0 + i);
        SendMessage(hwnd, WM_SETFONT, (WPARAM)m_hfontMenu, 0);
        g_fnBtnProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)s_ButtonWndProc);        
        EnableWindow(hwnd, i < m_DataSrc.m_iItems);
    }

    // Set focus to first menu item
    SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM1));

    // We created the windows with zero size, now we adjust that size to take into
    // account for the selected font size, etc.
    _AdjustToFitFonts();
}

void CDlgApp::_RedrawMenu()
{
    for (int i=0; i < MAX_MENUITEMS; i++)
    {
        // setting window text only actually sets the accelerator, real drawing of text is in OnDrawItem
        SetWindowText(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), (i < m_DataSrc.m_iItems) ? m_DataSrc[i].GetTitle() : TEXT(""));
        EnableWindow(GetDlgItem(m_hwnd, IDM_MENUITEM0+i), (i < m_DataSrc.m_iItems));
    }
}

/**
*  This method handles the WM_DESTROY message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnDestroy()
{
    // ensure this is the last message we care about
    SetWindowLongPtr(m_hwnd, GWLP_USERDATA, 0);
    
    PostQuitMessage(0);

    return 0;
}

LRESULT CDlgApp::OnActivate(WPARAM wParam)
{
    return 0;
}

/**
*  This method handles the WM_PAINT message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnPaint(HDC hdc)
{
    // this code makes the window look better when being dragged around
    PAINTSTRUCT ps;
    BeginPaint(m_hwnd,&ps);
    EndPaint(m_hwnd,&ps);

    return 0;
}

/**
*  This method handles the WM_ERASEBKGND message.
*
*  @return         No return value.
*/
LRESULT CDlgApp::OnEraseBkgnd(HDC hdc)
{
    RECT rect;
    
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(hdc, m_hpal, FALSE);
        RealizePalette(hdc);
    }

    SetMapMode(hdc, MM_TEXT);
    SetBkMode(hdc, TRANSPARENT);

    // Draw the top pane:
    rect.left = 0;
    rect.top = 0;
    rect.right = m_cxClient;
    rect.bottom = m_cxTopPanel;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, m_hdcGradientTop256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrTopPanel);
    }

    // Draw the center pane:
    rect.left = 0;
    rect.top = m_cxTopPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyBottomPanel;
    FillRect(hdc, &rect, m_hbrCenterPanel);

    // Drag the clouds/flag bitmap
    if (m_f8by6)
    {
        rect.left = 0;
        rect.top = m_cxTopPanel;
        rect.right = 397;
        rect.bottom = m_cxTopPanel + 180;
        HDC hdcCloudsFlag;
        if (Mirror_IsWindowMirroredRTL(m_hwnd))
        {
            hdcCloudsFlag = m_fLowColor? m_hdcCloudsFlagRTL256 : m_hdcCloudsFlagRTL;
        }
        else
        {
            hdcCloudsFlag = m_fLowColor? m_hdcCloudsFlag256 : m_hdcCloudsFlag;
        }

        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, hdcCloudsFlag , 0,0, SRCCOPY | NOMIRRORBITMAP);
    }

    // Draw the bottom pane:
    rect.left = 0;
    rect.top = m_cyBottomPanel;
    rect.right = m_cxClient;
    rect.bottom = m_cyClient;
    if (m_f8by6 && !m_fLowColor)
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom, 0,0, SRCCOPY );
    }
    else if (m_f8by6 && m_fLowColor && (m_iColors > 16))
    {
        BitBlt( hdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top + 1, m_hdcGradientBottom256, 0,0, SRCCOPY );
    }
    else
    {
        FillRect(hdc, &rect, m_hbrBottomPanel);
    }


    // Draw the flag bitmap if in 640x480
    if (!m_f8by6)
    {
        rect.left = 20;
        rect.top = 80;
        rect.right = rect.left + FLAG_WIDTH;
        rect.bottom = rect.top + FLAG_HEIGHT;
        BitBlt( hdc, rect.left, rect.top, FLAG_WIDTH, FLAG_HEIGHT, m_hdcFlag, 0,0, SRCCOPY | NOMIRRORBITMAP); // don't mirror flag on RTL systems for trademark reasons
    }

    // Draw the header bitmap:
    _PaintHeaderBitmap();

    // draw menu icons
    _DrawMenuIcons(FALSE);

    // draw header text
    if (m_f8by6)
    {
        rect.left = 237;
        rect.top  = 192;
    }
    else
    {
        rect.left = 197;
        rect.top  = 142;
    }
    rect.right = rect.left + 400;
    rect.bottom = rect.top + m_cHeaderFontHeight;
    
    HFONT hfontOld = (HFONT)SelectObject(hdc,m_hfontHeader);
    if ( !m_fHighContrast )
    {
        SetTextColor(hdc,m_crShadow);
        DrawText(hdc,m_szHeader,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    }
    _InvalidateRectIntl(m_hwnd, &rect, FALSE);

    rect.left -= 2; rect.right -= 2; rect.top -= 2; rect.bottom -= 2;

    SetTextColor(hdc,m_crHeaderText);
    DrawText(hdc,m_szHeader,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    _InvalidateRectIntl(m_hwnd, &rect, FALSE);

    // draw title text
    if (m_f8by6)
    {
        rect.left = 97;
        rect.top  = 105;
    }
    else
    {
        rect.left = 72;
        rect.top  = 63;
    }
    rect.right = rect.left + 700;
    rect.bottom = rect.top + m_cTitleFontHeight;
    
    (HFONT)SelectObject(hdc,m_hfontTitle);
    if ( !m_fHighContrast )
    {
        SetTextColor(hdc,m_crShadow);
        DrawText(hdc,m_szTitle,-1,&rect,DT_NOCLIP|DT_WORDBREAK);
    }

    rect.left -= 2; rect.right -= 2; rect.top -= 2; rect.bottom -= 2;
    SetTextColor(hdc,m_crTitleText);
    DrawText(hdc,m_szTitle,-1,&rect,DT_NOCLIP|DT_WORDBREAK);

    // restore the DC to its original value
    SelectObject(hdc,hfontOld);
    if(hpalOld)
        SelectPalette(hdc, hpalOld, FALSE);


    return TRUE;
}

void CDlgApp::_PaintHeaderBitmap()
{
    HDC hdc = GetDC(m_hwnd);
    if (hdc)
    {
        RECT rect;
        if (m_f8by6)
        {
            rect.left = 177;
            rect.top = 186;
        }
        else
        {
            rect.left = 137;
            rect.top = 133;
        }
        rect.right = rect.left + HEADER_WIDTH;
        rect.bottom = rect.top + HEADER_HEIGHT;
        BitBlt( hdc, rect.left, rect.top, HEADER_WIDTH, HEADER_HEIGHT, (SCREEN_MAIN == m_dwScreen) ? m_hdcHeader : m_hdcHeaderSub, 0,0, SRCCOPY );
        _InvalidateRectIntl(m_hwnd, &rect, FALSE);
        ReleaseDC(m_hwnd, hdc);
    }
}

LRESULT CDlgApp::OnMouseMove(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        POINT pt;
        pt.x = x;
        pt.y = y;
        for (int i=0; i<m_DataSrc.m_iItems; i++)
        {
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            RECT rect;
            rect.left = (i > 0) ? MENUARROWCX(i) : EXITARROWCX(i);  
            rect.top  = (i > 0) ? MENUARROWCY(i) : EXITARROWCY(i);  
            rect.right = rect.left + MENUICON_WIDTH;
            rect.bottom = rect.top + MENUICON_HEIGHT;

            if (PtInRect(&rect, pt))
            {
                SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + i));
                SetCursor(m_hcurHand);
                return 0;
            }
        }

        SetCursor(LoadCursor(NULL,IDC_ARROW));
    }
    return 0;
}

LRESULT CDlgApp::OnLButtonUp(int x, int y, DWORD fwKeys)
{    
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        POINT pt;
        pt.x = x;
        pt.y = y;

        for (int i=0; i<m_DataSrc.m_iItems; i++)
        {
            HWND hwnd = GetDlgItem(m_hwnd, IDM_MENUITEM0+i);
            RECT rect;
            rect.left = (i > 0) ? MENUARROWCX(i) : EXITARROWCX(i);  
            rect.top  = (i > 0) ? MENUARROWCY(i) : EXITARROWCY(i);  
            rect.right = rect.left + MENUICON_WIDTH;
            rect.bottom = rect.top + MENUICON_HEIGHT;

            if (PtInRect(&rect, pt))
            {
                OnCommand(IDM_MENUITEM0 + i);
                return 0;
            }
        }
    }
    return 0;
}

LRESULT CDlgApp::OnSetCursor(HWND hwnd, int nHittest, int wMouseMsg)
{
    if (GetForegroundWindow() == m_hwnd) // only care if we have focus
    {
        if ( !m_fTaskRunning )
        {
            if ( hwnd != m_hwnd )
            {
                SetCursor(m_hcurHand);
                return TRUE;
            }
        }

        SetCursor(LoadCursor(NULL,IDC_ARROW));
    }
    return TRUE;
}

LRESULT CDlgApp::OnChangeScreen(DWORD dwScreen)
{
    static DWORD dwSelectedOld; // we store the last position on the main screen

    if (m_dwScreen != dwScreen)
    {
        m_dwScreen = dwScreen;
        _RedrawMenu();
        _DrawMenuIcons(TRUE);
        UpdateWindow(m_hwnd);
        _PaintHeaderBitmap();

        if (SCREEN_MAIN == dwScreen) // if switching back to main, restore selection
        {
            m_iSelectedItem = dwSelectedOld;
        }
        else // otherwise default to the first item in the selection
        {
            dwSelectedOld = m_iSelectedItem;
            m_iSelectedItem = 1;
        }
        SetFocus(GetDlgItem(m_hwnd, IDM_MENUITEM0 + m_iSelectedItem));
    }
    return TRUE;
}

LRESULT CDlgApp::OnCommand(int wID)
{
    if ( !m_fTaskRunning )
    {
        int iNewSelectedItem = m_iSelectedItem;
        BOOL fRun = FALSE;
        
        switch(wID)
        {
        case IDM_MENUITEM0:
            PostQuitMessage( 0 );
            break;
            
        case IDM_MENUITEM1:
        case IDM_MENUITEM2:
        case IDM_MENUITEM3:
        case IDM_MENUITEM4:
        case IDM_MENUITEM5:
        case IDM_MENUITEM6:
        case IDM_MENUITEM7:
            fRun = TRUE;
            m_iSelectedItem = wID - IDM_MENUITEM0;
            // m_iSelectedItem should be a real menu item now, but just to make sure:
            ASSERT( (m_iSelectedItem < m_DataSrc.m_iItems) && (m_iSelectedItem >= 0) );
            break;
            
        default:
            // When we hit this then this isn't a message we care about.  We return FALSE which
            // tells our WndProc to call DefWndProc which makes everything happy.
            return FALSE;
        }
        
        if ( fRun )
        {
            m_fTaskRunning = TRUE;
            m_DataSrc.Invoke( m_iSelectedItem, m_hwnd );
            m_fTaskRunning = FALSE;
        }
    }
    else
    {
        // currently the only commands that are valid while another task is running are
        // IDM_SHOWCHECK and anything that goes to the default handler above.  Everything
        // else will come to here and cause a message beep
        MessageBeep(0);
    }
    return TRUE;
}

LRESULT CDlgApp::OnQueryNewPalette()
{
    if ( m_hpal )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            UnrealizeObject(m_hpal);
            RealizePalette(hdc);
            UpdateWindow(m_hwnd);
            if(hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
        return TRUE;
    }
    return FALSE;
}

LRESULT CDlgApp::OnPaletteChanged(HWND hwnd)
{
    if ( m_hpal && (m_hwnd != hwnd) )
    {
        HDC hdc = GetDC(m_hwnd);
        if (hdc)
        {
            HPALETTE hpalOld = SelectPalette(hdc, m_hpal, FALSE);
            RealizePalette(hdc);
            UpdateColors(hdc);
            if (hpalOld)
                SelectPalette(hdc, hpalOld, FALSE);
            ReleaseDC(m_hwnd, hdc);
        }
    }
    return TRUE;
}

LRESULT CDlgApp::OnDrawItem(UINT iCtlID, LPDRAWITEMSTRUCT pdis)
{
    int i = iCtlID - IDM_MENUITEM0;
    RECT rect = pdis->rcItem;
    HPALETTE hpalOld = NULL;

    if ( m_hpal )
    {
        hpalOld = SelectPalette(pdis->hDC, m_hpal, FALSE);
        RealizePalette(pdis->hDC);
    }

    FillRect( pdis->hDC, &rect, (i > 0) ? m_hbrCenterPanel : m_hbrBottomPanel);    

    if (i < m_DataSrc.m_iItems)
    {
        SetBkMode(pdis->hDC, TRANSPARENT);
        SetTextColor(
                pdis->hDC,
                ((m_DataSrc[i].m_dwFlags&WF_ALTERNATECOLOR)?m_crDisabledText:m_crNormalText));
        DrawText(pdis->hDC,m_DataSrc[i].GetTitle(),-1,&rect,DT_NOCLIP|DT_WORDBREAK);

        if ( pdis->itemState & ODS_FOCUS )
        {
            if ( m_fHighContrast )
            {
                rect.left -= 1;
                rect.top -= 2;
                rect.right += 1;
                rect.bottom -= 2;
                DrawFocusRect(pdis->hDC,&rect);
            }
        }
    }
    if ( hpalOld )
    {
        SelectPalette(pdis->hDC, hpalOld, FALSE);
    }
    _DrawMenuIcons(FALSE);

    return TRUE;
}


LRESULT CALLBACK CDlgApp::s_ButtonWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CDlgApp *pThis = (CDlgApp *)GetWindowLongPtr(GetParent(hwnd), GWLP_USERDATA);
    switch (uMsg)
    {
    case WM_ERASEBKGND:
        return TRUE;
        break;
    case WM_MOUSEMOVE:
        if (GetForegroundWindow() == GetParent(hwnd))
        {
            if ( !pThis->m_fTaskRunning )
            {
                int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM0;
        
                if ( iID != pThis->m_iSelectedItem )
                {
                    SetFocus(hwnd);
                }
            }
        }
        else
        {
            return FALSE;
        }
        break;

    case WM_SETFOCUS:
        if (GetForegroundWindow() == GetParent(hwnd))
        {
            if ( !pThis->m_fTaskRunning )
            {
                int iID = ((int)GetWindowLongPtr(hwnd, GWLP_ID)) - IDM_MENUITEM0;
                if ( iID != pThis->m_iSelectedItem )
                {
                    pThis->m_iSelectedItem = iID;
                    SetFocus(GetDlgItem(GetParent(hwnd), IDM_MENUITEM0+iID));
                }
            }
        }
        else
        {
            return FALSE;
        }
        break;
    }

    return CallWindowProc(g_fnBtnProc, hwnd, uMsg, wParam, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\util.h ===
#pragma once

#include <ntverp.h>

#define ARM_CHANGESCREEN   WM_APP + 2
// Forced to define these myself because they weren't on Win95.

#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

// winver 0x0500 definition
#ifndef NOMIRRORBITMAP
#define NOMIRRORBITMAP            (DWORD)0x80000000
#endif // NOMIRRORBITMAP

// Relative Version
enum RELVER
{ 
    VER_UNKNOWN,        // we haven't checked the version yet
    VER_INCOMPATIBLE,   // the current os cannot be upgraded using this CD (i.e. win32s)
    VER_OLDER,          // current os is an older version on NT or is win9x
    VER_SAME,           // current os is the same version as the CD
    VER_NEWER,          // the CD contains a newer version of the OS
};


// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(HMODULE hModule, UINT wID, LPSTR lpBuffer,  int cchBufferMax);

BOOL Mirror_IsWindowMirroredRTL(HWND hWnd);

BOOL LocalPathRemoveFileSpec(LPTSTR pszPath);
LPSTR LocalStrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize);
BOOL LocalPathAppendA(LPTSTR pszPath, LPTSTR pszNew, UINT cchPath);
BOOL SafeExpandEnvStringsA(LPSTR pszSource, LPSTR pszDest, UINT cchDest);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\util.cpp ===
// util.cpp: Utility functions
//
//////////////////////////////////////////////////////////////////////

#include <windows.h>
#include <winbase.h>    // for GetCommandLine
#include "util.h"
#include <debug.h>
#include "resource.h"

// LoadStringExW and LoadStringAuto are stolen from shell\ext\mlang\util.cpp
//
// Extend LoadString() to to _LoadStringExW() to take LangId parameter
int LoadStringExW(
    HMODULE    hModule,
    UINT      wID,
    LPWSTR    lpBuffer,            // Unicode buffer
    int       cchBufferMax,        // cch in Unicode buffer
    WORD      wLangId)
{
    HRSRC hResInfo;
    HANDLE hStringSeg;
    LPWSTR lpsz;
    int    cch;

    
    // Make sure the parms are valid.     
    if (lpBuffer == NULL || cchBufferMax == 0) 
    {
        return 0;
    }

    cch = 0;
    
    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.     
    if (hResInfo = FindResourceExW(hModule, (LPCWSTR)RT_STRING,
                                   (LPWSTR)IntToPtr(((USHORT)wID >> 4) + 1), wLangId)) 
    {        
        // Load that segment.        
        hStringSeg = LoadResource(hModule, hResInfo);
        
        // Lock the resource.        
        if (lpsz = (LPWSTR)LockResource(hStringSeg)) 
        {            
            // Move past the other strings in this segment.
            // (16 strings in a segment -> & 0x0F)             
            wID &= 0x0F;
            while (TRUE) 
            {
                cch = *((WORD *)lpsz++);   // PASCAL like string count
                                            // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                // Step to start if next string
             }
            
            // Account for the NULL                
            cchBufferMax--;
                
            // Don't copy more than the max allowed.                
            if (cch > cchBufferMax)
                cch = cchBufferMax-1;
                
            // Copy the string into the buffer.                
            CopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));

            // Attach Null terminator.
            lpBuffer[cch] = 0;
        }
    }

    return cch;
}

#define LCID_ENGLISH 0x409

typedef LANGID (*GETUI_ROUTINE) ();

#define REGSTR_RESOURCELOCALE TEXT("Control Panel\\Desktop\\ResourceLocale")

void _GetUILanguageWin9X(LANGID* plangid)
{
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_RESOURCELOCALE, 0, KEY_READ, &hkey))
    {
        TCHAR szBuffer[9];
        DWORD cbData = sizeof(szBuffer);
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, NULL, NULL, NULL, (LPBYTE)szBuffer, &cbData))
        {
            *plangid = (LANGID)strtol(szBuffer, NULL, 16);
        }
        RegCloseKey(hkey);
    }
}

void _GetUILanguageWinNT(LANGID* plangid)
{
    HMODULE hmodule = GetModuleHandle("kernel32.dll"); 
    if (hmodule)
    {
        GETUI_ROUTINE NT5API = (GETUI_ROUTINE)GetProcAddress(hmodule, "GetSystemDefaultLangID");
        if (NT5API)
        {
            *plangid = NT5API();
        }
    }
}

LANGID GetUILanguage()
{
    LANGID langid = LCID_ENGLISH;
    OSVERSIONINFO osv = {0};
    osv.dwOSVersionInfoSize = sizeof(osv);
    if (GetVersionEx(&osv))
    {
        if (VER_PLATFORM_WIN32_WINDOWS == osv.dwPlatformId) // Win9X
        {
            _GetUILanguageWin9X(&langid);
        }
        else if ((VER_PLATFORM_WIN32_NT == osv.dwPlatformId) && 
                 (osv.dwMajorVersion >= 4)) // WinNT, only support NT4 and higher
        {
            _GetUILanguageWinNT(&langid);
        }
    }
    return langid;
}

BOOL _GetBackupLangid(LANGID langidUI, LANGID* plangidBackup)
{
    BOOL fSuccess = TRUE;
    switch (PRIMARYLANGID(langidUI))
    {
    case LANG_SPANISH:
        *plangidBackup = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH_MODERN);
        break;
    case LANG_CHINESE:      // chinese and portuguese have multiple locales, there is no good default for them.
    case LANG_PORTUGUESE:
        fSuccess = FALSE;
        break;
    default:
        *plangidBackup = MAKELANGID(PRIMARYLANGID(langidUI), SUBLANG_DEFAULT);
        break;
    }
    return fSuccess;
}

// LoadString from the correct resource
//   try to load in the system default language
//   fall back to english if fail
int LoadStringAuto(
    HMODULE    hModule,
    UINT      wID,
    LPSTR     lpBuffer,            
    int       cchBufferMax)
{
    int iRet = 0;

    LPWSTR lpwStr = (LPWSTR) LocalAlloc(LPTR, cchBufferMax*sizeof(WCHAR));

    if (lpwStr)
    {        
        iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, GetUILanguage());
        if (!iRet)
        {
            LANGID backupLangid;
            if (_GetBackupLangid(GetUILanguage(), &backupLangid))
            {
                iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, backupLangid);
            }
            
            if (!iRet)
            {
                iRet = LoadStringExW(hModule, wID, lpwStr, cchBufferMax, LCID_ENGLISH);
            }
        }

        if (iRet)
            iRet = WideCharToMultiByte(CP_ACP, 0, lpwStr, iRet, lpBuffer, cchBufferMax, NULL, NULL);

        if(iRet >= cchBufferMax)
            iRet = cchBufferMax-1;

        lpBuffer[iRet] = 0;

        LocalFree(lpwStr);
    }

    return iRet;
}

#define WS_EX_LAYOUTRTL         0x00400000L // Right to left mirroring
BOOL Mirror_IsWindowMirroredRTL(HWND hWnd)
{
    return (GetWindowLongA( hWnd , GWL_EXSTYLE ) & WS_EX_LAYOUTRTL );
}

// stolen from shell\shlwapi\path.c (b/c we ship downlevel)
BOOL LocalPathRemoveFileSpec(LPTSTR pszPath)
{
    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1), "LocalPathRemoveFileSpec: caller passed bad pszPath");

    if (pszPath)
    {
        LPTSTR pT;
        LPTSTR pT2 = pszPath;

        for (pT = pT2; *pT2; pT2 = CharNext(pT2))
        {
            if (*pT2 == TEXT('\\'))
            {
                pT = pT2;             // last "\" found, (we will strip here)
            }
            else if (*pT2 == TEXT(':'))     // skip ":\" so we don't
            {
                if (pT2[1] == TEXT('\\'))    // strip the "\" from "C:\"
                {
                    pT2++;
                }
                pT = pT2 + 1;
            }
        }

        if (*pT == 0)
        {
            // didn't strip anything
            return FALSE;
        }
        else if (((pT == pszPath) && (*pT == TEXT('\\'))) ||                        //  is it the "\foo" case?
                 ((pT == pszPath+1) && (*pT == TEXT('\\') && *pszPath == TEXT('\\'))))  //  or the "\\bar" case?
        {
            // Is it just a '\'?
            if (*(pT+1) != TEXT('\0'))
            {
                // Nope.
                *(pT+1) = TEXT('\0');
                return TRUE;        // stripped something
            }
            else
            {
                // Yep.
                return FALSE;
            }
        }
        else
        {
            *pT = 0;
            return TRUE;    // stripped something
        }
    }
    return  FALSE;
}

// stolen from shlwapi\strings.c
LPSTR LocalStrCatBuffA(LPSTR pszDest, LPCSTR pszSrc, int cchDestBuffSize)
{
    if (pszDest && pszSrc)
    {
        LPSTR psz = pszDest;

        // we walk forward till we find the end of pszDest, subtracting
        // from cchDestBuffSize as we go.
        while (*psz)
        {
            psz++;
            cchDestBuffSize--;
        }

        if (cchDestBuffSize > 0)
        {
            lstrcpyn(psz, pszSrc, cchDestBuffSize);
        }
    }
    return pszDest;
}

// a poor man's path append
BOOL LocalPathAppendA(LPTSTR pszPath, LPTSTR pszNew, UINT cchPath)
{
    if ('\\' != pszPath[lstrlen(pszPath) - 1])
    {
        LocalStrCatBuffA(pszPath, TEXT("\\"), cchPath);
    }
    LocalStrCatBuffA(pszPath, pszNew, cchPath);
    return TRUE;
}

BOOL SafeExpandEnvStringsA(LPSTR pszSource, LPSTR pszDest, UINT cchDest)
{
    UINT cch = ExpandEnvironmentStrings(pszSource, pszDest, cchDest);
    return (cch > 0 && cch <= cchDest);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\autorun\sources.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

# relative path to root of shell project
CCSHELL_DIR     = $(PROJECT_ROOT)

INCLUDES=$(CCSHELL_DIR)\inc

!if $(386)
CHICAGO_LIB_PATH=$(SDK_LIB_DEST)\chicago\i386
SHELL32_LIB_FILE=$(CCSHELL_DIR)\lib\i386\shell32.w95
!else
CHICAGO_LIB_PATH=$(SDK_LIB_PATH)
SHELL32_LIB_FILE=$(SDK_LIB_PATH)\shell32.lib
!endif

TARGETNAME = autorun
TARGETPATH = obj
TARGETTYPE = PROGRAM

# msadek; DO NOT link with msvcrt.lib as it will cause problems
# with win95 and winnt3.51

TARGETLIBS= \
    $(CHICAGO_LIB_PATH)\gdi32.lib         \
    $(SHELL32_LIB_FILE)

UMTYPE=windows
UMENTRY=winmain

NOT_LEAN_AND_MEAN=1
SUBSYSTEM_VERSION=4.00
CHICAGO_PRODUCT=1

SOURCES = \
    ..\autorun.cpp \
    ..\dataitem.cpp \
    ..\datasrc.cpp \
    ..\dlgapp.cpp  \
    ..\resource.rc \
    ..\util.cpp

#
# Separate versions are built for server and professional
#
!if "$(SERVER)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_SERVER_VERSION
!elseif "$(SERVER)" == "2"
C_DEFINES=$(C_DEFINES) -DBUILD_ADVANCED_SERVER_VERSION
!elseif "$(SERVER)" == "3"
C_DEFINES=$(C_DEFINES) -DBUILD_DATACENTER_VERSION
!elseif "$(SERVER)" == "4"
C_DEFINES=$(C_DEFINES) -DBUILD_BLADE_VERSION
!elseif "$(SERVER)" == "5"
C_DEFINES=$(C_DEFINES) -DBUILD_SMALL_BUSINESS_VERSION
!elseif "$(PERSONAL)" == "1"
C_DEFINES=$(C_DEFINES) -DBUILD_PERSONAL_VERSION
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\callback.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    callback.h
**
** Purpose: Defines the IEmptyVoluemCacheCallback interface for 
**          the cleanup manager.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef CALLBACK_H
#define CALLBACK_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif

#ifndef EMPTYVC_H
    #include <emptyvc.h>
#endif



/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Class declarations
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Class:   CVolumeCacheCallBack
** Purpose: Implements the IEmptyVolumeCacheCallBack interface
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
class CVolumeCacheCallBack : public IEmptyVolumeCacheCallBack {
private:
protected:
	//
	// Data
	//
	ULONG       m_cRef;         // Reference count

public:

    //  
    //Constructors
    //
    CVolumeCacheCallBack    (void);
    ~CVolumeCacheCallBack   (void);

	//
    // IUnknown interface members
	//
	STDMETHODIMP            QueryInterface (REFIID, LPVOID FAR *);
	STDMETHODIMP_(ULONG)    AddRef (void);
	STDMETHODIMP_(ULONG)    Release (void);

    //
    //IEmptyVolumeCacheCallBack interface members
    //
    STDMETHODIMP    ScanProgress(
                        DWORDLONG dwSpaceUsed,
                        DWORD dwFlags,
                        LPCWSTR pszStatus
                        );

    STDMETHODIMP    PurgeProgress(
                        DWORDLONG dwSpaceFreed,
                        DWORDLONG dwSpaceToFree,
                        DWORD dwFlags,
                        LPCWSTR pszStatus
                        );

	void SetCleanupMgrInfo(PVOID pVoid);
    void SetCurrentClient(PVOID pVoid);


}; // CVolumeCacheCallBack


typedef CVolumeCacheCallBack *PCVOLUMECACHECALLBACK;

#endif CALLBACK_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\callback.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    callback.cpp
**
** Purpose: Defines the IEmptyVoluemCacheCallback interface for 
**          the cleanup manager.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "callback.h"
#include "dmgrinfo.h"
#include "dmgrdlg.h"



/*
**------------------------------------------------------------------------------
**	Local variables
**------------------------------------------------------------------------------
*/
static PCLIENTINFO g_pClientInfo;   // Set to the current CLIENTINFO struct

static CleanupMgrInfo *g_pcmi;		


CVolumeCacheCallBack::CVolumeCacheCallBack(
    void
    )
{
	g_pClientInfo = NULL;
	g_pcmi = NULL;
}

CVolumeCacheCallBack::~CVolumeCacheCallBack(
    void
    )
{
	;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::QueryInterface
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    riid  -  interface ID to query on 
**    ppv   -  pointer to interface if we support it
** Return:     NOERROR on success, E_NOINTERFACE otherwise
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP CVolumeCacheCallBack::QueryInterface(
   REFIID      riid, 
   LPVOID FAR *ppv
   )
{
    *ppv = NULL;

    //
    //Check for IUnknown interface request
    //
    if (IsEqualIID (riid, IID_IUnknown))
    {
        // 
        //Typecast to the requested interface so C++ sets up
        //the virtual tables correctly
        //
        *ppv = (LPUNKNOWN)(LPEMPTYVOLUMECACHECALLBACK) this;
        AddRef();
        return NOERROR;
    }  

    
    //
    //Check for IEmptyVolumeCacheCallBack interface request
    //
    if (IsEqualIID (riid, IID_IEmptyVolumeCacheCallBack))
    {
        // 
        //Typecast to the requested interface so C++ sets up
        //the virtual tables correctly
        //
        *ppv = (LPEMPTYVOLUMECACHECALLBACK) this;
        AddRef();
        return NOERROR;
    }  

    //
    //Error - unsupported interface requested
    //
    return E_NOINTERFACE;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::AddRef
**
** Purpose:    ups the reference count to this object
** Notes;
** Return:     current refernce count
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP_(ULONG) CVolumeCacheCallBack::AddRef()
{
    return ++m_cRef;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::Release
**
** Purpose:    downs the reference count to this object
**             and deletes the object if no one is using it
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP_(ULONG) CVolumeCacheCallBack::Release()
{
    //  
    //Decrement and check
    //
    if (--m_cRef)
        return m_cRef;

    //
    //No references left to this object
    //
    delete this;

    return 0L;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::ScanProgress
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    dwSpaceUsed	-  Amount of space that the client can free so far
**    dwFlags		-  IEmptyVolumeCache flags
**	  pszStatus		-  Display string to tell the user what is happening
** Return:     If E_ABORT then this indicates that no more notifications
**			   are required and the client should abort the scan.  S_OK
**			   if the client should continue scanning.
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP
CVolumeCacheCallBack::ScanProgress(
	DWORDLONG dwSpaceUsed,
	DWORD dwFlags,
	LPCWSTR pszStatus
	)
{
	//
	//Update the amount of used disk space for this client
	//
	if (g_pClientInfo)
		g_pClientInfo->dwUsedSpace.QuadPart = dwSpaceUsed;

	//
	//Check the Flags.  If this is the last notification from this client
	//then set g_pClientInfo to NULL
	//
	if (dwFlags & EVCCBF_LASTNOTIFICATION)
		g_pClientInfo = NULL;

	//
	//Has the user aborted the scan?  If so let the cleanup object know
	//so that it can stop scanning
	//
	if (g_pcmi->bAbortScan)
		return E_ABORT;

	else
		return S_OK;
}

/*
**------------------------------------------------------------------------------
** CVolumeCacheCallBack::PurgeProgress
**
** Purpose:    Part of the IUnknown interface
** Parameters:
**    dwSpaceFreed	-  Amount of disk space freed so far.
**	  dwSpaceToFree -  Amount the client was expected to free.
**    dwFlags		-  IEmptyVolumeCache flags
**	  pszStatus		-  Display string to tell the user what is happening
** Return:     If E_ABORT then this indicates that no more notifications
**			   are required and the client should abort the scan.  S_OK
**			   if the client should continue scanning.
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
STDMETHODIMP
CVolumeCacheCallBack::PurgeProgress(
	DWORDLONG dwSpaceFreed,
	DWORDLONG dwSpaceToFree,
	DWORD dwFlags,
	LPCWSTR pszStatus
	)
{
	g_pcmi->cbCurrentClientPurgedSoFar.QuadPart = dwSpaceFreed;

	//
	//Update the progress bar
	//
	PostMessage(g_pcmi->hAbortPurgeWnd, WMAPP_UPDATEPROGRESS, 0, 0);


	//
	//Has the user aborted the purge?  If so let the cleanup object know
	//so that it can stop purging
	//
	if (g_pcmi->bAbortPurge)
		return E_ABORT;

	else
		return S_OK;
}

void
CVolumeCacheCallBack::SetCleanupMgrInfo(
	PVOID pVoid
	)
{
	if (pVoid)
		g_pcmi = (CleanupMgrInfo*)pVoid;
}

void
CVolumeCacheCallBack::SetCurrentClient(
	PVOID pVoid
	)
{
	if (pVoid)
		g_pClientInfo = (PCLIENTINFO)pVoid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\diskguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    diskguid.h
**
** Purpose: Defines The 'Disk Space Cleanup Property Sheet' Class ID for OLE 2.0
** Notes:   The unique Class ID of this Disk Space Cleanup Shell extension class is:
**
**          E0568D07-88AE-11d0-8B0C-00805F8ABE06
**
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DISKGUID_H
#define DISKGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/
// {E0568D07-88AE-11d0-8B0C-00805F8ABE06}
DEFINE_GUID(CLSID_CleanMgrShellExt, 
0xe0568d07, 0x88ae, 0x11d0, 0x8b, 0xc, 0x0, 0x80, 0x5f, 0x8a, 0xbe, 0x6);



#endif // DISKGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\common.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Manager
** File:    common.h
**
** Purpose: various common stuff for this module
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
#define COMMON_H


/*
**------------------------------------------------------------------------------
**  Microsoft C++ include files
**------------------------------------------------------------------------------
*/
#ifndef STRICT
    #define STRICT
#endif

#define INC_OLE2           // WIN32, get ole2 from windows.h

#include <windows.h>
#include <windowsx.h>

#include <shlobj.h>
#include <shlobjp.h>

#include <shlwapi.h>
#include <shlwapip.h>

#include <initguid.h>
#include <regstr.h>
#include <strsafe.h>

#include "resource.h"

#include "cmstrings.h"
#include "ids.h"

#ifdef _DEBUG
   #define DEBUG
#endif


#define ARRAYSIZE(x)    (sizeof(x)/sizeof(x[0]))

#define FLAG_SAGESET                0x00000001
#define FLAG_SAGERUN                0x00000002
#define FLAG_TUNEUP                 0x00000004
#define FLAG_LOWDISK                0x00000008
#define FLAG_VERYLOWDISK            0x00000010
#define FLAG_SETUP                  0x00000020

#define FLAG_SAVE_STATE             0x80000000

#define STATE_SELECTED              0x00000001
#define STATE_SAGE_SELECTED         0x00000002

#define RETURN_SUCCESS              0x00000001
#define RETURN_CLEANER_FAILED       0x00000002
#define RETURN_USER_CANCELED_SCAN   0x00000003
#define RETURN_USER_CANCELED_PURGE  0x00000004

#ifdef NEC_98
#define SZ_DEFAULT_DRIVE            TEXT("A:\\")
#else
#define SZ_DEFAULT_DRIVE            TEXT("C:\\")
#endif

#define SZ_CLASSNAME                TEXT("CLEANMGR")
#define SZ_STATE                    TEXT("StateFlags")
#define SZ_DEFAULTICONPATH          TEXT("CLSID\\%s\\DefaultIcon")

#define SZ_RUNDLL32                 TEXT("RUNDLL32.EXE")
#define SZ_INSTALLED_PROGRAMS       TEXT("shell32.dll,Control_RunDLL appwiz.cpl")
#define SZ_RUN_INSTALLED_PROGRAMS   TEXT("control.exe appwiz.cpl")

#define SZ_SYSOCMGR                 TEXT("sysocmgr.exe")
#define SZ_WINDOWS_SETUP            TEXT("/i:%s\\sysoc.inf")

#define DEFAULT_PRIORITY            200

#define MAX_GUID_STRING_LEN         39
#define INTER_ITEM_SPACE            10
#define DESCRIPTION_LENGTH          512
#define BUTTONTEXT_LENGTH           50
#define MAX_DESC_LEN                100
#define INDENT                      5
#define  cbRESOURCE                 256
#define NUM_BYTES_IN_MB             0x100000

extern HINSTANCE    g_hInstance;
extern HWND         g_hDlg;

#ifdef DEBUG
#define MI_TRAP                     _asm int 3

void
DebugPrint(
    HRESULT hr,
    LPCSTR  lpFormat,
    ...
    );


#define MiDebugMsg( args )          DebugPrint args

#else

#define MI_TRAP
#define MiDebugMsg( args )

#endif // DEBUG


#endif // COMMON_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\cleanmgr.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    cleanmgr.cpp
**
** Purpose: WinMain for the Disk Cleanup applet.
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#define CPP_FUNCTIONS
#include "crtfree.h"

#include "dmgrinfo.h"

#include "diskguid.h"
#include "resource.h"
#include "textout.h"
#include "dmgrdlg.h"
#include "msprintf.h"
#include "diskutil.h"
#include "seldrive.h"
#include "drivlist.h"

/*
**------------------------------------------------------------------------------
** Global Defines
**------------------------------------------------------------------------------
*/
#define SWITCH_HIDEUI               'N'
#define SWITCH_HIDEMOREOPTIONS      'M'
#define SWITCH_DRIVE                'D'

#define SZ_SAGESET                  TEXT("/SAGESET")
#define SZ_SAGERUN                  TEXT("/SAGERUN")
#define SZ_TUNEUP                   TEXT("/TUNEUP")
#define SZ_SETUP                    TEXT("/SETUP")

#define SZ_LOWDISK                  TEXT("/LOWDISK")
#define SZ_VERYLOWDISK              TEXT("/VERYLOWDISK")

/*
**------------------------------------------------------------------------------
** Global variables
**------------------------------------------------------------------------------
*/
HINSTANCE   g_hInstance = NULL;
HWND        g_hDlg = NULL;
BOOL        g_bAlreadyRunning = FALSE;

/*
**------------------------------------------------------------------------------
** ParseCommandLine
**
** Purpose:    Parses command line for switches
** Parameters:
**    lpCmdLine command line string
**    pdwFlags  pointer to flags DWORD
**    pDrive    pointer to a character that the drive letter
**              is returned in
** Return:     TRUE if command line contains /SAGESET or
**              /SAGERUN
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL
ParseCommandLine(
    LPTSTR  lpCmdLine,
    PDWORD  pdwFlags,
    PULONG  pulProfile
    )
{
    LPTSTR  lpStr = lpCmdLine;
    BOOL    bRet = FALSE;
    int     i;
    TCHAR   szProfile[4];

    *pulProfile = 0;

    //
    //Look for /SAGESET:n on the command line
    //
    if ((lpStr = StrStrI(lpCmdLine, SZ_SAGESET)) != NULL)
    {
        lpStr += lstrlen(SZ_SAGESET);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_SAGESET;
        bRet = TRUE;
    }

    //
    //Look for /SAGERUN:n on the command line
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_SAGERUN)) != NULL)
    {
        lpStr += lstrlen(SZ_SAGERUN);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_SAGERUN;
        bRet = TRUE;
    }

    //
    //Look for /TUNEUP:n
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_TUNEUP)) != NULL)
    {
        lpStr += lstrlen(SZ_TUNEUP);
        if (*lpStr && *lpStr == ':')
        {
            lpStr++;
            i = 0;
            while (*lpStr && *lpStr != ' ' && i < 4)
            {
                szProfile[i] = *lpStr;
                lpStr++;
                i++;
            }

            *pulProfile = StrToInt(szProfile);
        }

        *pdwFlags = FLAG_TUNEUP | FLAG_SAGESET;
        bRet = TRUE;
    }

    //
    //Look for /LOWDISK
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_LOWDISK)) != NULL)
    {
        lpStr += lstrlen(SZ_LOWDISK);
        *pdwFlags = FLAG_LOWDISK;
        bRet = TRUE;
    }

    //
    //Look for /VERYLOWDISK
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_VERYLOWDISK)) != NULL)
    {
        lpStr += lstrlen(SZ_VERYLOWDISK);
        *pdwFlags = FLAG_VERYLOWDISK | FLAG_SAGERUN;
        bRet = TRUE;
    }

    //
    //Look for /SETUP
    //
    else if ((lpStr = StrStrI(lpCmdLine, SZ_SETUP)) != NULL)
    {
        lpStr += lstrlen(SZ_SETUP);
        *pdwFlags = FLAG_SETUP | FLAG_SAGERUN;
        bRet = TRUE;
    }

    return bRet;
}

/*
**------------------------------------------------------------------------------
** ParseForDrive
**
** Purpose:    Parses command line for switches
** Parameters:
**    lpCmdLine command line string
**    pDrive    Buffer that the drive string will be returned
**              in, the format will be x:\
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL 
ParseForDrive(
    LPTSTR lpCmdLine,
    PTCHAR pDrive
    )
{
    LPTSTR  lpStr = lpCmdLine;

    GetBootDrive(pDrive, 4);

    while (*lpStr)
    {
        //
        //Did we find a '-' or a '/'?
        //
        if ((*lpStr == '-') || (*lpStr == '/'))
        {
            lpStr++;

            //
            //Is this the Drive switch?
            //
            if (*lpStr && (toupper(*lpStr) == SWITCH_DRIVE))
            {
                //
                //Skip any white space
                //
                                lpStr++;
                while (*lpStr && *lpStr == ' ')
                                        lpStr++;

                //
                //The next character is the driver letter
                //
                if (*lpStr)
                {
                    pDrive[0] = (TCHAR)toupper(*lpStr);
                    pDrive[1] = ':';
                    pDrive[2] = '\\';
                    pDrive[3] = '\0';
                    return TRUE;
                }
            }
        }

        lpStr++;
    }

    return FALSE;
}

BOOL CALLBACK EnumWindowsProc(
    HWND hWnd,
    LPARAM lParam
    )
{
    TCHAR   szWindowTitle[260];

    GetWindowText(hWnd, szWindowTitle, ARRAYSIZE(szWindowTitle));
    if (StrCmp(szWindowTitle, (LPTSTR)lParam) == 0)
    {
        MiDebugMsg((0, "There is already an instance of cleanmgr.exe running on this drive!"));
        SetForegroundWindow(hWnd);
        g_bAlreadyRunning = TRUE;
        return FALSE;
    }

    return TRUE;
}



/*
**------------------------------------------------------------------------------
**
** ProcessMessagesUntilEvent() - This does a message loop until an event or a
**                               timeout occurs.  
**
**------------------------------------------------------------------------------
*/

DWORD ProcessMessagesUntilEvent(HWND hwnd, HANDLE hEvent, DWORD dwTimeout)
{
    MSG msg;
    DWORD dwEndTime = GetTickCount() + dwTimeout;
    LONG lWait = (LONG)dwTimeout;
    DWORD dwReturn;

    for (;;)
    {
        dwReturn = MsgWaitForMultipleObjects(1, &hEvent,
                FALSE, lWait, QS_ALLINPUT);

        // were we signalled or did we time out?
        if (dwReturn != (WAIT_OBJECT_0 + 1))
        {
            break;
        }

        // we woke up because of messages.
        while (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE))
        {
            TranslateMessage(&msg);
            if (msg.message == WM_SETCURSOR)
            {
                SetCursor(LoadCursor(NULL, IDC_WAIT));
            }
            else
            {
                DispatchMessage(&msg);
            }
        }

        // calculate new timeout value
        if (dwTimeout != INFINITE)
        {
            lWait = (LONG)dwEndTime - GetTickCount();
        }
    }
    
    return dwReturn;
}



/*
**------------------------------------------------------------------------------
**
** WaitForARP() - Waits for the "Add/Remove Programs" Control Panel applet to
**                be closed by the user.
**
**------------------------------------------------------------------------------
*/

void WaitForARP()
{
    HWND hwndARP = NULL;
    HANDLE hProcessARP = NULL;
    DWORD dwProcId = 0;
    TCHAR szARPTitle[128];

    // We want to wait until the user closes "Add/Remove Programs" to continue.
    // To do this, we must first get an HWND to the dialog window.  This is
    // accomplished by trying to find the window by its title for no more than
    // about 5 seconds (looping 10 times with a 0.5 second delay between attempts).
    LoadString(g_hInstance, IDS_ADDREMOVE_TITLE, szARPTitle, ARRAYSIZE(szARPTitle));
    for (int i = 0; (i < 10) && (!hwndARP); i++)
    {
        hwndARP = FindWindow(NULL, szARPTitle);
        Sleep(500);
    }

    // If we got the HWND, then we can get the process handle, and wait
    // until the Add/Remove process goes away to continue.
    if (hwndARP)
    {
        GetWindowThreadProcessId(hwndARP, &dwProcId);
        hProcessARP = OpenProcess(SYNCHRONIZE, FALSE, dwProcId);
        if (hProcessARP)
        {
            ProcessMessagesUntilEvent(hwndARP, hProcessARP, INFINITE);
            CloseHandle(hProcessARP);
        }
    }
}

int APIENTRY WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    DWORD           dwFlags = 0;
    CleanupMgrInfo  *pcmi = NULL;
    TCHAR           szDrive[4];
    TCHAR           szSageDrive[4];
    TCHAR           szCaption[64];
    TCHAR           szInitialMessage[812];
    TCHAR           szFinalMessage[830];
    ULONG           ulProfile = 0;
    WNDCLASS        cls = {0};
    TCHAR           szVolumeName[MAX_PATH];
    int             RetCode = RETURN_SUCCESS;
    int             nDoAgain = IDYES;
    ULARGE_INTEGER  ulFreeBytesAvailable,
                    ulTotalNumberOfBytes,
                    ulTotalNumberOfFreeBytes;
    UINT            uiTotalFreeMB;
    STARTUPINFO     si;
    PROCESS_INFORMATION    pi;
    BOOL            fFirstInstance = TRUE;
    HWND            hwnd = NULL;
    HANDLE          hEvent = NULL;


    //
    // Decide if this is the first instance
    //

    hEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("Cleanmgr:  Instance event"));

    if (hEvent)
    {
        if (GetLastError() == ERROR_ALREADY_EXISTS)
        {
            fFirstInstance = FALSE;
        }
    }

    g_hInstance = hInstance;

    InitCommonControls();

    //
    //Initialize support classes
    //
    CleanupMgrInfo::Register(hInstance);

    cls.lpszClassName  = SZ_CLASSNAME;
    cls.hCursor        = LoadCursor(NULL, IDC_ARROW);
    cls.hIcon          = LoadIcon(hInstance, MAKEINTRESOURCE(ICON_CLEANMGR));
    cls.hbrBackground  = (HBRUSH)(COLOR_WINDOW + 1);
    cls.hInstance      = hInstance;
    cls.style          = CS_HREDRAW | CS_VREDRAW;
    cls.lpfnWndProc    = DefDlgProc;
    cls.cbWndExtra     = DLGWINDOWEXTRA;
    RegisterClass(&cls);

    //
    //Parse the command line
    //
    ParseCommandLine(lpCmdLine, &dwFlags, &ulProfile);

    if (!ParseForDrive(lpCmdLine, szDrive) && 
        !(dwFlags & FLAG_SAGESET) &&
        !(dwFlags & FLAG_SAGERUN))
    {
PromptForDisk:
        if (!SelectDrive(szDrive))
            goto Cleanup_Exit;
    }
    
    // Also check for any of the final series of dialogs which may display after the main UI has gone away 
    if (!g_bAlreadyRunning)
    {
        LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
        EnumWindows(EnumWindowsProc, (LPARAM)szCaption);

        LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
        EnumWindows(EnumWindowsProc, (LPARAM)szCaption);
    }
    
    // If we didn't catch another instance of cleanmgr via EnumWindows(), we catch it with a
    // named event.  We wait until now to do it so EnumWindows() can bring the other instance's
    // window to the foreground if it is up.
    if (!fFirstInstance)
    {
        g_bAlreadyRunning = TRUE;
    }

    if (g_bAlreadyRunning)
    {
        RetCode = FALSE;
        goto Cleanup_Exit;
    }
    
    if (dwFlags & FLAG_SAGERUN)
    {
        szSageDrive[1] = TCHAR(':');
        szSageDrive[2] = TCHAR('\\');
        szSageDrive[3] = TCHAR('\0');

        for (TCHAR c = 'A'; c <= 'Z'; c++)
        {
            szSageDrive[0] = c;

            //
            //Create CleanupMgrInfo object for this drive
            //
            pcmi = new CleanupMgrInfo(szSageDrive, dwFlags, ulProfile);
            if (pcmi != NULL && pcmi->isAbortScan() == FALSE  && pcmi->isValid())
            {
                pcmi->purgeClients();
            }

            // Keep the latest scan window handle (but hide the window)
            if (pcmi && pcmi->hAbortScanWnd)
            {
                hwnd = pcmi->hAbortScanWnd;
                ShowWindow(hwnd, SW_HIDE);
            }
            
            //
            //Destroy the CleanupMgrInfo object for this drive
            //
            if (pcmi)
            {
                RetCode = pcmi->dwReturnCode;
                
                if ( pcmi->hAbortScanWnd )
                {
                    pcmi->bAbortScan = TRUE;
                    WaitForSingleObject(pcmi->hAbortScanThread, INFINITE);
                    pcmi->bAbortScan = FALSE;
                }
                
                delete pcmi;
                pcmi = NULL;
            }
        }
    }
    else
    {
        //
        //Create CleanupMgrInfo object
        //
        pcmi = new CleanupMgrInfo(szDrive, dwFlags, ulProfile);
        if (pcmi != NULL && pcmi->isAbortScan() == FALSE)
        {
            //
            //User specified an invalid drive letter
            //
            if (!(pcmi->isValid()))
            {
                // dismiss the dialog first
                if ( pcmi->hAbortScanWnd )
                {
                    pcmi->bAbortScan = TRUE;

                    //
                    //Wait for scan thread to finish
                    //  
                    WaitForSingleObject(pcmi->hAbortScanThread, INFINITE);

                    pcmi->bAbortScan = FALSE;
                }
                
                TCHAR   szWarningTitle[256];
                TCHAR   *pszWarning;
                pszWarning = SHFormatMessage( MSG_BAD_DRIVE_LETTER, szDrive );
                LoadString(g_hInstance, IDS_TITLE, szWarningTitle, ARRAYSIZE(szWarningTitle));

                MessageBox(NULL, pszWarning, szWarningTitle, MB_OK | MB_SETFOREGROUND);
                LocalFree(pszWarning);

                if (pcmi)
                {
                    delete pcmi;
                    pcmi = NULL;
                    goto PromptForDisk;
                }
            }
            else
            {
                //Bring up the main dialog
                int nResult = DisplayCleanMgrProperties(NULL, (LPARAM)pcmi);
                if (nResult)
                {
                    pcmi->dwUIFlags |= FLAG_SAVE_STATE;
                
                    //
                    //Need to purge the clients if we are NOT
                    //in the SAGE settings mode.
                    //
                    if (!(dwFlags & FLAG_SAGESET) && !(dwFlags & FLAG_TUNEUP)  && pcmi->bPurgeFiles)
                        pcmi->purgeClients();
                }   
            }
        }

        //
        //Destroy the CleanupMgrInfo object
        //
        if (pcmi)
        {
            RetCode = pcmi->dwReturnCode;
            delete pcmi;
            pcmi = NULL;
        }
    }

    GetStartupInfo(&si);

    // If we were called on a low free disk space case, we want to inform the user of how much space remains,
    // and encourage them to free up space via Add/Remove programs until they reach 200MB free in the /LOWDISK
    // case, or 50MB free in the /VERYLOWDISK case.
    while (nDoAgain == IDYES)
    {
        BOOL bFinalTime = FALSE;
            
        nDoAgain = IDNO;

        // Bring up the Low Disk message box
        if (dwFlags & FLAG_LOWDISK)
        {
            GetDiskFreeSpaceEx(szDrive, &ulFreeBytesAvailable, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes);
            uiTotalFreeMB = (UINT) (ulTotalNumberOfFreeBytes.QuadPart / (NUM_BYTES_IN_MB));
            if (uiTotalFreeMB < 200)
            {
                if (uiTotalFreeMB < 80)
                {
                    LoadString(g_hInstance, IDS_LOWDISK_MESSAGE2, szInitialMessage, ARRAYSIZE(szInitialMessage));
                }
                else
                {
                    LoadString(g_hInstance, IDS_LOWDISK_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                }

                LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
                StringCchPrintf(szFinalMessage, ARRAYSIZE(szFinalMessage), szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONWARNING | MB_TOPMOST);
            }
            else
            {
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                StringCchPrintf(szFinalMessage, ARRAYSIZE(szFinalMessage), szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_TOPMOST);
                bFinalTime = TRUE;
            }
        }
        else if (dwFlags & FLAG_VERYLOWDISK)
        {
            // Bring up the Very Low Disk message box
            GetDiskFreeSpaceEx(szDrive, &ulFreeBytesAvailable, &ulTotalNumberOfBytes, &ulTotalNumberOfFreeBytes);
            uiTotalFreeMB = (UINT) (ulTotalNumberOfFreeBytes.QuadPart / (NUM_BYTES_IN_MB));
            if (uiTotalFreeMB < 50)
            {
                LoadString(g_hInstance, IDS_LOWDISK_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_VERYLOWDISK_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                StringCchPrintf(szFinalMessage, ARRAYSIZE(szFinalMessage), szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONSTOP | MB_TOPMOST);
            }
            else
            {
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_CAPTION, szCaption, ARRAYSIZE(szCaption));
                LoadString(g_hInstance, IDS_LOWDISK_SUCCESS_MESSAGE, szInitialMessage, ARRAYSIZE(szInitialMessage));
                StringCchPrintf(szFinalMessage, ARRAYSIZE(szFinalMessage), szInitialMessage, uiTotalFreeMB);
                nDoAgain = MessageBox(hwnd, szFinalMessage, szCaption, MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2 | MB_TOPMOST);
                bFinalTime = TRUE;
            }
        }

        if (nDoAgain == IDYES)
        {
            // Launch the Add/Remove Programs dialog
            TCHAR szFullPath[MAX_PATH];
            HRESULT hr = StringCchCopy(szInitialMessage, ARRAYSIZE(szInitialMessage), SZ_RUN_INSTALLED_PROGRAMS);
            
            hr = GetSystemDirectory(szFullPath, ARRAYSIZE(szFullPath))? S_OK : E_FAIL;
            if (SUCCEEDED(hr))
            {
                hr = PathAppend(szFullPath, szInitialMessage) ? S_OK : E_FAIL;
            }
            
            if (SUCCEEDED(hr) && CreateProcess(NULL, szFullPath, NULL, NULL, FALSE, NORMAL_PRIORITY_CLASS, NULL, NULL, &si, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);

                // Only bother to wait around if it is not our final time through
                if (! bFinalTime)
                {
                    WaitForARP();                    
                }
                else
                {
                    // If this was our final time through, then set the flag
                    // to break out of the loop
                    nDoAgain = IDNO;
                }
            }
            else
            {
                // If we cannot launch Add/Remove programs for some reason, we break
                // out of the loop
                nDoAgain = IDNO;
            }
        }
    }

Cleanup_Exit:

    if (hEvent)
    {
        CloseHandle (hEvent);
    }

    CleanupMgrInfo::Unregister();

    return RetCode;
}


STDAPI_(int) ModuleEntry(void)
{
    int i;
    STARTUPINFOA si;
    LPTSTR pszCmdLine = GetCommandLine();

    //
    // We don't want the "No disk in drive X:" requesters, so we set
    // the critical error mask such that calls will just silently fail
    //

    SetErrorMode(SEM_FAILCRITICALERRORS);

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfoA(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);

    // Since we now have a way for an extension to tell us when it is finished,
    // we will terminate all processes when the main thread goes away.

    return i;
}

void _cdecl main()
{
    ModuleEntry();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\diskutil.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    diskutil.h
**
** Purpose: General Disk utility functions
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DISKUTIL_H
#define DISKUTIL_H


/*
**------------------------------------------------------------------------------
** Project include files 
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif


/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/

#ifndef  cb1MEG
   #define  cb1MEG         ((ULONG)1048576L)
   #define  cb2MEG         (cb1MEG * 2L)
   #define  cb5MEG         (cb1MEG * 5L)
   #define  cb10MEG        (cb1MEG * 10L)
   #define  cb50MEG        (cb1MEG * 50L)
   #define  cb100MEG       (cb1MEG * 100L)
#endif

#ifndef DRENUM
#define DRENUM
typedef enum
   {
   Drive_A = 0,
   Drive_B, Drive_C, Drive_D, Drive_E, Drive_F,
   Drive_G, Drive_H, Drive_I, Drive_J, Drive_K,
   Drive_L, Drive_M, Drive_N, Drive_O, Drive_P,
   Drive_Q, Drive_R, Drive_S, Drive_T, Drive_U,
   Drive_V, Drive_W, Drive_X, Drive_Y, Drive_Z,
   Drive_INV,
   Drive_ALL
   } drenum;
#endif // DRENUM


typedef enum  
   {
   hwUnknown,
   hwINVALID,
   hwRemoveable,
   hwFixed,
   hwNetwork,
   hwCDROM,
   hwRamDrive,
   hwFloppy
   } hardware;


typedef enum 
   {
   vtINVALID,
   vtDoubleSpace,
   vtDriveSpace,
   vtFrosting,
   vtMixed,
   vtFuture
   } volumetype;

typedef struct _DEVIOCTL_REGISTERS {
	DWORD reg_EBX;
	DWORD reg_EDX;
	DWORD reg_ECX;
	DWORD reg_EAX;
	DWORD reg_EDI;
	DWORD reg_ESI;
	DWORD reg_Flags;
} DEVIOCTL_REGISTERS, *PDEVIOCTL_REGISTERS;

/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/

BOOL fIsSingleDrive(
    LPTSTR lpDrive
    );

BOOL 
fIsValidDriveString(
    const TCHAR * szDrive
    );

BOOL 
GetDriveFromString(
    const TCHAR * szDrive, 
    drenum & dre
    );

BOOL 
CreateStringFromDrive(
    drenum dre, 
    TCHAR * szDrive, 
    ULONG cLen
    );

HICON
GetDriveIcon(
    drenum dre,
    BOOL bSmallIcon
	);

BOOL
GetDriveDescription(
    drenum dre, 
    TCHAR *psz,
    size_t cch
    );

BOOL 
GetHardwareType(
    drenum dre, 
    hardware &hwType
    );

ULARGE_INTEGER
GetFreeSpaceRatio(
	WORD dwDrive,
	ULARGE_INTEGER cbTotal
	);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\diskutil.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    diskutil.cpp
**
** Purpose: Disk utility functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "diskutil.h"   
#include "msprintf.h"
#include "resource.h"


#define Not_VxD
#include <vwin32.h>



/*
**------------------------------------------------------------------------------
** fIsSingleDrive
**
** Purpose:    gets a drive letter from a drive string
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
fIsSingleDrive (
    LPTSTR lpDrive
    )
{
    //  
    //Is it a valid drive string ?!?
    //
    if (!fIsValidDriveString(lpDrive))
        return FALSE;

    //  
    //Is it a valid drive ?!?
    //
    BOOL rc = FALSE;

    UINT driveType = GetDriveType (lpDrive);
    switch (driveType)
    {
        case 0:                 // Unknown drive type
        case 1:                 // Invalid drive type
            break;

        case DRIVE_REMOVABLE:   // Removable drive (floppy,bernoulli,syquest,etc)
        case DRIVE_FIXED:       // Hard disk
            // We support removeable and fixed drives
            rc = TRUE;
            break;
      
        case DRIVE_REMOTE:      // Network
        case DRIVE_CDROM:       // CD-ROM
            break;

        case DRIVE_RAMDISK:     // RAM disk
            // We support ram drives, even though it's rather dubious
            rc = TRUE;
            break;

        default:                // Unknown drive type
            break;
    }

    return rc;
}

/*
**------------------------------------------------------------------------------
** fIsValidDriveString
**
** Purpose:    determines if a drive is a valid drive string
** Note:       assumes a drive string consists of a drive letter,
**             colon, and slash characters and nothing else.
**             Example:  "C:\"
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
fIsValidDriveString(
    const TCHAR * szDrive
    )
{
    //  
    //Make sure we have a valid string
    //
    if ((szDrive == NULL) || (szDrive[0] == 0))
        return FALSE;

    //  
    //Make sure length is equal to length of valid drive string "C:\"
    //
    INT iLen = lstrlen(szDrive);
    if (iLen != 3)
        return FALSE;

    //  
    //Check drive letter
    //
    TCHAR ch = szDrive[0];
    if ((ch >= 'a') && (ch <= 'z'))   
        ;
    else if ((ch >= 'A') && (ch <= 'Z'))
        ;
    else
        return FALSE;

    //  
    //Check colon
    //
    ch = szDrive[1];
    if (ch != ':')
        return FALSE;

    //  
    //Check slash
    //
    ch = szDrive[2];
    if (ch != '\\')
        return FALSE;

    //  
    //Check zero terminating byte
    //
    ch = szDrive[3];
    if (ch != 0)
        return FALSE;

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** GetDriveFromString
**
** Purpose:    gets a drive letter from a drive string
** Mod Log:    Created by Jason Cobb (4/97)
**------------------------------------------------------------------------------
*/
BOOL 
GetDriveFromString(
    const TCHAR * szDrive, 
    drenum & dre
    )
{
    dre = Drive_INV;

    //
    //Make sure we have a valid string
    //
    if ((szDrive == NULL) || (szDrive[0] == 0))
        return FALSE;

    //  
    //Get drive number from drive letter
    //
    TCHAR chDrive = szDrive[0];
    if ((chDrive >= TCHAR('a')) && (chDrive <= TCHAR('z')))
        dre = (drenum)(chDrive - TCHAR('a'));
    else if ((chDrive >= TCHAR('A')) && (chDrive <= TCHAR('Z')))
        dre = (drenum)(chDrive - TCHAR('A'));
    else
        return FALSE;

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** GetDriveIcon
**
** Purpose:    
** Parameters:
**    dre - driver letter
**    bSmallIcon - TRUE if small icon is desired.
** Return:     Drive Icon returned by the shell
** Notes:   
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
HICON
GetDriveIcon(
    drenum dre,
    BOOL bSmallIcon
    )
{
    TCHAR        szDrive[10];
    SHFILEINFO    fi;

    CreateStringFromDrive(dre, szDrive, sizeof(szDrive));

    if (bSmallIcon)
        SHGetFileInfo(szDrive, 0, &fi, sizeof(fi), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_SMALLICON);
    else
        SHGetFileInfo(szDrive, 0, &fi, sizeof(fi), SHGFI_ICON | SHGFI_DISPLAYNAME | SHGFI_LARGEICON);

    return fi.hIcon;
}

BOOL
GetDriveDescription(
    drenum dre, 
    TCHAR *psz,
    size_t cchDest
    )
{
    TCHAR *desc;
    TCHAR szVolumeName[MAX_PATH];
    TCHAR szDrive[MAX_PATH];
    BOOL bRet = TRUE;

    *szVolumeName = 0;
    CreateStringFromDrive(dre, szDrive, sizeof(szDrive));
    GetVolumeInformation(szDrive, szVolumeName, ARRAYSIZE(szVolumeName), NULL, NULL, NULL, NULL, 0);

    desc = SHFormatMessage( MSG_VOL_NAME_DRIVE_LETTER, szVolumeName, (TCHAR)(dre + 'A'));
    
    if (!SUCCEEDED(StringCchCopy(psz, cchDest, desc)))
    {
        bRet = FALSE;
    }
    
    LocalFree (desc);

    return bRet;
}


/*
**------------------------------------------------------------------------------
** GetHardwareType
**
** Purpose:    
** Parameters:
**    hwHardware  - hardware type of drive
** Return:     TRUE if compatible with our needs
**             FALSE otherwise
** Notes:   
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
GetHardwareType(
    drenum dre, 
    hardware &hwType
    )
{
    TCHAR szDrive[4];

    hwType = hwINVALID;


    //  
    //Get drive string from drive number
    //
    if (!CreateStringFromDrive(dre, szDrive, 4))
        return FALSE;

    UINT uiType = GetDriveType(szDrive);
    switch (uiType)
    {
        case 0:
            hwType = hwUnknown;
            return FALSE;

        case 1:
            hwType = hwINVALID;
            return FALSE;

        case DRIVE_REMOVABLE:
            hwType = hwRemoveable;
            break;

        case DRIVE_FIXED:
            hwType = hwFixed;
            break;

        case DRIVE_REMOTE:
            hwType = hwNetwork;
            return FALSE;

        case DRIVE_CDROM:
            hwType = hwCDROM;
            return FALSE;

        case DRIVE_RAMDISK:
            hwType = hwRamDrive;
            break;

        default:
            hwType = hwUnknown;
            return FALSE;
    }

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** CreateStringFromDrive
**
** Purpose:    creates a drive string from a drive number
** Mod Log:    Created by Jason Cobb (4/97)
**------------------------------------------------------------------------------
*/
BOOL 
CreateStringFromDrive(
    drenum dre, 
    TCHAR * szDrive, 
    ULONG cLen
    )
{
    if ((szDrive == NULL) || (cLen < 4))
        return FALSE;

    if (dre == Drive_INV)
        return FALSE;

    TCHAR ch = (CHAR)(dre + 'A');

    //
    //Drive string = Drive letter, colon, slash = "C:\"
    //
    szDrive[0] = ch;
    szDrive[1] = ':';
    szDrive[2] = '\\';
    szDrive[3] = 0;

    return TRUE;
}

ULARGE_INTEGER
GetFreeSpaceRatio(
    WORD dwDrive,
    ULARGE_INTEGER cbTotal
    )
{
    // for now, hardcode it as a percentage...
    ULARGE_INTEGER cbMin;
    // for now use 1% as the test to go into aggressive mode...
    cbMin.QuadPart = cbTotal.QuadPart / 100;
    return cbMin;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\dmgrdlg.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrdlg.cpp
**
** Purpose: Implements the Disk Space Cleanup Drive dialog
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "dmgrdlg.h"
#include "dmgrinfo.h"
#include "diskutil.h"
#include "msprintf.h"

#include <help.h>


// To work around a "feature" of listview we need the ability to temporarily ignore certain LVN_ITEMCHANGED messages:
BOOL    g_bIgnoreCheckStateChanges = TRUE;

/*
**------------------------------------------------------------------------------
** Local defines
**------------------------------------------------------------------------------
*/
#define crSliceUsed     RGB( 0, 0, 255 )
#define crSliceFree     RGB( 255, 0, 255)
#define crSliceCleanup  RGB( 255, 255, 0 )

const DWORD aHelpIDs[]=
{
    IDC_INTRO_TEXT,                 IDH_CLEANMGR_INTRO_TEXT,
    IDC_FILES_TO_REMOVE_TEXT,       IDH_CLEANMGR_CLIENT_LIST,
    IDC_CLIENT_LIST,                IDH_CLEANMGR_CLIENT_LIST,
    IDC_TOTAL_SPACE_DESCRIPTION,    IDH_CLEANMGR_TOTAL_SPACE,
    IDC_TOTAL_SPACE_TEXT,           IDH_CLEANMGR_TOTAL_SPACE,
    IDC_DESCRIPTION_GROUP,          IDH_CLEANMGR_DESCRIPTION_GROUP,
    IDC_DESCRIPTION_TEXT,           IDH_CLEANMGR_DESCRIPTION_GROUP,
    IDC_DETAILS_BUTTON,             IDH_CLEANMGR_DETAILS_BUTTON,
    IDC_WINDOWS_SETUP_ICON,         IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_GROUP,        IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_TEXT,         IDH_CLEANMGR_SETUP_GROUP,
    IDC_WINDOWS_SETUP_BUTTON,       IDH_CLEANMGR_SETUP_BUTTON,
    IDC_INSTALLED_PROGRAMS_ICON,    IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_GROUP,   IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_TEXT,    IDH_CLEANMGR_PROGRAMS_GROUP,
    IDC_INSTALLED_PROGRAMS_BUTTON,  IDH_CLEANMGR_PROGRAMS_BUTTON,
    IDC_SYSTEM_RESTORE_ICON,        IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_GROUP,       IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_TEXT,        IDH_CLEANMGR_SYSTEM_RESTORE_GROUP,
    IDC_SYSTEM_RESTORE_BUTTON,      IDH_CLEANMGR_SYSTEM_RESTORE_BUTTON,
    IDC_AUTO_LAUNCH,                IDH_CLEANMGR_AUTO_LAUNCH,
    IDC_DRIVE_ICON_LOCATION,        ((DWORD)-1),
    IDC_SETTINGS_DRIVE_TEXT,        ((DWORD)-1),
    0, 0
};


/*
**------------------------------------------------------------------------------
** Local function prototypes
**------------------------------------------------------------------------------
*/
BOOL CleanupMgrDlgInit     (HWND hDlg, LPARAM lParam);
void CleanupMgrDlgCleanup  (HWND hDlg);
BOOL CleanupMgrDlgCommand  (HWND hDlg, WPARAM wParam, LPARAM lParam);
BOOL CleanupMgrDlgNotify   (HWND hDlg, UINT uiMessage, WPARAM wParam, LPARAM lParam);

BOOL CleanupMgrDlgInitText (HWND hDlg);
BOOL CleanupMgrDlgInitList (HWND hDlg);
VOID UpdateTotalSpaceToBeFreed(HWND hDlg);

INT_PTR CALLBACK MoreOptionsDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);


LPARAM ListView_GetItemData(HWND hwndList, int i)
{
    LVITEM lvi = {0};
    lvi.iItem = i;
    lvi.mask = LVIF_PARAM;
    if ( ListView_GetItem(hwndList, &lvi) )
    {
        return lvi.lParam;
    }
    return NULL;
}

/*
**------------------------------------------------------------------------------
** DisplayCleanMgrProperties
**
** Purpose:    Creates the Cleanup Manager property sheet
** Parameters:
**    hDlg     - Handle to dialog window
**    lParam   - DWORD to pass onto the property pages
** Return:     1 if user pressed "OK"
**             0 if user pressed "Cancel"
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
DWORD 
DisplayCleanMgrProperties(
    HWND    hWnd,
    LPARAM  lParam
    )
{
    DWORD           dwRet;
    TCHAR           *psz;
    PROPSHEETPAGE   psp;
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE  hpsp[2];
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)lParam;
    if (pcmi == NULL)
    {
        //
        //Error - passed in invalid CleanupMgrInfo info
        //
        return 0;
    }

    memset(&psh, 0, sizeof(PROPSHEETHEADER));

    psp.dwSize = sizeof(PROPSHEETPAGE);
    psp.dwFlags = PSP_DEFAULT | PSP_USETITLE;
    psp.hInstance = g_hInstance;
    psp.lParam = lParam;

    psp.pszTitle = MAKEINTRESOURCE(IDS_DISKCLEANUP);
    psp.pszTemplate = MAKEINTRESOURCE(IDD_DISK_CLEANER);
    psp.pfnDlgProc = DiskCleanupManagerProc;
    hpsp[0] = CreatePropertySheetPage(&psp);

    if (!(pcmi->dwUIFlags & FLAG_SAGESET))
    {
        // Only display the second tab if the user is an admin
        if (IsUserAnAdmin())
        {
            psp.pszTitle = MAKEINTRESOURCE(IDS_MOREOPTIONS);
            psp.pszTemplate = MAKEINTRESOURCE(IDD_MORE_OPTIONS);
            psp.pfnDlgProc = MoreOptionsDlgProc;
            hpsp[1] = CreatePropertySheetPage(&psp);

    // commented out until after BEta 2
    //      psp.pszTitle = MAKEINTRESOURCE(IDS_SETTINGS);
    //      psp.pszTemplate = MAKEINTRESOURCE(IDD_SETTINGS);
    //      psp.pfnDlgProc = SettingsDlgProc;
    //      hpsp[2] = CreatePropertySheetPage(&psp);

    //      psh.nPages = 3;
            psh.nPages = 2;
        }
        else
        {
            // User is not an admin so only display the first tab
            psh.nPages = 1;
        }

        //
        //Create the dialog title
        //
        psz = SHFormatMessage( MSG_APP_TITLE, pcmi->szVolName, pcmi->szRoot[0]); 
    }

    else
    {
        psh.nPages = 1;

        //
        //Create the dialog title
        //
        psz = SHFormatMessage( MSG_APP_SETTINGS_TITLE );
    }

    psh.dwSize = sizeof(PROPSHEETHEADER);
    psh.dwFlags = PSH_NOAPPLYNOW | PSH_USEICONID;
    psh.hInstance = g_hInstance;
    psh.hwndParent = hWnd;
    psh.pszIcon = MAKEINTRESOURCE(ICON_CLEANMGR);
    psh.phpage = hpsp;
    psh.pszCaption = psz;

    dwRet = (DWORD)PropertySheet(&psh);

    LocalFree(psz);
    return dwRet;
}

/*
**------------------------------------------------------------------------------
** DiskCleanupManagerProc
**
** Purpose:    Dialog routine for Disk Cleanup Manager Property Sheet
** Parameters:
**    hDlg     - Handle to dialog window
**    uMessage - behavior type
**    wParam   - depends on message
**    lParam   - depends on message
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
INT_PTR CALLBACK
DiskCleanupManagerProc(
    HWND   hDlg, 
    UINT   uiMessage, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    switch (uiMessage)
    {
        case WM_INITDIALOG:
            return CleanupMgrDlgInit(hDlg, lParam);

        case WM_DESTROY:
            CleanupMgrDlgCleanup(hDlg);
            break;

        case WM_COMMAND:
            return CleanupMgrDlgCommand(hDlg, wParam, lParam);

        case WM_NOTIFY:
            return CleanupMgrDlgNotify(hDlg, uiMessage, wParam, lParam);

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        case WM_SYSCOLORCHANGE:
            SendMessage( GetDlgItem(hDlg, IDC_CLIENT_LIST), uiMessage, wParam, lParam);
            break;
    }

    //Non-handled message
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInit
**
** Purpose:    Handles dialog initialization
** Parameters:
**    hDlg     - Handle to dialog window
**    lParam   - Property Sheet pointer
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgInit(
    HWND hDlg, 
    LPARAM lParam
    )
{
    LPPROPSHEETPAGE     lppsp;
    
    g_hDlg = hDlg;

    //
    //Make sure we have an invalid pointer to start out with
    //
    SetWindowLongPtr (hDlg, DWLP_USER, 0L);

    //   
    //Get the CleanupMgrInfo
    //
    lppsp = (LPPROPSHEETPAGE)lParam;
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)lppsp->lParam;
    if (pcmi == NULL)
    {
        //Error - passed in invalid CleanupMgrInfo info
        return FALSE;
    }

    // now as we are becoming visible, we can dismiss the progress dialog
    if ( pcmi->hAbortScanWnd )
    {
        pcmi->bAbortScan = TRUE;

        //
        //Wait for scan thread to finish
        //  
        WaitForSingleObject(pcmi->hAbortScanThread, INFINITE);

        pcmi->bAbortScan = FALSE;
    }

    //
    //Save pointer to CleanupMgrInfo object
    //
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmi);

    //
    //Initialize all text
    //
    if (!CleanupMgrDlgInitText(hDlg))
        goto HAS_ERROR;

    //
    //Initialize the icon
    //
    SendDlgItemMessage(hDlg,IDC_DRIVE_ICON_LOCATION,STM_SETICON,(WPARAM)pcmi->hDriveIcon,0);

    //
    //If we are in SAGE settings mode then hide the total amount of space text
    //
    if (pcmi->dwUIFlags & FLAG_SAGESET)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_TOTAL_SPACE_DESCRIPTION), SW_HIDE);
        ShowWindow(GetDlgItem(hDlg, IDC_TOTAL_SPACE_TEXT), SW_HIDE);
    }

    //
    //Initialize the list box (all of the cleanup clients)
    //
    if (!CleanupMgrDlgInitList(hDlg))
        goto HAS_ERROR;    

    return TRUE;

HAS_ERROR:
    //  
    //Delete any memory structures still hanging around
    //
    CleanupMgrDlgCleanup (hDlg);
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgCleanup
**
** Purpose:    
** Parameters:
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrDlgCleanup(
    HWND hDlg
    )
{
    //
    //Make sure we have a valid parameter
    //
    if (!hDlg)
        return;

    //
    //Hide the window right away since we might block waiting for a 
    //COM client to finish.
    //
    ShowWindow(hDlg, SW_HIDE);

    g_hDlg = NULL;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrWarningPrompt
**
** Purpose:    Asks the user if they are sure they want to delete the files
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE if user says YES
**             FALSE if user says NO
** Notes;
** Mod Log:    Created by Jason Cobb (6/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrWarningPrompt(
    HWND hDlg
    )
{
    TCHAR   szWarning[256];
    TCHAR   *pszWarningTitle;
    int     i;
    BOOL    bItemSelected = FALSE;

    //
    //First verify that at least one item is selected.  If no items are selected then
    //nothing will be deleted so we don't need to bother prompting the user.
    //
    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return TRUE;

    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if (pcmi->pClientInfo[i].bSelected == TRUE)
        {
            bItemSelected = TRUE;
            break;
        }
    }        

    if (bItemSelected)
    {
        LoadString(g_hInstance, IDS_DELETEWARNING, szWarning, ARRAYSIZE(szWarning));
        pszWarningTitle = SHFormatMessage( MSG_APP_TITLE, pcmi->szVolName, pcmi->szRoot[0]);

        if (MessageBox(hDlg, szWarning, pszWarningTitle, MB_YESNO | MB_ICONQUESTION) == IDYES)
        {
            LocalFree(pszWarningTitle);
            return TRUE;
        }
        else
        {
            LocalFree(pszWarningTitle);
            return FALSE;
        }
    }

    //
    //No items are selected so just return TRUE since nothing will be deleted.
    //
    return TRUE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgCommand
**
** Purpose:    Handles command messages
** Parameters:
**    hDlg     - Handle to dialog window
**    wParam   - depends on command
**    lParam   - depends on command
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL CleanupMgrDlgCommand(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    WORD wID = LOWORD(wParam);

    if ( IDC_DETAILS_BUTTON == wID )
    {
        HWND    hWndList = GetDlgItem(hDlg, IDC_CLIENT_LIST);
        int     wIndex;

        wIndex = ListView_GetNextItem(hWndList, -1, LVNI_SELECTED);
        if (-1 != wIndex)
        {
            PCLIENTINFO pClientInfo = (PCLIENTINFO)ListView_GetItemData(hWndList,wIndex);
            if ( pClientInfo )
            {
                pClientInfo->pVolumeCache->ShowProperties(hDlg);
            }
        }
    }
    return 0;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrDlgNotify
**
** Purpose:    Handles notify messages
** Parameters:
**    hDlg     - Handle to dialog window
**    wParam   - depends on command
**    lParam   - depends on command
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgNotify(
    HWND hDlg, 
    UINT uiMessage,
    WPARAM wParam, 
    LPARAM lParam
    )
{
    CleanupMgrInfo  *pcmi;
    LPNMHDR pnmhdr = (LPNMHDR)lParam;

    if (IDC_CLIENT_LIST == pnmhdr->idFrom)
    {
        // a list view notification
        #define pnmlv ((LPNMLISTVIEW)pnmhdr)

        switch (pnmhdr->code)
        {
            case LVN_ITEMCHANGED:
                if ( pnmlv->uChanged & LVIF_STATE )
                {
                    LVITEM lvi;
                    lvi.iItem = pnmlv->iItem;
                    lvi.iSubItem = pnmlv->iSubItem;
                    lvi.mask = LVIF_PARAM;
                    ListView_GetItem( pnmhdr->hwndFrom, &lvi );
                    PCLIENTINFO pClientInfo = (PCLIENTINFO)lvi.lParam;

                    // check if an item was selected
                    if ( pnmlv->uNewState & LVIS_SELECTED )
                    {
                        if (pClientInfo->wcsDescription)
                        {
                            TCHAR szDescription[DESCRIPTION_LENGTH];
                            SHUnicodeToTChar(pClientInfo->wcsDescription, szDescription, ARRAYSIZE( szDescription ));
                            SetDlgItemText(hDlg, IDC_DESCRIPTION_TEXT, szDescription);
                        }
                        else
                        {
                            SetDlgItemText(hDlg, IDC_DESCRIPTION_TEXT, TEXT(""));
                        }

                        //
                        //Show or Hide the Settings button
                        //
                        if (pClientInfo->dwInitializeFlags & EVCF_HASSETTINGS)
                        {
                            TCHAR szButton[BUTTONTEXT_LENGTH];
                            SHUnicodeToTChar(pClientInfo->wcsAdvancedButtonText, szButton, ARRAYSIZE( szButton ));
                            SetDlgItemText(hDlg, IDC_DETAILS_BUTTON, szButton);
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_BUTTON), SW_SHOW);
                        }
                        else
                        {
                            ShowWindow(GetDlgItem(hDlg, IDC_DETAILS_BUTTON), SW_HIDE);
                        }
                    }

                    // Check if the state image changed.  This results from checking or unchecking
                    // one of the list view checkboxes.
                    if ((pnmlv->uNewState ^ pnmlv->uOldState) & LVIS_STATEIMAGEMASK)
                    {
                        if ( !g_bIgnoreCheckStateChanges )
                        {
                            pClientInfo->bSelected = ListView_GetCheckState( pnmhdr->hwndFrom, pnmlv->iItem );
                            UpdateTotalSpaceToBeFreed(hDlg);
                        }
                    }
                }
                break;
        }
    }
    else
    {
        // must be a property sheet notification
        switch(pnmhdr->code)
        {
            case PSN_RESET:
                pcmi = GetCleanupMgrInfoPointer(hDlg);
                pcmi->bPurgeFiles = FALSE;
                break;

            case PSN_APPLY:
                pcmi = GetCleanupMgrInfoPointer(hDlg);
                if (!(pcmi->dwUIFlags & FLAG_SAGESET))
                {
                    // We're not in SAGESET mode
                    // Ask the user if they would like to proceed if there are items selected
                    if (!CleanupMgrWarningPrompt(hDlg))
                    {
                        // The user clicked no so drop them back to the main window
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        pcmi->bPurgeFiles = FALSE;
                        return TRUE;
                    }
					
                    // User clicked yes so continue as normal
                    pcmi->bPurgeFiles = TRUE;
                }
                else
                {   
                    pcmi->bPurgeFiles = TRUE;
                }
                break;
        }
    }

    return FALSE;
}


/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInitText
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrDlgInitText(
    HWND hDlg
    )
{
    if (hDlg == NULL)
        return FALSE;

    //
    // Step 1. Get pointers to Info structures
    //

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return FALSE;
    if (pcmi->dre == Drive_INV)
        return FALSE;

    // 
    // Step 2. Extract useful info
    //

    //
    //get vol name   
    //
    TCHAR * pszVolName = pcmi->szVolName;
    if (pszVolName == NULL)
        pszVolName = TEXT("");

    //  
    //get drive letter
    //
    TCHAR chDrive = pcmi->dre + 'A';

    //
    // Step 3. Initialize text
    //
      
    //
    //Set header
    //
    if (pcmi->dwUIFlags & FLAG_SAGESET)
    {
        TCHAR * psz;
        psz = SHFormatMessage( MSG_INTRO_SETTINGS_TEXT );
        SetDlgItemText (hDlg, IDC_INTRO_TEXT, psz);
        LocalFree(psz);
    }
    else
    {
        TCHAR * psz;
        TCHAR * pszDrive;
        TCHAR szBuffer[50];
        
        pszDrive = SHFormatMessage( MSG_VOL_NAME_DRIVE_LETTER, pszVolName, chDrive);

        StrFormatKBSize(pcmi->cbEstCleanupSpace.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
        psz = SHFormatMessage( MSG_INTRO_TEXT, pszDrive, szBuffer);
        SetDlgItemText (hDlg, IDC_INTRO_TEXT, psz);
        LocalFree(pszDrive);
        LocalFree(psz);
    }

    return TRUE;
}

/*
**------------------------------------------------------------------------------
** UpdateTotalSpaceToBeFreed
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     NONE
** Notes;
** Mod Log:    Created by Jason Cobb (7/97)
**------------------------------------------------------------------------------
*/
VOID UpdateTotalSpaceToBeFreed(HWND hDlg)
{
    int             i;
    ULARGE_INTEGER  TotalSpaceToFree;

    TotalSpaceToFree.QuadPart = 0;
    
    if (hDlg == NULL)
        return;

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return;
    if (pcmi->dre == Drive_INV)
        return;

    //
    //Calculate the total space to be freed by adding up the dwUsedSpace value
    //on all of the selected clients
    //
    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if (pcmi->pClientInfo[i].bSelected)
        {
            TotalSpaceToFree.QuadPart += pcmi->pClientInfo[i].dwUsedSpace.QuadPart;
        }
    }        

    //
    //Display the total space to be freed
    //
    TCHAR szBuffer[10];
    StrFormatKBSize(TotalSpaceToFree.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
    SetDlgItemText(hDlg, IDC_TOTAL_SPACE_TEXT, szBuffer);
}


/*
**------------------------------------------------------------------------------
** CleanupMgrDlgInitList
**
** Purpose:    
** Parameters:
**    hDlg     - Handle to dialog window
** Return:     TRUE on sucess
**             FALSE on failure
** Notes;
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/

#define NAME_COL_PERCENT    80
#define SIZE_COL_PERCENT    20

BOOL CleanupMgrDlgInitList(HWND hDlg)
{
    int i;
    
    if (hDlg == NULL)
        return FALSE;

    CleanupMgrInfo * pcmi = GetCleanupMgrInfoPointer(hDlg);
    if (pcmi == NULL)
        return FALSE;

    if (pcmi->dre == Drive_INV)
        return FALSE;
        
    HWND hwndList = GetDlgItem(hDlg, IDC_CLIENT_LIST);
    RECT rc;
    GetClientRect(hwndList, &rc);
    int cxList = rc.right - GetSystemMetrics(SM_CXVSCROLL);

    // I have no idea what all this TUNEUP and SAGESET stuff means, but the old code
    // only drew the sizes if the following condition was true.  As such, I'm only
    // showing the size column if the same condition is true:
    BOOL bShowTwoCols = (!(pcmi->dwUIFlags & FLAG_TUNEUP) && !(pcmi->dwUIFlags & FLAG_SAGESET));

    LVCOLUMN lvc;
    lvc.mask = LVCF_SUBITEM | LVCF_WIDTH;
    lvc.iSubItem = 0;
    lvc.cx = bShowTwoCols ? MulDiv(cxList, NAME_COL_PERCENT, 100) : cxList;
    ListView_InsertColumn( hwndList, 0, &lvc );

    if ( bShowTwoCols )
    {
        lvc.mask = LVCF_SUBITEM | LVCF_WIDTH | LVCF_FMT;
        lvc.iSubItem = 1;
        lvc.cx = MulDiv(cxList, SIZE_COL_PERCENT, 100);
        lvc.fmt = LVCFMT_RIGHT;
        ListView_InsertColumn( hwndList, 1, &lvc );
    }

    HIMAGELIST himg = ImageList_Create(16, 16, ILC_COLOR|ILC_MASK, 4, 4);
    ListView_SetImageList(hwndList, himg, LVSIL_SMALL );
    ListView_SetExtendedListViewStyleEx(hwndList, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT, LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);

    // When we add an item to the listview the listview code always initializes the item to the unchecked
    // state.  It then fires a WM_NOTIFY telling us the state changed to "off" which causes us to nuke our
    // bSelected value.  As such we need to ignore state image changes during the addition of list view
    // items so that we can preserve our bSelected state.
    g_bIgnoreCheckStateChanges = TRUE;

    for (i=0; i<pcmi->iNumVolumeCacheClients; i++)
    {
        if ((pcmi->pClientInfo[i].pVolumeCache != NULL) &&
            (pcmi->pClientInfo[i].wcsDisplayName != NULL) &&
            (pcmi->pClientInfo[i].bShow == TRUE))
        {
            LPTSTR      lpszDisplayName;
            ULONG cb;

            cb = WideCharToMultiByte(CP_ACP, 0, pcmi->pClientInfo[i].wcsDisplayName, -1, NULL, 0, NULL, NULL);
            if ((lpszDisplayName = (LPTSTR)LocalAlloc(LPTR, (cb + 1) * sizeof( TCHAR ))) != NULL)
            {
#ifdef UNICODE
                StringCchCopy(lpszDisplayName, cb, pcmi->pClientInfo[i].wcsDisplayName);
#else
                //
                //Convert UNICODE display name to ANSI and then add it to the list
                //
                WideCharToMultiByte(CP_ACP, 0, pcmi->pClientInfo[i].wcsDisplayName, -1, lpszDisplayName, cb, NULL, NULL);
#endif

                //
                //Determine where in the list this item should go.
                //
                int iSortedPossition;
                int totalSoFar = ListView_GetItemCount(hwndList);

                for (iSortedPossition=0; iSortedPossition<totalSoFar; iSortedPossition++)
                {
                    PCLIENTINFO pClientInfo = (PCLIENTINFO)ListView_GetItemData(hwndList, iSortedPossition);
                    if (!pClientInfo || (pcmi->pClientInfo[i].dwPriority < pClientInfo->dwPriority))
                        break;
                }

                //
                //Insert this item at index j in the list
                //
                LVITEM lvi = {0};
                lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE;
                lvi.iItem = iSortedPossition;
                lvi.iSubItem = 0;
                lvi.pszText = lpszDisplayName;
                lvi.lParam = (LPARAM)&(pcmi->pClientInfo[i]);
                lvi.iImage = ImageList_AddIcon(himg, pcmi->pClientInfo[i].hIcon);
                
                iSortedPossition = ListView_InsertItem(hwndList, &lvi);

                if (bShowTwoCols)
                {
                    TCHAR szBuffer[10];

                    StrFormatKBSize(pcmi->pClientInfo[i].dwUsedSpace.QuadPart, szBuffer, ARRAYSIZE( szBuffer ));
                    ListView_SetItemText( hwndList, iSortedPossition, 1, szBuffer );
                }

                // Set the initial check state.  We can't do this when we add the item because the
                // list view code specifically ingores your State Image Flags if you have the
                // LVS_EX_CHECKBOX style set, which we do.
                ListView_SetCheckState( hwndList, iSortedPossition, pcmi->pClientInfo[i].bSelected );

                LocalFree( lpszDisplayName );
            }
        }
    }        

    g_bIgnoreCheckStateChanges = FALSE;

    UpdateTotalSpaceToBeFreed(hDlg);
    ListView_SetItemState(hwndList, 0, LVIS_SELECTED, LVIS_SELECTED);

    return TRUE;
}


typedef DWORD (WINAPI * PFNSRFIFO)(LPCWSTR pwszDrive, DWORD dwTargetRp, INT nPercent,
                                   BOOL fIncludeCurrentRp);


INT_PTR CALLBACK
MoreOptionsDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo      *pcmi;

    switch(Message)
    {
        case WM_INITDIALOG:
        {
            LPPROPSHEETPAGE lppsp;
            HMODULE hSRClient;

            lppsp = (LPPROPSHEETPAGE)lParam;
            pcmi = (CleanupMgrInfo *)lppsp->lParam;
            if (pcmi == NULL)
            {
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }
            SetWindowLongPtr (hDlg, DWLP_USER, (LONG_PTR) pcmi);

            hSRClient = LoadLibraryEx(TEXT("srclient.dll"), NULL, DONT_RESOLVE_DLL_REFERENCES);
            if (hSRClient)
            {
                FreeLibrary (hSRClient);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_GROUP), FALSE);
                ShowWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_ICON), SW_HIDE);
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_TEXT), FALSE);
                EnableWindow(GetDlgItem(hDlg, IDC_SYSTEM_RESTORE_BUTTON), FALSE);
            }
        }
        break;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_WINDOWS_SETUP_BUTTON:
                    {
                        TCHAR szSysDir[MAX_PATH];
                        if ( GetSystemDirectory(szSysDir, ARRAYSIZE(szSysDir)) )
                        {
                            TCHAR szParam[MAX_PATH];
                            
                            StringCchPrintf(szParam, ARRAYSIZE(szParam), SZ_WINDOWS_SETUP, szSysDir);
                            
                            // Use full path
                            if (PathAppend(szSysDir, SZ_SYSOCMGR))
                            {
                                ShellExecute(NULL, NULL, szSysDir, szParam, NULL, SW_SHOWNORMAL);
                            }
                        }
                    }
                    break;

                case IDC_INSTALLED_PROGRAMS_BUTTON:
                {
                    TCHAR szPath[MAX_PATH];
                    
                    if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)))
                    {
                        // Use full path
                        if (PathAppend(szPath, SZ_RUNDLL32))
                        {
                            ShellExecute(NULL, NULL, szPath, SZ_INSTALLED_PROGRAMS, NULL, SW_SHOWNORMAL);
                        }
                    }
                }
                break;

                case IDC_SYSTEM_RESTORE_BUTTON:
                    pcmi = (CleanupMgrInfo *) GetWindowLongPtr (hDlg, DWLP_USER);

                    if (pcmi)
                    {
                        HMODULE hSRClient = NULL;
                        PFNSRFIFO pfnSRFifo;
                        TCHAR szCaption[100];
                        TCHAR szMessage[200];
                        INT iResult;

                        LoadString(g_hInstance, IDS_DISKCLEANUP, szCaption, ARRAYSIZE(szCaption));
                        LoadString(g_hInstance, IDS_SYSTEM_RESTORE_MESSAGE, szMessage, ARRAYSIZE(szMessage));
                        iResult = MessageBox(hDlg, szMessage, szCaption, MB_YESNO | MB_ICONQUESTION);


                        if (iResult == IDYES)
                        {
                            hSRClient = LoadLibrary(TEXT("srclient.dll"));
                            if (hSRClient)
                            {
                                pfnSRFifo = (PFNSRFIFO) GetProcAddress (hSRClient, "SRFifo");

                                if (pfnSRFifo)
                                {
                                    pfnSRFifo ((LPCWSTR)pcmi->szRoot, NULL, 0, FALSE);
                                }

                                FreeLibrary (hSRClient);
                            }
                        }
                    }
                    break;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        default:
            return FALSE;
    }

    return TRUE;
}

INT_PTR CALLBACK
SettingsDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LPPROPSHEETPAGE lppsp;
    CleanupMgrInfo *pcmi;
    DWORD dwType, cbBytes;
    DWORD dwLDSDisable;
    HKEY hk;
    
    switch(Message)
    {
        case WM_INITDIALOG:
        {
            TCHAR * psz;
            hardware hwType;

            lppsp = (LPPROPSHEETPAGE)lParam;
            pcmi = (CleanupMgrInfo *)lppsp->lParam;
            if (pcmi == NULL)
            {
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pcmi);

            TCHAR * pszVolName = pcmi->szVolName;
            if (pszVolName == NULL)
                pszVolName = TEXT("");

            TCHAR chDrive = pcmi->dre + TCHAR('A');

            psz = SHFormatMessage( MSG_INTRO_SETTINGS_TAB, pszVolName, chDrive );
            SetDlgItemText (hDlg, IDC_SETTINGS_DRIVE_TEXT, psz);
            LocalFree(psz);

            //
            //Initialize the icon
            //
            SendDlgItemMessage(hDlg,IDC_DRIVE_ICON_LOCATION,STM_SETICON,(WPARAM)pcmi->hDriveIcon,0);

            //
            //Initialize the auto launch check box
            //
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_FILESYSTEM, 0, KEY_READ, &hk) == ERROR_SUCCESS)
            {
                dwLDSDisable = 0;
                dwType = REG_DWORD;
                cbBytes = sizeof(dwLDSDisable);
                if (RegQueryValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, NULL, &dwType, (LPBYTE)&dwLDSDisable, &cbBytes) == ERROR_SUCCESS)
                {
                    if (dwLDSDisable & (0x01 << pcmi->dre))
                    {
                        CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 0);
                    }
                    else
                    {
                        CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 1);
                    }
                }

                RegCloseKey(hk);
            }

            //
            //Gray out the auto launch option if this is not a fixed disk
            //
            if (!GetHardwareType(pcmi->dre, hwType) ||
                (hwType != hwFixed))
            {
                CheckDlgButton(hDlg, IDC_AUTO_LAUNCH, 0);
                EnableWindow(GetDlgItem(hDlg, IDC_AUTO_LAUNCH), FALSE);
            }
        }
            break;

        case WM_NOTIFY:
            switch(((NMHDR *)lParam)->code)
            {
                case PSN_APPLY:
                    pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);

                    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_FILESYSTEM, 0, KEY_READ | KEY_WRITE, &hk) == ERROR_SUCCESS)
                    {
                        dwLDSDisable = 0;
                        dwType = REG_DWORD;
                        cbBytes = sizeof(dwLDSDisable);
                        if (RegQueryValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, NULL, &dwType, (LPBYTE)&dwLDSDisable, &cbBytes) == ERROR_SUCCESS)
                        {
                            if (IsDlgButtonChecked(hDlg, IDC_AUTO_LAUNCH))
                            {
                                dwLDSDisable &= ~(0x01 << pcmi->dre);
                            }
                            else
                            {
                                dwLDSDisable |= (0x01 << pcmi->dre);
                            }
                        
                            RegSetValueEx(hk, REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE, 0, REG_DWORD,
                                (LPBYTE)&dwLDSDisable, sizeof(dwLDSDisable));
                        }
                            
                        RegCloseKey(hk);
                    }
                    break;

                case PSN_RESET:
                    break;
            }
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR) aHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID) aHelpIDs);
            return TRUE;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\dmgrdlg.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    dmgrdlg.h
**
** Purpose: Implements Disk Space Cleanup Dialog Property Sheets
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DMGRDLG_H
#define DMGRDLG_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
   #include "common.h"
#endif


/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/
DWORD 
DisplayCleanMgrProperties(
	HWND	hWnd,
	LPARAM	lParam
	);

INT_PTR CALLBACK
DiskCleanupManagerProc(
    HWND hDlg, 
    UINT uMessage, 
    WPARAM wParam, 
    LPARAM lParam
    );

//void 
//CleanupMgrUpdateUI(
//    HWND hDlg
//    );

HWND
GetDiskCleanupManagerWindowHandle(
    void
    );

#endif // DMGRDLG_H
/*
**------------------------------------------------------------------------------
**  End of file
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\drivlist.h ===
#ifndef DRIVLIST_H
#define DRIVLIST_H

#ifndef DISKUTIL_H
	#include "diskutil.h"
#endif

/*
 * DEFINITIONS ________________________________________________________________
 *
 */

typedef enum	// Per-window extra bytes for DriveList
{
	DL_COMBOWND = 0,	// Far pointer to a ComboBox HWND.
	DL_COMBOPROC = 4,	// Far pointer to original comboproc
	DL_UPDATES = 8	// ==0 if paints are OK
} DriveWindLongs;


#define szDriveListCLASS  "DRIVELISTCLASS"

#define DLN_SELCHANGE   (WM_USER +110)	// Sends WP=drive letter chosen

#define DL_UPDATESBAD   (WM_USER +111)	// Don't refresh until later...
#define DL_UPDATESOKAY  (WM_USER +112)	// ...later's here.

#define STYLE_LISTBOX   0x000080000


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

BOOL   RegisterDriveList   (HANDLE hInst);
void   ExitDriveList       (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\ids.h ===
#define IDH_CLEANMGR_BASE                      12000
#define IDH_CLEANMGR_INTRO_TEXT                (IDH_CLEANMGR_BASE +0x0001)
#define IDH_CLEANMGR_CLIENT_LIST               (IDH_CLEANMGR_BASE +0x0002)
#define IDH_CLEANMGR_TOTAL_SPACE               (IDH_CLEANMGR_BASE +0x0003)
#define IDH_CLEANMGR_DESCRIPTION_GROUP         (IDH_CLEANMGR_BASE +0x0004)
#define IDH_CLEANMGR_DETAILS_BUTTON            (IDH_CLEANMGR_BASE +0x0005)
#define IDH_CLEANMGR_SETUP_GROUP               (IDH_CLEANMGR_BASE +0x0006)
#define IDH_CLEANMGR_SETUP_BUTTON              (IDH_CLEANMGR_BASE +0x0007)
#define IDH_CLEANMGR_PROGRAMS_GROUP            (IDH_CLEANMGR_BASE +0x0008)
#define IDH_CLEANMGR_PROGRAMS_BUTTON           (IDH_CLEANMGR_BASE +0x0009)
#define IDH_CLEANMGR_SYSTEM_RESTORE_GROUP      (IDH_CLEANMGR_BASE +0x000a)
#define IDH_CLEANMGR_SYSTEM_RESTORE_BUTTON     (IDH_CLEANMGR_BASE +0x000b)
#define IDH_CLEANMGR_AUTO_LAUNCH               (IDH_CLEANMGR_BASE +0x000c)
#define IDH_CLEANMGR_SELDRIVE                  (IDH_CLEANMGR_BASE +0x000d)
#define IDH_CLEANMGR_SELDRIVE_OK               (IDH_CLEANMGR_BASE +0x000e)
#define IDH_CLEANMGR_SELDRIVE_EXIT             (IDH_CLEANMGR_BASE +0x000f)

#define REGSTR_VAL_DRIVE_LDS_BDCAST_DISABLE     TEXT("DisableLowDiskSpaceBroadcast")
#define REGSTR_VAL_ADVANCEDBUTTONTEXT           TEXT("AdvancedButtonText")
#define REGSTR_PATH_SETUP_SETUP                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup")
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\midebug.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrinfo.c
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#include <stdio.h>
#include <string.h>

#ifdef DEBUG

// Patch this to TRUE to see spew
BOOL g_fSpew = FALSE;

void
DebugPrint(
    HRESULT hr,
    LPCSTR  lpFormat,
    ...
    )
{
    if (!g_fSpew) return;

    va_list marker;
    CHAR    MessageBuffer[512];
    void    *pMsgBuf = NULL;
    
    va_start(marker, lpFormat);
    StringCchVPrintfA(MessageBuffer, ARRAYSIZE(MessageBuffer), lpFormat, marker);
    va_end(marker);

    if (hr != 0)
    {                       
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&pMsgBuf,
            0, NULL);
                 
        StringCchPrintfA(MessageBuffer, ARRAYSIZE(MessageBuffer), "%s %X (%s)", MessageBuffer, hr, (LPTSTR)pMsgBuf);
    }
    
    OutputDebugStringA("CLEANMGR: ");
    OutputDebugStringA(MessageBuffer);
    OutputDebugStringA("\r\n");

#ifdef MESSAGEBOX                        
    MessageBoxA(NULL, MessageBuffer, "CLEANMGR DEBUG MESSAGE", MB_OK);
#endif
                        
    LocalFree(pMsgBuf);
}

#endif  //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\msprintf.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    msprintf.cpp
**
** Purpose: Print functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "msprintf.h"
#include "resource.h"
#include "diskutil.h"       // cb1MEG




/*
**------------------------------------------------------------------------------
** Function definitions
**------------------------------------------------------------------------------
*/

TCHAR * cdecl SHFormatMessage( DWORD dwMessageId, ...)
{
    va_list   arg;
    va_start (arg, dwMessageId);
    LPVOID pBuffer = NULL;

    // use format message to build the string...
    DWORD dwRes = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE,
                                NULL, dwMessageId, 0, (LPTSTR) & pBuffer, 0, &arg );
    return (TCHAR *) pBuffer;                  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\drivlist.cpp ===
#include "common.h"
#include "diskutil.h"
#include "msprintf.h"
#include "drivlist.h" 
#include "miniicon.h"

#define  cxBITMAP  18
#define  cyBITMAP  18
#define  cbRESOURCE 256


/*
 * VARIABLES __________________________________________________________________
 *
 */
FARPROC lpfnComboMain;


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

LONG APIENTRY 
DriveListProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    );

BOOL CALLBACK 
DriveComboProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    );

void 
GoSelectDrive(
    HWND hWnd, 
    drenum dre
    );
    
void 
DrawDriveItem(
    DRAWITEMSTRUCT *lpdi
    );

/*
 * ROUTINES ___________________________________________________________________
 *
 */

/*** RegisterDriveList - Registers the DriveList class (always do this!!!)
 *
 */
BOOL 
RegisterDriveList(
    HINSTANCE hInst
    )
{
    WNDCLASS wc;

    wc.style       = CS_NOCLOSE;
    wc.lpfnWndProc = DriveListProc;	// Standard callback function
    wc.cbClsExtra  = 0;	            // No per-class extra data
    wc.cbWndExtra  = 12;	        // We store proc addresses here
    wc.hInstance   = hInst;	        // Registering application

    wc.hIcon = NULL;
    wc.hCursor = LoadCursor (NULL, MAKEINTRESOURCE(IDC_ARROW));
    wc.hbrBackground = CreateSolidBrush(GetSysColor(COLOR_BTNFACE));

    wc.lpszMenuName  = NULL;	    // Name of menu resource in .RC file
    wc.lpszClassName = szDriveListCLASS;	// Name used in call to CreateWindow

    RegisterClass(&wc);

    return TRUE;
}

/*** ExitDriveList - Frees memory allocated for the DriveList class
 *
 */
void 
ExitDriveList(
    void
    )
{
}

/*** DriveListProc - Procedure for handing a DriveList
 *
 */
LONG APIENTRY 
DriveListProc(
    HWND hWnd, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    MEASUREITEMSTRUCT *lpmi;
    CREATESTRUCT      *lpcs;
    HWND              hCombo;
    PAINTSTRUCT       ps;
    long              l;
    RECT              r;

    switch (Message)
    {
        case  WM_CREATE:
            lpcs = (CREATESTRUCT *)lParam;

            if (lpcs->style & STYLE_LISTBOX)
            {
                MiDebugMsg((0, "CreateWindowEx(ListBox)"));
                hCombo = CreateWindowEx (
                                //EDGE_SUNKEN | WS_EX_EDGEMASK,
                                EDGE_SUNKEN,
                                "ListBox",
                                "",
                                LBS_OWNERDRAWFIXED | LBS_HASSTRINGS |
                                WS_VSCROLL |
                                WS_VISIBLE | WS_CHILD | CBS_SIMPLE,
                                0,
                                0,
                                lpcs->cx,
                                lpcs->cy *5,
                                hWnd,
                                NULL,
                                lpcs->hInstance,
                                NULL
                                );
            }
            else
            {
                MiDebugMsg((0, "CreateWindowEx(ComboBox)"));
                hCombo = CreateWindow (
                                "ComboBox",
                                "",
                                LBS_USETABSTOPS |
                                CBS_OWNERDRAWFIXED | CBS_HASSTRINGS |
                                CBS_DROPDOWNLIST | WS_VSCROLL |
                                WS_VISIBLE | WS_CHILD | CBS_SIMPLE,
                                0,
                                0,
                                lpcs->cx,
                                lpcs->cy *4,	// NUMBER LINES in DROP DOWN
                                hWnd,
                                NULL,
                                lpcs->hInstance,
                                NULL
                                );
            }

            SetWindowLong(hWnd, DL_COMBOWND, (long)hCombo);
            SetWindowLong(hWnd, DL_UPDATES, 0L);

            if (hCombo == NULL)
                return -1;

            //
            //Subclass the combobox
            //
            lpfnComboMain = (FARPROC)GetWindowLong(hCombo, GWL_WNDPROC);
            SetWindowLong(hCombo, GWL_WNDPROC, (LONG)DriveComboProc);

            //wproc = (WNDPROC)GetWindowLong (hCombo, GWL_WNDPROC);
            //SetWindowLong(hWnd, DL_COMBOPROC, (long)wproc);
            //wproc = (WNDPROC)DriveComboProc;
            //SetWindowLong(hCombo, GWL_WNDPROC, (long)wproc);

            return 0;
            break;

        case  WM_DESTROY:  
            hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND);

            if (hCombo != NULL)
            {
                SetWindowLong (hCombo, GWL_WNDPROC, (long)lpfnComboMain);

                DestroyWindow(hCombo);
                SetWindowLong(hWnd, DL_COMBOWND, 0L);
            }
            return 0;
            break;

        case WM_HELP:
            ((LPHELPINFO) lParam)->hItemHandle = hWnd;
            return DefWindowProc (hWnd, Message, wParam, lParam);

        case WM_CONTEXTMENU:
            return DefWindowProc (hWnd, Message, (WPARAM) hWnd, lParam);

        case  WM_PAINT:
            BeginPaint (hWnd, &ps);
            EndPaint (hWnd, &ps);
            break;

        case  WM_COMMAND:
            if ((HIWORD(lParam) == CBN_SELCHANGE) || 
                (HIWORD(lParam) == LBN_SELCHANGE))
            {
                wParam = GetWindowLong(hWnd, GWL_ID);
                SendMessage(GetParent(hWnd),Message,wParam,lParam);
            }
            break;

        case  WM_MEASUREITEM:
            lpmi = (MEASUREITEMSTRUCT *)lParam;
            lpmi->itemWidth = cxBITMAP;
            lpmi->itemHeight = cyBITMAP +2;
            break;

        case  WM_DRAWITEM:
            DrawDriveItem((DRAWITEMSTRUCT *)lParam);
            return 0;
            break;

        case  DL_UPDATESBAD:
            l = GetWindowLong(hWnd, DL_UPDATES);
            SetWindowLong(hWnd, DL_UPDATES, l+1);
            break;

        case  DL_UPDATESOKAY:
            l = GetWindowLong(hWnd, DL_UPDATES);
            SetWindowLong(hWnd, DL_UPDATES, l-1);

            if (l == 1)
            {
                GetClientRect(hWnd, &r);
                InvalidateRect(hWnd, &r, FALSE);
                UpdateWindow(hWnd);
            }
            break;
    }

    /*
    if ((hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND)) == NULL)
        return -1;

    if ((wproc = (WNDPROC)GetWindowLong(hCombo, GWL_WNDPROC)) == NULL)
        return -1;

    if (Message > WM_USER)
    {
        return CallWindowProc(wproc, hCombo, Message, wParam, lParam);
    }

    if (Message == WM_SETFONT || Message == WM_SETFOCUS || Message == WM_KILLFOCUS)
    {
        CallWindowProc(wproc, hCombo, Message, wParam, lParam);
    }
    if (Message == WM_GETDLGCODE)
        return (DLGC_WANTCHARS | DLGC_WANTARROWS);

    if (Message == WM_KEYDOWN)
    {
        if ((wParam == VK_UP) || (wParam == VK_DOWN) ||
            (wParam == VK_LEFT) || (wParam == VK_RIGHT) ||
            (wParam == VK_HOME) || (wParam == VK_END) ||
            (wParam == VK_F4))
        {
            CallWindowProc (wproc, hCombo, Message, wParam, lParam);
            Message = WM_CHAR;
        }
    }

    if (Message == WM_CHAR)
    {
        return CallWindowProc (wproc, hCombo, Message, wParam, lParam);
    }
    */

    return DefWindowProc (hWnd, Message, wParam, lParam);
}

/*** DriveComboProc - Procedure for handing a DriveList
 *
 */
BOOL CALLBACK 
DriveComboProc(
    HWND hCombo, 
    UINT Message, 
    WPARAM wParam, 
    LPARAM lParam
    )
{
    HWND      hWnd;

    if ((hWnd = GetParent(hCombo)) == NULL)
        return -1;

    if (Message == WM_GETDLGCODE)
        return (DLGC_WANTCHARS | DLGC_WANTARROWS);

    if (Message == WM_CHAR)
    {
        if (wParam >= 'A' && wParam <= 'Z')  GoSelectDrive(hWnd, (drenum)(wParam-'A'));
        if (wParam >= 'a' && wParam <= 'z')  GoSelectDrive(hWnd, (drenum)(wParam-'a'));
        return DefWindowProc (hWnd, Message, wParam, lParam);
    }

    return CallWindowProc((WNDPROC)lpfnComboMain, hCombo, Message, wParam, lParam);
}

/*** GoSelectDrive - Choose a new drive, based on a keypress
 *
 */
void 
GoSelectDrive(
    HWND hWnd, 
    drenum dre
    )
{
    HWND      hCombo;
    USHORT    nItems;
    USHORT    n;
    DWORD     data;
    WPARAM    wParam;
    LPARAM    lParam;
    BOOL      fList;

    if ((hCombo = (HWND)GetWindowLong(hWnd, DL_COMBOWND)) == NULL)
        return;

    fList = (GetWindowLong (hWnd, GWL_STYLE) & STYLE_LISTBOX) ? TRUE : FALSE;

    if (fList)
        nItems = (USHORT)CallWindowProc((WNDPROC)lpfnComboMain, hCombo, LB_GETCOUNT, 0, 0L);
    else
        nItems = (USHORT)CallWindowProc((WNDPROC)lpfnComboMain, hCombo, CB_GETCOUNT, 0, 0L);

    for (n = 0; n < nItems; n++)
    {
        if (fList)
            data = CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, LB_GETITEMDATA, (WPARAM)n, 0L);
        else
            data = CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, CB_GETITEMDATA, (WPARAM)n, 0L);

        if (LOBYTE(data) == dre)
        {
            if (fList)
                CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, LB_SETCURSEL, (WPARAM)n, 0L);
            else
                CallWindowProc ((WNDPROC)lpfnComboMain, hCombo, CB_SETCURSEL, (WPARAM)n, 0L);

            wParam = (WPARAM)GetWindowLong(hWnd, GWL_ID);
            lParam = (LPARAM)MAKELONG((WORD)hCombo, (WORD)CBN_SELCHANGE);
            SendMessage(GetParent(hWnd), WM_COMMAND, wParam, lParam);
            return;
        }
    }

    MessageBeep (MB_ICONEXCLAMATION);
}

void 
DrawDriveItem(
    DRAWITEMSTRUCT *lpdi
    )
{
    TCHAR    buf[cbRESOURCE] = "";
    HWND     hWnd;
    int      x, y;
    HICON    hi;
    COLORREF clrBk, clrFg;
    HBRUSH   hb;
    int      dre;
    long     l;

    if (lpdi->itemAction & ODA_FOCUS)
        return;

    dre = (int)LOBYTE(lpdi->itemData);
    MiDebugMsg((0, "DrawDriveItem for dre %d", dre));
    if ((dre != Drive_INV) && ((dre < (int)Drive_A) || (dre > (int)Drive_Z)))
        return;

    hWnd = GetParent (lpdi->hwndItem);

    if (GetWindowLong (hWnd, DL_UPDATES) != 0)
        return;

    l = GetWindowLong (hWnd, GWL_STYLE);
    if (l & STYLE_LISTBOX)
        SendMessage (hWnd, LB_GETTEXT,  (WPARAM)lpdi->itemID,(LPARAM)(LPTSTR)buf);
    else
        SendMessage (hWnd, CB_GETLBTEXT,(WPARAM)lpdi->itemID,(LPARAM)(LPTSTR)buf);

    x = lpdi->rcItem.left;
    y = lpdi->rcItem.top;

    hi = GetDriveIcon((drenum)dre);

    if (lpdi->itemState & ODS_SELECTED)
    {
        clrBk = SetBkColor   (lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
        clrFg = SetTextColor (lpdi->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
    }
    else
    {
        clrBk = SetBkColor   (lpdi->hDC, GetSysColor(COLOR_WINDOW));
        clrFg = SetTextColor (lpdi->hDC, GetSysColor(COLOR_WINDOWTEXT));
    }

    hb = CreateSolidBrush (GetBkColor(lpdi->hDC));
    FillRect (lpdi->hDC, &lpdi->rcItem, hb);
    DeleteObject (hb);

    TabbedTextOut (lpdi->hDC, x +((hi == NULL) ? 1 : 21), y+3,
                   buf, _fstrlen(buf), 0, NULL, 0);

    SetBkColor (lpdi->hDC, clrBk);
    SetTextColor (lpdi->hDC, clrFg);

    if (hi == NULL)
        return;

    DrawIconEx(lpdi->hDC, x+1, y+1, hi,
        MINIY, MINIX, 0, NULL, DI_NORMAL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\dmgrinfo.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    dmgrinfo.h
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DMGRINFO_H
#define DMGRINFO_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/

#ifndef COMMON_H
   #include "common.h"
#endif

#ifndef EMPTYVC_H
    #include <emptyvc.h>
#endif

#ifndef DISKUTIL_H
   #include "diskutil.h"
#endif

#ifndef CALLBACK_H
    #include "callback.h"
#endif



/*
**------------------------------------------------------------------------------
** Defines
**------------------------------------------------------------------------------
*/
#define	WMAPP_UPDATEPROGRESS	WM_USER+1
#define WMAPP_UPDATESTATUS		WM_USER+2

#define PROGRESS_DIVISOR		0xFFFF
/*
**------------------------------------------------------------------------------
** Global function prototypes
**------------------------------------------------------------------------------
*/
   // forward references to make compile work
class CleanupMgrInfo;

CleanupMgrInfo * GetCleanupMgrInfoPointer(HWND hDlg);


/*
**------------------------------------------------------------------------------
** Class declarations
**------------------------------------------------------------------------------
*/
typedef struct tag_ClientInfo
{
    HICON               hIcon;
    CLSID               clsid;
    LPEMPTYVOLUMECACHE  pVolumeCache;
    HKEY                hClientKey;
    TCHAR				szRegKeyName[MAX_PATH];
	LPWSTR				wcsDescription;
	LPWSTR				wcsDisplayName;
	LPWSTR				wcsAdvancedButtonText;
    DWORD               dwInitializeFlags;
    DWORD				dwPriority;
    ULARGE_INTEGER      dwUsedSpace;
    BOOL				bShow;
    BOOL                bSelected;
} CLIENTINFO, *PCLIENTINFO;

/*
**------------------------------------------------------------------------------
** Class:   CleanupMgrInfo
** Purpose: Stores useful info for the Disk space cleanup manager drive tab
** Notes:
** Mod Log: Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
class CleanupMgrInfo {
private:
protected:
    static      HINSTANCE   hInstance;
    
    void  init(void);
    void  destroy(void);
    BOOL  initializeClients(void);
    void  deactivateClients(void);
    void  deactivateSingleClient(PCLIENTINFO pSingleClientInfo);
    BOOL  getSpaceUsedByClients(void);
	void calculateSpaceToPurge(void);
    HICON GetClientIcon(LPTSTR, BOOL fIconPath);

public:
    drenum      dre;                        // Drive letter
	HICON		hDriveIcon;					// Drive Icon
    TCHAR       szRoot[MAX_PATH];           // Root
    TCHAR       szVolName[MAX_PATH];        // Volume name
    TCHAR		szFileSystem[MAX_PATH];		// File System name		
    hardware    hwHardware;                 // Hardware Type
    volumetype  vtVolume;                   // Volume Type

    ULARGE_INTEGER   cbDriveFree;           // Free space on drive
    ULARGE_INTEGER   cbDriveUsed;           // Used space on drive
    ULARGE_INTEGER   cbEstCleanupSpace;     // Estimated space that can be cleaned
	ULARGE_INTEGER	 cbLowSpaceThreshold;	// Low disk space threshold (for agressive mode)
	ULARGE_INTEGER	 cbSpaceToPurge;
	ULARGE_INTEGER	 cbProgressDivider;

	DWORD		dwReturnCode;
    DWORD		dwUIFlags;
    ULONG		ulSAGEProfile;				// SAGE Profile
    BOOL		bOutOfDiskSpace;			// Are we in agressive mode?
    BOOL		bPurgeFiles;				// Should we delete the files?

	HANDLE		hAbortScanThread;			// Abort Scan thread Handle
	HWND		hAbortScanWnd;
	HANDLE		hAbortScanEvent;
	DWORD		dwAbortScanThreadID;

	HANDLE		hAbortPurgeThread;
	HWND		hAbortPurgeWnd;
	HANDLE		hAbortPurgeEvent;
	DWORD		dwAbortPurgeThreadID;
	ULARGE_INTEGER	cbTotalPurgedSoFar;
	ULARGE_INTEGER	cbCurrentClientPurgedSoFar;

	static void Register(HINSTANCE hInstance);
	static void Unregister();

    //
    //Volume Cache client information
    //
    int         iNumVolumeCacheClients;
    PCLIENTINFO pClientInfo;

    //
    //IEmptyVolumeCacheCallBack interface
    //
    PCVOLUMECACHECALLBACK    volumeCacheCallBack;
    LPEMPTYVOLUMECACHECALLBACK  pIEmptyVolumeCacheCallBack;
    BOOL                    bAbortScan;    
    BOOL                    bAbortPurge;         
    
    //  
    //Constructors
    //
    CleanupMgrInfo    (void);
    CleanupMgrInfo    (LPTSTR lpDrive, DWORD dwFlags, ULONG ulProfile);
    ~CleanupMgrInfo   (void);

    //   
    //Creation methods
    //
    BOOL isValid   (void)   { return dre != Drive_INV; }
    BOOL create    (LPTSTR lpDrive, DWORD Flags);
	BOOL isAbortScan (void)	{ return bAbortScan; }

	BOOL  purgeClients(void);

}; // CleanupMgrInfo


#endif DMGRINFO_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\dmgrinfo.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    dmgrinfo.c
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include <limits.h>
#include <emptyvc.h>
#include "dmgrinfo.h"
#include "dmgrdlg.h"
#include "diskutil.h"
#include "resource.h"
#include "msprintf.h"


/*
**------------------------------------------------------------------------------
**  Local variables
**------------------------------------------------------------------------------
*/
HINSTANCE   CleanupMgrInfo::hInstance             = NULL;


/*
**------------------------------------------------------------------------------
** Function prototypes
**------------------------------------------------------------------------------
*/
INT_PTR CALLBACK
ScanAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void
ScanAbortThread(
    CleanupMgrInfo *pcmi
    );

INT_PTR CALLBACK
PurgeAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

void
PurgeAbortThread(
    CleanupMgrInfo *pcmi
    );

/*
**------------------------------------------------------------------------------
** Function definitions
**------------------------------------------------------------------------------
*/


void
CleanupMgrInfo::Register(
    HINSTANCE hInstance
    )
{
    CleanupMgrInfo::hInstance = hInstance;
}

void
CleanupMgrInfo::Unregister(
    void
    )
{
    CleanupMgrInfo::hInstance= NULL;
}

/*
**------------------------------------------------------------------------------
** GetCleanupMgrInfoPointer
**
** Purpose:    
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo * GetCleanupMgrInfoPointer(
    HWND hDlg
    )
{
    //   
    //Get the DriveInfo
    //
    CleanupMgrInfo * pcmi = (CleanupMgrInfo *)GetWindowLongPtr(hDlg, DWLP_USER);

    return pcmi;
}



/*
**------------------------------------------------------------------------------
** CleanupMgrInfo method definitions
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** CleanupMgrInit::init
**
** Purpose:    sets to default values
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::init(void)
{
    dre             = Drive_INV;
    szVolName[0]    = 0;
    vtVolume        = vtINVALID;
    dwUIFlags       = 0;
    bPurgeFiles     = TRUE;
}


/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::destroy
**
** Purpose:    releases any dynamic memory
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::destroy(void)
{
    //
    //Set values back to defaults
    //
    init();
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::CleanupMgrInfo
**
** Purpose:    Default constructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::CleanupMgrInfo (void)
{
    init();
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::CleanupMgrInfo
**
** Purpose:    Constructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::CleanupMgrInfo(
    LPTSTR lpDrive,
    DWORD dwFlags,
    ULONG ulProfile
    )
{
    HRESULT hr;

    init();

    hr = CoInitialize(NULL);

    if (SUCCEEDED(hr))
    {
        if (create(lpDrive, dwFlags))
        {
            dwReturnCode = RETURN_SUCCESS;
            dwUIFlags = dwFlags;
            ulSAGEProfile = ulProfile;
            bAbortScan = FALSE;
            bAbortPurge = FALSE;
    
            volumeCacheCallBack = NULL;
            pIEmptyVolumeCacheCallBack = NULL;
            volumeCacheCallBack = new CVolumeCacheCallBack();

            if (volumeCacheCallBack)
            {
                hr = volumeCacheCallBack->QueryInterface(IID_IEmptyVolumeCacheCallBack,
                                                   (LPVOID*)&pIEmptyVolumeCacheCallBack);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

            if (hr != NOERROR)
            {
                MiDebugMsg((hr, "CleanupMgrInfo::CleanupMgrInfo failed with error "));
            }

            //
            //Initialize all of the cleanup clients
            //
            if (initializeClients() && !(dwUIFlags & FLAG_TUNEUP) && !(dwUIFlags & FLAG_SAGESET))
            {
                //
                //Have all of the cleanup clients calculate the ammount of disk
                //space that they can free up.
                //
                getSpaceUsedByClients();
            }
        }
    }
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::~CleanupMgrInfo
**
** Purpose:    Destructor
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
CleanupMgrInfo::~CleanupMgrInfo (void)
{
    if (isValid())
    {
        //
        //Cleanup the Volume Cache Clients
        //
        deactivateClients();    

        if (volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->Release();
        }
   
        CoUninitialize();

        destroy();   
    }
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::create
**
** Purpose:    Gets Drive info from drive letter
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrInfo::create(
    LPTSTR lpDrive,
    DWORD Flags
    )
{
     
    //
    //Note:  Make sure the assigns to zero stay current
    //       otherwise we might get garbage stats if
    //       we fail because of lack of free space
    //
    DWORD cSectorsPerCluster;
    DWORD cBytesPerSector;
    DWORD cBytesPerCluster;
    DWORD cFreeClusters;
    DWORD cUsedClusters;
    DWORD cTotalClusters;
    ULARGE_INTEGER cbFree;
    ULARGE_INTEGER cbUsed;
    ULARGE_INTEGER cbTotal;
#ifdef NEC_98
    drenum drive;
    hardware hw_type;
#endif

    cbFree.QuadPart = 0;
    cbUsed.QuadPart = 0;
    
    //
    //Cleanup up any old stuff
    //
    destroy();

    //
    //Check parameters
    //
    if (lpDrive == NULL)
    {
        return FALSE;
    }
      
    //  
    //Is it a valid drive path
    //
    if (!fIsValidDriveString(lpDrive))
    {
        return FALSE;
    }

    //
    //Get drive from path
    //
    if (!GetDriveFromString(lpDrive, dre))
    {
        return FALSE;
    }

    if (!SUCCEEDED(StringCchCopy(szRoot, ARRAYSIZE(szRoot), lpDrive)))
    {
        return FALSE;
    }

      
    // 
    // Step 2.  Get general info from drive
    //

    //
    //Get volume name
    //
    if (!GetVolumeInformation (szRoot,                                 // Root name
                               szVolName,                              // Volume Name
                               ARRAYSIZE(szVolName),                   // Size
                               NULL,                                   // Volume serial number
                               NULL,                                   // Max path length
                               NULL,                                   // flags
                               szFileSystem, sizeof(szFileSystem)))    // file system name                         
    {
        //Error - failed to get volume name
        goto lblERROR;
    }

    //
    //Get the Driver Icon
    //
    if (Flags & FLAG_SAGESET)
        hDriveIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(ICON_CLEANMGR));
    else
        hDriveIcon = GetDriveIcon(dre, FALSE);

    //  
    //Get Hardware type
    //
    if (!GetHardwareType(dre, hwHardware))
    {
        //Error - failed to get hardware
        goto lblERROR;
    }


#ifdef NEC_98
    drive = Drive_A;
    GetHardwareType (Drive_A, hw_type);

    if (hw_type != hwFixed) 
    {
        drive = Drive_B;
        GetHardwareType (Drive_B, hw_type);

        if (hw_type != hwFixed)
            drive = Drive_C;
    }
#endif


    // 
    //Get disk statistics
    //
    if (!GetDiskFreeSpace (szRoot, 
                           &cSectorsPerCluster, 
                           &cBytesPerSector,
                           &cFreeClusters,
                           &cTotalClusters))
    {
        //Error - couldn't get drive stats
        goto lblERROR;
    }
      
    //  
    //Calculate secondary statistics
    //
    cBytesPerCluster = cBytesPerSector * cSectorsPerCluster;
    if (cTotalClusters >= cFreeClusters)
        cUsedClusters = cTotalClusters - cFreeClusters;
    else
        cUsedClusters = 0L;

    cbFree.QuadPart   = UInt32x32To64(cFreeClusters, cBytesPerCluster);
    cbUsed.QuadPart   = UInt32x32To64(cUsedClusters, cBytesPerCluster);
    cbTotal.QuadPart  = cbFree.QuadPart + cbUsed.QuadPart;

    //
    //Get the current low disk space ratio
    //
    cbLowSpaceThreshold = GetFreeSpaceRatio(dre, cbTotal);

    //
    //Should we also load the agressive cleaners? We only do this if we
    //are below are critical threshold of disk space left.
    //
    if (cbLowSpaceThreshold.QuadPart >= cbFree.QuadPart)
    {
        MiDebugMsg((0, "*****We are in aggressive mode*****"));
        bOutOfDiskSpace = TRUE;
    }
    else
        bOutOfDiskSpace = FALSE;

    // 
    // Step 3.  Save stats
    //

    cbDriveFree          = cbFree;
    cbDriveUsed          = cbUsed;
    cbEstCleanupSpace.QuadPart    = 0;

    //
    //Success
    //
    return TRUE;

lblERROR:
    //  
    //Error
    //
    destroy();
    return FALSE;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::initializeClients
**
** Purpose:    Initializes all of the Volume Cache Clients
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL 
CleanupMgrInfo::initializeClients(void)
{
    HKEY    hKeyVolCache = NULL;
    DWORD   iSubKey;
    DWORD   dwClient;
    TCHAR   szVolCacheClient[MAX_PATH];
    TCHAR   szGUID[MAX_PATH];
    DWORD   dwGUIDSize;
    DWORD   dwType;
    DWORD   dwState, cb, cw;
    TCHAR   szProfile[64];
    BOOL    bRet = TRUE;
    BOOL    bCleanup;

    iNumVolumeCacheClients = 0;
    pClientInfo = NULL;
    
    MiDebugMsg((0, "CleanupMgrInfo::initializeClients entered"));

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_VOLUMECACHE, 0, KEY_READ, &hKeyVolCache) == ERROR_SUCCESS)
    {
        //
        //Enumerate through all of the clients to see how large we need to make the pClientInfo array
        //

        iSubKey = 0;
        while(RegEnumKey(hKeyVolCache, iSubKey, szVolCacheClient, ARRAYSIZE(szVolCacheClient)) != ERROR_NO_MORE_ITEMS)
        {
            iSubKey++;        
        }
        
        if ((pClientInfo = (PCLIENTINFO)LocalAlloc(LPTR, (iSubKey * sizeof(CLIENTINFO)))) == NULL)
        {
#ifdef DEBUG
            MessageBox(NULL, TEXT("FATAL ERROR LocalAlloc() failed!"), TEXT("CLEANMGR DEBUG"), MB_OK);
#endif
            RegCloseKey(hKeyVolCache);
            return FALSE;
        }
        
        //
        //Fill in the pClientInfo data structure and initialize all of the volume cache clients
        //   
        iSubKey = 0;
        dwClient = 0;
        while(RegEnumKey(hKeyVolCache, iSubKey, szVolCacheClient, ARRAYSIZE(szVolCacheClient)) != ERROR_NO_MORE_ITEMS)
        {
            HRESULT hr;
            
            // default is we failed, so cleanup the current item....
            bCleanup = TRUE;
            
            if (RegOpenKeyEx(hKeyVolCache, szVolCacheClient, 0, MAXIMUM_ALLOWED, &(pClientInfo[dwClient].hClientKey)) == ERROR_SUCCESS)
            {
                hr = StringCchCopy( pClientInfo[dwClient].szRegKeyName, 
                                    ARRAYSIZE(pClientInfo[dwClient].szRegKeyName),
                                    szVolCacheClient);
            
                dwGUIDSize = sizeof(szGUID);
                dwType = REG_SZ;
                if (SUCCEEDED(hr) && RegQueryValueEx(pClientInfo[dwClient].hClientKey, NULL, NULL, &dwType, (LPBYTE)szGUID, &dwGUIDSize) == ERROR_SUCCESS)
                {
                    WCHAR   wcsFmtID[39];

#ifdef UNICODE
                    StringCchCopy(wcsFmtID, ARRAYSIZE(wcsFmtID), szGUID);
#else
                    //Convert to Unicode.
                    MultiByteToWideChar(CP_ACP, 0, szGUID, -1, wcsFmtID, ARRAYSIZE( wcsFmtID )) ;
#endif

                    //Convert to GUID.
                    hr = CLSIDFromString((LPOLESTR)wcsFmtID, &(pClientInfo[dwClient].clsid));

                    if (FAILED(hr))
                    {
                        MiDebugMsg((hr, "CLSIDFromString(%s,) returned error ", szGUID));
                    }

                    //
                    //Create an instance of the COM object for this cleanup client
                    //
                    pClientInfo[dwClient].pVolumeCache = NULL;
                    hr = CoCreateInstance(pClientInfo[dwClient].clsid,
                                                    NULL,
                                                    CLSCTX_INPROC_SERVER,
                                                    IID_IEmptyVolumeCache,
                                                    (void **) &(pClientInfo[dwClient].pVolumeCache));

                    if (SUCCEEDED(hr))
                    {
                        WCHAR   wcsRoot[MAX_PATH];

                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients Created IID_IEmptyVolumeCache"));
                        //
                        //Set the flags to pass to the cleanup client
                        //
                        pClientInfo[dwClient].dwInitializeFlags = 0;
                        if (dwUIFlags & FLAG_SAGESET)
                            pClientInfo[dwClient].dwInitializeFlags |= EVCF_SETTINGSMODE;
                        if (bOutOfDiskSpace)
                            pClientInfo[dwClient].dwInitializeFlags |= EVCF_OUTOFDISKSPACE;

#ifdef UNICODE
                        StringCchCopy(wcsRoot, ARRAYSIZE(wcsRoot), szRoot);
#else
                        //
                        //Convert szRoot to UNICODE
                        //
                        MultiByteToWideChar(CP_ACP, 0, szRoot, -1, wcsRoot, ARRAYSIZE( wcsRoot ));
#endif

                        // Try to use version two of the interface if it is supported
                        IEmptyVolumeCache2 * pEVC2;
                        hr = pClientInfo[dwClient].pVolumeCache->QueryInterface( IID_IEmptyVolumeCache2, (void**)&pEVC2 );
                        if (SUCCEEDED(hr))
                        {
                            // version 2 exists so that we can have a mutli-local enabled data driven cleaner.  It
                            // allows the added Advanced Button to be set to a localized value.  It tells the
                            // object being called which key it is being called for so that one object can support
                            // multiple filters.
                            WCHAR   wcsFilterName[MAX_PATH];
                            MiDebugMsg((hr, "CleanupMgrInfo::initializeClients found V2 interface"));
#ifdef UNICODE
                            StringCchCopy(wcsFilterName, ARRAYSIZE(wcsFilterName), szVolCacheClient);
#else
                            MultiByteToWideChar(CP_ACP, 0, szVolCacheClient, -1, wcsFilterName, ARRAYSIZE( wcsFilterName )) ;
#endif

                            hr = pEVC2->InitializeEx(pClientInfo[dwClient].hClientKey,
                                                    (LPCWSTR)wcsRoot,
                                                    (LPCWSTR)wcsFilterName,
                                                    &((LPWSTR)pClientInfo[dwClient].wcsDisplayName),
                                                    &((LPWSTR)pClientInfo[dwClient].wcsDescription),
                                                    &((LPWSTR)pClientInfo[dwClient].wcsAdvancedButtonText),
                                                    &(pClientInfo[dwClient].dwInitializeFlags));
                            pEVC2->Release();
                        }
                        else
                        {
                            MiDebugMsg((hr, "CleanupMgrInfo::initializeClients using V1 interface"));
                            //
                            //Initialize the cleanup client
                            //
                            if ((pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(DESCRIPTION_LENGTH*sizeof(WCHAR))) == NULL)
                                return FALSE;

                            // We seem to have shipped this thing with a giant leak.  The object is supposted to set
                            // pClientInfo[dwClient].wcsDescription to NULL if the registry value should be used instead
                            // of the buffer.  However we just allocated a buffer for pClientInfo[dwClient].wcsDescription
                            // in the code above (this is the dumbass part).  All the filters then set this pointer to
                            // NULL and it's bye-bye buffer.  I can't simply not allocate this memory because some cleaners
                            // might rely on being able to use this memory and we shipped it that way.
                            LPWSTR wszLeakProtection = pClientInfo[dwClient].wcsDescription;
                            hr = pClientInfo[dwClient].pVolumeCache->Initialize(pClientInfo[dwClient].hClientKey,
                                                                               (LPCWSTR)wcsRoot,
                                                                               &((LPWSTR)pClientInfo[dwClient].wcsDisplayName),
                                                                               &((LPWSTR)pClientInfo[dwClient].wcsDescription),
                                                                               &(pClientInfo[dwClient].dwInitializeFlags));                                                                
                            if ( wszLeakProtection != pClientInfo[dwClient].wcsDescription )
                            {
                                // REVIEW: Use try...except around CoTaskMemFree in case some smart cleaner
                                // realized our mistake and deleted the memory for us?
                                MiDebugMsg((hr, "CleanupMgrInfo::initializeClients prevent mem leak hack"));
                                CoTaskMemFree( wszLeakProtection );
                            }

                            if ( S_OK == hr )
                            {
                                // To make it easier to make a cleaner we have a default implementation of IEmptyVolumeCache
                                // that works entirerly using registry data.  The problem is that display strings are strored
                                // in the registry.  This is invalid for NT because NT must be multi-local localizable and
                                // the only way to do that is to load all display strings from a resource.  As a hack, you
                                // can now implement IPropertyBag using an object with it's guid stored under the propertybag
                                // value in the registry.  We will cocreate this object and query for IPropertyBag.  If this
                                // works then we will attempt to read the localized strings from the property bag before we
                                // fall back on checking the registry.
                                TCHAR   szPropBagGUID[MAX_PATH];
                                HRESULT hrFoo;
                                IPropertyBag * ppb = NULL;
                                VARIANT var;

                                VariantInit( &var );
                                dwGUIDSize = sizeof(szPropBagGUID);
                                dwType = REG_SZ;
                                if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, TEXT("PropertyBag"), NULL, &dwType, (LPBYTE)szPropBagGUID, &dwGUIDSize) == ERROR_SUCCESS)
                                {
                                    WCHAR   wcsFmtID[39];
                                    CLSID   clsid;

                                    MiDebugMsg((hr, "CleanupMgrInfo::initializeClients found PropBag key"));

#ifdef UNICODE
                                    StringCchCopy(wcsFmtID, ARRAYSIZE(wcsFmtID), szPropBagGUID);
#else
                                    MultiByteToWideChar(CP_ACP, 0, szPropBagGUID, -1, wcsFmtID, ARRAYSIZE( wcsFmtID )) ;
#endif

                                    //Convert to GUID.
                                    CLSIDFromString((LPOLESTR)wcsFmtID, &clsid);

                                    //
                                    //Create an instance of the COM object for this cleanup client
                                    //
                                    hrFoo = CoCreateInstance(clsid,
                                                          NULL,
                                                          CLSCTX_INPROC_SERVER,
                                                          IID_IPropertyBag,
                                                          (void **) &ppb);

                                    if ( FAILED(hrFoo) )
                                    {
                                        MiDebugMsg((hrFoo, "CleanupMgrInfo::initializeClients failed to create PropBag"));
                                    }
                                }

                                //
                                //If the client did not return the DisplayName via the Initialize
                                //Interface then we need to get it from the registry.
                                //
                                if ((pClientInfo[dwClient].wcsDisplayName) == NULL)
                                {
                                    LPTSTR  lpszDisplayName;

                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for display"));

                                        SHTCharToUnicode(REGSTR_VAL_DISPLAY, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (SysStringLen(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsDisplayName = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StringCbCopy( pClientInfo[dwClient].wcsDisplayName,
                                                              dwSize,
                                                              var.bstrVal );
                                            }
                                            VariantClear( &var );
                                        }
                                    }

                                    if ((pClientInfo[dwClient].wcsDisplayName) == NULL)
                                    {
                                        //
                                        //First check if their is a "display" value for the client's 
                                        //name that is displayed in the list box.  If not then use
                                        //the key name itself.
                                        //
                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DISPLAY, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        cb = max(cb, (ULONG)(lstrlen(szVolCacheClient) + 1) * sizeof (TCHAR));
                                        if ((lpszDisplayName = (LPTSTR)LocalAlloc(LPTR, cb)) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DISPLAY, NULL, &dwType, (LPBYTE)lpszDisplayName, &cb) != ERROR_SUCCESS)
                                            {
                                                //
                                                //Count not find "display" value so use the key name instead
                                                //
                                                StringCbCopy(lpszDisplayName, cb, szVolCacheClient);
                                            }

#ifdef UNICODE
                                            cw = (lstrlen( lpszDisplayName ) + 1) * sizeof( WCHAR);
#else
                                            //
                                            //Convert this value to UNICODE
                                            //
                                            cw = MultiByteToWideChar(CP_ACP, 0, lpszDisplayName, -1, NULL, 0);
#endif
                                            if ((pClientInfo[dwClient].wcsDisplayName = (LPWSTR)CoTaskMemAlloc(cw*sizeof(WCHAR))) != NULL)
                                            {
#ifdef UNICODE
                                                StringCchCopy(pClientInfo[dwClient].wcsDisplayName,
                                                              cw,
                                                              lpszDisplayName);
#else
                                                MultiByteToWideChar(CP_ACP, 0, lpszDisplayName, -1, (pClientInfo[dwClient].wcsDisplayName), cw);
#endif
                                            }
                                            LocalFree(lpszDisplayName);
                                        }
                                    }
                                }

                                //
                                //If the client did not return the Description via the Initialize
                                //Interface then we need to get it from the registry.
                                //
                                if ((pClientInfo[dwClient].wcsDescription) == NULL)
                                {
                                    LPTSTR  lpszDescription;


                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for description"));

                                        SHTCharToUnicode(REGSTR_VAL_DESCRIPTION, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (SysStringLen(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StringCbCopy(pClientInfo[dwClient].wcsDescription,
                                                              dwSize,
                                                              var.bstrVal);
                                            }
                                            VariantClear( &var );
                                        }
                                    }

                                    if ((pClientInfo[dwClient].wcsDescription) == NULL)
                                    {
                                        //
                                        //Check if their is a "description" value for the client 
                                        //
                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DESCRIPTION, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        if ((lpszDescription = (LPTSTR)LocalAlloc(LPTR, (cb + 1 ) * sizeof( TCHAR ))) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_DESCRIPTION, NULL, &dwType, (LPBYTE)lpszDescription, &cb) == ERROR_SUCCESS)
                                            {
#ifdef UNICODE
                                                cw = ( lstrlen( lpszDescription ) + 1 ) * sizeof( WCHAR );
#else
                                                //
                                                //Convert this value to UNICODE
                                                //
                                                cw = MultiByteToWideChar(CP_ACP, 0, lpszDescription, -1, NULL, 0);
#endif
                                                if ((pClientInfo[dwClient].wcsDescription = (LPWSTR)CoTaskMemAlloc(cw*sizeof(WCHAR))) != NULL)
                                                {
#ifdef UNICODE                                          
                                                    StringCchCopy(pClientInfo[dwClient].wcsDescription,
                                                                 cw,
                                                                 lpszDescription);
#else
                                                    MultiByteToWideChar(CP_ACP, 0, lpszDescription, -1, (pClientInfo[dwClient].wcsDescription), cw);
#endif
                                                }
                                            }

                                            LocalFree(lpszDescription);
                                        }
                                    }
                                }

                                //
                                //Set the Advanced Button text
                                //
                                pClientInfo[dwClient].wcsAdvancedButtonText = NULL;

                                if (pClientInfo[dwClient].dwInitializeFlags & EVCF_HASSETTINGS)
                                {
                                    if ( ppb )
                                    {
                                        WCHAR wszSrc[MAX_PATH];
                                        MiDebugMsg((hr, "CleanupMgrInfo::initializeClients checking PropBag for button text"));

                                        SHTCharToUnicode(REGSTR_VAL_ADVANCEDBUTTONTEXT, wszSrc, MAX_PATH);

                                        // do propertybag stuff
                                        var.vt = VT_BSTR;
                                        var.bstrVal = NULL;
                                        hrFoo = ppb->Read( wszSrc, &var, NULL );
                                        if (SUCCEEDED(hrFoo))
                                        {
                                            if ( var.vt == VT_BSTR )
                                            {
                                                DWORD dwSize = (SysStringLen(var.bstrVal)+1)*sizeof(WCHAR);
                                                pClientInfo[dwClient].wcsAdvancedButtonText = (LPWSTR)CoTaskMemAlloc(dwSize);
                                                StringCbCopy(pClientInfo[dwClient].wcsAdvancedButtonText,
                                                              dwSize,
                                                              var.bstrVal);
                                            }
                                            VariantClear( &var );
                                        }
                                    }
                                    if ( pClientInfo[dwClient].wcsAdvancedButtonText == NULL )
                                    {
                                        LPTSTR  lpszAdvancedButtonText;
                                        TCHAR   szDetails[BUTTONTEXT_LENGTH];

                                        LoadString(g_hInstance, IDS_DETAILS, szDetails, ARRAYSIZE(szDetails));

                                        cb = 0;
                                        dwType = REG_SZ;
                                        RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_ADVANCEDBUTTONTEXT, NULL, &dwType, (LPBYTE)NULL, &cb);
                                        cb = max(cb, (UINT)(lstrlen(szDetails)+1) * sizeof(TCHAR));
                                        if ((lpszAdvancedButtonText = (LPTSTR)LocalAlloc(LPTR, cb)) != NULL)
                                        {
                                            if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_ADVANCEDBUTTONTEXT, NULL, &dwType, (LPBYTE)lpszAdvancedButtonText, &cb) != ERROR_SUCCESS)
                                            {
                                                StringCbCopy(lpszAdvancedButtonText,
                                                              cb,
                                                              szDetails);
                                            }
                                            

#ifdef UNICODE
                                            cw = (lstrlen( lpszAdvancedButtonText ) + 1) * sizeof( WCHAR );
#else
                                            //
                                            //Convert this value to UNICODE
                                            //
                                            cw = MultiByteToWideChar(CP_ACP, 0, lpszAdvancedButtonText, -1, NULL, 0);
#endif
                                            if ((pClientInfo[dwClient].wcsAdvancedButtonText = (LPWSTR)CoTaskMemAlloc(cw*sizeof(WCHAR))) != NULL)
                                            {
#ifdef UNICODE
                                                StringCchCopy(pClientInfo[dwClient].wcsAdvancedButtonText,
                                                              cw,
                                                              lpszAdvancedButtonText);
                                                
#else
                                                MultiByteToWideChar(CP_ACP, 0, lpszAdvancedButtonText, -1, (pClientInfo[dwClient].wcsAdvancedButtonText), cw);
#endif
                                            }

                                            LocalFree(lpszAdvancedButtonText);
                                        }
                                    }
                                }

                                if (ppb)
                                {
                                    ppb->Release();
                                }
                            }
                        }

                        // Now we're back to stuff that both version 1 and version 2 require
                        if (SUCCEEDED(hr))
                        {
                            if (S_OK == hr)
                            {
                                //
                                //Default to showing this client in the UI
                                //
                                pClientInfo[dwClient].bShow = TRUE;
                            
                                //
                                //Get the "priority" from the registry
                                //
                                cb = sizeof(pClientInfo[dwClient].dwPriority);
                                dwType = REG_DWORD;
                                if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, REGSTR_VAL_PRIORITY, NULL, &dwType, (LPBYTE)&(pClientInfo[dwClient].dwPriority), &cb) != ERROR_SUCCESS)
                                    pClientInfo[dwClient].dwPriority = DEFAULT_PRIORITY;
                                
                                //
                                //Flags
                                //
                                if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                {
                                    StringCchPrintf(szProfile, ARRAYSIZE(szProfile),
                                                    TEXT("%s%04d"), SZ_STATE, ulSAGEProfile);
                                }
                                else
                                {
                                    StringCchCopy(szProfile, ARRAYSIZE(szProfile), SZ_STATE);
                                }
                                    
                                dwState = 0;
                                cb = sizeof(dwState);
                                dwType = REG_DWORD;
                                
                                // If we were called with the low disk flag, select every cleaner by default
                                if (dwUIFlags & FLAG_LOWDISK)
                                {
                                    pClientInfo[iSubKey].bSelected = TRUE;
                                }

                                // Otherwise, check the registry
                                else if (RegQueryValueEx(pClientInfo[dwClient].hClientKey, szProfile, NULL,
                                    &dwType, (LPBYTE)&dwState, &cb) == ERROR_SUCCESS)
                                {
                                    if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                    {
                                        pClientInfo[dwClient].bSelected = (dwState & STATE_SAGE_SELECTED);
                                    }
                                    else
                                    {
                                        pClientInfo[dwClient].bSelected = (dwState & STATE_SELECTED);
                                    }
                                }
                                else
                                {
                                    //
                                    //No registry settings for this profile so use the cleanup clients
                                    //default settings.
                                    //
                                    if (dwUIFlags & FLAG_SAGERUN || dwUIFlags & FLAG_SAGESET)
                                    {
                                        pClientInfo[dwClient].bSelected = (pClientInfo[dwClient].dwInitializeFlags & EVCF_ENABLEBYDEFAULT_AUTO) ? TRUE : FALSE;
                                    }
                                    else
                                    {
                                        pClientInfo[dwClient].bSelected = (pClientInfo[dwClient].dwInitializeFlags & EVCF_ENABLEBYDEFAULT) ? TRUE : FALSE;
                                    }
                                }
                                
                                //
                                //Get the icon of the cleanup client
                                //

                                // first test to see if it is overridden...
                                TCHAR szIconPath[MAX_PATH];
                                cb = sizeof( szIconPath );
                                BOOL fOverridden = FALSE;
                                
                                if ( RegQueryValueEx(pClientInfo[dwClient].hClientKey, TEXT("IconPath"), NULL,
                                    &dwType, (LPBYTE)szIconPath, &cb) == ERROR_SUCCESS )
                                {
                                    fOverridden = TRUE;
                                }
                                else
                                {
                                    StringCchCopy(szIconPath, ARRAYSIZE(szIconPath), szGUID);
                                }
                                
                                pClientInfo[dwClient].hIcon = GetClientIcon(szIconPath, fOverridden);

                                bCleanup = FALSE;
                            }
                            else
                            {
                                //
                                //This should be S_FALSE.  This means that the client has nothing to 
                                //cleanup now so we don't even need to show it in the list.
                                //Therefor we will just call its Release() function and close it's
                                //registry key.
                                //

                                // drop through and let it cleanup below...
                            }
                        }
                        else
                        {
                            MiDebugMsg((hr, "Client %d Initialize() retuned error ", dwClient));
                        }                                                                      
                    }
                    else
                    {
                        MiDebugMsg((hr, "Client %d %s returned error ", dwClient, szGUID));
                    }
                }
#ifdef DEBUG
                else
                {
                    MessageBox(NULL, szVolCacheClient, TEXT("ERROR Opening GUID key"), MB_OK);
                }                
#endif
            }
#ifdef DEBUG
            else
            {
                MessageBox(NULL, szVolCacheClient, TEXT("ERROR Opening the client key"), MB_OK);
            }
#endif

            if ( bCleanup )
            {
                deactivateSingleClient(&(pClientInfo[dwClient]));
                ZeroMemory( &(pClientInfo[dwClient]), sizeof( CLIENTINFO ));
            }
            else
            {
                dwClient ++;
            }
            iSubKey++;        
        }
        iNumVolumeCacheClients = dwClient;
    }
#ifdef DEBUG
    else
    {
        MessageBox(NULL, TEXT("ERROR Opening up Volume Cache key"), TEXT("CLEANMGR DEBUG"), MB_OK);
    }
#endif

    if( hKeyVolCache )
    {
        RegCloseKey(hKeyVolCache);
    }
    return bRet;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::deactivateClients
**
** Purpose:    Initializes all of the Volume Cache Clients
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::deactivateClients(void)
{
    int     i;
    
    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        deactivateSingleClient(&(pClientInfo[i]));
    }

    //
    //Free the pClientInfo array
    //
    if (pClientInfo)
    {
        MiDebugMsg((0, "LocalFree() on ClientInfo structure"));
        LocalFree( pClientInfo);
    }
}


/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::deactivateSingleClient
**
** Purpose:    Deactivate's the given client and closes its registry key
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
void 
CleanupMgrInfo::deactivateSingleClient(PCLIENTINFO pSingleClientInfo)
{
    DWORD   dwDeactivateFlags = 0;
    TCHAR   szProfile[64];
    
    if (pSingleClientInfo->pVolumeCache != NULL)
    {
        //
        //Call the clients Deactivate function
        //
        pSingleClientInfo->pVolumeCache->Deactivate(&dwDeactivateFlags);

        //
        //Release the client
        //
        pSingleClientInfo->pVolumeCache->Release();
        pSingleClientInfo->pVolumeCache = NULL;
    }
            
    if (pSingleClientInfo->hClientKey != 0)
    {
        DWORD   dwState, cb, dwType, dwSelectedFlag;

        if (dwUIFlags & FLAG_SAVE_STATE)
        {
            //
            //Save the state flags
            //
            if (dwUIFlags & FLAG_SAGESET)
            {
                dwSelectedFlag = STATE_SAGE_SELECTED;
                StringCchPrintf(szProfile, ARRAYSIZE(szProfile), TEXT("%s%04d"), SZ_STATE, ulSAGEProfile);
            }
            else
            {
                dwSelectedFlag = STATE_SELECTED;
                StringCchCopy(szProfile, ARRAYSIZE(szProfile), SZ_STATE);
            }

            dwState = 0;
            cb = sizeof(dwState);
            dwType = REG_DWORD;
            if (RegQueryValueEx(pSingleClientInfo->hClientKey, szProfile, NULL, &dwType, (LPBYTE)&dwState, &cb) == ERROR_SUCCESS)
            {
                if (pSingleClientInfo->bSelected)
                {
                    dwState |= dwSelectedFlag;
                }
                else
                {
                    dwState &= ~dwSelectedFlag;
                }

                RegSetValueEx(pSingleClientInfo->hClientKey, szProfile, 0, REG_DWORD, (LPBYTE)&dwState, sizeof(dwState));
            }
        }
    
        //
        //Close all of the registry keys
        //
        RegCloseKey(pSingleClientInfo->hClientKey);

        //
        //Should we remove this entry from the registry?
        //
        if (dwDeactivateFlags & EVCF_REMOVEFROMLIST && pSingleClientInfo->bSelected)
        {
            HKEY    hKeyVolCache;
            
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_VOLUMECACHE, 0, KEY_WRITE, &hKeyVolCache) == ERROR_SUCCESS)
            {
                SHDeleteKey(hKeyVolCache, pSingleClientInfo->szRegKeyName);
                RegCloseKey(hKeyVolCache);
            }
        }            
            
    }

    //
    //Free the DisplayName and Description memory
    //
    if (pSingleClientInfo->wcsDisplayName)
        CoTaskMemFree(pSingleClientInfo->wcsDisplayName);
        
    if (pSingleClientInfo->wcsDescription)
        CoTaskMemFree(pSingleClientInfo->wcsDescription);
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::getSpaceUsedByClients
**
** Purpose:    Calls the IEmptyVolumeCache->GetSpaceUsed interface for each client
**             to determine the total amount of cache space.  This function is
**             called on a secondary thread because it can take quite a long time.
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrInfo::getSpaceUsedByClients(void)
{
    int         i;
    HRESULT     hr;
    BOOL        bRet = TRUE;
    TCHAR       szDisplayName[256];
        
    cbEstCleanupSpace.QuadPart = 0;
    bAbortScan = FALSE;

    hAbortScanEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Someone should make sure the window created in the ScanAbortThread thread is visible before
    // the hAbortScanEvent event is signaled
    hAbortScanThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)ScanAbortThread,
        (LPVOID)this, 0, &dwAbortScanThreadID);

    //
    //Wait until the Abort Scan window is created
    //
    WaitForSingleObject(hAbortScanEvent, INFINITE);

    CloseHandle(hAbortScanEvent);

    if (volumeCacheCallBack != NULL)
    {
        volumeCacheCallBack->SetCleanupMgrInfo((PVOID)this);
    }

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //Update the progress UI
        //
        szDisplayName[0] = '\0';
        
#ifdef UNICODE
        StringCchCopy(szDisplayName, ARRAYSIZE(szDisplayName), pClientInfo[i].wcsDisplayName);
#else
        WideCharToMultiByte(CP_ACP, 0, pClientInfo[i].wcsDisplayName, -1, szDisplayName, sizeof(szDisplayName), NULL, NULL);
#endif
        
        PostMessage(hAbortScanWnd, WMAPP_UPDATEPROGRESS, (WPARAM)i, (LPARAM)szDisplayName);

        //
        //Query the client for the ammount of cache disk space that it could
        //possible free.
        //
        if (pClientInfo[i].pVolumeCache != NULL && volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->SetCurrentClient((PVOID)&(pClientInfo[i]));
            hr = pClientInfo[i].pVolumeCache->GetSpaceUsed(&(pClientInfo[i].dwUsedSpace.QuadPart), 
                                                                    pIEmptyVolumeCacheCallBack);      
            
            if (FAILED(hr))
            {
                dwReturnCode = RETURN_CLEANER_FAILED;
                MiDebugMsg((hr, "Client %d GetSpaceUsed failed with error ", i));
            }
            
            MiDebugMsg((0, "Client %d has %d disk space it can free", i,
                pClientInfo[i].dwUsedSpace.QuadPart));
        }

        //
        //See if this cleaner wants to be hidden if it has no space to free
        //
        if ((pClientInfo[i].dwUsedSpace.QuadPart == 0) &&
            (pClientInfo[i].dwInitializeFlags & EVCF_DONTSHOWIFZERO))
        {
            MiDebugMsg((0, "Not showing client %d because it has no space to free", i));
            pClientInfo[i].bShow = FALSE;
        }

        cbEstCleanupSpace.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;

        //
        //Did the user abort?
        //
        if (bAbortScan == TRUE)
        {
            dwReturnCode = RETURN_USER_CANCELED_SCAN;
            bRet = FALSE;
            break;
        }
    }

    // the dismissal of the progress dialog is now delayed until the propsheet comes up..

    return bRet;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::calculateSpaceToPurge
**
** Purpose:    Calculates the amount of space that is going to be purged
**             by adding up all of the selected clients.  It also calculates
**             the progress bar divisor number.  This is needed because a
**             progress bar has a MAX of 0xFFFF.
**
** Mod Log:    Created by Jason Cobb (6/97)
**------------------------------------------------------------------------------
*/
void
CleanupMgrInfo::calculateSpaceToPurge(void)
{
    int i;
    
    cbSpaceToPurge.QuadPart = 0;

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //If this client is not selected or we are not showing it then don't purge it
        //
        if (pClientInfo[i].bShow == FALSE || pClientInfo[i].bSelected == FALSE)
            continue;
    
        cbSpaceToPurge.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;
    }

    cbProgressDivider.QuadPart = (cbSpaceToPurge.QuadPart / PROGRESS_DIVISOR) + 1;
}

/*
**------------------------------------------------------------------------------
** CleanupMgrInfo::purgeClients
**
** Purpose:    Calls the IEmptyVolumeCache->Purge interface for each client
**             to have the client cleaner object start removeing their files
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
BOOL
CleanupMgrInfo::purgeClients(void)
{
    int         i;
    HRESULT     hr;
    BOOL        bRet = TRUE;
    TCHAR       szDisplayName[256];
        
    cbTotalPurgedSoFar.QuadPart = 0;
    bAbortPurge = FALSE;

    //
    //Calculate the amount of space that will be purged.
    //
    calculateSpaceToPurge();
    MiDebugMsg((0, "Total number of bytes to delete is %d", cbSpaceToPurge.LowPart));

    hAbortPurgeEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

    // Someone should (but it hasn't broken in 3 years), make sure the window created in PurgeAbortThread is visible before
    // the hAbortPurgeEvent is signaled
    hAbortPurgeThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)PurgeAbortThread,
        (LPVOID)this, 0, &dwAbortPurgeThreadID);

    //
    //Wait until the Abort Purge window is created
    //
    WaitForSingleObject(hAbortPurgeEvent, INFINITE);

    CloseHandle(hAbortPurgeEvent);

    if (volumeCacheCallBack != NULL)
    {
        volumeCacheCallBack->SetCleanupMgrInfo((PVOID)this);
    }

    for (i=0; i<iNumVolumeCacheClients; i++)
    {
        //
        //If this client is not selected or we are not showing it then don't purge it
        //
        if (pClientInfo[i].bShow == FALSE || pClientInfo[i].bSelected == FALSE)
            continue;
    
#ifdef UNICODE
        StringCchCopy(szDisplayName, ARRAYSIZE(szDisplayName), pClientInfo[i].wcsDisplayName);
#else
        //
        //Convert UNICODE display name to ANSI and then add it to the list
        //
        WideCharToMultiByte(CP_ACP, 0, pClientInfo[i].wcsDisplayName, -1, szDisplayName, sizeof(szDisplayName), NULL, NULL);
#endif

        PostMessage(hAbortPurgeWnd, WMAPP_UPDATESTATUS, 0, (LPARAM)szDisplayName);

        cbCurrentClientPurgedSoFar.QuadPart = 0;

        //
        //Query the client for the ammount of cache disk space that it could
        //possible free.
        //
        if (pClientInfo[i].pVolumeCache != NULL && volumeCacheCallBack != NULL)
        {
            volumeCacheCallBack->SetCurrentClient((PVOID)&(pClientInfo[i]));

            hr = pClientInfo[i].pVolumeCache->Purge(pClientInfo[i].dwUsedSpace.QuadPart, pIEmptyVolumeCacheCallBack);
            
            if (FAILED(hr))
            {
                dwReturnCode = RETURN_CLEANER_FAILED;
                MiDebugMsg((hr, "Client %d Purge failed with error ", i));
            }
        }

        cbTotalPurgedSoFar.QuadPart += pClientInfo[i].dwUsedSpace.QuadPart;
        cbCurrentClientPurgedSoFar.QuadPart = 0;

        //
        //Update the progress bar
        //
        PostMessage(hAbortPurgeWnd, WMAPP_UPDATEPROGRESS, 0, 0);

        //
        //Did the user abort?
        //
        if (bAbortPurge == TRUE)
        {
            dwReturnCode = RETURN_USER_CANCELED_PURGE;
            bRet = FALSE;
            break;
        }

        Sleep(1000);
    }

    if (!bAbortPurge)
    {
        bAbortPurge = TRUE;

        //
        //Wait for Purge thread to finish
        //  
        WaitForSingleObject(hAbortPurgeThread, INFINITE);

        bAbortPurge = FALSE;
    }

    return bRet;
}

/*
**------------------------------------------------------------------------------
** GetClientIcon
**
** Purpose:    Gets the Icon for this client.  
**             The icon will be inferred using the standard OLE mechanism
**             under HKCR\CLSID\{clsid}\DefaultIcon (with the default value
**             for this being the <Module Path>, <icon index>).
**             If no icon is specified the standard windows icon will be used.
** Mod Log:    Created by Jason Cobb (2/97)
**------------------------------------------------------------------------------
*/
HICON
CleanupMgrInfo::GetClientIcon(
    LPTSTR  lpGUID,
    BOOL    fIconPath
    )
{
    HKEY    hk;
    HICON   hIconLarge, hIconSmall;
    HICON   hIcon = NULL;
    TCHAR   szIconKey[MAX_PATH];
    TCHAR   szDefaultIcon[MAX_PATH];
    DWORD   dwType, cbBytes;
    TCHAR   szIconExeName[MAX_PATH];
    int     i, iIconIndex;
    HRESULT hr = E_FAIL;

    if ( fIconPath )
    {
        hr = StringCchCopy(szDefaultIcon, ARRAYSIZE(szDefaultIcon), lpGUID);
    }
    else
    {
        hr = StringCchPrintf(szIconKey, ARRAYSIZE(szIconKey), SZ_DEFAULTICONPATH, lpGUID);
        if (SUCCEEDED(hr) && RegOpenKeyEx(HKEY_CLASSES_ROOT, szIconKey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
        {
            dwType = REG_SZ;
            cbBytes = sizeof(szDefaultIcon);
            if (RegQueryValueEx(hk, NULL, NULL, &dwType, (LPBYTE)szDefaultIcon, &cbBytes) == ERROR_SUCCESS)
            {
                fIconPath = TRUE;
            }
            RegCloseKey(hk);
        }
    }

    if (SUCCEEDED(hr) && fIconPath)
    {
        //
        //Parse out the exe where the icon lives
        //
        for(i=0; i<lstrlen(szDefaultIcon); i++)
        {
            if (szDefaultIcon[i] == ',')
                break;

            szIconExeName[i] = szDefaultIcon[i];
        }

        szIconExeName[i] = '\0';

        //
        //Parse out the icon index
        //
        i++;
        iIconIndex = StrToInt(&(szDefaultIcon[i]));

        if (ExtractIconEx(szIconExeName, iIconIndex, (HICON FAR *)&hIconLarge, (HICON FAR *)&hIconSmall, 1))
        {
            if (hIconSmall)
                hIcon = hIconSmall;
            else
                hIcon = hIconLarge;
        }
    }
    
    if (hIcon == NULL)
    {
        if ((hIcon = LoadIcon(CleanupMgrInfo::hInstance, MAKEINTRESOURCE(ICON_GENERIC))) == NULL)
        {
            MiDebugMsg((0, "LoadIcon failed with error %d", GetLastError()));
        }   
    }
    
    return hIcon;
}

INT_PTR CALLBACK
ScanAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo *pcmi;

    switch(Message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hDlg, DWLP_USER, 0L);

            //   
            //Get the CleanupMgrInfo
            //
            pcmi = (CleanupMgrInfo *)lParam;    
            if (pcmi == NULL)
            {   
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }       

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            TCHAR * psz;
            psz = SHFormatMessage( MSG_SCAN_ABORT_TEXT, pcmi->szVolName, pcmi->szRoot[0] );
            SetDlgItemText (hDlg, IDC_ABORT_TEXT, psz);
            LocalFree(psz);

            //
            //Set the limits on the progress bar
            //
            SendDlgItemMessage(hDlg, IDC_ABORT_SCAN_PROGRESS, PBM_SETRANGE,
                0, MAKELPARAM(0, pcmi->iNumVolumeCacheClients));
            break;

        case WMAPP_UPDATEPROGRESS:
            if (lParam != NULL)
                SetDlgItemText(hDlg, IDC_SCAN_STATUS_TEXT, (LPTSTR)lParam);
            else
                SetDlgItemText(hDlg, IDC_SCAN_STATUS_TEXT, TEXT(""));
                
            SendDlgItemMessage(hDlg, IDC_ABORT_SCAN_PROGRESS, PBM_SETPOS,
                (WPARAM)wParam, 0);
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
                pcmi->bAbortScan = TRUE;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

BOOL
PASCAL
MessagePump(
    HWND hDialogWnd
    )
{
    MSG Msg;
    BOOL fGotMessage;

    if ((fGotMessage = PeekMessage(&Msg, NULL, 0, 0, PM_REMOVE))) 
    {
        if (!IsDialogMessage(hDialogWnd, &Msg)) 
        {
            TranslateMessage(&Msg);
            DispatchMessage(&Msg);
        }
    }

    return fGotMessage;
}


void
ScanAbortThread(
    CleanupMgrInfo *pcmi
    )
{
    if ((pcmi->hAbortScanWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_SCAN_ABORT),
        NULL, ScanAbortDlgProc, (LPARAM)pcmi)) == NULL)
    {
        return;
    }   

    // Show the window (except when the /SETUP flag is specified)
    if (!(pcmi->dwUIFlags & FLAG_SETUP))
        ShowWindow(pcmi->hAbortScanWnd, SW_SHOW);

    // Trigger the event so we can continue with the scan.
    // If this is triggered from WM_INITDIALOG it can move too quickly
    // and will end up sending a message to NULL instead of the scan abort window
    // because the hwnd doesn't get set until CreateDialogParam returns.
    SetEvent(pcmi->hAbortScanEvent);
    
    //
    //Keep spinning till the Scan is stopped
    //
    while (!(pcmi->bAbortScan))
    {
        MessagePump(pcmi->hAbortScanWnd);
    }

    //
    //Destroy the Abort Scan dialog
    //
    if (pcmi->hAbortScanWnd != NULL)
    {
        DestroyWindow(pcmi->hAbortScanWnd);
        pcmi->hAbortScanWnd = NULL;
    }
}

INT_PTR CALLBACK
PurgeAbortDlgProc(
    HWND hDlg,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    CleanupMgrInfo  *pcmi;
    DWORD           dwCurrent;

    switch(Message)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hDlg, DWLP_USER, 0L);

            //   
            //Get the CleanupMgrInfo
            //
            pcmi = (CleanupMgrInfo *)lParam;    
            if (pcmi == NULL)
            {   
                //Error - passed in invalid CleanupMgrInfo info
                return FALSE;
            }       

            //
            //Save pointer to CleanupMgrInfo object
            //
            SetWindowLongPtr(hDlg, DWLP_USER, lParam);

            TCHAR * psz;
            psz = SHFormatMessage( MSG_PURGE_ABORT_TEXT, pcmi->szVolName, pcmi->szRoot[0]);
            SetDlgItemText (hDlg, IDC_PURGE_TEXT, psz);
            LocalFree(psz);

            //
            //Set the limits on the progress bar
            //
            if (pcmi->cbProgressDivider.QuadPart != 0)
                dwCurrent = (DWORD)(pcmi->cbSpaceToPurge.QuadPart / pcmi->cbProgressDivider.QuadPart);
            else
                dwCurrent = (DWORD)(pcmi->cbSpaceToPurge.QuadPart);

            SendDlgItemMessage(hDlg, IDC_ABORT_PURGE_PROGRESS, PBM_SETRANGE,
                0, MAKELPARAM(0, dwCurrent));

            break;

        case WMAPP_UPDATESTATUS:
            if (lParam != NULL)
                SetDlgItemText(hDlg, IDC_PURGE_STATUS_TEXT, (LPTSTR)lParam);
            else
                SetDlgItemText(hDlg, IDC_PURGE_STATUS_TEXT, TEXT(""));
            break;

        case WMAPP_UPDATEPROGRESS:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
            {
                if (pcmi->cbProgressDivider.QuadPart != 0)
                    dwCurrent = (DWORD)((pcmi->cbTotalPurgedSoFar.QuadPart +
                        pcmi->cbCurrentClientPurgedSoFar.QuadPart) /
                        pcmi->cbProgressDivider.QuadPart);
                else
                    dwCurrent = (DWORD)(pcmi->cbTotalPurgedSoFar.QuadPart +
                        pcmi->cbCurrentClientPurgedSoFar.QuadPart);

                SendDlgItemMessage(hDlg, IDC_ABORT_PURGE_PROGRESS, PBM_SETPOS,
                    (WPARAM)dwCurrent, 0);
            }
            break;

        case WM_CLOSE:
        case WM_COMMAND:
            pcmi = (CleanupMgrInfo *)GetWindowLongPtr (hDlg, DWLP_USER);
            if (pcmi != NULL)
                pcmi->bAbortPurge = TRUE;
            break;

        default:
            return FALSE;
    }

    return TRUE;
}

void
PurgeAbortThread(
    CleanupMgrInfo *pcmi
    )
{
    if ((pcmi->hAbortPurgeWnd = CreateDialogParam(g_hInstance, MAKEINTRESOURCE(IDD_PURGE_ABORT),
        NULL, PurgeAbortDlgProc, (LPARAM)pcmi)) == NULL)
    {
        return;
    }   

    // Show the window (except when the /SETUP flag is specified)
    if (!(pcmi->dwUIFlags & FLAG_SETUP))
        ShowWindow(pcmi->hAbortPurgeWnd, SW_SHOW);

    // Make sure the HWND has been set before setting off the event
    PulseEvent(pcmi->hAbortPurgeEvent);

    //
    //Keep spinning till the Purge is stopped
    //
    while (!(pcmi->bAbortPurge))
    {
        MessagePump(pcmi->hAbortPurgeWnd);
    }

    //
    //Destroy the Abort Purge dialog
    //
    if (pcmi->hAbortPurgeWnd != NULL)
    {
        DestroyWindow(pcmi->hAbortPurgeWnd);
        pcmi->hAbortPurgeWnd = NULL;
    }
}
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\msprintf.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Manager
** File:    msprintf.h
**
** Purpose: various common stuff for this module
** Notes:   
** Mod Log: Created by Rich Jernigan (??/??)
**          Modified by Shawn Brown (2/95)
**			Modified by Jason Cobb (2/97)
**
** Copyright (c)1995 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef MSPRINTF_H
#define MSPRINTF_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#ifndef COMMON_H
   #include "common.h"
#endif

/*
**------------------------------------------------------------------------------
** Global Prototypes
**------------------------------------------------------------------------------
*/

TCHAR * cdecl SHFormatMessage( DWORD dwMessageId, ...);

#endif  // MSPRINTF_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by cleanmgr.rc
//

#define IDS_DETAILS                     19
#define IDS_TITLE                       20
#define IDS_DELETEWARNING               21
#define IDS_DISKCLEANUP                 22
#define IDS_MOREOPTIONS                 23
#define IDS_SYSTEM_RESTORE_MESSAGE      24
#define IDS_SETTINGS                    27
#define IDD_DISK_CLEANER                101
#define IDC_DESCRIPTION_GROUP           101
#define IDD_SCAN_ABORT                  102
#define ICON_CLEANMGR                   104
#define IDD_PURGE_ABORT                 106
#define IDD_COUNTDOWN_ABORT             109
#define IDD_MORE_OPTIONS                110
#define ICON_GENERIC                    111
#define ICON_SETUP                      113
#define IDD_SETTINGS                    115
#define IDD_SELDRIVE                    116
#define BMP_MINIICONS                   200
#define IDC_SELDRIVE_COMBO              999
#define IDC_CLIENT_LIST                 1000
#define IDC_INTRO_TEXT                  1001
#define IDC_DETAILS_BUTTON              1002
#define IDC_DESCRIPTION_TEXT            1003
#define IDC_ABORT_TEXT                  1005
#define IDC_ABORT_SCAN_PROGRESS         1006
#define IDC_DRIVE_ICON_LOCATION         1007
#define IDC_PURGE_TEXT                  1008
#define IDC_ABORT_PURGE_PROGRESS        1009
#define IDC_PURGE_DRIVE_TEXT            1010
#define IDC_PURGE_STATUS_TEXT           1011
#define IDC_SCAN_STATUS_TEXT            1012
#define IDC_COUNTDOWN_TEXT              1013
#define IDC_COUNTDOWN_PROGRESS          1014
#define IDC_COUNTDOWN_DRIVE_TEXT        1015
#define IDC_WINDOWS_SETUP_ICON          1016
#define IDC_WINDOWS_SETUP_GROUP         1017
#define IDC_WINDOWS_SETUP_TEXT          1018
#define IDC_WINDOWS_SETUP_BUTTON        1019
#define IDC_INSTALLED_PROGRAMS_ICON     1020
#define IDC_AUTO_LAUNCH                 1021
#define IDC_INSTALLED_PROGRAMS_GROUP    1022
#define IDC_SETTINGS_DRIVE_TEXT         1023
#define IDC_INSTALLED_PROGRAMS_TEXT     1024
#define IDC_INSTALLED_PROGRAMS_BUTTON   1025
#define IDC_TOTAL_SPACE_TEXT            1026
#define IDC_SYSTEM_RESTORE_GROUP        1027
#define IDC_SYSTEM_RESTORE_ICON         1028
#define IDC_SYSTEM_RESTORE_TEXT         1029
#define IDC_SYSTEM_RESTORE_BUTTON       1030
#define IDC_TOTAL_SPACE_DESCRIPTION     1031
#define IDC_FILES_TO_REMOVE_TEXT        1032
#define IDC_BACK_BUTTON                 1133
#define IDC_WIZBMP                      1134
#define IDC_SELDRIVE_TEXT               1135
#define IDC_SELDRIVE_TEXT2              1136
#define IDS_LOWDISK_CAPTION             1200
#define IDS_LOWDISK_MESSAGE             1201
#define IDS_VERYLOWDISK_MESSAGE         1202
#define IDS_LOWDISK_SUCCESS_CAPTION     1203
#define IDS_LOWDISK_SUCCESS_MESSAGE     1204
#define IDS_ADDREMOVE_TITLE             1205
#define IDS_LOWDISK_MESSAGE2            1206

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        117
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1037
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\textout.h ===
#ifndef TEXTOUT_H
#define TEXTOUT_H


/*
 * DEFINITIONS ________________________________________________________________
 *
 */

#ifdef UNICODE
#define szTextOutCLASS     TEXT("TextOutClassW")
#else
#define szTextOutCLASS     TEXT("TextOutClass")
#endif


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

         void     RegisterTextOutClass       (HINSTANCE);
         void     UnregisterTextOutClass     (void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\seldrive.h ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Manager
** File:    seldrive.h
**
** Purpose: Code that implements the "Select Drive" dialog
**
** Notes:   
** Mod Log: Created by Jason Cobb (12/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef SELDRIVE_H
#define SELDRIVE_H

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "diskutil.h"

// pszDrive in/out param
BOOL SelectDrive(LPTSTR pszDrive);

void GetBootDrive(PTCHAR pDrive, DWORD Size);
	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\seldrive.cpp ===
#include "common.h"
#include "seldrive.h"   
#include "msprintf.h"

#include <regstr.h>
#include <help.h>

const DWORD aSelDriveHelpIDs[]=
{
    IDC_SELDRIVE_COMBO,             IDH_CLEANMGR_SELDRIVE,
    IDOK,                           IDH_CLEANMGR_SELDRIVE_OK,
    IDCANCEL,                       IDH_CLEANMGR_SELDRIVE_EXIT,                   
    IDC_SELDRIVE_TEXT,              ((DWORD)-1),
    IDC_SELDRIVE_TEXT2,             ((DWORD)-1),
    0, 0
};

static struct
{
    drenum  dreDef;     // default drive to choose
    drenum  dreChose;   // drive selected at end of dialog
} dsd;


INT_PTR CALLBACK
SelectDriveProc(
	HWND hDlg,
	UINT Message,
	WPARAM wParam,
	LPARAM lParam
	);

BOOL
fillSelDriveList(
    HWND hDlg
    );

WPARAM
AddComboString(
    HWND hDlg, 
    int id, 
    TCHAR *psz, 
    DWORD val
    );

void 
SelectComboItem(
    HWND hDlg, 
    int id, 
    WPARAM w
    );

void 
SelectDriveDlgDrawItem(
    HWND hDlg, 
    DRAWITEMSTRUCT *lpdis, 
    BOOL bHighlightBackground    
    );


// TRUE if the user selected a drive, FALSE if a user selected Exit.
// If a user does select a drive then that drive is returned in the
// 
// in/out:
//      pszDrive

BOOL SelectDrive(LPTSTR pszDrive)
{
    drenum dre;

    GetDriveFromString(pszDrive, dre);

    dsd.dreDef  = dre;

    if (DialogBox(g_hInstance, MAKEINTRESOURCE(IDD_SELDRIVE), NULL, SelectDriveProc) != IDOK)
        return FALSE;

    CreateStringFromDrive(dsd.dreChose, pszDrive, 4);
    
    return TRUE;
}

INT_PTR CALLBACK SelectDriveProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
    switch (Message)
    {
        case WM_INITDIALOG:
            if (!fillSelDriveList (hDlg))
            {
                EndDialog (hDlg, IDCANCEL);
            }

            SetFocus(GetDlgItem(hDlg, IDC_SELDRIVE_COMBO));
            break;

        case WM_DESTROY:
            EndDialog (hDlg, IDCANCEL);
            break;

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, NULL,
                    HELP_WM_HELP, (DWORD_PTR)(LPTSTR)aSelDriveHelpIDs);
            return TRUE;

        case WM_CONTEXTMENU:
            WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
                    (DWORD_PTR)(LPVOID)aSelDriveHelpIDs);
            return TRUE;

        case WM_DRAWITEM:
            SelectDriveDlgDrawItem(hDlg, (DRAWITEMSTRUCT *)lParam, TRUE);
            break;

        case WM_COMMAND:
            switch(wParam)
            {
                case IDOK:
                    dsd.dreChose = (drenum)SendDlgItemMessage(hDlg, IDC_SELDRIVE_COMBO, CB_GETITEMDATA, 
                                  (WPARAM)SendDlgItemMessage(hDlg, IDC_SELDRIVE_COMBO, CB_GETCURSEL, 0, 0L), 0L);
                    //Fall through
                    
                case IDCANCEL:
                    EndDialog (hDlg, wParam);
                    break;
            }
            break;

        default:
            return FALSE;
        }

    return TRUE;
}

void SelectDriveDlgDrawItem(HWND hDlg, DRAWITEMSTRUCT *lpdis, BOOL bHighlightBackground)
{
    HDC             hdc = lpdis->hDC;
    TCHAR           szText[MAX_DESC_LEN*2];
    SIZE            size;
    drenum          dre;
    HICON           hIcon = NULL;
    DWORD       dwExStyle = 0L;
    UINT        fuETOOptions = 0;

    if ((int)lpdis->itemID < 0)
        return;

    SendMessage(lpdis->hwndItem, CB_GETLBTEXT, lpdis->itemID, (DWORD_PTR)(LPTSTR)szText);
    GetTextExtentPoint32(hdc, szText, lstrlen(szText), &size);
    dre = (drenum)SendMessage(lpdis->hwndItem, CB_GETITEMDATA, lpdis->itemID, 0);

    if (lpdis->itemAction != ODA_FOCUS)
    {
        int clrBackground = COLOR_WINDOW;
        int clrText = COLOR_WINDOWTEXT;
        if (bHighlightBackground && lpdis->itemState & ODS_SELECTED) {
            clrBackground = COLOR_HIGHLIGHT;
            clrText = COLOR_HIGHLIGHTTEXT;
        }

        //
        //For multiple selection, we don't want to draw items as
        //selected.  Just focus rect below.
        //
        SetBkColor(hdc, GetSysColor(clrBackground));
        SetTextColor(hdc, GetSysColor(clrText));

        //
        //Fill in the background; do this before mini-icon is drawn
        //
        ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &(lpdis->rcItem), NULL, 0, NULL);

        //
        //Draw mini-icon for this item and move string accordingly
        //
        if ((hIcon = GetDriveIcon(dre, TRUE)) != NULL)
        {
            DrawIconEx(lpdis->hDC, lpdis->rcItem.left, lpdis->rcItem.top, hIcon,
                       16, 16, 0, NULL, DI_NORMAL);
            lpdis->rcItem.left += 16;
        }

        lpdis->rcItem.left += INDENT;

        //
        //Draw the cleanup client display name text transparently on top of the background
        //
        SetBkMode(hdc, TRANSPARENT);
        dwExStyle = GetWindowLong(hDlg, GWL_EXSTYLE);
        if(dwExStyle & WS_EX_RTLREADING)
        {
           fuETOOptions |= ETO_RTLREADING; 
        }        
        ExtTextOut(hdc, lpdis->rcItem.left, lpdis->rcItem.top +
                   ((lpdis->rcItem.bottom - lpdis->rcItem.top) - size.cy) / 2,
                   fuETOOptions, NULL, szText, lstrlen(szText), NULL);
    }

    if (lpdis->itemAction == ODA_FOCUS || (lpdis->itemState & ODS_FOCUS))
        DrawFocusRect(hdc, &(lpdis->rcItem));
}

BOOL fillSelDriveList(HWND hDlg)
{
    BOOL      bDoDrive[Drive_Z+1];
    int       dre;
    hardware  hw;
    WPARAM    dw;
    WPARAM    dwSelected = 0;
    USHORT    nFound = 0;
    drenum    dreSelected = Drive_INV;
    TCHAR pszText[cbRESOURCE];
    int cDrv = 0;

    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        bDoDrive[dre] = FALSE;
    }

    //
    //First, figger out what drives to hit.
    //
    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        // hw id evil by ref param
        GetHardwareType((drenum)dre, hw);
        switch (hw)
        {
        case hwFixed:
            cDrv += 1;
            bDoDrive[dre] = TRUE;
            break;
        }
    }

    for (dre = (int)Drive_A; dre <= (int)Drive_Z; dre++)
    {
        if (!bDoDrive[dre])
            continue;

        GetDriveDescription((drenum)dre, pszText, ARRAYSIZE(pszText));
        dw = AddComboString(hDlg, IDC_SELDRIVE_COMBO, pszText, (DWORD)dre);
        nFound++;
        
        if (dsd.dreDef == (drenum)dre ||
            dreSelected == Drive_INV ||
            (dreSelected < Drive_C && dsd.dreDef == Drive_ALL) ||
            (dreSelected < Drive_C && dsd.dreDef == Drive_INV) )
        {
            dwSelected = dw;
            dreSelected = (drenum)dre;
        }
    }

    //
    //Found some drives? Pick one, and leave.
    //
    if (nFound != 0)
    {
        SelectComboItem(hDlg, IDC_SELDRIVE_COMBO, dwSelected);
        dsd.dreDef = dreSelected;
        // if only one drive in the list simulate OK press
        if (cDrv == 1)
            PostMessage(hDlg, WM_COMMAND, IDOK, 0);
        return TRUE;
    }

    return FALSE;
}

void SelectComboItem(HWND hDlg, int id, WPARAM w)
{
   LPARAM lParam = MAKELONG((WORD)GetDlgItem(hDlg,id), (WORD)CBN_SELCHANGE );
   SendDlgItemMessage(hDlg, id, CB_SETCURSEL, w, 0L);
   SendMessage(hDlg, WM_COMMAND, id, lParam);
}

WPARAM AddComboString(HWND hDlg, int id, TCHAR *psz, DWORD val)
{
   WPARAM dw = SendDlgItemMessage(hDlg, id, CB_ADDSTRING, 0, (LPARAM)psz);
   SendDlgItemMessage(hDlg, id, CB_SETITEMDATA, dw, (LPARAM)val);

   return dw;
}

void GetBootDrive(PTCHAR pDrive, DWORD Size)
{
    HKEY	hKey;
    DWORD	cbSize, dwType;
    
    pDrive[0] = '\0';
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP_SETUP, 0, KEY_READ, &hKey) == ERROR_SUCCESS)
    {
        cbSize = Size;
        dwType = REG_SZ;
        if (RegQueryValueEx(hKey, REGSTR_VAL_BOOTDIR, NULL, &dwType, (LPBYTE)pDrive, &cbSize) == ERROR_SUCCESS)
        {
            RegCloseKey(hKey);
        }
        else
        {
            pDrive[0] = '\0';
        }
    }
    
    if (pDrive[0] == '\0')
    {
        StringCbCopy(pDrive, Size, SZ_DEFAULT_DRIVE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\sources.inc ===
CCSHELL_DIR=$(PROJECT_ROOT)

!include $(CCSHELL_DIR)\common.inc
SOURCES_USED=$(CCSHELL_DIR)\common.inc

INCLUDES=$(CCSHELL_DIR)\inc\win95;$(INCLUDES)

# make sure that the .mc file puts its output in $O
PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)

USE_MSVCRT=1

TARGETNAME=cleanmgr
TARGETPATH=obj
TARGETTYPE=PROGRAM

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(CCSHELL_DIR)\lib\$O\shguid.lib  \
                  $(CCSHELL_DIR)\lib\$O\shguidp.lib \
                  $(SHELL_LIB_PATH)\shlwapip.lib    \
                  $(SHELL_LIB_PATH)\comctlp.lib     \
                  $(SHELL_LIB_PATH)\shell32p.lib    \
                  $(TARGETLIBS)

SOURCES     = ..\cleanmgr.rc \
              ..\cmstrings.mc \
              ..\cleanmgr.cpp \
              ..\dmgrdlg.cpp \
              ..\dmgrinfo.cpp \
              ..\diskutil.cpp \
              ..\msprintf.cpp \
              ..\callback.cpp \
              ..\seldrive.cpp \
              ..\midebug.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\common.h

#!if $(386)
#UMENTRYABS      = ModuleEntry@0
#!else
#UMENTRYABS      = ModuleEntry
#!endif

# 
# Fusionized
# 
SXS_ASSEMBLY_NAME=Microsoft.Windows.Shell.CleanMgr
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=CleanMgr.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\cleanmgr\textout.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Cleanup Applet
** File:    textout.cpp
**
** Purpose: Print functions
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"
#include "textout.h"


/*
 * DEFINITIONS ________________________________________________________________
 *
 */

         typedef struct
            {
            HWND     hWnd;
            LONG     style;
            TCHAR    *pszText;	   // Buffer for text
            size_t   cbMaxText;	// Length of text buffer
            HFONT    hf;	      // Current font
            HBITMAP  bmp;	      // Off-screen bitmap for NO FLICKER
            RECT     rBmp;	      // Size of 'bmp'
            } TextOutInfo;


/*
 * VARIABLES __________________________________________________________________
 *
 */

         static HINSTANCE     l_hInst = NULL;


/*
 * PROTOTYPES _________________________________________________________________
 *
 */

         LRESULT APIENTRY TextOutProc         (HWND, UINT, WPARAM, LPARAM);

         void             TextOutPaint        (TextOutInfo *, HDC, RECT *);

         BOOL             TextOutMakeBitmap   (TextOutInfo *);
         BOOL             TextOutSetText      (TextOutInfo *, LPCTSTR);
         void             TextOutRedraw       (TextOutInfo *, BOOL = TRUE);


/*
 * ROUTINES ___________________________________________________________________
 *
 */
/*
void RegisterTextOutClass (HINSTANCE hInst)
{
   WNDCLASS  wc;

   if (hInst == NULL)
      return;

   l_hInst = hInst;
   

   wc.style = 0;
   wc.lpfnWndProc    = TextOutProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = sizeof (void *);
   wc.hInstance      = hInst;
   wc.hIcon          = NULL;
   wc.hCursor        = LoadCursor (NULL, IDC_ARROW);
   wc.hbrBackground  = NULL;
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = szTextOutCLASS;

   RegisterClass (&wc);
}


void UnregisterTextOutClass (void)
{
	   //	Unregister from windows
   if (l_hInst)
      UnregisterClass (szTextOutCLASS, l_hInst);
   l_hInst = NULL;
}


LRESULT APIENTRY TextOutProc (HWND hWnd, UINT msg, WPARAM wp, LPARAM lp)
{
   TextOutInfo   *ptoi;
   PAINTSTRUCT    ps;
   HDC            hdc;

   if (msg == WM_CREATE)
      {
      if ((ptoi = (TextOutInfo *)GlobalAlloc (GMEM_FIXED, sizeof(*ptoi))) == 0)
         {
         //OutOfMemory();
         return -1;
         }
      SetWindowLongPtr (hWnd, 0, (LPARAM)ptoi);

      ptoi->hWnd        = hWnd;
      ptoi->style       = ((LPCREATESTRUCT)lp)->style;
      ptoi->pszText     = NULL;
      ptoi->cbMaxText   = 0;
      ptoi->hf          = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
      ptoi->bmp         = NULL;

      if (!TextOutMakeBitmap (ptoi))
         return -1;

      if (!TextOutSetText (ptoi, ((LPCREATESTRUCT)lp)->lpszName ))
         return -1;

      TextOutRedraw (ptoi);
      }
   else if ((ptoi = (TextOutInfo *)GetWindowLongPtr (hWnd, 0)) == NULL)
      {
      return DefWindowProc (hWnd, msg, wp, lp);
      }


   switch (msg)
      {
      case WM_DESTROY:  if (ptoi->pszText != NULL)
                           GlobalFree (ptoi->pszText);
                        if (ptoi->bmp != NULL)
                           DeleteObject (ptoi->bmp);
                        GlobalFree (ptoi);
                        SetWindowLongPtr (hWnd, 0, 0L);
                       break;

      case WM_USER:     TextOutRedraw (ptoi, FALSE);
                       break;

      case WM_PAINT:    hdc = BeginPaint (hWnd, &ps);
                        TextOutPaint (ptoi, hdc, &ps.rcPaint);
                        EndPaint (hWnd, &ps);
                        return 0;
                       break;

      case WM_SETTEXT:  TextOutSetText (ptoi, (LPCTSTR)lp);
                        TextOutRedraw (ptoi);
                       break;

      case WM_GETFONT:  return (LRESULT)ptoi->hf;
                       break;

      case WM_SETFONT:  if ((ptoi->hf = (HFONT)wp) == NULL)
                           {
                           ptoi->hf = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
                           }
                        if (LOWORD(lp) != 0)
                           {
                           TextOutRedraw (ptoi);
                           }
                       break;

      case WM_SIZE:     TextOutMakeBitmap (ptoi);
                       break;

      case WM_ERASEBKGND:
                        return (LRESULT)1;
                       break;
      }

   return DefWindowProc (hWnd, msg, wp, lp);
}


void TextOutPaint (TextOutInfo *ptoi, HDC hdcTrg, RECT *pr)
{
   RECT     r;
   HDC      hdcSrc;
   HBITMAP  bmpSrc;


   if (ptoi->bmp == NULL)	// No bitmap?
      return;	// No paint.

   if (pr == NULL)
      {
      GetClientRect (ptoi->hWnd, pr = &r);
      }

   hdcSrc = CreateCompatibleDC (hdcTrg);
   bmpSrc = (HBITMAP) SelectObject (hdcSrc, (HGDIOBJ)ptoi->bmp);

   BitBlt (hdcTrg, pr->left, pr->top, pr->right -pr->left, pr->bottom -pr->top,
           hdcSrc, pr->left, pr->top, SRCCOPY);

   SelectObject (hdcSrc, (HGDIOBJ)bmpSrc);
   DeleteDC (hdcSrc);
}


BOOL TextOutMakeBitmap (TextOutInfo *ptoi)
{
   HDC      hdc, hdcMem;
   RECT     r;

   GetClientRect (ptoi->hWnd, &r);

   if (ptoi->bmp != NULL)
      {
      if ( ((ptoi->rBmp.right - ptoi->rBmp.left) > (r.right - r.left)) ||
           ((ptoi->rBmp.bottom - ptoi->rBmp.top) > (r.bottom - r.top)) )
         {
         DeleteObject (ptoi->bmp);
         ptoi->bmp = NULL;
         }
      }

   if (ptoi->bmp == NULL)
      {
      hdc = GetDC (ptoi->hWnd);
      hdcMem = CreateCompatibleDC (hdc);

      ptoi->bmp = CreateCompatibleBitmap (hdc, r.right, r.bottom);
      ptoi->rBmp = r;

      DeleteDC (hdcMem);
      ReleaseDC (ptoi->hWnd, hdc);
      }

   if (ptoi->bmp == NULL)
      {
      //OutOfMemory();
      return FALSE;
      }

   return TRUE;
}


BOOL TextOutSetText (TextOutInfo *ptoi, LPCTSTR psz)
{
   size_t  cb;

   if (psz == NULL)
      {
      if (ptoi->pszText != NULL)
         ptoi->pszText[0] = 0;
      return TRUE;
      }

   cb = 1+ lstrlen(psz);
   if (cb > (ptoi->cbMaxText))
      {
      if (ptoi->pszText != NULL)
         {
         GlobalFree (ptoi->pszText);
         ptoi->pszText = NULL;
         }

      if ((ptoi->pszText = (TCHAR *)GlobalAlloc (GMEM_FIXED, cb * sizeof( TCHAR ))) == NULL)
         {
         ptoi->cbMaxText = 0;
         //OutOfMemory();
         return FALSE;
         }

      ptoi->cbMaxText = cb;
      }

   StrCpy(ptoi->pszText, psz);
   return TRUE;
}


void TextOutRedraw (TextOutInfo *ptoi, BOOL fRepaint)
{
   HBRUSH   hbr;
   HDC      hdc, hdcMem;
   HBITMAP  bmpOld;
   RECT     r;
   WPARAM   wp;
   LPARAM   lp;
   HFONT    hfOld = NULL;

   if (ptoi->bmp == NULL)
      return;

   hdc = GetDC (ptoi->hWnd);
   hdcMem = CreateCompatibleDC (hdc);
   bmpOld = (HBITMAP) SelectObject (hdcMem, (HGDIOBJ)ptoi->bmp);

   wp = (WPARAM)hdcMem;
   lp = (LPARAM)ptoi->hWnd;
   hbr = (HBRUSH)SendMessage (GetParent(ptoi->hWnd), WM_CTLCOLORSTATIC, wp,lp);

   if (hbr == NULL)
      {
      SetTextColor (hdc, GetSysColor (COLOR_BTNTEXT));
      SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));
      hbr = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));
      }


   GetClientRect (ptoi->hWnd, &r);
   FillRect (hdcMem, &r, hbr);

   if (ptoi->pszText != NULL)
      {
      if (ptoi->hf != NULL)
         hfOld = (HFONT) SelectObject (hdcMem, ptoi->hf);

      UINT fDrawFlags = DT_EXPANDTABS |  DT_WORDBREAK;
      if (ptoi->style & SS_RIGHT)
         fDrawFlags |= DT_RIGHT;
      else if (ptoi->style & SS_CENTER)
         fDrawFlags |= DT_CENTER;
      else
         fDrawFlags |= DT_LEFT;

      DrawText (  hdcMem,
                  ptoi->pszText,
                  lstrlen(ptoi->pszText),
                  &r,
                  fDrawFlags ); 
       
      if (hfOld != NULL)
         SelectObject (hdcMem, hfOld);
      }


   DeleteObject (hbr);

   SelectObject (hdcMem, bmpOld);
   DeleteDC (hdcMem);
   ReleaseDC (ptoi->hWnd, hdc);

   if (fRepaint)
      {
      InvalidateRect (ptoi->hWnd, NULL, TRUE);
      UpdateWindow (ptoi->hWnd);
      }
}
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\common.h ===
#ifndef COMMON_H
#define COMMON_H

#define STRICT

#include <windows.h>
#include <windowsx.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <strsafe.h>

#define DDEVCF_DOSUBDIRS            0x00000001 	// recursively search/remove 
#define DDEVCF_REMOVEAFTERCLEAN     0x00000002 	// remove from the registry after run once
#define DDEVCF_REMOVEREADONLY       0x00000004  // remove file even if it is read-only
#define DDEVCF_REMOVESYSTEM         0x00000008  // remove file even if it is system
#define DDEVCF_REMOVEHIDDEN         0x00000010  // remove file even if it is hidden
#define DDEVCF_DONTSHOWIFZERO       0x00000020  // don't show this cleaner if it has nothing to clean
#define DDEVCF_REMOVEDIRS           0x00000040  // Match filelist against directories and remove everything under them.
#define DDEVCF_RUNIFOUTOFDISKSPACE  0x00000080  // Only run if machine is out of disk space.
#define DDEVCF_REMOVEPARENTDIR      0x00000100  // remove the parent directory once done.
#define DDEVCF_PRIVATE_LASTACCESS   0x10000000  // use LastAccessTime

#define FILETIME_HOUR_HIGH          0x000000C9  // High DWORD for a FILETIME hour
#define FILETIME_HOUR_LOW           0x2A69C000  // Low DWORD for a FILETIME hour

#define CLSID_STRING_SIZE           39
#define DESCRIPTION_LENGTH          512
#define BUTTONTEXT_LENGTH           50
#define DISPLAYNAME_LENGTH          128
#define ARRAYSIZE(x)                (sizeof(x)/sizeof(x[0]))

#define REGSTR_VAL_BITMAPDISPLAY                TEXT("BitmapDisplay")
#define REGSTR_VAL_URL                          TEXT("URL")
#define REGSTR_VAL_FOLDER                       TEXT("folder")
#define REGSTR_VAL_CSIDL                        TEXT("CSIDL")
#define REGSTR_VAL_FILELIST                     TEXT("FileList")
#define REGSTR_VAL_LASTACCESS                   TEXT("LastAccess")
#define REGSTR_VAL_FLAGS                        TEXT("Flags")           // DDEVCF_ flags
#define REGSTR_VAL_CLEANUPSTRING                TEXT("CleanupString")
#define REGSTR_VAL_FAILIFPROCESSRUNNING         TEXT("FailIfProcessRunning")
#define REGSTR_PATH_SETUP_SETUP                 TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup")

typedef struct tag_CleanFileStruct
{
    TCHAR           file[MAX_PATH];
    ULARGE_INTEGER  ulFileSize;
    BOOL            bSelected;
    BOOL            bDirectory;
    struct tag_CleanFileStruct    *pNext;
} CLEANFILESTRUCT, *PCLEANFILESTRUCT;

#ifdef _DEBUG
   #define DEBUG
#endif

#ifdef DEBUG
#define MI_TRAP                     _asm int 3

void
DebugPrint(
    HRESULT hr,
    LPCTSTR  lpFormat,
    ...
    );

#define MiDebugMsg( args )          DebugPrint args

#else

#define MI_TRAP
#define MiDebugMsg( args )

#endif // DEBUG

#endif // COMMON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\compclen.cpp ===
#include "common.h"

#include <emptyvc.h>

#ifndef COMPCLEN_H
#include "compclen.h"
#endif

#include <regstr.h>
#include <olectl.h>
#include <tlhelp32.h>


#ifndef RESOURCE_H
#include "resource.h"
#endif

#ifdef DEBUG
#include <stdio.h>
#endif // DEBUG

BOOL g_bSettingsChange = FALSE;

const LPCTSTR g_NoCompressFiles[] = 
{ 
    TEXT("NTLDR"),
    TEXT("OSLOADER.EXE"),
    TEXT("PAGEFILE.SYS"),
    TEXT("NTDETECT.COM"),
    TEXT("EXPLORER.EXE"),
};

LPCTSTR g_NoCompressExts[] = 
{ 
    TEXT(".PAL") 
};

extern HINSTANCE g_hDllModule;

extern UINT incDllObjectCount(void);
extern UINT decDllObjectCount(void);

CCompCleanerClassFactory::CCompCleanerClassFactory() : m_cRef(1)
{
    incDllObjectCount();
}

CCompCleanerClassFactory::~CCompCleanerClassFactory()                                                
{
    decDllObjectCount();
}

STDMETHODIMP CCompCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}           

STDMETHODIMP_(ULONG) CCompCleanerClassFactory::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCompCleanerClassFactory::Release()
{
    if (--m_cRef)
        return m_cRef;
    
    delete this;
    return 0;
}

STDMETHODIMP CCompCleanerClassFactory::CreateInstance(IUnknown * pUnkOuter, REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    
    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }
    
    HRESULT hr;
    CCompCleaner *pCompCleaner = new CCompCleaner();  
    if (pCompCleaner)
    {
        hr = pCompCleaner->QueryInterface (riid, ppvObj);
        pCompCleaner->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    return hr;          
}

STDMETHODIMP CCompCleanerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        incDllObjectCount();
    else
        decDllObjectCount();
    
    return S_OK;
}

CCompCleaner::CCompCleaner() : m_cRef(1)
{
    cbSpaceUsed.QuadPart = 0;
    cbSpaceFreed.QuadPart = 0;
    szVolume[0] = 0;
    szFolder[0] = 0;

    incDllObjectCount();
}

CCompCleaner::~CCompCleaner()
{
    // Free the list of directories
    FreeList(head);
    head = NULL;

    decDllObjectCount();
}

STDMETHODIMP CCompCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppv = (IEmptyVolumeCache2*) this;
        AddRef();
        return S_OK;
    }  

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CCompCleaner::AddRef()
{
    return ++m_cRef;
}

STDMETHODIMP_(ULONG) CCompCleaner::Release()
{
    if (--m_cRef)
        return m_cRef;
    
    delete this;
    return 0;
}

// Initializes the Compression Cleaner and returns flags to the cache manager

STDMETHODIMP CCompCleaner::Initialize(HKEY hRegKey,
                                      LPCWSTR pszVolume,
                                      LPWSTR  *ppwszDisplayName,
                                      LPWSTR  *ppwszDescription,
                                      DWORD   *pdwFlags)
{
    TCHAR szFileSystemName[MAX_PATH];
    DWORD fFileSystemFlags;
    
    bPurged = FALSE;
    
    //
    // Allocate memory for the DisplayName string and load the string.
    // If the allocation fails, then we will return NULL which will cause
    // cleanmgr.exe to read the name from the registry.
    //
    if (*ppwszDisplayName = (LPWSTR)CoTaskMemAlloc(DISPLAYNAME_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_DISP, *ppwszDisplayName, DISPLAYNAME_LENGTH);
    }
    
    //
    // Allocate memory for the Description string and load the string.
    // If the allocation fails, then we will return NULL which will cause
    // cleanmgr.exe to read the description from the registry.
    //
    if (*ppwszDescription = (LPWSTR)CoTaskMemAlloc(DESCRIPTION_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_DESC, *ppwszDescription, DESCRIPTION_LENGTH);
    }
    
    //
    //If you want your cleaner to run only when the machine is dangerously low on
    //disk space then return S_FALSE unless the EVCF_OUTOFDISKSPACE flag is set.
    //
    //if (!(*pdwFlags & EVCF_OUTOFDISKSPACE))
    //{
    //          return S_FALSE;
    //}
    
    if (*pdwFlags & EVCF_SETTINGSMODE)
    {
        bSettingsMode = TRUE;
    }
    else 
    {
        bSettingsMode = FALSE;
    }
    
    //Tell the cache manager to disable this item by default
    *pdwFlags = 0;
    
    //Tell the Disk Cleanup Manager that we have a Settings button
    *pdwFlags |= EVCF_HASSETTINGS;
    
    // If we're in Settings mode no need to do all this other work
    //
    if (bSettingsMode) 
        return S_OK;
        
    ftMinLastAccessTime.dwLowDateTime = 0;
    ftMinLastAccessTime.dwHighDateTime = 0;
    
    if (GetVolumeInformation(pszVolume, NULL, 0, NULL, NULL, &fFileSystemFlags, szFileSystemName, MAX_PATH) &&
        (0 == lstrcmp(szFileSystemName, TEXT("NTFS"))) &&
        (fFileSystemFlags & FS_FILE_COMPRESSION))
    {
        StringCchCopy(szFolder, ARRAYSIZE(szFolder), pszVolume);
    
        // Calculate the last access date filetime
        CalcLADFileTime();
        return S_OK;
    }
    return S_FALSE;
}

STDMETHODIMP CCompCleaner::InitializeEx(HKEY hRegKey, LPCWSTR pcwszVolume, LPCWSTR pcwszKeyName,
                                        LPWSTR *ppwszDisplayName, LPWSTR *ppwszDescription,
                                        LPWSTR *ppwszBtnText, DWORD *pdwFlags)
{
    // Allocate memory for the ButtonText string and load the string.
    // If we can't allocate the memory, leave the pointer NULL.

    if (*ppwszBtnText = (LPWSTR)CoTaskMemAlloc(BUTTONTEXT_LENGTH * sizeof(WCHAR)))
    {
        LoadString(g_hDllModule, IDS_COMPCLEANER_BUTTON, *ppwszBtnText, BUTTONTEXT_LENGTH);
    }
    
    //
    // Now let the IEmptyVolumeCache version 1 Init function do the rest
    //
    return Initialize(hRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
}

// Returns the total amount of space that the compression cleaner can free.

STDMETHODIMP CCompCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    cbSpaceUsed.QuadPart  = 0;

    WalkFileSystem(picb, FALSE);
    
    picb->ScanProgress(cbSpaceUsed.QuadPart, EVCCBF_LASTNOTIFICATION, NULL);
    
    *pdwSpaceUsed = cbSpaceUsed.QuadPart;
    
    return S_OK;
}

// does the compression

STDMETHODIMP CCompCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    bPurged = TRUE;
    
    // Compress the files
    WalkFileSystem(picb, TRUE);
    
    // Send the last notification to the cleanup manager
    picb->PurgeProgress(cbSpaceFreed.QuadPart, (cbSpaceUsed.QuadPart - cbSpaceFreed.QuadPart), EVCCBF_LASTNOTIFICATION, NULL);
    
    return S_OK;
}

/*
** Dialog box that displays all of the files that will be compressed by this cleaner.
**
** NOTE:  Per the specification for the Compression Cleaner we are not
**                providing the view files functionality.  However, I will leave
**                the framework in place just in case we want to use it.
*/
INT_PTR CALLBACK ViewFilesDlgProc(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HWND hwndList;
    LV_ITEM lviItem;
    CLEANFILESTRUCT *pCleanFile;
    
    switch (Msg) 
    {
    case WM_INITDIALOG:
        hwndList = GetDlgItem(hDlg, IDC_COMP_LIST);
        pCleanFile = (CLEANFILESTRUCT *)lParam;
        
        ListView_DeleteAllItems(hwndList);
        
        while (pCleanFile) 
        {
            lviItem.mask = LVIF_TEXT | LVIF_IMAGE;
            lviItem.iSubItem = 0;
            lviItem.iItem = 0;
            
            //
            //Only show files
            //
            if (!pCleanFile->bDirectory) 
            {
                lviItem.pszText = pCleanFile->file;
                ListView_InsertItem(hwndList, &lviItem);
            }
            
            pCleanFile = pCleanFile->pNext;
            lviItem.iItem++;
        }
        
        break;
        
    case WM_COMMAND:
        
        switch (LOWORD(wParam)) 
        {
        case IDOK:
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}

// Dialog box that displays the settings for this cleaner.

INT_PTR CALLBACK SettingsDlgProc(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam)
{
    HKEY hCompClenReg;                          // Handle to our registry path
    DWORD dwDisposition;                        // stuff for the reg calls
    DWORD dwByteCount;                          // Ditto
    DWORD dwNumDays = DEFAULT_DAYS; // Number of days setting from registry
    static UINT DaysIn;                         // Number of days initial setting
    UINT DaysOut;                                   // Number of days final setting
#ifdef DEBUG
    static CLEANFILESTRUCT *pCleanFile; // Pointer to our file list
#endif // DEBUG
    
    switch(Msg) {
        
    case WM_INITDIALOG:
        
#ifdef DEBUG
        pCleanFile = (CLEANFILESTRUCT *)lParam;
#endif // DEBUG
        //
        // Set the range for the Days spin control (1 to 500)
        //
        SendDlgItemMessage(hDlg, IDC_COMP_SPIN, UDM_SETRANGE, 0, (LPARAM) MAKELONG ((short) MAX_DAYS, (short) MIN_DAYS));
        
        //
        // Get the current user setting for # days and init
        // the spin control edit box
        //
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, COMPCLN_REGPATH,
            0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ, NULL,
            &hCompClenReg, &dwDisposition))
        {
            dwByteCount = sizeof(dwNumDays);
            
            if (ERROR_SUCCESS == RegQueryValueEx(hCompClenReg,
                TEXT("Days"), NULL, NULL, (LPBYTE) &dwNumDays, &dwByteCount))
            {
                //
                // Got day count from registry, make sure it's
                // not too big or too small.
                //
                if (dwNumDays > MAX_DAYS) dwNumDays = MAX_DAYS;
                if (dwNumDays < MIN_DAYS) dwNumDays = MIN_DAYS;
                
                SetDlgItemInt(hDlg, IDC_COMP_EDIT, dwNumDays, FALSE);
            }
            else
            {
                //
                // Failed to get the day count from the registry
                // so just use the default.
                //
                
                SetDlgItemInt(hDlg, IDC_COMP_EDIT, DEFAULT_DAYS, FALSE);
            }
        }
        else
        {
            //
            // Failed to get the day count from the registry
            // so just use the default.
            //
            
            SetDlgItemInt(hDlg, IDC_COMP_EDIT, DEFAULT_DAYS, FALSE);
        }
        
        RegCloseKey(hCompClenReg);
        
        // Track the initial setting so we can figure out
        // if the user has changed the setting on the way
        // out.
        
        DaysIn = GetDlgItemInt(hDlg, IDC_COMP_EDIT, NULL, FALSE);
        
        break;
        
    case WM_COMMAND:
        
        switch (LOWORD(wParam)) 
        {
#ifdef DEBUG
        case IDC_VIEW:
            DialogBoxParam(g_hDllModule, MAKEINTRESOURCE(IDD_COMP_VIEW), hDlg, ViewFilesDlgProc, (LPARAM)pCleanFile);
            break;
#endif // DEBUG
            
        case IDOK:
            
            //
            // Get the current spin control value and write the
            // setting to the registry.
            //
            
            DaysOut = GetDlgItemInt(hDlg, IDC_COMP_EDIT, NULL, FALSE);
            
            if (DaysOut > MAX_DAYS) DaysOut = MAX_DAYS;
            if (DaysOut < MIN_DAYS) DaysOut = MIN_DAYS;
            
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                COMPCLN_REGPATH,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_WRITE,
                NULL,
                &hCompClenReg,
                &dwDisposition))
            {
                dwNumDays = (DWORD)DaysOut;
                RegSetValueEx(hCompClenReg,
                    TEXT("Days"),
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwNumDays,
                    sizeof(dwNumDays));
                
                RegCloseKey(hCompClenReg);
            }
            
            // Don't care if this failed -- what can we
            // do about it anyway...
            
            // If the user has changed the setting we need
            // to recalculate the list of files.
            
            if (DaysIn != DaysOut)
            {
                g_bSettingsChange = TRUE;   
            }
            
            // Fall thru to IDCANCEL
            
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        }
        break;
        
    default:
        return FALSE;
    }
    
    return TRUE;
}

STDMETHODIMP CCompCleaner::ShowProperties(HWND hwnd)
{
    g_bSettingsChange = FALSE;
    
    DialogBoxParam(g_hDllModule, MAKEINTRESOURCE(IDD_COMP_SETTINGS), hwnd, SettingsDlgProc, (LPARAM)head);
    
    //
    // If the settings have changed we need to recalculate the
    // LAD Filetime.
    //
    if (g_bSettingsChange)
    {
        CalcLADFileTime();
        return S_OK;                // Tell CleanMgr that settings have changed.
    }
    else
    {
        return S_FALSE;         // Tell CleanMgr no settings changed.
    }
    
    return S_OK; // Shouldn't hit this but just in case.
}

// Deactivates the cleaner...this basically does nothing.

STDMETHODIMP CCompCleaner::Deactivate(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return S_OK;
}

/*
** checks if the file is a specified number of days
** old. If the file has not been accessed in the
** specified number of days then it can safely be
** deleted.  If the file has been accessed in that
** number of days then the file will not be deleted.
**
** Notes;
** Mod Log:         Created by Jason Cobb (7/97)
**                          Adapted for Compression Cleaner by DSchott (6/98)
*/
BOOL CCompCleaner::LastAccessisOK(FILETIME ftFileLastAccess)
{
    //Is the last access FILETIME for this file less than the current
    //FILETIME minus the number of specified days?
    return (CompareFileTime(&ftFileLastAccess, &ftMinLastAccessTime) == -1);
}

// This function checks if the file is in the g_NoCompressFiles file list.
//  If it is, returns TRUE, else FALSE.

BOOL IsDontCompressFile(LPCTSTR lpFullPath)
{
    LPCTSTR lpFile = PathFindFileName(lpFullPath);
    if (lpFile)
    {
        for (int i = 0; i < ARRAYSIZE(g_NoCompressFiles); i++)
        {
            if (!lstrcmpi(lpFile, g_NoCompressFiles[i]))
            {
                MiDebugMsg((0, TEXT("File is in No Compress list: %s"), lpFile));
                return TRUE;
            }
        }
        LPCTSTR lpExt = PathFindExtension(lpFile);
        if (lpExt)
        {
            for (int i = 0; i < ARRAYSIZE(g_NoCompressExts); i++)
            {
                if (!lstrcmpi(lpExt, g_NoCompressExts[i]))
                {
                    MiDebugMsg((0, TEXT("File has No Compress extension: %s"), lpFile));
                    return TRUE;
                }
            }
        }
    }
    return FALSE;   // If we made it here the file must be OK to compress.
}


/*
** checks if a file is open by doing a CreateFile
** with fdwShareMode of 0.  If GetLastError() retuns
** ERROR_SHARING_VIOLATION then this function retuns TRUE because
** someone has the file open.  Otherwise this function retuns false.
**
** Notes;
** Mod Log:     Created by Jason Cobb (7/97)
**              Adapted for Compression Cleaner by DSchott (6/98)
**------------------------------------------------------------------------------
*/
BOOL IsFileOpen(LPTSTR lpFile, DWORD dwAttributes, FILETIME *lpftFileLastAccess)
{
    BOOL bRet = FALSE;
#if 0
    // Need to see if we can open file with WRITE access -- if we
    // can't we can't compress it.  Of course if the file has R/O
    // attribute then we won't be able to open for WRITE.  So,
    // we need to remove the R/O attribute long enough to try
    // opening the file then restore the original attributes.
    
    if (dwAttributes & FILE_ATTRIBUTE_READONLY)
    {
        SetFileAttributes(lpFile, FILE_ATTRIBUTE_NORMAL);
    }
    
    SetLastError(0);
    
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL, NULL);
    
    if (INVALID_HANDLE_VALUE == hFile)
    {
        DWORD dwResult = GetLastError();
        
        if ((ERROR_SHARING_VIOLATION == dwResult) || (ERROR_ACCESS_DENIED == dwResult))
        {
            bRet = TRUE;
        }
    }
    else
    {
        SetFileTime(hFile, NULL, lpftFileLastAccess, NULL);
        CloseHandle(hFile);
    }

    if (dwAttributes & FILE_ATTRIBUTE_READONLY) 
        SetFileAttributes(lpFile, dwAttributes);

#endif
    return bRet;
}

/*
**
** Purpose:     This function provides a common entry point for
**              searching for files to compress and then compressing them
**
** Notes;
** Mod Log:     Created by Bret Anderson (1/01)
**
**------------------------------------------------------------------------------
*/
void CCompCleaner::WalkFileSystem(IEmptyVolumeCacheCallBack *picb, BOOL bCompress)
{
    MiDebugMsg((0, TEXT("CCompCleaner::WalkFileSystem")));
    
    cbSpaceUsed.QuadPart = 0;
    
    if (!bCompress)
    {
        //
        //Walk all of the folders in the folders list scanning for disk space.
        //
        for (LPTSTR lpSingleFolder = szFolder; *lpSingleFolder; lpSingleFolder += lstrlen(lpSingleFolder) + 1)
            WalkForUsedSpace(lpSingleFolder, picb, bCompress, 0);
    }
    else
    {
        //
        // Walk through the linked list of directories compressing the necessary files
        //
        CLEANFILESTRUCT *pCompDir = head;
        while (pCompDir)
        {
            WalkForUsedSpace(pCompDir->file, picb, bCompress, 0);
            pCompDir = pCompDir->pNext;
        }
    }
    
    return;
}

/*
** Purpose:     This function gets the current last access days
**              setting from the registry and calculates the magic
**              filetime we're looking for when searching for files
**              to compress.
**
** Notes;
** Mod Log:     Created by David Schott (7/98)
*/
void CCompCleaner::CalcLADFileTime()
{
    HKEY hCompClenReg = NULL;     // Handle to our registry path
    DWORD dwDisposition;          // stuff for the reg calls
    DWORD dwByteCount;            // Ditto
    DWORD dwDaysLastAccessed = 0; // Day count from the registry setting
    
    MiDebugMsg((0, TEXT("CCompCleaner::CalcLADFileTime")));
    
    //
    // Get the DaysLastAccessed value from the registry.
    //
    
    dwDaysLastAccessed = DEFAULT_DAYS;
    
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, COMPCLN_REGPATH,
        0, NULL, REG_OPTION_NON_VOLATILE, KEY_READ,
        NULL, &hCompClenReg, &dwDisposition))
    {
        dwByteCount = sizeof(dwDaysLastAccessed);
        
        RegQueryValueEx(hCompClenReg,
            TEXT("Days"),
            NULL,
            NULL,
            (LPBYTE) &dwDaysLastAccessed,
            &dwByteCount);
        
        RegCloseKey(hCompClenReg);
    }
    
    //
    // Verify LD setting is within range
    //
    if (dwDaysLastAccessed > MAX_DAYS) 
        dwDaysLastAccessed = MAX_DAYS;
    if (dwDaysLastAccessed < MIN_DAYS) 
        dwDaysLastAccessed = MIN_DAYS;
    
    //
    //Determine the LastAccessedTime 
    //
    if (dwDaysLastAccessed != 0)
    {
        ULARGE_INTEGER  ulTemp, ulLastAccessTime;
        FILETIME        ft;
        
        //Determine the number of days in 100ns units
        ulTemp.LowPart = FILETIME_HOUR_LOW;
        ulTemp.HighPart = FILETIME_HOUR_HIGH;
        
        ulTemp.QuadPart *= dwDaysLastAccessed;
        
        //Get the current FILETIME
        GetSystemTimeAsFileTime(&ft);
        ulLastAccessTime.LowPart = ft.dwLowDateTime;
        ulLastAccessTime.HighPart = ft.dwHighDateTime;
        
        //Subtract the Last Access number of days (in 100ns units) from 
        //the current system time.
        ulLastAccessTime.QuadPart -= ulTemp.QuadPart;
        
        //Save this minimal Last Access time in the FILETIME member variable
        //ftMinLastAccessTime.
        ftMinLastAccessTime.dwLowDateTime = ulLastAccessTime.LowPart;
        ftMinLastAccessTime.dwHighDateTime = ulLastAccessTime.HighPart;
    }
}

/*
** Purpose:     This function will walk the specified directory and increment
**                  the member variable to indicate how much disk space these files
**                  are taking or it will perform the action of compressing the files
**                  if the bCompress variable is set.
**                  It will look at the dwFlags member variable to determine if it
**                  needs to recursively walk the tree or not.
**                  We no longer want to store a linked list of all files to compress
**                  due to extreme memory usage on large filesystems.  This means
**                  we will walk through all the files on the system twice.
** Notes;
** Mod Log:     Created by Jason Cobb (2/97)
**              Adapted for Compression Cleaner by DSchott (6/98)
*/
BOOL CCompCleaner::WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb, BOOL bCompress, int depth)
{
    BOOL bRet = TRUE;
    BOOL bFind = TRUE;
    WIN32_FIND_DATA wd;
    ULARGE_INTEGER dwFileSize;
    static DWORD dwCount = 0;

    TCHAR szFindPath[MAX_PATH], szAddFile[MAX_PATH];

    if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
    {
        BOOL bFolderFound = FALSE;

        bFind = TRUE;
        HANDLE hFind = FindFirstFile(szFindPath, &wd);
        while (hFind != INVALID_HANDLE_VALUE && bFind)
        {
            if (!PathCombine(szAddFile, lpPath, wd.cFileName))
            {
                // Failure here means the file name is too long, just ignore that file
                continue;
            }
            
            if (wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                dwFileSize.HighPart = 0;
                dwFileSize.LowPart = 0;
                bFolderFound = TRUE;
            }
            else if ((IsFileOpen(szAddFile, wd.dwFileAttributes, &wd.ftLastAccessTime) == FALSE) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_COMPRESSED)) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_ENCRYPTED)) &&
                (!(wd.dwFileAttributes & FILE_ATTRIBUTE_OFFLINE)) &&
                (LastAccessisOK(wd.ftLastAccessTime)) &&
                (!IsDontCompressFile(szAddFile)))
            {
                dwFileSize.HighPart = wd.nFileSizeHigh;
                dwFileSize.LowPart = wd.nFileSizeLow;
                
                if (bCompress) 
                {
                    if (!CompressFile(picb, szAddFile, dwFileSize))
                    {
                        bRet = FALSE;
                        bFind = FALSE;
                        break;
                    }
                }
                else 
                {
                    cbSpaceUsed.QuadPart += (dwFileSize.QuadPart * 4 / 10);
                }
            }
            
            // CallBack the cleanup Manager to update the UI

            if ((dwCount++ % 10) == 0 && !bCompress)
            {
                if (picb && picb->ScanProgress(cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                {
                    //
                    //User aborted
                    //
                    bFind = FALSE;
                    bRet = FALSE;
                    break;
                }
            }
            
            bFind = FindNextFile(hFind, &wd);
        }
    
        FindClose(hFind);
    
        if (bRet && bFolderFound)
        {
            //
            //Recurse through all of the directories
            //
            if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
            {
                bFind = TRUE;
                HANDLE hFind = FindFirstFile(szFindPath, &wd);
                while (hFind != INVALID_HANDLE_VALUE && bFind)
                {
                    if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                        (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                        (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                    {
                        ULARGE_INTEGER cbSpaceBefore;

                        cbSpaceBefore.QuadPart = cbSpaceUsed.QuadPart;

                        PathCombine(szAddFile, lpPath, wd.cFileName);
            
                        if (WalkForUsedSpace(szAddFile, picb, bCompress, depth + 1) == FALSE)
                        {
                            // User canceled
                            bFind = FALSE;
                            bRet = FALSE;
                            break;
                        }

                        // Tag this directory for compression
                        // We only want to tag directories that are in the root
                        // otherwise we'll end up with a very large data structure
                        if (cbSpaceBefore.QuadPart != cbSpaceUsed.QuadPart && 
                            depth == 0 && !bCompress)
                        {
                            AddDirToList(szAddFile);
                        }
                    }
        
                    bFind = FindNextFile(hFind, &wd);
                }
    
                FindClose(hFind);
            }
        }
    }
    return bRet;
}

// Adds a directory to the linked list of directories.

BOOL CCompCleaner::AddDirToList(LPCTSTR lpFile)
{
    BOOL bRet = TRUE;
    CLEANFILESTRUCT *pNew = (CLEANFILESTRUCT *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pNew));

    if (pNew == NULL)
    {
        MiDebugMsg((0, TEXT("CCompCleaner::AddDirToList -> ERROR HeapAlloc() failed with error %d"), GetLastError()));
        return FALSE;
    }

    StringCchCopy(pNew->file, ARRAYSIZE(pNew->file), lpFile);

    if (head)
        pNew->pNext = head;
    else
        pNew->pNext = NULL;

    head = pNew;

    return bRet;
}

void CCompCleaner::FreeList(CLEANFILESTRUCT *pCleanFile)
{
    if (pCleanFile == NULL)
        return;

    if (pCleanFile->pNext)
        FreeList(pCleanFile->pNext);

    HeapFree(GetProcessHeap(), 0, pCleanFile);
}

// Compresses the specified file

BOOL CCompCleaner::CompressFile(IEmptyVolumeCacheCallBack *picb, LPCTSTR lpFile, ULARGE_INTEGER filesize)
{
    ULARGE_INTEGER ulCompressedSize;
    
    ulCompressedSize.QuadPart = filesize.QuadPart;
    
    // If the file is read only, we need to remove the
    // R/O attribute long enough to compress the file.
    
    BOOL bFileWasRO = FALSE;
    DWORD dwAttributes = GetFileAttributes(lpFile);
    
    if ((0xFFFFFFFF != dwAttributes) && (dwAttributes & FILE_ATTRIBUTE_READONLY))
    {
        bFileWasRO = TRUE;
        SetFileAttributes(lpFile, FILE_ATTRIBUTE_NORMAL);
    }
    
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE,
        FILE_SHARE_DELETE | FILE_SHARE_READ | FILE_SHARE_WRITE,
        NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (INVALID_HANDLE_VALUE != hFile)
    {
        USHORT InBuffer = COMPRESSION_FORMAT_DEFAULT;
        DWORD dwBytesReturned = 0;
        if (DeviceIoControl(hFile, FSCTL_SET_COMPRESSION, &InBuffer, sizeof(InBuffer),
            NULL, 0, &dwBytesReturned, NULL))
        {
            // Get the compressed file size so we can figure out
            // how much space we gained by compressing.
            ulCompressedSize.LowPart = GetCompressedFileSize(lpFile, &ulCompressedSize.HighPart);
        }
        CloseHandle(hFile);
    }
    
    // Restore the file attributes if needed
    if (bFileWasRO) 
        SetFileAttributes(lpFile, dwAttributes);
    
    // Adjust the cbSpaceFreed
    cbSpaceFreed.QuadPart = cbSpaceFreed.QuadPart + (filesize.QuadPart - ulCompressedSize.QuadPart);
    
    // Call back the cleanup manager to update the progress bar
    if (picb->PurgeProgress(cbSpaceFreed.QuadPart, (cbSpaceUsed.QuadPart - cbSpaceFreed.QuadPart), 0, NULL) == E_ABORT)
    {
        // User aborted so stop compressing files
        MiDebugMsg((0, TEXT("CCompCleaner::PurgeFiles User abort")));
        return FALSE;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\compclen.h ===
// NTFS Compression Disk Cleanup cleaner
#ifndef COMPCLEN_H
#define COMPCLEN_H

#include "common.h"

#define COMPCLN_REGPATH TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VolumeCaches\\Compress old files")

#define MAX_DAYS 500           // Settings dialog spin control max
#define MIN_DAYS 1             // Settings dialog spin control min
#define DEFAULT_DAYS 50        // Default #days if no setting in registry

// Manufactures instances of our CCompCleaner object

class CCompCleanerClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;     // Reference count
    ~CCompCleanerClassFactory();

public:
    CCompCleanerClassFactory();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

// the Compression Cleaner Class

class CCompCleaner : public IEmptyVolumeCache2
{
private:
    ULONG               m_cRef;                 // reference count

    ULARGE_INTEGER      cbSpaceUsed;
    ULARGE_INTEGER      cbSpaceFreed;

    FILETIME            ftMinLastAccessTime;

    TCHAR               szVolume[MAX_PATH];
    TCHAR               szFolder[MAX_PATH];
    BOOL                bPurged;                // TRUE if Purge() method was run
    BOOL                bSettingsMode;          // TRUE if currently in settings mode

    CLEANFILESTRUCT     *head;

    BOOL AddDirToList(LPCTSTR lpPath);
    void FreeList(CLEANFILESTRUCT *pCleanFile);

    BOOL WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb, BOOL bCompress, int depth);
    BOOL CompressFile(IEmptyVolumeCacheCallBack *picb, LPCTSTR lpFile, ULARGE_INTEGER filesize);
    void WalkFileSystem(IEmptyVolumeCacheCallBack *picb, BOOL bCompress);
    void CalcLADFileTime();
    BOOL LastAccessisOK(FILETIME ftFileLastAccess);
    ~CCompCleaner(void);

public:
    CCompCleaner(void);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    //
    // IEmptyVolumeCache2 interface members
    //
    STDMETHODIMP    Initialize(
                HKEY hRegKey,
                LPCWSTR pszVolume,
                LPWSTR *ppszDisplayName,
                LPWSTR *ppszDescription,
                DWORD *pdwFlags
                );


    STDMETHODIMP    GetSpaceUsed(
                DWORDLONG *pdwSpaceUsed,
                IEmptyVolumeCacheCallBack *picb
                );
                
    STDMETHODIMP    Purge(
                DWORDLONG dwSpaceToFree,
                IEmptyVolumeCacheCallBack *picb
                );
                
    STDMETHODIMP    ShowProperties(
                HWND hwnd
                );
                
    STDMETHODIMP    Deactivate(
                DWORD *pdwFlags
                );                                                                                                                                

    STDMETHODIMP    InitializeEx(
                HKEY hRegKey,
                LPCWSTR pcwszVolume,
                LPCWSTR pcwszKeyName,
                LPWSTR *ppwszDisplayName,
                LPWSTR *ppwszDescription,
                LPWSTR *ppwszBtnText,
                DWORD *pdwFlags
                );

};

#endif // CCLEAN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\dataguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  System Data Driver Cleaner
** File:    dataguid.h
**
** Purpose: Defines The 'System Data Driven Cleaner' Class ID for OLE 2.0
** Notes:   The unique Class ID of this System Data Driven Cleaner class is:
**
**          6E793362-73C6-11D0-8469-00AA00442901
**
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/
#ifndef DATAGUID_H
#define DATAGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/
#include <objbase.h>
#include <initguid.h>


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/
// {C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}
DEFINE_GUID(CLSID_DataDrivenCleaner, 
0xc0e13e61, 0xcc6, 0x11d1, 0xbb, 0xb6, 0x0, 0x60, 0x97, 0x8b, 0x2a, 0xe6);
#define ID_SYSTEMDATACLEANER                        0
#define REG_SYSTEMDATACLEANER_CLSID                 TEXT("CLSID\\{C0E13E61-0CC6-11d1-BBB6-0060978B2AE6}")

// {A9B48EAC-3ED8-11d2-8216-00C04FB687DA}
DEFINE_GUID(CLSID_ContentIndexerCleaner, 
0xa9b48eac, 0x3ed8, 0x11d2, 0x82, 0x16, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);
#define ID_CONTENTINDEXCLEANER                      1

/*
**------------------------------------------------------------------------------
** IDs for the property bag implementations
**------------------------------------------------------------------------------
*/
// {60F6E464-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_OldFilesInRootPropBag, 
0x60f6e464, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_OLDFILESINROOTPROPBAG                    3
#define REG_OLDFILESINROOTPROPBAG_CLSID             TEXT("CLSID\\{60F6E464-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E465-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_TempFilesPropBag, 
0x60f6e465, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_TEMPFILESPROPBAG                         4
#define REG_TEMPFILESPROPBAG_CLSID                  TEXT("CLSID\\{60F6E465-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E466-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_SetupFilesPropBag, 
0x60f6e466, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_SETUPFILESPROPBAG                        5
#define REG_SETUPFILESPROPBAG_CLSID                 TEXT("CLSID\\{60F6E466-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {60F6E467-4DEF-11d2-B2D9-00C04F8EEC8C}
DEFINE_GUID(CLSID_UninstalledFilesPropBag, 
0x60f6e467, 0x4def, 0x11d2, 0xb2, 0xd9, 0x0, 0xc0, 0x4f, 0x8e, 0xec, 0x8c);
#define ID_UNINSTALLEDFILESPROPBAG                  6
#define REG_UNINSTALLEDFILESPROPBAG_CLSID           TEXT("CLSID\\{60F6E467-4DEF-11d2-B2D9-00C04F8EEC8C}")

// {24400D16-5754-11d2-8218-00C04FB687DA}
DEFINE_GUID(CLSID_IndexCleanerPropBag, 
0x24400d16, 0x5754, 0x11d2, 0x82, 0x18, 0x0, 0xc0, 0x4f, 0xb6, 0x87, 0xda);
#define ID_INDEXCLEANERPROPBAG                      7
#define REG_INDEXCLEANERPROPBAG_CLSID               TEXT("CLSID\\{24400D16-5754-11d2-8218-00C04FB687DA}")


#endif // DATAGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\dataclen.h ===
#ifndef DATACLEN_H
#define DATACLEN_H

#include "common.h"

class CCleanerClassFactory : public IClassFactory
{
private:
    ULONG   _cRef;     // Reference count
    DWORD   _dwID;     // what type of class factory are we?
    
    ~CCleanerClassFactory();

public:
    CCleanerClassFactory(DWORD);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IClassFactory
    STDMETHODIMP CreateInstance(IUnknown *, REFIID, void **);
    STDMETHODIMP LockServer(BOOL);
};

// This is the actual Data Driven Cleaner Class

class CDataDrivenCleaner : public IEmptyVolumeCache
{
private:
    ULONG               _cRef;                 // reference count
    
    ULARGE_INTEGER      _cbSpaceUsed;
    ULARGE_INTEGER      _cbSpaceFreed;
    
    FILETIME            _ftMinLastAccessTime;
    
    TCHAR               _szVolume[MAX_PATH];
    TCHAR               _szFolder[MAX_PATH];
    DWORD               _dwFlags;
    TCHAR               _filelist[MAX_PATH];
    TCHAR		_szCleanupCmdLine[MAX_PATH];
    BOOL		_bPurged;				// TRUE if Purge() method was run
    
    PCLEANFILESTRUCT    _head;                   // head of the linked list of files
    
    BOOL WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb);
    BOOL WalkAllFiles(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb);
    BOOL AddFileToList(LPCTSTR lpFile, ULARGE_INTEGER filesize, BOOL bDirectory);
    void PurgeFiles(IEmptyVolumeCacheCallBack *picb, BOOL bDoDirectories);
    void FreeList(PCLEANFILESTRUCT pCleanFile);
    BOOL LastAccessisOK(FILETIME ftFileLastAccess);
    
    ~CDataDrivenCleaner(void);
    
public:
    CDataDrivenCleaner(void);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IEmptyVolumeCache
    STDMETHODIMP    Initialize(
        HKEY hRegKey,
        LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName,
        LPWSTR *ppszDescription,
        DWORD *pdwFlags
        );
    
    STDMETHODIMP    GetSpaceUsed(
        DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    Purge(
        DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    ShowProperties(
        HWND hwnd
        );
    
    STDMETHODIMP    Deactivate(
        DWORD *pdwFlags
        );                                                                                                                                
};

/*
**------------------------------------------------------------------------------
** Class:   CDataDrivenPropBag
** Purpose: This is the property bag used to allow string localization for the
**          default data cleaner.  This class implements multiple GUIDs each of
**          which will return different values for the three valid properties.
** Notes:   
** Mod Log: Created by ToddB (9/98)
**------------------------------------------------------------------------------
*/ 
class CDataDrivenPropBag : public IPropertyBag
{
private:
    ULONG               _cRef;                 // reference count
    
    // We use this object for several different property bags.  Based on the CLSID used
    // to create this object we set the value of _dwFilter to a known value so that we
    // know which property bag we are.
    DWORD               _dwFilter;

    ~CDataDrivenPropBag(void);

public:
    CDataDrivenPropBag (DWORD);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IPropertyBag
    STDMETHODIMP Read(LPCOLESTR, VARIANT *, IErrorLog *);
    STDMETHODIMP Write(LPCOLESTR, VARIANT *);
};

class CContentIndexCleaner : public IEmptyVolumeCache
{
private:
    IEmptyVolumeCache * _pDataDriven;
    LONG _cRef;
    
    ~CContentIndexCleaner(void);

public:
    CContentIndexCleaner(void);
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID, void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IEmptyVolumeCache
    STDMETHODIMP    Initialize(
        HKEY hRegKey,
        LPCWSTR pszVolume,
        LPWSTR *ppszDisplayName,
        LPWSTR *ppszDescription,
        DWORD *pdwFlags
        );
    
    STDMETHODIMP    GetSpaceUsed(
        DWORDLONG *pdwSpaceUsed,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    Purge(
        DWORDLONG dwSpaceToFree,
        IEmptyVolumeCacheCallBack *picb
        );
    
    STDMETHODIMP    ShowProperties(
        HWND hwnd
        );
    
    STDMETHODIMP    Deactivate(
        DWORD *pdwFlags
        );                                                                                                                                
};

#endif // DATACLEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\dataclen.cpp ===
#include "common.h"
#include "dataguid.h"
#include "compguid.h"

#include <emptyvc.h>

#include "dataclen.h"
#include "compclen.h"

#include <regstr.h>
#include <olectl.h>
#include <tlhelp32.h>

#define DECL_CRTFREE
#include <crtfree.h>
#ifndef RESOURCE_H
    #include "resource.h"
#endif

#include <winsvc.h>
#include <shlwapi.h>
#include <shlwapip.h>

#include <advpub.h>

HINSTANCE   g_hDllModule      = NULL;  // Handle to this DLL itself.
LONG        g_cDllObjects     = 0;     // Count number of existing objects 

STDAPI_(int) LibMain(HINSTANCE hInstance, DWORD fdwReason, LPVOID pvRes)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_hDllModule   = hInstance;
        break;;
    }

    return TRUE;
}

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    DWORD dw;
    HRESULT hr;
    
    *ppv = NULL;
    
    //
    // Is the request for one of our cleaner objects?
    //
    if (IsEqualCLSID(rclsid, CLSID_DataDrivenCleaner))
    {
        dw = ID_SYSTEMDATACLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_ContentIndexerCleaner))
    {
        dw = ID_CONTENTINDEXCLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_CompCleaner))
    {
        dw = ID_COMPCLEANER;
    }
    else if (IsEqualCLSID(rclsid, CLSID_OldFilesInRootPropBag))
    {
        dw = ID_OLDFILESINROOTPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_TempFilesPropBag))
    {
        dw = ID_TEMPFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_SetupFilesPropBag))
    {
        dw = ID_SETUPFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_UninstalledFilesPropBag))
    {
        dw = ID_UNINSTALLEDFILESPROPBAG;
    }
    else if (IsEqualCLSID(rclsid, CLSID_IndexCleanerPropBag))
    {
        dw = ID_INDEXCLEANERPROPBAG;
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
    
    if (ID_COMPCLEANER == dw)
    {
        CCompCleanerClassFactory *pcf = new CCompCleanerClassFactory();
        if (pcf)
        {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        CCleanerClassFactory * pcf = new CCleanerClassFactory(dw);
        if (pcf)
        {
            hr = pcf->QueryInterface(riid, ppv);
            pcf->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    
    return hr;
}

STDAPI DllCanUnloadNow(void)
{
    return (0 == g_cDllObjects) ? S_OK : S_FALSE;
}

HRESULT CallRegInstall(LPCSTR szSection)
{
    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));
    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");
        if (pfnri)
        {
            STRENTRY seReg[] = {
                { "25", "%SystemRoot%" },
                { "11", "%SystemRoot%\\system32" },
            };
            STRTABLE stReg = { ARRAYSIZE(seReg), seReg };
            hr = pfnri(g_hDllModule, szSection, &stReg);
        }
        // since we only do this from DllInstall() don't load and unload advpack over and over
        // FreeLibrary(hinstAdvPack);
    }
    return hr;
}

STDAPI DllRegisterServer()
{
    return CallRegInstall("RegDll");
}

STDAPI DllUnregisterServer()
{
    return CallRegInstall("UnregDll");
}

UINT incDllObjectCount(void)
{
    return InterlockedIncrement(&g_cDllObjects);
}

UINT decDllObjectCount(void)
{
#if DBG==1
        if( 0 == g_cDllObjects )
        {
            DebugBreak();   // ref counting problem
        }
#endif
    return InterlockedDecrement(&g_cDllObjects);
}

CCleanerClassFactory::CCleanerClassFactory(DWORD dw) : _cRef(1), _dwID(dw)
{
    incDllObjectCount();
}

CCleanerClassFactory::~CCleanerClassFactory()               
{
    decDllObjectCount();
}

STDMETHODIMP CCleanerClassFactory::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppv = (IClassFactory *)this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}   

STDMETHODIMP_(ULONG) CCleanerClassFactory::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CCleanerClassFactory::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CCleanerClassFactory::CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    *ppv = NULL;

    if (pUnkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    if (_dwID == ID_CONTENTINDEXCLEANER)
    {
        CContentIndexCleaner *pContentIndexCleaner = new CContentIndexCleaner();  
        if (pContentIndexCleaner)
        {
            hr = pContentIndexCleaner->QueryInterface(riid, ppv);
            pContentIndexCleaner->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        CDataDrivenCleaner *pDataDrivenCleaner = new CDataDrivenCleaner();  
        if (pDataDrivenCleaner)
        {
            hr = pDataDrivenCleaner->QueryInterface(riid, ppv);
            pDataDrivenCleaner->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (IsEqualIID(riid, IID_IPropertyBag))
    {
        CDataDrivenPropBag *pDataDrivenPropBag = new CDataDrivenPropBag(_dwID);  
        if (pDataDrivenPropBag)
        {
            hr = pDataDrivenPropBag->QueryInterface(riid, ppv);
            pDataDrivenPropBag->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleanerClassFactory::CreateInstance called for unknown riid (%d)"), (_dwID)));
    }

    return hr;      
}

STDMETHODIMP CCleanerClassFactory::LockServer(BOOL fLock)
{
    if (fLock)
        incDllObjectCount();
    else
        decDllObjectCount();

    return S_OK;
}

CDataDrivenCleaner::CDataDrivenCleaner() : _cRef(1)
{
    _cbSpaceUsed.QuadPart = 0;
    _cbSpaceFreed.QuadPart = 0;
    _szVolume[0] = 0;
    _szFolder[0] = 0;
    _filelist[0] = 0;
    _dwFlags = 0;

    _head = NULL;

    incDllObjectCount();
}

CDataDrivenCleaner::~CDataDrivenCleaner()
{
    FreeList(_head);
    _head = NULL;
   
    decDllObjectCount();
}

STDMETHODIMP CDataDrivenCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || 
        IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppv = (IEmptyVolumeCache*) this;
        AddRef();
        return S_OK;
    }  
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataDrivenCleaner::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CDataDrivenCleaner::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

// Initializes the System Data Driven Cleaner and returns the 
// specified IEmptyVolumeCache flags to the cache manager.

STDMETHODIMP CDataDrivenCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                                            LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags)
{
    TCHAR szTempFolder[MAX_PATH];
    ULONG DaysLastAccessed = 0;
    PTSTR pTemp;
    BOOL bFolderOnVolume;

    _bPurged = FALSE;

    *ppszDisplayName = NULL;    // cleanmgr.exe will get these values from
    *ppszDescription = NULL;

    _ftMinLastAccessTime.dwLowDateTime = 0;
    _ftMinLastAccessTime.dwHighDateTime = 0;

    if (*pdwFlags & EVCF_SETTINGSMODE)
    {
        return S_OK;
    }

    _szFolder[0] = 0;
    _dwFlags = 0;
    _filelist[0] = 0;
    _szCleanupCmdLine[0] = 0;
    
    if (hRegKey)
    {
        DWORD dwType, cbData;
        DWORD dwCSIDL;

        cbData = sizeof(dwCSIDL);
        if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_CSIDL, NULL, &dwType, (LPBYTE)&dwCSIDL, &cbData))
        {
            // CSIDL=<hex CSIDL_ value>

            SHGetFolderPath(NULL, dwCSIDL, NULL, 0, _szFolder);

            if (_szFolder[0])
            {
                TCHAR szRelPath[MAX_PATH];
                cbData = sizeof(szRelPath);
                if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_FOLDER, NULL, &dwType, (LPBYTE)szRelPath, &cbData))
                {
                    // optionally append "folder" as a relative path
                    PathAppend(_szFolder, szRelPath);
                }
            }
        }

        if (0 == _szFolder[0])
        {
            // still nothing, try "folder"=<path1>|<path2>
            cbData = sizeof(_szFolder);
            if (ERROR_SUCCESS == RegQueryValueEx(hRegKey, REGSTR_VAL_FOLDER, NULL, &dwType, (LPBYTE)_szFolder, &cbData))
            {
                if (REG_SZ == dwType)
                {
                    // REG_SZ that needs to be converted to a MULTI_SZ
                    //
                    // paths separated by '|' like ?:\foo|?:\bar

                    for (pTemp = _szFolder; *pTemp; pTemp++)
                    {
                        if (*pTemp == TEXT('|'))
                        {
                            *pTemp++ = NULL;
                        }
                    }
                    // double NULL terminated
                    pTemp++;
                    *pTemp = 0;
                }
                else if (REG_EXPAND_SZ == dwType)
                {
                    // single folder with environment expantion
                    if (SHExpandEnvironmentStrings(_szFolder, szTempFolder, (ARRAYSIZE(szTempFolder) - 1)))    // leave extra space for double NULL
                    {
                        StringCchCopy(_szFolder, ARRAYSIZE(_szFolder), szTempFolder);
                    }
                    _szFolder[lstrlen(_szFolder) + 1] = 0;  // double NULL terminated.
                }
                else if (REG_MULTI_SZ == dwType)
                {
                    // nothing else to do, we're done
                }
                else 
                {
                    // invalid data
                    _szFolder[0] = NULL;
                }
            }
        }

        cbData = sizeof(_dwFlags);
        RegQueryValueEx(hRegKey, REGSTR_VAL_FLAGS, NULL, &dwType, (LPBYTE)&_dwFlags, &cbData);

        cbData = sizeof(_filelist);
        RegQueryValueEx(hRegKey, REGSTR_VAL_FILELIST, NULL, &dwType, (LPBYTE)_filelist, &cbData);

        cbData = sizeof(DaysLastAccessed);
        RegQueryValueEx(hRegKey, REGSTR_VAL_LASTACCESS, NULL, &dwType, (LPBYTE)&DaysLastAccessed, &cbData);     

        cbData = sizeof(_szCleanupCmdLine);
        RegQueryValueEx(hRegKey, REGSTR_VAL_CLEANUPSTRING, NULL, &dwType, (LPBYTE)_szCleanupCmdLine, &cbData);
    }

    // If the DDEVCF_RUNIFOUTOFDISKSPACE bit is set then make sure the EVCF_OUTOFDISKSPACE flag
    // was passed in. If it was not then return S_FALSE so we won't run.
    if ((_dwFlags & DDEVCF_RUNIFOUTOFDISKSPACE) &&
        (!(*pdwFlags & EVCF_OUTOFDISKSPACE)))
    {
        return S_FALSE;
    }

    StringCchCopy(_szVolume, ARRAYSIZE(_szVolume), pszVolume);

    // Fix up the filelist.  The file list can either be a MULTI_SZ list of files or 
    // a list of files separated by the ':' colon character or a '|' bar character. 
    // These characters were choosen because they are invalid filename characters.

    for (pTemp = _filelist; *pTemp; pTemp++)
    {
        if (*pTemp == TEXT(':') || *pTemp == TEXT('|'))
        {
            *pTemp++ = 0;
        }
    }
    pTemp++;            // double null terminate
    *pTemp = 0;

    bFolderOnVolume = FALSE;
    if (_szFolder[0] == 0)
    {
        // If no folder value is given so use the current volume
        StringCchCopy(_szFolder, ARRAYSIZE(_szFolder), pszVolume);
        bFolderOnVolume = TRUE;
    }
    else
    {
        // A valid folder value was given, loop over each folder to check for "?" and ensure that
        // we are on a drive that contains some of the specified folders

        for (LPTSTR pszFolder = _szFolder; *pszFolder; pszFolder += lstrlen(pszFolder) + 1)
        {   
            // Replace the first character of each folder (driver letter) if it is a '?'
            // with the current volume.
            if (*pszFolder == TEXT('?'))
            {
                *pszFolder = *pszVolume;
                bFolderOnVolume = TRUE;
            }

            // If there is a valid "folder" value in the registry make sure that it is 
            // on the specified volume.  If it is not then return S_FALSE so that we are
            // not displayed on the list of items that can be freed.
            if (!bFolderOnVolume)
            {
                StringCchCopy(szTempFolder, ARRAYSIZE(szTempFolder), pszFolder);
                
                szTempFolder[lstrlen(pszVolume)] = 0;
                if (lstrcmpi(pszVolume, szTempFolder) == 0)
                {
                    bFolderOnVolume = TRUE;
                }
            }
        }
    }

    if (bFolderOnVolume == FALSE)
    {
        return S_FALSE; //Don't display us in the list
    }

    //
    // Determine the LastAccessedTime 
    //
    if (DaysLastAccessed)
    {
        ULARGE_INTEGER  ulTemp, ulLastAccessTime;

        //Determine the number of days in 100ns units
        ulTemp.LowPart = FILETIME_HOUR_LOW;
        ulTemp.HighPart = FILETIME_HOUR_HIGH;

        ulTemp.QuadPart *= DaysLastAccessed;

        //Get the current FILETIME
        SYSTEMTIME st;
        GetSystemTime(&st);
        FILETIME ft;
        SystemTimeToFileTime(&st, &ft);

        ulLastAccessTime.LowPart = ft.dwLowDateTime;
        ulLastAccessTime.HighPart = ft.dwHighDateTime;

        //Subtract the Last Access number of days (in 100ns units) from 
        //the current system time.
        ulLastAccessTime.QuadPart -= ulTemp.QuadPart;

        //Save this minimal Last Access time in the FILETIME member variable
        //ftMinLastAccessTime.
        _ftMinLastAccessTime.dwLowDateTime = ulLastAccessTime.LowPart;
        _ftMinLastAccessTime.dwHighDateTime = ulLastAccessTime.HighPart;

        _dwFlags |= DDEVCF_PRIVATE_LASTACCESS;
    }

    *pdwFlags = 0;  // disable this item by default

    if (_dwFlags & DDEVCF_DONTSHOWIFZERO)
        *pdwFlags |= EVCF_DONTSHOWIFZERO;
    
    return S_OK;
}

// Returns the total amount of space that the data driven cleaner can remove.
STDMETHODIMP CDataDrivenCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    _cbSpaceUsed.QuadPart = 0;

    //
    // Walk all of the folders in the folders list scanning for disk space.
    //
    for (LPTSTR pszFolder = _szFolder; *pszFolder; pszFolder += lstrlen(pszFolder) + 1)
        WalkForUsedSpace(pszFolder, picb);

    picb->ScanProgress(_cbSpaceUsed.QuadPart, EVCCBF_LASTNOTIFICATION, NULL);
    
    *pdwSpaceUsed =  _cbSpaceUsed.QuadPart;

    return S_OK;
}

// Purges (deletes) all of the files specified in the "filelist" portion of the registry.

STDMETHODIMP CDataDrivenCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    _bPurged = TRUE;

    //
    //Delete the files
    //
    PurgeFiles(picb, FALSE);
    PurgeFiles(picb, TRUE);

    //
    //Send the last notification to the cleanup manager
    //
    picb->PurgeProgress(_cbSpaceFreed.QuadPart, (_cbSpaceUsed.QuadPart - _cbSpaceFreed.QuadPart),
        EVCCBF_LASTNOTIFICATION, NULL);

    //
    //Free the list of files
    //
    FreeList(_head);
    _head = NULL;

    //
    //Run the "CleanupString" command line if one was provided
    //
    if (*_szCleanupCmdLine)
    {
        STARTUPINFO si = {0};
        PROCESS_INFORMATION pi = {0};

        si.cb = sizeof(si);
    
        if (CreateProcess(NULL, _szCleanupCmdLine, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
        {
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
        else
        {
            MiDebugMsg((0, TEXT("CreateProcess(%s) failed with error %d"), _szCleanupCmdLine, GetLastError()));
        }
    }

    return S_OK;
}

STDMETHODIMP CDataDrivenCleaner::ShowProperties(HWND hwnd)
{
    return S_OK;
}

// Deactivates the System Driven Data cleaner...this basically  does nothing.

STDMETHODIMP CDataDrivenCleaner::Deactivate(DWORD *pdwFlags)
{
    *pdwFlags = 0;

    //
    //See if this object should be removed.
    //Note that we will only remove a cleaner if it's Purge() method was run.
    //
    if (_bPurged && (_dwFlags & DDEVCF_REMOVEAFTERCLEAN))
        *pdwFlags |= EVCF_REMOVEFROMLIST;
    
    return S_OK;
}

/*
** checks if the file is a specified number of days
** old (if the "lastaccess" DWORD is in the registry for this cleaner).
** If the file has not been accessed in the specified number of days
** then it can safely be deleted.  If the file has been accessed in
** that number of days then the file will not be deleted.
*/
BOOL CDataDrivenCleaner::LastAccessisOK(FILETIME ftFileLastAccess)
{
    if (_dwFlags & DDEVCF_PRIVATE_LASTACCESS)
    {
        //Is the last access FILETIME for this file less than the current
        //FILETIME minus the number of specified days?
        return (CompareFileTime(&ftFileLastAccess, &_ftMinLastAccessTime) == -1);
    }
    return TRUE;
}

// checks if a file is open by doing a CreateFile
// with fdwShareMode of 0.  If GetLastError() retuns
// ERROR_SHARING_VIOLATION then this function retuns TRUE because
// someone has the file open.  Otherwise this function retuns false.

BOOL TestFileIsOpen(LPCTSTR lpFile, FILETIME *pftFileLastAccess)
{
#if 0
    // too slow, disable this
    HANDLE hFile = CreateFile(lpFile, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING,
                FILE_ATTRIBUTE_NORMAL, NULL);

    if ((hFile == INVALID_HANDLE_VALUE) &&
        (GetLastError() == ERROR_SHARING_VIOLATION))
    {
        return TRUE;    //File is currently open by someone
    }

    //
    // File is not currently open
    //
    SetFileTime(hFile, NULL, pftFileLastAccess, NULL);
    CloseHandle(hFile);
#endif
    return FALSE;
}

// recursively walk the specified directory and 
// add all the files under this directory to the delete list.

BOOL CDataDrivenCleaner::WalkAllFiles(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb)
{
    BOOL            bRet = TRUE;
    BOOL            bFind = TRUE;
    HANDLE          hFind;
    WIN32_FIND_DATA wd;
    TCHAR           szFindPath[MAX_PATH];
    TCHAR           szAddFile[MAX_PATH];
    ULARGE_INTEGER  dwFileSize;
    static DWORD    dwCount = 0;

    //
    //If this is a directory then tack a *.* onto the end of the path
    //and recurse through the rest of the directories
    //
    DWORD dwAttributes = GetFileAttributes(lpPath);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
        {
            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //First check if the attributes of this file are OK for us to delete.
                //
                if (((!(wd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) ||
                    (_dwFlags & DDEVCF_REMOVEREADONLY)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) ||
                    (_dwFlags & DDEVCF_REMOVESYSTEM)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) ||
                    (_dwFlags & DDEVCF_REMOVEHIDDEN)))
                {
                    if (PathCombine(szAddFile, lpPath, wd.cFileName))
                    {
                        //
                        //This is a file so check if it is open
                        //
                        if ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) &&
                            (TestFileIsOpen(szAddFile, &wd.ftLastAccessTime) == FALSE) &&
                            (LastAccessisOK(wd.ftLastAccessTime)))
                        {
                            //
                            //File is not open so add it to the list
                            //
                            dwFileSize.HighPart = wd.nFileSizeHigh;
                            dwFileSize.LowPart = wd.nFileSizeLow;
                            AddFileToList(szAddFile, dwFileSize, FALSE);
                        }
                    }

                    //
                    //CallBack the cleanup Manager to update the UI
                    //
                    if ((dwCount++ % 10) == 0)
                    {
                        if (picb->ScanProgress(_cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                        {
                            //
                            //User aborted
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
            
                bFind = FindNextFile(hFind, &wd);
            }
        
            FindClose(hFind);
        }

        //
        //Recurse through all of the directories
        //
        if (PathCombine(szFindPath, lpPath, TEXT("*.*")))
        {
            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //This is a directory
                //
                if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                    (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                {
                    if (PathCombine(szAddFile, lpPath, wd.cFileName))
                    {
                        dwFileSize.QuadPart = 0;
                        AddFileToList(szAddFile, dwFileSize, TRUE);   
                        
                        if (WalkAllFiles(szAddFile, picb) == FALSE)
                        {
                            //
                            //User cancled
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
                bFind = FindNextFile(hFind, &wd);
            }
            FindClose(hFind);
        }
    }
    return bRet;
}

// walk the specified directory and create a 
// linked list of files that can be deleted.  It will also
// increment the member variable to indicate how much disk space
// these files are taking.
// It will look at the dwFlags member variable to determine if it
// needs to recursively walk the tree or not.

BOOL CDataDrivenCleaner::WalkForUsedSpace(LPCTSTR lpPath, IEmptyVolumeCacheCallBack *picb)
{
    BOOL            bRet = TRUE;
    BOOL            bFind = TRUE;
    HANDLE          hFind;
    WIN32_FIND_DATA wd;
    TCHAR           szFindPath[MAX_PATH];
    TCHAR           szAddFile[MAX_PATH];
    ULARGE_INTEGER  dwFileSize;
    static DWORD    dwCount = 0;
    LPTSTR          lpSingleFile;

    //
    //If this is a directory then tack a *.* onto the end of the path
    //and recurse through the rest of the directories
    //
    DWORD dwAttributes = GetFileAttributes(lpPath);
    if (dwAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        //
        //Enum through the MULTI_SZ filelist
        //
        for (lpSingleFile = _filelist; *lpSingleFile; lpSingleFile += lstrlen(lpSingleFile) + 1)
        {
            StringCchCopy(szFindPath, ARRAYSIZE(szFindPath), lpPath);
            PathAppend(szFindPath, lpSingleFile);

            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                if (StrCmp(wd.cFileName, TEXT(".")) == 0 || StrCmp(wd.cFileName, TEXT("..")) == 0)
                {
                    // ignore these two, otherwise we'll cover the whole disk..
                    bFind = FindNextFile(hFind, &wd);
                    continue;
                }
                
                //
                //First check if the attributes of this file are OK for us to delete.
                //
                if (((!(wd.dwFileAttributes & FILE_ATTRIBUTE_READONLY)) ||
                    (_dwFlags & DDEVCF_REMOVEREADONLY)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) ||
                    (_dwFlags & DDEVCF_REMOVESYSTEM)) &&
                    ((!(wd.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) ||
                    (_dwFlags & DDEVCF_REMOVEHIDDEN)))
                {
                    StringCchCopy(szAddFile, ARRAYSIZE(szAddFile), lpPath);
                    PathAppend(szAddFile, wd.cFileName);

                    //
                    //Check if this is a subdirectory
                    //
                    if (wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                    {
                        if (_dwFlags & DDEVCF_REMOVEDIRS)
                        {
                            dwFileSize.QuadPart = 0;
                            AddFileToList(szAddFile, dwFileSize, TRUE);

                            if (WalkAllFiles(szAddFile, picb) == FALSE)
                            {
                                //
                                //User cancled
                                //
                                FindClose(hFind);
                                return FALSE;
                            }
                        }
                    }

                    //
                    //This is a file so check if it is open
                    //
                    else if ((TestFileIsOpen(szAddFile, &wd.ftLastAccessTime) == FALSE) &&
                        (LastAccessisOK(wd.ftLastAccessTime)))
                    {
                        //
                        //File is not open so add it to the list
                        //
                        dwFileSize.HighPart = wd.nFileSizeHigh;
                        dwFileSize.LowPart = wd.nFileSizeLow;
                        AddFileToList(szAddFile, dwFileSize, FALSE);
                    }                       

                    //
                    //CallBack the cleanup Manager to update the UI
                    //
                    if ((dwCount++ % 10) == 0)
                    {
                        if (picb->ScanProgress(_cbSpaceUsed.QuadPart, 0, NULL) == E_ABORT)
                        {
                            //
                            //User aborted
                            //
                            FindClose(hFind);
                            return FALSE;
                        }
                    }
                }
            
                bFind = FindNextFile(hFind, &wd);
            }
        
            FindClose(hFind);
        }

        if (_dwFlags & DDEVCF_DOSUBDIRS)
        {
            //
            //Recurse through all of the directories
            //
            StringCchCopy(szFindPath, ARRAYSIZE(szFindPath), lpPath);
            PathAppend(szFindPath, TEXT("*.*"));

            bFind = TRUE;
            hFind = FindFirstFile(szFindPath, &wd);
            while (hFind != INVALID_HANDLE_VALUE && bFind)
            {
                //
                //This is a directory
                //
                if ((wd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) &&
                    (lstrcmp(wd.cFileName, TEXT(".")) != 0) &&
                    (lstrcmp(wd.cFileName, TEXT("..")) != 0))
                {
                    StringCchCopy(szAddFile, ARRAYSIZE(szAddFile), lpPath);
                    PathAppend(szAddFile, wd.cFileName);

                    if (WalkForUsedSpace(szAddFile, picb) == FALSE)
                    {
                        //
                        //User cancled
                        //
                        FindClose(hFind);
                        return FALSE;
                    }
                }
        
                bFind = FindNextFile(hFind, &wd);
            }

            FindClose(hFind);
        }

        if (_dwFlags & DDEVCF_REMOVEPARENTDIR)
        {
            // add the parent directory to the list if we are told to remove them....
            dwFileSize.QuadPart = 0;
            AddFileToList(lpPath, dwFileSize, TRUE);
        }
    }
    else
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleaner::WalkForUsedSpace -> %s is NOT a directory!"),
            lpPath));
    }

    return bRet;
}

// Adds a file to the linked list of files.
BOOL CDataDrivenCleaner::AddFileToList(LPCTSTR lpFile, ULARGE_INTEGER  filesize, BOOL bDirectory)
{
    BOOL bRet = TRUE;
    CLEANFILESTRUCT *pNew = (CLEANFILESTRUCT *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*pNew));

    if (pNew == NULL)
    {
        MiDebugMsg((0, TEXT("CDataDrivenCleaner::AddFileToList -> ERROR HeapAlloc() failed with error %d"),
            GetLastError()));
        return FALSE;
    }

    StringCchCopy(pNew->file, ARRAYSIZE(pNew->file), lpFile);
    pNew->ulFileSize.QuadPart = filesize.QuadPart;
    pNew->bSelected = TRUE;
    pNew->bDirectory = bDirectory;

    if (_head)
        pNew->pNext = _head;
    else
        pNew->pNext = NULL;

    _head = pNew;

    _cbSpaceUsed.QuadPart += filesize.QuadPart;

    return bRet;
}

// Removes the files from the disk.

void CDataDrivenCleaner::PurgeFiles(IEmptyVolumeCacheCallBack *picb, BOOL bDoDirectories)
{
    CLEANFILESTRUCT *pCleanFile = _head;

    _cbSpaceFreed.QuadPart = 0;

    while (pCleanFile)
    {
        //
        //Remove a directory
        //
        if (bDoDirectories && pCleanFile->bDirectory)
        {
            SetFileAttributes(pCleanFile->file, FILE_ATTRIBUTE_NORMAL);
            if (!RemoveDirectory(pCleanFile->file))
            {
                MiDebugMsg((0, TEXT("Error RemoveDirectory(%s) returned error %d"),
                    pCleanFile->file, GetLastError()));
            }
        }

        //
        //Remove a file
        //
        else if (!bDoDirectories && !pCleanFile->bDirectory)
        {
            SetFileAttributes(pCleanFile->file, FILE_ATTRIBUTE_NORMAL);
            if (!DeleteFile(pCleanFile->file))
            {
                MiDebugMsg((0, TEXT("Error DeleteFile(%s) returned error %d"),
                    pCleanFile->file, GetLastError()));
            }
        }
        
        //
        //Adjust the cbSpaceFreed
        //
        _cbSpaceFreed.QuadPart += pCleanFile->ulFileSize.QuadPart;

        //
        //Call back the cleanup manager to update the progress bar
        //
        if (picb->PurgeProgress(_cbSpaceFreed.QuadPart, (_cbSpaceUsed.QuadPart - _cbSpaceFreed.QuadPart),
            0, NULL) == E_ABORT)
        {
            //
            //User aborted so stop removing files
            //
            return;
        }

        pCleanFile = pCleanFile->pNext;
    }
}

// Frees the memory allocated by AddFileToList.

void CDataDrivenCleaner::FreeList(CLEANFILESTRUCT *pCleanFile)
{
    if (pCleanFile == NULL)
        return;

    if (pCleanFile->pNext)
        FreeList(pCleanFile->pNext);

    HeapFree(GetProcessHeap(), 0, pCleanFile);
}

CDataDrivenPropBag::CDataDrivenPropBag(DWORD dw) : _cRef(1), _dwFilter(dw)
{
    incDllObjectCount();
}

CDataDrivenPropBag::~CDataDrivenPropBag()
{
    decDllObjectCount();
}

STDMETHODIMP CDataDrivenPropBag::QueryInterface(REFIID riid,  void **ppv)
{
    *ppv = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IPropertyBag))
    {
        *ppv = (IPropertyBag*) this;
        AddRef();
        return S_OK;
    }  

    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CDataDrivenPropBag::AddRef()
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CDataDrivenPropBag::Release()
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CDataDrivenPropBag::Read(LPCOLESTR pwszProp, VARIANT *pvar, IErrorLog *)
{
    if (pvar->vt != VT_BSTR)    // in/out
    {
        return E_FAIL;
    }

    DWORD dwID = 0;
    DWORD dwDisplay;
    DWORD dwDesc;
    TCHAR szBuf[MAX_PATH];

    switch (_dwFilter)
    {
    case ID_OLDFILESINROOTPROPBAG:
        dwDisplay = IDS_OLDFILESINROOT_DISP;
        dwDesc = IDS_OLDFILESINROOT_DESC;
        break;
    case ID_TEMPFILESPROPBAG:
        dwDisplay = IDS_TEMPFILES_DISP;
        dwDesc = IDS_TEMPFILES_DESC;
        break;
    case ID_SETUPFILESPROPBAG:
        dwDisplay = IDS_SETUPFILES_DISP;
        dwDesc = IDS_SETUPFILES_DESC;
        break;
    case ID_UNINSTALLEDFILESPROPBAG:
        dwDisplay = IDS_UNINSTALLFILES_DISP;
        dwDesc = IDS_UNINSTALLFILES_DESC;
        break;
    case ID_INDEXCLEANERPROPBAG:
        dwDisplay = IDS_INDEXERFILES_DISP;
        dwDesc = IDS_INDEXERFILES_DESC;
        break;

    default:
        return E_UNEXPECTED;
    }

    if (0 == lstrcmpiW(pwszProp, L"display"))
    {
        dwID = dwDisplay;
    }
    else if (0 == lstrcmpiW(pwszProp, L"description"))
    {
        dwID = dwDesc;
    }
    else
    {
        return E_INVALIDARG;
    }

    if (LoadString(g_hDllModule, dwID, szBuf, ARRAYSIZE(szBuf)))
    {
        pvar->bstrVal = SysAllocString(szBuf);
        if (pvar->bstrVal)
        {
            return S_OK;
        }
    }

    return E_OUTOFMEMORY;
}

STDMETHODIMP CDataDrivenPropBag::Write(LPCOLESTR, VARIANT *)
{
    return E_NOTIMPL;
}

CContentIndexCleaner::CContentIndexCleaner(void) : _cRef(1)
{
    _pDataDriven = NULL;
    incDllObjectCount();
}

CContentIndexCleaner::~CContentIndexCleaner(void)
{
    if (_pDataDriven)
    {
        _pDataDriven->Release();
    }
    decDllObjectCount();
}

STDMETHODIMP CContentIndexCleaner::QueryInterface(REFIID riid, void **ppv)
{
    *ppv = NULL;
    
    if (riid == IID_IUnknown || riid == IID_IEmptyVolumeCache)
    {
        *ppv = (IEmptyVolumeCache *) this;
        AddRef();
        return S_OK;
    }
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) CContentIndexCleaner::AddRef(void)
{
    return ++_cRef;
}

STDMETHODIMP_(ULONG) CContentIndexCleaner::Release(void)
{
    if (--_cRef)
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CContentIndexCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                                              LPWSTR *ppszDisplayName, LPWSTR *ppszDescription, DWORD *pdwFlags)
{
    // check the volume first to see if it is in the list of cache's know about.
    // If it isn't, then we can just go ahead. If the volume is a known cache, then
    // we must check to see if the service is running...

    HKEY hkeyCatalogs;
    BOOL fFound = FALSE;

    LONG lRes = RegOpenKeyExW(HKEY_LOCAL_MACHINE, L"System\\CurrentControlSet\\Control\\ContentIndex\\Catalogs", 0, KEY_READ, &hkeyCatalogs);
    if (lRes != ERROR_SUCCESS)
    {
        return S_FALSE;
    }

    int iIndex = 0;

    do
    {
        WCHAR szBuffer[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szBuffer);
        lRes = RegEnumKeyExW(hkeyCatalogs, iIndex ++, szBuffer, &dwSize, NULL, NULL, NULL, NULL);
        if (lRes != ERROR_SUCCESS)
        {
            break;
        }

        WCHAR szData[MAX_PATH];
        dwSize = sizeof(szData);
        lRes = SHGetValueW(hkeyCatalogs, szBuffer, L"Location", NULL, szData, &dwSize);
        if (lRes == ERROR_SUCCESS)
        {
            // check to see if it is the same volume... (two characters letter and colon)
            if (StrCmpNIW(pszVolume, szData , 2) == 0)
            {
                fFound = TRUE;
            }
        }

    }
    while (TRUE);

    RegCloseKey(hkeyCatalogs);

    if (fFound)
    {
        // check to see if the index is on or off, if the indexer is on, then we should not allow the user to blow 
        // this off their hard drive...

        SC_HANDLE hSCM = OpenSCManager(NULL, NULL, GENERIC_READ | SC_MANAGER_ENUMERATE_SERVICE);
        if (hSCM)
        {
            SC_HANDLE hCI;
            hCI = OpenService(hSCM, TEXT("cisvc"), SERVICE_QUERY_STATUS);
            if (hCI)
            {
                SERVICE_STATUS rgSs;
                if (QueryServiceStatus(hCI, &rgSs))
                {
                    if (rgSs.dwCurrentState != SERVICE_RUNNING)
                        fFound = FALSE;
                }
                CloseServiceHandle(hCI);
            }
            CloseServiceHandle(hSCM);
        }

        // if it wasn't inactive, then we can't delete it...
        if (fFound)
            return S_FALSE;
    }

    CDataDrivenCleaner *pDataDrivenCleaner = new CDataDrivenCleaner;
    if (pDataDrivenCleaner)
    {
        pDataDrivenCleaner->QueryInterface(IID_IEmptyVolumeCache, (void **)&_pDataDriven);
        pDataDrivenCleaner->Release();
    }

    return _pDataDriven ? _pDataDriven->Initialize(hRegKey, pszVolume, ppszDisplayName, ppszDescription, pdwFlags) : E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
    if (_pDataDriven)
        return _pDataDriven->GetSpaceUsed(pdwSpaceUsed, picb);
        
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    if (_pDataDriven)
        return _pDataDriven->Purge(dwSpaceToFree, picb);
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::ShowProperties(HWND hwnd)
{
    if (_pDataDriven)
        return _pDataDriven->ShowProperties(hwnd);
        
    return E_FAIL;
}
                                    
STDMETHODIMP CContentIndexCleaner::Deactivate(DWORD *pdwFlags)
{
    if (_pDataDriven)
        return _pDataDriven->Deactivate(pdwFlags);
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\compguid.h ===
/*
**------------------------------------------------------------------------------
** Module:  NTFS Compression Disk Cleanup Cleaner
** File:    compguid.h
**
** Purpose: Defines A 'NTFS Compression Cleaner' Class ID for OLE 2.0
** Notes:   The unique Class ID of this Compression Cleaner class is:
**
**          {B50F5260-0C21-11D2-AB56-00A0C9082678}
**
** Mod Log: Created by Jason Cobb (2/97)
**          Adapted for Compression Cleaner by DSchott (6/98)
**
** Copyright (c)1997-1998 Microsoft Corporation. All Rights Reserved.
**------------------------------------------------------------------------------
*/
#ifndef COMPGUID_H
#define COMPGUID_H


/*
**------------------------------------------------------------------------------
** Microsoft C++ include files 
**------------------------------------------------------------------------------
*/
#include <objbase.h>
#include <initguid.h>


/*
**------------------------------------------------------------------------------
** Class ID
**------------------------------------------------------------------------------
*/

// {B50F5260-0C21-11D2-AB56-00A0C9082678}
DEFINE_GUID(CLSID_CompCleaner,
0xB50F5260L, 0x0C21, 0x11D2, 0xAB, 0x56, 0x00, 0xA0, 0xC9, 0x08, 0x26, 0x78);

#define REG_COMPCLEANER_GUID             TEXT("{B50F5260-0C21-11D2-AB56-00A0C9082678}")
#define REG_COMPCLEANER_CLSID            TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}")
#define REG_COMPCLEANER_INPROCSERVER32   TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}\\InProcServer32")
#define REG_COMPCLEANER_DEFAULTICON      TEXT("CLSID\\{B50F5260-0C21-11D2-AB56-00A0C9082678}\\DefaultIcon")
#define ID_COMPCLEANER                   2

#endif // COMPGUID_H
/*
**------------------------------------------------------------------------------
** End of File
**------------------------------------------------------------------------------
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\win95\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\winnt\makefile.inc ===
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\makefile.inc ===
..\dataclen.rc : $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\midebug.cpp ===
/*
**------------------------------------------------------------------------------
** Module:  Disk Space Cleanup Property Sheets
** File:    midebug.cpp
**
** Purpose: Defines the CleanupMgrInfo class for the property tab
** Notes:   
** Mod Log: Created by Jason Cobb (2/97)
**
** Copyright (c)1997 Microsoft Corporation, All Rights Reserved
**------------------------------------------------------------------------------
*/

/*
**------------------------------------------------------------------------------
** Project include files
**------------------------------------------------------------------------------
*/
#include "common.h"

#include <stdio.h>
#include <string.h>


#ifdef DEBUG

// Patch this to TRUE to see spew
BOOL g_fSpew = FALSE;

void
DebugPrint(
    HRESULT hr,
    LPCTSTR  lpFormat,
    ...
    )
{
    if (!g_fSpew) return;

    va_list marker;
    TCHAR    MessageBuffer[512];
    void    *pMsgBuf;
    
    va_start(marker, lpFormat);
    StringCchVPrintf(MessageBuffer, ARRAYSIZE(MessageBuffer), lpFormat, marker);
    va_end(marker);

    if (hr != 0)
    {                       
        FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&pMsgBuf,
            0, NULL);
                 
        StringCchPrintf(MessageBuffer, ARRAYSIZE(MessageBuffer), TEXT("%s %X (%s)"), MessageBuffer, hr, (LPTSTR)pMsgBuf);
        LocalFree(pMsgBuf);
    }
    
    OutputDebugString(TEXT("DATACLEN: "));
    OutputDebugString(MessageBuffer);
    OutputDebugString(TEXT("\r\n"));
}

#endif  //DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by compex.rc
//
#ifndef _WINDOWS_
   #include <windef.h>
   #include <winbase.h>
   #include <wingdi.h>
   #include <winuser.h>
   #include <commctrl.h>
#endif

   // Make sure we have the appropriate flags for Windows95 look and feel
#ifndef DS_3DLOOK
    #define DS_3DLOOK          0x04L
#endif

#ifndef DS_MODALFRAME
   #define DS_MODALFRAME   0x80L
#endif

#ifndef DS_CONTEXTHELP
   #define DS_CONTEXTHELP  0x2000L
#endif

#define IDC_STATIC                      -1

#define ICON_DATACLEN                   100

#define IDD_COMP_VIEW                   101
#define IDD_COMP_SETTINGS               102


// #define IDS_PROPBAGNAME                          999
// #define IDS_SYSTEMDATACLEANER                   1000
#define IDS_OLDFILESINROOT_W95		        1001
#define IDS_OLDFILESINROOT_DISP_W95		1002
#define IDS_OLDFILESINROOT_DESC_W95		1003
#define IDS_OLDFILESINROOT_FILE_W95		1004
// #define IDS_TEMPFILES				1005
#define IDS_TEMPFILES_DISP			1006
#define IDS_TEMPFILES_DESC			1007
// #define IDS_TEMPFILES_FILE			1008
// #define IDS_SETUPFILES				1009
#define IDS_SETUPFILES_DISP			1010
#define IDS_SETUPFILES_DESC			1011
// #define IDS_SETUPFILES_FILE			1012
// #define IDS_SETUPFILES_PROCESS			1013
// #define IDS_UNINSTALLFILES			1014
#define IDS_UNINSTALLFILES_DISP	                1015
#define IDS_UNINSTALLFILES_DESC			1016
// #define IDS_UNINSTALLFILES_FILE			1017
// #define IDS_UNINSTALLFILES_CLEN			1018
// #define IDS_OLDFILESINROOT_FOLDER_W95           1019
// #define IDS_OLDFILESINROOT_NT                   1020
#define IDS_OLDFILESINROOT_DISP_NT		1021
#define IDS_OLDFILESINROOT_DESC_NT		1022
// #define IDS_OLDFILESINROOT_FILE_NT		1023
// #define IDS_OLDFILESINROOT_FOLDER_NT            1024
#define IDC_COMP_LIST                           1000
#define IDS_COMPCLEANER                         1025
#define IDC_SPIN1                               1001
#define IDS_COMPCLEANER_DISP                    1026
#define IDC_EDIT1                               1002
#define IDS_COMPCLEANER_DESC                    1027
#define IDC_COMP_SPIN                           1003
#define IDS_COMPCLEANER_BUTTON                  1028
#define IDC_COMP_EDIT                           1004
#define IDC_COMP_DESC                           1005
#define IDC_COMP_DAYS                           1006
#define IDC_VIEW                                1007
#define IDC_SPIN_DESC                           1008
#define IDC_COMP_DIV                            1009
#define IDS_INDEXERFILES_DISP			1041
#define IDS_INDEXERFILES_DESC			1042

// #define IDS_INDEXCLEANER                        1046

#define ID_ICON_CONTENTINDEX			2000
#define ID_ICON_COMPRESS                        2001
#define ID_ICON_CHKDSK                          2002

#ifdef UNICODE
#define IDS_OLDFILESINROOT_DISP         IDS_OLDFILESINROOT_DISP_NT
#define IDS_OLDFILESINROOT_DESC         IDS_OLDFILESINROOT_DESC_NT
#else
#define IDS_OLDFILESINROOT_DISP         IDS_OLDFILESINROOT_DISP_W95
#define IDS_OLDFILESINROOT_DESC         IDS_OLDFILESINROOT_DESC_W95
#endif
// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        102
#define _APS_NEXT_COMMAND_VALUE         40000
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           100
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\dblnul.cpp ===
#include "cleanupwiz.h"
#include "dblnul.h"

//
// Use of Zero-initialized memory keeps us from having to add nul terminators.
//

BOOL
DblNulTermList::AddString(
    LPCTSTR psz,            // String to copy.
    int cch                 // Length of psz in chars (excl nul term).
    )
{
    while((m_cchAlloc - m_cchUsed) < (cch + 2))
    {
        if (!Grow())
            return false;
    }
    ASSERT(NULL != m_psz);
    if (SUCCEEDED(StringCchCopy(m_psz + m_cchUsed, m_cchAlloc - m_cchUsed, psz)))
    {
        m_cchUsed += cch + 1;
        m_cStrings++;
        return true;
    }
    else
    {
        return false;
    }
}


BOOL
DblNulTermList::Grow(
    void
    )
{
    BOOL fRet;

    ASSERT(m_cchGrow > 0);
    if (!m_psz)
    {
        int cb = m_cchGrow * sizeof(TCHAR);
        m_psz = (LPTSTR)LocalAlloc(LPTR, cb);
        if (m_psz)
        {
            *m_psz = TEXT('\0');
            m_cchAlloc = m_cchGrow;
            fRet = TRUE;
        }
        else
        {
            fRet = FALSE;
        }
    }
    else
    {        
        int cb = (m_cchAlloc + m_cchGrow) * sizeof(TCHAR);
        LPTSTR p = (LPTSTR)LocalReAlloc(m_psz, cb, LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (!p)
        {
            fRet = FALSE;
        }
        else
        {
            m_psz = p;
            m_cchAlloc += m_cchGrow;
            fRet = TRUE;
        }        
    }
    return fRet;
}


BOOL
DblNulTermListIter::Next(
    LPCTSTR *ppszItem
    )
{
    if (*m_pszCurrent)
    {
        *ppszItem = m_pszCurrent;
        m_pszCurrent += lstrlen(m_pszCurrent) + 1;
        return true;
    }
    return false;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\dblnul.h ===
#ifndef _INC_FLDRCLNR_DBLNUL_H
#define _INC_FLDRCLNR_DBLNUL_H

//
// For iterating over items in a double-nul terminated list of
// text strings.
//
class DblNulTermListIter
{
    public:
        explicit DblNulTermListIter(LPCTSTR pszList)
            : m_pszList(pszList),
              m_pszCurrent(pszList) { }

        ~DblNulTermListIter(void) { }

        BOOL Next(LPCTSTR *ppszItem);
        void Reset(void)
            { m_pszCurrent = m_pszList; }

    private:
        LPCTSTR m_pszList;
        LPCTSTR m_pszCurrent;
};


class DblNulTermList
{
    public:
        explicit DblNulTermList(int cchGrow = MAX_PATH)
            : m_psz(NULL),
              m_cchAlloc(0),
              m_cchUsed(0),
              m_cStrings(0),
              m_cchGrow(cchGrow) {  }

        ~DblNulTermList(void)
            { LocalFree(m_psz); }

        BOOL AddString(LPCTSTR psz)
            { return AddString(psz, psz ? lstrlen(psz) : 0); }

        int Count(void) const
            { return m_cStrings; }

        operator LPCTSTR ()
            { return m_psz; }

        DblNulTermListIter CreateIterator(void) const
            { return DblNulTermListIter(m_psz); }

#if DBG
        void Dump(void) const;
#endif

    private:
        LPTSTR m_psz;       // The text buffer.
        int    m_cchAlloc;  // Total allocation in chars.
        int    m_cchUsed;   // Total used excluding FINAL nul term.
        int    m_cchGrow;   // How much to grow each expansion.
        int    m_cStrings;  // Count of strings in list.

        BOOL AddString(LPCTSTR psz, int cch);
        BOOL Grow(void);

        //
        // Prevent copy.
        //
        DblNulTermList(const DblNulTermList& rhs);
        DblNulTermList& operator = (const DblNulTermList& rhs);
};


#endif // INC_FLDRCLNR_DBLNUL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\cleanupwiz.h ===
#ifndef _CLEANUPWIZ_H_
#define _CLEANUPWIZ_H_

#include <shlobj.h>
#include <shfusion.h>
#include <regstr.h>            // REGSTR_PATH_EXPLORER
#include <ccstock.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <cfgmgr32.h>

// some useful debug stuff
#define  SZ_DEBUGINI        "ccshell.ini"
#define  SZ_DEBUGSECTION    "Desktop Cleaning Utility"
#define  SZ_MODULE          "fldrclnr"
#include <debug.h>


// constant strings
extern const LPTSTR c_szRegStrSHELLFOLDERS;
extern const LPTSTR c_szRegStrDESKTOPNAMESPACE;
extern const LPTSTR c_szRegStrPROFILELIST; 
extern const LPTSTR c_szRegStrMSNCODES;
extern const LPTSTR c_szRegStrPATH_OCMANAGER;
extern const LPTSTR c_szRegStrWMP_PATH_SETUP;

extern const LPTSTR c_szRegStrPROFILESDIR;
extern const LPTSTR c_szRegStrALLUSERS;
extern const LPTSTR c_szRegStrDEFAULTUSER;
extern const LPTSTR c_szRegStrDESKTOP;
extern const LPTSTR c_szRegStrMSN_IAONLY;
extern const LPTSTR c_szDESKTOP_DIR;
extern const LPTSTR c_szRegStrIEACCESS;
extern const LPTSTR c_szRegStrYES;
extern const LPTSTR c_szRegStrWMP_REGVALUE;
extern const LPTSTR c_szDEFAULT_USER;

extern const LPTSTR c_szVAL_TIME; 
extern const LPTSTR c_szVAL_DELTA_DAYS;
extern const LPTSTR c_szVAL_DONTRUN;

extern const LPTSTR c_szVALUE_STARTPANEL; 
extern const LPTSTR c_szVALUE_CLASSICMENU;

extern const LPTSTR c_szOEM_TITLEVAL;
extern const LPTSTR c_szOEM_DISABLE;
extern const LPTSTR c_szOEM_SEVENDAY_DISABLE;

//
// These flags specify the mode the wizard runs in
//
#define CLEANUP_MODE_NORMAL   0x0
#define CLEANUP_MODE_ALL      0x1
#define CLEANUP_MODE_SILENT   0x2

#define REGSTR_PATH_CLEANUPWIZ            REGSTR_PATH_EXPLORER TEXT("\\Desktop\\CleanupWiz")
#define REGSTR_PATH_HIDDEN_DESKTOP_ICONS  REGSTR_PATH_EXPLORER TEXT("\\HideDesktopIcons\\%s")
#define REGSTR_OEM_PATH                   REGSTR_PATH_SETUP TEXT("\\OemStartMenuData")

//
// enum for figuring what type of desktop item we are dealing with
//
typedef enum eFILETYPE
{
    FC_TYPE_REGITEM,
    FC_TYPE_LINK,
    FC_TYPE_EXE,
    FC_TYPE_FOLDER,
    FC_TYPE_OTHER,
};

//
// struct used to keep track of which items should
// be cleaned
//
typedef struct
{
    LPITEMIDLIST    pidl;
    BOOL            bSelected;  
    LPTSTR          pszName;    
    HICON           hIcon;      
    FILETIME        ftLastUsed;
} FOLDERITEMDATA, * PFOLDERITEMDATA;


class CCleanupWiz
{
    public:
        CCleanupWiz();
        
        ~CCleanupWiz();
        
        STDMETHODIMP                Run(DWORD dwCleanMode, HWND hwndParent); 
        STDMETHODIMP_(int)          GetNumDaysBetweenCleanup(); // returns the number of days to check for between runs         

    private:
        IShellFolder *              _psf;
        HDSA                        _hdsaItems;
        DWORD                       _dwCleanMode;
        int                         _iDeltaDays;
        BOOL                        _bInited;
        int                         _cItemsOnDesktop;
        
        HFONT                       _hTitleFont;
        TCHAR                       _szFolderName[MAX_PATH];
        
        STDMETHODIMP                _RunInteractive(HWND hwndParent);
        STDMETHODIMP                _RunSilent();

        STDMETHODIMP_(DWORD)        _LoadUnloadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive);
        STDMETHODIMP                _HideRegItemsFromNameSpace(LPCTSTR szDestPath, HKEY hkey);
        STDMETHODIMP                _GetDesktopFolderBySid(LPCTSTR szDestPath, LPCTSTR pszSid, LPTSTR pszBuffer, DWORD cchBuffer);
        STDMETHODIMP                _GetDesktopFolderByRegKey(LPCTSTR pszRegKey, LPCTSTR pszRegValue, LPTSTR szBuffer, DWORD cchBuffer);
        STDMETHODIMP                _AppendDesktopFolderName(LPTSTR pszBuffer);
        STDMETHODIMP                _MoveDesktopItems(LPCTSTR pszFrom, LPCTSTR pszTo);
        STDMETHODIMP                _SilentProcessUserBySid(LPCTSTR pszDestPath, LPCTSTR pszSid);
        STDMETHODIMP                _SilentProcessUserByRegKey(LPCTSTR pszDestPath, LPCTSTR pszRegKey, LPCTSTR pszRegValue);
        STDMETHODIMP                _SilentProcessUsers(LPCTSTR pszDestPath);


        STDMETHODIMP                _LoadDesktopContents();
        STDMETHODIMP                _LoadMergedDesktopContents();
        STDMETHODIMP                _ProcessItems();
        STDMETHODIMP                _ShowBalloonNotification();
        STDMETHODIMP                _LogUsage();

        STDMETHODIMP                _ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem);
        STDMETHODIMP_(BOOL)         _ShouldProcess();
        STDMETHODIMP_(BOOL)         _IsSupportedType(LPCITEMIDLIST pidl);
        STDMETHODIMP_(BOOL)         _IsCandidateForRemoval(LPCITEMIDLIST pidl,  FILETIME * pftLastUsed);
        STDMETHODIMP_(BOOL)         _IsRegItemName(LPTSTR pszName);
        STDMETHODIMP_(BOOL)         _CreateFakeRegItem(LPCTSTR pszDestPath, LPCTSTR pszName, LPCTSTR pszGUID);
        STDMETHODIMP                _GetUEMInfo(WPARAM wParam, LPARAM lParam, int * pcHit, FILETIME * pftLastUsed);
        STDMETHODIMP_(eFILETYPE)    _GetItemType(LPCITEMIDLIST pidl);
        STDMETHODIMP                _HideRegPidl(LPCITEMIDLIST pidl, BOOL bHide);
        STDMETHODIMP                _HideRegItem(CLSID* pclsid, BOOL fHide, BOOL* pfWasHidden);
        STDMETHODIMP                _GetDateFromFileTime(FILETIME ftLastUsed, LPTSTR pszDate, int cch );

        STDMETHODIMP                _InitListBox(HWND hWndListView);
        STDMETHODIMP                _InitChoosePage(HWND hWndListView);
        STDMETHODIMP                _InitFinishPage(HWND hWndListView);
        STDMETHODIMP                _RefreshFinishPage(HWND hDlg);
        STDMETHODIMP_(int)          _PopulateListView(HWND hWndListView);
        STDMETHODIMP_(int)          _PopulateListViewFinish(HWND hWndListView);
        STDMETHODIMP_(void)         _CleanUpDSA();
        STDMETHODIMP                _CleanUpDSAItem(FOLDERITEMDATA * pfid);
        STDMETHODIMP                _SetCheckedState(HWND hWndListView);
        STDMETHODIMP                _MarkSelectedItems(HWND hWndListView);
        
        STDMETHODIMP                _InitializeAndLaunchWizard(HWND hwndParent);

        
        INT_PTR STDMETHODCALLTYPE   _IntroPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        INT_PTR STDMETHODCALLTYPE   _ChooseFilesPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        INT_PTR STDMETHODCALLTYPE   _FinishPageDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);
        
        static INT_PTR CALLBACK     s_StubDlgProc(HWND hdlg, UINT wm, WPARAM wParam, LPARAM lParam);        
} ;           

// helper functions
STDAPI_(BOOL) IsUserAGuest();
void CreateDesktopIcons(); // if OEM decides to disable silent mode, then we create icons on desktop

#endif // _CLEANUPWIZ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\dataclen\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.
!ENDIF

PRECOMPILED_CXX=1

PRECOMPILED_INCLUDE=..\common.h

SELFREGNAME= $(O)\selfreg_dataclen.inf
MISCFILES= $(MISCFILES) $(SELFREGNAME)

CCSHELL_DIR = $(PROJECT_ROOT)

!INCLUDE $(CCSHELL_DIR)\COMMON.INC

INCLUDES=$(CCSHELL_DIR)\inc\win95;$(INCLUDES)

NO_BROWSER_FILE = 1

TARGETNAME=dataclen
TARGETPATH=obj
TARGETTYPE=DYNLINK

#VERIFY_LC       = 1
LC_PATH         = $(PROJECT_ROOT)\lcinf

TARGETLIBS      = \
                  $(SDK_LIB_PATH)\kernel32.lib      \
                  $(SDK_LIB_PATH)\gdi32.lib         \
                  $(SDK_LIB_PATH)\user32.lib        \
                  $(SDK_LIB_PATH)\advapi32.lib      \
                  $(SDK_LIB_PATH)\uuid.lib          \
                  $(SDK_LIB_PATH)\ole32.lib         \
                  $(SDK_LIB_PATH)\oleaut32.lib      \
                  $(SDK_LIB_PATH)\shell32.lib       \
                  $(PROJECT_LIB_PATH)\shlwapip.lib

USE_MSVCRT=1

SOURCES     = ..\dataclen.rc    \
              ..\midebug.cpp    \
              ..\dataclen.cpp   \
              ..\compclen.cpp

DLLDEF          = ..\dataclen.def

DLLENTRY        = LibMain

DLLBASE         = 0x10000000

NTTARGETFILE0   = $(SELFREGNAME)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\cleanupwiz.cpp ===
//
// CleanupWiz.cpp
//

#include "CleanupWiz.h"
#include "resource.h"
#include "dblnul.h"

#include <windowsx.h> // for SetWindowFont
#include <varutil.h>
#include <commctrl.h>
#include <shlwapi.h>
#include <shguidp.h>
#include <ieguidp.h>

// UEM stuff: including this source file is the 
// recommended way of using it in your project
// (see comments in the file itself for the reason)
#include "..\inc\uassist.cpp" 

////////////////////////////////////////////
//
// Globals, constants, externs etc...
//
////////////////////////////////////////////

// none of these strings are ever localized, so it's safe to use them
const LPTSTR c_szRegStrSHELLFOLDERS     = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders");
const LPTSTR c_szRegStrDESKTOPNAMESPACE = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Desktop\\NameSpace");
const LPTSTR c_szRegStrPROFILELIST      = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList");
const LPTSTR c_szRegStrMSNCODES         = TEXT("Software\\Microsoft\\MSN6\\Setup\\MSN\\Codes");
const LPTSTR c_szRegStrPATH_OCMANAGER   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager\\Subcomponents");
const LPTSTR c_szRegStrWMP_PATH_SETUP   = TEXT("Software\\Microsoft\\MediaPlayer\\Setup");

const LPTSTR c_szRegStrPROFILESDIR      = TEXT("ProfilesDirectory");
const LPTSTR c_szRegStrALLUSERS         = TEXT("AllUsersProfile");
const LPTSTR c_szRegStrDEFAULTUSER      = TEXT("DefaultUserProfile");
const LPTSTR c_szRegStrDESKTOP          = TEXT("Desktop");
const LPTSTR c_szRegStrMSN_IAONLY       = TEXT("IAOnly");
const LPTSTR c_szDESKTOP_DIR            = TEXT("Desktop"); // backup in case we can't get the localized version
const LPTSTR c_szRegStrIEACCESS         = TEXT("IEAccess");
const LPTSTR c_szRegStrYES              = TEXT("yes");
const LPTSTR c_szRegStrWMP_REGVALUE     = TEXT("DesktopShortcut");
const LPTSTR c_szDEFAULT_USER           = TEXT("Default User");

const LPTSTR c_szVAL_TIME               = TEXT("Last used time");
const LPTSTR c_szVAL_DELTA_DAYS         = TEXT("Days between clean up");
const LPTSTR c_szVAL_DONTRUN            = TEXT("NoRun");

const LPTSTR c_szVALUE_STARTPANEL       = TEXT("NewStartPanel");
const LPTSTR c_szVALUE_CLASSICMENU      = TEXT("ClassicStartMenu");

const LPTSTR c_szOEM_TITLEVAL           = TEXT("DesktopShortcutsFolderName");
const LPTSTR c_szOEM_DISABLE            = TEXT("DesktopShortcutsCleanupDisable");
const LPTSTR c_szOEM_SEVENDAY_DISABLE   = TEXT("OemDesktopCleanupDisable");

extern HINSTANCE g_hInst;
STDMETHODIMP GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid);

//
// number of items to grow dsa by
//
const int c_GROWBYSIZE = 4; 

//
// number of pages in the wizard
//
const int c_NUM_PAGES = 3;

//
// dialog prompt text length
//
const int c_MAX_PROMPT_TEXT = 1024;
const int c_MAX_HEADER_LEN = 64;
const int c_MAX_DATE_LEN = 40;

//
// file modified more than 60 days back is candidate for cleanup
// this value can be overriden by policy
//
const int c_NUMDAYSTODECAY = 60; 

//
//  Needed for hiding regitems
//
#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }
DEFINE_SCID(SCID_DESCRIPTIONID, PSGUID_SHELLDETAILS, PID_DESCRIPTIONID);

//
// pointer to member function typedef 
//
typedef INT_PTR (STDMETHODCALLTYPE CCleanupWiz::* PCFC_DlgProcFn)(HWND, UINT, WPARAM, LPARAM);

//
// struct for helping us manage our dialog procs
//
typedef struct 
{
    CCleanupWiz * pcfc;
    PCFC_DlgProcFn pfnDlgProc;
} DLGPROCINFO, *PDLGPROCINFO;    

//
// enum for columns
//
typedef enum eColIndex
{
    FC_COL_SHORTCUT,
        FC_COL_DATE
};    


//////////////////////////////////////////////////////
//
// iDays can be negative or positive, indicating time in the past or future
//
//
#define FTsPerDayOver1000 (10000*60*60*24) // we've got (1000 x 10,000) 100ns intervals per second

STDAPI_(void) GetFileTimeNDaysFromGivenTime(const FILETIME *pftGiven, FILETIME * pftReturn, int iDays)
{
    __int64 i64 = *((__int64 *) pftGiven);
    i64 += Int32x32To64(iDays*1000,FTsPerDayOver1000);
    
    *pftReturn = *((FILETIME *) &i64);    
}

STDAPI_(void) GetFileTimeNDaysFromCurrentTime(FILETIME *pf, int iDays)
{
    SYSTEMTIME st;
    FILETIME ftNow;
    
    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &ftNow);
    
    GetFileTimeNDaysFromGivenTime(&ftNow, pf, iDays);
}

/////////////////////////////////////////////////
//
//
// The CCleanupWiz class implementation
//
//
/////////////////////////////////////////////////

CCleanupWiz::CCleanupWiz(): _psf(NULL),
                            _hdsaItems(NULL), 
                            _hTitleFont(NULL),
                            _iDeltaDays(0),
                            _dwCleanMode(CLEANUP_MODE_NORMAL)
{
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC = ICC_LISTVIEW_CLASSES;
    _bInited = InitCommonControlsEx(&icce) && SUCCEEDED(SHGetDesktopFolder(&_psf));
};

CCleanupWiz::~CCleanupWiz()
{
    _CleanUpDSA();
    ATOMICRELEASE(_psf);
};

STDMETHODIMP CCleanupWiz::Run(DWORD dwCleanMode, HWND hwndParent)
{
    HRESULT hr;
    
    if (!_bInited)
    {
        hr = E_FAIL;
    }
    else
    {    
        _dwCleanMode = dwCleanMode;
    
        if (CLEANUP_MODE_SILENT == _dwCleanMode)
        {
            hr = _RunSilent();
        }
        else
        {
            hr = _RunInteractive(hwndParent);
        }
    }

    return hr;
}

STDMETHODIMP CCleanupWiz::_RunInteractive(HWND hwndParent)
{
    HRESULT hr;
    _iDeltaDays = GetNumDaysBetweenCleanup();

    if (_iDeltaDays < 0)
    {
        _iDeltaDays = c_NUMDAYSTODECAY; //initial default value
    }

    LoadString(g_hInst, IDS_ARCHIVEFOLDER, _szFolderName, MAX_PATH);
    // init the common control classes we need
    hr = _LoadDesktopContents();
    if (SUCCEEDED(hr))    
    {
        UINT cItems = DSA_GetItemCount(_hdsaItems);
        if (CLEANUP_MODE_NORMAL == _dwCleanMode)
        {
            if (cItems > 0) // if there are items, we want to notify and proceed only if the user wants us to.
            {
                hr = _ShowBalloonNotification();
            }
            else
            {
                hr = S_FALSE;
            }
        }
        else
        {
            ASSERT(CLEANUP_MODE_ALL == _dwCleanMode);
            hr = S_OK; // run manually, we show everything
        }

        if (S_OK == hr)
        {
            _cItemsOnDesktop = cItems;
            hr = _InitializeAndLaunchWizard(hwndParent);
        }                        

        _LogUsage(); // set registry values to indicate the last run time
    }
    return hr;
}


//
// Creates the property pages for the wizard and launches the wizard
//
//
STDMETHODIMP CCleanupWiz::_InitializeAndLaunchWizard(HWND hwndParent)
{
    HRESULT hr = S_OK;
    
    DLGPROCINFO adpi[c_NUM_PAGES];    
    HPROPSHEETPAGE ahpsp[c_NUM_PAGES];
    PROPSHEETPAGE psp = {0};    
    
    if (!_hTitleFont)
    {
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;

        TCHAR szFont[128];
        LoadString(g_hInst, IDS_TITLELOGFONT, szFont, ARRAYSIZE(szFont));
        if (SUCCEEDED(StringCchCopy(TitleLogFont.lfFaceName, ARRAYSIZE(TitleLogFont.lfFaceName), szFont)))
        {       
            HDC hdc = GetDC(NULL);
            INT FontSize = 12;
            TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
            _hTitleFont = CreateFontIndirect(&TitleLogFont);
            ReleaseDC(NULL, hdc);
        }
    }
    
    //
    // Intro Page
    //
    adpi[0].pcfc        = this;
    adpi[0].pfnDlgProc  = &CCleanupWiz::_IntroPageDlgProc;
    psp.dwSize          = sizeof(psp);
    psp.dwFlags         = PSP_DEFAULT|PSP_HIDEHEADER;
    psp.hInstance       = g_hInst; 
    psp.lParam          = (LPARAM) &adpi[0]; 
    psp.pfnDlgProc      = s_StubDlgProc;
    psp.pszTemplate     = MAKEINTRESOURCE(IDD_INTRO);
    ahpsp[0]            = CreatePropertySheetPage(&psp);
    
    //
    // Choose files page
    //
    adpi[1].pcfc            = this;
    adpi[1].pfnDlgProc      = &CCleanupWiz::_ChooseFilesPageDlgProc;    
    psp.hInstance           = g_hInst;
    psp.dwFlags             = PSP_DEFAULT|PSP_USEHEADERTITLE| PSP_USEHEADERSUBTITLE;
    psp.lParam              = (LPARAM) &adpi[1];
    psp.pszHeaderTitle      = MAKEINTRESOURCE(IDS_CHOOSEFILES);    
    psp.pszHeaderSubTitle   = MAKEINTRESOURCE(IDS_CHOOSEFILES_INFO);
    psp.pszTemplate         = MAKEINTRESOURCE(IDD_CHOOSEFILES);
    psp.pfnDlgProc          = s_StubDlgProc;    
    ahpsp[1]                = CreatePropertySheetPage(&psp);
    
    //
    // Completion Page
    //
    adpi[2].pcfc        = this;
    adpi[2].pfnDlgProc  = &CCleanupWiz::_FinishPageDlgProc;
    psp.dwFlags         = PSP_DEFAULT|PSP_HIDEHEADER;
    psp.hInstance       = g_hInst; 
    psp.lParam          = (LPARAM) &adpi[2]; 
    psp.pfnDlgProc      = s_StubDlgProc;
    psp.pszTemplate     = MAKEINTRESOURCE(IDD_FINISH);
    ahpsp[2]            = CreatePropertySheetPage(&psp);
    
    //
    // The wizard property sheet
    //
    PROPSHEETHEADER psh = {0};
    
    psh.dwSize          = sizeof(psh);
    psh.hInstance       = g_hInst;
    psh.hwndParent      = hwndParent;
    psh.phpage          = ahpsp;
    psh.dwFlags         = PSH_WIZARD97|PSH_WATERMARK|PSH_HEADER;
    psh.pszbmWatermark  = MAKEINTRESOURCE(IDB_WATERMARK);
    psh.pszbmHeader     = MAKEINTRESOURCE(IDB_LOGO);
    psh.nStartPage      = _cItemsOnDesktop ? 0 : c_NUM_PAGES - 1; // if there are no pages on desktop, start on final page
    psh.nPages          = c_NUM_PAGES;
    
    PropertySheet(&psh);
    
    return hr;
}

//
// Pops up a balloon notification tip which asks the user 
// if he wants to clean up the desktop.
//
// returns S_OK if user wants us to cleanup.
//
STDMETHODIMP CCleanupWiz::_ShowBalloonNotification()
{
    IUserNotification *pun;
    HRESULT hr = CoCreateInstance(CLSID_UserNotification, NULL, 
                                  CLSCTX_INPROC_SERVER, IID_PPV_ARG(IUserNotification, &pun));
    if (SUCCEEDED(hr))
    {
        TCHAR szTitle[64], szMsg[256]; // we leave enough room for localization bloat
        
        LoadString(g_hInst, IDS_NOTIFICATION_TITLE, szTitle, ARRAYSIZE(szTitle));
        LoadString(g_hInst, IDS_NOTIFICATION_TEXT, szMsg, ARRAYSIZE(szMsg));
        
        // these pun->Set functions can't fail...
        pun->SetIconInfo(LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_WIZ_ICON)), szTitle);
        pun->SetBalloonInfo(szTitle, szMsg, NIIF_WARNING);                
        pun->SetBalloonRetry(20 * 1000, -1, 1);  // try once, for 20 seconds
        
        // returns S_OK if user wants to continue, ERROR_CANCELLED if timedout
        // or canncelled otherwise.
        hr = pun->Show(NULL, 0); // we don't support iquerycontinue, we will just wait
        
        pun->Release();        
    }        
    return hr;
}

//
// Gets the list of items on the desktop that should be cleaned 
//
// if dwCleanMode == CLEANUP_MODE_NORMAL, it only loads items which have not been used recently
// if dwCleanMode == CLEANUP_MODE_ALL, it loads all items on the desktop, marking those which have not been used recently
//
// 
STDMETHODIMP CCleanupWiz::_LoadDesktopContents()
{
    ASSERT(_psf);
    ASSERT((CLEANUP_MODE_ALL == _dwCleanMode) || (CLEANUP_MODE_NORMAL == _dwCleanMode));
    
    IEnumIDList * ppenum;
    
    DWORD grfFlags = SHCONTF_NONFOLDERS;
    HRESULT hr = _psf->EnumObjects(NULL, grfFlags, &ppenum);
    
    if (SUCCEEDED(hr))
    {
        _CleanUpDSA();
        _hdsaItems = DSA_Create(sizeof(FOLDERITEMDATA), c_GROWBYSIZE);
        
        if (_hdsaItems)
        {
            ULONG celtFetched;
            FOLDERITEMDATA fid = {0};
            
            hr = S_OK;
            while(SUCCEEDED(hr) && (S_OK == ppenum->Next(1,&fid.pidl, &celtFetched)))
            {
                if (_IsSupportedType(fid.pidl)) // only support links and regitems
                {
                    // note, the call to _IsCandidateForRemoval also obtains the last 
                    // used timestamp for the item
                    BOOL bShouldRemove = _IsCandidateForRemoval(fid.pidl, &fid.ftLastUsed);
                    if ( (CLEANUP_MODE_ALL == _dwCleanMode) || bShouldRemove)
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCTSTR) fid.pidl, 
                            0, 
                            &sfi, 
                            sizeof(sfi), 
                            SHGFI_PIDL | SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON ))
                        {
                            if (Str_SetPtr(&(fid.pszName), sfi.szDisplayName))
                            {
                                fid.hIcon = sfi.hIcon;
                                fid.bSelected = bShouldRemove;
                                if (-1 != DSA_AppendItem(_hdsaItems, &fid))
                                {
                                    // All is well, the item has succesfully been added
                                    // to the dsa, we zero out the fields so as not to 
                                    // free those resources now, they will be freed when the 
                                    // dsa is destroyed. 
                                    ZeroMemory(&fid, sizeof(fid));
                                    continue;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }                                                                
                        }
                    }                        
                }
                // Common cleanup path for various failure cases above,
                // we did not add this item to the dsa, so cleanup now.                
                _CleanUpDSAItem(&fid);
            }
            //
            // If we did not load any items into the dsa, we return S_FALSE
            //
            if (SUCCEEDED(hr))
            {
                hr = DSA_GetItemCount(_hdsaItems) > 0 ? S_OK : S_FALSE;
            }                   
        }
        else
        {
            // we failed to allocate memory for the DSA
            hr = E_OUTOFMEMORY;
        }
        ppenum->Release();
    } 
    return hr;
}

//
// Gets the list of items on the desktop that should be cleaned 
//
// if dwCleanMode == CLEANUP_MODE_SILENT, it loads all items on all desktops, marking them all
//
// 
STDMETHODIMP CCleanupWiz::_LoadMergedDesktopContents()
{
    ASSERT(_psf);
    
    IEnumIDList * ppenum;
    
    DWORD grfFlags = _dwCleanMode == CLEANUP_MODE_SILENT ? SHCONTF_FOLDERS | SHCONTF_NONFOLDERS: SHCONTF_NONFOLDERS;
    HRESULT hr = _psf->EnumObjects(NULL, grfFlags, &ppenum);
    
    if (SUCCEEDED(hr))
    {
        _CleanUpDSA();
        _hdsaItems = DSA_Create(sizeof(FOLDERITEMDATA), c_GROWBYSIZE);
        
        if (_hdsaItems)
        {
            ULONG celtFetched;
            FOLDERITEMDATA fid = {0};
            
            hr = S_OK;
            while(SUCCEEDED(hr) && (S_OK == ppenum->Next(1,&fid.pidl, &celtFetched)))
            {
                if (_IsSupportedType(fid.pidl)) // only support links and regitems
                {
                    // note, the call to _IsCandidateForRemoval also obtains the last 
                    // used timestamp for the item
                    BOOL bShouldRemove = ((CLEANUP_MODE_SILENT == _dwCleanMode) ||
                        (_IsCandidateForRemoval(fid.pidl, &fid.ftLastUsed)));
                    if ( (CLEANUP_MODE_ALL == _dwCleanMode) || bShouldRemove)
                    {
                        SHFILEINFO sfi = {0};
                        if (SHGetFileInfo((LPCTSTR) fid.pidl, 
                            0, 
                            &sfi, 
                            sizeof(sfi), 
                            SHGFI_PIDL | SHGFI_DISPLAYNAME | SHGFI_ICON | SHGFI_SMALLICON ))
                        {
                            if (Str_SetPtr(&(fid.pszName), sfi.szDisplayName))
                            {
                                fid.hIcon = sfi.hIcon;
                                fid.bSelected = bShouldRemove;
                                if (-1 != DSA_AppendItem(_hdsaItems, &fid))
                                {
                                    // All is well, the item has succesfully been added
                                    // to the dsa, we zero out the fields so as not to 
                                    // free those resources now, they will be freed when the 
                                    // dsa is destroyed. 
                                    ZeroMemory(&fid, sizeof(fid));
                                    continue;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }                                                                
                        }
                    }                        
                }
                // Common cleanup path for various failure cases above,
                // we did not add this item to the dsa, so cleanup now.                
                _CleanUpDSAItem(&fid);
            }
            //
            // If we did not load any items into the dsa, we return S_FALSE
            //
            if (SUCCEEDED(hr))
            {
                hr = DSA_GetItemCount(_hdsaItems) > 0 ? S_OK : S_FALSE;
            }                   
        }
        else
        {
            // we failed to allocate memory for the DSA
            hr = E_OUTOFMEMORY;
        }
        ppenum->Release();
    } 
    return hr;
}

//
// Expects the given pidl to be a link or regitem. Determines if it is a candidate for removal based
// on when was the last time it was used.
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsCandidateForRemoval(LPCITEMIDLIST pidl, FILETIME * pftLastUsed)
{
    BOOL bRet = FALSE;  // be conservative, if we do not know anything about the 
    // object we will not volunteer to remove it
    int cHit = 0;
    TCHAR szName[MAX_PATH];
    
    ASSERT(_psf);
    
    //
    // we store UEM usage info for the regitems and links on the desktop
    //
    if (SUCCEEDED(DisplayNameOf(_psf, 
        pidl, 
        SHGDN_INFOLDER | SHGDN_FORPARSING, 
        szName, 
        ARRAYSIZE(szName))))
    {
        if (SUCCEEDED(_GetUEMInfo(-1, (LPARAM) szName, &cHit, pftLastUsed)))
        {                    
            FILETIME ft;
            GetFileTimeNDaysFromCurrentTime(&ft, -_iDeltaDays);
            
#ifdef DEBUG
            SYSTEMTIME st;
            FileTimeToSystemTime(&ft, &st);    
#endif
            
            bRet = (CompareFileTime(pftLastUsed, &ft) < 0);
        }
    }
    return bRet;
}


STDMETHODIMP CCleanupWiz::_ShouldShow(IShellFolder* psf, LPCITEMIDLIST pidlFolder, LPCITEMIDLIST pidlItem)
{
    HRESULT hr;
    
    IShellFolder2 *psf2;
    hr = psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
    if (SUCCEEDED(hr))
    {
        // Get the GUID in the pidl, which requires IShellFolder2.
        CLSID guidItem;
        hr = GetItemCLSID(psf2, pidlItem, &guidItem);
        if (SUCCEEDED(hr))
        {
            SHELLSTATE  ss = {0};
            SHGetSetSettings(&ss, SSF_STARTPANELON, FALSE);  //See if the StartPanel is on!
            
            TCHAR szRegPath[MAX_PATH];
            //Get the proper registry path based on if StartPanel is ON/OFF
            hr = StringCchPrintf(szRegPath, ARRAYSIZE(szRegPath), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, (ss.fStartPanelOn ? c_szVALUE_STARTPANEL : c_szVALUE_CLASSICMENU));
            if (SUCCEEDED(hr))
            {            
                //Convert the guid to a string
                TCHAR szGuidValue[MAX_GUID_STRING_LEN];
            
                SHStringFromGUID(guidItem, szGuidValue, ARRAYSIZE(szGuidValue));
            
                //See if this item is turned off in the registry.
                if (SHRegGetBoolUSValue(szRegPath, szGuidValue, FALSE, /* default */FALSE))
                    hr = S_FALSE; //They want to hide it; So, return S_FALSE.
            
                if (SHRestricted(REST_NOMYCOMPUTERICON) && IsEqualCLSID(CLSID_MyComputer, guidItem))
                    hr = S_FALSE;
            }
            
        }
        psf2->Release();
    }
    
    // if we fail for some reason, be generous and say that we should offer to clean this up
    if (FAILED(hr))
    {
        hr = S_OK;
    }

    return hr;
}

//
// Normal, All: We only support removing regitems and links from the desktop
// Silent:      WE NEVER GET HERE FROM SILENT
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsSupportedType(LPCITEMIDLIST pidl)
{
    ASSERT(_dwCleanMode != CLEANUP_MODE_SILENT);
    
    BOOL fRetVal = FALSE;
    
    eFILETYPE eType = _GetItemType(pidl);
    
    if (FC_TYPE_REGITEM == eType)                            // handle regitems
    {
        fRetVal = TRUE;
        
        if (S_OK != _ShouldShow(_psf, NULL, pidl)) // regitems must succeed _ShouldShow
        {
            fRetVal = FALSE;
        }
        else
        {
            IShellFolder2 *psf2;
            CLSID guidItem;
            if (SUCCEEDED(_psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2)))) // must not be one of the shell desktop items
            {            
                if (SUCCEEDED(GetItemCLSID(psf2, pidl, &guidItem)) && 
                    (IsEqualCLSID(CLSID_MyComputer, guidItem) || 
                    IsEqualCLSID(CLSID_MyDocuments, guidItem) || 
                    IsEqualCLSID(CLSID_NetworkPlaces, guidItem) || 
                    IsEqualCLSID(CLSID_RecycleBin, guidItem)))
                {
                    fRetVal = FALSE;
                }
                psf2->Release();
            }
        }
    }
    else if (FC_TYPE_LINK == eType)                         // handle links
    {
        fRetVal = TRUE;
        
        TCHAR szName[MAX_PATH];
        if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName), NULL)))
        {
            if (!lstrcmp(szName, _szFolderName)) // must not be the folder we're cleaning things up to               
            {
                fRetVal = FALSE;
            }
        }
    }
    
    return fRetVal;
}

//
// Returns the type of the pidl. 
// We are only interested in Links and Regitems, so we return FC_TYPE_OTHER for
// all other items.
//

STDMETHODIMP_(eFILETYPE) CCleanupWiz::_GetItemType(LPCITEMIDLIST pidl)
{    
    eFILETYPE eftVal = FC_TYPE_OTHER;        
    TCHAR szName[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    IShellLink *psl;
    
    ASSERT(_psf);
    
    if (FAILED(SHGetNameAndFlags(pidl,  SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName), NULL)))
    {
        szName[0] = 0;
    }
    if (FAILED(SHGetNameAndFlags(pidl,  SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath), NULL)))
    {
        szPath[0] = 0;
    }
    
    if(_IsRegItemName(szName))
    {        
        eftVal = FC_TYPE_REGITEM; 
    }
    else if (SUCCEEDED( _psf->GetUIObjectOf(NULL, 
        1, 
        &pidl, 
        IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        eftVal = FC_TYPE_LINK;
        psl->Release();
    }
    else if (PathIsDirectory(szPath))
    {
        eftVal = FC_TYPE_FOLDER;
    }
    else
    {
        //
        // Maybe this item is a kind of .{GUID} object we created to restore
        // regitems. In that case we want to actually restore the regitem
        // at this point by marking it as unhidden.
        //
        
        LPTSTR pszExt = PathFindExtension(szName);
        if (TEXT('.') == *pszExt                        // it is a file extension
            && lstrlen(++pszExt) == (GUIDSTR_MAX - 1)   // AND the extension is of the right length 
            // note: GUIDSTR_MAX includes the terminating NULL
            // while lstrlen does not, hence the expression
            && TEXT('{') == *pszExt)                    // AND looks like it is a guid...
        {
            // we most prob have a bonafide guid string 
            // pszExt now points to the beginning of the GUID string
            TCHAR szGUIDName[ARRAYSIZE(TEXT("::")) + GUIDSTR_MAX];
            
            // put it in the regitem SHGDN_FORPARSING name format, which is like 
            //
            //      "::{16B280C6-EE70-11D1-9066-00C04FD9189D}"
            //
            if (SUCCEEDED(StringCchPrintf(szGUIDName, ARRAYSIZE(szGUIDName), TEXT("::%s"), pszExt)))
            {
                LPITEMIDLIST pidlGUID;
                DWORD dwAttrib = SFGAO_NONENUMERATED;
            
                //
                // get the pidl of the regitem, if this call succeeds, it means we do have
                // a corresponding regitem in the desktop's namespace
                //
                if (SUCCEEDED(_psf->ParseDisplayName(NULL, 
                    NULL, 
                    szGUIDName, 
                    NULL, 
                    &pidlGUID, 
                    &dwAttrib)))
                {
                    //
                    // check if the regitem is marked as hidden
                    //
                    if (dwAttrib & SFGAO_NONENUMERATED)
                    {
                        //
                        // One last check before we enable the regitem:
                        // Does the regitem have the same display name as the .CLSID file. 
                        // In case the user has restored this .CLSID file and renamed it we will
                        // not attempt to restore the regitem as it may confuse the user.
                        //
                        TCHAR szNameRegItem[MAX_PATH];
                    
                        if (SUCCEEDED((DisplayNameOf(_psf, 
                            pidl,  
                            SHGDN_NORMAL, 
                            szName, 
                            ARRAYSIZE(szName)))) &&
                            SUCCEEDED((DisplayNameOf(_psf, 
                            pidlGUID,  
                            SHGDN_NORMAL, 
                            szNameRegItem, 
                            ARRAYSIZE(szNameRegItem)))) &&
                            lstrcmp(szName, szNameRegItem) == 0)
                        {                                                                                                                                                                      
                            if (SUCCEEDED(_HideRegPidl(pidlGUID, FALSE)))
                            {
                                // delete the file corresponding to the regitem
                                if (SUCCEEDED(DisplayNameOf(_psf, 
                                    pidl,  
                                    SHGDN_NORMAL | SHGDN_FORPARSING, 
                                    szName, 
                                    ARRAYSIZE(szName))))
                                {
                                    DeleteFile(szName); // too bad if we fail, we will just
                                    // have two identical icons on the desktop
                                }
                            
                                //
                                // Log the current time as the last used time of the regitem.
                                // We just re-enabled this regitem but we do not have the
                                // usage info for the corresponding .{CLSID} which the user had
                                // been using so far. So we will be conservative and say that
                                // it was used right now, so that it does not become a candidate
                                // for removal soon. As this is a regitem that the user restored
                                // after the wizard removed it, so it is a fair assumption that
                                // the user has used it after restoring it and is not a candidate
                                // for cleanup right now.
                                //
                                UEMFireEvent(&UEMIID_SHELL, UEME_RUNPATH, UEMF_XEVENT, -1, (LPARAM)szGUIDName);
                            }
                        }                            
                    }
                
                    ILFree(pidlGUID);   
                }
            }
        }
    }
    return eftVal;
}


//
// Determines if a filename is that of a regitem
//        
// a regitem's SHGDN_INFOLDER | SHGDN_FORPARSING name is always "::{someguid}"
// 
// CDefview::_LogDesktopLinksAndRegitems() uses the same test to determine
// if a given pidl is a regitem. This case can lead to false positives if
// you have other items on the desktop which have infoder parsing names
// beginning with "::{", but as ':' is not presently allowed in filenames 
// it should not be a problem. 
//
STDMETHODIMP_(BOOL) CCleanupWiz::_IsRegItemName(LPTSTR pszName)
{
    return (pszName[0] == TEXT(':') && pszName[1] == TEXT(':') && pszName[2] == TEXT('{'));    
}

STDMETHODIMP_(BOOL) CCleanupWiz::_CreateFakeRegItem(LPCTSTR pszDestPath, LPCTSTR pszName, LPCTSTR pszGUID)
{
    BOOL fRetVal = FALSE;
    
    TCHAR szLinkName[MAX_PATH];
    if (SUCCEEDED(StringCchCopy(szLinkName, ARRAYSIZE(szLinkName), pszDestPath)) &&
        PathAppend(szLinkName, pszName) &&
        SUCCEEDED(StringCchCat(szLinkName, ARRAYSIZE(szLinkName), TEXT("."))) &&
        SUCCEEDED(StringCchCat(szLinkName, ARRAYSIZE(szLinkName), pszGUID)))
    {
        //
        // We use the CREATE_ALWAYS flag so that if the file already exists
        // in the Unused Desktop Files folder, we will go ahead and hide the 
        // regitem.
        //
        HANDLE hFile = CreateFile(szLinkName, 0, FILE_SHARE_READ, NULL, 
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            // we created/opened the shortcut, now hide the regitem and close 
            // the shortcut file
            fRetVal = TRUE;
            CloseHandle(hFile);
        }
    }
    
    return fRetVal;
}

//
// Given path to an exe, returns the UEM hit count and last used date for it
//
STDMETHODIMP CCleanupWiz::_GetUEMInfo(WPARAM wParam, LPARAM lParam, int * pcHit, FILETIME * pftLastUsed)
{
    UEMINFO uei;
    uei.cbSize = sizeof(uei);
    uei.dwMask = UEIM_HIT | UEIM_FILETIME;
    
    
    HRESULT hr = UEMQueryEvent(&UEMIID_SHELL, UEME_RUNPATH, wParam, lParam, &uei);
    if (SUCCEEDED(hr))       
    {
        *pcHit = uei.cHit;
        *pftLastUsed = uei.ftExecute;
    }
    return hr;
}


STDMETHODIMP_(BOOL) CCleanupWiz::_ShouldProcess()
{
    BOOL fRetVal = FALSE;
    if (_dwCleanMode == CLEANUP_MODE_SILENT)
    {
        fRetVal = TRUE;
    }
    else
    {
        int cItems = DSA_GetItemCount(_hdsaItems);
        for (int i = 0; i < cItems; i++)
        {
            FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);             
            if (pfid && pfid->bSelected)
            {
                fRetVal = TRUE;
                break;
            }
        }
    }
    
    return fRetVal;
}

//
// Process the list of items. At this point _hdsaItems only contains the
// items that the user wants to delete
//
STDMETHODIMP CCleanupWiz::_ProcessItems()
{
    TCHAR szFolderLocation[MAX_PATH]; // desktop folder
    HRESULT hr = S_OK;
    
    if (_ShouldProcess())
    {
        LPITEMIDLIST pidlCommonDesktop = NULL;
        
        ASSERT(_psf);
        // use the archive folder on the desktop
        if (CLEANUP_MODE_SILENT != _dwCleanMode)
        {
            hr = DisplayNameOf(_psf, NULL, SHGDN_FORPARSING, szFolderLocation, ARRAYSIZE(szFolderLocation));
        }
        else // use the archive folder in Program Files
        {
            hr = SHGetFolderLocation(NULL, CSIDL_PROGRAM_FILES , NULL, 0, &pidlCommonDesktop);
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(_psf, pidlCommonDesktop, SHGDN_FORPARSING, szFolderLocation, ARRAYSIZE(szFolderLocation));
            }
        }
        
        
        if (SUCCEEDED(hr))
        {
            ASSERTMSG(*_szFolderName, "Desktop Cleaner: Archive Folder Name not present");
            
            // create the full path of the archive folder
            TCHAR szFolderPath[MAX_PATH];
            hr = StringCchCopy(szFolderPath, ARRAYSIZE(szFolderPath), szFolderLocation);
            if (SUCCEEDED(hr))
            {
                if (!PathAppend(szFolderPath, _szFolderName))
                {
                    hr = E_FAIL;
                }
                else
                {            
                    //
                    // We have to make sure that this folder exists, as otherwise, if we try to move
                    // a single shortcut using SHFileOperation, that file will be renamed to the target 
                    // name instead of being put in a folder with that name.
                    //        
                    SECURITY_ATTRIBUTES sa;
                    sa.nLength = sizeof (sa);
                    sa.lpSecurityDescriptor = NULL; // we get the default attributes for this process
                    sa.bInheritHandle = FALSE;
            
                    int iRetVal = SHCreateDirectoryEx(NULL, szFolderPath, &sa);        
                    if (ERROR_SUCCESS == iRetVal || ERROR_FILE_EXISTS == iRetVal || ERROR_ALREADY_EXISTS == iRetVal)
                    {
                        DblNulTermList dnSourceFiles;
                        TCHAR szFileName[MAX_PATH + 1]; // to pad an extra null char for SHFileOpStruct
                
                        //
                        //
                        // now we can start on the files we need to move
                        //
                        int cItems = DSA_GetItemCount(_hdsaItems);
                        for (int i = 0; i < cItems; i++)
                        {
                            FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);             
                    
                            if (pfid && (pfid->bSelected || _dwCleanMode == CLEANUP_MODE_SILENT) &&
                                SUCCEEDED(DisplayNameOf(_psf,pfid->pidl, 
                                SHGDN_FORPARSING, 
                                szFileName, 
                                ARRAYSIZE(szFileName) - 1)))
                            {   
                                if (_IsRegItemName(szFileName))
                                {
                                    // if its a regitem, we create a "Item Name.{GUID}" file
                                    // and mark the regitem as hidden. 
                                    //    
                                    if (_CreateFakeRegItem(szFolderPath, pfid->pszName, szFileName+2))
                                    {
                                        _HideRegPidl(pfid->pidl, TRUE); 
                                    }
                                }
                                else // not a regitem, will move it
                                {
                                    dnSourceFiles.AddString(szFileName);                           
                                }                                                                            
                            }
                        }
                
                
                        if (dnSourceFiles.Count() > 0)
                        {
                            DblNulTermList dnTargetFolder;
                            dnTargetFolder.AddString(szFolderPath);
                    
                            SHFILEOPSTRUCT sfo;
                            sfo.hwnd = NULL;
                            sfo.wFunc = FO_MOVE;
                            sfo.pFrom = (LPCTSTR) dnSourceFiles;                           
                            sfo.pTo = (LPCTSTR) dnTargetFolder;         
                            sfo.fFlags = FOF_NORECURSION | FOF_NOCONFIRMMKDIR | FOF_ALLOWUNDO ;
                            hr = SHFileOperation(&sfo);
                        }
                
                        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (LPCVOID) szFolderPath, 0);
                        SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, (LPCVOID) szFolderLocation, 0);            
                
                    }
                    else
                    {
                        // we failed to create the Unused Desktop Files folder
                        hr = E_FAIL; 
                    }
                }
            }        
        }
    }
    
    return hr;
}



////////////////////////////////////////////////////////
//
// DialogProcs
//
// TODO: test for accessibilty issues
//
////////////////////////////////////////////////////////

INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_IntroPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {                
    case WM_INITDIALOG:
        {
            HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_TITLE_WELCOME);
            if (_hTitleFont)
            {
                SetWindowFont(hWnd, _hTitleFont, TRUE);
            }
        }
        break;
        
    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;
            
            switch (lpnm->code)
            {
            case PSN_SETACTIVE:      
                PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                break;
            }
            break;
        }            
    }    
    return ipRet;
}

INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_ChooseFilesPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    HWND hwLV = NULL;
    
    switch (wMsg)
    {
    case WM_INITDIALOG:        
        _InitChoosePage(hDlg);
        ipRet = TRUE;
        break;
        
    case WM_NOTIFY :        
        LPNMHDR lpnm = (LPNMHDR) lParam;
        switch (lpnm->code)
        {
        case PSN_SETACTIVE:
            PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT | PSWIZB_BACK);
            hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
            _SetCheckedState(hwLV);
            break;
            
        case PSN_WIZNEXT:
            // remember the items the user selected
            hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
            _MarkSelectedItems(hwLV);
            break;                    
            
        case PSN_WIZBACK:
            // remember the items the user selected
            hwLV = GetDlgItem(hDlg, IDC_LV_PROMPT);
            _MarkSelectedItems(hwLV);
            break;                    
        }
        break;        
    }    
    return ipRet;
}


INT_PTR STDMETHODCALLTYPE  CCleanupWiz::_FinishPageDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {   
    case WM_INITDIALOG:        
        _InitFinishPage(hDlg);
        ipRet = TRUE;
        break;
        
    case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;
            
            switch (lpnm->code)
            {
            case PSN_SETACTIVE:
                PropSheet_SetWizButtons(GetParent(hDlg), _cItemsOnDesktop ? PSWIZB_BACK | PSWIZB_FINISH : PSWIZB_FINISH); 
                // selection can change so need to do this everytime you come to this page 
                _RefreshFinishPage(hDlg);            
                break;
                
            case PSN_WIZFINISH:
                // process the items now
                _ProcessItems();
                break;                
            }
            break;
        }           
    }   
    return ipRet;
}

//
// stub dialog proc which redirects calls to the right dialog procs
//
INT_PTR CALLBACK CCleanupWiz::s_StubDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    PDLGPROCINFO pInfo = (PDLGPROCINFO) GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (WM_INITDIALOG == wMsg)
    {        
        pInfo = (PDLGPROCINFO) ((LPPROPSHEETPAGE) lParam) -> lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM) pInfo);        
    }
    
    if (pInfo)
    {
        CCleanupWiz * pThis = pInfo->pcfc;
        PCFC_DlgProcFn pfn = pInfo->pfnDlgProc;
        
        return (pThis->*pfn)(hDlg, wMsg, wParam, lParam);
    }    
    return FALSE;
}


STDMETHODIMP CCleanupWiz::_InitListBox(HWND hWndListView)
{
    ListView_SetExtendedListViewStyle(hWndListView, LVS_EX_SUBITEMIMAGES);
    //
    // add the columns
    //    
    LVCOLUMN lvcDate;
    TCHAR szDateHeader[c_MAX_HEADER_LEN];
    
    lvcDate.mask = LVCF_SUBITEM | LVCF_WIDTH | LVCF_TEXT ;
    lvcDate.iSubItem = FC_COL_SHORTCUT;
    lvcDate.cx = 200;
    LoadString(g_hInst, IDS_HEADER_ITEM, szDateHeader, ARRAYSIZE(szDateHeader));
    lvcDate.pszText = szDateHeader;    
    ListView_InsertColumn(hWndListView, FC_COL_SHORTCUT, &lvcDate);
    
    lvcDate.mask = LVCF_SUBITEM | LVCF_FMT | LVCF_WIDTH | LVCF_TEXT ; 
    lvcDate.iSubItem = FC_COL_DATE;
    lvcDate.fmt = LVCFMT_LEFT;
    lvcDate.cx  = 1;
    LoadString(g_hInst, IDS_HEADER_DATE, szDateHeader, ARRAYSIZE(szDateHeader));
    lvcDate.pszText = szDateHeader;           
    ListView_InsertColumn(hWndListView, FC_COL_DATE, &lvcDate);
    ListView_SetColumnWidth(hWndListView, FC_COL_DATE, LVSCW_AUTOSIZE_USEHEADER);
    
    return S_OK;
}

STDMETHODIMP CCleanupWiz::_InitChoosePage(HWND hDlg) 
{ 
    HWND hWndListView = GetDlgItem(hDlg, IDC_LV_PROMPT);
    
    _InitListBox(hWndListView);
    
    //
    // add the images
    //
    HIMAGELIST hSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
        GetSystemMetrics(SM_CYSMICON), 
        ILC_MASK | ILC_COLOR32 , c_GROWBYSIZE, c_GROWBYSIZE);  
    
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {    
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);        
        
        if (pfid)
        {
            ImageList_AddIcon(hSmall, pfid->hIcon);
        }
    }    
    ListView_SetImageList(hWndListView, hSmall, LVSIL_SMALL);
    
    //
    // set the checkboxes style
    //
    ListView_SetExtendedListViewStyleEx(hWndListView, LVS_EX_CHECKBOXES, LVS_EX_CHECKBOXES);
    
    _PopulateListView(hWndListView);            
    
    return S_OK; 
}

STDMETHODIMP CCleanupWiz::_InitFinishPage(HWND hDlg) 
{
    HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_TITLE_WELCOME);
    
    if (_hTitleFont)
    {
        SetWindowFont(hWnd, _hTitleFont, TRUE); 
    }
    
    HIMAGELIST hSmall = ImageList_Create(GetSystemMetrics(SM_CXSMICON), 
        GetSystemMetrics(SM_CYSMICON), 
        ILC_MASK | ILC_COLOR32, c_GROWBYSIZE, c_GROWBYSIZE);  
    
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {    
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);        
        
        if (pfid)
        {
            ImageList_AddIcon(hSmall, pfid->hIcon);
        }
    }
    
    ListView_SetImageList(GetDlgItem(hDlg, IDC_LV_INFORM), hSmall, LVSIL_SMALL);
    return S_OK;
}

STDMETHODIMP CCleanupWiz::_RefreshFinishPage(HWND hDlg) 
{
    HRESULT hr;
    HWND hWndListView = GetDlgItem(hDlg, IDC_LV_INFORM);
    ListView_DeleteAllItems(hWndListView);
    
    int cMovedItems = _PopulateListViewFinish(hWndListView);
    
    // set the informative text to reflect how many items were moved
    HWND hWnd = GetDlgItem(hDlg, IDC_TEXT_INFORM);
    TCHAR szDisplayText[c_MAX_PROMPT_TEXT];
    
    ShowWindow(GetDlgItem(hDlg, IDC_LV_INFORM), BOOLIFY(cMovedItems));
    ShowWindow(GetDlgItem(hDlg, IDC_TEXT_SHORTCUTS), BOOLIFY(cMovedItems));
    ShowWindow(GetDlgItem(hDlg, IDC_TEXT_CHANGE), BOOLIFY(cMovedItems));        
    
    if ( 0 == cMovedItems)
    {
        LoadString(g_hInst, _cItemsOnDesktop ? IDS_INFORM_NONE : IDS_INFORM_NONEFOUND, 
                   szDisplayText, ARRAYSIZE(szDisplayText));
        hr = S_OK;
    }
    else if (1 == cMovedItems)
    {
        LoadString(g_hInst, IDS_INFORM_SINGLE, 
                   szDisplayText, ARRAYSIZE(szDisplayText));
        hr = S_OK;
    }
    else
    {
        TCHAR szRawText[c_MAX_PROMPT_TEXT];        
        LoadString(g_hInst, IDS_INFORM, szRawText, ARRAYSIZE(szRawText));
        hr = StringCchPrintf(szDisplayText, ARRAYSIZE(szDisplayText), szRawText, cMovedItems);                
    }        
    SetWindowText(hWnd, szDisplayText);
    
    return hr;
}    


STDMETHODIMP_(int) CCleanupWiz::_PopulateListView(HWND hWndListView) 
{ 
    LVITEM lvi = {0};    
    int cRet = 0;
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);
        
        lvi.mask = LVIF_TEXT | LVIF_IMAGE;
        lvi.pszText = pfid->pszName;
        lvi.iImage = i;
        lvi.iItem = i;
        lvi.iSubItem = FC_COL_SHORTCUT;
        ListView_InsertItem(hWndListView, &lvi);
        cRet++;
        
        // set the last used date
        TCHAR szDate[c_MAX_DATE_LEN];
        if (SUCCEEDED(_GetDateFromFileTime(pfid->ftLastUsed, szDate, ARRAYSIZE(szDate))))
        {
            ListView_SetItemText(hWndListView, i, FC_COL_DATE, szDate);     
        }    
    }
    return cRet; 
}

STDMETHODIMP_(int) CCleanupWiz::_PopulateListViewFinish(HWND hWndListView) 
{ 
    LVITEM lvi = {0};    
    lvi.mask = LVIF_TEXT | LVIF_IMAGE ;
    int cRet = 0;
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);
        
        //
        // it's the Finish Page, we only show the items we were asked to move
        //
        if (pfid && pfid->bSelected)
        {
            lvi.pszText = pfid->pszName;
            lvi.iImage = i;
            lvi.iItem = i;
            ListView_InsertItem(hWndListView, &lvi);
            cRet++;
        }
        
    }
    return cRet; 
}

//
// Converts a given FILETIME date into s displayable string
//
STDMETHODIMP CCleanupWiz::_GetDateFromFileTime(FILETIME ftLastUsed, LPTSTR pszDate, int cch )
{
    HRESULT hr;
    if (0 == ftLastUsed.dwHighDateTime && 0 == ftLastUsed.dwLowDateTime)
    {
        LoadString(g_hInst, IDS_NEVER, pszDate, cch);
        hr = S_OK;
        {
            hr = E_FAIL;
        }
    }
    else
    {
        DWORD dwFlags = FDTF_SHORTDATE;
        if (0 == SHFormatDateTime(&ftLastUsed, &dwFlags, pszDate, cch))
        {
            hr = E_FAIL;
        }
        else
        {
            hr = S_OK;
        }
    }
    return hr;
}

//
// Marks listview items as checked or unchecked
//
STDMETHODIMP CCleanupWiz::_SetCheckedState(HWND hWndListView) 
{ 
    int cItems = DSA_GetItemCount(_hdsaItems);
    for (int i = 0; i < cItems; i++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, i);       
        
        if (pfid)
        {
            ListView_SetCheckState(hWndListView, i, pfid->bSelected);
        }
    }
    return S_OK; 
}

//
// Reverse of above, updates our list based on user selection.
//
STDMETHODIMP CCleanupWiz::_MarkSelectedItems(HWND hWndListView) 
{ 
    int cItems = ListView_GetItemCount(hWndListView);
    for (int iLV = 0; iLV < cItems; iLV++)
    {
        FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems, iLV);       
        
        if (pfid)
        {
            pfid->bSelected = ListView_GetCheckState(hWndListView, iLV);
        }
    }
    return S_OK; 
}

//
// These methods clean up _hdsaItems and free the allocated memory
//
STDMETHODIMP_(void) CCleanupWiz::_CleanUpDSA()
{
    if (_hdsaItems != NULL)
    {
        for (int i = DSA_GetItemCount(_hdsaItems)-1; i >= 0; i--)
        {
            FOLDERITEMDATA * pfid = (FOLDERITEMDATA *) DSA_GetItemPtr(_hdsaItems,i);            
            
            if (pfid)
            {
                _CleanUpDSAItem(pfid);
            }
        }    
        DSA_Destroy(_hdsaItems);
        _hdsaItems = NULL;
    }        
}

STDMETHODIMP CCleanupWiz::_CleanUpDSAItem(FOLDERITEMDATA * pfid)
{
    
    if (pfid->pidl)
    {
        ILFree(pfid->pidl);
    }
    
    if (pfid->pszName)
    {
        Str_SetPtr(&(pfid->pszName), NULL);
    }
    
    if (pfid->hIcon)
    {
        DestroyIcon(pfid->hIcon);
    }
    
    ZeroMemory(pfid, sizeof(*pfid));
    
    return S_OK;
}

//////////////////////
//
// Hide regitems 
// 
//////////////////////


//
// Helper routines used below.
// Cloned from shell32/util.cpp 
//
STDMETHODIMP GetItemCLSID(IShellFolder2 *psf, LPCITEMIDLIST pidlLast, CLSID *pclsid)
{
    VARIANT var;
    HRESULT hr = psf->GetDetailsEx(pidlLast, &SCID_DESCRIPTIONID, &var);
    if (SUCCEEDED(hr))
    {
        SHDESCRIPTIONID did;
        hr = VariantToBuffer(&var, (void *)&did, sizeof(did));
        if (SUCCEEDED(hr))
            *pclsid = did.clsid;
        
        VariantClear(&var);
    }
    return hr;
}


//
// Given a regitem, it sets the SFGAO_NONENUMERATED bit on it so that 
// that it no longer shows up in the folder.
//
// Since we are primarily only interested in cleaning up desktop clutter,
// that means we don't have to worry about all possible kinds of regitems. 
// Our main target is apps like Outlook which create regitems instead of 
// .lnk shortcuts. So our code does not have to be as complex as the 
// regfldr.cpp version for deleting regitems, which has to account for
// everything, from legacy regitems to delegate folders.
//
//
STDMETHODIMP CCleanupWiz::_HideRegPidl(LPCITEMIDLIST pidlr, BOOL fHide)
{
    IShellFolder2 *psf2;
    HRESULT hr = _psf->QueryInterface(IID_PPV_ARG(IShellFolder2, &psf2));
    if (SUCCEEDED(hr))
    {
        CLSID clsid;
        hr = GetItemCLSID(psf2, pidlr, &clsid);
        if (SUCCEEDED(hr))
        {    
            hr = _HideRegItem(&clsid, fHide, NULL);
        }            
        psf2->Release();                    
    }    
    return hr;
}

STDMETHODIMP CCleanupWiz::_HideRegItem(CLSID* pclsid, BOOL fHide, BOOL* pfWasVisible)
{
    HKEY hkey;            
    
    if (pfWasVisible)
    {
        *pfWasVisible = FALSE;
    }
    
    HRESULT hr = SHRegGetCLSIDKey(*pclsid, TEXT("ShellFolder"), FALSE, TRUE, &hkey);
    if(SUCCEEDED(hr))
    {
        DWORD dwAttr, dwErr;
        DWORD dwType = 0;
        DWORD cbSize = sizeof(dwAttr);
        
        if (ERROR_SUCCESS == RegQueryValueEx(hkey, TEXT("Attributes"), NULL, &dwType, (BYTE *) &dwAttr, &cbSize))
        {
            if (pfWasVisible)
            {
                *pfWasVisible = !(dwAttr & SFGAO_NONENUMERATED);
            }
            fHide ? dwAttr |= SFGAO_NONENUMERATED : dwAttr &= ~SFGAO_NONENUMERATED;
        }
        else
        {
            // attributes do not exist, so we will try creating them
            fHide ? dwAttr = SFGAO_NONENUMERATED : dwAttr = 0; 
        }
        dwErr = RegSetValueEx(hkey, TEXT("Attributes"), NULL, dwType, (BYTE *) &dwAttr, cbSize);
        hr = HRESULT_FROM_WIN32(dwErr);
        RegCloseKey(hkey);
    }                                                            
    
    return hr;
}

//
// Method writes out the last used time in the registry and the 
// number of days it was checkin for
//
STDMETHODIMP CCleanupWiz::_LogUsage()
{ 
    FILETIME ft;
    SYSTEMTIME st;
    
    GetLocalTime(&st);
    SystemTimeToFileTime(&st, &ft);
    
    //
    // we ignore if any of these calls fail, as we cannot really do anything 
    // in that case. the next time we run, we will run maybe sooner that expected.
    //
    SHRegSetUSValue(REGSTR_PATH_CLEANUPWIZ, c_szVAL_TIME, 
        REG_BINARY, &ft, sizeof(ft), 
        SHREGSET_FORCE_HKCU);
    
    SHRegSetUSValue(REGSTR_PATH_CLEANUPWIZ, c_szVAL_DELTA_DAYS,
        REG_DWORD,(DWORD *) &_iDeltaDays, sizeof(_iDeltaDays), 
        SHREGSET_FORCE_HKCU);    
    
    //
    // TODO: also write out to log file here 
    //    
    return S_OK;   
}

//
// returns the current value from the policy key or the user settings
//
STDMETHODIMP_(int) CCleanupWiz::GetNumDaysBetweenCleanup()
{
    DWORD dwData;
    DWORD dwType;
    DWORD cch = sizeof (DWORD);
    
    int iDays = -1; // if the value does not exist
    
    //
    // ISSUE-2000/12/01-AIDANL  Removed REGSTR_POLICY_CLEANUP, don't think we need both, but want to 
    //                          leave this note in case issues come up later.
    //
    if (ERROR_SUCCESS == (SHRegGetUSValue(REGSTR_PATH_CLEANUPWIZ, c_szVAL_DELTA_DAYS, 
        &dwType, &dwData, &cch,FALSE, NULL, 0)))               
    {
        iDays = dwData;
    }
    
    return iDays;
}

// helper functions
STDAPI_(BOOL) IsUserAGuest()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\resource.h ===
#define IDS_INFORM                      1
#define IDS_INFORM_SINGLE               2
#define IDS_INFORM_NONE                 3
#define IDS_INFORM_NONEFOUND            4
#define IDS_NEVER                       5
#define IDS_NOTIFICATION_TITLE          6
#define IDS_NOTIFICATION_TEXT           7
#define IDS_ARCHIVEFOLDER               8
#define IDS_CHOOSEFILES                 9
#define IDS_CHOOSEFILES_INFO            10
#define IDS_HEADER_DATE                 11
#define IDS_HEADER_ITEM                 12
#define IDS_ARCHIVEFOLDER_FIRSTBOOT     15
#define IDS_TITLELOGFONT                20

#define IDS_WMP                         50
#define IDS_DEFAULTUSER                 51
#define IDS_MSN                         60
#define IDS_MSN_ALT                     61

#define IDI_WIZ_ICON                    100

#define IDD_INTRO                       101
#define IDD_CHOOSEFILES                 102
#define IDD_FINISH                      103

#define IDB_WATERMARK                   200
#define IDB_LOGO                        201

#define IDC_DETAILS                     1000
#define IDC_LIST2                       1001
#define IDC_CHECK1                      1002
#define IDC_LIST1                       1003
#define IDC_COMBO1                      1004

#define IDC_LV_PROMPT                   1010
#define IDC_LV_INFORM                   1010
#define IDC_TEXT_TITLE_WELCOME          1011
#define IDC_TEXT_INFORM                 1012
#define IDC_TEXT_SHORTCUTS              1013
#define IDC_TEXT_CHANGE                 1014
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\dll.cpp ===
//
// Dll.cpp
//
// Dll API functions for FldrClnr.dll
//
//

#include <windows.h>
#include <shlwapi.h>
#include <shfusion.h>
#include "CleanupWiz.h"

// declare debug needs to be defined in exactly one source file in the project
#define  DECLARE_DEBUG
#include <debug.h>

HINSTANCE           g_hInst;
CRITICAL_SECTION    g_csDll = {0};   // needed by ENTERCRITICAL in uassist.cpp (UEM code)

//
// Dll functions
//

extern "C" BOOL APIENTRY DllMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            SHFusionInitializeFromModule(hDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            SHFusionUninitialize();
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}

STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK; 
}

STDAPI DllRegisterServer(void)
{
    return S_OK;
}

STDAPI DllUnregisterServer(void)
{
    return S_OK;
}


//////////////////////////////////////////////////////

// ensure only one instance is running
HANDLE AnotherCopyRunning()
{
    HANDLE hMutex = CreateMutex(NULL, FALSE, TEXT("DesktopCleanupMutex"));

    if (hMutex && GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Mutex created but by someone else
        CloseHandle(hMutex);
        hMutex = NULL;
    }

    return hMutex;
}

//////////////////////////////////////////////////////

//
// This function checks whether we need to run the cleaner 
// We will not run if user is guest, user has forced us not to, or if the requisite
// number of days have not yet elapsed
//
BOOL ShouldRun(DWORD dwCleanMode)
{
    DWORD cch, dwData;

    if (IsUserAGuest())
    {
        return FALSE;
    }

    //
    // if we're in silent mode and NOT in personal mode and the DONT RUN flag is set, we return immediately
    // (the OEM set the "don't run silent mode" flag)
    //
    cch = sizeof(DWORD);
    if ((CLEANUP_MODE_SILENT == dwCleanMode) && 
        (!IsOS(OS_PERSONAL)) &&
        (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, c_szOEM_DISABLE, NULL, &dwData, &cch)) &&
        (dwData != 0))
    {
        return FALSE;
    }

    //
    // if we're in silent mode and the other DONT RUN flag is set, we return immediately
    // (the OEM set the "don't run silent mode" flag)
    //
    cch = sizeof(DWORD);
    if ((CLEANUP_MODE_SILENT == dwCleanMode) && 
        (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, c_szOEM_SEVENDAY_DISABLE, NULL, &dwData, &cch)) &&
        (dwData != 0))
    {
        CreateDesktopIcons(); // create default icons on the desktop (IE, MSN Explorer, Media Player)
        return FALSE;
    }

    //
    // check if policy prevents us from running 
    //
    if ((CLEANUP_MODE_NORMAL == dwCleanMode || CLEANUP_MODE_ALL == dwCleanMode) &&
        (SHRestricted(REST_NODESKTOPCLEANUP)))
    {
        return FALSE;
    }
    
    return TRUE;
}

///////////////////////
//
// Our exports
//
///////////////////////


//
// The rundll32.exe entry point for starting the dekstop cleaner.
// called via "rundll32.exe fldrclnr.dll,Wizard_RunDLL" 
//
// can take an optional parameter in the commandline :
//
// "all"    - show all the items on the desktop in the UI
// "silent" - silently clean up all the items on the desktop
//

STDAPI_(void) Wizard_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{
    DWORD dwCleanMode;

    if (0 == StrCmpNIA(pszCmdLine, "all", 3))
    {
        dwCleanMode = CLEANUP_MODE_ALL;
    }
    else if (0 == StrCmpNIA(pszCmdLine, "silent", 6))
    {
        dwCleanMode = CLEANUP_MODE_SILENT;
    }
    else
    {
        dwCleanMode = CLEANUP_MODE_NORMAL;
    }

    HANDLE hMutex = AnotherCopyRunning();

    if (hMutex)
    {
        if (ShouldRun(dwCleanMode))
        {    
            if (InitializeCriticalSectionAndSpinCount(&g_csDll, 0)) // needed for UEM stuff
            {
                if (SUCCEEDED(CoInitializeEx(NULL, COINIT_APARTMENTTHREADED))) // also for UEM stuff.
                {
                    CCleanupWiz cfc;
                    cfc.Run(dwCleanMode, hwndStub);
                    CoUninitialize();
                }
        
                DeleteCriticalSection(&g_csDll);
            }
        }
        CloseHandle(hMutex);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\gcinst.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

extern const TCHAR c_szProgmanIni[];
extern const TCHAR c_szStartup[];
extern const TCHAR c_szProgmanExe[];
extern const TCHAR c_szProgman[];


void BuildDefaultGroups(void);
void EditStartMenu(void);
BOOL FindProgmanIni(LPTSTR pszPath);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\group.h ===
//---------------------------------------------------------------------------
// 
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------

#define GC_PROMPTBEFORECONVERT	0x0001
#define GC_REPORTERROR		0x0002
#define GC_OPENGROUP		0x0004
#define GC_BUILDLIST		0x0008

typedef void (CALLBACK *PFNGRPCALLBACK)(LPCTSTR lpszGroup);

BOOL Group_Convert(HWND hwnd, LPCTSTR lpszOldGroup, UINT options);
DWORD Group_ReadLastModDateTime(LPCTSTR lpszGroupFile);
void Group_WriteLastModDateTime(LPCTSTR lpszGroupFile,DWORD dwLowDateTime);
int Group_Enum(PFNGRPCALLBACK pfncb, BOOL fProgress, BOOL fModifiedOnly);
int Group_EnumNT(PFNGRPCALLBACK pfncb, BOOL fProgress, BOOL fModifiedOnly, HKEY hKeyRoot, LPCTSTR lpKey);
void Group_EnumOldGroups(PFNGRPCALLBACK pfncb, BOOL fProgress);
void AppList_WriteFile(void);
BOOL AppList_Create(void);
void AppList_Destroy(void);
void AppList_AddCurrentStuff(void);
int Group_GetLastConversionCount(void);

#define PRICF_NORMAL            0x0000
#define PRICF_ALLOWSLASH        0x0001

void PathRemoveIllegalChars(LPTSTR pszPath, int iGroupName, UINT flags);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\cleanup\fldrclnr\silent.cpp ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <shlwapi.h>

#include "CleanupWiz.h"
#include "resource.h"
#include "dblnul.h"

extern HINSTANCE g_hInst;

//#define SILENTMODE_LOGGING

#ifdef SILENTMODE_LOGGING

HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

void StartLogging(LPTSTR pszFolderPath)
{
    TCHAR szLogFile[MAX_PATH];
    if (SUCCEEDED(StringCchCopy(szLogFile, ARRAYSIZE(szLogFile), pszFolderPath)) &&
        PathAppend(szLogFile, TEXT("log.txt")))
    {
        g_hLogFile = CreateFile(szLogFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
    }
}

void StopLogging()
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}

void WriteLog(LPCTSTR pszTemplate, LPCTSTR pszParam1, LPCTSTR pszParam2)
{
    if (INVALID_HANDLE_VALUE != g_hLogFile)
    {
        TCHAR szBuffer[1024];
        DWORD cbWritten;
        if (SUCCEEDED(StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), pszTemplate, pszParam1, pszParam2)) &&
            WriteFile(g_hLogFile, szBuffer, sizeof(TCHAR) * lstrlen(szBuffer), &cbWritten, NULL))
        {
            FlushFileBuffers(g_hLogFile);
        }
    }
}

#define STARTLOGGING(psz) StartLogging(psz)
#define STOPLOGGING StopLogging()
#define WRITELOG(pszTemplate, psz1, psz2) WriteLog(pszTemplate, psz1, psz2)

#else

#define STARTLOGGING(psz)
#define STOPLOGGING
#define WRITELOG(pszTemplate, psz1, psz2)

#endif 

// copied from shell\ext\shgina\cenumusers.cpp
DWORD CCleanupWiz::_LoadUnloadHive(HKEY hKey, LPCTSTR pszSubKey, LPCTSTR pszHive)
{
    DWORD dwErr;
    BOOLEAN bWasEnabled;
    NTSTATUS status;

    status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &bWasEnabled);

    if ( NT_SUCCESS(status) )
    {
        if (pszHive)
        {
            dwErr = RegLoadKey(hKey, pszSubKey, pszHive);
        }
        else
        {
            dwErr = RegUnLoadKey(hKey, pszSubKey);
        }

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, bWasEnabled, FALSE, &bWasEnabled);
    }
    else
    {
        dwErr = RtlNtStatusToDosError(status);
    }

    return dwErr;
}

HRESULT CCleanupWiz::_HideRegItemsFromNameSpace(LPCTSTR pszDestPath, HKEY hkey)
{
    DWORD dwIndex = 0;
    TCHAR szCLSID[39];
    while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex++, szCLSID, ARRAYSIZE(szCLSID)))
    {
        CLSID clsid;            
        if (GUIDFromString(szCLSID, &clsid) &&
            CLSID_MyComputer != clsid &&
            CLSID_MyDocuments != clsid &&
            CLSID_NetworkPlaces != clsid &&
            CLSID_RecycleBin != clsid)
        {
            BOOL fWasVisible;
            if (SUCCEEDED(_HideRegItem(&clsid, TRUE, &fWasVisible)) && 
                fWasVisible)
            {
                HKEY hkeyCLSID;
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ, &hkeyCLSID))
                {
                    HKEY hkeySub;
                    if (ERROR_SUCCESS == RegOpenKeyEx(hkeyCLSID, szCLSID, 0, KEY_READ, &hkeySub))
                    {
                        TCHAR szName[260];
                        LONG cbName = sizeof(szName);
                        if (ERROR_SUCCESS == RegQueryValue(hkeySub, NULL, szName, &cbName))
                        {
                            _CreateFakeRegItem(pszDestPath, szName, szCLSID);
                        }
                        RegCloseKey(hkeySub);
                    }
                    RegCloseKey(hkeyCLSID);
                }
            }
        }
    }

    return S_OK;
}

HRESULT CCleanupWiz::_GetDesktopFolderBySid(LPCTSTR pszDestPath, LPCTSTR pszSid, LPTSTR pszBuffer, DWORD cchBuffer)
{
    ASSERT(cchBuffer >= MAX_PATH); // because we do PathAppend on it

    HRESULT hr;

    TCHAR szKey[MAX_PATH];
    TCHAR szProfilePath[MAX_PATH];
    DWORD dwSize;
    DWORD dwErr;

    // Start by getting the user's ProfilePath from the registry
    hr = StringCchCopy(szKey, ARRAYSIZE(szKey), c_szRegStrPROFILELIST);
    if (SUCCEEDED(hr))
    {
        if (!PathAppend(szKey, pszSid))
        {
            hr = E_FAIL;
        }
        else
        {
            dwSize = sizeof(szProfilePath);
            dwErr = SHGetValue(HKEY_LOCAL_MACHINE,
                               szKey,
                               TEXT("ProfileImagePath"),
                               NULL,
                               szProfilePath,
                               &dwSize);

            if (ERROR_SUCCESS != dwErr ||
                !PathAppend(szProfilePath, TEXT("ntuser.dat")))
            {
                hr = E_FAIL;
            }
            else
            {
                dwErr = _LoadUnloadHive(HKEY_USERS, pszSid, szProfilePath);

                if (ERROR_SUCCESS != dwErr && 
                    ERROR_SHARING_VIOLATION != dwErr) // sharing violation means the hive is already open
                {
                    hr = HRESULT_FROM_WIN32(dwErr);
                }
                else
                {
                    HKEY hkey;

                    hr = StringCchCopy(szKey, ARRAYSIZE(szKey), pszSid);
                    if (SUCCEEDED(hr))
                    {
                        if (!PathAppend(szKey, c_szRegStrSHELLFOLDERS))
                        {
                            hr = E_FAIL;
                        }
                        else
                        {                    
                            dwErr = RegOpenKeyEx(HKEY_USERS,
                                                 szKey,
                                                 0,
                                                 KEY_QUERY_VALUE,
                                                 &hkey);

                            if ( dwErr != ERROR_SUCCESS )
                            {
                                hr = HRESULT_FROM_WIN32(dwErr);
                            }
                            else
                            {
                                dwSize = cchBuffer;
                                dwErr = RegQueryValueEx(hkey, c_szRegStrDESKTOP, NULL, NULL, (LPBYTE)pszBuffer, &dwSize);
                                if ( dwErr == ERROR_SUCCESS )
                                {
                                    if (!PathAppend(pszBuffer, TEXT("*")))
                                    {
                                        hr = E_FAIL;
                                    }
                                }

                                RegCloseKey(hkey);
                            }

                            if (SUCCEEDED(hr))
                            {
                                hr = StringCchCopy(szKey, ARRAYSIZE(szKey), pszSid);
                                if (SUCCEEDED(hr))
                                {
                                    if (!PathAppend(szKey, c_szRegStrDESKTOPNAMESPACE))
                                    {
                                        hr = E_FAIL;
                                    }
                                    else
                                    {
                                        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_USERS, szKey, 0, KEY_READ, &hkey))
                                        {
                                            _HideRegItemsFromNameSpace(pszDestPath, hkey);
                                            RegCloseKey(hkey);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    _LoadUnloadHive(HKEY_USERS, pszSid, NULL);
                }
            }
        }
    }

    return hr;
}


HRESULT CCleanupWiz::_AppendDesktopFolderName(LPTSTR pszBuffer)
{
    TCHAR szDesktopPath[MAX_PATH];
    LPTSTR pszDesktopName;

    if (SHGetSpecialFolderPath(NULL, szDesktopPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE))
    {
        pszDesktopName = PathFindFileName(szDesktopPath);
    }
    else
    {
        pszDesktopName = c_szDESKTOP_DIR;
    }

    return PathAppend(pszBuffer, pszDesktopName) ? S_OK : E_FAIL;
}

HRESULT CCleanupWiz::_GetDesktopFolderByRegKey(LPCTSTR pszRegKey, LPCTSTR pszRegValue, LPTSTR szBuffer, DWORD cchBuffer)
{
    HRESULT hr = E_FAIL;
    DWORD cb = cchBuffer * sizeof(TCHAR);
    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, pszRegKey, c_szRegStrPROFILESDIR, NULL, (void*)szBuffer, &cb))
    {
        TCHAR szAppend[MAX_PATH];
        cb = sizeof(szAppend);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, pszRegKey, pszRegValue, NULL, (void*)szAppend, &cb))
        {
            if (PathAppend(szBuffer, szAppend))
            {
                if (SUCCEEDED(_AppendDesktopFolderName(szBuffer)))
                {
                    if (PathAppend(szBuffer, TEXT("*")))
                    {
                        hr = S_OK;
                    }
                }
            }
        }
    }

    return hr;
}

HRESULT CCleanupWiz::_MoveDesktopItems(LPCTSTR pszFrom, LPCTSTR pszTo)
{
    WRITELOG(TEXT("**** MoveDesktopItems: %s %s ****        "), pszFrom, pszTo);
    SHFILEOPSTRUCT fo;
    fo.hwnd = NULL;
    fo.wFunc = FO_MOVE;
    fo.pFrom = pszFrom;
    fo.pTo = pszTo;
    fo.fFlags = FOF_NOCONFIRMATION | FOF_NOCONFIRMMKDIR | FOF_NOCOPYSECURITYATTRIBS | FOF_NOERRORUI | FOF_RENAMEONCOLLISION;
    int iRet = SHFileOperation(&fo);
    return HRESULT_FROM_WIN32(iRet);
}

HRESULT CCleanupWiz::_SilentProcessUserBySid(LPCTSTR pszDestPath, LPCTSTR pszSid)
{
    ASSERT(pszDestPath && *pszDestPath && pszSid && *pszSid);

    HRESULT hr;

    WRITELOG(TEXT("**** SilentProcessUserBySid: %s ****        "), pszSid, TEXT(""));

    TCHAR szTo[MAX_PATH + 1];
    TCHAR szFrom[MAX_PATH + 1];
    hr = StringCchCopy(szTo, ARRAYSIZE(szTo) - 1, pszDestPath);
    if (SUCCEEDED(hr))
    {
        hr = _GetDesktopFolderBySid(pszDestPath, pszSid, szFrom, ARRAYSIZE(szFrom));
        if (SUCCEEDED(hr))
        {
            szFrom[lstrlen(szFrom) + 1] = 0;
            szTo[lstrlen(szTo) + 1] = 0;
            hr = _MoveDesktopItems(szFrom, szTo);
        }
    }

    return hr;
}

HRESULT CCleanupWiz::_SilentProcessUserByRegKey(LPCTSTR pszDestPath, LPCTSTR pszRegKey, LPCTSTR pszRegValue)
{
    ASSERT(pszRegKey && *pszRegKey && pszRegValue && *pszRegValue && pszDestPath && *pszDestPath);

    HRESULT hr;


    TCHAR szTo[MAX_PATH + 1];
    TCHAR szFrom[MAX_PATH + 1];
    hr = StringCchCopy(szTo, ARRAYSIZE(szTo) - 1, pszDestPath);
    if (SUCCEEDED(hr))
    {
        hr = _GetDesktopFolderByRegKey(pszRegKey, pszRegValue, szFrom, ARRAYSIZE(szFrom));
        if (SUCCEEDED(hr))
        {
            szFrom[lstrlen(szFrom) + 1] = 0;
            szTo[lstrlen(szTo) + 1] = 0;
            hr = _MoveDesktopItems(szFrom, szTo);
        }
    }

    return hr;
}


HRESULT CCleanupWiz::_SilentProcessUsers(LPCTSTR pszDestPath)
{
    HRESULT hr = E_FAIL;
    HKEY hkey;    
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegStrPROFILELIST, 0, KEY_READ, &hkey))
    {
        TCHAR szSid[MAX_PATH];
        DWORD dwIndex = 0;
        while (ERROR_SUCCESS == RegEnumKey(hkey, dwIndex++, szSid, ARRAYSIZE(szSid)))
        {
            _SilentProcessUserBySid(pszDestPath, szSid);
        }

        RegCloseKey(hkey);
        hr = S_OK;
    }

    return hr;
}

HRESULT CCleanupWiz::_RunSilent()
{
    HRESULT hr;

    // if we're in silent mode, try to get the special folder name out of the registry, else default to normal name
    DWORD dwType = REG_SZ;
    DWORD cb = sizeof(_szFolderName);

    if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_OEM_PATH, c_szOEM_TITLEVAL, &dwType, _szFolderName, &cb))
    {
        LoadString(g_hInst, IDS_ARCHIVEFOLDER_FIRSTBOOT, _szFolderName, MAX_PATH);
    }

    // assemble the name of the directory we should write to
    TCHAR szPath[MAX_PATH];
    hr = SHGetFolderPath(NULL, CSIDL_PROGRAM_FILES, NULL, SHGFP_TYPE_CURRENT, szPath);
    if (SUCCEEDED(hr))
    {
        if (!PathAppend(szPath, _szFolderName))
        {
            hr = E_FAIL;
        }
        else
        {
            SHCreateDirectoryEx(NULL, szPath, NULL);
            if (!PathIsDirectory(szPath))
            {
                hr = E_FAIL;
            }
            else
            {
                hr = S_OK;

                STARTLOGGING(szPath);

                // Move regitems of All Users
                HKEY hkey;
                if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegStrDESKTOPNAMESPACE, 0, KEY_READ, &hkey))
                {
                    hr = E_FAIL;
                }
                else
                {
                    _HideRegItemsFromNameSpace(szPath, hkey);
                    RegCloseKey(hkey);
                }

                // Move desktop items of All Users
                if (FAILED(_SilentProcessUserByRegKey(szPath, c_szRegStrPROFILELIST, c_szRegStrALLUSERS)))
                {
                    hr = E_FAIL;
                }

                // move desktop items of Default User
                if (FAILED(_SilentProcessUserByRegKey(szPath, c_szRegStrPROFILELIST, c_szRegStrDEFAULTUSER)))
                {
                    hr = E_FAIL;
                }

                // Move desktop items of each normal users
                if (FAILED(_SilentProcessUsers(szPath)))
                {
                    hr = E_FAIL;
                }

                STOPLOGGING;
            }
        }
    }

    return hr;
}

BOOL _ShouldPlaceIEDesktopIcon()
{
    BOOL fRetVal = TRUE;
    
    DWORD dwData;
    DWORD cbData = sizeof(dwData);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegStrPATH_OCMANAGER, c_szRegStrIEACCESS, NULL, &dwData, &cbData)) &&
        (dwData == 0))
    {
        fRetVal = FALSE;
    }
    return fRetVal;
}

BOOL _ShouldUseMSNInternetAccessIcon()
{
    BOOL fRetVal = FALSE;

    TCHAR szBuffer[4];
    DWORD cbBuffer = sizeof(szBuffer);
    if ((ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szRegStrMSNCODES, c_szRegStrMSN_IAONLY, NULL, szBuffer, &cbBuffer)) &&
        (!StrCmpI(szBuffer, TEXT("yes"))))
    {
        fRetVal = TRUE;
    }

    return fRetVal;
}

HRESULT _AddIEIconToDesktop()
{
    DWORD dwData = 0;
    TCHAR szCLSID[MAX_GUID_STRING_LEN];
    TCHAR szBuffer[MAX_PATH];

    HRESULT hr = SHStringFromGUID(CLSID_Internet, szCLSID, ARRAYSIZE(szCLSID));
    if (SUCCEEDED(hr))
    {
        for (int i = 0; i < 2; i ++)
        {
            hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), REGSTR_PATH_HIDDEN_DESKTOP_ICONS, 
                                 (i == 0) ? c_szVALUE_STARTPANEL : c_szVALUE_CLASSICMENU);
            if (SUCCEEDED(hr))
            {
                SHRegSetUSValue(szBuffer, szCLSID, REG_DWORD, &dwData, sizeof(DWORD), SHREGSET_FORCE_HKLM);
            }
        }
    }

    return hr;
}

HRESULT _AddWMPIconToDesktop()
{
    // first set this registry value so if the WMP shortcut creator kicks in after us (it may not, due to timing concerns) it will not delete our shortcut
    SHRegSetUSValue(c_szRegStrWMP_PATH_SETUP, c_szRegStrWMP_REGVALUE, REG_SZ, c_szRegStrYES, sizeof(TCHAR) * (ARRAYSIZE(c_szRegStrYES) + 1), SHREGSET_FORCE_HKLM);

    HRESULT hr;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szSourcePath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];

    // we get docs and settings\all users\start menu\programs
    hr = SHGetSpecialFolderPath(NULL, szSourcePath, CSIDL_COMMON_PROGRAMS, FALSE);
    if (SUCCEEDED(hr))
    {
        // strip it down to docs and settings\all users, using szDestPath as a temp buffer
        hr = StringCchCopy(szDestPath, ARRAYSIZE(szDestPath), szSourcePath);
        if (SUCCEEDED(hr))
        {
            if (!PathRemoveFileSpec(szSourcePath) || // remove Programs
                !PathRemoveFileSpec(szSourcePath)) // remove Start Menu
            {
                hr = E_FAIL;
            }
            else
            {
                hr = StringCchCopy(szBuffer, ARRAYSIZE(szBuffer), szDestPath + lstrlen(szSourcePath));
                if (SUCCEEDED(hr))
                {
                    // load "Default user" into szDestPath
                    LoadString(g_hInst, IDS_DEFAULTUSER, szDestPath, ARRAYSIZE(szDestPath));
                    if (!PathRemoveFileSpec(szSourcePath) ||    // remove All Users, now szSourcePath is "docs and settings"
                        !PathAppend(szSourcePath, szDestPath))  // now szSourcePath is "docs and settings\Default User"

                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        // sanity check, localizers may have inappropriately localized Default User on a system where it shouldn't be localized
                        if (!PathIsDirectory(szSourcePath))
                        {
                            // if so, remove what they gave us and just add the English "Default User", which is what it is on most machines
                            if (!PathRemoveFileSpec(szSourcePath) ||
                                !PathAppend(szSourcePath, c_szRegStrDEFAULTUSER))
                            {
                                hr = E_FAIL;
                            }
                        }

                        if (SUCCEEDED(hr))
                        {
                            if (!PathAppend(szSourcePath, szBuffer))
                            {
                                hr = E_FAIL;
                            }
                            else
                            {
                                // now szSourcePath is docs and settings\Default User\start menu\programs

                                hr = SHGetSpecialFolderPath(NULL, szDestPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE);
                                if (SUCCEEDED(hr))
                                {
                                    LoadString(g_hInst, IDS_WMP, szBuffer, ARRAYSIZE(szBuffer));
                                    if (!PathAppend(szSourcePath, szBuffer) ||
                                        !PathAppend(szDestPath, szBuffer) ||
                                        !CopyFileEx(szSourcePath, szDestPath, 0, 0, 0, COPY_FILE_FAIL_IF_EXISTS))
                                    {
                                        hr = E_FAIL;
                                    }
                                    else
                                    {
                                        hr = S_OK;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    return hr;
}


HRESULT _AddMSNIconToDesktop(BOOL fUseMSNExplorerIcon)
{
    HRESULT hr = E_FAIL;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szSourcePath[MAX_PATH];
    TCHAR szDestPath[MAX_PATH];
    
    if ((SUCCEEDED(SHGetSpecialFolderPath(NULL, szSourcePath, CSIDL_COMMON_PROGRAMS, FALSE))) &&        
        (SUCCEEDED(SHGetSpecialFolderPath(NULL, szDestPath, CSIDL_COMMON_DESKTOPDIRECTORY, FALSE))))
    {            
        if (fUseMSNExplorerIcon)
        {
            LoadString(g_hInst, IDS_MSN, szBuffer, ARRAYSIZE(szBuffer)); // MSN Explorer
        }
        else
        {
            LoadString(g_hInst, IDS_MSN_ALT, szBuffer, ARRAYSIZE(szBuffer)); // Get Online With MSN
        }

        if (PathAppend(szSourcePath, szBuffer) &&
            PathAppend(szDestPath, szBuffer))
        {
            if (CopyFileEx(szSourcePath, szDestPath, 0, 0, 0, COPY_FILE_FAIL_IF_EXISTS))
            {
                hr = S_OK;
            }
        }
    }

    return hr;
}

void CreateDesktopIcons()
{
    BOOL fIEDesktopIcon = _ShouldPlaceIEDesktopIcon();

    _AddWMPIconToDesktop();
    
    if (fIEDesktopIcon)
    {
        _AddIEIconToDesktop();
    }

    _AddMSNIconToDesktop(fIEDesktopIcon || !_ShouldUseMSNInternetAccessIcon());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\grpconv.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#define STRICT
#define _INC_OLE

#include <windows.h>
#include <shlapip.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shsemip.h>
#include <shellp.h>
#include <commdlg.h>
#include <commctrl.h>
#include <comctrlp.h>

//---------------------------------------------------------------------------
// Global to the app.
#define CCHSZSHORT      32
#define CCHSZNORMAL     256

#define MAXGROUPNAMELEN     30  // from progman

extern HINSTANCE g_hinst;
extern TCHAR g_szStartGroup[MAXGROUPNAMELEN + 1];
extern HKEY g_hkeyGrpConv;
extern const TCHAR c_szGroups[];
extern const TCHAR c_szNULL[];
extern const TCHAR c_szSettings[];
extern BOOL g_fDoingCommonGroups;
extern BOOL g_fDoProgmanDde;
extern BOOL g_fShowUI;

#define REGSTR_PATH_EXPLORER_SHELLFOLDERS REGSTR_PATH_EXPLORER TEXT("\\Shell Folders")


// This version of grpconv has to work on win95 and NT4, as well as memphis and NT5.
// Therefore, we have to undef a few things that get #defined to the xxxA and xxxW
// functions so the binary will link to the old shell32.nt4 and shell32.w95 libs.
#undef IsLFNDrive
WINSHELLAPI BOOL WINAPI IsLFNDrive(LPCTSTR pszPath);

#undef SHGetSpecialFolderPath
WINSHELLAPI BOOL WINAPI SHGetSpecialFolderPath(HWND hwndOwner, LPTSTR lpszPath, int nFolder, BOOL fCreate);

#undef PathFindFileName
LPTSTR WINAPI PathFindFileName(LPCTSTR pPath);

#undef PathAppend
BOOL WINAPI PathAppend(LPTSTR pPath, LPNCTSTR pMore);

#undef PathFileExists
BOOL WINAPI PathFileExists(LPCTSTR lpszPath);

#undef PathGetArgs
LPTSTR WINAPI PathGetArgs(LPCTSTR pszPath);

#undef PathUnquoteSpaces
void WINAPI PathUnquoteSpaces(LPTSTR lpsz);

#undef ILCreateFromPath
LPITEMIDLIST WINAPI ILCreateFromPath(LPCTSTR pszPath);

#undef PathRemoveFileSpec
BOOL WINAPI PathRemoveFileSpec(LPTSTR pFile);

#undef PathFindExtension
WINSHELLAPI LPTSTR WINAPI PathFindExtension(LPCTSTR pszPath);
                                                                        
#undef PathAddBackslash
LPTSTR WINAPI PathAddBackslash(LPTSTR lpszPath);

#undef PathIsRoot
BOOL  WINAPI PathIsRoot(LPCTSTR pPath);

#undef PathCombine
LPTSTR WINAPI PathCombine(LPTSTR lpszDest, LPCTSTR lpszDir, LPNCTSTR lpszFile);

#undef PathGetDriveNumber
int WINAPI PathGetDriveNumber(LPNCTSTR lpsz);

#undef PathRemoveBlanks
void WINAPI PathRemoveBlanks(LPTSTR lpszString);

#undef PathIsUNC
BOOL WINAPI PathIsUNC(LPTSTR pszPath);

// from shlguidp.h
DEFINE_GUID(IID_IShellLinkDataList, 0x45e2b4ae, 0xb1c3, 0x11d0, 0xb9, 0x2f, 0x0, 0xa0, 0xc9, 0x3, 0x12, 0xe1);


#ifndef UNICODE
// The current headers will #define this to IID_IShellLinkA if 
// unicode is not defined. This will prevent us from linking to
// the win95 shell32.lib (iedev\lib\chicago\*\shell32.w95) and
// so we just define it here for the ANSI case.
#undef IID_IShellLink
DEFINE_SHLGUID(IID_IShellLink, 0x000214EEL, 0, 0);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\group.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"
#include "util.h"
#include "rcids.h"
#include "group.h"
#include "gcinst.h"
#include <port32.h>
#include <regstr.h>
#define INITGUID
#include <initguid.h>
#pragma data_seg(DATASEG_READONLY)
#include <coguid.h>
#include <oleguid.h>
#pragma data_seg()

#ifdef DEBUG
extern UINT GC_TRACE;
#endif

//---------------------------------------------------------------------------
// Exported.
const TCHAR c_szMapGroups[] = TEXT("MapGroups");
#ifndef WINNT
const TCHAR c_szDelGroups[] = TEXT("DelGroups");
#endif

//---------------------------------------------------------------------------
// Global to this file only;
static const TCHAR c_szGrpConv[] = TEXT("Grpconv");
static const TCHAR c_szLastModDateTime[] = TEXT("LastModDateTime");
static const TCHAR c_szRegistry[] = TEXT("Registry");
static const TCHAR c_szDefaultUser[] = TEXT("DefaultUser");
static const TCHAR c_szGrpConvData[] = TEXT("compat.csv");
static const TCHAR c_szProgmanStartup[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Settings\\Startup");
static const TCHAR c_szDotPif[] = TEXT(".pif");

// New group stuff
HDSA hdsaPMItems;       // current group
HDSA g_hdsaAppList;

HKEY hkeyGroups = NULL;
BOOL g_fDoingCommonGroups = FALSE;


#pragma pack(1)

typedef struct tagRECTS
{
    short left;
    short top;
    short right;
    short bottom;
} RECTS;

typedef struct
    {
    LPTSTR lpszDesc;
    LPTSTR lpszCL;
    LPTSTR lpszWD;
    LPTSTR lpszIconPath;
    WORD wiIcon;
    WORD wHotKey;
    int nShowCmd;
#ifdef WINNT
    BOOL bSepVdm;
#endif
    }   PMITEM, *PPMITEM, *LPPMITEM;

// Old Progman stuff.
#define GROUP_MAGIC    0x43434D50L  // 'PMCC'
#define GROUP_UNICODE  0x43554D50L  // 'PMUC'

/*
 * Win 3.1 .GRP file formats (ITEMDEF for items, GROUPDEF for groups)
 */
typedef struct
    {
    POINTS        pt;
    WORD          iIcon;
    WORD          cbHeader;
    WORD          cbANDPlane;
    WORD          cbXORPlane;
    WORD          pHeader;
    WORD          pANDPlane;
    WORD          pXORPlane;
    WORD          pName;
    WORD          pCommand;
    WORD          pIconPath;
    } ITEMDEF, *PITEMDEF, *LPITEMDEF;

typedef struct
    {
    DWORD     dwMagic;
    WORD      wCheckSum;
    WORD      cbGroup;
    WORD      nCmdShow;
    RECTS     rcNormal;
    POINTS    ptMin;
    WORD      pName;
    WORD      cxIcon;
    WORD      cyIcon;
    WORD      wIconFormat;
    WORD      wReserved;
    WORD      cItems;
    } GROUPDEF, *PGROUPDEF, *LPGROUPDEF;

typedef struct
    {
    WORD wID;
    WORD wItem;
    WORD cb;
    } PMTAG, *PPMTAG, *LPPMTAG;

// Thank God the tag stuff never really caught on.
#define TAG_MAGIC GROUP_MAGIC
#define ID_MAINTAIN                 0x8000
#define ID_MAGIC                    0x8000
#define ID_WRITERVERSION        0x8001
#define ID_APPLICATIONDIR       0x8101
#define ID_HOTKEY                   0x8102
#define ID_MINIMIZE                 0x8103
#ifdef WINNT
#define ID_NEWVDM                   0x8104
#endif
#define ID_LASTTAG                  0xFFFF

/*
 * NT 3.1 Ansi .GRP File format structures
 */
typedef struct tagGROUPDEF_A {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    nCmdShow;       /* min, max, or normal state */
    WORD    pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    rgiItems[1];    /* array of ITEMDEF offsets */
} NT_GROUPDEF_A, *PNT_GROUPDEF_A;
typedef NT_GROUPDEF_A *LPNT_GROUPDEF_A;

typedef struct tagITEMDEF_A {
    POINT   pt;             /* location of item icon in group */
    WORD    idIcon;         /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    indexIcon;      /* index of item icon */
    WORD    dummy2;         /* - not used anymore */
    WORD    pIconRes;       /* offset of icon resource */
    WORD    dummy3;         /* - not used anymore */
    WORD    pName;          /* offset of name string */
    WORD    pCommand;       /* offset of command string */
    WORD    pIconPath;      /* offset of icon path */
} NT_ITEMDEF_A, *PNT_ITEMDEF_A;
typedef NT_ITEMDEF_A *LPNT_ITEMDEF_A;

/*
 * NT 3.1a Unicode .GRP File format structures
 */
typedef struct tagGROUPDEF {
    DWORD   dwMagic;        /* magical bytes 'PMCC' */
    DWORD   cbGroup;        /* length of group segment */
    RECT    rcNormal;       /* rectangle of normal window */
    POINT   ptMin;          /* point of icon */
    WORD    wCheckSum;      /* adjust this for zero sum of file */
    WORD    nCmdShow;       /* min, max, or normal state */
    DWORD   pName;          /* name of group */
                            /* these four change interpretation */
    WORD    cxIcon;         /* width of icons */
    WORD    cyIcon;         /* hieght of icons */
    WORD    wIconFormat;    /* planes and BPP in icons */
    WORD    wReserved;      /* This word is no longer used. */

    WORD    cItems;         /* number of items in group */
    WORD    Reserved1;
    DWORD   Reserved2;
    DWORD   rgiItems[1];    /* array of ITEMDEF offsets */
} NT_GROUPDEF, *PNT_GROUPDEF;
typedef NT_GROUPDEF *LPNT_GROUPDEF;

typedef struct tagITEMDEF {
    POINT   pt;             /* location of item icon in group */
    WORD    iIcon;          /* id of item icon */
    WORD    wIconVer;       /* icon version */
    WORD    cbIconRes;      /* size of icon resource */
    WORD    wIconIndex;     /* index of the item icon (not the same as the id) */
    DWORD   pIconRes;       /* offset of icon resource */
    DWORD   pName;          /* offset of name string */
    DWORD   pCommand;       /* offset of command string */
    DWORD   pIconPath;      /* offset of icon path */
} NT_ITEMDEF, *PNT_ITEMDEF;
typedef NT_ITEMDEF *LPNT_ITEMDEF;

typedef struct _tag
  {
    WORD wID;                   // tag identifier
    WORD dummy1;                // need this for alignment!
    int wItem;                  // (unde the covers 32 bit point!)item the tag belongs to
    WORD cb;                    // size of record, including id and count
    WORD dummy2;                // need this for alignment!
    BYTE rgb[1];
  } NT_PMTAG, * LPNT_PMTAG;

/* the pointers in the above structures are short pointers relative to the
 * beginning of the segments.  This macro converts the short pointer into
 * a long pointer including the proper segment/selector value.        It assumes
 * that its argument is an lvalue somewhere in a group segment, for example,
 * PTR(lpgd->pName) returns a pointer to the group name, but k=lpgd->pName;
 * PTR(k) is obviously wrong as it will use either SS or DS for its segment,
 * depending on the storage class of k.
 */
#define PTR(base, offset) (LPBYTE)((PBYTE)base + offset)

/* PTR2 is used for those cases where a variable already contains an offset
 * (The "case that doesn't work", above)
 */
#define PTR2(lp,offset) ((LPBYTE)MAKELONG(offset,HIWORD(lp)))

/* this macro is used to retrieve the i-th item in the group segment.  Note
 * that this pointer will NOT be NULL for an unused slot.
 */
#define ITEM(lpgd,i) ((LPNT_ITEMDEF)PTR(lpgd, lpgd->rgiItems[i]))

/* Keeping things starting on aligned boundaries allows faster access on
 * most platforms.
 */
#define MyDwordAlign(size)  (((size) + 3) & ~3)

#pragma pack()


#define CFree(a)    if(a) Free(a)

//---------------------------------------------------------------------------
#define Stream_Write(ps, pv, cb)    SUCCEEDED((ps)->lpVtbl->Write(ps, pv, cb, NULL))
#define Stream_Close(ps)            (void)(ps)->lpVtbl->Release(ps)

#define VOF_BAD     0
#define VOF_WIN31   1
#define VOF_WINNT   2

int ConvertToUnicodeGroup(LPNT_GROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup);


//---------------------------------------------------------------------------
// Init the group stuff
BOOL ItemList_Create(LPCTSTR lpszGroup)
{
    if (!hdsaPMItems)
            hdsaPMItems = DSA_Create(SIZEOF(PMITEM), 16);

        if (hdsaPMItems)
                return TRUE;

        DebugMsg(DM_ERROR, TEXT("cg.gi: Unable to init."));
        return FALSE;
}

//---------------------------------------------------------------------------
// Tidyup.
void ItemList_Destroy(void)
{
        int i;
        int cItems;
        LPPMITEM lppmitem;

        // Clean up the items.
        cItems = DSA_GetItemCount(hdsaPMItems);
        for(i=0; i < cItems; i++)
        {
                lppmitem = DSA_GetItemPtr(hdsaPMItems, 0);
                // Nuke the strings.
                CFree(lppmitem->lpszDesc);
                CFree(lppmitem->lpszCL);
                CFree(lppmitem->lpszWD);
                CFree(lppmitem->lpszIconPath);
                // Nuke the structure.
                DSA_DeleteItem(hdsaPMItems, 0);
        }
        DSA_Destroy(hdsaPMItems);
        hdsaPMItems = NULL;
}

//---------------------------------------------------------------------------
// Returns TRUE if the file smells like an old PM group, the title of the
// group is returned in lpszTitle which must be at least 32 chars big.
// REVIEW - Is it worth checking the checksum?
UINT Group_ValidOldFormat(LPCTSTR lpszOldGroup, LPTSTR lpszTitle)
    {
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE  fh;
#endif
    UINT nCode;
    GROUPDEF grpdef;

    // Find and open the group file.
#ifdef UNICODE
    fh = CreateFile(
             lpszOldGroup,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh != INVALID_HANDLE_VALUE)
#else
    fh = _lopen(lpszOldGroup, OF_READ | OF_SHARE_DENY_NONE);
    if (fh != HFILE_ERROR)
#endif
        {
        // Get the definition.
#ifdef UNICODE
        ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL);
#else
        _lread(fh, &grpdef, SIZEOF(grpdef));
#endif

        // Does it have the right magic bytes?.
        switch( grpdef.dwMagic )
            {
            case GROUP_UNICODE:
                {
                    NT_GROUPDEF nt_grpdef;

#ifdef UNICODE
                    SetFilePointer(fh, 0, NULL, FILE_BEGIN);
                    ReadFile(fh, &nt_grpdef, SIZEOF(nt_grpdef), &dwBytesRead, NULL);
#else
                    _llseek(fh, 0, 0);      // Back to the start
                    _lread(fh, &nt_grpdef, SIZEOF(nt_grpdef));
#endif

                    // Yep, Get it's size..
                    // Is it at least as big as the header says it is?
#ifdef UNICODE
                    if ( nt_grpdef.cbGroup <= (DWORD)SetFilePointer(fh, 0L, NULL,  FILE_END))
#else
                    if ( nt_grpdef.cbGroup <= (DWORD)_llseek(fh, 0L, 2))
#endif
                    {
                        WCHAR wchGroupName[MAXGROUPNAMELEN+1];

                        // Yep, probably valid.
                        // Get its title.
#ifdef UNICODE
                        SetFilePointer(fh, nt_grpdef.pName, 0, FILE_BEGIN);
                        ReadFile(fh, wchGroupName, SIZEOF(wchGroupName), &dwBytesRead, NULL);
                        lstrcpy(lpszTitle, wchGroupName);
#else
                        _llseek(fh, nt_grpdef.pName, 0);
                        _lread(fh,wchGroupName, SIZEOF(wchGroupName));
                        WideCharToMultiByte (CP_ACP, 0, wchGroupName, -1,
                                         lpszTitle, MAXGROUPNAMELEN+1, NULL, NULL);
#endif
                        nCode = VOF_WINNT;
                    }
                    else
                    {
                        // No. Too small.
                        DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid size."));
                        nCode = VOF_BAD;
                    }
                }
                break;
            case GROUP_MAGIC:
                {
                CHAR chGroupName[MAXGROUPNAMELEN+1];
                // Yep, Get it's size..
                // Is it at least as big as the header says it is?
#ifdef UNICODE
                if (grpdef.cbGroup <= (WORD) SetFilePointer(fh, 0L, NULL, FILE_END))
#else
                if (grpdef.cbGroup <= (WORD) _llseek(fh, 0L, 2))
#endif
                    {
                    // Check to make sure there is a name embedded in the
                    // .grp file.  If not, just use the filename
                    if (grpdef.pName==0)
                        {
                        LPTSTR lpszFile, lpszExt, lpszDest = lpszTitle;

                        lpszFile = PathFindFileName( lpszOldGroup );
                        lpszExt  = PathFindExtension( lpszOldGroup );
                        for( ;
                             lpszFile && lpszExt && (lpszFile != lpszExt);
                             *lpszDest++ = *lpszFile++
                            );
                        *lpszDest = TEXT('\0');

                        }
                    else
                        {

                        // Yep, probably valid.
                        // Get it's title.
#ifdef UNICODE
                        SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
                        ReadFile(fh, chGroupName, MAXGROUPNAMELEN+1, &dwBytesRead, NULL);
                        MultiByteToWideChar(
                            CP_ACP,
                            MB_PRECOMPOSED,
                            chGroupName,
                            -1,
                            lpszTitle,
                            MAXGROUPNAMELEN+1
                            ) ;
#else
                        _llseek(fh, grpdef.pName, 0);
                        _lread(fh, lpszTitle, MAXGROUPNAMELEN+1);
#endif
                        }

                    nCode = VOF_WIN31;
                    }
                else
                    {
                    // No. Too small.
                    DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid size."));
                    nCode = VOF_BAD;
                    }
                break;
                }

            default:
                // No, the magic bytes are wrong.
                DebugMsg(DM_TRACE, TEXT("gc.gvof: File has invalid magic bytes."));
                nCode = VOF_BAD;
                break;
            }
#ifdef UNICODE
        CloseHandle(fh);
#else
        _lclose(fh);
#endif
        }
    else
        {
        // No. Can't even read the file.
        DebugMsg(DM_TRACE, TEXT("gc.gvof: File is unreadble."));
        nCode = VOF_BAD;
        }

    return nCode;
    }

BOOL _IsValidFileNameChar(TBYTE ch, UINT flags)
{
    switch (ch) {
    case TEXT('\\'):      // path separator
        return flags & PRICF_ALLOWSLASH;
    case TEXT(';'):       // terminator
    case TEXT(','):       // terminator
    case TEXT('|'):       // pipe
    case TEXT('>'):       // redir
    case TEXT('<'):       // redir
    case TEXT('"'):       // quote
    case TEXT('?'):       // wc           we only do wilds here because they're
    case TEXT('*'):       // wc           legal for qualifypath
    case TEXT(':'):       // drive colon
    case TEXT('/'):       // path sep
        return FALSE;
    }

    // Can not be a control char...
    return ch >= TEXT(' ');
}


void PathRemoveIllegalChars(LPTSTR pszPath, int iGroupName, UINT flags)
{
    LPTSTR pszT = pszPath + iGroupName;

    // Map all of the strange characters out of the name for both LFn and not
    // machines
    while (*pszT)
    {
        if (!_IsValidFileNameChar(*pszT, flags))
            *pszT = TEXT('_');        // Don't Allow invalid chars in names
        pszT = CharNext(pszT);
    }
}

//---------------------------------------------------------------------------
// We want certain groups to end up in a new location eg Games is now
// Applications\Games.
void MapGroupTitle(LPCTSTR lpszOld, LPTSTR lpszNew, UINT cchNew)
{
    // Is there a mapping?
    if (!Reg_GetString(g_hkeyGrpConv, c_szMapGroups, lpszOld, lpszNew, cchNew*sizeof(TCHAR)))
    {
        // Nope, just use the given name.
        lstrcpyn(lpszNew, lpszOld, cchNew);
    }
    DebugMsg(DM_TRACE, TEXT("gc.mgr: From %s to %s"), lpszOld, lpszNew);
}

#undef PathRemoveExtension
//---------------------------------------------------------------------------
void PathRemoveExtension(LPTSTR pszPath)
{
    LPTSTR pExt = PathFindExtension(pszPath);
    if (*pExt)
    {
        Assert(*pExt == TEXT('.'));
        *pExt = 0;    // null out the "."
    }
}

//---------------------------------------------------------------------------
// Given a path to an old group, create and return a path to where the new
// group will be.
BOOL Group_GenerateNewGroupPath(HWND hwnd, LPCTSTR lpszOldGrpTitle,
    LPTSTR lpszNewGrpPath, LPCTSTR pszOldGrpPath)
{
    int iLen;
    TCHAR szGrpTitle[MAX_PATH];
    TCHAR szOldGrpTitle[32];


    // Get the location for all the special shell folders.
    if (g_fDoingCommonGroups)
        SHGetSpecialFolderPath(hwnd, lpszNewGrpPath, CSIDL_COMMON_PROGRAMS, TRUE);
    else
        SHGetSpecialFolderPath(hwnd, lpszNewGrpPath, CSIDL_PROGRAMS, TRUE);


    if (IsLFNDrive(lpszNewGrpPath))
    {
        // Fix it a bit.
        lstrcpyn(szOldGrpTitle, lpszOldGrpTitle, ARRAYSIZE(szOldGrpTitle));
        PathRemoveIllegalChars(szOldGrpTitle, 0, PRICF_NORMAL);
        // Munge the names so that things move to the new locations.
        MapGroupTitle(szOldGrpTitle, szGrpTitle, ARRAYSIZE(szGrpTitle));
        // Stick on the new group name.
        PathAddBackslash(lpszNewGrpPath);
        iLen = lstrlen(lpszNewGrpPath);
        // NB Don't use PathAppend() - very bad if there's a colons in the title.
        lstrcpyn(lpszNewGrpPath+iLen, szGrpTitle, MAX_PATH-iLen);
        PathRemoveIllegalChars(lpszNewGrpPath, iLen, PRICF_ALLOWSLASH);
    }
    else
    {
        // Just use the old group file name - this will make sure the group
        // names remain unique.
        PathAppend(lpszNewGrpPath, PathFindFileName(pszOldGrpPath));
        PathRemoveExtension(lpszNewGrpPath);
    }

    if (!PathFileExists(lpszNewGrpPath))
    {
        // Folder doesn't exist.
        // return Win32CreateDirectory(lpszNewGrpPath, NULL);
        return (SHCreateDirectory(hwnd, lpszNewGrpPath) == 0);
    }

    // Folder already exists.
    return TRUE;
}

//---------------------------------------------------------------------------
// Returns true if the offsets given in the item def are valid-ish.
BOOL CheckItemDef(LPITEMDEF lpitemdef, WORD cbGroup)
    {
    if (lpitemdef->pHeader < cbGroup && lpitemdef->pANDPlane < cbGroup &&
        lpitemdef->pXORPlane < cbGroup && lpitemdef->pName < cbGroup &&
        lpitemdef->pCommand < cbGroup && lpitemdef->pIconPath < cbGroup &&
        lpitemdef->pHeader && lpitemdef->pXORPlane && lpitemdef->pCommand)
        return TRUE;
    else
        {
        return FALSE;
        }
    }

//---------------------------------------------------------------------------
// Returns true if the offsets given in the item def are valid-ish.
BOOL CheckItemDefNT(LPNT_ITEMDEF lpitemdef, DWORD cbGroup)
    {
    if (lpitemdef->pName < cbGroup &&
        lpitemdef->pCommand < cbGroup &&
        lpitemdef->pIconPath < cbGroup &&
        lpitemdef->pCommand)
        return TRUE;
    else
        {
        return FALSE;
        }
    }

//---------------------------------------------------------------------------
// Read the tags info from the given file handle from the given offset.
#ifdef UNICODE
void HandleTags(HANDLE fh, WORD oTags)
#else
void HandleTags(int fh, WORD oTags)
#endif
{
    LONG cbGroupReal;
    PMTAG pmtag;
    BOOL fTags = TRUE;
    TCHAR szText[MAX_PATH];
    BOOL fFirstTag = FALSE;
    LPPMITEM lppmitem;
    WORD wHotKey;
#ifdef UNICODE
    DWORD      dwBytesRead;
#endif

    DebugMsg(DM_TRACE, TEXT("cg.ht: Reading tags."));
#ifdef UNICODE
    cbGroupReal = SetFilePointer(fh, 0, NULL, FILE_END);
#else
    cbGroupReal = (WORD) _llseek(fh, 0L, 2);
#endif
    if (cbGroupReal <= (LONG) oTags)
    {
        // No tags in this file.
        return;
    }

    // Get to the tags section.
#ifdef UNICODE
    SetFilePointer(fh, oTags, NULL, FILE_BEGIN);
#else
    _llseek(fh, oTags, 0);
#endif
    while (fTags)
    {
#ifdef UNICODE
        if (!ReadFile(fh, &pmtag, SIZEOF(pmtag), &dwBytesRead, NULL) || dwBytesRead == 0) {
            fTags = FALSE;
            break;
        }
#else
        fTags = _lread(fh, &pmtag, SIZEOF(pmtag));
#endif
        switch (pmtag.wID)
        {
            case ID_MAGIC:
            {
//                DebugMsg(DM_TRACE, "gc.ht: First tag found.");
                fFirstTag = TRUE;
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
            case ID_LASTTAG:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Last tag found.");
                fTags = FALSE;
                break;
            }
            case ID_APPLICATIONDIR:
            {
//                DebugMsg(DM_TRACE, "gc.ht: App dir %s found for %d.", (LPSTR) szText, pmtag.wItem);
                fgets(szText, ARRAYSIZE(szText), fh);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    Str_SetPtr(&lppmitem->lpszCL, szText);
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                break;
            }
            case ID_HOTKEY:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Hotkey found for %d.", pmtag.wItem);
#ifdef UNICODE
                ReadFile(fh, &wHotKey, SIZEOF(wHotKey), &dwBytesRead, NULL);
#else
                _lread(fh, &wHotKey, SIZEOF(wHotKey));
#endif
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->wHotKey = wHotKey;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                break;
            }
            case ID_MINIMIZE:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Minimise flag found for %d.", pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->nShowCmd = SW_SHOWMINNOACTIVE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
#ifdef WINNT
            case ID_NEWVDM:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Separate VDM flag found for %d.", pmtag.wItem );
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->bSepVdm = TRUE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
#ifdef UNICODE
                SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                break;
            }
#endif
            default:
            {
                // We've found something we don't understand but we haven't
                // found the first tag yet - probably a bust file.
                if (!fFirstTag)
                {
                    DebugMsg(DM_TRACE, TEXT("gc.ht: No initial tag found - tags section is corrupt."));
                    fTags = FALSE;
                }
                else
                {
                    // Some unknown tag.
                    if (pmtag.cb < SIZEOF(PMTAG))
                    {
                        // Can't continue!
                        DebugMsg(DM_TRACE, TEXT("gc.ht: Tag has invalid size - ignoring remaining tags."));
                        fTags = FALSE;
                    }
                    else
                    {
                        // Just ignore its data and continue.
#ifdef UNICODE
                        SetFilePointer(fh, pmtag.cb - SIZEOF(PMTAG), NULL, FILE_CURRENT);
#else
                        _llseek(fh, pmtag.cb - SIZEOF(PMTAG), 1);
#endif
                    }
                }
                break;
            }
        }
    }
}

//---------------------------------------------------------------------------
// Read the tags info from the given file handle from the given offset.
#ifdef UNICODE
void HandleTagsNT(HANDLE fh, DWORD oTags)
#else
void HandleTagsNT(int fh, DWORD oTags)
#endif
{
    DWORD cbGroupReal;
    DWORD dwPosition;
    NT_PMTAG pmtag;
    BOOL fTags = TRUE;
    WCHAR wszTemp[MAX_PATH];
    TCHAR szText[MAX_PATH];
    BOOL fFirstTag = FALSE;
    LPPMITEM lppmitem;
    WORD wHotKey;
#ifdef UNICODE
    DWORD dwBytesRead;
#endif

    DebugMsg(DM_TRACE, TEXT("cg.ht: Reading tags."));
#ifdef UNICODE
    cbGroupReal = SetFilePointer(fh, 0, NULL, FILE_END);
#else
    cbGroupReal = _llseek(fh, 0L, 2);
#endif
    if (cbGroupReal <= oTags)
    {
        // No tags in this file.
        return;
    }

    // Get to the tags section.
    dwPosition = oTags;
    while (fTags)
    {
#ifdef UNICODE
        SetFilePointer(fh, dwPosition, NULL, FILE_BEGIN);
        if (!ReadFile(fh, &pmtag, SIZEOF(pmtag), &dwBytesRead, NULL) || dwBytesRead == 0) {
            fTags = FALSE;
            break;
        }

#else
        _llseek(fh,dwPosition,0);
        fTags = _lread(fh, &pmtag, SIZEOF(pmtag));
#endif
        switch (pmtag.wID)
        {
            case ID_MAGIC:
            {
//                DebugMsg(DM_TRACE, "gc.ht: First tag found.");
                fFirstTag = TRUE;
                dwPosition += pmtag.cb;
                break;
            }
            case ID_LASTTAG:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Last tag found.");
                fTags = FALSE;
                break;
            }
            case ID_APPLICATIONDIR:
            {
#ifdef UNICODE
                SetFilePointer(fh, dwPosition+FIELD_OFFSET(NT_PMTAG,rgb[0]), NULL, FILE_BEGIN);
                ReadFile(fh, wszTemp, SIZEOF(wszTemp), &dwBytesRead, NULL);
                lstrcpy(szText, wszTemp);
#else
                _llseek(fh,dwPosition+FIELD_OFFSET(NT_PMTAG,rgb[0]),0);
                _lread(fh,wszTemp,SIZEOF(wszTemp));
                WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                                 szText, ARRAYSIZE(szText), NULL, NULL);
#endif
//                DebugMsg(DM_TRACE, "gc.ht: App dir %s found for %d.", (LPSTR) szText, pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    Str_SetPtr(&lppmitem->lpszCL, szText);
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                dwPosition += pmtag.cb;
                break;
            }
            case ID_HOTKEY:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Hotkey found for %d.", pmtag.wItem);
#ifdef UNICODE
                ReadFile(fh, &wHotKey, SIZEOF(wHotKey), &dwBytesRead, NULL);
#else
                _lread(fh, &wHotKey, SIZEOF(wHotKey));
#endif
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->wHotKey = wHotKey;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                dwPosition += pmtag.cb;
                break;
            }
            case ID_MINIMIZE:
            {
//                DebugMsg(DM_TRACE, "gc.ht: Minimise flag found for %d.", pmtag.wItem);
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->nShowCmd = SW_SHOWMINNOACTIVE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
                dwPosition += pmtag.cb;
                break;
            }
#ifdef WINNT
            case ID_NEWVDM:
            {
                // DebugMsg(DM_TRACE, "gc.ht: Separate VDM flag found for %d.", pmtag.wItem );
                lppmitem = DSA_GetItemPtr(hdsaPMItems, pmtag.wItem);
                if (lppmitem)
                {
                    lppmitem->bSepVdm = TRUE;
                }
#ifdef DEBUG
                else
                {
                    DebugMsg(DM_ERROR, TEXT("gc.ht: Item is invalid."));
                }
#endif
                // Skip to the next tag.
                dwPosition += pmtag.cb;
                break;
            }
#endif
            default:
            {
                // We've found something we don't understand but we haven't
                // found the first tag yet - probably a bust file.
                if (!fFirstTag)
                {
                    DebugMsg(DM_TRACE, TEXT("gc.ht: No initial tag found - tags section is corrupt."));
                    fTags = FALSE;
                }
                else
                {
                    // Some unknown tag.
                    if (pmtag.cb < SIZEOF(PMTAG))
                    {
                        // Can't continue!
                        DebugMsg(DM_TRACE, TEXT("gc.ht: Tag has invalid size - ignoring remaining tags."));
                        fTags = FALSE;
                    }
                    else
                    {
                        // Just ignore its data and continue.
                        dwPosition += pmtag.cb;
                    }
                }
                break;
            }
        }
    }
}

//---------------------------------------------------------------------------
void DeleteBustedItems(void)
{
    int i, cItems;
    LPPMITEM ppmitem;


    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        ppmitem = DSA_GetItemPtr(hdsaPMItems, i);
        // Is the item broken?
        if (!ppmitem->lpszDesc || !(*ppmitem->lpszDesc))
        {
            // Yep, delete it.
            DSA_DeleteItem(hdsaPMItems, i);
            cItems--;
            i--;
        }
    }
}

//---------------------------------------------------------------------------
void ShortenDescriptions(void)
{
    int i, cItems;
    LPPMITEM ppmitem;

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        ppmitem = DSA_GetItemPtr(hdsaPMItems, i);
        // Shorten the descriptions
        lstrcpyn(ppmitem->lpszDesc, ppmitem->lpszDesc, 9);
    }
}

//---------------------------------------------------------------------------
// Kinda like PathFindFileName() but handles things like c:\foo\ differently
// to match progmans code.
LPTSTR WINAPI _PathFindFileName(LPCTSTR pPath)
{
    LPCTSTR pT;

    for (pT = pPath; *pPath; pPath = CharNext(pPath)) {
        if ((pPath[0] == TEXT('\\') || pPath[0] == TEXT(':')) && (pPath[1] != TEXT('\\')))
            pT = pPath + 1;
    }

    return (LPTSTR)pT;   // const -> non const
}

//---------------------------------------------------------------------------
// Take a 3.1 format WD and exe and convert them to the new style.
// NB Old style was WD+exename and exepath - new style is exepath+exename and
// WD.
void MungePaths(void)
{
    LPTSTR lpszFileName;         // Ptr to filename part (plus params).
    LPTSTR lpszParams;           // Ptr to first char of params.
    TCHAR szCL[MAX_PATH];
    TCHAR szWD[MAX_PATH];
    int i, cItems;
    LPPMITEM lppmitem;


    cItems = DSA_GetItemCount(hdsaPMItems);

    for (i=0; i<cItems; i++)
    {
        szCL[0] = TEXT('\0');
        szWD[0] = TEXT('\0');
        lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

        // Get the current command line.
        Str_GetPtr(lppmitem->lpszCL, szCL, ARRAYSIZE(szCL));
        // Get the current working dir.
        Str_GetPtr(lppmitem->lpszWD, szWD, ARRAYSIZE(szWD));
#ifdef OLDWAY
        // Find the filename part...
        // Params will confuse PFFN.
        lpszParams = PathGetArgs(szWD);
        if (*lpszParams)
        {
            // Chop them off.
            // NB Previous char is a space by definition.
            *(lpszParams-1) = TEXT('\0');
            lpszFileName = _PathFindFileName(szWD);
            // Put them back
            *(lpszParams-1) = TEXT(' ');
        }
        else
        {
            // No params.
            lpszFileName = PathFindFileName(szWD);
        }
        // Copy this onto the exe path.
        lstrcat((LPTSTR) szCL, lpszFileName);
        // Remove it from the end of the WD.
        *lpszFileName = TEXT('\0');
        // For anything but things like c:\ remove the last slash.
        if (!PathIsRoot(szWD))
        {
            *(lpszFileName-1) = TEXT('\0');
        }
#else
        lpszFileName = szWD;

        if (*lpszFileName == TEXT('"'))
        {
            while (lpszFileName)
            {
                lpszFileName = StrChr(lpszFileName+1,TEXT('"'));
                if (!lpszFileName)
                {
                    //
                    // The directory is not in quotes and since the command
                    // path starts with a quote, there is no working directory.
                    //
                    lpszFileName = szWD;
                    break;
                }
                if (*(lpszFileName+1) == TEXT('\\'))
                {
                    //
                    // The working directory is in quotes.
                    //
                    lpszFileName++;
                    break;
                }
            }
        }
        else
        {
            //
            // if there's a working directory, it is not in quotes
            // Copy up until the last \ preceding any quote, space, or the end
            //
            LPTSTR lpEnd = lpszFileName;

            while (*lpszFileName && *lpszFileName != TEXT('"') && *lpszFileName != TEXT(' '))
            {
                if ((*lpszFileName == TEXT('\\') || *lpszFileName == TEXT(':')) && *(lpszFileName+1) != TEXT('\\'))
                    lpEnd = lpszFileName;
                lpszFileName = CharNext(lpszFileName);
            }
            lpszFileName = lpEnd;
        }
        //
        // If the split is at the beginning,
        // then there is no working dir
        //
        if (lpszFileName == szWD)
        {
            lstrcat(szCL, szWD);
            szWD[0] = TEXT('\0');
        }
        else
        {
            lstrcat(szCL, lpszFileName+1);
            *(lpszFileName+1) = TEXT('\0');        // Split it.

            //
            // Remove quotes from the working dir NOW.
            //
            if (szWD[0] == TEXT('"')) {
               LPTSTR lpTemp;

               for (lpTemp = szWD+1; *lpTemp && *lpTemp != TEXT('"'); lpTemp++)
                  *(lpTemp-1) = *lpTemp;

               if (*lpTemp == TEXT('"')) {
                  *(lpTemp-1) = TEXT('\0');
               }
            }

            // For anything but things like c:\ remove the last slash.
            if (!PathIsRoot(szWD))
            {
                *lpszFileName = TEXT('\0');
            }
        }
#endif

        // Replace the data.
        Str_SetPtr(&lppmitem->lpszCL, szCL);
        Str_SetPtr(&lppmitem->lpszWD, szWD);

        // DebugMsg(DM_TRACE, "gc.mp: Exe %s, WD %s", (LPSTR)szCL, (LPSTR)szWD);
    }
}


//---------------------------------------------------------------------------
// Set all the fields of the given pmitem to clear;
void PMItem_Clear(LPPMITEM lppmitem)
    {
    lppmitem->lpszDesc = NULL;
    lppmitem->lpszCL = NULL;
    lppmitem->lpszWD = NULL;
    lppmitem->lpszIconPath = NULL;
    lppmitem->wiIcon = 0;
    lppmitem->wHotKey = 0;
    lppmitem->nShowCmd = SW_SHOWNORMAL;
#ifdef WINNT
    lppmitem->bSepVdm = FALSE;
#endif
    }

//---------------------------------------------------------------------------
// Read the item data from the file and add it to the list.
// Returns TRUE if everything went perfectly.
#ifdef UNICODE
BOOL GetAllItemData(HANDLE fh, WORD cItems, WORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#else
BOOL GetAllItemData(HFILE fh, WORD cItems, WORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#endif
{
    UINT cbItemArray;
    WORD *rgItems;
    UINT i, iItem;
    TCHAR szDesc[CCHSZNORMAL];
    TCHAR szCL[CCHSZNORMAL];
    TCHAR szIconPath[CCHSZNORMAL];
    ITEMDEF itemdef;
    BOOL fOK = TRUE;
    UINT cbRead;
    PMITEM pmitem;
#ifdef UNICODE
    DWORD dwBytesRead;
#endif

    // Read in the old item table...
    iItem = 0;
    cbItemArray = cItems * SIZEOF(*rgItems);
    rgItems = (WORD *)LocalAlloc(LPTR, cbItemArray);
    if (!rgItems)
    {
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Out of memory."));
        return FALSE;
    }
#ifdef UNICODE
    SetFilePointer(fh, SIZEOF(GROUPDEF), NULL, FILE_BEGIN);
    ReadFile(fh, rgItems, cbItemArray, &dwBytesRead, NULL);
#else
    _llseek(fh, SIZEOF(GROUPDEF), 0);
    _lread(fh, rgItems, cbItemArray);
#endif

    // Show progress in two stages, first reading then writing.
    Group_SetProgressNameAndRange(lpszNewGrpPath, (cItems*2)-1);

    // Read in the items.
    // NB Don't just skip busted items since the tag data contains
    // indices to items and that includes busted ones. Just use
    // an empty description to indicate that the link is invalid.
    for (i=0; i<cItems; i++)
    {
        Group_SetProgress(i);

        szDesc[0] = TEXT('\0');
        szCL[0] = TEXT('\0');
        szIconPath[0] = TEXT('\0');
        itemdef.iIcon = 0;

        if (rgItems[i] == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file has empty item definition - skipping."));
            goto AddItem;
        }
        if (rgItems[i] > cbGroup)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (item entry in invalid part of file) - skipping item."));
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, rgItems[i], NULL, FILE_BEGIN);
        ReadFile(fh, &itemdef, SIZEOF(itemdef), &cbRead, NULL);
#else
        _llseek(fh, rgItems[i], 0);
        cbRead = _lread(fh, &itemdef, SIZEOF(itemdef));
#endif
        if (cbRead != SIZEOF(itemdef))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid definition) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
        if (!CheckItemDef(&itemdef, cbGroup))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid item field) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pName, NULL, FILE_BEGIN);
#else
        _llseek(fh, itemdef.pName, 0);
#endif
        fgets(szDesc, SIZEOF(szDesc), fh);
        if (!*szDesc)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty name) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pCommand, NULL, FILE_BEGIN);
#else
        _llseek(fh, itemdef.pCommand, 0);
#endif
        fgets(szCL, SIZEOF(szCL), fh);

// We hit this case with links to c:\ (rare, very rare).
#if 0
        if (!*szCL)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty command line) - skipping item %d."), i);
            // We use a null description to signal a problem with this item.
            szDesc[0] = TEXT('\0');
            fOK = FALSE;
            goto AddItem;
        }
#endif

        if (itemdef.pIconPath!=0xFFFF)
        {
#ifdef UNICODE
            SetFilePointer(fh, itemdef.pIconPath, NULL, FILE_BEGIN);
#else
            _llseek(fh, itemdef.pIconPath, 0);
#endif
            fgets(szIconPath, SIZEOF(szIconPath), fh);
        }
        else
        {
            szIconPath[ 0 ] = TEXT('\0');
        }

        if (!*szIconPath)
        {
            // NB Do nothing. Empty icon paths are legal - associated apps where the associated
            // app is missing will have an empty icon path.
        }

        // NB Forget about the icon data.

        // DebugMsg(DM_TRACE, "gc.gcnfo: Found item %s.", (LPSTR) szDesc);

        // Store away the data....
        // NB We load the old commands line into the working dir field because
        // only the leaf is the command, the rest is the WD. Once we've been
        // through the tags section we can sort out the mess.
AddItem:
        PMItem_Clear(&pmitem);

#ifdef DEBUG
        DebugMsg(GC_TRACE, TEXT("gc.gaid: Desc %s"), (LPTSTR) szDesc);
        DebugMsg(GC_TRACE, TEXT("    WD: %s"), (LPTSTR) szCL);
        DebugMsg(GC_TRACE, TEXT("    IP: %s(%d)"), (LPTSTR) szIconPath, itemdef.iIcon);
#endif

        // Don't store anything for items with invalid descriptions.
        if (*szDesc)
        {
            // Remove illegal chars.
            PathRemoveIllegalChars(szDesc, 0, PRICF_NORMAL);
            Str_SetPtr(&pmitem.lpszDesc, szDesc);
            Str_SetPtr(&pmitem.lpszWD, szCL);
            Str_SetPtr(&pmitem.lpszIconPath, szIconPath);
            pmitem.wiIcon = itemdef.iIcon;
        }

        DSA_InsertItem(hdsaPMItems, iItem, &pmitem);

        iItem++;
    }

    LocalFree((HLOCAL)rgItems);

    return fOK;
}

//-----------------------------------------------------------------------------
// Functions to try to find out which icon was appropriate given the NT icon
// identifier number (the identifier for the RT_ICON resource only).
//-----------------------------------------------------------------------------
typedef struct _enumstruct {
    UINT    iIndex;
    BOOL    fFound;
    WORD    wIconRTIconID;
} ENUMSTRUCT, *LPENUMSTRUCT;

BOOL EnumIconFunc(
    HMODULE hMod,
    LPCTSTR lpType,
    LPTSTR  lpName,
    LPARAM  lParam
) {
    HANDLE  h;
    PBYTE   p;
    int     id;
    LPENUMSTRUCT    lpes = (LPENUMSTRUCT)lParam;

    if (!lpName)
        return TRUE;

    h = FindResource(hMod, lpName, lpType);
    if (!h)
        return TRUE;

    h = LoadResource(hMod, h);
    p = LockResource(h);
    id = LookupIconIdFromDirectory(p, TRUE);
    UnlockResource(h);
    FreeResource(h);

    if (id == lpes->wIconRTIconID)
    {
        lpes->fFound = TRUE;
        return FALSE;
    }
    lpes->iIndex++;

    return TRUE;
}

WORD FindAppropriateIcon( LPTSTR lpszFileName, WORD wIconRTIconID )
{
    HINSTANCE hInst;
    TCHAR   szExe[MAX_PATH];
    WORD    wIcon = wIconRTIconID;
    ENUMSTRUCT  es;
    int olderror;

    hInst = FindExecutable(lpszFileName,NULL,szExe);
    if ( hInst <= (HINSTANCE)HINSTANCE_ERROR )
    {
        return 0;
    }

    olderror = SetErrorMode(SEM_FAILCRITICALERRORS);
    hInst = LoadLibraryEx(szExe,NULL, DONT_RESOLVE_DLL_REFERENCES);
    SetErrorMode(olderror);
    if ( hInst <= (HINSTANCE)HINSTANCE_ERROR )
    {
        return 0;
    }

    es.iIndex = 0;
    es.fFound = FALSE;
    es.wIconRTIconID = wIconRTIconID;

    EnumResourceNames( hInst, RT_GROUP_ICON, EnumIconFunc, (LPARAM)&es );

    FreeLibrary( hInst );

    if (es.fFound)
    {
        return (WORD)es.iIndex;
    }
    else
    {
        return 0;
    }
}

//---------------------------------------------------------------------------
// Read the item data from the file and add it to the list.
// Returns TRUE if everything went perfectly.
#ifdef UNICODE
BOOL GetAllItemDataNT(HANDLE fh, WORD cItems, DWORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#else
BOOL GetAllItemDataNT(HFILE fh, WORD cItems, DWORD cbGroup, LPTSTR lpszOldGrpTitle, LPTSTR lpszNewGrpPath)
#endif
{
    UINT cbItemArray;
    DWORD *rgItems;
    UINT i, iItem;
    WCHAR wszTemp[CCHSZNORMAL];
    TCHAR szDesc[CCHSZNORMAL];
    TCHAR szCL[CCHSZNORMAL];
    TCHAR szIconPath[CCHSZNORMAL];
    NT_ITEMDEF itemdef;
    BOOL fOK = TRUE;
#ifdef UNICODE
    DWORD cbRead;
#else
    UINT cbRead;
#endif
    PMITEM pmitem;

    // Read in the old item table...
    iItem = 0;
    cbItemArray = cItems * SIZEOF(*rgItems);
    rgItems = (DWORD *)LocalAlloc(LPTR, cbItemArray);
    if (!rgItems)
    {
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Out of memory."));
        return FALSE;
    }
#ifdef UNICODE
    SetFilePointer(fh, FIELD_OFFSET(NT_GROUPDEF,rgiItems[0]), NULL, FILE_BEGIN);
    ReadFile(fh, rgItems, cbItemArray, &cbRead, NULL);
#else
    _llseek(fh, FIELD_OFFSET(NT_GROUPDEF,rgiItems[0]), 0);
    _lread(fh, rgItems, cbItemArray);
#endif

    // Show progress in two stages, first reading then writing.
    Group_SetProgressNameAndRange(lpszNewGrpPath, (cItems*2)-1);

    // Read in the items.
    // NB Don't just skip busted items since the tag data contains
    // indices to items and that includes busted ones. Just use
    // an empty description to indicate that the link is invalid.
    for (i=0; i<cItems; i++)
    {
        Group_SetProgress(i);

        szDesc[0] = TEXT('\0');
        szCL[0] = TEXT('\0');
        szIconPath[0] = TEXT('\0');
        itemdef.iIcon = 0;

        if (rgItems[i] == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file has empty item definition - skipping."));
            goto AddItem;
        }
        if (rgItems[i] > cbGroup)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (item entry in invalid part of file) - skipping item."));
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, rgItems[i], NULL, FILE_BEGIN);
        ReadFile(fh, &itemdef, SIZEOF(itemdef), &cbRead, NULL);
#else
        _llseek(fh, rgItems[i], 0);
        cbRead = _lread(fh, &itemdef, SIZEOF(itemdef));
#endif
        if (cbRead != SIZEOF(itemdef))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid definition) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
        if (!CheckItemDefNT(&itemdef, cbGroup))
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (invalid item field) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        SetFilePointer(fh, itemdef.pName, NULL, FILE_BEGIN);
        ReadFile(fh, wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pName, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp)); // There will be a NUL somewhere
#endif
        if (!*wszTemp)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty name) - skipping item %d."), i);
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        lstrcpy(szDesc, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szDesc, ARRAYSIZE(szDesc), NULL, NULL);
#endif

#ifdef UNICODE
        SetFilePointer(fh, itemdef.pCommand, NULL, FILE_BEGIN);
        ReadFile(fh, &wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pCommand, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp));
#endif
        if (!*wszTemp)
        {
            DebugMsg(DM_TRACE, TEXT("gc.gcnfo: Old group file busted (empty command line) - skipping item %d."), i);
            // We use a null description to signal a problem with this item.
            szDesc[0] = TEXT('\0');
            fOK = FALSE;
            goto AddItem;
        }
#ifdef UNICODE
        lstrcpy(szCL, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szCL, ARRAYSIZE(szCL), NULL, NULL);
#endif

#ifdef UNICODE
        SetFilePointer(fh, itemdef.pIconPath, NULL, FILE_BEGIN);
        ReadFile(fh, wszTemp, SIZEOF(wszTemp), &cbRead, NULL);
#else
        _llseek(fh, itemdef.pIconPath, 0);
        _lread(fh, wszTemp, SIZEOF(wszTemp));
#endif
        if (!*wszTemp)
        {
            // NB Do nothing. Empty icon paths are legal - associated apps where the associated
            // app is missing will have an empty icon path.
        }
#ifdef UNICODE
        lstrcpy(szIconPath, wszTemp);
#else
        WideCharToMultiByte (CP_ACP, 0, wszTemp, -1,
                         szIconPath, ARRAYSIZE(szIconPath), NULL, NULL);
#endif

        // NB Forget about the icon data.

        // DebugMsg(DM_TRACE, "gc.gcnfo: Found item %s.", (LPSTR) szDesc);

        // Store away the data....
        // NB We load the old commands line into the working dir field because
        // only the leaf is the command, the rest is the WD. Once we've been
        // through the tags section we can sort out the mess.
AddItem:
        PMItem_Clear(&pmitem);

#ifdef DEBUG
        DebugMsg(GC_TRACE, TEXT("gc.gaid: Desc %s"), (LPTSTR) szDesc);
        DebugMsg(GC_TRACE, TEXT("    WD: %s"), (LPTSTR) szCL);
        DebugMsg(GC_TRACE, TEXT("    IP: %s(%d)"), (LPTSTR) szIconPath, itemdef.iIcon);
#endif

        // Don't store anything for items with invalid descriptions.
        if (*szDesc)
        {
            WORD    wIconIndex;

            // Remove illegal chars.
            PathRemoveIllegalChars(szDesc, 0, PRICF_NORMAL);
            Str_SetPtr(&pmitem.lpszDesc, szDesc);
            Str_SetPtr(&pmitem.lpszWD, szCL);
            Str_SetPtr(&pmitem.lpszIconPath, szIconPath);

            wIconIndex = itemdef.wIconIndex;
            if ( wIconIndex == 0 )
            {
                WORD    wIcon;
                HICON   hIcon;

                if ( *szIconPath == TEXT('\0') )
                {
                    FindExecutable(szCL,NULL,szIconPath);
                }
                if ( *szIconPath != TEXT('\0') )
                {
                    wIconIndex = FindAppropriateIcon( szIconPath, itemdef.iIcon);
                }
            }
            pmitem.wiIcon = wIconIndex;
        }

        DSA_InsertItem(hdsaPMItems, iItem, &pmitem);

        iItem++;
    }

    LocalFree((HLOCAL)rgItems);

    return fOK;
}

//---------------------------------------------------------------------------
// Create the links in the given dest dir.
void CreateLinks(LPCTSTR lpszNewGrpPath, BOOL fStartup, INT cItemsStart)
{
    int i, cItems;
    TCHAR szLinkName[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    // we make this 3*MAX_PATH so that DARWIN and LOGO3 callers can pass their extra information
    TCHAR szExpBuff[3*MAX_PATH];
    WCHAR wszPath[MAX_PATH];
    LPTSTR lpszArgs;
    LPCTSTR dirs[2];
    IShellLink *psl;
    LPTSTR pszExt;

    if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl))) {
        IPersistFile *ppf;
        psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);

        cItems = DSA_GetItemCount(hdsaPMItems);

        for (i = 0; i < cItems; i++) {
            LPPMITEM lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

            // We show the progress in 2 halves.
            Group_SetProgress(cItemsStart+(i*cItemsStart/cItems));

            // command line and args.
            // if this command line points to net drives we should add
            // the UNC mapping to the link
            Str_GetPtr(lppmitem->lpszCL, szBuffer, ARRAYSIZE(szBuffer));

            // Spaces at the begining of the CL will confuse us.
            PathRemoveBlanks(szBuffer);

            lpszArgs = PathGetArgs(szBuffer);
            if (*lpszArgs)
                *(lpszArgs-1) = TEXT('\0');

            // NB Special case, remove all links to Progman[.exe] from the
            // Startup Group. A lot of people put it there to give it a hotkey.
            // We want to be able to delete it regardless of its name ie we
            // can't just use setup.ini to do the work.
            if (fStartup)
            {
                if ((lstrcmpi(c_szProgmanExe, PathFindFileName(szBuffer)) == 0) ||
                    (lstrcmpi(c_szProgman, PathFindFileName(szBuffer)) == 0))
                    continue;
            }

            psl->lpVtbl->SetArguments(psl, lpszArgs);

            //
            // Remove quotes from the command file name NOW.
            //
            if (szBuffer[0] == TEXT('"')) {
               LPTSTR lpTemp;

               for (lpTemp = szBuffer+1; *lpTemp && *lpTemp != TEXT('"'); lpTemp++)
                  *(lpTemp-1) = *lpTemp;

               if (*lpTemp == TEXT('"')) {
                  *(lpTemp-1) = TEXT('\0');
               }
            }

            // working directory
            // NB Progman assumed an empty WD meant use the windows
            // directory but we want to change this so to be
            // backwards compatable we'll fill in missing WD's here.
            if (!lppmitem->lpszWD || !*lppmitem->lpszWD)
            {
                // NB For links to pif's we don't fill in a default WD
                // so we'll pick it up from pif itself. This fixes a
                // problem upgrading some Compaq Deskpro's.
                pszExt = PathFindExtension(szBuffer);
                if (lstrcmpi(pszExt, c_szDotPif) == 0)
                {
                    psl->lpVtbl->SetWorkingDirectory(psl, c_szNULL);
                }
                else
                {
#ifdef WINNT
                    // Avoid setting to %windir%, under NT we want to change to the users home directory.
                    psl->lpVtbl->SetWorkingDirectory( psl, TEXT("%HOMEDRIVE%%HOMEPATH%") );
#else
                    // Not a pif. Set the WD to be that of the windows dir.
                    psl->lpVtbl->SetWorkingDirectory(psl, TEXT("%windir%"));
#endif
                }
            }
            else
            {
                psl->lpVtbl->SetWorkingDirectory(psl, lppmitem->lpszWD);
            }

            // icon location

            // REVIEW, do we want to unqualify the icon path if possible?  also,
            // if the icon path is the same as the command line we don't need it
            if (lppmitem->wiIcon != 0 || lstrcmpi(lppmitem->lpszIconPath, szBuffer) != 0)
            {
                // Remove args.
                lpszArgs = PathGetArgs(lppmitem->lpszIconPath);
                if (*lpszArgs)
                    *(lpszArgs-1) = TEXT('\0');
                psl->lpVtbl->SetIconLocation(psl, lppmitem->lpszIconPath, lppmitem->wiIcon);
            }
            else
            {
                psl->lpVtbl->SetIconLocation(psl, NULL, 0);
            }

            // hotkey
            psl->lpVtbl->SetHotkey(psl, lppmitem->wHotKey);

            // show command
            psl->lpVtbl->SetShowCmd(psl, lppmitem->nShowCmd);

            // Description. Currently pifmgr is the only guy
            // that cares about the description and they use
            // it to overide the default pif description.
            psl->lpVtbl->SetDescription(psl, lppmitem->lpszDesc);

            //
            //  NOTE it is very important to set filename *last*
            //  because if this is a group item to another link
            //  (either .lnk or .pif) we want the link properties
            //  to override the ones we just set.
            //
            //  qualify path to subject (szBuffer)

            dirs[0] = lppmitem->lpszWD;
            dirs[1] = NULL;

            // Try expanding szBuffer
            ExpandEnvironmentStrings( szBuffer, szExpBuff, MAX_PATH );
            szExpBuff[ MAX_PATH-1 ] = TEXT('\0');
            if (!PathResolve(szExpBuff, dirs, PRF_TRYPROGRAMEXTENSIONS))
            {
                // Just assume the expanded thing was a-ok...
                ExpandEnvironmentStrings(szBuffer, szExpBuff, MAX_PATH);
                szExpBuff[ MAX_PATH-1 ] = TEXT('\0');
            }

            // all we need to call is setpath, it takes care of creating the
            // pidl for us.
            psl->lpVtbl->SetPath( psl, szBuffer );
#ifdef WINNT
            {
                IShellLinkDataList* psldl;

                if (SUCCEEDED(psl->lpVtbl->QueryInterface(psl, &IID_IShellLinkDataList, (LPVOID)&psldl)))
                {
                    DWORD dwFlags;
                    if (SUCCEEDED(psldl->lpVtbl->GetFlags(psldl, &dwFlags)))
                    {
                        if (lppmitem->bSepVdm)
                            dwFlags |= SLDF_RUN_IN_SEPARATE;
                        else
                            dwFlags &= (~SLDF_RUN_IN_SEPARATE);

                        psldl->lpVtbl->SetFlags(psldl, dwFlags);
                    }
                    psldl->lpVtbl->Release(psldl);
                }
            }
#endif

            // over write the link if it already exists

            PathCombine(szLinkName, lpszNewGrpPath, lppmitem->lpszDesc);
            lstrcat(szLinkName, TEXT(".lnk"));
            PathQualify(szLinkName);
            // OLE string.
            StrToOleStrN(wszPath, ARRAYSIZE(wszPath), szLinkName, -1);
            ppf->lpVtbl->Save(ppf, wszPath, TRUE);
        }
        ppf->lpVtbl->Release(ppf);
        psl->lpVtbl->Release(psl);
    }
}

//----------------------------------------------------------------------------
// Returns TRUE if the specified group title is that of the startup group.
BOOL StartupCmp(LPTSTR szGrp)
{
    static TCHAR szOldStartupGrp[MAX_PATH];
    TCHAR szNewStartupPath[MAX_PATH];

    if (!*szOldStartupGrp)
    {
        // Was it over-ridden in progman ini?
        GetPrivateProfileString(c_szSettings, c_szStartup, c_szNULL, szOldStartupGrp,
            ARRAYSIZE(szOldStartupGrp), c_szProgmanIni);
        if (!*szOldStartupGrp)
        {
            LONG    lResult;
            DWORD   cbSize;

            // No, try reading it from the NT registry
            cbSize = MAX_PATH;
            lResult = RegQueryValue(HKEY_CURRENT_USER, c_szProgmanStartup, szOldStartupGrp, &cbSize );

            // Potential porblem with Kana Start

            if ( lResult != ERROR_SUCCESS )
            {
                // No, use the default name.
                LoadString(g_hinst, IDS_STARTUP, szOldStartupGrp, ARRAYSIZE(szOldStartupGrp));
            }
        }

        if (*szOldStartupGrp)
        {
            // Yes, use the over-riding name by updating the registry.
            SHGetSpecialFolderPath(NULL, szNewStartupPath, CSIDL_PROGRAMS, FALSE);
            PathAddBackslash(szNewStartupPath);
            lstrcat(szNewStartupPath, szOldStartupGrp);
            DebugMsg(DM_TRACE, TEXT("gc.sc: Non-default Startup path is %s."), szNewStartupPath);
            Reg_SetString(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER_SHELLFOLDERS, c_szStartup, szNewStartupPath);
        }

    }

    // Does it match?
    if (*szOldStartupGrp && (lstrcmpi(szGrp, szOldStartupGrp) == 0))
        return TRUE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL CALLBACK IsDescUnique(LPCTSTR lpsz, UINT n)
{
    int i, cItems;
    LPPMITEM pitem;

    // DebugMsg(DM_TRACE, "gc.idu: Checking uniqueness of %s.", lpsz);

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i=0; i<cItems; i++)
    {
        // N is our guy, skip it.
        if ((UINT)i == n)
            continue;

        pitem = DSA_GetItemPtr(hdsaPMItems, i);
        Assert(pitem);
        if (pitem->lpszDesc && *pitem->lpszDesc && (lstrcmpi(pitem->lpszDesc, lpsz) == 0))
        {
            // DebugMsg(DM_TRACE, "gc.idu: Not Unique.");
            return FALSE;
        }
    }
    // Yep. can't find it, must be unique.
    // DebugMsg(DM_TRACE, "gc.idu: Unique.");
    return TRUE;
}

//---------------------------------------------------------------------------
// If there are two or more items with the same link name then change them so
// that they are unique.
void ResolveDuplicates(LPCTSTR pszNewGrpPath)
{
    LPPMITEM pitem;
    int i, cItems;
    TCHAR szNew[MAX_PATH];
    BOOL fLFN;
    int cchSpace;

    DebugMsg(DM_TRACE, TEXT("gc.rd: Fixing dups..."));

    // How much room is there for adding the #xx stuff?
    cchSpace = (ARRAYSIZE(szNew)-lstrlen(pszNewGrpPath))-2;

    if (cchSpace > 0)
    {
        // LFN's or no?
        fLFN = IsLFNDrive(pszNewGrpPath);
        if (!fLFN && cchSpace > 8)
            cchSpace = 8;

        // Fix dups
        cItems = DSA_GetItemCount(hdsaPMItems);
        for (i=0; i<(cItems-1); i++)
        {
            pitem = DSA_GetItemPtr(hdsaPMItems, i);
            Assert(pitem);
            YetAnotherMakeUniqueName(szNew, cchSpace, pitem->lpszDesc, IsDescUnique, i, fLFN);
            // Did we get a new name?
            if (lstrcmp(szNew, pitem->lpszDesc) != 0)
            {
                // Yep.
                DebugMsg(DM_TRACE, TEXT("gc.rd: %s to %s"), pitem->lpszDesc, szNew);
                Str_SetPtr(&pitem->lpszDesc, szNew);
            }
        }
    }

    DebugMsg(DM_TRACE, TEXT("gc.rd: Done."));
}

//---------------------------------------------------------------------------
typedef struct
{
    LPTSTR pszName;
    LPTSTR pszPath;
    LPTSTR pszModule;
    LPTSTR pszVer;
} ALITEM;
typedef ALITEM *PALITEM;

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_WriteFile(void)
{
    int i, cItems;
    PALITEM palitem;
    TCHAR szBetaID[MAX_PATH];
    TCHAR szLine[4*MAX_PATH];
    HANDLE hFile;
    DWORD cbWritten;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(g_hdsaAppList);
    if (cItems)
    {
        // Get the beta ID.
        szBetaID[0] = TEXT('\0');
        Reg_GetString(HKEY_LOCAL_MACHINE, c_szRegistry, c_szDefaultUser, szBetaID, SIZEOF(szBetaID));

        // Ick - Hard coded file name and in the current dir!
        hFile = CreateFile(c_szGrpConvData, GENERIC_WRITE, FILE_SHARE_READ, NULL,
            CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hFile != INVALID_HANDLE_VALUE)
        {
            for (i=0; i < cItems; i++)
            {
                palitem = DSA_GetItemPtr(g_hdsaAppList, i);
                wsprintf(szLine, TEXT("%s,\"%s\",\"%s\",\"%s\",\"%s\",,,\r\n"), szBetaID, palitem->pszName,
                    palitem->pszPath, palitem->pszModule, palitem->pszVer);
                DebugMsg(DM_TRACE,TEXT("gc.al_wf: %s"), szLine);
                WriteFile(hFile, szLine, lstrlen(szLine)*SIZEOF(TCHAR), &cbWritten, NULL);
            }
            CloseHandle(hFile);
        }
        else
        {
            DebugMsg(DM_ERROR, TEXT("gc.al_wf: Can't write file."));
        }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("gc.al_wf: Empty app list. Nothing to write."));
    }
}

//---------------------------------------------------------------------------
//#define DSA_AppendItem(hdsa, pitem)  DSA_InsertItem(hdsa, 0x7fff, pitem)

//---------------------------------------------------------------------------
static TCHAR const c_szTranslation[] = TEXT("\\VarFileInfo\\Translation");
static TCHAR const c_szStringFileInfo[] = TEXT("\\StringFileInfo\\");
static TCHAR const c_szEngLangCharSet[] = TEXT("040904e4");
static TCHAR const c_szSlash[] = TEXT("\\");
static TCHAR const c_szInternalName[] = TEXT("InternalName");
static TCHAR const c_szProductVersion[] = TEXT("ProductVersion");

//----------------------------------------------------------------------------
BOOL Ver_GetDefaultCharSet(const PVOID pBuf, LPTSTR pszLangCharSet, int cbLangCharSet)
{

    LPWORD pTransTable;
    DWORD cb;

    Assert(pszLangCharSet);
    Assert(cbLangCharSet > 8);

    if (VerQueryValue(pBuf, (LPTSTR)c_szTranslation, &pTransTable, &cb))
    {
        wsprintf(pszLangCharSet, TEXT("%04X%04X"), *pTransTable, *(pTransTable+1));
        return TRUE;
    }

    return FALSE;
}

//----------------------------------------------------------------------------
BOOL Ver_GetStringFileInfo(PVOID pBuf, LPCTSTR pszLangCharSet,
    LPCTSTR pszStringName, LPTSTR pszValue, int cchValue)
{
    TCHAR szSubBlock[MAX_PATH];
    LPTSTR pszBuf;
    DWORD cbBuf;

    lstrcpy(szSubBlock, c_szStringFileInfo);
    lstrcat(szSubBlock, pszLangCharSet);
    lstrcat(szSubBlock, c_szSlash);
    lstrcat(szSubBlock, pszStringName);

    if (VerQueryValue(pBuf, szSubBlock, &pszBuf, &cbBuf))
    {
        lstrcpyn(pszValue, pszBuf, cchValue);
        return TRUE;
    }
    return FALSE;
}

//---------------------------------------------------------------------------
void GetVersionInfo(LPTSTR pszPath, LPTSTR pszModule, int cchModule, LPTSTR pszVer, int cchVer)
{
    DWORD cbBuf;
    LPVOID pBuf;
    TCHAR szCharSet[MAX_PATH];
    DWORD dwWasteOfAnAuto;

    Assert(pszModule);
    Assert(pszVer);

    pszModule[0] = TEXT('\0');
    pszVer[0] = TEXT('\0');

    cbBuf = GetFileVersionInfoSize(pszPath, &dwWasteOfAnAuto);
    if (cbBuf)
    {
        pBuf = SHAlloc(cbBuf);
        if (pBuf)
        {
            if (GetFileVersionInfo(pszPath, 0, cbBuf, pBuf))
            {
                // Try the default language from the translation tables.
                if (Ver_GetDefaultCharSet(pBuf, szCharSet, ARRAYSIZE(szCharSet)))
                {
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szInternalName, pszModule, cchModule);
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szProductVersion, pszVer, cchVer);
                }
                else
                {
                    // Try the same language as us.
                    LoadString(g_hinst, IDS_DEFLANGCHARSET, szCharSet, ARRAYSIZE(szCharSet));
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szInternalName, pszModule, cchModule);
                    Ver_GetStringFileInfo(pBuf, szCharSet, c_szProductVersion, pszVer, cchVer);
                }

                // Last chance - try English.
                if (!*pszModule)
                    Ver_GetStringFileInfo(pBuf, c_szEngLangCharSet, c_szInternalName, pszModule, cchModule);
                if (!*pszVer)
                    Ver_GetStringFileInfo(pBuf, c_szEngLangCharSet, c_szProductVersion, pszVer, cchVer);
            }
            else
            {
                DebugMsg(DM_TRACE, TEXT("gc.gvi: Can't get version info."));
            }
            SHFree(pBuf);
        }
        else
        {
            DebugMsg(DM_TRACE, TEXT("gc.gvi: Can't allocate version info buffer."));
            }
    }
    else
    {
        DebugMsg(DM_TRACE, TEXT("gc.gvi: No version info."));
    }
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
BOOL AppList_Create(void)
{
    Assert(!g_hdsaAppList);

    g_hdsaAppList = DSA_Create(SIZEOF(ALITEM), 0);

    if (g_hdsaAppList)
    {
        return TRUE;
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.al_c: Can't create app list."));
        return FALSE;
    }
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_Destroy(void)
{
    int i, cItems;
    PALITEM palitem;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(g_hdsaAppList);
    for (i=0; i < cItems; i++)
    {
        palitem = DSA_GetItemPtr(g_hdsaAppList, i);
        if (palitem->pszName)
            SHFree(palitem->pszName);
        if (palitem->pszPath)
            SHFree(palitem->pszPath);
        if (palitem->pszModule)
            SHFree(palitem->pszModule);
        if (palitem->pszVer)
            SHFree(palitem->pszVer);
    }

    DSA_Destroy(g_hdsaAppList);
    g_hdsaAppList = NULL;
}

//---------------------------------------------------------------------------
// Record the total list of apps in a DSA.
void AppList_Append(void)
{
    int i, cItems;
    // char szName[MAX_PATH];
    // char szPath[MAX_PATH];
    TCHAR szModule[MAX_PATH];
    TCHAR szVer[MAX_PATH];
    TCHAR szCL[MAX_PATH];
    LPTSTR lpszArgs;
    LPCTSTR dirs[2];
    ALITEM alitem;

    Assert(g_hdsaAppList);

    cItems = DSA_GetItemCount(hdsaPMItems);
    for (i = 0; i < cItems; i++)
    {
        LPPMITEM lppmitem = DSA_GetItemPtr(hdsaPMItems, i);

        // We show the progress in 2 halves.
        Group_SetProgress(cItems+i);

        // Command line and args.
        Str_GetPtr(lppmitem->lpszCL, szCL, ARRAYSIZE(szCL));
        lpszArgs = PathGetArgs(szCL);
        if (*lpszArgs)
            *(lpszArgs-1) = TEXT('\0');
        dirs[0] = lppmitem->lpszWD;
        dirs[1] = NULL;
        PathResolve(szCL, dirs, PRF_TRYPROGRAMEXTENSIONS);

        // Version info.
        GetVersionInfo(szCL, szModule, ARRAYSIZE(szModule), szVer, ARRAYSIZE(szVer));

        alitem.pszName = NULL;
        alitem.pszPath = NULL;
        alitem.pszModule = NULL;
        alitem.pszVer = NULL;

        Str_SetPtr(&alitem.pszName, lppmitem->lpszDesc);
        Str_SetPtr(&alitem.pszPath, szCL);
        Str_SetPtr(&alitem.pszModule, szModule);
        Str_SetPtr(&alitem.pszVer, szVer);
        DSA_AppendItem(g_hdsaAppList, &alitem);
    }
    DebugMsg(DM_TRACE, TEXT("gc.al_a: %d items"), DSA_GetItemCount(g_hdsaAppList));
}

//---------------------------------------------------------------------------
// Reads an old format Progman Group files and creates a directory containing
// links that matches the group file.
BOOL Group_CreateNewFromOld(HWND hwnd, LPCTSTR lpszOldGrpPath, UINT options)
{
    GROUPDEF grpdef;
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE fh;
#endif
    TCHAR szNewGrpPath[MAX_PATH];
    TCHAR szOldGrpTitle[MAXGROUPNAMELEN + 1];
    // LPSTR lpszExt;
    BOOL fStatus = FALSE;
    SHELLEXECUTEINFO sei;
    BOOL fStartup = FALSE;

    if (!ItemList_Create(lpszOldGrpPath))
        return FALSE;

#ifdef UNICODE
    fh = CreateFile(
             lpszOldGrpPath,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh == INVALID_HANDLE_VALUE) {
#else
    fh = _lopen(lpszOldGrpPath, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Unable to open group."));
        goto ProcExit2;
    }

#ifdef UNICODE
    if ((!ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL)) ||
        (dwBytesRead != SIZEOF(grpdef))) {
#else
    if (_lread(fh, &grpdef, SIZEOF(grpdef)) != SIZEOF(grpdef)) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: header too small."));
        goto ProcExit;
    }

    if (grpdef.cItems > 50) {
        // NB This isn;t fatal so carry on.
        DebugMsg(DM_ERROR, TEXT("gc.gcnfo: Too many items."));
    }

    // Check to make sure there is a name embedded in the
    // .grp file.  If not, just use the filename
    if (grpdef.pName==0) {
        LPTSTR lpszFile, lpszExt, lpszDest = szOldGrpTitle;

        lpszFile = PathFindFileName( lpszOldGrpPath );
        lpszExt  = PathFindExtension( lpszOldGrpPath );
        for( ;
             lpszFile && lpszExt && (lpszFile != lpszExt);
             *lpszDest++ = *lpszFile++
            );
        *lpszDest = TEXT('\0');

    } else {

#ifdef UNICODE
        CHAR szAnsiTitle[ MAXGROUPNAMELEN + 1 ];

        SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
        ReadFile(fh, szAnsiTitle, SIZEOF(szAnsiTitle), &dwBytesRead, NULL);
        MultiByteToWideChar( CP_ACP, 0, szAnsiTitle, -1, szOldGrpTitle, ARRAYSIZE(szOldGrpTitle) );
#else
        _llseek(fh, grpdef.pName, 0);
        _lread(fh, szOldGrpTitle, SIZEOF(szOldGrpTitle));
#endif

    }

    // Get the destination dir, use the title from the old group...

    // Special case the startup group.
    if (StartupCmp(szOldGrpTitle)) {
        fStartup = TRUE;
        if (g_fDoingCommonGroups) {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_STARTUP, TRUE);
        }
    } else {
        if (!Group_GenerateNewGroupPath(hwnd, szOldGrpTitle, szNewGrpPath, lpszOldGrpPath)) {
            DebugMsg(DM_ERROR, TEXT("gc.gcnfo; Unable to create destination directory."));
            goto ProcExit;
        }
    }

    // PathQualify(szNewGrpPath);

    // ResolveDuplicateGroupNames(szNewGrpPath);

    // Go through every item in the old group and make it a link...

    if (!GetAllItemData(fh, grpdef.cItems, grpdef.cbGroup, szOldGrpTitle, szNewGrpPath)) {
        if (options & GC_REPORTERROR)
            MyMessageBox(hwnd, IDS_APPTITLE, IDS_BADOLDGROUP, NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    // Deal with the tags section.
    HandleTags(fh, grpdef.cbGroup);

    // Now we've dealt with the tags we don't need to keep track of
    // busted items so delete them now. From here on we always have
    // valid items.
    DeleteBustedItems();

    // Shorten descs on non-lfn drives.
    if (!IsLFNDrive(szNewGrpPath))
        ShortenDescriptions();

    // Fixup the paths/WD stuff.
    MungePaths();

    // Fix dups.
    ResolveDuplicates(szNewGrpPath);

    // Do we just want a list of the apps or create some links?
    if (options & GC_BUILDLIST)
            AppList_Append();
    else
        CreateLinks(szNewGrpPath, fStartup, grpdef.cItems);

    // Get the cabinet to show the new group.
    if (options & GC_OPENGROUP)
    {
        sei.cbSize = SIZEOF(sei);
        sei.fMask = 0;
        sei.hwnd = hwnd;
        sei.lpVerb = NULL;
        sei.lpFile = szNewGrpPath;
        sei.lpParameters = NULL;
        sei.lpDirectory = NULL;
        sei.lpClass = NULL;
        sei.nShow = SW_SHOWNORMAL;
        sei.hInstApp = g_hinst;

        // ShellExecute(hwnd, NULL, szNewGrpPath, NULL, NULL, SW_SHOWNORMAL);
        ShellExecuteEx(&sei);
    }

    // Everything went OK.
    fStatus = TRUE;

ProcExit:
#ifdef UNICODE
    CloseHandle(fh);
#else
    _lclose(fh);
#endif
#ifndef WINNT
    // we only need to call Group_DeleteIfRequired
    // when we are on a Japanese language machine (win95J or win98J). We 
    // should have a runtime check for Japanese here.

    // Delete old group file when it is specified in special
    // registry entry. Bug#7259-win95d
    //
    if (fStatus == TRUE)
    {
        // delete it only if the conversion was successful.
        Group_DeleteIfRequired(szOldGrpTitle,lpszOldGrpPath);
    }
#endif // !WINNT
ProcExit2:
    ItemList_Destroy();
    return fStatus;
}

//---------------------------------------------------------------------------
// Reads an NT format Progman Group files and creates a directory containing
// links that matches the group file.
BOOL Group_CreateNewFromOldNT(HWND hwnd, LPCTSTR lpszOldGrpPath, UINT options)
{
    NT_GROUPDEF grpdef;
#ifdef UNICODE
    HANDLE fh;
    DWORD  dwBytesRead;
#else
    HFILE fh;
#endif
    TCHAR szNewGrpPath[MAX_PATH];
    WCHAR szOldGrpTitleUnicode[MAXGROUPNAMELEN + 1];
    TCHAR szOldGrpTitle[MAXGROUPNAMELEN + 1];
    // LPSTR lpszExt;
    BOOL fStatus = FALSE;
    SHELLEXECUTEINFO sei;
    BOOL fStartup = FALSE;

    if (!ItemList_Create(lpszOldGrpPath))
        return FALSE;


#ifdef UNICODE
    fh = CreateFile(
             lpszOldGrpPath,
             GENERIC_READ,
             FILE_SHARE_READ,
             NULL,
             OPEN_EXISTING,
             0,
             NULL
             );
    if (fh == INVALID_HANDLE_VALUE) {
#else
    fh = _lopen(lpszOldGrpPath, OF_READ | OF_SHARE_DENY_NONE);
    if (fh == HFILE_ERROR) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: Unable to open group."));
        goto ProcExit2;
    }

#ifdef UNICODE
    if (!ReadFile(fh, &grpdef, SIZEOF(grpdef), &dwBytesRead, NULL) ||
        dwBytesRead != SIZEOF(grpdef)) {
#else
    if (_lread(fh, &grpdef, SIZEOF(grpdef)) != SIZEOF(grpdef)) {
#endif
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: header too small."));
        goto ProcExit;
    }

    if (grpdef.cItems > 50) {
        // NB This isn;t fatal so carry on.
        DebugMsg(DM_ERROR, TEXT("gc.gcnfont: Too many items."));
    }

#ifdef UNICODE
    SetFilePointer(fh, grpdef.pName, NULL, FILE_BEGIN);
    ReadFile(fh, szOldGrpTitleUnicode, SIZEOF(szOldGrpTitleUnicode), &dwBytesRead, NULL);
#else
    _llseek(fh, grpdef.pName, 0);
    _lread(fh, szOldGrpTitleUnicode, SIZEOF(szOldGrpTitleUnicode));
#endif

#ifdef UNICODE
    lstrcpy(szOldGrpTitle, szOldGrpTitleUnicode);
#else
    WideCharToMultiByte (CP_ACP, 0, szOldGrpTitleUnicode, -1,
                         szOldGrpTitle, MAXGROUPNAMELEN+1, NULL, NULL);
#endif

    // Get the destination dir, use the title from the old group.
    // REVIEW UNDONE - until we get long filenames we'll use the old
    // groups' filename as the basis for the new group instead of it's
    // title.


    // Special case the startup group.
    if (StartupCmp(szOldGrpTitle)) {
        if (g_fDoingCommonGroups) {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_COMMON_STARTUP, TRUE);
        } else {
            SHGetSpecialFolderPath(hwnd, szNewGrpPath, CSIDL_STARTUP, TRUE);
        }
    } else {
        if (!Group_GenerateNewGroupPath(hwnd, szOldGrpTitle, szNewGrpPath, lpszOldGrpPath)) {
            DebugMsg(DM_ERROR, TEXT("gc.gcnfo; Unable to create destination directory."));
            goto ProcExit;
        }
    }

    // Go through every item in the old group and make it a link...
    if (!GetAllItemDataNT(fh, grpdef.cItems, grpdef.cbGroup, szOldGrpTitle, szNewGrpPath)) {
        if (options & GC_REPORTERROR)
            MyMessageBox(hwnd, IDS_APPTITLE, IDS_BADOLDGROUP, NULL, MB_OK | MB_ICONEXCLAMATION);
    }

    // Deal with the tags section.
    HandleTagsNT(fh, grpdef.cbGroup);

    // Now we've dealt with the tags we don't need to keep track of
    // busted items so delete them now. From here on we always have
    // valid items.
    DeleteBustedItems();

    // Shorten descs on non-lfn drives.
    if (!IsLFNDrive(szNewGrpPath))
        ShortenDescriptions();

    // Fixup the paths/WD stuff.
    MungePaths();

    // Fix dups.
    ResolveDuplicates(szNewGrpPath);

    // Do we just want a list of the apps or create some links?
    if (options & GC_BUILDLIST)
            AppList_Append();
    else
        CreateLinks(szNewGrpPath, fStartup, grpdef.cItems);

    // Get the cabinet to show the new group.
    if (options & GC_OPENGROUP)
    {
        sei.cbSize = SIZEOF(sei);
        sei.fMask = 0;
        sei.hwnd = hwnd;
        sei.lpVerb = NULL;
        sei.lpFile = szNewGrpPath;
        sei.lpParameters = NULL;
        sei.lpDirectory = NULL;
        sei.lpClass = NULL;
        sei.nShow = SW_SHOWNORMAL;
        sei.hInstApp = g_hinst;

        // ShellExecute(hwnd, NULL, szNewGrpPath, NULL, NULL, SW_SHOWNORMAL);
        ShellExecuteEx(&sei);
    }

    // Everything went OK.
    fStatus = TRUE;

ProcExit:
#ifdef UNICODE
    CloseHandle(fh);
#else
    _lclose(fh);
#endif
ProcExit2:
    ItemList_Destroy();
    return fStatus;
}

//---------------------------------------------------------------------------
// Record the last write date/time of the given group in the ini file.
void Group_WriteLastModDateTime(LPCTSTR lpszGroupFile,DWORD dwLowDateTime)
{
    Reg_SetStruct(g_hkeyGrpConv, c_szGroups, lpszGroupFile, &dwLowDateTime, SIZEOF(dwLowDateTime));
}

//---------------------------------------------------------------------------
// Read the last write date/time of the given group from the ini file.
DWORD Group_ReadLastModDateTime(LPCTSTR lpszGroupFile)
{
    DWORD dwDateTime = 0;

    Reg_GetStruct(g_hkeyGrpConv, c_szGroups, lpszGroupFile, &dwDateTime, SIZEOF(dwDateTime));

    return dwDateTime;
}

//---------------------------------------------------------------------------
// Convert the given group to the new format.
// Returns FALSE if something goes wrong.
// Returns true if the given group got converted or the user cancelled.
BOOL Group_Convert(HWND hwnd, LPCTSTR lpszOldGrpFile, UINT options)
    {
    TCHAR szGroupTitle[MAXGROUPNAMELEN + 1];          // PM Groups had a max title len of 30.
    BOOL fStatus;
    WIN32_FIND_DATA fd;
    HANDLE hff;
    UINT    nCode;
    UINT    iErrorId;


    Log(TEXT("Grp: %s"), lpszOldGrpFile);

    DebugMsg(DM_TRACE, TEXT("gc.gc: Converting group %s"), (LPTSTR) lpszOldGrpFile);

    // Does the group exist?
    if (PathFileExists(lpszOldGrpFile))
        {
        // Group exists - is it valid?

        nCode = Group_ValidOldFormat(lpszOldGrpFile, szGroupTitle);
        switch( nCode )
            {
            case VOF_WINNT:
            case VOF_WIN31:
                // Yes - ask for confirmation.
                if (!(options & GC_PROMPTBEFORECONVERT) ||
                    MyMessageBox(hwnd, IDS_APPTITLE, IDS_OKTOCONVERT, szGroupTitle, MB_YESNO) == IDYES)
                    {
                    // Everything went OK?
                    if ( nCode == VOF_WIN31 )
                        {
                        fStatus = Group_CreateNewFromOld(hwnd,lpszOldGrpFile,
                                                                      options);
                        }
                    else
                        {
                        fStatus = Group_CreateNewFromOldNT(hwnd,lpszOldGrpFile,
                                                                      options);
                        }
                    if ( fStatus )
                        {
                        iErrorId = 0;
                        }
                    else
                        {
                        // Nope - FU. Warn and exit.
                        iErrorId = IDS_CONVERTERROR;
                        }
                    }
                else
                    {
                    // User cancelled...
                    iErrorId = 0;
                    }
                break;

            default:
            case VOF_BAD:
                {
                // Nope, File is invalid.
                // Warn user.
                iErrorId = IDS_NOTGROUPFILE;
                }
                break;
            }
        }
    else
        {
        // Nope, File doesn't even exist.
        iErrorId = IDS_MISSINGFILE;
        }

    if ( iErrorId != 0 )
        {
        if (options & GC_REPORTERROR)
            {
            MyMessageBox(hwnd, IDS_APPTITLE, iErrorId,
                         lpszOldGrpFile, MB_OK|MB_ICONEXCLAMATION);
            }

        Log(TEXT("Grp: %s done."), lpszOldGrpFile);

        return FALSE;
        }
    else
        {
        DebugMsg(DM_TRACE, TEXT("gc.gc: Done."));

        Log(TEXT("Grp: %s done."), lpszOldGrpFile);

        return TRUE;
        }
    }

//---------------------------------------------------------------------------
// Checks the date/time stamp of the given group against the one in
// grpconv.ini
BOOL GroupHasBeenModified(LPCTSTR lpszGroupFile)
{
        WIN32_FIND_DATA fd;
        HANDLE hff;
        BOOL fModified;

        hff = FindFirstFile(lpszGroupFile, &fd);
        if (hff != INVALID_HANDLE_VALUE)
        {
                if (Group_ReadLastModDateTime(lpszGroupFile) != fd.ftLastWriteTime.dwLowDateTime)
                {
                        DebugMsg(DM_TRACE, TEXT("cg.ghbm: Group %s has been modified."), (LPTSTR)lpszGroupFile);
                        fModified = TRUE;
                }
                else
                {
                        DebugMsg(DM_TRACE, TEXT("cg.ghbm: Group %s has not been modified."), (LPTSTR)lpszGroupFile);
                        fModified = FALSE;
                }
                FindClose(hff);
                return fModified;
        }
        else
        {
                // Hmm, file doesn't exist, pretend it's up to date.
                return TRUE;
        }
}

//---------------------------------------------------------------------------
// Converts a group file from its NT registry into a real file on disk. Since
// the disk format for NT 1.0 files never existed and collided in its usage
// the GROUP_MAGIC file type, we will convert it from the registry, directly
// into a GROUP_UNICODE format file.  In this way we will always be able to
// distiguish the NT group files from the Win 3.1 group files.

BOOL MakeGroupFile( LPTSTR lpFileName, LPTSTR lpGroupName)
{
    LONG    lResult;
    DWORD   cbSize;
    HGLOBAL hBuffer;
    HGLOBAL hNew;
    LPBYTE  lpBuffer;
    BOOL    fOk;
    HANDLE  hFile;
    HKEY    hkey;
    DWORD   cbWrote;

    fOk = FALSE;

    lResult = RegOpenKeyEx(hkeyGroups, lpGroupName, 0,
                            KEY_READ, &hkey );
    if ( lResult != ERROR_SUCCESS )
    {
        return FALSE;
    }

    lResult = RegQueryValueEx( hkey, NULL, NULL, NULL, NULL, &cbSize);
    if ( lResult != ERROR_SUCCESS )
    {
        goto CleanupKey;
    }

    hBuffer = GlobalAlloc(GMEM_MOVEABLE,cbSize);
    if ( hBuffer == NULL )
    {
        goto CleanupKey;
    }
    lpBuffer = (LPBYTE)GlobalLock(hBuffer);
    if ( lpBuffer == NULL )
    {
        goto CleanupMem;
    }

    lResult = RegQueryValueEx( hkey, NULL, NULL, NULL,
                             lpBuffer, &cbSize );

    if ( lResult != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    if ( *(DWORD *)lpBuffer == GROUP_MAGIC )
    {
        HGLOBAL hNew;

        cbSize = ConvertToUnicodeGroup( (LPNT_GROUPDEF_A)lpBuffer, &hNew );

        GlobalUnlock( hBuffer );
        GlobalFree( hBuffer );
        hBuffer = hNew;
        lpBuffer = GlobalLock( hBuffer );
        if ( lpBuffer == NULL )
        {
            goto CleanupMem;
        }
    }

    hFile = CreateFile(lpFileName,GENERIC_WRITE,0,NULL,
                       CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        fOk = WriteFile(hFile,lpBuffer,cbSize,&cbWrote,NULL);

        CloseHandle(hFile);
    }

Cleanup:
    GlobalUnlock(hBuffer);

CleanupMem:
    GlobalFree(hBuffer);

CleanupKey:
    RegCloseKey( hkey );
    return fOk;
}

#define BIG_STEP 512

// returns S_OK if allocated a sufficiently large buffer (buffer allocated with LocalAlloc returned)
// returns E_FAIL if buffer required is larger than BIG_STEP*7 characters (no buffer returned)
// returns E_OUTOFMEMORY if memory allocation failed (no buffer returned)

HRESULT GetSufficientlyLargeGroupBuffer(LPTSTR pszIni, LPTSTR* ppszBuffer)
{
    UINT cchBuffer;
    HRESULT hr = S_FALSE;
    for (cchBuffer = BIG_STEP; (S_FALSE == hr) && (cchBuffer <= BIG_STEP * 7); cchBuffer += BIG_STEP)
    {
        *ppszBuffer = (LPTSTR)LocalAlloc(LPTR, cchBuffer * sizeof(TCHAR));
        if (!*ppszBuffer)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            if ((UINT)GetPrivateProfileString(c_szGroups, NULL, c_szNULL, *ppszBuffer, cchBuffer, pszIni) < (cchBuffer - 5))
            {
                hr = S_OK; // found a big enough buffer, we can stop
            }
            else
            {
                LocalFree((HLOCAL)*ppszBuffer);
                *ppszBuffer = NULL;
                hr = S_FALSE; // continue in the loop
            }
        }
    }

    if (S_FALSE == hr)
    {
        hr = E_FAIL; // make callers using SUCCEEDED happy
    }
    return hr;
}

//----------------------------------------------------------------------------
// Enumerate all the groups or just all the modified groups.
int Group_Enum(PFNGRPCALLBACK pfncb, BOOL fProgress,
    BOOL fModifiedOnly)
{
    TCHAR szIniFile[MAX_PATH], szFile[MAX_PATH];
    FILETIME  ft;
    UINT uSize;
    LPTSTR pSection, pKey;
    int cGroups = 0;
    HANDLE hFile;
    WIN32_FIND_DATA fd;

    if (!FindProgmanIni(szIniFile))
        return 0;

    if (FAILED(GetSufficientlyLargeGroupBuffer(szIniFile, &pSection)))
        return 0;

    if (fProgress)
        Group_CreateProgressDlg();

    for (pKey = pSection; *pKey; pKey += lstrlen(pKey) + 1)
    {
        GetPrivateProfileString(c_szGroups, pKey, c_szNULL, szFile, ARRAYSIZE(szFile), szIniFile);
        if (szFile[0])
        {
            if (!fModifiedOnly || GroupHasBeenModified(szFile))
            {
                (*pfncb)(szFile);
                cGroups++;
                hFile = FindFirstFile (szFile, &fd);

                if (hFile != INVALID_HANDLE_VALUE) {
                    FindClose (hFile);
                    Group_WriteLastModDateTime(szFile, fd.ftLastWriteTime.dwLowDateTime);
                }
            }
        }
    }

    // Cabinet uses the date/time of progman.ini as a hint to speed things up
    // so set it here so we won't run automatically again.
    GetSystemTimeAsFileTime(&ft);
    Group_WriteLastModDateTime(szIniFile,ft.dwLowDateTime);

    LocalFree((HLOCAL)pSection);

    if (fProgress)
        Group_DestroyProgressDlg();

    return cGroups;
}



//----------------------------------------------------------------------------
// Enumerate all the NT groups or just all the modified groups.
int Group_EnumNT(PFNGRPCALLBACK pfncb, BOOL fProgress,
    BOOL fModifiedOnly, HKEY hKeyRoot, LPCTSTR lpKey)
{
    LONG      lResult;
    DWORD     dwSubKey = 0;
    TCHAR     szGroupName[MAXGROUPNAMELEN+1];
    TCHAR     szFileName[MAX_PATH];
    TCHAR     szTempFileDir[MAX_PATH];
    TCHAR     szTempFileName[MAX_PATH];
    DWORD     cchGroupNameLen;
    FILETIME  ft;
    BOOL      fOk;
    BOOL      fDialog = FALSE;
    BOOL      fProcess;
    int       cGroups = 0;


    //
    // Look for groups in the registry
    //

    lResult = RegOpenKeyEx(hKeyRoot, lpKey, 0,
                            KEY_READ, &hkeyGroups );
    if ( lResult != ERROR_SUCCESS )
    {
        return 0;
    }


    while ( TRUE )
    {
        cchGroupNameLen = ARRAYSIZE(szGroupName);
        lResult = RegEnumKeyEx( hkeyGroups, dwSubKey, szGroupName,
                                &cchGroupNameLen, NULL, NULL, NULL, &ft );
        szGroupName[MAXGROUPNAMELEN] = TEXT('\0');

        if ( lResult == ERROR_NO_MORE_ITEMS )
        {
            break;
        }
        if ( lResult == ERROR_SUCCESS )
        {
            GetWindowsDirectory(szFileName, ARRAYSIZE(szFileName));

            // Save this dir for use by GetTempFileName below
            lstrcpy(szTempFileDir, szFileName);

#ifdef WINNT
            GetEnvironmentVariable(TEXT("USERPROFILE"), szTempFileDir, MAX_PATH);
#endif
            lstrcat(szFileName,TEXT("\\"));
            lstrcat(szFileName,szGroupName);
            lstrcat(szFileName,TEXT(".grp"));

            //
            // If the key has been modified since we last processed it,
            // then time to process it again.
            //
            fProcess = FALSE;
            if (fModifiedOnly)
            {
                if ( Group_ReadLastModDateTime(szFileName) != ft.dwLowDateTime )
                {
                    fProcess = TRUE;
                }
            }
            else
            {
                fProcess = TRUE;
            }

            if (fProcess)
            {
                if (GetTempFileName(szTempFileDir,TEXT("grp"),0,szTempFileName) != 0)
                {
                    fOk = MakeGroupFile(szTempFileName,szGroupName);
                    if ( fOk )
                    {
                        if (fProgress && !fDialog)
                        {
                            Group_CreateProgressDlg();
                            fDialog = TRUE;
                        }
                        (*pfncb)(szTempFileName);
                        DeleteFile(szTempFileName);
                        Group_WriteLastModDateTime(szFileName,ft.dwLowDateTime);
                        cGroups++;
                    }
                }
            }
        }
        dwSubKey++;
    }

    RegCloseKey( hkeyGroups );
    hkeyGroups = NULL;

    if (fProgress && fDialog)
        Group_DestroyProgressDlg();

    return cGroups;
}







//---------------------------------------------------------------------------
// Find the progman ini from before an upgrade.
BOOL FindOldProgmanIni(LPTSTR pszPath)
{
    if (Reg_GetString(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP, REGSTR_VAL_OLDWINDIR, pszPath, MAX_PATH*SIZEOF(TCHAR)))
    {
        PathAppend(pszPath, c_szProgmanIni);

        if (PathFileExists(pszPath))
        {
            return TRUE;
        }
        DebugMsg(DM_ERROR, TEXT("Can't find old progman.ini"));
        return FALSE;
    }
    return FALSE;
}

//----------------------------------------------------------------------------
// Enumerate all the old groups.
void Group_EnumOldGroups(PFNGRPCALLBACK pfncb, BOOL fProgress)
{
    TCHAR szIniFile[MAX_PATH], szFile[MAX_PATH];
    UINT uSize;
    LPTSTR pSection, pKey;

    if (!FindOldProgmanIni(szIniFile))
        return;

    if (FAILED(GetSufficientlyLargeGroupBuffer(szIniFile, &pSection)))
        return;

    if (fProgress)
        Group_CreateProgressDlg();

    for (pKey = pSection; *pKey; pKey += lstrlen(pKey) + 1)
    {
        GetPrivateProfileString(c_szGroups, pKey, c_szNULL, szFile, ARRAYSIZE(szFile), szIniFile);
        if (szFile[0])
        {
            (*pfncb)(szFile);
        }
    }

    if (fProgress)
        Group_DestroyProgressDlg();

    LocalFree((HLOCAL)pSection);
}

//----------------------------------------------------------------------------
// Given a pidl for a link, extract the appropriate info and append it to
// the app list.
void AppList_AppendCurrentItem(LPITEMIDLIST pidlFolder, LPSHELLFOLDER psf,
    LPITEMIDLIST pidlItem, IShellLink *psl, IPersistFile *ppf)
{
    STRRET str;
    WCHAR wszPath[MAX_PATH];
    TCHAR szName[MAX_PATH];
    TCHAR sz[MAX_PATH];
    TCHAR szPath[MAX_PATH];
    TCHAR szModule[MAX_PATH];
    TCHAR szVer[MAX_PATH];
    ALITEM alitem;

    if (SUCCEEDED(psf->lpVtbl->GetDisplayNameOf(psf, pidlItem, SHGDN_NORMAL, &str)))
    {
        // Get the name.
        StrRetToStrN(szName, ARRAYSIZE(szName), &str, pidlItem);
        DebugMsg(DM_TRACE, TEXT("c.gi_gi: Link %s"), szName);

        // Get the path from the link...
        SHGetPathFromIDList(pidlFolder, sz);
        PathAppend(sz, szName);
        lstrcat(sz, TEXT(".lnk"));
        StrToOleStrN(wszPath, ARRAYSIZE(wszPath), sz, -1);
        ppf->lpVtbl->Load(ppf, wszPath, 0);
        // Copy all the data.
        szPath[0] = TEXT('\0');
        if (SUCCEEDED(psl->lpVtbl->GetPath(psl, szPath, ARRAYSIZE(szPath), NULL, SLGP_SHORTPATH)))
        {
            // Valid CL?
            if (szPath[0])
            {
                GetVersionInfo(szPath, szModule, ARRAYSIZE(szModule), szVer, ARRAYSIZE(szVer));

                alitem.pszName = NULL;
                alitem.pszPath = NULL;
                alitem.pszModule = NULL;
                alitem.pszVer = NULL;

                Str_SetPtr(&alitem.pszName, szName);
                Str_SetPtr(&alitem.pszPath, szPath);
                Str_SetPtr(&alitem.pszModule, szModule);
                Str_SetPtr(&alitem.pszVer, szVer);
                DSA_AppendItem(g_hdsaAppList, &alitem);
            }
        }
    }
}

//----------------------------------------------------------------------------
HRESULT AppList_ShellFolderEnum(LPITEMIDLIST pidlFolder, LPSHELLFOLDER psf)
{
    HRESULT hres;
    LPENUMIDLIST penum;
    IShellLink *psl;
    LPITEMIDLIST pidlItem;
    UINT celt;
    IPersistFile *ppf;
    DWORD dwAttribs;
    LPSHELLFOLDER psfItem;
    LPITEMIDLIST pidlPath;

    DebugMsg(DM_TRACE, TEXT("gc.al_sfe: Enum..."));

    hres = psf->lpVtbl->EnumObjects(psf, (HWND)NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &penum);
    if (SUCCEEDED(hres))
    {
        hres = ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl);
        if (SUCCEEDED(hres))
        {
            psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);
            while ((penum->lpVtbl->Next(penum, 1, &pidlItem, &celt) == NOERROR) && (celt == 1))
            {
                dwAttribs = SFGAO_LINK|SFGAO_FOLDER;
                if (SUCCEEDED(psf->lpVtbl->GetAttributesOf(psf, 1, &pidlItem, &dwAttribs)))
                {
                    // Is it a folder
                    if (dwAttribs & SFGAO_FOLDER)
                    {
                        // Recurse.
                        DebugMsg(DM_TRACE, TEXT("al_sfe: Folder."));
                        hres = psf->lpVtbl->BindToObject(psf, pidlItem, NULL, &IID_IShellFolder, &psfItem);
                        if (SUCCEEDED(hres))
                        {
                            pidlPath = ILCombine(pidlFolder, pidlItem);
                            if (pidlPath)
                            {
                                AppList_ShellFolderEnum(pidlPath, psfItem);
                                psfItem->lpVtbl->Release(psfItem);
                                ILFree(pidlPath);
                            }
                        }
                    }
                    else if (dwAttribs & SFGAO_LINK)
                    {
                        // Regular link, add it to the list.
                        DebugMsg(DM_TRACE, TEXT("al_sfe: Link."));
                        AppList_AppendCurrentItem(pidlFolder, psf, pidlItem, psl, ppf);
                    }
                }
                SHFree(pidlItem);
            }
            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
        }
        penum->lpVtbl->Release(penum);
    }
    return hres;
}

//----------------------------------------------------------------------------
void Applist_SpecialFolderEnum(int nFolder)
{
    HRESULT hres;
    LPITEMIDLIST pidlGroup;
    LPSHELLFOLDER psf, psfDesktop;
    TCHAR sz[MAX_PATH];

    // Get the group info.
    if (SHGetSpecialFolderPath(NULL, sz, nFolder, FALSE))
    {
        pidlGroup = ILCreateFromPath(sz);
        if (pidlGroup)
            {
            if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellDesktop, &IID_IShellFolder, &psfDesktop)))
            {
                hres = psfDesktop->lpVtbl->BindToObject(psfDesktop, pidlGroup, NULL, &IID_IShellFolder, &psf);
                if (SUCCEEDED(hres))
                {
                    hres = AppList_ShellFolderEnum(pidlGroup, psf);
                    psf->lpVtbl->Release(psf);
                }
                psfDesktop->lpVtbl->Release(psfDesktop);
            }
            else
            {
                DebugMsg(DM_ERROR, TEXT("OneTree: failed to bind to Desktop root"));
            }
            ILFree(pidlGroup);
            }
        else
        {
                DebugMsg(DM_ERROR, TEXT("gc.al_acs: Can't create IDList for path.."));
        }
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.al_acs: Can't find programs folder."));
    }
}

BOOL StartMenuIsProgramsParent(void)
{
    LPITEMIDLIST pidlStart, pidlProgs;
    BOOL fParent = FALSE;

    if (SHGetSpecialFolderLocation(NULL, CSIDL_STARTMENU, &pidlStart))
    {
        if (SHGetSpecialFolderLocation(NULL, CSIDL_PROGRAMS, &pidlProgs))
        {
            if (ILIsParent(pidlStart, pidlProgs, FALSE))
                fParent = TRUE;
            ILFree(pidlProgs);
        }
        ILFree(pidlStart);
    }

    return fParent;
}

//---------------------------------------------------------------------------
// Return the links in a group.
void AppList_AddCurrentStuff(void)
{

    DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating everything..."));

    DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating StartMenu..."));
    Applist_SpecialFolderEnum(CSIDL_STARTMENU);
    if (!StartMenuIsProgramsParent())
    {
        DebugMsg(DM_TRACE, TEXT("gc.al_acs: Enumerating Programs..."));
        Applist_SpecialFolderEnum(CSIDL_PROGRAMS);
    }
}

// On NT we plan on converting NT formated group files into folders and links
// therefore we need the ability of supporting all of the NT group file formats

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  SIZEOFGroup() -                                                         */
/*                                                                          */
/*--------------------------------------------------------------------------*/
DWORD SizeofGroup(LPNT_GROUPDEF lpgd)
{
    LPNT_PMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    // The following needs to be verified
    lptag = (LPNT_PMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((DWORD)((PCHAR)lptag - (PCHAR)lpgd +MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb))+4) <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) + 4)
        && *(PLONG)lptag->rgb == TAG_MAGIC)
      {
        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)))) <= cbSeg)
          {
            if (lptag->wID == ID_LASTTAG)
                return cb;
            (LPSTR)lptag += lptag->cb;
          }
      }
    return lpgd->cbGroup;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  FindTag() -                                                             */
/*                                                                          */
/*--------------------------------------------------------------------------*/

LPNT_PMTAG FindTag(LPNT_GROUPDEF lpgd, int item, WORD id)
{
    LPNT_PMTAG lptag;
    DWORD cbSeg;
    DWORD cb;

    cbSeg = (DWORD)GlobalSize(lpgd);

    lptag = (LPNT_PMTAG)((LPSTR)lpgd+lpgd->cbGroup);

    if ((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) + 4 <= cbSeg
        && lptag->wID == ID_MAGIC
        && lptag->wItem == (int)0xFFFF
        && lptag->cb == (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)) +4)
        && *(LONG *)lptag->rgb == TAG_MAGIC) {

        while ((cb = (DWORD)((PCHAR)lptag - (PCHAR)lpgd + MyDwordAlign(SIZEOF(NT_PMTAG))-MyDwordAlign(SIZEOF(lptag->rgb)))) <= cbSeg)
        {
            if ((item == lptag->wItem)
                && (id == 0 || id == lptag->wID)) {
                return lptag;
            }

            if (lptag->wID == ID_LASTTAG)
                return NULL;

            (LPSTR)lptag += lptag->cb;
        }
    }
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  DeleteTag() -                                                           */
/*                                                                          */
/* in:                                                                      */
/*      hGroup  group handle, can be discardable (alwayws shrink object)        */
/*                                                                          */
/*--------------------------------------------------------------------------*/

VOID DeleteTag(HANDLE hGroup, int item, WORD id)
{
    LPNT_PMTAG lptag;
    LPWSTR lp1, lp2;
    LPWSTR lpend;
    LPNT_GROUPDEF lpgd;

    lpgd = (LPNT_GROUPDEF) GlobalLock(hGroup);

    lptag = FindTag(lpgd,item,id);

    if (lptag == NULL) {
        GlobalUnlock(hGroup);
        return;
    }

    lp1 = (LPWSTR)lptag;

    lp2 = (LPWSTR)((LPSTR)lptag + lptag->cb);

    lpend = (LPWSTR)((LPSTR)lpgd + SizeofGroup(lpgd));

    while (lp2 < lpend) {
        *lp1++ = *lp2++;
    }

    /* always reallocing smaller
     */
    GlobalUnlock(hGroup);
    GlobalReAlloc(hGroup, (DWORD)((LPSTR)lp1 - (LPSTR)lpgd), 0);

    return;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddTag() -                                                              */
/*                                                                          */
/* in:                                                                      */
/*      h       group handle, must not be discardable!                              */
/*                                                                          */
/* returns:                                                                 */
/*  0   failure                                                             */
/*      1       success                                                             */
/*--------------------------------------------------------------------------*/
INT AddTag(HANDLE h, int item, WORD id, LPWSTR lpbuf, UINT cb)
{
    LPNT_PMTAG lptag;
    WORD fAddFirst;
    LPNT_GROUPDEF lpgd;
    int cbNew;
    int cbMyLen;
    LPNT_GROUPDEF lpgdOld;


    if (!cb && lpbuf) {
        cb = SIZEOF(WCHAR)*(lstrlenW(lpbuf) + 1);
    }
    cbMyLen = MyDwordAlign(cb);

    if (!lpbuf) {
        cb = 0;
        cbMyLen = 0;
    }

    /*
     * Remove the old version of the tag, if any.
     */
    DeleteTag(h, item, id);

    lpgd = (LPNT_GROUPDEF)GlobalLock(h);

    lptag = FindTag(lpgd, (int)0xFFFF, (WORD)ID_LASTTAG);

    if (!lptag) {
        /*
         * In this case, there are no tags at all, and we have to add
         * the first tag, the interesting tag, and the last tag
         */
        cbNew = 3 * (MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb))) + 4 + cbMyLen;
        fAddFirst = TRUE;
        lptag = (LPNT_PMTAG)((LPSTR)lpgd + lpgd->cbGroup);

    } else {
        /*
         * In this case, only the interesting tag needs to be added
         * but we count in the last because the delta is from lptag
         */
        cbNew = 2 * (MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb))) + cbMyLen;
        fAddFirst = FALSE;
    }

    /*
     * check for 64K limit
     */
    if ((DWORD_PTR)lptag + cbNew < (DWORD_PTR)lptag) {
        return 0;
    }

    cbNew += (DWORD)((PCHAR)lptag -(PCHAR)lpgd);
    lpgdOld = lpgd;
    GlobalUnlock(h);
    if (!GlobalReAlloc(h, (DWORD)cbNew, GMEM_MOVEABLE)) {
        return 0;
    }

    lpgd = (LPNT_GROUPDEF)GlobalLock(h);
    lptag = (LPNT_PMTAG)((LPSTR)lpgd + ((LPSTR)lptag - (LPSTR)lpgdOld));
    if (fAddFirst) {
        /*
         * Add the first tag
         */
        lptag->wID = ID_MAGIC;
        lptag->wItem = (int)0xFFFF;
        *(LONG *)lptag->rgb = TAG_MAGIC;
        lptag->cb = (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb)) + 4);
        (LPSTR)lptag += lptag->cb;
    }

    /*
     * Add the tag
     */
    lptag->wID = id;
    lptag->wItem = item;
    lptag->cb = (WORD)(MyDwordAlign(SIZEOF(NT_PMTAG)) - MyDwordAlign(SIZEOF(lptag->rgb)) + cbMyLen);
    if (lpbuf) {
        memmove(lptag->rgb, lpbuf, (WORD)cb);
    }
    (LPSTR)lptag += lptag->cb;

    /*
     * Add the end tag
     */
    lptag->wID = ID_LASTTAG;
    lptag->wItem = (int)0xFFFF;
    lptag->cb = 0;

    GlobalUnlock(h);

    return 1;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  CreateNewGroupFromAnsiGroup() -                                                      */
/*                                                                          */
/*  This function creates a new, empty group.                               */
/*                                                                          */
/*--------------------------------------------------------------------------*/

HANDLE CreateNewGroupFromAnsiGroup(LPNT_GROUPDEF_A lpGroupORI)
{
    HANDLE      hT;
    LPNT_GROUPDEF lpgd;
    int         i;
    int         cb;
    int         cItems;          // number of items in 16bit group
    LPSTR       pGroupName;      // 32bit group name
    LPWSTR      pGroupNameUNI = NULL;   // 32bit UNICODE group name
    UINT        wGroupNameLen;   // length of pGroupName DWORD aligned.
    INT         cchWideChar = 0; //character count of resultant unicode string
    INT         cchMultiByte = 0;

    pGroupName = (LPSTR)PTR(lpGroupORI, lpGroupORI->pName);

    //
    // convert pGroupName to unicode here
    //
    cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pGroupName,
            -1,pGroupNameUNI,cchWideChar) ;

    pGroupNameUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

    if (NULL == pGroupNameUNI)
        goto Exit;

    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,pGroupName,
            -1,pGroupNameUNI,cchMultiByte) ;


    wGroupNameLen = MyDwordAlign(SIZEOF(WCHAR)*(lstrlenW(pGroupNameUNI) + 1));
    cItems = lpGroupORI->cItems;
    cb = SIZEOF(NT_GROUPDEF) + (cItems * SIZEOF(DWORD)) +  wGroupNameLen;

    //
    // In CreateNewGroup before GlobalAlloc.
    //
    hT = GlobalAlloc(GHND, (DWORD)cb);
    if (!hT) {
        LocalFree((HLOCAL)pGroupNameUNI);
        goto Exit;
    }

    lpgd = (LPNT_GROUPDEF)GlobalLock(hT);

    //
    // use the NT 1.0 group settings for what we can.
    //
    lpgd->nCmdShow = lpGroupORI->nCmdShow;
    lpgd->wIconFormat = lpGroupORI->wIconFormat;
    lpgd->cxIcon = lpGroupORI->cxIcon;
    lpgd->cyIcon = lpGroupORI->cyIcon;
    lpgd->ptMin.x = (INT)lpGroupORI->ptMin.x;
    lpgd->ptMin.y = (INT)lpGroupORI->ptMin.y;
    CopyRect(&(lpgd->rcNormal),&(lpGroupORI->rcNormal));


    lpgd->dwMagic = GROUP_UNICODE;
    lpgd->cbGroup = (DWORD)cb;
    lpgd->pName = SIZEOF(NT_GROUPDEF) + cItems * SIZEOF(DWORD);

    lpgd->Reserved1 = (WORD)-1;
    lpgd->Reserved2 = (DWORD)-1;

    lpgd->cItems = (WORD)cItems;

    for (i = 0; i < cItems; i++) {
        lpgd->rgiItems[i] = 0;
    }

    lstrcpyW((LPWSTR)((LPBYTE)lpgd + SIZEOF(NT_GROUPDEF) + cItems * SIZEOF(DWORD)),
            pGroupNameUNI); // lhb tracks
    LocalFree((HLOCAL)pGroupNameUNI);

    GlobalUnlock(hT);
    return(hT);

Exit:
    return NULL;
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  AddThing() -                                                            */
/*                                                                          */
/* in:                                                                      */
/*      hGroup  group handle, must not be discardable                       */
/*      lpStuff pointer to data or NULL to init data to zero                */
/*      cbStuff count of item (may be 0) if lpStuff is a string             */
/*                                                                          */
/* Adds an object to the group segment and returns its offset.  Will        */
/* reallocate the segment if necessary.                                     */
/*                                                                          */
/* Handle passed in must not be discardable                                 */
/*                                                                          */
/* returns:                                                                 */
/*      0       failure                                                     */
/*      > 0     offset to thing in the segment                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

DWORD AddThing(HANDLE hGroup, LPWSTR lpStuff, DWORD cbStuff)
{
    DWORD        cb;
    LPNT_GROUPDEF lpgd;
    DWORD        offset;
    LPWSTR       lpT;
    DWORD        cbStuffSize;
    DWORD        cbGroupSize;
    DWORD        myOffset;

    if (cbStuff == 0xFFFFFFFF) {
        return 0xFFFFFFFF;
    }

    if (!cbStuff) {
        cbStuff = SIZEOF(WCHAR)*(DWORD)(1 + lstrlenW(lpStuff));
    }

    cbStuffSize = MyDwordAlign((int)cbStuff);

    lpgd = (LPNT_GROUPDEF)GlobalLock(hGroup);
    cb = SizeofGroup(lpgd);
    cbGroupSize = MyDwordAlign((int)cb);

    offset = lpgd->cbGroup;
    myOffset = (DWORD)MyDwordAlign((int)offset);

    GlobalUnlock(hGroup);

    if (!GlobalReAlloc(hGroup,(DWORD)(cbGroupSize + cbStuffSize), GMEM_MOVEABLE))
        return 0;

    lpgd = (LPNT_GROUPDEF)GlobalLock(hGroup);

    /*
     * Slide the tags up
     */
    memmove((LPSTR)lpgd + myOffset + cbStuffSize, (LPSTR)lpgd + myOffset,
                            (cbGroupSize - myOffset));
    lpgd->cbGroup += cbStuffSize;

    lpT = (LPWSTR)((LPSTR)lpgd + myOffset);
    if (lpStuff) {
        memcpy(lpT, lpStuff, cbStuff);

    } else {
        /*
         * Zero it
         */
        while (cbStuffSize--) {
            *((LPBYTE)lpT)++ = 0;
        }
    }


    GlobalUnlock(hGroup);

    return myOffset;
}

DWORD AddThing_A(HANDLE hGroup, LPSTR lpStuff, WORD cbStuff)
{
    LPWSTR      lpStuffUNI = NULL;
    BOOL        bAlloc = FALSE;
    DWORD cb;

    if (cbStuff == 0xFFFF) {
        return 0xFFFF;
    }

    if (!cbStuff) {
            INT cchMultiByte;
            INT cchWideChar = 0;

        bAlloc = TRUE;
        cchMultiByte=MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
            -1,lpStuffUNI,cchWideChar) ;

        lpStuffUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

        if (lpStuffUNI)
        {
            MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpStuff,
                -1,lpStuffUNI,cchMultiByte) ;

            cbStuff = (WORD)SIZEOF(WCHAR)*(1 + lstrlenW(lpStuffUNI)); // lhb tracks
        }
    } else {
        lpStuffUNI = (LPWSTR)lpStuff;
    }

    if (lpStuffUNI)
    {
        cb = AddThing(hGroup, lpStuffUNI, cbStuff);

        if (bAlloc)
            LocalFree(lpStuffUNI);
    }
    else
    {
        cb = 0;
    }

    return(cb);
}

/*--------------------------------------------------------------------------*/
/*                                                                          */
/*  ConvertToUnicodeGroup() -                                               */
/*                                                                          */
/*  returns the size of the new unicode group.                              */
/*                                                                          */
/*--------------------------------------------------------------------------*/

int ConvertToUnicodeGroup(LPNT_GROUPDEF_A lpGroupORI, LPHANDLE lphNewGroup)
{
    HANDLE hNewGroup;
    LPNT_GROUPDEF lpgd;
    LPNT_ITEMDEF lpid;
    LPBYTE lpid_A;
    LPNT_PMTAG lptag_A;
    LPSTR lpTagValue;
    WORD wTagId;
    LPSTR lpT;
    DWORD offset;
    int cb;
    int i;
    INT cchMultiByte;
    INT cchWideChar;
    LPWSTR lpTagValueUNI;
    BOOL bAlloc = FALSE;

    hNewGroup = CreateNewGroupFromAnsiGroup(lpGroupORI);
    if (!hNewGroup) {
        return(0);
    }

    //
    // Add all items to the new formatted group.
    //
    for (i = 0; i < (int)lpGroupORI->cItems; i++) {

      //
      // Get the pointer to the 16bit item
      //
      lpid_A = (LPBYTE)ITEM(lpGroupORI, i);
      if (lpGroupORI->rgiItems[i]) {

        //
        // Create the item.
        //
        offset = AddThing(hNewGroup, NULL, SIZEOF(NT_ITEMDEF));
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing NT_ITEMDEF failed"));
            goto QuitThis;
        }

        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);

        lpgd->rgiItems[i] = offset;
        lpid = ITEM(lpgd, i);

        //
        // Set the item's position.
        //
        lpid->pt.x = ((LPNT_ITEMDEF_A)lpid_A)->pt.x;
        lpid->pt.y = ((LPNT_ITEMDEF_A)lpid_A)->pt.y;

        //
        // Add the item's Name.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI,((LPNT_ITEMDEF_A)lpid_A)->pName);

        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pName failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pName = offset;

        //
        // Add the item's Command line.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pCommand);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pCommand failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pCommand = offset;

        //
        // Add the item's Icon path.
        //
        GlobalUnlock(hNewGroup);
        lpT = (LPSTR)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pIconPath);
        offset = AddThing_A(hNewGroup, lpT, 0);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pIconPath failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconPath = offset;

        //
        // Get the item's icon resource using the Icon path and the icon index.
        // And add the item's Icon resource.
        //
        lpid->iIcon    = ((LPNT_ITEMDEF_A)lpid_A)->idIcon;
            lpid->cbIconRes = ((LPNT_ITEMDEF_A)lpid_A)->cbIconRes;
            lpid->wIconVer  = ((LPNT_ITEMDEF_A)lpid_A)->wIconVer;
        GlobalUnlock(hNewGroup);

        lpT = (LPBYTE)PTR(lpGroupORI, ((LPNT_ITEMDEF_A)lpid_A)->pIconRes);
        offset = AddThing_A(hNewGroup, (LPSTR)lpT, lpid->cbIconRes);
        if (!offset) {
            DebugMsg(DM_ERROR, TEXT("gc.ctug: AddThing pIconRes failed"));
            goto PuntCreation;
        }
        lpgd = (LPNT_GROUPDEF)GlobalLock(hNewGroup);
        lpid = ITEM(lpgd, i);
        lpid->pIconRes = offset;

        GlobalUnlock(hNewGroup);

      }
    }

    /*
     * Copy all the tags to the new group format.
     */
    lptag_A = (LPNT_PMTAG)((LPSTR)lpGroupORI + lpGroupORI->cbGroup); // lhb tracks

    if (lptag_A->wID == ID_MAGIC &&
        lptag_A->wItem == (int)0xFFFF &&
        *(LONG *)lptag_A->rgb == TAG_MAGIC) {

        //
        // This is the first tag id, goto start of item tags.
        //
        (LPBYTE)lptag_A += lptag_A->cb;

        while (lptag_A->wID != ID_LASTTAG) {

            wTagId = lptag_A->wID;
            cb = lptag_A->cb  - (3 * SIZEOF(DWORD)); // cb - sizeof tag

            if (wTagId == ID_MINIMIZE) {
                lpTagValueUNI = NULL;
            }
            else {
                lpTagValue = lptag_A->rgb ;
                if (wTagId != ID_HOTKEY) {

                    bAlloc = TRUE;
                    cchWideChar = 0;
                    cchMultiByte=MultiByteToWideChar(CP_ACP,
                                         MB_PRECOMPOSED,lpTagValue,
                                        -1,NULL,cchWideChar) ;

                    lpTagValueUNI = LocalAlloc(LPTR,(++cchMultiByte)*SIZEOF(WCHAR)) ;

                    MultiByteToWideChar(CP_ACP,MB_PRECOMPOSED,lpTagValue,
                                        -1,lpTagValueUNI,cchMultiByte) ;
                    cb = SIZEOF(WCHAR)*(lstrlenW(lpTagValueUNI) + 1); // lhb tracks
                }
                else {
                    lpTagValueUNI = (LPWSTR)lpTagValue;
                }
            }

            if (! AddTag( hNewGroup,
                          lptag_A->wItem,   // wItem
                          wTagId,              // wID
                          lpTagValueUNI,          // rgb : tag value
                          cb
                        )) {

                DebugMsg(DM_ERROR, TEXT("gc.ctug: AddTag failed"));
            }

            if (bAlloc && lpTagValueUNI) {
                LocalFree(lpTagValueUNI);
                bAlloc = FALSE;
            }

            (LPBYTE)lptag_A += lptag_A->cb ;      //  go to next tag
        }
    }

    lpgd = GlobalLock(hNewGroup);
    cb = SizeofGroup(lpgd);
    GlobalUnlock(hNewGroup);
    *lphNewGroup = hNewGroup;
    return(cb);

PuntCreation:
QuitThis:
    if (hNewGroup) {
        GlobalFree(hNewGroup);
    }
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\gcinst.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"    
#include "gcinst.h"
#include "util.h"
#include <shellp.h>
#include <trayp.h>
#include <regstr.h>
#include <shguidp.h>
#include <windowsx.h>
#include "rcids.h"
#include "group.h"

#ifdef WINNT
// NT is unicode so use a larger buffer since sizeof(TCHAR) is > than on win95
#define BUFSIZES 40960
#else
// on win95 GetPrivateProfileSection has a 32767 char limit, so
// we make this a bit smaller
#define BUFSIZES 20480
#endif // WINNT

// Define checkbox states for listview
#define LVIS_GCNOCHECK  0x1000
#define LVIS_GCCHECK    0x2000

#define HSZNULL         0
#define HCONVNULL       0
#define HCONVLISTNULL   0
#define DDETIMEOUT      20*1000

extern UINT GC_TRACE;
extern const TCHAR c_szMapGroups[];
BOOL g_fDoProgmanDde = FALSE;
BOOL g_fInitDDE = FALSE;

#define CH_COLON        TEXT(':')

//---------------------------------------------------------------------------
// Global to this file only...
static const TCHAR c_szGrpConvInf[] = TEXT("setup.ini");
static const TCHAR c_szGrpConvInfOld[] = TEXT("setup.old");
static const TCHAR c_szExitProgman[] = TEXT("[ExitProgman(1)]");
static const TCHAR c_szAppProgman[] = TEXT("AppProgman");
static const TCHAR c_szEnableDDE[] = TEXT("EnableDDE");
static const TCHAR c_szProgmanOnly[] = TEXT("progman.only");
static const TCHAR c_szProgmanGroups[] = TEXT("progman.groups");
static const TCHAR c_szDesktopGroups[] = TEXT("desktop.groups");
static const TCHAR c_szStartupGroups[] = TEXT("startup.groups");
static const TCHAR c_szSendToGroups[] = TEXT("sendto.groups");
static const TCHAR c_szRecentDocsGroups[] = TEXT("recentdocs.groups");

//---------------------------------------------------------------------------
const TCHAR c_szProgmanIni[] = TEXT("progman.ini");
const TCHAR c_szStartup[] = TEXT("Startup");
const TCHAR c_szProgmanExe[] = TEXT("progman.exe");
const TCHAR c_szProgman[] = TEXT("Progman");

// NB This must match the one in cabinet.
static const TCHAR c_szRUCabinet[] = TEXT("[ConfirmCabinetID]");

typedef struct
{
        DWORD dwInst;
        HCONVLIST hcl;
        HCONV hconv;
        BOOL fStartedProgman;
} PMDDE, *PPMDDE;

//
// This function grovles HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\ShellFolders
// and creates a DPA with strings of all the speial folders
//
BOOL CreateSpecialFolderDPA(HDPA* phdpaSF)
{
    HKEY hkSP;
    TCHAR szValueName[MAX_PATH];
    DWORD cbValueName;
    DWORD cbData;
    DWORD dwIndex = 0;
    LONG lRet = ERROR_SUCCESS;

    // we should only ever be called once to populate the dpa
    if (*phdpaSF != NULL)
        return FALSE;

    if (RegOpenKeyEx(HKEY_CURRENT_USER,
                     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders"),
                     0,
                     KEY_QUERY_VALUE,
                     &hkSP) != ERROR_SUCCESS)
    {
        // couldnt open the key, so bail
        return FALSE;
    }

    *phdpaSF = DPA_Create(4);

    do
    {
        cbValueName = ARRAYSIZE(szValueName);

        lRet = RegEnumValue(hkSP,
                           dwIndex,
                           szValueName,
                           &cbValueName,
                           NULL,
                           NULL,
                           NULL,
                           &cbData);
        
        if (lRet == ERROR_SUCCESS)
        {
            LPTSTR pszValueData = LocalAlloc(LPTR, cbData);

            if (!pszValueData)
                break;
            
            if (RegQueryValueEx(hkSP,
                                szValueName,
                                NULL,
                                NULL,
                                (LPBYTE)pszValueData,
                                &cbData) == ERROR_SUCCESS)
            {
                DPA_AppendPtr(*phdpaSF, pszValueData);
            }
        }

        dwIndex++;

    } while (lRet != ERROR_NO_MORE_ITEMS);

    return TRUE;
}


//
// SafeRemoveDirectory checks to make sure that we arent removing a "special"
// folder. On win95 when we remove the last shortcut from the %windir%\desktop folder,
// we go and remove that as well. This causes the shell to hang among other bad things.
//
BOOL SafeRemoveDirectory(LPCTSTR pszDir)
{
    static HDPA hdpaSF = NULL;
    int iMax;
    int iIndex;

    if (!hdpaSF && !CreateSpecialFolderDPA(&hdpaSF))
    {
        // if we cant read the special folders, error on the
        // side of caution
        return FALSE;
    }

    iMax = DPA_GetPtrCount(hdpaSF);

    for (iIndex = 0; iIndex < iMax; iIndex++)
    {
        LPTSTR pszSpecialFolder = DPA_GetPtr(hdpaSF, iIndex);

        if (!pszSpecialFolder)
            continue;

        if (lstrcmpi(pszDir, pszSpecialFolder) == 0)
            return FALSE;
    }
   
    // no special folders matched, so its ok to delete it
    return Win32RemoveDirectory(pszDir);
}


//---------------------------------------------------------------------------
void Progman_ReplaceItem(PPMDDE ppmdde, LPCTSTR szName, LPCTSTR pszCL,
        LPCTSTR szArgs, LPCTSTR szIP, int iIcon, LPCTSTR szWD)
{
        TCHAR szBuf[512];

        if (g_fDoProgmanDde)
        {
            wsprintf(szBuf, TEXT("[ReplaceItem(\"%s\")]"), szName);
            DdeClientTransaction((LPBYTE)szBuf, 
                                 (lstrlen(szBuf)+1)*SIZEOF(TCHAR),
                                 ppmdde->hconv,
                                 HSZNULL,
                                 0,
                                 XTYP_EXECUTE,
                                 DDETIMEOUT,
                                 NULL);

            wsprintf(szBuf, TEXT("[AddItem(\"%s %s\",\"%s\",%s,%d,-1,-1,%s)]"), pszCL, szArgs,
                    szName, szIP, iIcon, szWD);
            DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                    XTYP_EXECUTE, DDETIMEOUT, NULL);
        }
}

//---------------------------------------------------------------------------
void Progman_DeleteItem(PPMDDE ppmdde, LPCTSTR szName)
{
        // NB Progman only support 256 char commands.
        TCHAR szBuf[256];

        if (g_fDoProgmanDde)
        {
            wsprintf(szBuf, TEXT("[DeleteItem(%s)]"), szName);
            DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                    XTYP_EXECUTE, DDETIMEOUT, NULL);
        }
}

//---------------------------------------------------------------------------
void Reg_SetMapGroupEntry(LPCTSTR pszOld, LPCTSTR pszNew)
{
    Reg_SetString(g_hkeyGrpConv, c_szMapGroups, pszOld, pszNew);
    DebugMsg(DM_TRACE, TEXT("gc.r_cmge: From %s to %s"), pszOld, pszNew);
}

//---------------------------------------------------------------------------
void GetProperGroupName(LPCTSTR pszGroupPath, LPTSTR pszGroup, int cchGroup)
{    
    LPTSTR pszGroupName;
    
   // Progman only supports a single level hierachy so...
    pszGroupName = PathFindFileName(pszGroupPath);

    // NB If we do have a group within a group then we should add a 
    // MapGroup entry to the registry so running GrpConv in the
    // future won't cause groups to get duplicated.
    if (lstrcmpi(pszGroupName, pszGroupPath) != 0)
    {
        Reg_SetMapGroupEntry(pszGroupName, pszGroupPath);
    }
        
    // A missing group name implies use a default.
    if (!pszGroupName || !*pszGroupName)
    {
        LoadString(g_hinst, IDS_PROGRAMS, pszGroup, cchGroup);
    }
    else
    {
        lstrcpyn(pszGroup, pszGroupName, cchGroup);
    }
}

//---------------------------------------------------------------------------
BOOL Progman_CreateGroup(PPMDDE ppmdde, LPCTSTR pszGroupPath)
{
        // NB Progman only support 256 char commands.
        TCHAR szBuf[256];
        TCHAR szGroup[MAX_PATH];
    HDDEDATA hdata;

    GetProperGroupName(pszGroupPath, szGroup, ARRAYSIZE(szGroup));
    
    if (g_fDoProgmanDde)
    {
        wsprintf(szBuf, TEXT("[CreateGroup(%s)]"), szGroup);
        hdata = DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
                XTYP_EXECUTE, DDETIMEOUT, NULL);
        Assert(hdata);
    }
    else
        return FALSE;
    
    return hdata ? TRUE : FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_ShowGroup(PPMDDE ppmdde, LPCTSTR pszGroupPath)
{
    // NB Progman only support 256 char commands.
    TCHAR szBuf[256];
    TCHAR szGroup[MAX_PATH];
    HDDEDATA hdata;
 
    GetProperGroupName(pszGroupPath, szGroup, ARRAYSIZE(szGroup));

    if (g_fDoProgmanDde)
    {
        wsprintf(szBuf, TEXT("[ShowGroup(%s, %d)]"), szGroup, SW_SHOWNORMAL);
        hdata = DdeClientTransaction((LPBYTE)szBuf, (lstrlen(szBuf)+1)*SIZEOF(TCHAR), ppmdde->hconv, HSZNULL, 0,
            XTYP_EXECUTE, DDETIMEOUT, NULL);
        Assert(hdata);
    }
    else
        return FALSE;
    
    return hdata ? TRUE : FALSE;
}


// Given a string that potentially could be "::{GUID}:DATA::....::{GUID}:DATA::Path",
// return the pointer to the path.  This starts after the last double-colon sequence.
// (Darwin and Logo3 uses this format.)
LPTSTR FindPathSection(LPCTSTR pszPath)
{
    LPCTSTR psz = pszPath;
    LPCTSTR pszFirstColon = NULL;
    LPCTSTR pszDblColon = NULL;

    // Find the last double-colon sequence
    while (*psz)
    {
        if (*psz == CH_COLON)
        {
            // Was the previous character a colon too?
            if (pszFirstColon)
            {
                // Yes; remember that position
                pszDblColon = pszFirstColon;
                pszFirstColon = NULL;
            }
            else
            {
                // No; remember this as a potential for being the first colon
                // in a double-colon sequence
                pszFirstColon = psz;
            }
        }
        else
            pszFirstColon = NULL;

        psz = CharNext(psz);
    }

    if (pszDblColon)
        return (LPTSTR)pszDblColon+2;       // skip the double-colon

    return (LPTSTR)pszPath;
}


#define BG_DELETE_EMPTY                 0x0001
#define BG_PROG_GRP_CREATED             0x0002
#define BG_PROG_GRP_SHOWN               0x0004
#define BG_SEND_TO_GRP                  0x0008
#define BG_LFN                          0x0010
#define BG_RECENT_DOCS                  0x0020
#define BG_SET_PROGRESS_TEXT            0x0040
#define BG_FORCE_DESKTOP                0x0080
#define BG_FORCE_STARTUP                0x0100
#define BG_FORCE_RECENT                 0x0200
#define BG_FORCE_SENDTO                 0x0400

//---------------------------------------------------------------------------
void BuildGroup(LPCTSTR lpszIniFileName, LPCTSTR lpszSection, 
        LPCTSTR lpszGroupName, PPMDDE ppmdde, BOOL fUpdFolder, DWORD dwFlags)
{
    // Data associated with readining in section.
    HGLOBAL hg;
    LPTSTR lpBuf;       // Pointer to buffer to read section into
    int cb;
    LPTSTR pszLine;
    IShellLink *psl;
    TCHAR szName[MAX_PATH];
    TCHAR szCL[3*MAX_PATH]; // we make this 3*MAX_PATH so that DARWIN and LOGO3 callers can pass the extra information
    TCHAR szIP[2*MAX_PATH];
    TCHAR szArgs[2*MAX_PATH];
    TCHAR szGroupFolder[MAX_PATH];
    TCHAR szSpecialGrp[32];
    WCHAR wszPath[2*MAX_PATH];
    TCHAR szWD[2*MAX_PATH];
    TCHAR szDesc[3*MAX_PATH];
    TCHAR szNum[8];      // Should never exceed this!
    LPTSTR lpszArgs;
    TCHAR szCLPathPart[3*MAX_PATH]; // this 3*MAX_PATH because we use them to twiddle with szCL
    TCHAR szCLSpecialPart[3*MAX_PATH]; // this 3*MAX_PATH because we use them to twiddle with szCL
    int iLen;
    int iIcon;
    LPTSTR pszExt;
    // DWORD dwFlags = BG_DELETE_EMPTY;
    
    // BOOL fDeleteEmpty = TRUE;
    // BOOL fProgGrpCreated = FALSE;
    // BOOL fProgGrpShown = FALSE;
    // BOOL fSendToGrp = FALSE;
    // BOOL fLFN;


    Log(TEXT("Setup.Ini: %s"), lpszGroupName);
        
    DebugMsg(GC_TRACE, TEXT("gc.bg: Rebuilding %s"), (LPTSTR) lpszGroupName);

    // Special case [SendTo] section name - this stuff doesn't
    // need to be added to progman.
    LoadString(g_hinst, IDS_SENDTO, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
    if ((dwFlags & BG_FORCE_SENDTO) || (lstrcmpi(lpszSection, szSpecialGrp) == 0))
    {
        DebugMsg(GC_TRACE, TEXT("gc.bg: SendTo section - no Progman group"));
        // fSendToGrp = TRUE;
        dwFlags |= BG_SEND_TO_GRP;
    }

    // Now lets read in the section for the group from the ini file
    // First allocate a buffer to read the section into
    hg  = GlobalAlloc(GPTR, BUFSIZES);  // Should never exceed 64K?
    if (hg)
    {
        lpBuf = GlobalLock(hg);

        // Special case the startup group. 
        LoadString(g_hinst, IDS_STARTUP, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        // Is this the startup group?
        szGroupFolder[0] = TEXT('\0');
        if ((dwFlags & BG_FORCE_STARTUP) || (lstrcmpi(szSpecialGrp, lpszGroupName) == 0))
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Startup group..."));
            // Yep, Try to get the new location.
            Reg_GetString(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER_SHELLFOLDERS, c_szStartup,
            szGroupFolder, SIZEOF(szGroupFolder));
            // fDeleteEmpty = FALSE;
            dwFlags &= ~BG_DELETE_EMPTY;
        }
           
        // Is this the desktop folder?
        LoadString(g_hinst, IDS_DESKTOP, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        if ((dwFlags & BG_FORCE_RECENT) || (lstrcmp(szSpecialGrp, PathFindFileName(lpszGroupName)) == 0))
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Desktop group..."));
            // fDeleteEmpty = FALSE;
            dwFlags &= ~BG_DELETE_EMPTY;
        }

        // Special case the recent folder.
        LoadString(g_hinst, IDS_RECENT, szSpecialGrp, ARRAYSIZE(szSpecialGrp));
        if (lstrcmp(szSpecialGrp, lpszGroupName) == 0)
        {
            DebugMsg(DM_TRACE, TEXT("gc.bg: Recent group..."));
            dwFlags |= BG_RECENT_DOCS;
            dwFlags &= ~BG_DELETE_EMPTY;
        }
        
        if (SUCCEEDED(ICoCreateInstance(&CLSID_ShellLink, &IID_IShellLink, &psl)))
        {
            IPersistFile *ppf;
            psl->lpVtbl->QueryInterface(psl, &IID_IPersistFile, &ppf);


            // now Read in the secint into our buffer
            cb = GetPrivateProfileSection(lpszSection, lpBuf, BUFSIZES/SIZEOF(TCHAR), lpszIniFileName);

            if (cb > 0)
            {
                pszLine = lpBuf;

                // Create the folder...
                // Use a generic name until we get items to add so we
                // don't stick group names like "AT&T" in users faces
                // when all we're trying to do is delete items from them.
                Group_SetProgressNameAndRange((LPCTSTR)-1, cb);

                // Did we fill in the szGroupFolder yet?
                if (!*szGroupFolder)
                {
                    // some people pass us a fully qualified path for lpszGroupName (eg c:\foo\bar or \\pyrex\user\foo)
                    // if that is the case, then use the path they specify
                    if ((PathGetDriveNumber((LPTSTR)lpszGroupName) != -1) || PathIsUNC((LPTSTR)lpszGroupName))
                    {
                        lstrcpy(szGroupFolder, lpszGroupName);
                        iLen = 2; // let PathRemoveIllegalChars validate the whole string after "c:" or "\\"
                    }
                    else
                    {
                        // non-fully qualified groupname, so just construct it under startmenu\programs
                        SHGetSpecialFolderPath(NULL, szGroupFolder, CSIDL_PROGRAMS, TRUE);

                        iLen = lstrlen(szGroupFolder);
                        PathAppend(szGroupFolder, lpszGroupName);
                    }

                    PathRemoveIllegalChars(szGroupFolder, iLen, PRICF_ALLOWSLASH);
                    // This should take care of mapping it if machine does not support LFNs.
                    PathQualify(szGroupFolder);
                }
                else
                {
                    DebugMsg(DM_TRACE, TEXT("gc.bg: Startup group mapped to %s."), szGroupFolder);
                }

                if (fUpdFolder && !(dwFlags & BG_RECENT_DOCS))
                {
                    if (!PathFileExists(szGroupFolder))
                    {
                        if (SHCreateDirectory(NULL, szGroupFolder) != 0)
                        {
                            DebugMsg(DM_ERROR, TEXT("gc.bg: Can't create %s folder."), (LPTSTR) szGroupFolder);
                        }
                    }
                }

                // Keep track if we can create LFN link names on this drive.
                // fLFN = IsLFNDrive(szGroupFolder);
                if (IsLFNDrive((LPCTSTR)szGroupFolder))
                    dwFlags |= BG_LFN;
#ifdef DEBUG                
                if (!(dwFlags & BG_LFN))
                    DebugMsg(DM_TRACE, TEXT("gc.bg: Using short names for this group."), szName);
#endif
                        
                // Add the items...
                //
                // Warning: it appears like the data in the setup.ini file does not
                // match the standard x=y, but is simpy x or x,y,z so we must
                // 1 bias the indexes to ParseField
                while (*pszLine)
                {
                    // Set progress on how many bytes we have processed.
                    Group_SetProgress((int)(pszLine-lpBuf));
                    DebugMsg(GC_TRACE, TEXT("gc.bg: Create Link:%s"), (LPTSTR)pszLine);

                    // Add item.
                    // Get the short name if we're on a SFN drive.
                    szName[0] = TEXT('\0');
                    if (!(dwFlags & BG_LFN))
                        ParseField(pszLine, 7, szName, ARRAYSIZE(szName));
                    // Get the long name if we're not on an SFN drive
                    // or if there is no short name.                   
                    if (!*szName)
                        ParseField(pszLine, 1, szName, ARRAYSIZE(szName));

                    DebugMsg(GC_TRACE, TEXT("  Link:%s"), (LPTSTR)szName);

                    
                    // Dutch/French sometimes have illegal chars in their ini files.
                    // NB Progman needs the unmangled names so only remove illegal chars
                    // from the Explorer string, not szName.
                    // NB Names can contain slashes so PathFindFileName() isn't very
                    // useful here.
                    iLen = lstrlen(szGroupFolder);
                    PathAppend(szGroupFolder, szName);
                    PathRemoveIllegalChars(szGroupFolder, iLen+1, PRICF_NORMAL);

                    // Handle LFNs on a SFN volume.
                    PathQualify(szGroupFolder);

                    if (ParseField(pszLine, 2, szCL, ARRAYSIZE(szCL)) && (*szCL != 0))
                    {
                        // assume that this is not a DARWIN or LOGO3 special link, and thus
                        // the path is just what we just read (szCL)
                        lstrcpy(szCLPathPart, szCL);
                        lstrcpy(szCLSpecialPart, szCL);

                        // We're going to have to add something to the group,
                        // switch to using it's real name.
                        if (!(dwFlags & BG_SET_PROGRESS_TEXT))
                        {
                            dwFlags |= BG_SET_PROGRESS_TEXT;
                            Group_SetProgressNameAndRange(lpszGroupName, cb);
                        }

                        // see if we have ":: or just :: which indicates a special link.
                        // special links have a path that is of the form:
                        //
                        //      ::{GUID1}:data1::{GUID2}:data2::fullpathtolinktarget
                        //
                        // where there could be any number of guid+data sections and the full
                        // path to the link target at the end is optional.
                        //
                        // We seperate this out into the "special" part which contains the guids
                        // and the "path" part which has the fullpathtolinktarget at the end.

                        if (szCLSpecialPart[0]==TEXT('"') && szCLSpecialPart[1]==TEXT(':') && szCLSpecialPart[2]==TEXT(':'))
                        {
                            // the string was quoted and it is a special string
                            LPTSTR pszRealPathBegins;
                            int cch = lstrlen(szCLSpecialPart)+1;

                            // get rid of the leading "
                            hmemcpy(szCLSpecialPart, szCLSpecialPart+1, cch * SIZEOF(TCHAR));
                       
                            // find where the real path begins
                            pszRealPathBegins = FindPathSection(szCLSpecialPart);

                            if (*pszRealPathBegins)
                            {
                                // a path part exists, so add a leading ", and copy
                                // the real fullpathtolinktarget there.
                                lstrcpy(szCLPathPart, TEXT("\""));
                                lstrcat(szCLPathPart, pszRealPathBegins);

                                // terminate the special part after the last ::
                                *pszRealPathBegins = TEXT('\0');
                            }
                            else
                            {
                                // no there is no real path, just special info
                                *szCLPathPart = TEXT('\0');
                            }
                        }
                        else if (szCLSpecialPart[0]==TEXT(':') && szCLSpecialPart[1]==TEXT(':'))
                        {
                            // the string was not quoted and it is a special string
                            LPTSTR pszRealPathBegins = FindPathSection(szCLSpecialPart);

                            if (*pszRealPathBegins)
                            {
                                // we have a real path, so save it
                                lstrcpy(szCLPathPart, pszRealPathBegins);

                                // terminate the special part after the last ::
                                *pszRealPathBegins = TEXT('\0');
                            }
                            else
                            {
                                // no there is no real path, just special info
                                *szCLPathPart = TEXT('\0');
                            }
                        }
                        else
                        {
                            // not a "special" link
                            *szCLSpecialPart = TEXT('\0');
                        }
                            
                        if (*szCLPathPart)
                        {
                            // we have a command line so check for args
                            szArgs[0] = TEXT('\0');
                            lpszArgs = PathGetArgs(szCLPathPart);
                            if (*lpszArgs)
                            {
                                *(lpszArgs-1) = TEXT('\0');
                                lstrcpyn(szArgs, lpszArgs, ARRAYSIZE(szArgs));
                                DebugMsg(GC_TRACE, TEXT("   Cmd Args:%s"), szArgs);
                            }
                            psl->lpVtbl->SetArguments(psl, szArgs);       // arguments

                            PathUnquoteSpaces(szCLPathPart);
                            PathResolve(szCLPathPart, NULL, 0);

                            DebugMsg(GC_TRACE, TEXT("   cmd:%s"), (LPTSTR)szCLPathPart);
                        }

                        if (*szCLPathPart && (dwFlags & BG_RECENT_DOCS))
                        {
                            SHAddToRecentDocs(SHARD_PATH, szCLPathPart);

                            // Progman is just going to get a group called "Documents".
                            if (!(dwFlags & BG_PROG_GRP_CREATED))
                            {
                                if (Progman_CreateGroup(ppmdde, lpszGroupName))
                                    dwFlags |= BG_PROG_GRP_CREATED;
                            }
                            
                            if (dwFlags & BG_PROG_GRP_CREATED)
                                Progman_ReplaceItem(ppmdde, szName, szCLPathPart, NULL, NULL, 0, NULL);
                        }
                        else if (*szCLPathPart || *szCLSpecialPart)
                        {
                            // all we need to call is setpath, it takes care of creating the
                            // pidl for us.  We have to put back the special / path portions here
                            // so we can pass the full DARWIN or LOGO3 information.
                            lstrcpy(szCL, szCLSpecialPart);
                            lstrcat(szCL, szCLPathPart);

                            psl->lpVtbl->SetPath(psl, szCL);
                            // Icon file.
                            ParseField(pszLine, 3, szIP, ARRAYSIZE(szIP));
                            ParseField(pszLine, 4, szNum, ARRAYSIZE(szNum));
                            iIcon = StrToInt(szNum);

                            DebugMsg(GC_TRACE, TEXT("   Icon:%s"), (LPTSTR)szIP);

                            psl->lpVtbl->SetIconLocation(psl, szIP, iIcon);
                            lstrcat(szGroupFolder, TEXT(".lnk"));


                            // NB Field 5 is dependancy stuff that we don't
                            // care about.

                            // WD
#ifdef WINNT
                            /* For NT default to the users home directory, not nothing (which results in
                            /  the current directory, which is unpredictable) */
                            lstrcpy( szWD, TEXT("%HOMEDRIVE%%HOMEPATH%") );
#else
                            szWD[0] = TEXT('\0');
#endif
                            ParseField(pszLine, 6, szWD, ARRAYSIZE(szWD));
                            psl->lpVtbl->SetWorkingDirectory(psl, szWD);

                            // Field 8 is description for the link
                            ParseField(pszLine, 8, szDesc, ARRAYSIZE(szDesc));
                            DebugMsg(GC_TRACE, TEXT("    Description:%s"), (LPTSTR)szDesc);
                            psl->lpVtbl->SetDescription(psl, szDesc);
                            
                            StrToOleStrN(wszPath, ARRAYSIZE(wszPath), szGroupFolder, -1);
                            if (fUpdFolder)
                                ppf->lpVtbl->Save(ppf, wszPath, TRUE);
                                
                            // We've added stuff so don't bother trying to delete the folder
                            // later.
                            // fDeleteEmpty = FALSE;
                            dwFlags &= ~BG_DELETE_EMPTY;
                            
                            // Defer group creation.
                            // if (!fSendToGrp && !fProgGrpCreated)
                            if (!(dwFlags & BG_SEND_TO_GRP) && !(dwFlags & BG_PROG_GRP_CREATED))
                            {
                                if (Progman_CreateGroup(ppmdde, lpszGroupName))
                                    dwFlags |= BG_PROG_GRP_CREATED;
                            }
                            
                            // if (fProgGrpCreated)
                            if (dwFlags & BG_PROG_GRP_CREATED)
                            {
                                // use szCLPathPart for good ol'e progman
                                Progman_ReplaceItem(ppmdde, szName, szCLPathPart, szArgs, szIP, iIcon, szWD);
                            }
                        }
                        else
                        {
                            // NB The assumption is that setup.ini will only contain links
                            // to files that exist. If they don't exist we assume we have
                            // a bogus setup.ini and skip to the next item.
                            DebugMsg(DM_ERROR, TEXT("gc.bg: Bogus link info for item %s in setup.ini"), szName);
                        }
                    }
                    else
                    {
                        // Delete all links with this name.
                        // NB We need to get this from the registry eventually.
                        if (fUpdFolder)
                        {
                            pszExt = szGroupFolder + lstrlen(szGroupFolder);
                            lstrcpy(pszExt, TEXT(".lnk"));
                            Win32DeleteFile(szGroupFolder);
                            lstrcpy(pszExt, TEXT(".pif"));
                            Win32DeleteFile(szGroupFolder);
                        }
                        
                        // Tell progman too. Be careful not to create empty groups just
                        // to try to delete items from it.
                        // if (!fProgGrpShown)
                        if (!(dwFlags & BG_PROG_GRP_SHOWN))
                        {
                            // Does the group already exist?
                            if (Progman_ShowGroup(ppmdde, lpszGroupName))
                               dwFlags |= BG_PROG_GRP_SHOWN;
                               
                            // if (fProgGrpShown)
                            if (dwFlags & BG_PROG_GRP_SHOWN)
                            {
                                // Yep, activate it.
                               Progman_CreateGroup(ppmdde, lpszGroupName);
                            }
                        }

                        // If it exists, then delete the item otherwise don't bother.    
                        // if (fProgGrpShown)
                        if (dwFlags & BG_PROG_GRP_SHOWN)
                            Progman_DeleteItem(ppmdde, szName);
                    }

                    PathRemoveFileSpec(szGroupFolder);       // rip the link name off for next link

                    // Now point to the next line
                    pszLine += lstrlen(pszLine) + 1;
                }
            }

            // The group might now be empty now - try to delete it, if there's still
            // stuff in there then this will safely fail. NB We don't delete empty
            // Startup groups to give users a clue that it's something special.
            
            // if (fUpdFolder && fDeleteEmpty && *szGroupFolder)
            if (fUpdFolder && (dwFlags & BG_DELETE_EMPTY) && *szGroupFolder)
            {
                DebugMsg(DM_TRACE, TEXT("gc.bg: Deleting %s"), szGroupFolder);
                
                // keep trying to remove any directories up the path,
                // so we dont leave an empty directory tree structure.
                //
                // SafeRemoveDirectory fails if the directory is a special folder
                if(SafeRemoveDirectory(szGroupFolder))
                {
                    while(PathRemoveFileSpec(szGroupFolder))
                    {
                        if (!SafeRemoveDirectory(szGroupFolder))
                            break;
                    }
                }
            }

            ppf->lpVtbl->Release(ppf);
            psl->lpVtbl->Release(psl);
        }
    }

    if(hg)
    {
        GlobalFree(hg);
    }

    Log(TEXT("Setup.Ini: %s done."), lpszGroupName);
}

//---------------------------------------------------------------------------
HDDEDATA CALLBACK DdeCallback(UINT uType, UINT uFmt, HCONV hconv, HSZ hsz1, 
        HSZ hsz2, HDDEDATA hdata, ULONG_PTR dwData1, ULONG_PTR dwData2)
{
        return (HDDEDATA) NULL;
}

//---------------------------------------------------------------------------
BOOL _PartnerIsCabinet(HCONV hconv)
{
    //
    // (reinerf)
    // this sends the magical string [ConfirmCabinetID] to our current DDE partner.
    // Explorer.exe will return TRUE here, so we can distinguish it from progman.exe
    // which returns FALSE.
    //
        if (DdeClientTransaction((LPBYTE)c_szRUCabinet, SIZEOF(c_szRUCabinet),
                hconv, HSZNULL, 0, XTYP_EXECUTE, DDETIMEOUT, NULL))
        {
                return TRUE;
        }
        else
        {
                return FALSE;
        }
}

//---------------------------------------------------------------------------
// If progman is not the shell then it will be refusing DDE messages so we
// have to enable it here.
void _EnableProgmanDDE(void)
{
        HWND hwnd;

        hwnd = FindWindow(c_szProgman, NULL);
        while (hwnd)
        {
                // Is it progman?
                if (GetProp(hwnd, c_szAppProgman))
                {
                        DebugMsg(DM_TRACE, TEXT("gc.epd: Found progman, enabling dde."));
                        // NB Progman will clean this up at terminate time.
                        SetProp(hwnd, c_szEnableDDE, (HANDLE)TRUE);
                        break;
                }
                hwnd = GetWindow(hwnd, GW_HWNDNEXT);
        }
}

//---------------------------------------------------------------------------
// Will the real progman please stand up?
BOOL Progman_DdeConnect(PPMDDE ppmdde, HSZ hszService, HSZ hszTopic)
{
        HCONV hconv = HCONVNULL;
        
        Assert(ppmdde);

        DebugMsg(DM_TRACE, TEXT("gc.p_dc: Looking for progman..."));

        _EnableProgmanDDE();

        ppmdde->hcl = DdeConnectList(ppmdde->dwInst, hszService, hszTopic, HCONVLISTNULL, NULL);
        if (ppmdde->hcl)
        {
                hconv = DdeQueryNextServer(ppmdde->hcl, hconv);
                while (hconv)
                {       
                        // DdeQueryConvInfo(hconv, QID_SYNC, &ci);
                        if (!_PartnerIsCabinet(hconv))
                        {
                                DebugMsg(DM_TRACE, TEXT("gc.p_dc: Found likely candidate %x"), hconv);
                                ppmdde->hconv = hconv;
                                return TRUE;
                        }
                        else
                        {
                                DebugMsg(DM_TRACE, TEXT("gc.p_dc: Ignoring %x"), hconv);
                        }
                        hconv = DdeQueryNextServer(ppmdde->hcl, hconv);
                }
        }
        DebugMsg(DM_TRACE, TEXT("gc.p_dc: Couldn't find it."));
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL Window_CreatedBy16bitProcess(HWND hwnd)
{
    DWORD idProcess;

#ifdef WINNT
    return( LOWORD(GetWindowLongPtr(hwnd,GWLP_HINSTANCE)) != 0 );
#else
    GetWindowThreadProcessId(hwnd, &idProcess);
    return GetProcessDword(idProcess, GPD_FLAGS) & GPF_WIN16_PROCESS;
#endif
}

//---------------------------------------------------------------------------
// (reinerf)
// 
// check what the user has as their shell= set to (this is in the
// registry on NT and in the win.ini on win95/memphis.
BOOL IsShellExplorer()
{
    TCHAR szShell[MAX_PATH];

#ifdef WINNT
    {
        HKEY hKeyWinlogon;
        DWORD dwSize;

        szShell[0] = TEXT('\0');

        // Starting with NT4 Service Pack 3, NT honors the value in HKCU over
        // the one in HKLM, so read that first.
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                         0L,
                         KEY_QUERY_VALUE,
                         &hKeyWinlogon) == ERROR_SUCCESS)
        {
            dwSize = SIZEOF(szShell);
            RegQueryValueEx(hKeyWinlogon, TEXT("shell"), NULL, NULL, (LPBYTE)szShell, &dwSize);
            RegCloseKey(hKeyWinlogon);
        }

        if (!szShell[0])
        {
            // no HKCU value, so check HKLM
            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon"),
                             0L,
                             KEY_QUERY_VALUE,
                             &hKeyWinlogon) == ERROR_SUCCESS)
            {
                dwSize = SIZEOF(szShell);
                RegQueryValueEx(hKeyWinlogon, TEXT("shell"), NULL, NULL, (LPBYTE)szShell, &dwSize);
                RegCloseKey(hKeyWinlogon);
            }
        }
    }
#else
    {
        // on win95 we need to read the shell= line from the win.ini
        GetPrivateProfileString(TEXT("boot"),
                                TEXT("shell"),
                                TEXT("explorer.exe"),
                                szShell,
                                MAX_PATH,
                                TEXT("system.ini"));
    }
#endif

    if (lstrcmpi(TEXT("explorer.exe"), szShell) == 0)
        return TRUE;
    else
        return FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_IsRunning(void)
{
    HWND hwnd;
    TCHAR sz[MAX_PATH] = {0};

    hwnd = GetWindow(GetDesktopWindow(), GW_CHILD);
    while (hwnd)
    {
        GetClassName(hwnd, sz, ARRAYSIZE(sz));
#ifdef WINNT
        if (lstrcmpi(sz, c_szProgman) == 0)
#else
        if (Window_CreatedBy16bitProcess(hwnd) && 
            (lstrcmpi(sz, c_szProgman) == 0))
#endif
        {
            return TRUE;
        }
        hwnd = GetWindow(hwnd, GW_HWNDNEXT);
    }
    return FALSE;
}

//---------------------------------------------------------------------------
BOOL Progman_Startup(PPMDDE ppmdde)
{
    HSZ hszService, hszTopic;
    TCHAR szWindowsDir[MAX_PATH];
    int i = 0;
    
    Assert(ppmdde);
        
    // if the users shell is explorer, we dont bother
    // launching progman.exe, or doing any DDE work
    if (IsShellExplorer())
    {
        g_fInitDDE = FALSE;
        g_fDoProgmanDde = FALSE;
        ppmdde->fStartedProgman = FALSE;
        return FALSE;
    }

    // Is Progman running?
    if (Progman_IsRunning())
    {
        // Yep.
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Progman is already running."));
        ppmdde->fStartedProgman = FALSE;
    }        
    else
    {
        // Nope - we'll try to startit.
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Starting Progman..."));
        ppmdde->fStartedProgman = TRUE;


        GetWindowsDirectory(szWindowsDir, MAX_PATH);
#ifdef UNICODE
        // on WINNT progman lives in %windir%\system32
        lstrcat(szWindowsDir, TEXT("\\System32\\"));
#else
        // on win95 & memphis, progman lives in %windir%
        lstrcat(szWindowsDir, TEXT("\\"));
#endif
        lstrcat(szWindowsDir, c_szProgmanExe);

#ifdef UNICODE
        {
            STARTUPINFO si;
            PROCESS_INFORMATION pi;

            si.cb              = SIZEOF(si);
            si.lpReserved      = NULL;
            si.lpDesktop       = NULL;
            si.lpTitle         = NULL;
            si.dwX             = (DWORD)CW_USEDEFAULT;
            si.dwY             = (DWORD)CW_USEDEFAULT;
            si.dwXSize         = (DWORD)CW_USEDEFAULT;
            si.dwYSize         = (DWORD)CW_USEDEFAULT;
            si.dwXCountChars   = 0;
            si.dwYCountChars   = 0;
            si.dwFillAttribute = 0;
            si.dwFlags         = STARTF_USESHOWWINDOW;
            si.wShowWindow     = SW_HIDE;
            si.cbReserved2     = 0;
            si.lpReserved2     = 0;
            si.hStdInput       = NULL;
            si.hStdOutput      = NULL;
            si.hStdError       = NULL;

            if (CreateProcess(szWindowsDir, NULL, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                CloseHandle(pi.hProcess);
                CloseHandle(pi.hThread);
            }
        }
#else
        WinExec(szWindowsDir, SW_HIDE);
#endif
        // Give progman a bit of time to startup but bail after 10s.
        while (!Progman_IsRunning() && (i < 10))
        {
            Sleep(1000);
            i++;
        }
    }

    // Just a bit longer.
    Sleep(1000);
    
    // Grab the focus back?
    if (g_hwndProgress)
            SetForegroundWindow(g_hwndProgress);

    // we are going to try to do DDE, so set g_fInitDDE = TRUE,
    // so that we know to call DdeUninitialize later
    g_fInitDDE = TRUE;

    ppmdde->dwInst = 0;
    DdeInitialize(&ppmdde->dwInst, DdeCallback, APPCLASS_STANDARD|APPCMD_CLIENTONLY, 0);
    hszService = DdeCreateStringHandle(ppmdde->dwInst, (LPTSTR)c_szProgman, CP_WINNEUTRAL);
    hszTopic = DdeCreateStringHandle(ppmdde->dwInst, (LPTSTR)c_szProgman, CP_WINNEUTRAL);
    g_fDoProgmanDde = Progman_DdeConnect(ppmdde, hszService, hszTopic);
    DdeFreeStringHandle(ppmdde->dwInst, hszService);
    DdeFreeStringHandle(ppmdde->dwInst, hszTopic);
    
    return g_fDoProgmanDde;
}

//---------------------------------------------------------------------------
BOOL FindProgmanIni(LPTSTR pszPath)
{
    OFSTRUCT os;
#ifdef UNICODE
    LPTSTR   lpszFilePart;
#endif


    // NB Don't bother looking for the old windows directory, in the case of
    // an upgrade it will be the current windows directory.


    GetWindowsDirectory(pszPath, MAX_PATH);
    PathAppend(pszPath, c_szProgmanIni);

    if (PathFileExists(pszPath))
    {
        return TRUE;
    }
#ifdef UNICODE
    else if (SearchPath(NULL, c_szProgmanIni, NULL, MAX_PATH, pszPath, &lpszFilePart) != 0)
    {
        return TRUE;
    }
#else
    else if (OpenFile(c_szProgmanIni, &os, OF_EXIST) != -1)
    {
        lstrcpy(pszPath, os.szPathName);
        return TRUE;
    }
#endif

    DebugMsg(DM_ERROR, TEXT("Can't find progman.ini"));
    return FALSE;
}

//---------------------------------------------------------------------------
void UpdateTimeStampCallback(LPCTSTR lpszGroup)
{
    WIN32_FIND_DATA fd;
    HANDLE hff;

    DebugMsg(DM_TRACE, TEXT("gc.utc: Updating timestamp for %s."), lpszGroup);

    hff = FindFirstFile(lpszGroup, &fd);
    if (hff != INVALID_HANDLE_VALUE)
    {
        Group_WriteLastModDateTime(lpszGroup,fd.ftLastWriteTime.dwLowDateTime);
        FindClose(hff);
    }
}

//---------------------------------------------------------------------------
void Progman_Shutdown(PPMDDE ppmdde)
{
    TCHAR szIniFile[MAX_PATH];
    
    // only shutdown progman if we actually started it and we 
    // were doing DDE with it.
    if (ppmdde->fStartedProgman && g_fDoProgmanDde)
    {
        Log(TEXT("p_s: Shutting down progman..."));
    
        Log(TEXT("p_s: DdeClientTransaction."));
        DebugMsg(DM_TRACE, TEXT("gc.p_s: Shutting down progman."));
        DdeClientTransaction((LPBYTE)c_szExitProgman, SIZEOF(c_szExitProgman),
                ppmdde->hconv, HSZNULL, 0, XTYP_EXECUTE, DDETIMEOUT, NULL);
    }
        
    // if we initialzied DDE then uninit it now...
    if (g_fInitDDE)
    {
        Log(TEXT("p_s: DdeDisconnect."));
        DdeDisconnectList(ppmdde->hcl);

        Log(TEXT("p_s: DdeUnitialize."));
        DdeUninitialize(ppmdde->dwInst);
    }

    // We just went and modified all progman groups so update the time stamps.
    FindProgmanIni(szIniFile);
    Log(TEXT("p_s: Updating time stamps."));
    Group_Enum(UpdateTimeStampCallback, FALSE, TRUE);
    // Re-do the timestamp so that cab32 won't do another gprconv.
    UpdateTimeStampCallback(szIniFile);

    Log(TEXT("p_s: Done."));
}

//----------------------------------------------------------------------------
void BuildSectionGroups(LPCTSTR lpszIniFile, LPCTSTR lpszSection, 
    PPMDDE ppmdde, BOOL fUpdFolder, DWORD dwFlags)
{
    int cb = 0;
    LPTSTR pszLine;
    TCHAR szSectName[CCHSZSHORT];
    TCHAR szGroupName[2*MAX_PATH];
    LPTSTR lpBuf;
    
    // First allocate a buffer to read the section into
    lpBuf = (LPTSTR) GlobalAlloc(GPTR, BUFSIZES);  // Should never exceed 64K?
    if (lpBuf)
    {
        // Now Read in the secint into our buffer.
        if (PathFileExists(lpszIniFile))
            cb = GetPrivateProfileSection(lpszSection, lpBuf, BUFSIZES/SIZEOF(TCHAR), lpszIniFile);
            
        if (cb > 0)
        {
            Group_SetProgressDesc(IDS_CREATINGNEWSCS);
            pszLine = lpBuf;
            while (*pszLine)
            {
                // Make sure we did not fall off the deep end
                if (cb < (int)(pszLine - lpBuf))
                {
                    Assert(FALSE);
                    break;
                }

                // Now lets extract the fields off of the line
                ParseField(pszLine, 0, szSectName, ARRAYSIZE(szSectName));
                ParseField(pszLine, 1, szGroupName, ARRAYSIZE(szGroupName));

                // Pass off to build that group and update progman.
                BuildGroup(lpszIniFile, szSectName, szGroupName, ppmdde, fUpdFolder, dwFlags);

                // Now setup process the next line in the section
                pszLine += lstrlen(pszLine) + 1;
            }
        }
        GlobalFree((HGLOBAL)lpBuf);
        SHChangeNotify( 0, SHCNF_FLUSH, NULL, NULL);    // Kick tray into updating for real
    }
}

#ifdef WINNT
typedef UINT (__stdcall * PFNGETSYSTEMWINDOWSDIRECTORYW)(LPWSTR pwszBuffer, UINT cchSize);

//
// we need a wrapper for this since it only exists on NT5
//
UINT Wrap_GetSystemWindowsDirectoryW(LPWSTR pszBuffer, UINT cchBuff)
{
    static PFNGETSYSTEMWINDOWSDIRECTORYW s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)-1;

    if (s_pfn)
    {
        HINSTANCE hinst = GetModuleHandle(TEXT("KERNEL32.DLL"));

        if (hinst)
            s_pfn = (PFNGETSYSTEMWINDOWSDIRECTORYW)GetProcAddress(hinst, "GetSystemWindowsDirectoryW");
        else
            s_pfn = NULL;
    }

    if (s_pfn)
        return s_pfn(pszBuffer, cchBuff);
    
    SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
    return 0;
}
#endif // WINNT

//
// We now look for setup.ini in 3 places: first in %userprofile%, next GetWindowsDirectory(),
// and finally in the GetWindowsSystemDirectory() (since hydra can change the return value for
// GetWindowsDirectory but apps still might be putting stuff there).
//
// The reason we look in the %USERPROFILE% directory is that Win2000's new high-security model
// does not give default users write permission to %windir%, so apps will not be able to even
// create a setup.ini in that location. This breaks the per-user install stubs (ie4uinit.exe),
// who are now going to create the setup.ini in %USERPROFILE%, where the user will always have
// write permission.
//
void FindSetupIni(LPTSTR szSetupIniPath, int cchSetupIniPath)
{
    TCHAR szPath[MAX_PATH];

    ExpandEnvironmentStrings(TEXT("%USERPROFILE%"), szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);

    if (PathFileExists(szPath))
    {
        lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
        return;
    }

    // next try GetWindowsDirectory()
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);

    if (PathFileExists(szPath))
    {
        lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
        return;
    }

#ifdef WINNT
    // finally if we are on NT try GetWindowsSystemDirectory()
    if (Wrap_GetSystemWindowsDirectoryW(szPath, ARRAYSIZE(szPath)))
    {
        PathAppend(szPath, c_szGrpConvInf);

        if (PathFileExists(szPath))
        {
            lstrcpyn(szSetupIniPath, szPath, cchSetupIniPath);
            return;
        }
    }
#endif

    // We faild to find it! For compat reasons, we just do what the old code
    // does: GetWindowsDirectory() and PathAppend() and plow ahead...
    GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
    PathAppend(szPath, c_szGrpConvInf);
    return;
}


//---------------------------------------------------------------------------
// This parses the grpconv.inf file and creates the appropriate programs
// folders.
void BuildDefaultGroups(void)
{
    TCHAR szPath[MAX_PATH];
    PMDDE pmdde;

    Log(TEXT("bdg: ..."));
   
    // seek and you will find...
    FindSetupIni(szPath, ARRAYSIZE(szPath));

    // Now lets walk through the different items in this section
    Group_CreateProgressDlg();
    
    // Change the text in the progress dialog so people don't think we're
    // doing the same thing twice.
    // Group_SetProgressDesc(IDS_CREATINGNEWSCS);
    
    // Crank up Progman.
    Progman_Startup(&pmdde);
    // Build the stuff.
    BuildSectionGroups(szPath, c_szProgmanGroups, &pmdde, TRUE, BG_DELETE_EMPTY);
    BuildSectionGroups(szPath, c_szProgmanOnly, &pmdde, FALSE, BG_DELETE_EMPTY);
    // Custom sections.
    BuildSectionGroups(szPath, c_szDesktopGroups, &pmdde, FALSE, BG_FORCE_DESKTOP);
    BuildSectionGroups(szPath, c_szStartupGroups, &pmdde, FALSE, BG_FORCE_STARTUP);
    BuildSectionGroups(szPath, c_szSendToGroups, &pmdde, FALSE, BG_FORCE_SENDTO);
    BuildSectionGroups(szPath, c_szRecentDocsGroups, &pmdde, FALSE, BG_FORCE_RECENT);

    // Close down progman.
    Progman_Shutdown(&pmdde);
    Group_DestroyProgressDlg();
    // HACKHACK (reinerf) - we cant rename setup.ini -> setup.old because this causes problems
    // the second time when it will fail because setup.old already exists (and we possibly dont
    // have acls to overwrite it), and when it fails we orpan setup.ini as well (because the
    // rename failed!!). This after this, all fututre attempts to create a setup.ini will fail,
    // because one already exists, and we may not have acls to overwrite it. So, we just always
    // delete setup.ini when we are done.
    Win32DeleteFile(szPath);
        
    Log(TEXT("bdg: Done."));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\control\init.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include <windows.h>
#include <imm.h>        // ImmDisableIME
#include <cpl.h>
#include <cplp.h>       // CPL_POLICYREFRESH
#include <shellapi.h>   // ShellExecute
#include <shlwapi.h>
#include <shlwapip.h>   // IsOS
#include <debug.h>      // DebugMsg

#define DM_CPTRACE      0

#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif


//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
//  LEAVE THESE IN ENGLISH
//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

const TCHAR c_szCtlPanelClass[] = TEXT("CtlPanelClass");

const TCHAR c_szRunDLL32[]      = TEXT("%SystemRoot%\\system32\\rundll32.exe");
const TCHAR c_szUsersSnapin[]   = TEXT("%SystemRoot%\\system32\\lusrmgr.msc");

const TCHAR c_szRunDLLShell32Etc[]  = TEXT("Shell32.dll,Control_RunDLL ");

const TCHAR c_szControlPanelFolder[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\"");
const TCHAR c_szDoPrinters[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{2227A280-3AEA-1069-A2DE-08002B30309D}\"");
const TCHAR c_szDoFonts[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524152}\"");
const TCHAR c_szDoAdminTools[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D20EA4E1-3957-11d2-A40B-0C5020524153}\"");
const TCHAR c_szDoSchedTasks[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{D6277990-4C6A-11CF-8D87-00AA0060F5BF}\"");
const TCHAR c_szDoNetConnections[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{7007ACC7-3202-11D1-AAD2-00805FC1270E}\"");
const TCHAR c_szDoNetplwizUsers[] =
    TEXT("netplwiz.dll,UsersRunDll");
const TCHAR c_szDoFolderOptions[] =
    TEXT("shell32.dll,Options_RunDLL 0");
const TCHAR c_szDoScannerCamera[] =
    TEXT("\"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\::{E211B736-43FD-11D1-9EFB-0000F8757FCD}\"");

typedef struct
{
    LPCTSTR szOldForm;
    DWORD   dwOS;
    LPCTSTR szFile;
    LPCTSTR szParameters;
} COMPATCPL;

#define OS_ANY          ((DWORD)-1)

COMPATCPL const c_aCompatCpls[] =
{
    {   TEXT("DESKTOP"),          OS_ANY,               TEXT("desk.cpl"),       NULL                },
    {   TEXT("COLOR"),            OS_ANY,               TEXT("desk.cpl"),       TEXT(",@Appearance")},
    {   TEXT("DATE/TIME"),        OS_ANY,               TEXT("timedate.cpl"),   NULL                },
    {   TEXT("PORTS"),            OS_ANY,               TEXT("sysdm.cpl"),      TEXT(",2")          },
    {   TEXT("INTERNATIONAL"),    OS_ANY,               TEXT("intl.cpl"),       NULL                },
    {   TEXT("MOUSE"),            OS_ANY,               TEXT("main.cpl"),       NULL                },
    {   TEXT("KEYBOARD"),         OS_ANY,               TEXT("main.cpl"),       TEXT("@1")          },
    {   TEXT("NETWARE"),          OS_ANY,               TEXT("nwc.cpl"),        NULL                },
    {   TEXT("TELEPHONY"),        OS_ANY,               TEXT("telephon.cpl"),   NULL                },
    {   TEXT("INFRARED"),         OS_ANY,               TEXT("irprops.cpl"),    NULL                },
    {   TEXT("USERPASSWORDS"),    OS_ANYSERVER,         c_szUsersSnapin,        NULL                },
    {   TEXT("USERPASSWORDS"),    OS_WHISTLERORGREATER, TEXT("nusrmgr.cpl"),    NULL                },
    {   TEXT("USERPASSWORDS2"),   OS_ANY,               c_szRunDLL32,           c_szDoNetplwizUsers },
    {   TEXT("PRINTERS"),         OS_ANY,               c_szDoPrinters,         NULL                },
    {   TEXT("FONTS"),            OS_ANY,               c_szDoFonts,            NULL                },
    {   TEXT("ADMINTOOLS"),       OS_ANY,               c_szDoAdminTools,       NULL                },
    {   TEXT("SCHEDTASKS"),       OS_ANY,               c_szDoSchedTasks,       NULL                },
    {   TEXT("NETCONNECTIONS"),   OS_ANY,               c_szDoNetConnections,   NULL                },
    {   TEXT("FOLDERS"),          OS_ANY,               c_szRunDLL32,           c_szDoFolderOptions },
    {   TEXT("SCANNERCAMERA"),    OS_ANY,               c_szDoScannerCamera,    NULL                },
    {   TEXT("STICPL.CPL"),       OS_ANY,               c_szDoScannerCamera,    NULL                },
};

//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


DWORD GetRegisteredCplPath(LPCTSTR pszNameIn, LPTSTR pszPathOut, UINT cchPathOut)
{
    const HKEY rghkeyRoot[] = { HKEY_LOCAL_MACHINE, HKEY_CURRENT_USER };
    const TCHAR szSubkey[]  = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Control Panel\\Cpls");

    DWORD dwResult = ERROR_INSUFFICIENT_BUFFER;

    if (4 <= cchPathOut) // room for beginning/end quotes, at least 1 non-NULL char, and '\0'
    {
        int i;

        *pszPathOut = TEXT('\0');

        for (i = 0; i < ARRAYSIZE(rghkeyRoot) && TEXT('\0') == *pszPathOut; i++)
        {
            HKEY hkey;
            dwResult = RegOpenKeyEx(rghkeyRoot[i],
                                    szSubkey,
                                    0,
                                    KEY_QUERY_VALUE,
                                    &hkey);

            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szName[MAX_PATH];     // Destination for value name.
                TCHAR szPath[MAX_PATH * 2]; // Destination for value data.
                DWORD dwIndex = 0;
                DWORD cbPath;
                DWORD cchName;
                DWORD dwType;

                do
                {
                    cchName = ARRAYSIZE(szName);
                    cbPath  = sizeof(szPath);

                    dwResult = RegEnumValue(hkey,
                                            dwIndex++,
                                            szName,
                                            &cchName,
                                            NULL,
                                            &dwType,
                                            (LPBYTE)szPath,
                                            &cbPath);

                    if (ERROR_SUCCESS == dwResult && sizeof(TCHAR) < cbPath)
                    {
                        if (0 == lstrcmpi(pszNameIn, szName))
                        {
                            //
                            // We have a match.
                            //
                            if (REG_SZ == dwType || REG_EXPAND_SZ == dwType)
                            {
                                //
                                // Enclose the path in quotes (it may contain spaces) and expand env vars.
                                //
                                // Note that cchExpanded includes the terminating '\0'.
                                //
                                DWORD cchExpanded = ExpandEnvironmentStrings(szPath, pszPathOut+1, cchPathOut-2);
                                if (cchExpanded && cchExpanded <= cchPathOut-2)
                                {
                                    ASSERT(pszPathOut[cchExpanded] == TEXT('\0'));
                                    ASSERT(cchExpanded+1 < cchPathOut); // equivalent to "cchExpanded <= cchPathOut-2"
                                    pszPathOut[0] = TEXT('\"');
                                    pszPathOut[cchExpanded] = TEXT('\"');
                                    pszPathOut[cchExpanded+1] = TEXT('\0');
                                }
                                else
                                {
                                    // ExpandEnvironmentStrings failed, or the buffer wasn't big enough.
                                    dwResult = ERROR_INVALID_DATA;
                                }
                            }
                            else
                            {
                                //
                                // Invalid data type.
                                //
                                dwResult = ERROR_INVALID_DATA;
                            }
                            break;
                        }
                    }
                }
                while (ERROR_SUCCESS == dwResult);

                RegCloseKey(hkey);
            }
        }
    }
    return dwResult;
}


// Timer
#define TIMER_QUITNOW   1
#define TIMEOUT         10000

//---------------------------------------------------------------------------
LRESULT CALLBACK DummyControlPanelProc(HWND hwnd, UINT uMsg, WPARAM wparam, LPARAM lparam)
{
    switch (uMsg)
    {
        case WM_CREATE:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Created..."));
            // We only want to hang around for a little while.
            SetTimer(hwnd, TIMER_QUITNOW, TIMEOUT, NULL);
            return 0;
        case WM_DESTROY:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Destroyed..."));
            // Quit the app when this window goes away.
            PostQuitMessage(0);
            return 0;
        case WM_TIMER:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Timer %d"), wparam);
            if (wparam == TIMER_QUITNOW)
            {
                // Get this window to go away.
                DestroyWindow(hwnd);
            }
            return 0;
        case WM_COMMAND:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: Command %d"), wparam);
            // NB Hack for hollywood - they send a menu command to try
            // and open the printers applet. They try to search control panels
            // menu for the printers item and then post the associated command.
            // As our fake window doesn't have a menu they can't find the item
            // and post us a -1 instead (ripping on the way).
            if (wparam == (WPARAM)-1)
            {
                SHELLEXECUTEINFO sei = {0};
                sei.cbSize = sizeof(SHELLEXECUTEINFO);
                sei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE;
                sei.lpFile = c_szDoPrinters;
                sei.nShow = SW_SHOWNORMAL;
                ShellExecuteEx(&sei);
            }
            return 0;
        default:
            DebugMsg(DM_CPTRACE, TEXT("cp.dcpp: %x %x %x %x"), hwnd, uMsg, wparam, lparam);
            return DefWindowProc(hwnd, uMsg, wparam, lparam);
    }
}

//---------------------------------------------------------------------------
HWND _CreateDummyControlPanel(HINSTANCE hinst)
{
    WNDCLASS wc;
    wc.style = 0;
    wc.lpfnWndProc = DummyControlPanelProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hinst;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName = NULL;
    wc.lpszClassName = c_szCtlPanelClass;

    RegisterClass(&wc);
    return CreateWindow(c_szCtlPanelClass, NULL, 0, 0, 0, 0, 0, NULL, NULL, hinst, NULL);
}

BOOL ProcessPolicy(void)
{
    BOOL bResult = FALSE;
    HINSTANCE hInst = LoadLibrary(TEXT("desk.cpl"));
    if (hInst)
    {
        APPLET_PROC pfnCPLApplet = (APPLET_PROC)GetProcAddress(hInst, "CPlApplet");
        if (pfnCPLApplet)
        {
            (*pfnCPLApplet)(NULL, CPL_POLICYREFRESH, 0, 0);
            bResult = TRUE;
        }
        FreeLibrary (hInst);
    }
    return bResult;
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    SHELLEXECUTEINFO sei = {0};
    TCHAR szParameters[MAX_PATH * 2];
    MSG msg;
    HWND hwndDummy;

    DebugMsg(DM_TRACE, TEXT("cp.wm: Control starting."));

    // we need to check for PANEL passed in as an arg.  The run dialog
    // autocomplete shows "Control Panel" as a choice and we used to
    // interpret this as Control with panel as an arg.  So if we have
    // panel as an arg then we do the same processing as when we have
    // "Control" only.
    if (*lpCmdLine && lstrcmpi(lpCmdLine, TEXT("PANEL")))
    {
        int i;

        //
        // Policy hook.  Userenv.dll will call control.exe with the
        // /policy command line switch.  If so, we need to load the
        // desk.cpl applet and refresh the colors / bitmap.
        //
        if (lstrcmpi(TEXT("/policy"), lpCmdLine) == 0)
        {
            return ProcessPolicy();
        }

        //
        // Special case some applets since apps depend on them
        //
        for (i = 0; i < ARRAYSIZE(c_aCompatCpls); i++)
        {
            COMPATCPL const * pItem = &c_aCompatCpls[i];
            if (lstrcmpi(pItem->szOldForm, lpCmdLine) == 0
                && (pItem->dwOS == OS_ANY || IsOS(pItem->dwOS)))
            {
                sei.lpFile = pItem->szFile;
                sei.lpParameters = pItem->szParameters;
                break;
            }
        }

        if (!sei.lpFile)
        {
            int cch;

            //
            // Not a special-case CPL.
            // See if it's registered under "Control Panel\Cpls".
            // If so, we use the registered path.
            //
            lstrcpyn(szParameters, c_szRunDLLShell32Etc, ARRAYSIZE(szParameters));
            cch = lstrlen(szParameters);

            sei.lpFile = c_szRunDLL32;
            sei.lpParameters = szParameters;

            if (ERROR_SUCCESS != GetRegisteredCplPath(lpCmdLine, 
                                                      szParameters + cch,
                                                      ARRAYSIZE(szParameters) - cch))
            {
                //
                // Not registered.  Pass command line through.
                //
                if (cch + lstrlen(lpCmdLine) + sizeof('\0') <= ARRAYSIZE(szParameters))
                {
                    lstrcpyn(szParameters + cch, lpCmdLine, ARRAYSIZE(szParameters) - cch);
                }
                else
                {
                    // fail
                    return FALSE;
                }
            }
        }
    }
    else
    {
        // Open the Control Panel folder
        sei.lpFile = c_szControlPanelFolder;
    }

    // We create this window for ancient Win3x app compatibility. We used to
    // tell ISV's to exec control.exe and look for a window with this classname,
    // then send it messages to do stuff.  With one exception (see DummyControlPanelProc)
    // we haven't responded to any messages since Win3x, but we still keep
    // this around for app compat.
    ImmDisableIME(0);
    hwndDummy = _CreateDummyControlPanel(hInstance);

    // HACK: NerdPerfect tries to open a hidden control panel to talk to
    // we are blowing off fixing the communication stuff so just make
    // sure the folder does not appear hidden
    if (nCmdShow == SW_HIDE)
        nCmdShow = SW_SHOWNORMAL;

    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_FLAG_DDEWAIT | SEE_MASK_WAITFORINPUTIDLE | SEE_MASK_DOENVSUBST;
    sei.nShow = nCmdShow;

    ShellExecuteEx(&sei);

    if (IsWindow(hwndDummy))
    {
        while (GetMessage(&msg, NULL, 0, 0))
        {
            DispatchMessage(&msg);
        }
    }

    DebugMsg(DM_TRACE, TEXT("cp.wm: Control exiting."));

    return TRUE;
}

//---------------------------------------------------------------------------
// Stolen from the CRT, used to shrink our code.
int _stdcall ModuleEntry(void)
{
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    ExitProcess(WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT));
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

NTLEANANDMEAN=

TARGETNAME=grpconv
TARGETPATH=obj
TARGETTYPE=PROGRAM

NOT_LEAN_AND_MEAN=1

# this is an OS component and therefore it needs the OS version stamp
USE_NT_PRODUCT_VER=1

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\shell32\shell32.inc

!if defined(TARGET_WIN95)
USE_LIBCMT      = 1
!else
# Need to use libc.lib for NT version for now
USE_MSVCRT=1
!endif

!if defined(TARGET_WIN95)
C_DEFINES=$(C_DEFINES)
!else
C_DEFINES=$(C_DEFINES) -DNT -DWINNT -DUNICODE
!endif

# Make warnings equivalent to errors
!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF

MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

INCLUDES=.;..;

SOURCES= \
         ..\gcinst.c \
         ..\group.c  \
         ..\util.c   \
         ..\init.c   \
	 ..\grpconv.rc

UMTYPE=windows
!IF $(386)
UMENTRYABS=ModuleEntry@0
!ELSE
UMENTRYABS=ModuleEntry
!ENDIF

!if defined(TARGET_WIN95)
UMLIBS= \
        $(SDK_LIB_DEST)\chicago\i386\kernel32.lib         \
        $(SDK_LIB_DEST)\chicago\i386\gdi32.lib            \
        $(SDK_LIB_DEST)\chicago\i386\user32.lib
	
TARGETLIBS=\
        $(SHELL_LIB_PATH)\comctlp.lib        \
        $(CCSHELL_DIR)\lib\i386\shell32.w95     \
        $(PROJECT_ROOT)\lib\$(O)\shguid.lib  \
        $(SDK_LIB_PATH)\version.lib
!else
TARGETLIBS= \
        $(SHELL_LIB_PATH)\comctlp.lib      \
        $(SDK_LIB_PATH)\version.lib        \
        $(PROJECT_ROOT)\lib\$(O)\shguid.lib  \
!if $(386)	
        $(CCSHELL_DIR)\lib\i386\shell32.nt4
!else	
        $(SHELL_LIB_PATH)\shell32p.lib
!endif	

!endif

TARGETLIBS = $(TARGETLIBS) \
        $(PROJECT_ROOT)\lib\$(O)\shguidp.lib \

PRECOMPILED_INCLUDE=..\grpconv.h
PRECOMPILED_PCH=grpconv.pch
PRECOMPILED_OBJ=grpconv.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\init.c ===
#include "grpconv.h"
#include "util.h"
#include "rcids.h"
#include "group.h"
#include "gcinst.h"
#include <shellp.h>
#include <windowsx.h>
#include <regstr.h>

// we only call ImmDisableIME if we can sucessfully LoadLibrary
// and GetProcAddress it, since this function did not exist on NT4
// and win95.
extern BOOL WINAPI ImmDisableIME(DWORD);


//---------------------------------------------------------------------------
// Global to this file only...

const TCHAR g_szGRP[] = TEXT("grp");
const TCHAR c_szClassInfo[]     = STRINI_CLASSINFO;
const TCHAR g_szMSProgramGroup[] = TEXT("MSProgramGroup");
const TCHAR g_szSpacePercentOne[] = TEXT(" %1");
const TCHAR c_szGroups[] = TEXT("Groups");
const TCHAR c_szSettings[] = TEXT("Settings");
const TCHAR c_szWindow[] = TEXT("Window");
const TCHAR c_szNULL[] = TEXT("");
const TCHAR c_szRegGrpConv[] = REGSTR_PATH_GRPCONV;
const TCHAR c_szCLSID[] = TEXT("CLSID");
const CHAR c_szReporter[] = "reporter.exe -q";
const TCHAR c_szCheckAssociations[] = TEXT("CheckAssociations");
const TCHAR c_szRegExplorer[] = REGSTR_PATH_EXPLORER;
const TCHAR c_szDotDoc[] = TEXT(".doc");
const TCHAR c_szWordpadDocument[] = TEXT("wordpad.document");
const TCHAR c_szWordpadDocumentOne[] = TEXT("wordpad.document.1");
const TCHAR c_szUnicodeGroups[] = TEXT("UNICODE Program Groups");
const TCHAR c_szAnsiGroups[] = TEXT("Program Groups");
const TCHAR c_szCommonGroups[] = TEXT("SOFTWARE\\Program Groups");

HKEY g_hkeyGrpConv;

//---------------------------------------------------------------------------
// Global to the app...
HINSTANCE g_hinst;
TCHAR     g_szStartGroup[MAXGROUPNAMELEN + 1];
UINT      GC_TRACE = 0;       // Default no tracing
BOOL      g_fShowUI = TRUE;

// Forward declarations

int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow);


//---------------------------------------------------------------------------
BOOL InitApplication(HINSTANCE hInstance)
{
    TCHAR szTypeName[CCHSZNORMAL];
    TCHAR szPath[MAX_PATH];

    // Register this app as being able to handle progman groups.
    LoadString(hInstance, IDS_GROUPTYPENAME, szTypeName, ARRAYSIZE(szTypeName));
    // Get the path to this app.
    GetModuleFileName(hInstance, szPath, ARRAYSIZE(szPath));
    // Tag on the percent one thingy.
    lstrcat(szPath, g_szSpacePercentOne);
    // Regsiter the app.
    ShellRegisterApp(g_szGRP, g_szMSProgramGroup, szTypeName, szPath, TRUE);
    // Explorer key.
    RegCreateKey(HKEY_CURRENT_USER, c_szRegGrpConv, &g_hkeyGrpConv);

    Log(TEXT("Init Application."));

    return TRUE;
}

//---------------------------------------------------------------------------
void UnInitApplication(void)
{
    Log(TEXT("Uninit Application."));

    if (g_hkeyGrpConv)
        RegCloseKey(g_hkeyGrpConv);
}

// Do this here instead of in Explorer so we don't keep overwriting
// user settings.
#if 1
//----------------------------------------------------------------------------
const TCHAR c_szExplorer[] = TEXT("Explorer");
const TCHAR c_szRestrictions[] = TEXT("Restrictions");
const TCHAR c_szEditLevel[] = TEXT("EditLevel");
const TCHAR c_szNoRun[] = TEXT("NoRun");
const TCHAR c_szNoClose[] = TEXT("NoClose");
const TCHAR c_szNoSaveSettings[] = TEXT("NoSaveSettings");
const TCHAR c_szNoFileMenu[] = TEXT("NoFileMenu");
const TCHAR c_szShowCommonGroups[] = TEXT("ShowCommonGroups");
const TCHAR c_szNoCommonGroups[] = TEXT("NoCommonGroups");

void Restrictions_Convert(LPCTSTR szIniFile)
{
    DWORD dw, cbData, dwType;
    HKEY hkeyPolicies, hkeyPMRestrict;
    
    DebugMsg(DM_TRACE, TEXT("c.cr: Converting restrictions..."));
    
    if (RegCreateKey(HKEY_CURRENT_USER, REGSTR_PATH_POLICIES, &hkeyPolicies) == ERROR_SUCCESS)
    {
        // Get them. Set them.
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
            TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Program Manager\\Restrictions"),
            0, KEY_READ, &hkeyPMRestrict) == ERROR_SUCCESS) {
            
            cbData = sizeof(dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szEditLevel, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szEditLevel, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoRun, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoRun, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoClose, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoClose, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoSaveSettings, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoSaveSettings, dw);
            
            dw = 0;
            RegQueryValueEx(hkeyPMRestrict, c_szNoFileMenu, 0, &dwType, (LPBYTE)&dw, &cbData);
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoFileMenu, dw);
            
            dw = 0;
            if (RegQueryValueEx(hkeyPMRestrict, c_szShowCommonGroups, 0, &dwType, (LPBYTE)&dw, &cbData) == ERROR_SUCCESS) {
                dw = !dw;
            }
            Reg_SetDWord(hkeyPolicies, c_szExplorer, c_szNoCommonGroups, dw);
            
            RegCloseKey (hkeyPMRestrict);
        }
        RegCloseKey(hkeyPolicies);
    }
    else
    {
        DebugMsg(DM_ERROR, TEXT("gc.cr: Unable to create policy key for registry."));
        DebugMsg(DM_ERROR, TEXT("gc.cr: Restrictions can not be converted."));
    }
}
#endif

void CALLBACK Group_EnumCallback(LPCTSTR lpszGroup)
{
    Group_Convert(NULL, lpszGroup, 0);
}

// convert all 3.x groups to chicago directories and links
void DoAutoConvert(BOOL fModifiedOnly, BOOL bConvertGRPFiles)
{
    TCHAR szIniFile[MAX_PATH];
    int cb, cGroups = 0;

    Restrictions_Convert(NULL);

    cGroups = Group_EnumNT(Group_EnumCallback, TRUE, fModifiedOnly,
                         HKEY_CURRENT_USER, c_szUnicodeGroups);

    if (cGroups == 0) {

        //
        // Try ANSI progman groups (Upgrade from NT 3.1)
        //

        cGroups = Group_EnumNT(Group_EnumCallback, TRUE, fModifiedOnly,
                             HKEY_CURRENT_USER, c_szAnsiGroups);
    }

    if (bConvertGRPFiles && (cGroups == 0)) {

        //
        // Convert .grp files
        //

        cGroups = Group_Enum(Group_EnumCallback, TRUE, fModifiedOnly);
    }
}

void CALLBACK Group_ListApps(LPCTSTR lpszGroup)
{
    DebugMsg(DM_TRACE, TEXT("gc.g_la: %s"), lpszGroup);
    Group_Convert(NULL, lpszGroup, GC_BUILDLIST);
}

// Grovel the old .grp files to build a list of all the old installed apps.
void AppList_Build(void)
{
    DebugMsg(DM_TRACE, TEXT("gc.bal: Building app list..."));
    AppList_Create();
    Group_EnumOldGroups(Group_ListApps, TRUE);
    AppList_AddCurrentStuff();
    AppList_WriteFile();
    AppList_Destroy();
}

// FILE_ATTRIBUTE_READONLY         0x00000001
// FILE_ATTRIBUTE_HIDDEN           0x00000002
// FILE_ATTRIBUTE_SYSTEM           0x00000004

void DoDelete(LPCTSTR pszPath, LPCTSTR pszLongName)
{
    TCHAR szTo[MAX_PATH], szTemp[MAX_PATH];
    BOOL fDir = FALSE;

    // if the first character is an asterisk, it means to
    // treat the name as a directory
    if (*pszLongName == TEXT('*'))
    {
        fDir = TRUE;
        pszLongName = CharNext(pszLongName);
    }

    if (ParseField(pszLongName, 1, szTemp, ARRAYSIZE(szTemp)))
    {
        PathCombine(szTo, pszPath, szTemp);

        if (fDir)
        {
            // NOTE: RemoveDirectory fails if the directory
            // is not empty.  It is by design that we do not
            // recursively delete every file and directory.
            RemoveDirectory(szTo);
        }
        else
        {
            DeleteFile(szTo);
        }
    }
}

void DoRenameSetAttrib(LPCTSTR pszPath, LPCTSTR pszShortName, LPCTSTR pszLongName, BOOL bLFN)
{
    DWORD dwAttributes;
    TCHAR szFrom[MAX_PATH], szTo[MAX_PATH], szTemp[MAX_PATH];

    if (bLFN && (ParseField(pszLongName, 1, szTemp, ARRAYSIZE(szTemp))))
    {
        PathCombine(szFrom, pszPath, pszShortName);
        PathCombine(szTo, pszPath, szTemp);
        if (!MoveFile(szFrom, szTo))
        {
            DWORD dwError = GetLastError();
            DebugMsg(DM_TRACE, TEXT("c.rsa: Rename %s Failed %x"), szFrom, dwError);

            // Does the destination already exist?
            if (dwError == ERROR_ALREADY_EXISTS)
            {
                // Delete it.
                if (DeleteFile(szTo))
                {
                    if (!MoveFile(szFrom, szTo))
                    {
                        dwError = GetLastError();
                        DebugMsg(DM_TRACE, TEXT("c.rsa: Rename after Delete %s Failed %x"), szFrom, dwError);
                    }
                }
            }
        }
    }
    else
    {
        // use this to set the attributes on
        PathCombine(szTo, pszPath, pszShortName);
    }

    ParseField(pszLongName, 2, szTemp, ARRAYSIZE(szTemp));
    dwAttributes = (DWORD)StrToInt(szTemp);
    if (dwAttributes)
        SetFileAttributes(szTo, dwAttributes);
}

const TCHAR c_szDeleteRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DeleteFiles");
const TCHAR c_szRenameRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\RenameFiles");
const TCHAR c_szPreRenameRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\PreConvRenameFiles");

//
// this was stolen from shlwapi\reg.c, we cant link to it since we are "grpconv.exe",
// and we do not move in the same social circles as shlwapi.
//
DWORD NT5RegDeleteKey(HKEY hkey, LPCTSTR pszSubKey)
{
    DWORD dwRet;
    HKEY hkSubKey;

    // Open the subkey so we can enumerate any children
    dwRet = RegOpenKeyEx(hkey, pszSubKey, 0, KEY_ALL_ACCESS, &hkSubKey);
    if (ERROR_SUCCESS == dwRet)
    {
        DWORD   dwIndex;
        TCHAR   szSubKeyName[MAX_PATH + 1];
        DWORD   cchSubKeyName = ARRAYSIZE(szSubKeyName);
        TCHAR   szClass[MAX_PATH];
        DWORD   cbClass = ARRAYSIZE(szClass);

        // I can't just call RegEnumKey with an ever-increasing index, because
        // I'm deleting the subkeys as I go, which alters the indices of the
        // remaining subkeys in an implementation-dependent way.  In order to
        // be safe, I have to count backwards while deleting the subkeys.

        // Find out how many subkeys there are
        dwRet = RegQueryInfoKey(hkSubKey,
                                szClass,
                                &cbClass,
                                NULL,
                                &dwIndex, // The # of subkeys -- all we need
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                NULL);

        if (NO_ERROR == dwRet)
        {
            // dwIndex is now the count of subkeys, but it needs to be
            // zero-based for RegEnumKey, so I'll pre-decrement, rather
            // than post-decrement.
            while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
            {
                NT5RegDeleteKey(hkSubKey, szSubKeyName);
            }
        }

        RegCloseKey(hkSubKey);

        dwRet = RegDeleteKey(hkey, pszSubKey);
    }

    return dwRet;
}

void DoFileRenamesOrDeletes(LPCTSTR pszKey, BOOL fDelete)
{
    HKEY hkey;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, pszKey, &hkey) == ERROR_SUCCESS)
    {
        TCHAR szKey[32];
        int iKey;

        for (iKey = 0; RegEnumKey(hkey, iKey, szKey, ARRAYSIZE(szKey)) == ERROR_SUCCESS; iKey++)
        {
            HKEY hkeyEnum;

            // each key under here lists files to be renamed in a certain folder

            if (RegOpenKey(hkey, szKey, &hkeyEnum) == ERROR_SUCCESS)
            {
                DWORD cbValue;
                TCHAR szPath[MAX_PATH];

                // get the path where these files are
                cbValue = sizeof(szPath);
                if ((RegQueryValue(hkey, szKey, szPath, &cbValue) == ERROR_SUCCESS) && szPath[0])
                {
                    TCHAR szShortName[13], szLongName[MAX_PATH];
                    DWORD cbData, cbValue, dwType, iValue;
                    BOOL bLFN = IsLFNDrive(szPath);

                    for (iValue = 0; cbValue = ARRAYSIZE(szShortName), cbData = sizeof(szLongName),
                         (RegEnumValue(hkeyEnum, iValue, szShortName, &cbValue, NULL, &dwType, (LPBYTE)szLongName, &cbData) == ERROR_SUCCESS);
                         iValue++)
                    {
                        if (szShortName[0] && ( dwType == REG_SZ ) )
                        {
                            if (fDelete)
                                DoDelete(szPath, szLongName);
                            else
                                DoRenameSetAttrib(szPath, szShortName, szLongName, bLFN);
                        }
                    }
                }
                RegCloseKey(hkeyEnum);
            }
        }
        // Toast this whole section so we don't ever try to do renames or deletes twice.
        // We need to call NT5RegDeleteKey since on NT we dont nuke it if subkeys exist, but this helper does.
        NT5RegDeleteKey(HKEY_LOCAL_MACHINE, pszKey);
        RegCloseKey(hkey);
    }
}

void DoFileRenames(LPCTSTR pszKey)
{
    DoFileRenamesOrDeletes(pszKey, FALSE);
}

void DoFileDeletes(LPCTSTR pszKey)
{
    DoFileRenamesOrDeletes(pszKey, TRUE);
}

const TCHAR c_szLinksRoot[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Links");

void DoCopyLinks()
{
    HKEY hkey;
    BOOL bLFN;
    LPTSTR szSrcName, szDstName, szGroupFolder, szLinkName, szCmd;

    // DebugBreak();

    // Allocate buffer
    //
    if ((szSrcName = (LPTSTR)LocalAlloc(LPTR, 6*MAX_PATH)) == NULL)
      return;
    szDstName     = szSrcName+MAX_PATH;
    szGroupFolder = szDstName+MAX_PATH;
    szLinkName    = szGroupFolder+MAX_PATH;
    szCmd         = szLinkName+MAX_PATH;

    // Get the path to the special folder
    //
    SHGetSpecialFolderPath(NULL, szGroupFolder, CSIDL_PROGRAMS, TRUE);
    bLFN = IsLFNDrive(szGroupFolder);

    // Enumerate each link
    //
    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szLinksRoot, &hkey) == ERROR_SUCCESS)
    {
        DWORD cbData, cbValue, dwType, iValue;

        for (iValue = 0; cbValue = MAX_PATH, cbData = 2*MAX_PATH*sizeof(TCHAR),
             (RegEnumValue(hkey, iValue, szLinkName, &cbValue, NULL, &dwType, (LPBYTE)szCmd, &cbData) == ERROR_SUCCESS);
             iValue++)
        {
            if (szLinkName[0] && (dwType == REG_SZ))
            {
                // Build the destination name
                //
                lstrcpy(szDstName, szGroupFolder);
                ParseField(szCmd, 1, szSrcName, MAX_PATH);
                PathAppend(szDstName, szSrcName);

                // Check the volume type
                //
                if (bLFN)
                {
                    PathAppend(szDstName, szLinkName);
                    lstrcat(szDstName, TEXT(".lnk"));
                    ParseField(szCmd, 2, szSrcName, MAX_PATH);
                }
                else
                {
                    ParseField(szCmd, 2, szSrcName, MAX_PATH);
                    PathAppend(szDstName, PathFindFileName(szSrcName));
                }

                MoveFile(szSrcName, szDstName);
            }
        }
        // Nuke this section so we don't do copies twice.
        RegDeleteKey(HKEY_LOCAL_MACHINE, c_szLinksRoot);

        RegCloseKey(hkey);
    }

    LocalFree((HLOCAL)szSrcName);
}

// makes sure the current user's metrics are stored in scalable units
void ConvertMetricsToScalableUnits(BOOL fKeepBradsSettings)
{
    NONCLIENTMETRICS ncm;
    LOGFONT lf;
    HDC screen;
    int value;
    int floor = 0;

    // USER always writes out font sizes in points and metrics in twips
    // get and set everything of interest

    ncm.cbSize = sizeof( NONCLIENTMETRICS );
    SystemParametersInfo( SPI_GETNONCLIENTMETRICS, sizeof( ncm ),
        (void *)(LPNONCLIENTMETRICS)&ncm, FALSE );
    SystemParametersInfo( SPI_SETNONCLIENTMETRICS, sizeof( ncm ),
        (void *)(LPNONCLIENTMETRICS)&ncm, SPIF_UPDATEINIFILE );

    SystemParametersInfo( SPI_GETICONTITLELOGFONT, sizeof( lf ),
        (void *)(LPLOGFONT)&lf, FALSE );
    SystemParametersInfo( SPI_SETICONTITLELOGFONT, sizeof( lf ),
        (void *)(LPLOGFONT)&lf, SPIF_UPDATEINIFILE );

    // HACK: Win3x users could get into 120 DPI without upping the icon spacing
    // they need the equivalent of 75 pixels in the current logical resolution
    if (!fKeepBradsSettings)
    {
        screen = GetDC( NULL );
        if (screen)
        {
            floor = MulDiv( 75, GetDeviceCaps( screen, LOGPIXELSX ), 96 );
            ReleaseDC( NULL, screen );
        }
        else
        {
            floor = 0;
        }

        value = GetSystemMetrics( SM_CXICONSPACING );
        SystemParametersInfo( SPI_ICONHORIZONTALSPACING, max( value, floor ),
            NULL, SPIF_UPDATEINIFILE );

        value = GetSystemMetrics( SM_CYICONSPACING );
        SystemParametersInfo( SPI_ICONVERTICALSPACING, max( value, floor ),
            NULL, SPIF_UPDATEINIFILE );
    }

}

//----------------------------------------------------------------------------
// We need to nuke progman's window settings on first boot so it doesn't
// fill the screen and obscure the tray if we're in Win3.1 UI mode.
void NukeProgmanSettings(void)
{
    WritePrivateProfileString(c_szSettings, c_szWindow, NULL, c_szProgmanIni);
}

// Tells Explorer to check the win.ini extensions section.
void ExplorerCheckAssociations(void)
{
    DWORD dw = 1;

    Reg_Set(HKEY_CURRENT_USER, c_szRegExplorer, c_szCheckAssociations,
        REG_BINARY, &dw, sizeof(dw));
}

// The setup flag is set for first boot stuff (-s) and not for maintenance
// mode (-o).
void DoRandomOtherStuff(BOOL fSetup, BOOL fKeepBradsSettings)
{
    Log(TEXT("dros: ..."));

    Log(TEXT("dros: Renames."));
    DoFileRenames(c_szRenameRoot);
    Log(TEXT("dros: Copies."));
    DoCopyLinks();
    Log(TEXT("dros: Deletes."));
    DoFileDeletes(c_szDeleteRoot);

    if (fSetup)
    {
        Log(TEXT("dros: Converting metrics."));
        ConvertMetricsToScalableUnits(fKeepBradsSettings);
        Log(TEXT("dros: Nuking Progman settings."));
        NukeProgmanSettings();
        // GenerateSetupExitEvent();
        ExplorerCheckAssociations();
    }

    Log(TEXT("dros: Done."));
}

void DoConversion(HINSTANCE hinst, LPTSTR lpszCmdLine)
{
    HKEY hKey;
    DWORD Err, DataType, DataSize = sizeof(DWORD);
    DWORD Value;
    TCHAR szFile[MAX_PATH];
    TCHAR szFilters[CCHSZNORMAL];
    TCHAR szTitle[CCHSZNORMAL];
    HCURSOR hCursor;
    UINT olderrormode;

    *szFile = TEXT('\0');
    GetWindowsDirectory(szFile, ARRAYSIZE(szFile));
    PathAddBackslash(szFile);

    // set the error mode to ignore noopenfileerrorbox so on japanese PC-98 machines
    // whose hard drive is A: we dont ask for a floppy when running grpconv.
    olderrormode = SetErrorMode(0);
    SetErrorMode(olderrormode | SEM_NOOPENFILEERRORBOX | SEM_FAILCRITICALERRORS);

    // Is GUI Setup currently running?
    if ((Err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                           TEXT("System\\Setup"),
                           0,
                           KEY_READ,
                           &hKey)) == ERROR_SUCCESS) {

        Err = RegQueryValueEx(
                    hKey,
                    TEXT("SystemSetupInProgress"),
                    NULL,
                    &DataType,
                    (LPBYTE)&Value,
                    &DataSize);

        RegCloseKey(hKey);
    }

    if ( (Err == NO_ERROR) && Value ) {
        g_fShowUI = FALSE;
    }


    if (!lstrcmpi(lpszCmdLine, TEXT("/m")) || !lstrcmpi(lpszCmdLine, TEXT("-m")))
    {
        // manual mode

        // Get something from a commdlg....
        LoadString(hinst, IDS_FILTER, szFilters, ARRAYSIZE(szFilters));
        ConvertHashesToNulls(szFilters);
        LoadString(hinst, IDS_COMMDLGTITLE, szTitle, ARRAYSIZE(szTitle));
        // Keep going till they hit cancel.
        while (GetFileNameFromBrowse(NULL, szFile, ARRAYSIZE(szFile), NULL, g_szGRP, szFilters, szTitle))
        {
            Group_CreateProgressDlg();
            Group_Convert(NULL, szFile, GC_PROMPTBEFORECONVERT | GC_REPORTERROR | GC_OPENGROUP);
            Group_DestroyProgressDlg();
        }
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/s")) || !lstrcmpi(lpszCmdLine, TEXT("-s")))
    {
        // Rebuild - without the logo.
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(FALSE, TRUE);
        BuildDefaultGroups();
        DoRandomOtherStuff(TRUE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/n")) || !lstrcmpi(lpszCmdLine, TEXT("-n")))
    {
        //
        // Used by NT setup
        //
        // 1) Converts ProgMan common groups
        //
        g_fDoingCommonGroups = TRUE;
        Group_EnumNT(Group_EnumCallback, FALSE, FALSE,
                     HKEY_LOCAL_MACHINE, c_szCommonGroups);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/c")) || !lstrcmpi(lpszCmdLine, TEXT("-c")))
    {
        // Convert NT common progman groups only
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        g_fDoingCommonGroups = TRUE;
        Group_EnumNT(Group_EnumCallback, TRUE, FALSE,
                     HKEY_LOCAL_MACHINE, c_szCommonGroups);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/p")) || !lstrcmpi(lpszCmdLine, TEXT("-p")))
    {
        // Convert NT personal progman groups only
        // This switch is used by NT setup via userdiff
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoAutoConvert(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/t")) || !lstrcmpi(lpszCmdLine, TEXT("-t")))
    {
        // Same as -s but only coverts modified groups (used on a re-install).
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(TRUE, TRUE);
        BuildDefaultGroups();
        DoRandomOtherStuff(TRUE, TRUE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/q")) || !lstrcmpi(lpszCmdLine, TEXT("-q")))
    {
        // Question and answer stuff.
        AppList_Build();
        // Restart the reporter tool.
        WinExec(c_szReporter, SW_NORMAL);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/o")) || !lstrcmpi(lpszCmdLine, TEXT("-o")))
    {
        // Optional component GrpConv (ie don't look at Progman groups).
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        BuildDefaultGroups();
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (!lstrcmpi(lpszCmdLine, TEXT("/u")) || !lstrcmpi(lpszCmdLine, TEXT("-u")))
    {
        // Display NO UI (ie no progress dialog) and process
        // Optional components (ie don't look at Progman groups),
        g_fShowUI = FALSE;
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        BuildDefaultGroups();
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
    else if (*lpszCmdLine)
    {
        // file specified, convert just it
        Group_CreateProgressDlg();
        Group_Convert(NULL, lpszCmdLine, GC_REPORTERROR | GC_OPENGROUP);    // REVIEW, maybe silent?
        Group_DestroyProgressDlg();
    }
    else
    {
        hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
        DoFileRenames(c_szPreRenameRoot);
        DoAutoConvert(TRUE, TRUE);
        DoRandomOtherStuff(FALSE, FALSE);
        SetCursor(hCursor);
    }
}

// stolen from the CRT, used to shirink our code

int _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;
    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
    return i;   // We never comes here.
}

//---------------------------------------------------------------------------
int WinMainT(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)
{
    LCID lcid;
    HMODULE hLibImm;

    BOOL (WINAPI *ImmDisableIME)(DWORD) = NULL;

    lcid = GetThreadLocale();

    // we have to LoadLibaray/GetProcAddress ImmDisableIME because
    // this is not exported on win95 gold or NT4.
    hLibImm = LoadLibrary(TEXT("imm.dll"));
    if (hLibImm)
    {
        (FARPROC) *ImmDisableIME = GetProcAddress(hLibImm, "ImmDisableIME");
        if (ImmDisableIME != NULL)
        {
            if ( (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
                 (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN)   ||
                 (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE) )
            {
                ImmDisableIME(0);
            }
        }
        FreeLibrary(hLibImm);
    }

    g_hinst = hInstance;
    if (InitApplication(hInstance))
    {
            // We do all the work on InitInst
            InitCommonControls();
            DoConversion(hInstance, lpCmdLine);
            UnInitApplication();
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\rcids.h ===
//---------------------------------------------------------------------------
// RC stuff.
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Icons...
#define IDI_GRPCONV             100
#define IDI_PROGMAN             101

//---------------------------------------------------------------------------
// Bitmaps
#define IDB_CHECKSTATES         100
#define IDB_REDCARPET           101

//---------------------------------------------------------------------------
// Strings...
#define IDS_FILTER              200
#define IDS_COMMDLGTITLE        201
#define IDS_APPTITLE            202
#define IDS_OKTOCONVERT         203
#define IDS_CONVERTERROR        204
#define IDS_NOTGROUPFILE        205
#define IDS_MISSINGFILE         206
#define IDS_BADOLDGROUP         207
#define IDS_PROGRAMS            208
#define IDS_GROUPTYPENAME       209
#define IDS_ANOTHER             210
#define IDS_SENDTO              211
#define IDS_WASTEBASKET         212
#define IDS_WASTEBIN            213
#define IDS_CREATINGNEWSCS      214
#define IDS_STARTUP             215
#define IDS_DESKTOP             216
#define IDS_DEFLANGCHARSET      217
#define IDS_DDEMLTEST           218
#define IDS_LOTSAGROUPS1        219
#define IDS_LOTSAGROUPS2        220
#define IDS_RECENT              221
#define IDS_GROUP               222

//---------------------------------------------------------------------------
// Dialogs...
#define DLG_PROGRESS            300
#define IDC_GROUPNAME           301
#define IDC_STATIC              302
#define IDC_PROGRESS            303
#define IDD_REDCARPET           304
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\util.c ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------
#include "grpconv.h"
#include "util.h"
#include "rcids.h"

#include <tchar.h>

//---------------------------------------------------------------------------
// Global to this file only.

const TCHAR g_szDot[] = TEXT(".");
const TCHAR g_szShellOpenCommand[] = TEXT("\\Shell\\Open\\Command");
const TCHAR c_szElipses[] = TEXT("...");
const TCHAR c_szSpace[] = TEXT(" ");
const TCHAR c_szUS[] = TEXT("_");

static BOOL g_fShowProgressDlg = FALSE;
HWND g_hwndProgress = NULL;     // Progress dialog.

//---------------------------------------------------------------------------
LRESULT CALLBACK ProgressWndProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    switch (msg)
    {
    case WM_INITDIALOG:
        SetDlgItemText(hdlg, IDC_GROUPNAME, (LPTSTR)lparam);
        EnableMenuItem(GetSystemMenu(hdlg, FALSE), SC_CLOSE, MF_BYCOMMAND|MF_DISABLED|MF_GRAYED);
        return TRUE;
    }

    return 0;
}

//---------------------------------------------------------------------------
void ShowProgressDlg(void)
{
    // Has someone tried to create the dialog but it isn't up yet?
    if (g_fShowUI && g_fShowProgressDlg && !g_hwndProgress)
    {
        // Yep.
        // NB We can handle this failing, we just try to carry on without
        // the dialog.
        g_hwndProgress = CreateDialog(g_hinst, MAKEINTRESOURCE(DLG_PROGRESS), NULL, ProgressWndProc);
    }
}

//---------------------------------------------------------------------------
void Group_CreateProgressDlg(void)
{
    // NB We just set a flag here, the first guy to try to set the
    // current progress actually puts up the dialag.
    g_fShowProgressDlg = TRUE;
}

//---------------------------------------------------------------------------
void Group_DestroyProgressDlg(void)
{
    if (g_hwndProgress)
    {
        DestroyWindow(g_hwndProgress);
        g_hwndProgress = NULL;
    }
    g_fShowProgressDlg = FALSE;
}

//---------------------------------------------------------------------------
// If the text is too long, lop off the end and stick on some elipses.
void Text_TruncateAndAddElipses(HWND hwnd, LPTSTR lpszText)
{
        RECT rcClient;
        SIZE sizeText;
        SIZE sizeElipses;
        HDC hdc;
        UINT cch;
        
        Assert(hwnd);
        Assert(lpszText);
        
        hdc = GetDC(hwnd);
        if (hdc)
        {
                GetClientRect(hwnd, &rcClient);
                GetTextExtentPoint(hdc, lpszText, lstrlen(lpszText), &sizeText);
                // Is the text too long?
                if (sizeText.cx > rcClient.right)
                {
                        // Yes, it is, clip it.
                        GetTextExtentPoint(hdc, c_szElipses, 3, &sizeElipses);
                        GetTextExtentExPoint(hdc, lpszText, lstrlen(lpszText), rcClient.right - sizeElipses.cx,
                                &cch, NULL, &sizeText);
                        lstrcpy(lpszText+cch, c_szElipses);
                }
                ReleaseDC(hwnd, hdc);
        }
}

//---------------------------------------------------------------------------
void Group_SetProgressDesc(UINT nID)
{
    TCHAR sz[MAX_PATH];

    ShowProgressDlg();
    if (g_hwndProgress)
    {
        LoadString(g_hinst, nID, sz, ARRAYSIZE(sz));
                SendDlgItemMessage(g_hwndProgress, IDC_STATIC, WM_SETTEXT, 0, (LPARAM)sz);
    }
}

//---------------------------------------------------------------------------
void Group_SetProgressNameAndRange(LPCTSTR lpszGroup, int iMax)
{
        TCHAR sz[MAX_PATH];
        TCHAR szNew[MAX_PATH];
        LPTSTR lpszName;
        MSG msg;
        static int cGen = 1;
        
        ShowProgressDlg();
        if (g_hwndProgress)
        {
                // DebugMsg(DM_TRACE, "gc.gspnar: Range 0 to %d", iMax);
                SendDlgItemMessage(g_hwndProgress, IDC_PROGRESS, PBM_SETRANGE, 0, MAKELPARAM(0, iMax));

                if (lpszGroup == (LPTSTR)-1)
                {
                        // Use some sensible name - Programs (x)
                        // where x = 1 to n, incremented each time this is
                        // called.
                        LoadString(g_hinst, IDS_GROUP, sz, ARRAYSIZE(sz));
                        wsprintf(szNew, TEXT("%s (%d)"), sz, cGen++);
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, szNew);
                }
                else if (lpszGroup && *lpszGroup)
                {
                        lpszName = PathFindFileName(lpszGroup);
                        lstrcpy(sz, lpszName);
                        Text_TruncateAndAddElipses(GetDlgItem(g_hwndProgress, IDC_GROUPNAME), sz);
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, sz);
                }
                else
                {
                        // Use some sensible name.
                        LoadString(g_hinst, IDS_PROGRAMS, sz, ARRAYSIZE(sz));
                        SetDlgItemText(g_hwndProgress, IDC_GROUPNAME, sz);
                }
                
                // Let paints come in.
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                    DispatchMessage(&msg);
                }
        }
}

//---------------------------------------------------------------------------
void Group_SetProgress(int i)
{
        MSG msg;

        ShowProgressDlg();
        if (g_hwndProgress)
        {               
                // DebugMsg(DM_TRACE, "gc.gsp: Progress %d", i);
                
            // Progman keeps trying to steal the focus...
                SetForegroundWindow(g_hwndProgress);
                SendDlgItemMessage(g_hwndProgress, IDC_PROGRESS, PBM_SETPOS, i, 0);
        }

        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
                DispatchMessage(&msg);
        }

}

#if 0
//---------------------------------------------------------------------------
BOOL WritePrivateProfileInt(LPCTSTR lpszSection, LPCTSTR lpszValue, int i, LPCTSTR lpszIniFile)
{
        TCHAR szBuf[CCHSZSHORT];

        wsprintf(szBuf, TEXT("%d"), i);
        return WritePrivateProfileString(lpszSection, lpszValue, szBuf, lpszIniFile);
}
#endif

//---------------------------------------------------------------------------
// Register an app as being able to handle a particular extension with the
// given internal type, human readble type and command.
// NB lpszExt doesn't need a dot.
// By default this won't overide something in the registration DB.
// Setting fOveride to TRUE will cause existing entries in the DB
// to be over written.
void ShellRegisterApp(LPCTSTR lpszExt, LPCTSTR lpszTypeKey,
    LPCTSTR lpszTypeValue, LPCTSTR lpszCommand, BOOL fOveride)
    {
    TCHAR szKey[CCHSZNORMAL];
    TCHAR szValue[CCHSZSHORT];
    LONG lcb;
    LONG lStatus;

    // Deal with the mapping from extension to TypeKey.
    lstrcpyn(szKey, g_szDot, ARRAYSIZE(szKey));
    _tcsncat(szKey, lpszExt, (ARRAYSIZE(szKey) - 1) - lstrlen(szKey));
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &lcb);
    // Is the extension not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        lstrcpy(szValue, lpszTypeKey);
        if (RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, lpszTypeKey, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Extension registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering extension."));
            }
        }

    // Deal with the mapping from TypeKey to TypeValue
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, lpszTypeKey, szValue, &lcb);
    // Is the type not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        if (RegSetValue(HKEY_CLASSES_ROOT, lpszTypeKey, REG_SZ, lpszTypeValue, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Type registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering type."));
            }
        }

    // Deal with adding the open command.
    lstrcpy(szKey, lpszTypeKey);
    lstrcat(szKey, g_szShellOpenCommand);
    lcb = SIZEOF(szValue);
    lStatus = RegQueryValue(HKEY_CLASSES_ROOT, szKey, szValue, &lcb);
    // Is the command not registered or do we even care?
    if (lStatus != ERROR_SUCCESS || fOveride)
        {
        // No, so register it.
        if (RegSetValue(HKEY_CLASSES_ROOT, szKey, REG_SZ, lpszCommand, 0) == ERROR_SUCCESS)
            {
//            DebugMsg(DM_TRACE, "gc.sra: Command registered.");
            }
        else
            {
            DebugMsg(DM_ERROR, TEXT("gc.sra: Error registering command."));
            }
        }
    }

#if 0
//-------------------------------------------------------------------------
// Do a unix(ish) gets(). This assumes bufferd i/o.
// Reads cb-1 characters (the last one will be a NULL) or up to and including
// the first NULL.
LPTSTR fgets(LPTSTR sz, WORD cb, int fh)
    {
    UINT i;

    // Leave room for the NULL.
    cb--;
    for (i=0; i<cb; i++)
        {
        _lread(fh, &sz[i], 1);
        // Check for a null.
        if (sz[i] == TEXT('\0'))
            return sz;
        }

    // Ran out of room.
    // NULL Terminate.
    sz[cb-1] = TEXT('\0');
    return sz;
    }
#else
//-------------------------------------------------------------------------
// Do a unix(ish) gets(). This assumes bufferd i/o.
// Reads cb-1 characters (the last one will be a NULL) or up to and including
// the first NULL.
#ifdef UNICODE
LPTSTR fgets(LPTSTR sz, DWORD count, HANDLE fh)
{
    DWORD cch;
    DWORD dwFilePointer, dwBytesRead;
    CHAR *AnsiString = NULL, *AnsiStringPointer, ch;
    LPTSTR retval = NULL;

    //
    // Allocate memory for the reading the ansi string from the stream
    //

    if ((AnsiString = (CHAR *)LocalAlloc(LPTR, count * SIZEOF(CHAR))) == NULL) {
        return(retval);
    }
    AnsiStringPointer = AnsiString;

    // Where are we?
    dwFilePointer = SetFilePointer(fh, 0, NULL, FILE_CURRENT);

    // Fill the buffer.
    ReadFile(fh, AnsiString, count, &dwBytesRead, NULL);

    // Always null the buffer.
    AnsiString[count-1] = '\0';

    // Convert the Ansi String to Unicode
    if (MultiByteToWideChar(
        CP_ACP,
        MB_PRECOMPOSED,
        AnsiString,
        -1,
        sz,
        count
        )  != 0) {
        retval = sz;
    }

    // If there was an earlied null we need to puke the rest 
    // back in to the stream?
    cch = lstrlenA(AnsiString);
    if (cch != count-1)
        SetFilePointer(fh, dwFilePointer+cch+1, NULL, FILE_BEGIN);

    // Do Cleanup
    if (AnsiString != NULL) {
        LocalFree(AnsiString);
    }

    return retval;
}
#else
LPTSTR fgets(LPTSTR sz, WORD cb, int fh)
{
    int cch;
    LONG lpos;

    // Where are we?
    lpos = _llseek(fh, 0, 1);
    // Fill the buffer.
    _lread(fh, sz, cb);
    // Always null the buffer.
    sz[cb-1] = TEXT('\0');
    // If there was an earlied null we need to puke the rest 
    // back in to the stream?
    cch = lstrlen(sz);
    if (cch != cb-1)
        _llseek(fh, lpos+cch+1, 0);
    return sz;
}
#endif
#endif

//---------------------------------------------------------------------------
// Put up a message box wsprintf style.
int MyMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR lpsz, UINT nStyle)
    {
    TCHAR szTempField[CCHSZNORMAL];
    TCHAR szTitle[CCHSZNORMAL];
    TCHAR szMessage[CCHSZNORMAL];
    int  iMsgResult;

    if (LoadString(g_hinst, idTitle, szTitle, ARRAYSIZE(szTitle)))
        {
        if (LoadString(g_hinst, idMessage, szTempField, ARRAYSIZE(szTempField)))
            {
            if (lpsz)
                wsprintf(szMessage, szTempField, (LPTSTR)lpsz);
            else
                lstrcpy(szMessage, szTempField);

            if (hwnd)
                hwnd = GetLastActivePopup(hwnd);

            iMsgResult = MessageBox(hwnd, szMessage, szTitle, nStyle);
            if (iMsgResult != -1)
                return iMsgResult;
            }
        }

    // Out of memory...
    DebugMsg(DM_ERROR, TEXT("MMB: Out of memory.\n\r"));
    return -1;
    }

//-------------------------------------------------------------------------
// Replace hash characters in a string with NULLS.
void ConvertHashesToNulls(LPTSTR p)
    {
    while (*p)
        {
        if (*p == TEXT('#'))
            {
            *p = TEXT('\0');
            // You can't do an AnsiNext on a NULL.
            // NB - we know this is a single byte.
            p++;
            }
        else
            p = CharNext(p);
        }
    }

//-------------------------------------------------------------------------
// Copy the directory component of a path into the given buffer.
// i.e. everything after the last slash and the slash itself for everything
// but the root.
// lpszDir is assumed to be as big as lpszPath.
void Path_GetDirectory(LPCTSTR lpszPath, LPTSTR lpszDir)
    {
    LPTSTR lpszFileName;
    UINT cb;

    // The default is a null.
    lpszDir[0] = TEXT('\0');

    // Copy over everything but the filename.
    lpszFileName = PathFindFileName(lpszPath);
    cb = (UINT)(lpszFileName-lpszPath);
    if (cb)
        {
        // REVIEW lstrcpyn seems to have a problem with a cb of 0;
        lstrcpyn(lpszDir, lpszPath, cb+1);

        // Remove the trailing slash if needed.
        if (!PathIsRoot(lpszDir))
            lpszDir[cb-1] = TEXT('\0');
        }
    }




//-------------------------------------------------------------------------
//
// internal CoCreateInstance.
//
// bind straight to shell232 DllGetClassObject()
// this is meant to skip all the CoCreateInstance stuff when we
// know the thing we are looking for is in shell232.dll.  this also
// makes things work if the registry is messed up
//
HRESULT ICoCreateInstance(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv)
{
    LPCLASSFACTORY pcf;
    HRESULT hres = SHDllGetClassObject(rclsid, &IID_IClassFactory, &pcf);
    if (SUCCEEDED(hres))
    {
        hres = pcf->lpVtbl->CreateInstance(pcf, NULL, riid, ppv);
        pcf->lpVtbl->Release(pcf);
    }
    return hres;
}

//-------------------------------------------------------------------------
LPTSTR _lstrcatn(LPTSTR lpszDest, LPCTSTR lpszSrc, UINT cbDest)
{
    UINT i;

    i = lstrlen(lpszDest);
    lstrcpyn(lpszDest+i, lpszSrc, cbDest-i);
    return lpszDest;
}

//-------------------------------------------------------------------------
// Simplified from shelldll. Keep sticking on numbers till the name is unique.
BOOL WINAPI MakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName,
    UINT nStart, PFNISUNIQUE pfnIsUnique, UINT nUser, BOOL fLFN)
{
    TCHAR szAddend[4];
    int cbAddend;
    int i;

    // Is it already unique?
    if ((*pfnIsUnique)(pszOldName, nUser))
    {
        lstrcpyn(pszNewName, pszOldName, cbNewName);
        return TRUE;
    }
    else
    {
        // NB Max is 100 identically names things but we should never
        // hit this as the max number of items in a progman group was 50.
        for (i=nStart; i<100; i++)
        {
            // Generate the addend.
            wsprintf(szAddend, TEXT("#%d"), i);
            cbAddend = lstrlen(szAddend);
            // Lotsa room?
            if ((UINT)(lstrlen(pszOldName)+cbAddend+1) > cbNewName)
            {
                // Nope.
                lstrcpyn(pszNewName, pszOldName, cbNewName);
                lstrcpy(pszNewName+(cbNewName-cbAddend), szAddend);
            }
            else
            {
                // Yep.
                lstrcpy(pszNewName, pszOldName);
                
                if (!fLFN)
                    lstrcat(pszNewName, c_szSpace);

                lstrcat(pszNewName, szAddend);
            }
            // Is it unique?
            if ((*pfnIsUnique)(pszNewName, nUser))
            {
                // Yep.
                return TRUE;
            }
        }
    }

    // Ooopsie.
    lstrcpyn(pszNewName, pszOldName, cbNewName);
    DebugMsg(DM_ERROR, TEXT("gp.mun: Unable to generate a unique name for %s."), pszOldName);
    return FALSE;
}

//-------------------------------------------------------------------------
// Simplified from shell.dll (For LFN things only).
BOOL WINAPI YetAnotherMakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName,
    PFNISUNIQUE pfnIsUnique, UINT n, BOOL fLFN)
{
    BOOL fRet = FALSE;
    TCHAR szTemp[MAX_PATH];

    // Is given name already unique?
    if ((*pfnIsUnique)(pszOldName, n))
    {
        // Yep,
        lstrcpyn(pszNewName, pszOldName, cbNewName);
    }
    else
    {
        if (fLFN)
        {
            // Try "another".
            LoadString(g_hinst, IDS_ANOTHER, szTemp, ARRAYSIZE(szTemp));
            _lstrcatn(szTemp, pszOldName, cbNewName);
            if (!(*pfnIsUnique)(szTemp, n))
            {
                // Nope, use the old technique of sticking on numbers.
                return MakeUniqueName(pszNewName, cbNewName, pszOldName, 3, pfnIsUnique, n, FALSE);
            }
            else
            {
                // Yep.
                lstrcpyn(pszNewName, szTemp, cbNewName);
            }
        }
        else
        {
            // Just stick on numbers.
            return MakeUniqueName(pszNewName, cbNewName, pszOldName, 2, pfnIsUnique, n, TRUE);
        }
    }
    // Name is unique.
    return TRUE;
}

//----------------------------------------------------------------------------
// Sort of a registry equivalent of the profile API's.
BOOL WINAPI Reg_Get(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPVOID pData, DWORD cbData)
{
    HKEY hkeyNew;
    BOOL fRet = FALSE;
    DWORD dwType;
    
    if (!GetSystemMetrics(SM_CLEANBOOT) && (RegOpenKey(hkey, pszSubKey, &hkeyNew) == ERROR_SUCCESS))
    {
        if (RegQueryValueEx(hkeyNew, (LPVOID)pszValue, 0, &dwType, pData, &cbData) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
        RegCloseKey(hkeyNew);
    }
    return fRet;
}

//----------------------------------------------------------------------------
// Sort of a registry equivalent of the profile API's.
BOOL WINAPI Reg_Set(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dwType, 
    LPVOID pData, DWORD cbData)
{
    HKEY hkeyNew;
    BOOL fRet = FALSE;

    if (pszSubKey)
    {
        if (RegCreateKey(hkey, pszSubKey, &hkeyNew) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(hkeyNew, pszValue, 0, dwType, pData, cbData) == ERROR_SUCCESS)
            {
                fRet = TRUE;
            }
            RegCloseKey(hkeyNew);
        }
    }
    else
    {
        if (RegSetValueEx(hkey, pszValue, 0, dwType, pData, cbData) == ERROR_SUCCESS)
        {
            fRet = TRUE;
        }
    }
    return fRet;
}

//----------------------------------------------------------------------------
BOOL WINAPI Reg_SetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dw)
{
    return Reg_Set(hkey, pszSubKey, pszValue, REG_DWORD, &dw, SIZEOF(dw));
}

//----------------------------------------------------------------------------
BOOL WINAPI Reg_GetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPDWORD pdw)
{
    return Reg_Get(hkey, pszSubKey, pszValue, pdw, SIZEOF(*pdw));
}

//----------------------------------------------------------------------------
void __cdecl _Log(LPCTSTR pszMsg, ...)
{
    TCHAR sz[2*MAX_PATH+40];  // Handles 2*largest path + slop for message
    va_list     vaListMarker;

    va_start(vaListMarker, pszMsg);

    if (g_hkeyGrpConv)
    {
        wvsprintf(sz, pszMsg, vaListMarker);
        Reg_SetString(g_hkeyGrpConv, NULL, TEXT("Log"), sz);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\debug.cpp ===
#include <precomp.h>
// Define some things for debug.h
//
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "taskmgr"
#define SZ_MODULE           "TASKMGR"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\netpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       netpage.cpp
//
//  History:    Oct-18-2000   Olaf Miller  Created
//  
//--------------------------------------------------------------------------

#include "precomp.h" 

#define MIN_GRAPH_HEIGHT        120
#define SCROLLBAR_WIDTH         17
#define INVALID_VALUE           0xFFFFFFFF
#define PERCENT_SHIFT           10000000
#define PERCENT_DECIMAL_POINT   7

//
// Determines how the graphs are drawen (zoomed level)
//
static int g_NetScrollamount = 0;

extern WCHAR     g_szG[];
extern WCHAR     g_szM[];
extern WCHAR     g_szK[];
extern WCHAR     g_szZero[];
extern WCHAR     g_szPackets[];
extern WCHAR     g_szBitsPerSec[];
extern WCHAR     g_szScaleFont[SHORTSTRLEN];
extern WCHAR     g_szPercent[];
extern WCHAR     g_szNonOperational[];
extern WCHAR     g_szUnreachable[];
extern WCHAR     g_szDisconnected[];
extern WCHAR     g_szConnecting[];
extern WCHAR     g_szConnected[];
extern WCHAR     g_szOperational[];
extern WCHAR     g_szUnknownStatus[];
extern WCHAR     g_szGroupThousSep[];
extern WCHAR     g_szDecimal[];
extern ULONG     g_ulGroupSep;

//
// Window Proc the Network Tab
//
INT_PTR CALLBACK NetPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                ); 

//
// Colors of the pens
//
static const COLORREF aNetColors[] =
{    
    RGB(255, 000, 0),
    RGB(255, 255, 0), 
    RGB(000, 255, 0),
};

//
// Default values for the Networking Page's statistics columns
//
struct
{
    SHORT Format;
    SHORT Width;
} NetColumnDefaults[NUM_NETCOLUMN] =
{
    { LVCFMT_LEFT,     96 },      // COL_ADAPTERNAME  
    { LVCFMT_LEFT,     96 },      // COL_ADAPTERDESC   
    { LVCFMT_RIGHT,    96 },      // COL_NETWORKUTIL   
    { LVCFMT_RIGHT,    60 },      // COL_LINKSPEED   
    { LVCFMT_RIGHT,    96 },      // COL_STATE
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENTTHRU 
    { LVCFMT_RIGHT,    70 },      // COL_BYTESRECTHRU  
    { LVCFMT_RIGHT,    75 },      // COL_BYTESTOTALTHRU
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENT     
    { LVCFMT_RIGHT,    70 },      // COL_BYTESREC      
    { LVCFMT_RIGHT,    50 },      // COL_BYTESTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_BYTESSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_BYTESRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_BYTESTOTALPERINTER    
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSSSENT     
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSREC      
    { LVCFMT_RIGHT,    50 },      // COL_UNICASTSTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_UNICASTSTOTALPERINTER    
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSSSENT     
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSREC      
    { LVCFMT_RIGHT,    50 },      // COL_NONUNICASTSTOTAL    
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSSENTPERINTER     
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSRECPERINTER      
    { LVCFMT_RIGHT,    70 },      // COL_NONUNICASTSTOTALPERINTER    
};

//
// List of the name of the columns. These strings appear in the column header
//
static const _aIDNetColNames[NUM_NETCOLUMN] =
{
    IDS_COL_ADAPTERNAME,
    IDS_COL_ADAPTERDESC,   
    IDS_COL_NETWORKUTIL,   
    IDS_COL_LINKSPEED,   
    IDS_COL_STATE,   
    IDS_COL_BYTESSENTTHRU, 
    IDS_COL_BYTESRECTHRU,  
    IDS_COL_BYTESTOTALTHRU,
    IDS_COL_BYTESSENT,     
    IDS_COL_BYTESREC,      
    IDS_COL_BYTESTOTAL,    
    IDS_COL_BYTESSENTPERINTER,     
    IDS_COL_BYTESRECPERINTER,      
    IDS_COL_BYTESTOTALPERINTER,    
    IDS_COL_UNICASTSSSENT,     
    IDS_COL_UNICASTSREC,      
    IDS_COL_UNICASTSTOTAL,    
    IDS_COL_UNICASTSSENTPERINTER,     
    IDS_COL_UNICASTSRECPERINTER,      
    IDS_COL_UNICASTSTOTALPERINTER,    
    IDS_COL_NONUNICASTSSSENT,     
    IDS_COL_NONUNICASTSREC,      
    IDS_COL_NONUNICASTSTOTAL,    
    IDS_COL_NONUNICASTSSENTPERINTER,     
    IDS_COL_NONUNICASTSRECPERINTER,      
    IDS_COL_NONUNICASTSTOTALPERINTER,    
};

//
// List of window checkbox IDs. These check boxes appear in the Select a column diaglog box.
//
const int g_aNetDlgColIDs[] =
{
    IDC_ADAPTERNAME,
    IDC_ADAPTERDESC,   
    IDC_NETWORKUTIL,   
    IDC_LINKSPEED,   
    IDC_STATE,   
    IDC_BYTESSENTTHRU, 
    IDC_BYTESRECTHRU,  
    IDC_BYTESTOTALTHRU,
    IDC_BYTESSENT,     
    IDC_BYTESREC,      
    IDC_BYTESTOTAL,    
    IDC_BYTESSENTPERINTER,     
    IDC_BYTESRECPERINTER,      
    IDC_BYTESTOTALPERINTER,    
    IDC_UNICASTSSSENT,     
    IDC_UNICASTSREC,      
    IDC_UNICASTSTOTAL,    
    IDC_UNICASTSSENTPERINTER,     
    IDC_UNICASTSRECPERINTER,      
    IDC_UNICASTSTOTALPERINTER,    
    IDC_NONUNICASTSSSENT,     
    IDC_NONUNICASTSREC,      
    IDC_NONUNICASTSTOTAL,    
    IDC_NONUNICASTSSENTPERINTER,     
    IDC_NONUNICASTSRECPERINTER,      
    IDC_NONUNICASTSTOTALPERINTER,    
};

/*++

Routine Description:

    Changes the size of an array. Allocates new memory for the array and 
    copies the data in the old array to the new array. If the new array is 
    larger then the old array the extra memory is zeroed out.

Arguments:

    ppSrc -- Pointer to the source array.
    dwNewSize -- The size (in bytes) of the new array.

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT ChangeArraySize(LPVOID *ppSrc, DWORD dwNewSize)
{
    if( ppSrc == NULL )
    {
        return E_INVALIDARG;
    }

    if( NULL == *ppSrc )
    {   
        //
        // The array is empty. Allocate new space for it,
        //
        *ppSrc = (LPVOID) HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwNewSize);
        if( NULL == *ppSrc )
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        LPVOID pTmp;

        //
        // The array contains data. Allocate new memory for it and copy over the data in the array.
        // If the new array is larger then the old array the extra memory is zeroed out.
        //
        pTmp = (LPVOID)HeapReAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, *ppSrc, dwNewSize);        
        if( pTmp )
        {
            *ppSrc = pTmp;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }

    return S_OK;
}

/*++

Routine Description:

    Initialize all of the CAdapter class members. The CAdapter class
    use the Ip Helper api's to collect information about the Network 
    adapters on the local system.

Arguments:

    NONE

Return Value:

    VOID

Revision History:

      1-6-2000  Created by omiller

--*/
CAdapter::CAdapter()
{
    m_dwAdapterCount = 0;
    m_ppaiAdapterStats = NULL;
    m_pifTable = NULL;
    m_bToggle = 0;
    m_dwLastReportedNumberOfAdapters = 0;
}

/*++

Routine Description:

    Adds any new adapters reported by the IPHLPAPI and removes any old adapters
    that are no longer reported by the IPHLPAPI

Arguments:
    
    void

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::RefreshAdapterTable()
{
    DWORD   dwSize;
    DWORD   dwRetVal;
    BOOLEAN bFound;
    HRESULT hr;
    LONG i, j;

    //
    // Get the list of active adapters
    //
    do
    {
        //
        // Determine the size of the adapter array
        //

        if ( NULL != m_pifTable )
        {
            dwSize = (DWORD) HeapSize( GetProcessHeap(), 0, m_pifTable );
        }
        else
        {
            dwSize = 0;
        }

        //
        // Collect all of the adapter information for all adapters (WAN and LAN)
        //

        dwRetVal = GetInterfaceInfo(m_pifTable, &dwSize);
        switch(dwRetVal)
        {
        case ERROR_INSUFFICIENT_BUFFER:
            //
            // The array is to small. Need to make it bigger and try again.
            //
            hr = ChangeArraySize( (LPVOID *) &m_pifTable, dwSize );
            if( FAILED(hr) )
            {
                // Unable to expand the size of the array
                //
                return hr;
            }
            break;

        case NO_ERROR:
            //
            // Everything is happy
            //
            break;

        case ERROR_MORE_DATA:   // Error code 234
            // For some reason this error message means that there are no adapters. BUG?
            //
            m_dwAdapterCount = 0;
            return S_FALSE;            

        default:
            // Something went wrong fail.
            //
            m_dwAdapterCount = 0;
            return E_FAIL;
        }
    }
    while(dwRetVal);
    

    //
    // Fixed Bug: 669937 Av in taskmgr !CAdapter::RefreshAdapterTable
    // Determine which adapters are common in both lists. 
    //
    for(i=0; i<(LONG)m_dwAdapterCount; i++)
    {
        for(j=0, bFound = FALSE; bFound == FALSE && j<m_pifTable->NumAdapters; j++)
        {
            if( m_ppaiAdapterStats[i]->ifRowStartStats.dwIndex == m_pifTable->Adapter[j].Index )
            {
                m_pifTable->Adapter[j].Index = INVALID_VALUE;
                bFound = TRUE;
            }
        }
        if( !bFound )
        {            
            if( m_dwAdapterCount > (DWORD)(i+1))
            {
                memmove(&m_ppaiAdapterStats[i],&m_ppaiAdapterStats[i+1],(m_dwAdapterCount - (i+1)) * sizeof(ADAPTER_INFOEX));            
            }            
            m_dwAdapterCount--;
            i--;
        }
    }

    //
    // Add any new adapters
    //
    hr = ChangeArraySize( (LPVOID *) &m_ppaiAdapterStats, sizeof(ADAPTER_INFOEX) * min(m_pifTable->NumAdapters,MAX_ADAPTERS));                                  
    for(i=0; SUCCEEDED(hr) && i<m_pifTable->NumAdapters; i++)
    {
        if( m_pifTable->Adapter[i].Index != INVALID_VALUE )
        {
            hr = InitializeAdapter( &m_ppaiAdapterStats[ m_dwAdapterCount++ ], &m_pifTable->Adapter[ i ] );
        }
    }

    if( FAILED(hr) )
    {
        m_dwAdapterCount = 0;
    }

    return hr;
}

/*++

Routine Description:

    Update the connection names of the network adapter. This function is only called when the
    user selects the refresh menu item. The connection rarely change, so it would be a waste of
    time to update the connection name every time the get the adapter statistics.

Arguments:
    
    void

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::RefreshConnectionNames()
{
    //
    // Update the connection name for each adapter in out list
    //
    for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
    {        
        GetConnectionName( m_ppaiAdapterStats[dwAdapter]->wszGuid
                         , m_ppaiAdapterStats[dwAdapter]->wszConnectionName
                         , ARRAYSIZE(m_ppaiAdapterStats[dwAdapter]->wszConnectionName)
                         );     
    }
}

/*++
  
Routine Description:

    Get the connection name of an adapter.

Arguments:
    
    pwszAdapterGuid -- The guid of the adapter
    pwszConnectionName -- returns the connection name of the adapter

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::GetConnectionName(LPWSTR pwszAdapterGuid, LPWSTR pwszConnectionName, DWORD cchConnectionName)
{
    GUID IfGuid;    
    WCHAR wszConnName[MAXLEN_IFDESCR+1];
    DWORD Size;
    DWORD dwRetVal;
    HRESULT hr;

	//
	// Make sure the string is NULL terminated
	//
    Size = sizeof(wszConnName) - sizeof(WCHAR);
	wszConnName[MAXLEN_IFDESCR] = L'\0';

    //
    // Convert the GUID into a string
    //
    hr = CLSIDFromString( pwszAdapterGuid, &IfGuid );
         
    if( SUCCEEDED(hr) )
    {
        //
        // Use the private IPHLPAPI to get the connection name of the device. Size is the size fo the buffer,
        // not the number of chars
        //
        dwRetVal = NhGetInterfaceNameFromDeviceGuid(&IfGuid, wszConnName, &Size, FALSE, TRUE); 
        if( NO_ERROR == dwRetVal ) 
        {
            StringCchCopy(pwszConnectionName, cchConnectionName, wszConnName);
            return S_OK;
        }              
    }

    return E_FAIL;
}

/*++

Routine Description:

    Initialize the adapter information. i.e. get the adapter name, guid, adapter description and the initial 
    adapter statistics (bytes sent, bytes recieved etc)

Arguments:

    ppaiAdapterStats -- Adapter to initialize
    pAdapterDescription -- Information about the adapter (Index and Adapter GUID)
    
Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::InitializeAdapter(PPADAPTER_INFOEX ppaiAdapterStats, PIP_ADAPTER_INDEX_MAP pAdapterDescription)
{
    DWORD   dwRetVal;
    HRESULT hr;
    INT     iAdapterNameLength;

    if( !ppaiAdapterStats || !pAdapterDescription)
    {
        return E_INVALIDARG;
    }

    if( NULL == *ppaiAdapterStats )
    {
        //
        // This slot was never used before, we need to allocate memory for it
        //
        *ppaiAdapterStats = (PADAPTER_INFOEX) HeapAlloc( GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(**ppaiAdapterStats) );
    }
    
    if( *ppaiAdapterStats )
    {
        //
        // Initialize the adapter by filling in all the adapter values.
        //
        (*ppaiAdapterStats)->ifRowStartStats.dwIndex = (DWORD)pAdapterDescription->Index;
        
        // Get the initial statistics for this adapter
        //
        dwRetVal = GetIfEntry( &(*ppaiAdapterStats)->ifRowStartStats );
        if( NO_ERROR == dwRetVal )
        {
            if( (*ppaiAdapterStats)->ifRowStartStats.dwType == MIB_IF_TYPE_PPP || 
                (*ppaiAdapterStats)->ifRowStartStats.dwType == MIB_IF_TYPE_SLIP)
            {
                // We only need to adjust the link speed of modems since they compress data causing
                // network utilization to exceed 100%. The link speed of modems also changes during a
                // connection but the IPHLPAPIs do not report this change.
                //
                (*ppaiAdapterStats)->bAdjustLinkSpeed = TRUE;
            }
            else
            {
                (*ppaiAdapterStats)->bAdjustLinkSpeed = FALSE;
            }

            //
            // Initialize the adapter values. The start current and last stats are all the same at the start
            //
            memcpy( &(*ppaiAdapterStats)->ifRowStats[0], &(*ppaiAdapterStats)->ifRowStartStats, sizeof((*ppaiAdapterStats)->ifRowStats[0]) );
            memcpy( &(*ppaiAdapterStats)->ifRowStats[1], &(*ppaiAdapterStats)->ifRowStartStats, sizeof((*ppaiAdapterStats)->ifRowStats[1]) );
            memset( &(*ppaiAdapterStats)->ulHistory[0], INVALID_VALUE, sizeof((*ppaiAdapterStats)->ulHistory[0]) );
            memset( &(*ppaiAdapterStats)->ulHistory[1], INVALID_VALUE, sizeof((*ppaiAdapterStats)->ulHistory[1]) );
            mbstowcs( (*ppaiAdapterStats)->wszDesc, (LPCSTR)(*ppaiAdapterStats)->ifRowStartStats.bDescr, ARRAYSIZE((*ppaiAdapterStats)->wszDesc) );

            //
            // Extract the Device guid of the adapter
            //
            hr = E_FAIL;
            iAdapterNameLength = lstrlen(pAdapterDescription->Name);            
            if( iAdapterNameLength >= GUID_STR_LENGTH )
            {
                
                // The Guid is the last GUID_STR_LENGTH chars in the name. Get the guid and from the guid get the connection name
                //
                StringCchCopy( (*ppaiAdapterStats)->wszGuid
                             , ARRAYSIZE((*ppaiAdapterStats)->wszGuid) 
                             , &pAdapterDescription->Name[iAdapterNameLength - GUID_STR_LENGTH]
                             );
                hr = GetConnectionName( (*ppaiAdapterStats)->wszGuid
                                      , (*ppaiAdapterStats)->wszConnectionName
                                      , ARRAYSIZE((*ppaiAdapterStats)->wszConnectionName)
                                      );                
                                            
            }

            if( FAILED(hr) )
            {
                //
                // We were unable to get the connection name, use the adapter description as the connection name
                //
                StringCchCopy( (*ppaiAdapterStats)->wszConnectionName
                             , ARRAYSIZE((*ppaiAdapterStats)->wszConnectionName)
                             , (*ppaiAdapterStats)->wszDesc
                             );
            }

            return S_OK;
        }
    }    
    return E_OUTOFMEMORY;
}

/*++

Routine Description:

    Adjusts the link speed of an adapter. Modems change link speed during a connection and the also
    compress data. This often causes taskmgr to report network utilization greater than 100%. To avoid 
    confusing the user modems use the max link speed that taskmgr sees. If the link speed changes
    the adapters graph is adjusted to reflect the change in link speed.

Arguments:

    pAdapterInfo -- Adapter whos link speed needs to be adjusted.
    
Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::AdjustLinkSpeed(PADAPTER_INFOEX pAdapterInfo)
{
    if( pAdapterInfo && pAdapterInfo->ullTickCountDiff)
    {
        ULONGLONG ullBitsPerSecond;
        ULONGLONG ullBytesMoved;

        // Compute the total number of bits moved in this interval
        //
        ullBytesMoved = (pAdapterInfo->ifRowStats[m_bToggle].dwInOctets  + pAdapterInfo->ifRowStats[m_bToggle].dwOutOctets) -
                        (pAdapterInfo->ifRowStats[!m_bToggle].dwInOctets + pAdapterInfo->ifRowStats[!m_bToggle].dwOutOctets);

        // Compute the real link speed. Modems lie about there  link speed based on the number of bytes moved in this interval
        //
        ullBitsPerSecond = ullBytesMoved * 8 * 1000 / pAdapterInfo->ullTickCountDiff;

        // Memorize and use the highest link speed
        //
        pAdapterInfo->ifRowStats[m_bToggle].dwSpeed = (DWORD) max( max( ullBitsPerSecond, pAdapterInfo->ullLinkspeed )
                                                                 , pAdapterInfo->ifRowStats[m_bToggle].dwSpeed
                                                                 );

        if( pAdapterInfo->ullLinkspeed == 0 )
        {
            // First time run, no need to adjust the graphs
            //
            pAdapterInfo->ullLinkspeed = (DWORD) pAdapterInfo->ifRowStats[m_bToggle].dwSpeed;
        }
        else if( pAdapterInfo->ullLinkspeed != pAdapterInfo->ifRowStats[m_bToggle].dwSpeed )
        {
            // Adjust the points on the adapters graphs to reflect the new link speed.
            //
            for(DWORD dwPoint=0; dwPoint<HIST_SIZE; dwPoint++)
            {
                if( pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] != INVALID_VALUE )
                {
                    pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] = (ULONG)(pAdapterInfo->ulHistory[BYTES_RECEIVED_UTIL][dwPoint] *  pAdapterInfo->ullLinkspeed / pAdapterInfo->ifRowStats[m_bToggle].dwSpeed);
                    pAdapterInfo->ulHistory[BYTES_SENT_UTIL][dwPoint]     = (ULONG)(pAdapterInfo->ulHistory[BYTES_SENT_UTIL][dwPoint]     *  pAdapterInfo->ullLinkspeed / pAdapterInfo->ifRowStats[m_bToggle].dwSpeed);
                }
            }

            // Remember the new linkspeed
            //
            pAdapterInfo->ullLinkspeed = (DWORD) pAdapterInfo->ifRowStats[m_bToggle].dwSpeed;
        }
    }
}

/*++

Routine Description:

    Every few seconds this function is called to collect data about each of active network adapter 
    (Adapter name, bytes sent, bytes received, unicasts packets sent, unicast packets received etc).
    The CAdapter class memorizes the first and last set of data that it collected. It does this so the 
    user can determine i.e. the number of bytes sent between now and when taskmgr started and the number 
    of bytes sent between now and the last interval. Furthermore it memorizes the length of the interval
    (in milliseconds)

Arguments:

    bAdapterListChange -- Indicates if the adapters have been added or removed.

Return Value:

    HRESULT

Note: 
    
    The current and last data is stored in a two dimentional array. When the data is collected the next 
    time (i.e. when this function is called again), the Current data becomes the last data. Inorder to save time
    Current and last data are stored in a two dimensional array and m_bToggle is used to indicate which dimenstion
    is current (m_bToggle) and which is the last set of data (!m_bToggle).

Revision History:

      1-6-2000  Created by omiller

--*/

HRESULT CAdapter::Update(BOOLEAN & bAdapterListChange)
{    
    DWORD dwRetVal;
    DWORD dwNumberOfAdaptersReported = 0;
    HRESULT hr = S_OK;
    
    bAdapterListChange = FALSE;

    if( m_dwAdapterCount < MAX_ADAPTERS )
    {
        //
        // Check if there are any new adapters. If we already have 32 adapters don't bother, our list is full
        // If an Adapter is removed we will catch that later.
        //

        dwRetVal = GetNumberOfInterfaces( &dwNumberOfAdaptersReported );
        if( NO_ERROR == dwRetVal )
        {
            //
            // Make sure the number of interfaces is still the same. If not we need to update our interface table.
            //
            if( m_dwLastReportedNumberOfAdapters != dwNumberOfAdaptersReported )
            {
                //
                // The number of adapters changed, refresh our list
                //
                hr = RefreshAdapterTable();
                bAdapterListChange = TRUE;
                m_dwLastReportedNumberOfAdapters = dwNumberOfAdaptersReported;
            }
        }
        else
        {
            //
            // Unknow error, abort
            //
            hr = E_FAIL;
        }
    }

    if( SUCCEEDED(hr) )
    {
        m_bToggle = !m_bToggle;

        // Get the statistics for each adapter
        //
        for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
        {
            dwRetVal = GetIfEntry(&m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle]);
            if( NO_ERROR == dwRetVal )
            {
                // Compute the sampling interval for this adapter. If it the first run make sure delta time is 0
                // Advance the adapter's throughput history
                //
                ULONGLONG ullTickCount = GetTickCount();
                m_ppaiAdapterStats[dwAdapter]->ullTickCountDiff 
                    = ullTickCount - (m_ppaiAdapterStats[dwAdapter]->ullLastTickCount ? m_ppaiAdapterStats[dwAdapter]->ullLastTickCount : ullTickCount);
                m_ppaiAdapterStats[dwAdapter]->ullLastTickCount = ullTickCount;
                m_ppaiAdapterStats[dwAdapter]->ifRowStartStats.dwSpeed = m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle].dwSpeed;
                if( m_ppaiAdapterStats[dwAdapter]->bAdjustLinkSpeed )
                {                    
                    AdjustLinkSpeed(m_ppaiAdapterStats[dwAdapter]);
                }

                AdvanceAdapterHistory(dwAdapter);
            }
            else if( ERROR_INVALID_DATA == dwRetVal )
            {   
                // The adapter is no longer active. When the list is refreshed the adapter will be removed.
                //
                bAdapterListChange = TRUE;                
            }
            else
            {
                // Something went wrong abort
                //
                hr = E_FAIL;
                break;
            }
        }    
    }

    if( bAdapterListChange )
    {
        // Our adapter list is not uptodate, adapters that were active are no longer active. Remove them from our list
        //
        hr = RefreshAdapterTable();
    }

    return hr;
}


/*++

Routine Description:

    Adds commas into a number string to make it more readable

Arguments:

    ullValue - Number to simplify
    pwsz - Buffer to store resulting string
    cchNumber -- size of the buffer pwsz.

Return Value:

    String containing the simplified number

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::CommaNumber(ULONGLONG ullValue, WCHAR *pwsz, int cchNumber)
{

    WCHAR wsz[100];
    NUMBERFMT nfmt;    
    
    nfmt.NumDigits     = 0;
    nfmt.LeadingZero   = 0;
    nfmt.Grouping      = UINT(g_ulGroupSep);
    nfmt.lpDecimalSep  = g_szDecimal;
    nfmt.lpThousandSep = g_szGroupThousSep;
    nfmt.NegativeOrder = 0;

    _ui64tow(ullValue,wsz,10);

    GetNumberFormat(LOCALE_USER_DEFAULT,
                    0,
                    wsz,
                    &nfmt,
                    pwsz,
                    cchNumber);

    return pwsz;
}

/*++

Routine Description:

    Simplifies a number by converting the number into Giga, Mega or Kilo

Arguments:

    ullValue - Number to simplify
    psz - Buffer to store resulting string
    bBytes - Indicates if the number is in bytes

Return Value:

    String containing the simplified number

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::SimplifyNumber(ULONGLONG ullValue, WCHAR *psz, DWORD cch)
{        
    ULONG ulDivValue=1;
    LPWSTR pwszUnit=L"";
    WCHAR wsz[100];

    // ullValue is not number of bytes so div by 10^X
    //
    if( ullValue >= 1000000000 )
    {        
        ulDivValue = 1000000000;
        pwszUnit = g_szG;
    }
    else if( ullValue >= 1000000 )
    {
        ulDivValue = 1000000;
        pwszUnit = g_szM;
    }
    else if( ullValue >= 1000 )
    {
        ulDivValue = 1000;
        pwszUnit = g_szK;
    }

    //
    //  Shown in the UI - don't care if these get chopped.
    //

    StringCchCopy( psz, cch, CommaNumber( ullValue / ulDivValue, wsz, ARRAYSIZE(wsz) ) );
    StringCchCat( psz, cch, L" " );
    StringCchCat( psz, cch, pwszUnit );

    return psz;
}


/*++

Routine Description:

    Converts a floating point value (Stored as an integer shifted by PERCENT_SHIFT) into a string

Arguments:

    ulValue - floating point value to convert
    psz - Buffer to store resulting string
    bDisplayDecimal - Indicates if the decimal value should be displayed.

Return Value:

    String containg the Floating point string

Revision History:

      1-6-2000  Created by omiller

--*/
WCHAR * CNetPage::FloatToString(ULONGLONG ullValue, WCHAR *psz, DWORD cch, BOOLEAN bDisplayDecimal)
{
    ULONGLONG ulDecimal = 0;
    ULONGLONG ulNumber = 0;
    WCHAR wsz[100];

    // Get the integer value of the number
    //
    ulNumber = ullValue / PERCENT_SHIFT;
    if( _ui64tow(ulNumber,wsz,10) )
    {
        StringCchCopy( psz, cch, wsz ); //  Shown in UI - don't care if it gets chopped.
        if( ulNumber )
        {
            ullValue = ullValue - ulNumber * PERCENT_SHIFT;
        }
        if( !ulNumber || bDisplayDecimal)
        {
            ulDecimal = ullValue * 100 / PERCENT_SHIFT;
            if( ulDecimal && _ui64tow(ulDecimal,wsz,10) )
            {                
                StringCchCat( psz, cch, g_szDecimal );  //  Shown in UI - don't care if it gets chopped.
                if( ulDecimal < 10 ) 
                { 
                    StringCchCat( psz, cch, g_szZero ); //  Shown in UI - don't care if it gets chopped.
                }
                if( wsz[1] == L'0' ) 
                {   
                    wsz[1] = L'\0';
                }
                StringCchCat( psz, cch, wsz );  //  Shown in UI - don't care if it gets chopped.
            }
        }
    }

    return psz;
}

/*++

Routine Description:

    Initialize the networking tab. This function always returns 1. The networking tab
    displays all active connections (LAN and WAN). If no connections are present when
    taskmgr is started, the Network tab should still be displayed (thus return 1) incase
    a connection is established after taskmgr has started. The network tab will detect any
    newly established connections.

Arguments:

    None

Return Value:

    1

Revision History:

      1-6-2000  Created by omiller

--*/
BYTE InitNetInfo()
{
    // The network page should always appear even if there are no Network Adapters currently present.
    //
    return 1;
}


/*++

Routine Description:

    Uninitialize all CAdapter class members. Frees all memory that
    was allocated by the class.

Arguments:

    NONE

Return Value:

    VOID

Revision History:

      1-6-2000  Created by omiller

--*/
CAdapter::~CAdapter()
{
    if( NULL != m_pifTable )
    {
        HeapFree( GetProcessHeap(), 0, m_pifTable );
    }

    if( 0 != m_dwAdapterCount )
    {
        DWORD dwSize;
        DWORD dwTotalAdapterCount;

        // Get the total size of the array and compute the number of entries in the array.
        // m_dwAdapterCount only indicates the adapters are active. The array could have been bigger
        // at one point. Free the memory for all the entries.
        //
        dwSize = (DWORD)(m_ppaiAdapterStats == NULL ? 0 : HeapSize(GetProcessHeap(),0,m_ppaiAdapterStats));   
        dwTotalAdapterCount = dwSize / sizeof(PADAPTER_INFOEX);

        for(DWORD dwAdapter=0; dwAdapter < dwTotalAdapterCount; dwAdapter++)
        {
            if( m_ppaiAdapterStats[dwAdapter] )
            {
                HeapFree( GetProcessHeap(), 0, m_ppaiAdapterStats[ dwAdapter ]);
            }
        }
        
        HeapFree( GetProcessHeap(), 0, m_ppaiAdapterStats );
    }
}

/*++

Routine Description:

    Returns the number active adapters. The IP helper functions
    provide information about physical and non-physical adapters 
    (such as the Microsoft TCP loop back adapter). 

Arguments:

    NONE

Return Value:

    Number of active adapters

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CAdapter::GetNumberOfAdapters()
{
    return m_dwAdapterCount;
}


/*++

Routine Description:

    Resets the initial data for all Network adapters. The CAdapter class collects 
    information for all active network adapters (Bytes sent, bytes received, unicasts 
    packets sent, unicast packets received etc). The class memorizes the first set of data 
    for each adapter. This is done so that the user can determine the number of i.e. bytes
    sent from when taskmgr was first started. (i.e. the number of bytes seen now minuse the 
    number of bytes seen when taskmgr was started). When the user selects the Reset option, 
    this functions overwrites the initial data, collected when taskmgr started, with the 
    current data.

Arguments:

    NONE

Return Value:

    S_OK

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CAdapter::Reset()
{
    for(DWORD dwAdapter=0; dwAdapter < m_dwAdapterCount; dwAdapter++)
    {
        // Overwrite the Start and Last stats with the Current stats
        //
        memcpy( &m_ppaiAdapterStats[dwAdapter]->ifRowStartStats
              , &m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle]
              , sizeof(m_ppaiAdapterStats[dwAdapter]->ifRowStartStats)
              );
        memcpy( &m_ppaiAdapterStats[dwAdapter]->ifRowStats[!m_bToggle]
              , &m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle]
              , sizeof(m_ppaiAdapterStats[dwAdapter]->ifRowStats[!m_bToggle])
              );
    }

    return S_OK;
}


/*++

Routine Description:

    Extracts the text fields (i.e. connection name and description) from a specified adapter

Arguments:

    deAdapter -- Adapter who text the caller wants
    nStatValue -- Specifies which field the caller wants i.e. (Name or description)

Return Value:

    NULL -- if the adapter index is invalid or nStatValue is invalid

Revision History:

      1-6-2000  Created by omiller

--*/
LPWSTR CAdapter::GetAdapterText(DWORD dwAdapter, NETCOLUMNID nStatValue)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        switch(nStatValue)
        {
        case COL_ADAPTERNAME:
            // Get adapter name 
            //
            return m_ppaiAdapterStats[dwAdapter]->wszConnectionName;           

        case COL_ADAPTERDESC:
            // Get adapter description
            //
            return m_ppaiAdapterStats[dwAdapter]->wszDesc;          

        case COL_STATE:
            switch(m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle].dwOperStatus)
            {
            case IF_OPER_STATUS_NON_OPERATIONAL:
                return g_szNonOperational;
            case IF_OPER_STATUS_UNREACHABLE:
                return g_szUnreachable;
            case IF_OPER_STATUS_DISCONNECTED:
                return g_szDisconnected;
            case IF_OPER_STATUS_CONNECTING:
                return g_szConnecting;
            case IF_OPER_STATUS_CONNECTED:
                return g_szConnected;
            case IF_OPER_STATUS_OPERATIONAL:
                return g_szOperational;
            }
            return g_szUnknownStatus;
        }
    }

    return NULL;
}


/*++

Routine Description:

    Get the Send/Receive Network utilization history for a specified adapter

Arguments:

    deAdapter -- Adapter who text the caller wants
    nHistoryType -- BYTES_SENT_UTIL for send history
                    BYTES_RECEIVED_UTIL for receive history

Return Value:

    NULL -- if the adapter index is invalid or nStatValue is invalid

Revision History:

      1-6-2000  Created by omiller

--*/
ULONG * CAdapter::GetAdapterHistory(DWORD dwAdapter, ADAPTER_HISTORY nHistoryType)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        // Return the history
        //
        return m_ppaiAdapterStats[ dwAdapter ]->ulHistory[ nHistoryType ]; 
    }
    return NULL;
}

/*++

Routine Description:

    Updates the Send/Received Network Utilization adapter history

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
BOOLEAN CAdapter::AdvanceAdapterHistory(DWORD dwAdapter)
{
    ULONG *pulHistory;

    if( dwAdapter < m_dwAdapterCount )
    {
        // Shift the receive adapter history by one and add the new point
        //
        pulHistory = m_ppaiAdapterStats[ dwAdapter ]->ulHistory[ BYTES_RECEIVED_UTIL ]; 

        MoveMemory((LPVOID) (pulHistory + 1), (LPVOID) (pulHistory), sizeof(ULONG) * (HIST_SIZE - 1) );

        // Get and add the receive network utiliation
        //
        pulHistory[0] = (ULONG) GetAdapterStat(dwAdapter, COL_BYTESRECTHRU);

        // Shift the send adapter history by one and add the new point
        //
        pulHistory = m_ppaiAdapterStats[ dwAdapter ]->ulHistory[ BYTES_SENT_UTIL ]; 

        MoveMemory((LPVOID) (pulHistory + 1), (LPVOID) (pulHistory), sizeof(ULONG) * (HIST_SIZE - 1) );

        // Get and add the send network utilization
        //
        pulHistory[0] = (ULONG) GetAdapterStat(dwAdapter, COL_BYTESSENTTHRU);

        return TRUE;
    }

    return FALSE;
}


/*++

Routine Description:

    Get the scale. The scale specifies the maximum value that is in the Adapters history.
    This value determines how the data is graphed.

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    Maximum value in history

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CAdapter::GetScale(DWORD dwAdapter)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        return m_ppaiAdapterStats[ dwAdapter ]->dwScale;
    }
    return 0;
}

/*++

Routine Description:

    Set the scale. The scale specifies the maximum value that is in the Adapters history.
    This value determines how the data is graphed.

Arguments:

    dwAdapter -- Adapter Index

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CAdapter::SetScale(DWORD dwAdapter, DWORD dwScale)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        m_ppaiAdapterStats[dwAdapter]->dwScale = dwScale;
    }
}

/*++

Routine Description:

    Computes and returns the requested statistiocs value for the specified adapter

Arguments:

    dwAdapter -- Adapter Index
    nStatValue -- The stat value requested
    bAccumulative -- If true the current value is returned
                     if fale the current - start value is returned.

Return Value:

    The requested Statistic value

Revision History:

      1-6-2000  Created by omiller

--*/
ULONGLONG CAdapter::GetAdapterStat(DWORD dwAdapter, NETCOLUMNID nStatValue, BOOL bAccumulative)
{
    if( dwAdapter < m_dwAdapterCount )
    {
        // Create pointers to the arrays so I do not have to write so much
        //
        PMIB_IFROW pifrStart        = &m_ppaiAdapterStats[dwAdapter]->ifRowStartStats;
        PMIB_IFROW pifrLast         = &m_ppaiAdapterStats[dwAdapter]->ifRowStats[!m_bToggle];
        PMIB_IFROW pifrCurrent      = &m_ppaiAdapterStats[dwAdapter]->ifRowStats[m_bToggle];
        ULONGLONG  ullTickCountDiff = m_ppaiAdapterStats[dwAdapter]->ullTickCountDiff;

        // Get the stats value, do the calculation and return the value
        //
        switch(nStatValue)
        {

        case COL_NETWORKUTIL:
        case COL_BYTESSENTTHRU:
        case COL_BYTESRECTHRU:
        case COL_BYTESTOTALTHRU:
            {
                // Contains the maximum number of bytes that could have been transimited in the time intrval 
                // between Last and Current)
                //
                ULONGLONG ullMaxBytesTransmittedInInterval;
                ULONGLONG ull;
    
                ullMaxBytesTransmittedInInterval = (pifrCurrent->dwSpeed * ullTickCountDiff)/(8 * 1000);
                if( ullMaxBytesTransmittedInInterval == 0 ) 
                {
                    return 0;
                }
                switch(nStatValue)
                {
                case COL_BYTESTOTALTHRU:
                case COL_NETWORKUTIL:
                    ull = (pifrCurrent->dwInOctets - pifrLast->dwInOctets) + (pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
                    break;
                case COL_BYTESSENTTHRU:
                    ull = (pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
                    break;
                case COL_BYTESRECTHRU:
                    ull = (pifrCurrent->dwInOctets - pifrLast->dwInOctets);
                    break;
                default:
                    ull = 0;
                    break;
                }

                ull *= 100 * PERCENT_SHIFT;
                ull /= ullMaxBytesTransmittedInInterval;

                // Make usre we do not exceed 100%, just confuses the user. Davepl inside joke!
                //
                return ull > 100 * PERCENT_SHIFT ? 99 * PERCENT_SHIFT : ull;
            }
        
        case COL_LINKSPEED:
            return pifrStart->dwSpeed;
        case COL_BYTESSENT:
            return (ULONGLONG)(pifrCurrent->dwOutOctets  - (bAccumulative ? pifrStart->dwOutOctets : 0));
        case COL_BYTESREC:
            return (ULONGLONG)(pifrCurrent->dwInOctets - (bAccumulative ? pifrStart->dwInOctets : 0));
        case COL_BYTESTOTAL:
            return (ULONGLONG)((pifrCurrent->dwInOctets + pifrCurrent->dwOutOctets) - (bAccumulative ? (pifrStart->dwInOctets + pifrStart->dwOutOctets) : 0));
        case COL_BYTESSENTPERINTER:
            return (ULONGLONG)(pifrCurrent->dwOutOctets - pifrLast->dwOutOctets);
        case COL_BYTESRECPERINTER:
            return (ULONGLONG)(pifrCurrent->dwInOctets - pifrLast->dwInOctets);
        case COL_BYTESTOTALPERINTER:
            return (ULONGLONG)((pifrCurrent->dwOutOctets + pifrCurrent->dwInOctets) - (pifrLast->dwOutOctets + pifrLast->dwInOctets));
        case COL_UNICASTSSSENT:
            return (ULONGLONG)(pifrCurrent->dwInUcastPkts - (bAccumulative ? pifrStart->dwInUcastPkts : 0));
        case COL_UNICASTSREC:
            return (ULONGLONG)(pifrCurrent->dwOutUcastPkts - (bAccumulative ? pifrStart->dwOutUcastPkts : 0));
        case COL_UNICASTSTOTAL:
            return (ULONGLONG)((pifrCurrent->dwInUcastPkts + pifrCurrent->dwOutUcastPkts) - (bAccumulative ? (pifrStart->dwInUcastPkts + pifrStart->dwOutUcastPkts) : 0));
        case COL_UNICASTSSENTPERINTER:
            return (ULONGLONG)(pifrCurrent->dwOutUcastPkts - pifrLast->dwOutUcastPkts);
        case COL_UNICASTSRECPERINTER:
            return (ULONGLONG)(pifrCurrent->dwInUcastPkts - pifrLast->dwInUcastPkts);
        case COL_UNICASTSTOTALPERINTER:
            return (ULONGLONG)((pifrCurrent->dwOutUcastPkts + pifrCurrent->dwInUcastPkts) - (pifrLast->dwOutUcastPkts + pifrLast->dwInUcastPkts));
        case COL_NONUNICASTSSSENT:
            return (ULONGLONG)(pifrCurrent->dwInNUcastPkts - (bAccumulative ? pifrStart->dwInNUcastPkts : 0));
        case COL_NONUNICASTSREC:
            return (ULONGLONG)(pifrCurrent->dwOutNUcastPkts - (bAccumulative ? pifrStart->dwOutNUcastPkts : 0));
        case COL_NONUNICASTSTOTAL:
            return (ULONGLONG)((pifrCurrent->dwInNUcastPkts + pifrCurrent->dwOutNUcastPkts) - (bAccumulative ? (pifrStart->dwInNUcastPkts + pifrStart->dwOutNUcastPkts) : 0));
        case COL_NONUNICASTSSENTPERINTER:
            return (ULONGLONG)(pifrCurrent->dwOutNUcastPkts - pifrLast->dwOutNUcastPkts);
        case COL_NONUNICASTSRECPERINTER:
            return (ULONGLONG)(pifrCurrent->dwInNUcastPkts - pifrLast->dwInNUcastPkts);
        case COL_NONUNICASTSTOTALPERINTER:
            return (ULONGLONG)((pifrCurrent->dwOutNUcastPkts + pifrCurrent->dwInNUcastPkts) - (pifrLast->dwOutNUcastPkts + pifrLast->dwInNUcastPkts));
        }
    }

    return 0;
}

/*++

Routine Description:

    Initilize all member variables. The CNetPage class displays the information collected 
    by the CAdpter class

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
CNetPage::CNetPage()
{
    ZeroMemory((LPVOID) m_hPens, sizeof(m_hPens));
    m_bReset = TRUE;
    m_hPage = NULL;                    // Handle to this page's dlg
    m_hwndTabs = NULL;                 // Parent window
    m_hdcGraph = NULL;                 // Inmemory dc for cpu hist
    m_hbmpGraph = NULL;                // Inmemory bmp for adapter hist
    m_bPageActive = FALSE;
    m_hScaleFont = NULL;
    m_lScaleWidth = 0;  
    m_lScaleFontHeight = 0;   
    m_pGraph = NULL;
    m_dwGraphCount = 0;
    m_dwFirstVisibleAdapter = 0;
    m_dwGraphsPerPage = 0;
}

/*++

Routine Description:

    Clean up

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
CNetPage::~CNetPage()
{        
    DestroyGraphs();
    ReleasePens();
    ReleaseScaleFont();
};


/*++

Routine Description:

    Reset the start Adapter set

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::Reset()
{
    m_bReset = TRUE;
}


/*++

Routine Description:

    Creates the number of required graphs

Arguments:

    dwGraphsRequired -- Graphs required

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::CreateGraphs(DWORD dwGraphsRequired)
{
    DWORD   dwSize;
    LRESULT lFont;
    HRESULT hr = S_OK;

    // Create moore graphs if required
    //
    if( dwGraphsRequired > m_dwGraphCount )
    {        
        // Expand the size of the array so it can hold more graphs
        //
        dwSize = dwGraphsRequired * sizeof(GRAPH);
        hr = ChangeArraySize((LPVOID *)&m_pGraph,dwSize);
        if( SUCCEEDED(hr) )
        {
            // Get the font of the parent window
            //
            lFont = SendMessage(m_hPage,WM_GETFONT,NULL,NULL);

            for(; m_dwGraphCount < dwGraphsRequired; m_dwGraphCount++)
            {
                // Create the graph window. The graph is drawn in the window
                //
                m_pGraph[m_dwGraphCount].hwndGraph = CreateWindowEx(WS_EX_CLIENTEDGE,
                                                                      L"BUTTON",
                                                                      L"",
                                                                      WS_CHILDWINDOW | BS_OWNERDRAW | WS_DISABLED,
                                                                      0,0,0,0,
                                                                      m_hPage,
                                                                      (HMENU)ULongToPtr(IDC_NICGRAPH + m_dwGraphCount),
                                                                      NULL,NULL);
                if( m_pGraph[m_dwGraphCount].hwndGraph )
                {
                    if( m_dwGraphCount == 0 )
                    {
                        HDC hdc = GetDC(m_pGraph[m_dwGraphCount].hwndGraph);
                        if(hdc )
                        {
                            CreateScaleFont(hdc);
                            ReleaseDC(m_pGraph[m_dwGraphCount].hwndGraph,hdc);
                        }
                    }

                    // Create the frame window. The window draws a pretty border around the graph
                    //
                    m_pGraph[m_dwGraphCount].hwndFrame = CreateWindowEx(WS_EX_NOPARENTNOTIFY,
                                                                          L"DavesFrameClass",
                                                                          L"",
                                                                          0x7 | WS_CHILDWINDOW,
                                                                          0,0,0,0,
                                                                          m_hPage,
                                                                          NULL,NULL,NULL);

                    if( m_pGraph[m_dwGraphCount].hwndFrame )
                    {
                        // Create the graph window. The graph is drawn in the window
                        //                
                        SendMessage(m_pGraph[m_dwGraphCount].hwndFrame,WM_SETFONT,lFont,FALSE);                    
                    }
                    else
                    {
                        // Destroy the graph window and abort
                        // TODO hr = error and break;
                        DestroyWindow(m_pGraph[m_dwGraphCount].hwndGraph);
                        return E_OUTOFMEMORY;
                    }
                }
                else
                {
                    // Unable to create the window, abort
                    //
                    return E_OUTOFMEMORY;
                }
            }
        }
    }
    return hr;
}

/*++

Routine Description:

    Destroies the History graph windows

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::DestroyGraphs()
{
    for(DWORD dwGraph=0; dwGraph < m_dwGraphCount; dwGraph++)
    {
        DestroyWindow( m_pGraph[dwGraph].hwndGraph );
        DestroyWindow( m_pGraph[dwGraph].hwndFrame );
    }

    if( NULL != m_pGraph )
    {
        HeapFree( GetProcessHeap(), 0, m_pGraph );
        m_pGraph = NULL;
    }    

    m_dwGraphCount = 0;
}

/*++

Routine Description:

    Restores the order of the Network tab's list view columns. The order is
    stored in g_Options. When taskmgr is closed, the order is stored in the registry

Arguments:

    hwndList -- Handle to the list view

Return Value:

    NONE

Revision History:

      1-6-2000  Borrowed by omiller

--*/
void CNetPage::RestoreColumnOrder(HWND hwndList)
{
    INT rgOrder[ARRAYSIZE(g_aNetDlgColIDs)];
    INT cOrder = 0;
    INT iOrder = 0;

    //
    // Get the order of the columns
    //

    for (int i = 0; i < ARRAYSIZE(g_aNetDlgColIDs); i++)
    {
        iOrder = g_Options.m_NetColumnPositions[i];
        if (-1 == iOrder)
            break;

        rgOrder[cOrder++] = iOrder;
    }

    if (0 < cOrder)
    {
        //
        // Set the order of the columns
        //

        const HWND hwndHeader = ListView_GetHeader(hwndList);
        Header_SetOrderArray(hwndHeader, Header_GetItemCount(hwndHeader), rgOrder);
    }
}

/*++

Routine Description:

    Remember the order of the Network tab's list view columns. The order is
    stored in g_Options. When taskmgr is closed, the order is stored in the registry

Arguments:

    hwndList -- Handle to the list view

Return Value:

    NONE

Revision History:

      1-6-2000  Borrowed by omiller

--*/
void CNetPage::RememberColumnOrder(HWND hwndList)
{
    const HWND hwndHeader = ListView_GetHeader(hwndList);

    int x;

    x = Header_GetItemCount(hwndHeader);
    ASSERT(Header_GetItemCount(hwndHeader) <= ARRAYSIZE(g_Options.m_NetColumnPositions));

    //
    // Clear the array
    //

    FillMemory(&g_Options.m_NetColumnPositions, sizeof(g_Options.m_NetColumnPositions), 0xFF);

    //
    // Get the order of the columns and store it in the array
    //

    Header_GetOrderArray(hwndHeader, 
                         Header_GetItemCount(hwndHeader),
                         g_Options.m_NetColumnPositions);
}

/*++

Routine Description:

    The Window Proc for the select a column Dialog box. Allows the user to select the collumns.

Arguments:

    hwndDlg -- Handle to the dialog box
    uMsg -- Window message
    wParam -- Window message
    lParam -- WIndows Message

Return Value:

    Something

Revision History:

      1-6-2000  Borrowed by omiller

--*/
INT_PTR CALLBACK NetColSelectDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CNetPage * pPage = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        pPage = (CNetPage *) lParam;

        //
        // Start with none of the boxes checked
        //

        for (int i = 0; i < ARRAYSIZE(g_aNetDlgColIDs); i++)
        {
            CheckDlgButton(hwndDlg, g_aNetDlgColIDs[i], BST_UNCHECKED);
        }

        //
        // Then turn on the ones for the columns we have active
        //

        for (i = 0; i < ARRAYSIZE(g_aNetDlgColIDs); i++)
        {
            if (g_Options.m_ActiveNetCol[i] == -1)
            {
                break;
            }

            CheckDlgButton(hwndDlg, g_aNetDlgColIDs[ g_Options.m_ActiveNetCol[ i ] ], BST_CHECKED);
        }
        return TRUE;

    case WM_COMMAND:
        //
        // If user clicked OK, add the columns to the array and reset the listview
        //

        if (LOWORD(wParam) == IDOK)
        {
            //
            // First, make sure the column width array is up to date
            //

            pPage->SaveColumnWidths();

            INT iCol = 0;

            for (int i = 0; i < NUM_NETCOLUMN && g_aNetDlgColIDs[i] >= 0; i++)
            {
                if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, g_aNetDlgColIDs[i]))
                {
                    //
                    // It is checked
                    //

                    if (g_Options.m_ActiveNetCol[iCol] != (NETCOLUMNID) i)
                    {
                        //
                        // If the column wasn't already there, insert its column
                        // width into the column width array
                        //

                        ShiftArray(g_Options.m_NetColumnWidths, iCol, SHIFT_UP);
                        ShiftArray(g_Options.m_ActiveNetCol, iCol, SHIFT_UP);
                        g_Options.m_NetColumnWidths[iCol] = NetColumnDefaults[ i ].Width;
                        g_Options.m_ActiveNetCol[iCol] = (NETCOLUMNID) i;
                    }
                    iCol++;
                }
                else
                {
                    //
                    // Not checked, column not active.  If it used to be active,
                    // remove its column width from the column width array
                    //

                    if (g_Options.m_ActiveNetCol[iCol] == (NETCOLUMNID) i)
                    {
                        ShiftArray(g_Options.m_NetColumnWidths, iCol, SHIFT_DOWN);
                        ShiftArray(g_Options.m_ActiveNetCol, iCol, SHIFT_DOWN);
                    }
                }
            }

            //
            // Terminate the column list
            //
                            
            g_Options.m_ActiveNetCol[iCol] = (NETCOLUMNID) -1;
            pPage->SetupColumns();
            EndDialog(hwndDlg, IDOK);
        }
        else if (LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, IDCANCEL);
        }
        break;
    }

    return FALSE;
}

/*++

Routine Description:

    Handle the slect a column dialog box

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::PickColumns()
{    
    DialogBoxParam( g_hInstance
                  , MAKEINTRESOURCE(IDD_SELECTNETCOLS)
                  , g_hMainWnd
                  , NetColSelectDlgProc
                  , (LPARAM) this
                  );
}

/*++

Routine Description:

    Creates the necessary pens

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CreatePens()
{
    for (int i = 0; i < ARRAYSIZE(aNetColors); i++)
    {
        //
        // Create the pens.  If a failure occurs, just substitute
        // the white pen
        //

        m_hPens[i] = CreatePen(PS_SOLID, 1, aNetColors[i]);
        if (NULL == m_hPens[i])
        {
            m_hPens[i] = (HPEN) GetStockObject(WHITE_PEN);
        }
    }
}

/*++

Routine Description:

    Destroys the pens

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::ReleasePens()
{
    for (int i = 0; i < NUM_PENS; i++)
    {
        if ( NULL != m_hPens[ i ] )
        {
            DeleteObject( m_hPens[ i ] );
        }
    }
}

/*++

Routine Description:

    Compute the width (in px) of a string

Arguments:

    hdc - DC handle
    pszwText - String to determine the width of.


Return Value:

    The width of the string

Revision History:

      1-6-2000  Created by omiller

--*/
int GetStrWidth(HDC hdc, WCHAR *pszwText)
{
    int iWidth;
    int iTotalWidth = 0;

    if( pszwText )
    {
        // Sum the width of the chars in the string
        //
        for(int i=0; pszwText[i]!=L'\0'; i++)
        {
            if( GetCharWidth32( hdc, pszwText[i], pszwText[i], &iWidth ) )
            {
                iTotalWidth += iWidth;
            }
            else
            {
                // GetCharWidth32 failed, return -1 as an error code
                return -1;
            }
        }
    }
    // Return the total width of the string
    //
    return iTotalWidth;
}

/*++

Routine Description:

    Creates the font for the scale. The font is created when the first graph is created.
    The hdc of the raph is used to determine the height of the font and the total with of 
    the scale.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CreateScaleFont(HDC hdc)
{
    if( NULL == m_hScaleFont && NULL != hdc)
    {
        //
        // The font has not yet been created. 
        //

        INT FontSize;    
        NONCLIENTMETRICS ncm = {0};
        LOGFONT lf;
        HFONT hOldFont = NULL;

        ncm.cbSize = sizeof(ncm);
        if ( SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0) )
        {
            lf = ncm.lfMessageFont;
            lf.lfWeight = FW_THIN;

            //
            //  Make sure the font name will not be clipped.
            //

            Assert( ARRAYSIZE(lf.lfFaceName) >= ARRAYSIZE(g_szScaleFont) );
            StringCchCopy( lf.lfFaceName, ARRAYSIZE(lf.lfFaceName), g_szScaleFont );

            FontSize = 8;
            lf.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * FontSize / 72;
            m_hScaleFont = CreateFontIndirect(&lf);
            if ( NULL != m_hScaleFont )
            {
                hOldFont = (HFONT) SelectObject( hdc, (HGDIOBJ) m_hScaleFont );
            }

            m_lScaleFontHeight = lf.lfHeight - 2;
            m_lScaleWidth = GetStrWidth(hdc,L" 22.5 %");

            if( NULL != hOldFont )
            {
                SelectObject( hdc, (HGDIOBJ) hOldFont );
            }
        }
    }
}

/*++

Routine Description:

    Releases the fonts

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::ReleaseScaleFont()
{
    if( m_hScaleFont )
    {
        DeleteObject(m_hScaleFont);
        m_hScaleFont = NULL;
    }
}


/*++

Routine Description:

    Draws the scale for the graph

Arguments:

    hdcGraph - hdc of the graph
    prcGraph - Graph region
    dwMaxScaleValue - The highest scale value

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
INT CNetPage::DrawScale(HDC hdcGraph, RECT *prcGraph, DWORD dwMaxScaleValue)
{
    HPEN  hOldPen  = NULL;
    HFONT hOldFont = NULL;    
    INT   Leftside = prcGraph->left;
    WCHAR sz[100];
    RECT  rc;

    if( g_Options.m_bShowScale )
    {         
        if( NULL != m_hScaleFont )
        {
            // Set the scale font
            hOldFont = (HFONT) SelectObject(hdcGraph,(HGDIOBJ)m_hScaleFont);
        }

        // Set the text attributes 
        //
        SetBkMode(hdcGraph,TRANSPARENT);
        SetTextColor(hdcGraph,RGB(255, 255, 0));

        // Make room for the scale
        //
        Leftside += m_lScaleWidth;
        rc.left = prcGraph->left;
        rc.right = Leftside - 3;

        // Draw the upper scale value
        //
        rc.top = prcGraph->top;
        rc.bottom = rc.top - m_lScaleFontHeight;
        FloatToString( dwMaxScaleValue * PERCENT_SHIFT, sz, ARRAYSIZE(sz), TRUE );
        StringCchCat( sz, ARRAYSIZE(sz), L" " );
        StringCchCat( sz, ARRAYSIZE(sz), g_szPercent );
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        // Draw the middle scale value. multi by PERCENT_SHIFT because FloatToString takes a number shifted by PERCENT_SHIFT
        //
        rc.top = prcGraph->top + (prcGraph->bottom - prcGraph->top)/2 + m_lScaleFontHeight/2;
        rc.bottom = rc.top - m_lScaleFontHeight;
        FloatToString( ( dwMaxScaleValue * PERCENT_SHIFT ) / 2, sz, ARRAYSIZE(sz), TRUE );
        StringCchCat( sz, ARRAYSIZE(sz), L" " );
        StringCchCat( sz, ARRAYSIZE(sz), g_szPercent );
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        // Draw the botton scale value
        //
        rc.top = prcGraph->bottom + m_lScaleFontHeight; 
        rc.bottom = rc.top - m_lScaleFontHeight;
        StringCchCopy( sz, ARRAYSIZE(sz), g_szZero );
        StringCchCat( sz, ARRAYSIZE(sz), L" " );
        StringCchCat( sz, ARRAYSIZE(sz), g_szPercent );
        DrawText(hdcGraph,sz,lstrlen(sz),&rc,DT_RIGHT);

        if( hOldFont )
        {
            SelectObject(hdcGraph,hOldFont);
        }

        // Draw the scale line. Divides the scale from the graph
        //
        hOldPen = (HPEN) SelectObject( hdcGraph, m_hPens[1] );

        MoveToEx(hdcGraph,
                 Leftside,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               Leftside,
               prcGraph->bottom); 

        if( NULL != hOldPen)
        {
            SelectObject( hdcGraph, hOldPen );            
        }
    }

    return Leftside;
}
/*++


Routine Description:

    Draw the graph paper. The size of the squares depends of the zoom level.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
ULONG CNetPage::DrawAdapterGraphPaper(HDC hdcGraph, RECT * prcGraph, DWORD dwZoom)
{
    #define GRAPHPAPERSIZE 12

    HPEN  hPen;
    int   Leftside = prcGraph->left;
    ULONG ulSquareSize = GRAPHPAPERSIZE + (20 * (100 - 100/dwZoom)) / 100;        //28
    int   nLineCount = 0;

    Leftside = DrawScale(hdcGraph,prcGraph,100/dwZoom);

    hPen = CreatePen(PS_SOLID, 1, RGB(0, 128, 64));

    HGDIOBJ hOldObj = SelectObject(hdcGraph, hPen);

    // Draw the vertical lines 
    //
    for (int i = (ulSquareSize) + 1; i < prcGraph->bottom - prcGraph->top; i+= ulSquareSize)
    {
        MoveToEx(hdcGraph,
                 Leftside,
                 prcGraph->bottom - i,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               prcGraph->right,
               prcGraph->bottom - i); 

        nLineCount++;
    } 

    // Draw the horizontal lines
    //
    for (i = prcGraph->right - g_NetScrollamount; i > Leftside; i -= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 i,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               i,
               prcGraph->bottom);
    }

    if (hOldObj)
    {
        SelectObject(hdcGraph, hOldObj);
    }

    if( hPen )
    {
        DeleteObject(hPen);
    }

    return Leftside - prcGraph->left - 3;
}


/*++

Routine Description:

    Add the column headers to the Network tab's List view

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::SetupColumns()
{
    //
    // Delete all the items in the list view
    //
    ListView_DeleteAllItems(m_hListView);

    //
    // Remove all existing columns
    //

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(m_hListView, 0))
    {
        NULL;
    }

    //
    // Add all of the new columns
    //

    INT iColumn = 0;
    while (g_Options.m_ActiveNetCol[iColumn] >= 0)
    {
        INT idColumn = g_Options.m_ActiveNetCol[iColumn];

        WCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, _aIDNetColNames[idColumn], szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = NetColumnDefaults[ idColumn ].Format | (idColumn > 1 ? LVCFMT_RIGHT : 0);

        // If no width preference has been recorded for this column, use the
        // default

        if (-1 == g_Options.m_NetColumnWidths[iColumn])
        {
            lvcolumn.cx = NetColumnDefaults[ idColumn ].Width;
        }
        else
        {
            lvcolumn.cx = g_Options.m_NetColumnWidths[iColumn];
        }

        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(m_hListView, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }
        iColumn++;
    }

    ListView_SetExtendedListViewStyleEx(m_hListView,LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT , LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT);
    return S_OK;
}


/*++

Routine Description:

    Save the width of the columns

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/    
void CNetPage::SaveColumnWidths()
{
    UINT i = 0;
    LV_COLUMN col = { 0 };

    while (g_Options.m_ActiveNetCol[i] != (NETCOLUMNID) -1)
    {
        col.mask = LVCF_WIDTH;
        if (ListView_GetColumn(m_hListView, i, &col) )
        {
            g_Options.m_NetColumnWidths[i] = (SHORT)col.cx;
        }
        else
        {
            ASSERT(0 && "Couldn't get the column width");
        }
        i++;
    }
}

/*++

Routine Description:

    Initialize the Network tab

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::Initialize(HWND hwndParent)
{
    CreatePens();
    
    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,                    // handle to application instance
                    MAKEINTRESOURCE(IDD_NETPAGE),   // identifies dialog box template name
                    g_hMainWnd,                     // handle to owner window
                    NetPageProc,                    // pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }
    // no fail if GetDlgItem
    m_hNoAdapterText = GetDlgItem(m_hPage, IDC_NOADAPTERS);
    if( !m_hNoAdapterText )
    {
        return E_FAIL;
    }

    m_hScrollBar = GetDlgItem(m_hPage, IDC_GRAPHSCROLLVERT);
    if( !m_hScrollBar )
    {
        return E_FAIL;
    }

    m_hListView = GetDlgItem(m_hPage, IDC_NICTOTALS);
    if( !m_hListView )
    {
        return E_FAIL;
    }

    // Add the columns to the list view
    //
    SetupColumns();

    // Order the columns for the user
    //
    RestoreColumnOrder(m_hListView);

    return S_OK;
}

/*++

Routine Description:

    Creates the memory bitmaps for the graphs

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::CreateMemoryBitmaps(int x, int y)
{
    //
    // Create the inmemory bitmaps and DCs that we will use
    //

    HDC hdcPage = GetDC(m_hPage);
    m_hdcGraph = CreateCompatibleDC(hdcPage);

    if (NULL == m_hdcGraph)
    {
        ReleaseDC(m_hPage, hdcPage);
        return GetLastHRESULT();
    }

    m_rcGraph.left   = 0;
    m_rcGraph.top    = 0;
    m_rcGraph.right  = x;
    m_rcGraph.bottom = y;

    m_hbmpGraph = CreateCompatibleBitmap(hdcPage, x, y);
    ReleaseDC(m_hPage, hdcPage);
    if (NULL == m_hbmpGraph)
    {
        HRESULT hr = GetLastHRESULT();
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
        return hr;
    }

    //
    // Select the bitmap into the DC
    //

    m_hOldObject = SelectObject(m_hdcGraph, m_hbmpGraph);

    return S_OK;
}

/*++

Routine Description:

    Destroy the bitmaps for the graphs

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::FreeMemoryBitmaps()
{
    if ( NULL != m_hdcGraph )
    {
        if ( NULL != m_hOldObject )
        {
            HGDIOBJ hObj = SelectObject( m_hdcGraph, m_hOldObject );
            ASSERT( hObj == (HGDIOBJ) m_hbmpGraph );
            hObj; // unreferenced on FRE builds
        }

        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
    }
    
    if ( NULL != m_hbmpGraph )
    {
        DeleteObject(m_hbmpGraph);
        m_hbmpGraph = NULL;
    }
}

/*++

Routine Description:

    This function is called when the Network tab is activated.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::Activate()
{
    // Adjust the size and position of our dialog relative
    // to the tab control which "owns" us

    RECT rcParent;
    GetClientRect(m_hwndTabs, &rcParent);
    MapWindowPoints(m_hwndTabs, g_hMainWnd, (LPPOINT) &rcParent, 2);
    TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);

    // The user has switched to the tab. The Networking tab is now active
    // The tab will stay active for the whole life time of taskmgr
    //
    m_bPageActive = TRUE;

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 rcParent.left, rcParent.top,
                 rcParent.right - rcParent.left, rcParent.bottom - rcParent.top,
                 0);

    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    // Newly created dialogs seem to steal the focus, so give it back to the
    // tab control (which must have had it if we got here in the first place)

    SetFocus(m_hwndTabs);

    TimerEvent();

    // Change the menu bar to be the menu for this page

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_NET));

    AdjustMenuBar(hMenuNew);

    CheckMenuItem(hMenuNew,IDM_BYTESSENT,g_Options.m_bAutoSize ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESSENT,g_Options.m_bGraphBytesSent ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESRECEIVED,g_Options.m_bGraphBytesReceived ? MF_CHECKED:MF_UNCHECKED);
    CheckMenuItem(hMenuNew,IDM_BYTESTOTAL,g_Options.m_bGraphBytesTotal ? MF_CHECKED:MF_UNCHECKED);

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    SizeNetPage();

    return S_OK;
}


/*++

Routine Description:

    This function is called when the Network tab is deactivated.

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::Deactivate()
{
        
    SaveColumnWidths();

    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }

    FreeMemoryBitmaps( );
}

//
//
//
HRESULT CNetPage::Destroy()
{
    //
    // When we are being destroyed, kill off our dialog
    //    

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    FreeMemoryBitmaps( );

    return S_OK;
}

/*++

Routine Description:

    Get the title of the networking tab i.e. "Networking"

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_NETPAGETITLE, pszText, static_cast<int>(bufsize));
}


/*++

Routine Description:

    Size the History graph

Arguments:

    hdwp -- Defered Window Handle
    pGraph -- History graph to size
    pRect -- The corrdinates of the graph
    pDimRect -- The dimentions of the actual history graph

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::SizeGraph(HDWP hdwp, GRAPH *pGraph, RECT *pRect, RECT *pDimRect)
{
    RECT rc;
    DWORD dwGraphWidth  = pRect->right - g_DefSpacing * 2; 
    DWORD dwGraphHeight = pRect->bottom - g_TopSpacing - g_DefSpacing;
    

    // Size the frame
    //
    rc.left   = pRect->left;
    rc.top    = pRect->top;
    rc.right  = pRect->left + pRect->right;
    rc.bottom = pRect->top  + pRect->bottom;

    DeferWindowPos(hdwp, 
                   pGraph->hwndFrame, 
                   NULL, 
                   rc.left,
                   rc.top,
                   rc.right - rc.left,
                   rc.bottom - rc.top,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);        

    // Size the History graph
    //
    rc.left   = rc.left + g_DefSpacing;
    rc.top    = rc.top  + g_TopSpacing;
    rc.right  = rc.left + dwGraphWidth;
    rc.bottom = rc.top  + dwGraphHeight;

    DeferWindowPos(hdwp, 
                   pGraph->hwndGraph, 
                   NULL, 
                   rc.left,
                   rc.top,
                   rc.right - rc.left,
                   rc.bottom - rc.top,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);              

    if( pDimRect )
    {
        // Return the size of the history graph
        //
        *pDimRect = rc;
    }
}

/*++

Routine Description:

    Hide the history graph

Arguments:

    hdwp -- Defered Window Handle
    pGraph -- History graph to hide

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::HideGraph(HDWP hdwp, GRAPH *pGraph)
{
    // Hide the frame
    //
    DeferWindowPos(hdwp, 
                   pGraph->hwndFrame, 
                   NULL, 
                   0,0,0,0,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);        

    // Hide the graph
    //
    DeferWindowPos(hdwp, 
                   pGraph->hwndGraph, 
                   NULL, 
                   0,0,0,0,
                   SWP_NOZORDER | SWP_NOACTIVATE | SWP_HIDEWINDOW);        
}

/*++

Routine Description:

    Compute the number of graphs we can squeeze on a page

Arguments:

    dwHeight -- Height of the graphing area
    dwAdapterCount -- Total number of adapters 

Return Value:

    Number of adapters that can be squeeze on to the tab

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::GraphsPerPage(DWORD dwHeight, DWORD dwAdapterCount)
{
    DWORD dwGraphsPerPage = 0;

    if( dwAdapterCount )
    {
        DWORD dwGraphHeight;
        // Compute the average height of an adapter if all adapters were put on the page
        // If they all fit then squueze all of them on the page, if the height is smaller then the min
        // height compute the number of adapters we can squeeze on the page.
        //
        dwGraphHeight = dwHeight / dwAdapterCount;
        dwGraphHeight = dwGraphHeight < MIN_GRAPH_HEIGHT ? MIN_GRAPH_HEIGHT : dwGraphHeight;
        dwGraphsPerPage = dwHeight > dwGraphHeight ? dwHeight / dwGraphHeight : 1;        
    }

    return dwGraphsPerPage;
}

/*++

Routine Description:

    Get the first adapter that the user sees graphed.

Arguments:

    void 

Return Value:

    The first adapter the user sees graphed

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::GetFirstVisibleAdapter()
{
    DWORD dwAdapter = m_dwFirstVisibleAdapter;
    DWORD dwAdapterCount = m_Adapter.GetNumberOfAdapters();

    if( dwAdapter + m_dwGraphsPerPage > dwAdapterCount )
    {
        dwAdapter = dwAdapterCount - m_dwGraphsPerPage;
    }

    if( dwAdapter >= dwAdapterCount )
    {
        dwAdapter = 0;
    }

    return dwAdapter;
}

/*++

Routine Description:

    Assigns a name to each graph.

Arguments:

    void 

Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::LabelGraphs()
{
    DWORD dwAdapter;
    
    dwAdapter = GetFirstVisibleAdapter();

    for(DWORD dwGraph=0; dwGraph < m_dwGraphsPerPage; dwGraph++)
    {        
        SetWindowText( m_pGraph[ dwGraph ].hwndFrame, m_Adapter.GetAdapterText( dwAdapter + dwGraph, COL_ADAPTERNAME) );
    }

    UpdateGraphs();    
}

/*++

Routine Description:

    Size the history graphs. 

Arguments:

    void 

Return Value:

    void

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::SizeNetPage()
{
    HRESULT hr;    
    HDWP    hdwp;
    RECT    rcParent;
    RECT    rcGraph = {0};
    RECT    rcGraphDim = {0};
    DWORD   dwAdapterCount;
    DWORD   dwGraphHistoryHeight = 0;
    BOOLEAN bNeedScrollBar  = FALSE;

    m_dwGraphsPerPage = 0;

    if (g_Options.m_fNoTitle)
    {
        // Just display the graphs, not the list view or the tabs
        //
        GetClientRect(g_hMainWnd, &rcParent);
        dwGraphHistoryHeight = rcParent.bottom - rcParent.top - g_DefSpacing;
    }
    else
    {
        // Display the graphs, list view and tabs
        //
        GetClientRect(m_hwndTabs, &rcParent);
        MapWindowPoints(m_hwndTabs, m_hPage, (LPPOINT) &rcParent, 2);
        TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);
        dwGraphHistoryHeight = (rcParent.bottom - rcParent.top - g_DefSpacing) * 3 / 4;
    }    

    // Determine the number of adapters so we can compute the number of graphs to display perpage.
    //
    dwAdapterCount = m_Adapter.GetNumberOfAdapters();
    if( dwAdapterCount )
    {
        // Compute the number of graphs we can squeeze onto the page. One graph always fits onto the tab.
        //
        m_dwGraphsPerPage = GraphsPerPage(dwGraphHistoryHeight, dwAdapterCount);
        hr = CreateGraphs(m_dwGraphsPerPage);            
        if( FAILED(hr) )
        {
            // Unable to create the graphs, abort
            //
            return;
        }           

        // Determine if we need to display the scroll bar
        //
        bNeedScrollBar = (dwAdapterCount > m_dwGraphsPerPage);

        // Determine the rect for the first graph
        //
        rcGraph.left   = rcParent.left  + g_DefSpacing;
        rcGraph.right  = (rcParent.right - rcParent.left) - g_DefSpacing*2 - (bNeedScrollBar ? SCROLLBAR_WIDTH + g_DefSpacing : 0);
        rcGraph.top    = rcParent.top   + g_DefSpacing;
        rcGraph.bottom = dwGraphHistoryHeight / m_dwGraphsPerPage;
    }

    //
    // SizeGraph() and HideGraph() each have 2 DeferWindowPos calls.
    //
    hdwp = BeginDeferWindowPos(3 + m_dwGraphCount * 2); 
    if( hdwp ) 
    {
        // Position the scroll bar window
        //
        DeferWindowPos(hdwp, 
                       m_hScrollBar,
                       NULL, 
                       rcParent.right - g_DefSpacing - SCROLLBAR_WIDTH,
                       rcParent.top   + g_DefSpacing,
                       SCROLLBAR_WIDTH, 
                       rcGraph.bottom * m_dwGraphsPerPage,
                       (bNeedScrollBar ? SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW : SWP_HIDEWINDOW));              


        // Position the induvidual graphs. We might have created more graphs then we needed, hide the extra graphs
        //
        for(DWORD dwGraph=0; dwGraph < m_dwGraphCount; dwGraph++ )
        {
            if( dwGraph < m_dwGraphsPerPage )
            {
                SizeGraph( hdwp, &m_pGraph[ dwGraph ], &rcGraph, &rcGraphDim );
                rcGraph.top += rcGraph.bottom;
            }
            else
            {
                // Do not display these graphs
                //
                HideGraph( hdwp, &m_pGraph[ dwGraph ] );
            }
        }

        // Postion the list view that displays the stats

        DeferWindowPos(hdwp, 
                       m_hListView, 
                       NULL, 
                       rcGraph.left,
                       rcGraph.top + g_DefSpacing,
                       rcParent.right - rcParent.left - rcGraph.left - g_DefSpacing,
                       rcParent.bottom - rcGraph.top - g_DefSpacing,
                       dwAdapterCount ? SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW : SWP_HIDEWINDOW);              

        // Position the "No Active Adapters found" text
        //
        DeferWindowPos(hdwp, 
                       m_hNoAdapterText, 
                       NULL, 
                       rcParent.left ,
                       rcParent.top + (rcParent.bottom - rcParent.top) / 2 - 40,
                       rcParent.right - rcParent.left,
                       rcParent.bottom - rcParent.top,
                       dwAdapterCount ? SWP_HIDEWINDOW : SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);             

        EndDeferWindowPos(hdwp);

        FreeMemoryBitmaps();        // Free any old ones
        CreateMemoryBitmaps(rcGraphDim.right - rcGraphDim.left, rcGraphDim.bottom - rcGraphDim.top - 4); 

        LabelGraphs();

        if( bNeedScrollBar )
        {
            SCROLLINFO si;

            // Set up the scroll bar
            //
            si.cbSize = sizeof(SCROLLINFO);
            si.fMask  = SIF_PAGE | SIF_RANGE;
            si.nPage  = 1; 
            si.nMin   = 0;
            si.nMax   = dwAdapterCount - m_dwGraphsPerPage; 
    
            SetScrollInfo(m_hScrollBar,SB_CTL,&si,TRUE);
        }
    }
}


/*++

Routine Description:

    Update all of the Networking graphs. i.e. redraw the graphs

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::UpdateGraphs()
{
    for (DWORD dwGraph = 0; dwGraph < m_dwGraphsPerPage; dwGraph++)
    {
        InvalidateRect( m_pGraph[dwGraph].hwndGraph, NULL, FALSE ); 
        UpdateWindow( m_pGraph[dwGraph].hwndGraph) ;
    }
}


/*++

Routine Description:

    Draw a Networking graph

Arguments:

    prc -- the coordinates of the graph
    hPen -- The color of the graph line
    dwZoom -- the zoom level of the graph
    pHistory -- The history to plot
    pHistory2 -- The other history to draw in cobonation with the first history i.e. pHistory + pHistory2

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
DWORD CNetPage::DrawGraph(LPRECT prc, HPEN hPen, DWORD dwZoom, ULONG *pHistory, ULONG *pHistory2)
{
    HGDIOBJ   hOldObj;
    ULONGLONG nValue;
    DWORD     nMax=0;

    int Width = prc->right - prc->left;
    int Scale = (Width - 1) / HIST_SIZE;

    if (0 == Scale)
    {
        Scale = 2;
    }

    hOldObj = SelectObject(m_hdcGraph, hPen ); 

    // Compute the height of the graph
    //
    int GraphHeight = m_rcGraph.bottom - m_rcGraph.top;

    // Get the first value to plot
    //
    if( pHistory2 )
    {
        if( pHistory[0] == INVALID_VALUE || pHistory2[0] == INVALID_VALUE )
        {
            return nMax;
        }
        nValue = (DWORD) (pHistory[0]+pHistory2[0]);    
    }
    else
    {
        if( pHistory[0] == INVALID_VALUE )
        {
            return nMax;
        }
        nValue = (DWORD) (pHistory[0]);       
    }


    // Memorize the max value that is plotted (effects the zoom level)
    //
    nMax = (DWORD)(nValue/PERCENT_SHIFT > nMax ? nValue/PERCENT_SHIFT : nMax);
    nValue = (nValue * GraphHeight * dwZoom/ 100)/PERCENT_SHIFT;
    nValue = nValue == 0 ? 1 : nValue;
    
    MoveToEx(m_hdcGraph,
             m_rcGraph.right,
             m_rcGraph.bottom - (ULONG)nValue,
             (LPPOINT) NULL);

    // Plot the points
    //
    for (INT nPoint = 1; nPoint < HIST_SIZE && nPoint * Scale < Width; nPoint++)
    {
        if( pHistory2 )
        {
            if( pHistory[nPoint] == INVALID_VALUE || pHistory2[nPoint] == INVALID_VALUE )
            {
                return nMax;
            }

            // Get both points
            //
            nValue = (DWORD) (pHistory[nPoint]+pHistory2[nPoint]);        
        }
        else
        {
            if( pHistory[nPoint] == INVALID_VALUE )
            {
                return nMax;
            }
            
            // Just get the first point
            //
            nValue = (DWORD) (pHistory[nPoint]);        
        }

        //nValue /= PERCENT_SHIFT;

        // Memorize the max value that is plotted (effects the zoom level)
        //
        nMax = (DWORD)(nValue/PERCENT_SHIFT > nMax ? nValue/PERCENT_SHIFT : nMax);
        nValue = (nValue * GraphHeight * dwZoom / 100) / PERCENT_SHIFT;
        nValue = nValue == 0 ? 1 : nValue;

        LineTo(m_hdcGraph,
               m_rcGraph.right - (Scale * nPoint),
               m_rcGraph.bottom - (ULONG)nValue);        


    }

    if (hOldObj)
    {
        SelectObject(m_hdcGraph, hOldObj);
    }

    // Return the maximum value plotted
    //
    return nMax;
}


/*++

Routine Description:

    Draw a Networking graph

Arguments:

    lpdi -- the coordinates of the graph
    iPane -- The id of the graph to draw

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::DrawAdapterGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane)
{

    DWORD dwZoom = 1;
    DWORD dwScale = 100;
    DWORD dwAdapter;

    if( iPane > m_dwGraphCount )
    {
        return;
    }    

    // Get the adapter index.
    //
    dwAdapter = iPane + GetFirstVisibleAdapter();
    if( dwAdapter >= m_Adapter.GetNumberOfAdapters() )
    {
        // Invalid adapter, abort.
        //
        return;
    }
    
    // Get the scale for the adapter
    //
    dwScale = m_Adapter.GetScale(dwAdapter);


    // Determine the zoom level
    //
    if( g_Options.m_bAutoSize )
    {
        if( dwScale < 1 )
        {
            dwZoom = 100;
        }
        else if( dwScale < 5)
        {
            dwZoom = 20;
        }
        else if( dwScale < 25)
        {
            dwZoom = 4;
        } 
        else if( dwScale < 50)
        {
            dwZoom = 2;
        } 
        else
        {
            dwZoom = 1;
        }
    }


    if (NULL == m_hdcGraph)
    {
        return;
    }
   
    // Draw a black background into the graph
    //
    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(BLACK_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;
    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    // Draw the graph paper. The zoom effects the horzontal lines
    //
    ULONG ulWidth = DrawAdapterGraphPaper(m_hdcGraph, &m_rcGraph, dwZoom);

    DWORD nValue;
    dwScale = 0;
    
    lpdi->rcItem.left += ulWidth;

    if( g_Options.m_bGraphBytesSent )
    {
        // Draw the bytes sent graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem, m_hPens[0], dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_SENT_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    if( g_Options.m_bGraphBytesReceived )
    {
        // Draw the bytes received graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem,m_hPens[1], dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_RECEIVED_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    if( g_Options.m_bGraphBytesTotal)
    {
        // Draw the bytes total graph. Check the max value plotted
        //
        nValue = DrawGraph(&lpdi->rcItem,m_hPens[2],dwZoom, m_Adapter.GetAdapterHistory(dwAdapter,BYTES_SENT_UTIL),m_Adapter.GetAdapterHistory(dwAdapter,BYTES_RECEIVED_UTIL));
        dwScale = nValue > dwScale ? nValue : dwScale;
    }

    lpdi->rcItem.left -= ulWidth;

    // Save the max value plotted
    //
    m_Adapter.SetScale(dwAdapter,dwScale);

    // Shift and display the graph
    //
    INT xDiff = 0; //(m_rcGraph.right - m_rcGraph.left) - (lpdi->rcItem.right - lpdi->rcItem.left);

    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            xDiff,
            0,
            SRCCOPY);
}

/*++

Routine Description:

    Updates the Network tab's listview 

Arguments:

    NONE

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
HRESULT CNetPage::UpdatePage()
{
    HRESULT hr = S_OK;
    LVITEM lvitem;
    INT iColumn = 0;
    DWORD dwItemCount;
    DWORD dwItem=0;
    ULONGLONG ull;
    DWORD dwAdapterCount = m_Adapter.GetNumberOfAdapters();

    dwItemCount = ListView_GetItemCount(m_hListView);

    // Add or update the list view items
    //
    for(DWORD dwAdapter = 0; dwAdapter < dwAdapterCount; dwAdapter++)
    {
        // Only show the requested stats
        //
        iColumn = 0;
        while (g_Options.m_ActiveNetCol[iColumn] >= 0)
        {
            // This buffer needs to hold a 20 digit number with commas and G, M K and sometime bs so it is big enough
            WCHAR szw[100];
            lvitem.mask     = LVIF_TEXT;
            lvitem.iSubItem = iColumn;
            lvitem.iItem    = dwItem;
            lvitem.pszText  = L"";
            lvitem.lParam   = (LPARAM)NULL; //&m_Adapter.m_pAdapterInfo[dwAdapter]; //dwAdapter; //NULL; //(LPARAM)pna;

            // Get the value
            //
            switch(g_Options.m_ActiveNetCol[iColumn])
            {
            case COL_ADAPTERNAME:
            case COL_ADAPTERDESC:
            case COL_STATE:
                lvitem.pszText = m_Adapter.GetAdapterText(dwAdapter,g_Options.m_ActiveNetCol[iColumn]);
                break;
            
            case COL_NETWORKUTIL:                    
            case COL_BYTESSENTTHRU:
            case COL_BYTESRECTHRU:
            case COL_BYTESTOTALTHRU:
                // This buffer needs to hold a 20 digit number with commas and G, M K and sometime bs so it is big enough
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                FloatToString( ull, szw, ARRAYSIZE(szw), FALSE );
                StringCchCat( szw, ARRAYSIZE(szw), L" " );
                StringCchCat( szw, ARRAYSIZE(szw), g_szPercent );
                lvitem.pszText = szw;
                break;

            case COL_LINKSPEED:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                SimplifyNumber( ull, szw, ARRAYSIZE(szw) );
                StringCchCat( szw, ARRAYSIZE(szw), g_szBitsPerSec );
                lvitem.pszText = szw;
                break;

            case COL_BYTESSENT:
            case COL_BYTESREC:
            case COL_BYTESTOTAL:
            case COL_BYTESSENTPERINTER:
            case COL_BYTESRECPERINTER:
            case COL_BYTESTOTALPERINTER:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                CommaNumber( ull, szw, ARRAYSIZE(szw) );
                lvitem.pszText = szw;
                break;

            case COL_UNICASTSSSENT:
            case COL_UNICASTSREC:
            case COL_UNICASTSTOTAL:
            case COL_UNICASTSSENTPERINTER:
            case COL_UNICASTSRECPERINTER:
            case COL_UNICASTSTOTALPERINTER:
            case COL_NONUNICASTSSSENT:
            case COL_NONUNICASTSREC:
            case COL_NONUNICASTSTOTAL:
            case COL_NONUNICASTSSENTPERINTER:
            case COL_NONUNICASTSRECPERINTER:
            case COL_NONUNICASTSTOTALPERINTER:
                ull = m_Adapter.GetAdapterStat(dwAdapter,g_Options.m_ActiveNetCol[iColumn],!g_Options.m_bNetShowAll);
                CommaNumber( ull, szw, ARRAYSIZE(szw) );
                lvitem.pszText = szw;
                break;
            }
            if( dwItem >= dwItemCount)
            {
                // The adapter is not in the listview, add it
                //
                lvitem.mask |= LVIF_PARAM;
                if( -1 == ListView_InsertItem(m_hListView, &lvitem) )
                {
                    return E_FAIL;
                }
                dwItemCount = ListView_GetItemCount(m_hListView);
            }
            else
            {
                // The adapter is already in the list view, update the value
                //
                ListView_SetItem(m_hListView, &lvitem);
            }
            iColumn++;                                      
        }
        dwItem++;
    }   
    return hr;
}

/*++

Routine Description:

    Collect the Adapter information and update the tab

Arguments:

Return Value:

    HRESULT

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::CalcNetTime(void)
{   
    BOOLEAN bAdapterListChange = FALSE;
    HRESULT hr;

    // Update our adapter list with the new stats
    //
    hr = m_Adapter.Update(bAdapterListChange);

    if( SUCCEEDED(hr) )
    {
        // Collect the adapter information
        //
        if( m_bReset )
        {
            // Reset the Adapter start values
            //
            m_Adapter.Reset();
            m_bReset = FALSE;
        }

        if( bAdapterListChange )
        {
            // Some adapters changed, update the graphs (create and delete graphs)
            //
            Refresh();
        }

        // Update the listview
        //
        UpdatePage();   
    } 
}

void CNetPage::Refresh()
{
    m_Adapter.RefreshConnectionNames();
    SizeNetPage();
    ListView_DeleteAllItems(m_hListView);
}

/*++

Routine Description:

    Handle the timer event

Arguments:

    NONE

Return Value:

    NONE

Revision History:

      1-6-2000  Created by omiller

--*/
void CNetPage::TimerEvent()
{
    // If the Network tab is not selected and the user does not want to waste cpu usage for the networking adapter history
    // do not do any of the Networking calculations.
    //
    if( m_bPageActive || g_Options.m_bTabAlwaysActive)
    {

        // This will make the graph scrolll
        //
        g_NetScrollamount+=2;
        g_NetScrollamount %= GRAPHPAPERSIZE;
    
        // Collect the Adapter information
        //
        CalcNetTime();

        // Check if window minimized
        //
        if (FALSE == IsIconic(g_hMainWnd))
        {       
            UpdateGraphs();
        }
    }
}

//
//
//
DWORD CNetPage::GetNumberOfGraphs()
{
    return m_dwGraphCount;
}

//
//
//
void CNetPage::ScrollGraphs(WPARAM wParam)
{
    SCROLLINFO si;

    si.cbSize = sizeof(SCROLLINFO);
    si.fMask = SIF_ALL;

    if( GetScrollInfo(m_hScrollBar,SB_CTL,&si) )
    {
        switch(LOWORD(wParam))
        {
        case SB_BOTTOM:
            si.nPos = si.nMax;
            break;

        case SB_TOP:
            si.nPos = si.nMin;
            break;

        case SB_LINEDOWN:
            si.nPos++;
            break;

        case SB_LINEUP:
            si.nPos--;
            break;

        case SB_PAGEUP:
            si.nPos -= m_dwGraphsPerPage;
            break;

        case SB_PAGEDOWN:
            si.nPos += m_dwGraphsPerPage;
            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            si.nPos = HIWORD(wParam);
            break;
        }

        if( si.nPos < si.nMin )
        {
            si.nPos = si.nMin;
        }
        else if( si.nPos > si.nMax )
        {
            si.nPos = si.nMax;
        }

        m_dwFirstVisibleAdapter = si.nPos;
        
        SetScrollPos(m_hScrollBar,SB_CTL,si.nPos,TRUE);
        LabelGraphs();
    }
}
    
    
/*++

Routine Description:

    Window Proc for the Networking tab

Arguments:

    hwnd -- handle to dialog box
    uMsg -- message
    wParam -- first message parameter
    lParam -- second message parameter


Return Value:

    NO IDEA

Revision History:

      1-6-2000  Created by omiller

--*/
INT_PTR CALLBACK NetPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                )
{

    CNetPage * thispage = (CNetPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);


    // See if the parent wants this message
    //
    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_SHOWWINDOW:
    case WM_SIZE:
        //
        // Size our kids
        //
        thispage->SizeNetPage();
        return TRUE;

    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            dwStyle |= WS_CLIPCHILDREN;
            SetWindowLong(hwnd, GWL_STYLE, dwStyle);
        }
        return TRUE;


    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        if (g_Options.m_fNoTitle)
        {
            SendMessage(g_hMainWnd,
                        uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN,
                        HTCAPTION,
                        lParam);
        }
        break;

    case WM_COMMAND :
        if( LOWORD(wParam) == IDM_NETRESET)
        {
            thispage->Reset();
        }
        break;

    case WM_DRAWITEM:
        //
        // Draw one of our owner draw controls
        //
        if (wParam >= IDC_NICGRAPH && wParam <= (WPARAM)(IDC_NICGRAPH + thispage->GetNumberOfGraphs()) )
        {
            thispage->DrawAdapterGraph( (LPDRAWITEMSTRUCT) lParam, (UINT)wParam - IDC_NICGRAPH);
            return TRUE;
        }
        break;

    case WM_DESTROY:
        thispage->RememberColumnOrder(GetDlgItem(hwnd, IDC_NICTOTALS));
        break;

    case WM_VSCROLL:
        thispage->ScrollGraphs(wParam);
        break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\grpconv\util.h ===
//---------------------------------------------------------------------------
//
//---------------------------------------------------------------------------

//---------------------------------------------------------------------------
// Returns TRUE if the string is unique.
typedef BOOL (CALLBACK *PFNISUNIQUE)(LPCTSTR lpsz, UINT nUser);
extern HWND g_hwndProgress;

//---------------------------------------------------------------------------
#define LOGGING

#ifdef LOGGING
void __cdecl _Log(LPCTSTR pszMsg, ...);
#define Log _Log
#else
#define Log 1 ? (void)0 : (void)
#endif

//---------------------------------------------------------------------------
#define Reg_SetStruct(hkey, pszSubKey, pszValue, pData, cbData) Reg_Set(hkey, pszSubKey, pszValue, REG_BINARY, pData, cbData)
#define Reg_SetString(hkey, pszSubKey, pszValue, pszString) Reg_Set(hkey, pszSubKey, pszValue, REG_SZ, (LPTSTR)pszString,(lstrlen(pszString)+1)* SIZEOF(TCHAR))
#define Reg_GetString(hkey, pszSubKey, pszValue, pszString, cbString) Reg_Get(hkey, pszSubKey, pszValue, pszString, cbString)
#define Reg_GetStruct(hkey, pszSubKey, pszValue, pData, cbData) Reg_Get(hkey, pszSubKey, pszValue, pData, cbData)

//---------------------------------------------------------------------------
void    Group_SetProgress(int i);
void    Group_SetProgressNameAndRange(LPCTSTR lpszGroup, int iMax);
void    Group_CreateProgressDlg(void);
void    Group_DestroyProgressDlg(void);
void    ConvertHashesToNulls(LPTSTR p);
int     MyMessageBox(HWND hwnd, UINT idTitle, UINT idMessage, LPCTSTR lpsz, UINT nStyle);
#ifdef UNICODE
LPTSTR  fgets(LPTSTR sz, DWORD cb, HANDLE fh);
#else
LPTSTR   fgets(LPTSTR sz, WORD cb, int fh);
#endif
void    ShellRegisterApp(LPCTSTR lpszExt, LPCTSTR lpszTypeKey, LPCTSTR lpszTypeValue, LPCTSTR lpszCommand, BOOL fOveride);
// BOOL         NEAR PASCAL WritePrivateProfileInt(LPCSTR lpszSection, LPCSTR lpszValue, int i, LPCSTR lpszIniFile);
void    Group_SetProgressDesc(UINT nID);

HRESULT ICoCreateInstance(REFCLSID rclsid, REFIID riid, LPVOID * ppv);
BOOL    WINAPI YetAnotherMakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName, PFNISUNIQUE pfnIsUnique, UINT n, BOOL fLFN);
BOOL    WINAPI MakeUniqueName(LPTSTR pszNewName, UINT cbNewName, LPCTSTR pszOldName, UINT nStart, PFNISUNIQUE pfnIsUnique, UINT nUser, BOOL fLFN);
BOOL    WINAPI Reg_SetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dw);
BOOL    WINAPI Reg_GetDWord(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPDWORD pdw);
BOOL    WINAPI Reg_Set(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, DWORD dwType, LPVOID pData, DWORD cbData);
BOOL    WINAPI Reg_Get(HKEY hkey, LPCTSTR pszSubKey, LPCTSTR pszValue, LPVOID pData, DWORD cbData);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\perfpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       perfpage.cpp
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define GRAPH_BRUSH         BLACK_BRUSH
#define GRAPH_LINE_COLOR    RGB(0, 128, 64)
#define GRAPH_TEXT_COLOR    RGB(0, 255, 0)

#define STRIP_HEIGHT        75
#define STRIP_WIDTH         33

LARGE_INTEGER       PreviousCPUIdleTime[MAXIMUM_PROCESSORS] = {0 ,0};
LARGE_INTEGER       PreviousCPUTotalTime[MAXIMUM_PROCESSORS] = {0 ,0};
LARGE_INTEGER       PreviousCPUKernelTime[MAXIMUM_PROCESSORS] = {0 ,0};

LPBYTE              g_pCPUHistory[MAXIMUM_PROCESSORS] = { NULL };
LPBYTE              g_pKernelHistory[MAXIMUM_PROCESSORS] = { NULL };
LPBYTE              g_pMEMHistory = NULL;

BYTE                g_CPUUsage = 0;
BYTE                g_KernelUsage = 0;
__int64             g_MEMUsage = 0;
__int64             g_MEMMax   = 0;

DWORD               g_PageSize;


/*++ CPerfPage::SizePerfPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.
  

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

static const INT aPerfControls[] =
{
    IDC_STATIC1,
    IDC_STATIC2,
    IDC_STATIC3,
    IDC_STATIC4,
    IDC_STATIC5,
    IDC_STATIC6,
    IDC_STATIC8,
    IDC_STATIC9,
    IDC_STATIC10,
    IDC_STATIC11,
    IDC_STATIC12,
    IDC_STATIC13,
    IDC_STATIC14,
    IDC_STATIC15,
    IDC_STATIC16,
    IDC_STATIC17,
    IDC_TOTAL_PHYSICAL,
    IDC_AVAIL_PHYSICAL,
    IDC_FILE_CACHE,
    IDC_COMMIT_TOTAL,
    IDC_COMMIT_LIMIT,
    IDC_COMMIT_PEAK,
    IDC_KERNEL_TOTAL,
    IDC_KERNEL_PAGED,
    IDC_KERNEL_NONPAGED,
    IDC_TOTAL_HANDLES,
    IDC_TOTAL_THREADS,
    IDC_TOTAL_PROCESSES,
};

// Amount of spacing down from the top of a group box to the
// control it contains

void CPerfPage::SizePerfPage()
{
    // Get the coords of the tab control

    RECT rcParent;

    if (g_Options.m_fNoTitle)
    {
        GetClientRect(g_hMainWnd, &rcParent);
    }
    else
    {
        GetClientRect(m_hwndTabs, &rcParent);
        MapWindowPoints(m_hwndTabs, m_hPage, (LPPOINT) &rcParent, 2);
        TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);
    }

    // We have N panes, where N is 1 or g_cProcessors depending on what mode the
    // cpu meter is currently in

    INT  cPanes = (CM_PANES == g_Options.m_cmHistMode) ? g_cProcessors : 1;

    HDWP hdwp = BeginDeferWindowPos( 7 + ARRAYSIZE(aPerfControls) + cPanes );
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDC_STATIC5);
    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    // Move each of the child controls by the above delta

    for (int i = 0; i < ARRAYSIZE(aPerfControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aPerfControls[i]);
        RECT rcCtrl;
        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL,
                         rcCtrl.left,
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    HWND hwndTopFrame = GetDlgItem(m_hPage, IDC_STATIC13);
    RECT rcTopFrame;
    GetWindowRect(hwndTopFrame, &rcTopFrame);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcTopFrame, 2);
    INT yTop = rcTopFrame.top + dy;

    INT yHist;
    if (g_Options.m_fNoTitle)
    {
        yHist = rcParent.bottom - rcParent.top - g_DefSpacing * 2;
    }
    else
    {
        yHist = (yTop - g_DefSpacing * 3) / 2;
    }

    // Size the CPU history frame

    RECT rcFrame;
    HWND hwndFrame = GetDlgItem(m_hPage, IDC_CPUFRAME);
    GetWindowRect(hwndFrame, &rcFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcFrame, 2);

    DeferWindowPos(hdwp, hwndFrame, NULL, 0, 0,
                     (rcParent.right - rcFrame.left) - g_DefSpacing * 2,
                     yHist,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the CPU bar graph frame


    RECT rcCPUFrame;
    HWND hwndCPUFrame = GetDlgItem(m_hPage, IDC_STATIC);
    GetWindowRect(hwndCPUFrame, &rcCPUFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcCPUFrame, 2);

    DeferWindowPos(hdwp, hwndCPUFrame, NULL, 0, 0,
                     (rcCPUFrame.right - rcCPUFrame.left),
                     yHist,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    RECT rcCPUBAR;
    HWND hwndCPUBAR = GetDlgItem(m_hPage, IDC_CPUMETER);
    GetWindowRect(hwndCPUBAR, &rcCPUBAR);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcCPUBAR, 2);

    DeferWindowPos(hdwp, hwndCPUBAR, NULL, rcCPUFrame.left + g_InnerSpacing * 2, rcCPUFrame.top + g_TopSpacing,
                     (rcCPUBAR.right - rcCPUBAR.left),
                     yHist - g_TopSpacing - g_InnerSpacing * 2 ,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the mem bar graph frame


    RECT rcMEMFrame;
    HWND hwndMEMFrame = GetDlgItem(m_hPage, IDC_MEMBARFRAME);
    GetWindowRect(hwndMEMFrame, &rcMEMFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMEMFrame, 2);

    DeferWindowPos(hdwp, hwndMEMFrame, NULL, rcMEMFrame.left, yHist + g_DefSpacing * 2,
                     (rcMEMFrame.right - rcMEMFrame.left),
                     yHist,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    RECT rcMEMBAR;
    HWND hwndMEMBAR = GetDlgItem(m_hPage, IDC_MEMMETER);
    GetWindowRect(hwndMEMBAR, &rcMEMBAR);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMEMBAR, 2);

    DeferWindowPos(hdwp, hwndMEMBAR, NULL, rcMEMBAR.left, yHist + g_DefSpacing * 2 + g_TopSpacing,
                     (rcMEMBAR.right - rcMEMBAR.left),
                     yHist - g_InnerSpacing * 2  - g_TopSpacing,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Size the Memory history frame

    RECT rcMemFrame;
    HWND hwndMemFrame = GetDlgItem(m_hPage, IDC_MEMFRAME);
    GetWindowRect(hwndMemFrame, &rcMemFrame);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcMemFrame, 2);

    DeferWindowPos(hdwp, hwndMemFrame, NULL, rcMemFrame.left, yHist + g_DefSpacing * 2,
                     (rcParent.right - rcMemFrame.left) - g_DefSpacing * 2,
                     yHist,
                     SWP_NOZORDER | SWP_NOACTIVATE);


    // Total amount of room available for all of the panes

    INT   Width = (rcParent.right - rcParent.left) - (rcFrame.left - rcParent.left) - g_DefSpacing * 2
                  - g_InnerSpacing * 3;

    // Use this width to size the memory graph

    HWND hwndButton = GetDlgItem(m_hPage, IDC_MEMGRAPH);
    RECT rcButton;
    GetWindowRect(hwndButton, &rcButton);
    MapWindowPoints(NULL, m_hPage, (LPPOINT) &rcButton, 2);

    DeferWindowPos(hdwp, hwndButton, NULL, rcFrame.left + g_InnerSpacing * 2,
                     yHist + g_DefSpacing * 2 + g_TopSpacing,
                     Width - g_InnerSpacing,
                     yHist - g_InnerSpacing * 2  - g_TopSpacing,
                     SWP_NOZORDER | SWP_NOACTIVATE);

    // Total amount of room available for each CPU pane

    Width -= ( cPanes < 16 ? cPanes : 16 ) * g_InnerSpacing;
    Width /= ( cPanes < 16 ? cPanes : 16 );
    Width = Width >= 0 ? Width : 0;

    INT Height = ( yHist - g_InnerSpacing * 2 - g_TopSpacing ) / ( ( cPanes % 16 != 0 ? 1 : 0 ) + ( cPanes / 16 ) );

    for (i = 0; i < cPanes; i++)
    {
        HWND hwnd = GetDlgItem(m_hPage, IDC_CPUGRAPH + i);

        if ( NULL != hwnd )
        {
            INT left = rcFrame.left + g_InnerSpacing * ( ( i % 16 ) + 2) + Width * ( i % 16 );
            INT top = rcFrame.top + g_TopSpacing + Height * ( i / 16 );

            DeferWindowPos( hdwp, hwnd, NULL, left, top, Width, Height, 0 );
        }
    }

    // Create new bitmaps to be used in the history windows

    EndDeferWindowPos(hdwp);

    GetClientRect(hwndButton, &rcButton);
    FreeMemoryBitmaps();        // Free any old ones
    CreateMemoryBitmaps(rcButton.right - rcButton.left, rcButton.bottom - rcButton.top);
}

/*++ CPerfPage::CreatePens

Routine Description:

    Creates 8 different colors pens, saves them in
    the pen array

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

static const COLORREF aColors[] =
{
    RGB(000, 255, 000),
    RGB(255, 000, 000),
    RGB(255, 000, 255),
    RGB(000, 000, 255),
    RGB(000, 255, 255),
    RGB(255, 128, 000),
    RGB(255, 000, 255),
    RGB(000, 128, 255),

    // End of CPU pens

#define MEM_PEN 8

    RGB(255, 255, 0),

};

//
//
//
void CPerfPage::CreatePens()
{
    for (int i = 0; i < ARRAYSIZE(aColors); i++)
    {
        // Create then pen.  If a failure occurs, just substitute
        // the white pen

        m_hPens[i] = CreatePen(PS_SOLID, 1, aColors[i]);
        if (NULL == m_hPens[i])
        {
            m_hPens[i] = (HPEN) GetStockObject(WHITE_PEN);
        }
    }
}

//
//
//
void CPerfPage::ReleasePens()
{
    for (int i = 0; i < NUM_PENS; i++)
    {
        if (m_hPens[i])
        {
            DeleteObject(m_hPens[i]);
        }
    }
}

/*++ CPerfPage::DrawGraphPaper

Routine Description:

    Draws a graph-paper-like grid into a memory bitmap

Arguments:

    hdcGraph    - HDC to draw into
    prcGraph    - RECT describing area to draw
    Width       - Amount, on right side, to actually draw

Revision History:

      Jan-17-95 Davepl  Created

--*/

static int g_Scrollamount = 0;

void DrawGraphPaper(HDC hdcGraph, RECT * prcGraph, int Width)
{
    #define GRAPHPAPERSIZE 12

    int Leftside = prcGraph->right - Width;

    // Only one of the many graphs needs to ask us to scroll

    HPEN hPen = CreatePen(PS_SOLID, 1, GRAPH_LINE_COLOR);

    HGDIOBJ hOld = SelectObject(hdcGraph, hPen);

    for (int i = GRAPHPAPERSIZE - 1; i < prcGraph->bottom - prcGraph->top; i+= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 Leftside,
                 i + prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               prcGraph->right,
               i + prcGraph->top);
    }

    for (i = prcGraph->right - g_Scrollamount; i > Leftside; i -= GRAPHPAPERSIZE)
    {
        MoveToEx(hdcGraph,
                 i,
                 prcGraph->top,
                 (LPPOINT) NULL);

        LineTo(hdcGraph,
               i,
               prcGraph->bottom);
    }

    if (hOld)
    {
        SelectObject(hdcGraph, hOld);
    }

    DeleteObject(hPen);
}

/*++ CPerfPage::DrawCPUGraph

Routine Description:

    Draws the CPU graph (which is an ownerdraw control)

Arguments:

    lpdi    - LPDRAWITEMSTRUCT describing area we need to paint
    iPane   - Pane number to be drawn (ie: which CPU)

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::DrawCPUGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane)
{
    #define THISCPU 0

    if (NULL == m_hdcGraph)
    {
        return;
    }

    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(GRAPH_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;
    int Scale = (Width - 1) / HIST_SIZE;

    if (0 == Scale)
    {
        Scale = 2;
    }

    //
    // Draw the CPU history graph
    //

    DrawGraphPaper(m_hdcGraph, &m_rcGraph, Width);

    INT  cPanes = (CM_PANES == g_Options.m_cmHistMode) ? g_cProcessors : 1;
    int GraphHeight = ( m_rcGraph.bottom - m_rcGraph.top - 1 ) / ( ( cPanes % 16 != 0 ? 1 : 0 ) + ( cPanes / 16 ) );;

    if (g_Options.m_cmHistMode == CM_PANES)
    {
        //
        // Draw the kernel times
        //

        if (g_Options.m_fKernelTimes)
        {
            HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[1]);

            MoveToEx(m_hdcGraph,
                     m_rcGraph.right,
                     GraphHeight - (g_pKernelHistory[iPane][0] * GraphHeight) / 100,
                     (LPPOINT) NULL);

            for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
            {
                LineTo(m_hdcGraph,
                       m_rcGraph.right - Scale * i,
                       GraphHeight - (g_pKernelHistory[iPane][i] * GraphHeight) / 100);
            }

            if (hOld)
            {
                SelectObject(m_hdcGraph, hOld);
            }
        }

        //
        // Draw a particular CPU in its pane
        //

        HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[0]);

        MoveToEx(m_hdcGraph,
                 m_rcGraph.right,
                 GraphHeight - (g_pCPUHistory[iPane][0] * GraphHeight) / 100,
                 (LPPOINT) NULL);

        for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
        {
            LineTo(m_hdcGraph,
                   m_rcGraph.right - Scale * i,
                   GraphHeight - (g_pCPUHistory[iPane][i] * GraphHeight) / 100);
        }

        if (hOld)
        {
            SelectObject(m_hdcGraph, hOld);
        }
    }
    else
    {
        ASSERT(iPane == 0);

        //
        // Draw the kernel times
        //

        if (g_Options.m_fKernelTimes)
        {
            HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[1]);

            DWORD dwSum = 0;

            for (int iCPU = 0; iCPU < g_cProcessors; iCPU++)
            {
                dwSum += g_pKernelHistory[iCPU][0];
            }

            dwSum /= g_cProcessors;

            MoveToEx(m_hdcGraph,
                     m_rcGraph.right,
                     GraphHeight - (dwSum * GraphHeight) / 100,
                     (LPPOINT) NULL);

            for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
            {
                dwSum = 0;

                for (iCPU = 0; iCPU < g_cProcessors; iCPU++)
                {
                    dwSum += g_pKernelHistory[iCPU][i];
                }

                dwSum /= g_cProcessors;

                LineTo(m_hdcGraph,
                       m_rcGraph.right - Scale * i,
                       GraphHeight - (dwSum * GraphHeight) / 100);
            }

            if (hOld)
            {
                SelectObject(m_hdcGraph, hOld);
            }
        }

        //
        // Draw History as a sum of all CPUs
        //

        HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[0]);

        DWORD dwSum = 0;

        for (int iCPU = 0; iCPU < g_cProcessors; iCPU++)
        {
            dwSum += g_pCPUHistory[iCPU][0];
        }

        dwSum /= g_cProcessors;

        MoveToEx(m_hdcGraph,
                 m_rcGraph.right,
                 GraphHeight - (dwSum * GraphHeight) / 100,
                 (LPPOINT) NULL);

        for (int i = 0; i < HIST_SIZE && i * Scale < Width; i++)
        {
            dwSum = 0;

            for (iCPU = 0; iCPU < g_cProcessors; iCPU++)
            {
                dwSum += g_pCPUHistory[iCPU][i];
            }

            dwSum /= g_cProcessors;

            LineTo(m_hdcGraph,
                   m_rcGraph.right - Scale * i,
                   GraphHeight - (dwSum * GraphHeight) / 100);
        }

        if (hOld)
        {
            SelectObject(m_hdcGraph, hOld);
        }
    }

    //
    // Memory bitmap could be wider than the target control, so find a delta
    //

    INT xDiff = (m_rcGraph.right - m_rcGraph.left) - (lpdi->rcItem.right - lpdi->rcItem.left);

    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            xDiff,
            0,
            SRCCOPY);
}

/*++ CPerfPage::DrawMEMGraph

Routine Description:

    Draws the Memory history graph (which is an ownerdraw control)

Arguments:

    lpdi - LPDRAWITEMSTRUCT describing area we need to paint

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::DrawMEMGraph(LPDRAWITEMSTRUCT lpdi)
{
    #define THISCPU 0

    if (NULL == m_hdcGraph)
    {
        return;
    }

    FillRect(m_hdcGraph, &m_rcGraph, (HBRUSH) GetStockObject(GRAPH_BRUSH));

    int Width = lpdi->rcItem.right - lpdi->rcItem.left;

    DrawGraphPaper(m_hdcGraph, &m_rcGraph, Width);

    int Scale = (Width - 1) / HIST_SIZE;
    if (0 == Scale)
    {
        Scale = 2;
    }

    int GraphHeight = m_rcGraph.bottom - m_rcGraph.top - 1;

    HGDIOBJ hOld = SelectObject(m_hdcGraph, m_hPens[MEM_PEN]);

    MoveToEx(m_hdcGraph,
             m_rcGraph.right,
             m_rcGraph.bottom - (g_pMEMHistory[0] * GraphHeight) / 100,
             (LPPOINT) NULL);

    for (int i = 0; i < HIST_SIZE && i * Scale < Width - 1; i++)
    {
        if (0 == g_pMEMHistory[i])
        {
            break;  // End of Data
        }

        LineTo(m_hdcGraph,
               m_rcGraph.right - Scale * i,
               m_rcGraph.bottom - (g_pMEMHistory[i] * GraphHeight) / 100);
    }

    BitBlt( lpdi->hDC,
            lpdi->rcItem.left,
            lpdi->rcItem.top,
            lpdi->rcItem.right - lpdi->rcItem.left,
            lpdi->rcItem.bottom - lpdi->rcItem.top,
            m_hdcGraph,
            0,
            0,
            SRCCOPY);

    if (hOld)
    {
        SelectObject(m_hdcGraph, hOld);
    }
}

/*++ CPerfPage::UpdateGraphs

Routine Description:

    Adds and removed CPU panes as required

Arguments:

    none

Return Value:

    none

Revision History:

    Dec-16-96   Davepl  Create

***/

void CPerfPage::UpdateGraphs()
{
    UINT i;

    for ( i = 0; i < g_cProcessors; i ++ )
    {
        //
        //  Make sure we have enough windows to show all the processors
        //

        HWND hwnd = GetDlgItem( m_hPage, IDC_CPUGRAPH + i );
        if ( NULL == hwnd )
        {
            hwnd = CreateWindowEx( WS_EX_CLIENTEDGE
                                 , L"BUTTON"
                                 , L""
                                 , BS_OWNERDRAW | WS_DISABLED | WS_CHILD
                                 , 0
                                 , 0
                                 , 1
                                 , 1
                                 , m_hPage
                                 , (HMENU) ((ULONGLONG)IDC_CPUGRAPH + i)
                                 , NULL // ignored
                                 , NULL
                                 );
        }

        if ( NULL != hwnd && 0 != i )
        {
            //  Show/hide the window depending on the mode
            ShowWindow( hwnd, CM_PANES == g_Options.m_cmHistMode ? SW_SHOW : SW_HIDE );
        }
    }

    //
    // Hide/show everything but the CPU meters when we're in notitle/title mode
    //

    for (i = 0; i < ARRAYSIZE(aPerfControls); i++)
    {
        ShowWindow(GetDlgItem(m_hPage, aPerfControls[i]), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    }

    ShowWindow(GetDlgItem(m_hPage, IDC_MEMGRAPH), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMFRAME), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMBARFRAME), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);
    ShowWindow(GetDlgItem(m_hPage, IDC_MEMMETER), g_Options.m_fNoTitle ? SW_HIDE : SW_SHOW);

    SizePerfPage();
}

/*++ CPerfPage::DrawCPUDigits

Routine Description:

    Draws the CPU meter and digits

Arguments:

    lpdi - LPDRAWITEMSTRUCT describing area we need to paint

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

int GetCurFontSize(HDC hdc)
{
    int iRet = 0;
    LOGFONT lf;
    HFONT hf = (HFONT) GetCurrentObject(hdc, OBJ_FONT);
    if (hf)
    {
        if (GetObject(hf, sizeof(LOGFONT), &lf))
        {
            iRet = lf.lfHeight;
            if (iRet < 0)
            {
                iRet = (-iRet);
            }
        }
    }
    return iRet;
}

//
//
//
void CPerfPage::DrawCPUDigits(LPDRAWITEMSTRUCT lpdi)
{
    HBRUSH hBlack = (HBRUSH) GetStockObject(BLACK_BRUSH);
    HGDIOBJ hOld = SelectObject(lpdi->hDC, hBlack);
    Rectangle(lpdi->hDC, lpdi->rcItem.left, lpdi->rcItem.top, lpdi->rcItem.right, lpdi->rcItem.bottom);

    //
    // Draw the digits into the ownder draw control
    //

    INT xBarOffset = ((lpdi->rcItem.right - lpdi->rcItem.left) - STRIP_WIDTH) / 2;

    RECT rcBar;
    GetWindowRect(GetDlgItem(m_hPage, IDC_MEMMETER), &rcBar);
    INT cBarHeight = lpdi->rcItem.bottom - lpdi->rcItem.top - (GetCurFontSize(lpdi->hDC) + g_DefSpacing * 3);
    if (cBarHeight <= 0)
    {
        return;
    }

    INT ctmpBarLitPixels = (g_CPUUsage * cBarHeight) / 100;
    INT ctmpBarRedPixels = g_Options.m_fKernelTimes ? ctmpBarRedPixels = (g_KernelUsage * cBarHeight) / 100 : 0;

    INT cBarUnLitPixels = cBarHeight - ctmpBarLitPixels;
        cBarUnLitPixels = (cBarUnLitPixels / 3) * 3;

    INT cBarLitPixels = cBarHeight - cBarUnLitPixels;
    INT cBarRedPixels = ctmpBarRedPixels;

    SetBkMode(lpdi->hDC, TRANSPARENT);
    SetTextColor(lpdi->hDC, GRAPH_TEXT_COLOR);

    WCHAR szBuf[8];
    StringCchPrintf( szBuf, ARRAYSIZE(szBuf), L"%d %%", g_CPUUsage);    // don't care if it truncates - UI only

    RECT rcOut = lpdi->rcItem;
    rcOut.bottom -= 4;
    DrawText(lpdi->hDC, szBuf, -1, &rcOut, DT_SINGLELINE | DT_CENTER | DT_BOTTOM);

    HDC hdcMem = CreateCompatibleDC(lpdi->hDC);
    if (hdcMem)
    {
        //
        // Draw the CPU meter
        //

        //
        // Draw unlit portion
        //

        if (cBarHeight != cBarLitPixels)
        {
            INT cUnlit = cBarHeight - cBarLitPixels;
            INT cOffset = 0;
            HGDIOBJ hOldObj = SelectObject(hdcMem, m_hStripUnlit);

            while (cUnlit > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + cOffset,
                                  STRIP_WIDTH, min(cUnlit, STRIP_HEIGHT),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cUnlit, STRIP_HEIGHT);
                cUnlit -= min(cUnlit, STRIP_HEIGHT);
            }

            if ( NULL != hOldObj )
            {
                SelectObject( hdcMem, hOldObj );
            }
        }

        //
        // Draw lit portion
        //

        if (0 != cBarLitPixels)
        {
            HGDIOBJ hOldObj = SelectObject(hdcMem, m_hStripLit);
            INT cOffset = 0;
            INT cLit = cBarLitPixels - cBarRedPixels;

            while (cLit > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarLitPixels) + cOffset,
                                  STRIP_WIDTH, min(STRIP_HEIGHT, cLit),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cLit, STRIP_HEIGHT);
                cLit -= min(cLit, STRIP_HEIGHT);
            }
            
            if ( NULL != hOldObj )
            {
                SelectObject( hdcMem, hOldObj );
            }
        }

        if (0 != cBarRedPixels)
        {
            HGDIOBJ hOldObj = SelectObject(hdcMem, m_hStripLitRed);
            INT cOffset = 0;
            INT cRed = cBarRedPixels;

            while (cRed > 0)
            {
                BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarRedPixels) + cOffset,
                                  STRIP_WIDTH, min(cRed, STRIP_HEIGHT),
                                  hdcMem,
                                  0, 0, SRCCOPY);
                cOffset += min(cRed, STRIP_HEIGHT);
                cRed -= min(cRed, STRIP_HEIGHT);
            }

            if ( NULL != hOldObj )
            {
                SelectObject( hdcMem, hOldObj );
            }
        }

        DeleteDC(hdcMem);
    }

    SelectObject(lpdi->hDC, hOld);
}

// CPerfPage::DrawMEMMeter
//
// Draws the memory meter

void CPerfPage::DrawMEMMeter(LPDRAWITEMSTRUCT lpdi)
{
    HBRUSH hBlack = (HBRUSH) GetStockObject(BLACK_BRUSH);
    HGDIOBJ hOld = SelectObject(lpdi->hDC, hBlack);
    Rectangle(lpdi->hDC, lpdi->rcItem.left, lpdi->rcItem.top, lpdi->rcItem.right, lpdi->rcItem.bottom);

    INT xBarOffset = ((lpdi->rcItem.right - lpdi->rcItem.left) - STRIP_WIDTH) / 2;

    SetBkMode(lpdi->hDC, TRANSPARENT);
    SetTextColor(lpdi->hDC, GRAPH_TEXT_COLOR);

    WCHAR szBuf[32];
    StrFormatByteSize64( g_MEMUsage * 1024, szBuf, ARRAYSIZE(szBuf) );
    RECT rcOut = lpdi->rcItem;
    rcOut.bottom -= 4;
    DrawText(lpdi->hDC, szBuf, -1, &rcOut, DT_SINGLELINE | DT_CENTER | DT_BOTTOM);

    HDC hdcMem = CreateCompatibleDC(lpdi->hDC);
    if (hdcMem)
    {
        //
        // Draw the CPU meter
        //

        //
        // Draw unlit portion
        //

        INT cBarHeight = lpdi->rcItem.bottom - lpdi->rcItem.top - (GetCurFontSize(lpdi->hDC) + g_DefSpacing * 3);

        if (cBarHeight > 0)
        {
            INT cBarLitPixels = (INT)(( g_MEMUsage * cBarHeight ) / g_MEMMax);
            cBarLitPixels = (cBarLitPixels / 3) * 3;

            if (cBarHeight != cBarLitPixels)
            {
                HGDIOBJ hOldObj = SelectObject(hdcMem, m_hStripUnlit);
                INT cUnlit = cBarHeight - cBarLitPixels;
                INT cOffset = 0;

                while (cUnlit > 0)
                {
                    BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + cOffset,
                                      STRIP_WIDTH, min(cUnlit, STRIP_HEIGHT),
                                      hdcMem,
                                      0, 0, SRCCOPY);
                    cOffset += min(cUnlit, STRIP_HEIGHT);
                    cUnlit  -= min(cUnlit, STRIP_HEIGHT);
                }

                if ( NULL != hOldObj )
                {
                    SelectObject( hdcMem, hOldObj );
                }
            }

            //
            // Draw lit portion
            //

            if (0 != cBarLitPixels)
            {
                HGDIOBJ hOldObj = SelectObject(hdcMem, m_hStripLit);
                INT cOffset = 0;
                INT cLit    = cBarLitPixels;

                while (cLit > 0)
                {
                    BitBlt(lpdi->hDC, xBarOffset, g_DefSpacing + (cBarHeight - cBarLitPixels) + cOffset,
                                      STRIP_WIDTH, min(STRIP_HEIGHT, cLit),
                                      hdcMem,
                                      0, 0, SRCCOPY);
                    cOffset += min(cLit, STRIP_HEIGHT);
                    cLit    -= min(cLit, STRIP_HEIGHT);
                }

                if ( NULL != hOldObj )
                {
                    SelectObject( hdcMem, hOldObj );
                }
            }
        }

        DeleteDC(hdcMem);
    }

    SelectObject(lpdi->hDC, hOld);
}

/*++ CPerfPage::TimerEvent

Routine Description:

    Called by main app when the update time fires

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::TimerEvent()
{
    CalcCpuTime(TRUE);

    g_Scrollamount+=2;
    g_Scrollamount %= GRAPHPAPERSIZE;

    //
    // Force the displays to update
    //

    if (FALSE == IsIconic(g_hMainWnd))
    {
        InvalidateRect(GetDlgItem(m_hPage, IDC_CPUMETER), NULL, FALSE);
        UpdateWindow(GetDlgItem(m_hPage, IDC_CPUMETER));
        InvalidateRect(GetDlgItem(m_hPage, IDC_MEMMETER), NULL, FALSE);
        UpdateWindow(GetDlgItem(m_hPage, IDC_MEMMETER));

        UINT cPanes = ( CM_PANES == g_Options.m_cmHistMode ? g_cProcessors : 1);
        for (UINT i = 0; i < cPanes; i ++)
        {
            HWND hwnd = GetDlgItem(m_hPage, IDC_CPUGRAPH + i);
            if ( NULL != hwnd )
            {
                InvalidateRect(hwnd, NULL, FALSE);
                UpdateWindow(hwnd);
            }
        }
                        
        InvalidateRect(GetDlgItem(m_hPage, IDC_MEMGRAPH), NULL, FALSE);
        UpdateWindow(GetDlgItem(m_hPage, IDC_MEMGRAPH));
    }
}

/*++ PerfPageProc

Routine Description:

    Dialogproc for the performance page.

Arguments:

    hwnd   	- handle to dialog box
    uMsg	- message
    wParam	- first message parameter
    lParam 	- second message parameter

Return Value:

    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-12-95 Davepl  Created

--*/

INT_PTR CALLBACK PerfPageProc(
                HWND        hwnd,   	        // handle to dialog box
                UINT        uMsg,	            // message
                WPARAM      wParam,	            // first message parameter
                LPARAM      lParam 	            // second message parameter
                )
{
    CPerfPage * thispage = (CPerfPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    //
    // See if the parent wants this message
    //

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);

            DWORD dwStyle = GetWindowLong(hwnd, GWL_STYLE);
            dwStyle |= WS_CLIPCHILDREN;
            SetWindowLong(hwnd, GWL_STYLE, dwStyle);

            if (IS_WINDOW_RTL_MIRRORED(hwnd))
            {
                HWND hItem;
                LONG lExtStyle;

                hItem = GetDlgItem(hwnd,IDC_CPUMETER);
                lExtStyle = GetWindowLong(hItem,GWL_EXSTYLE);
                SetWindowLong(hItem,GWL_EXSTYLE, lExtStyle & ~(RTL_MIRRORED_WINDOW | RTL_NOINHERITLAYOUT));
                hItem = GetDlgItem(hwnd,IDC_MEMMETER);
                lExtStyle = GetWindowLong(hItem,GWL_EXSTYLE);
                SetWindowLong(hItem,GWL_EXSTYLE, lExtStyle & ~(dwExStyleRTLMirrorWnd | dwExStyleNoInheritLayout));
            }
        }
        // We handle focus during Activate(). Return FALSE here so the
        // dialog manager doesn't try to set focus.
        return FALSE;


    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        //
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        //
        if (g_Options.m_fNoTitle)
        {
            SendMessage(g_hMainWnd,
                        uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN,
                        HTCAPTION,
                        lParam);
        }
        break;

    case WM_NCLBUTTONDBLCLK:
    case WM_LBUTTONDBLCLK:
        SendMessage(g_hMainWnd, uMsg, wParam, lParam);
        break;

    case WM_CTLCOLORBTN:
        {
            const static int rgGraphs[] =
            {
                IDC_MEMGRAPH,
                IDC_MEMMETER,
                IDC_CPUMETER
            };

            int uCtlId = GetDlgCtrlID((HWND)lParam);

            for (int i = 0; i < ARRAYSIZE(rgGraphs); i++)
            {
                if ( uCtlId == rgGraphs[i] )
                {
                    return (INT_PTR) GetStockObject(GRAPH_BRUSH);
                }
            }
        
            // All CPU graphs should use the GRAPH_BRUSH

            if ( uCtlId >= IDC_CPUGRAPH && uCtlId <= IDC_CPUGRAPH + g_cProcessors )
            {
                return (INT_PTR) GetStockObject(GRAPH_BRUSH);
            }
        }
        break;

    case WM_SIZE:
        //
        // Size our kids
        //
        thispage->SizePerfPage();
        return FALSE;

    case WM_DRAWITEM:
        //
        // Draw one of our owner draw controls
        //
        if (wParam >= IDC_CPUGRAPH && wParam <= (WPARAM)(IDC_CPUGRAPH + g_cProcessors) )
        {
            thispage->DrawCPUGraph( (LPDRAWITEMSTRUCT) lParam, (UINT)wParam - IDC_CPUGRAPH);
            return TRUE;
        }
        else if (IDC_CPUMETER == wParam)
        {
            thispage->DrawCPUDigits( (LPDRAWITEMSTRUCT) lParam);
            return TRUE;
        }
        else if (IDC_MEMMETER == wParam)
        {
            thispage->DrawMEMMeter( (LPDRAWITEMSTRUCT) lParam);
            return TRUE;
        }
        else if (IDC_MEMGRAPH == wParam)
        {
            thispage->DrawMEMGraph( (LPDRAWITEMSTRUCT) lParam);
            return TRUE;
        }
        break;
    }

    return FALSE;
}

/*++ CPerfPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer

Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_PERFPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CPerfPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it

Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Activate()
{
    // Adjust the size and position of our dialog relative
    // to the tab control which "owns" us

    RECT rcParent;
    GetClientRect(m_hwndTabs, &rcParent);
    MapWindowPoints(m_hwndTabs, g_hMainWnd, (LPPOINT) &rcParent, 2);
    TabCtrl_AdjustRect(m_hwndTabs, FALSE, &rcParent);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 rcParent.left, rcParent.top,
                 rcParent.right - rcParent.left, rcParent.bottom - rcParent.top,
                 0);

    //
    // Make this page visible
    //

    ShowWindow(m_hPage, SW_SHOW);

    //
    // Make the CPU graphs visible or invisible depending on its current mode
    //

    UpdateGraphs();

    //
    // Change the menu bar to be the menu for this page
    //

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_PERF));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // There are no tabstops on this page, but we have to set focus somewhere.
    // If we don't, it may stay on the previous page, now hidden, which can
    // confuse the dialog manager and may cause us to hang.
    SetFocus(m_hwndTabs);

    return S_OK;
}

/*++ CPerfPage::Initialize

Routine Description:

    Loads the resources we need for this page, creates the inmemory DCs
    and bitmaps for the charts, and creates the actual window (a dialog)
    that represents this page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Initialize(HWND hwndParent)
{
    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    //
    // Create the color pens
    //

    CreatePens();

    m_hStripLit = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_LIT),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    m_hStripLitRed = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_LIT_RED),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    m_hStripUnlit = (HBITMAP) LoadImage(g_hInstance, MAKEINTRESOURCE(LED_STRIP_UNLIT),
                                     IMAGE_BITMAP,
                                     0, 0,
                                     LR_DEFAULTCOLOR);

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,	                // handle to application instance
                    MAKEINTRESOURCE(IDD_PERFPAGE),	// identifies dialog box template name
                    g_hMainWnd,	                    // handle to owner window
                    PerfPageProc,        	// pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }

    return S_OK;
}

/*++ CPerfPage::CreateMemoryBitmaps

Routine Description:

    Creates the inmemory bitmaps used to draw the history graphics

Arguments:

    x, y    - size of bitmap to create

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::CreateMemoryBitmaps(int x, int y)
{
    //
    // Create the inmemory bitmaps and DCs that we will use
    //

    HDC hdcPage = GetDC(m_hPage);
    m_hdcGraph = CreateCompatibleDC(hdcPage);

    if (NULL == m_hdcGraph)
    {
        ReleaseDC(m_hPage, hdcPage);
        return GetLastHRESULT();
    }

    m_rcGraph.left   = 0;
    m_rcGraph.top    = 0;
    m_rcGraph.right  = x;
    m_rcGraph.bottom = y;

    m_hbmpGraph = CreateCompatibleBitmap(hdcPage, x, y);
    ReleaseDC(m_hPage, hdcPage);
    if (NULL == m_hbmpGraph)
    {
        HRESULT hr = GetLastHRESULT();
        DeleteDC(m_hdcGraph);
        m_hdcGraph = NULL;
        return hr;
    }

    // Select the bitmap into the DC

    m_hObjOld = SelectObject(m_hdcGraph, m_hbmpGraph);

    return S_OK;
}

/*++ CPerfPage::FreeMemoryBitmaps

Routine Description:

    Frees the inmemory bitmaps used to drag the history graphs

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

void CPerfPage::FreeMemoryBitmaps()
{
    if (m_hdcGraph)
    {
        if (m_hObjOld)
        {
           SelectObject(m_hdcGraph, m_hObjOld);
        }

        DeleteDC(m_hdcGraph);
    }

    if (m_hbmpGraph)
    {
        DeleteObject(m_hbmpGraph);
    }

}

/*++ CPerfPage::Deactivate

Routine Description:

    Called when this page is losing its place up front

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CPerfPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}

/*++ CPerfPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call

Arguments:

Return Value:

Revision History:

      Nov-12-95 Davepl  Created

--*/

HRESULT CPerfPage::Destroy()
{
    //
    // When we are being destroyed, kill off our dialog
    //

    ReleasePens();

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_hStripLit)
    {
        DeleteObject(m_hStripLit);
        m_hStripLit = NULL;
    }

    if (m_hStripUnlit)
    {
        DeleteObject(m_hStripUnlit);
        m_hStripUnlit = NULL;
    }

    if (m_hStripLitRed)
    {
        DeleteObject(m_hStripLitRed);
        m_hStripLitRed = NULL;
    }

    FreeMemoryBitmaps( );

    return S_OK;
}


/*++

Routine Description:

    Initialize data for perf measurements

Arguments:

    None

Return Value:

    Number of system processors (0 if error)

Revision History:

      10-13-95  Modified from WPERF

--*/

BYTE InitPerfInfo()
{
    SYSTEM_BASIC_INFORMATION                    BasicInfo;
    PSYSTEM_PROCESSOR_PERFORMANCE_INFORMATION   PPerfInfo;
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION    ProcessorInfo[MAXIMUM_PROCESSORS];
    int                                         i;

    NTSTATUS Status = NtQuerySystemInformation(
       SystemBasicInformation,
       &BasicInfo,
       sizeof(BasicInfo),
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    g_PageSize = BasicInfo.PageSize;
    g_cProcessors = BasicInfo.NumberOfProcessors;

    if (g_cProcessors > MAXIMUM_PROCESSORS) {
        g_cProcessors = MAXIMUM_PROCESSORS;
    }

    for (i = 0; i < g_cProcessors; i++)
    {
        g_pCPUHistory[i] = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
        if (NULL == g_pCPUHistory[i])
        {
            return 0;
        }
        g_pKernelHistory[i] = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
        if (NULL == g_pKernelHistory[i])
        {
            return 0;
        }

    }

    g_pMEMHistory = (LPBYTE) LocalAlloc(LPTR, HIST_SIZE * sizeof(LPBYTE));
    if (NULL == g_pMEMHistory)
    {
        return 0;
    }

    Status = NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAXIMUM_PROCESSORS,
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    PPerfInfo = ProcessorInfo;


    for (i=0; i < g_cProcessors; i++)
    {
        PreviousCPUIdleTime[i]           =  PPerfInfo->IdleTime;
        PreviousCPUTotalTime[i].QuadPart =  PPerfInfo->UserTime.QuadPart +
                                            PPerfInfo->KernelTime.QuadPart;
        PreviousCPUKernelTime[i].QuadPart =  PPerfInfo->KernelTime.QuadPart +
                                             PPerfInfo->IdleTime.QuadPart;

                                            // PPerfInfo->IdleTime.QuadPart;
        PPerfInfo++;
    }

    //
    // Get the maximum commit limit
    //

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL);

    if (!NT_SUCCESS(Status))
    {
        return 0;
    }

    g_MEMMax = PerfInfo.CommitLimit * ( g_PageSize / 1024 );

    return(g_cProcessors);
}

/*++ ReleasePerfInfo

Routine Description:

   Frees the history buffers

Arguments:

Return Value:

Revision History:

      Nov-13-95 DavePl  Created

--*/

void ReleasePerfInfo()
{
    for (int i = 0; i < g_cProcessors; i++)
    {
        if (g_pCPUHistory[i])
        {
            LocalFree(g_pCPUHistory[i]);
            g_pCPUHistory[i] = NULL;
        }
        if (g_pKernelHistory[i])
        {
            LocalFree(g_pKernelHistory[i]);
            g_pKernelHistory[i] = NULL;
        }

    }

    if (g_pMEMHistory)
    {
        LocalFree(g_pMEMHistory);
    }
}

/*++ CalcCpuTime

Routine Description:

   calculate and return %cpu time and time periods

Arguments:

   None

Notes:

Revision History:

      Nov-13-95 DavePl  Created

--*/

void CalcCpuTime(BOOL fUpdateHistory)
{
    SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION ProcessorInfo[MAXIMUM_PROCESSORS];
    LARGE_INTEGER                            CPUIdleTime[MAXIMUM_PROCESSORS];
    LARGE_INTEGER                            CPUTotalTime[MAXIMUM_PROCESSORS];
    LARGE_INTEGER                            CPUKernelTime[MAXIMUM_PROCESSORS];

    LARGE_INTEGER                            SumIdleTime   = { 0 ,0 };
    LARGE_INTEGER                            SumTotalTime  = { 0, 0 };
    LARGE_INTEGER                            SumKernelTime = { 0, 0 };

    NTSTATUS Status;

    Status = NtQuerySystemInformation(
       SystemProcessorPerformanceInformation,
       ProcessorInfo,
       sizeof(SYSTEM_PROCESSOR_PERFORMANCE_INFORMATION) * MAXIMUM_PROCESSORS,
       NULL
    );

    if (!NT_SUCCESS(Status))
    {
        return;
    }

    //
    // Walk through the info for each CPU, and compile
    //
    //  - Amount of time each CPU has spent idle (since last check)
    //  - Amount of time each CPU has spent entirely (since last check)
    //
    // In addition to keeping per-CPU stats, compile a sum for
    //
    //  - Amount of time system has spent idle (since last check)
    //  - Amount of time that has elapsed, in total (since last check)
    //

    for (int ListIndex = 0; ListIndex < g_cProcessors; ListIndex++)
    {
        LARGE_INTEGER DeltaCPUIdleTime;
        LARGE_INTEGER DeltaCPUTotalTime;
        LARGE_INTEGER DeltaCPUKernelTime;

        CPUIdleTime[ListIndex].QuadPart  = ProcessorInfo[ListIndex].IdleTime.QuadPart;
        CPUKernelTime[ListIndex].QuadPart= ProcessorInfo[ListIndex].KernelTime.QuadPart-
                                           ProcessorInfo[ListIndex].IdleTime.QuadPart;
        CPUTotalTime[ListIndex].QuadPart = ProcessorInfo[ListIndex].KernelTime.QuadPart +
                                           ProcessorInfo[ListIndex].UserTime.QuadPart;// +
                                           //ProcessorInfo[ListIndex].IdleTime.QuadPart;

        DeltaCPUIdleTime.QuadPart        = CPUIdleTime[ListIndex].QuadPart -
                                           PreviousCPUIdleTime[ListIndex].QuadPart;
        DeltaCPUKernelTime.QuadPart      = CPUKernelTime[ListIndex].QuadPart -
                                           PreviousCPUKernelTime[ListIndex].QuadPart;
        DeltaCPUTotalTime.QuadPart       = CPUTotalTime[ListIndex].QuadPart -
                                           PreviousCPUTotalTime[ListIndex].QuadPart;

        SumIdleTime.QuadPart            += DeltaCPUIdleTime.QuadPart;
        SumTotalTime.QuadPart           += DeltaCPUTotalTime.QuadPart;
        SumKernelTime.QuadPart          += DeltaCPUKernelTime.QuadPart;

        // Calc CPU Usage % for this processor, scroll the history buffer, and store
        // the newly calced value at the head of the history buffer

        BYTE ThisCPU;

        if (DeltaCPUTotalTime.QuadPart != 0)
        {
            ThisCPU = static_cast<BYTE>(100 - ((DeltaCPUIdleTime.QuadPart * 100) / DeltaCPUTotalTime.QuadPart));
        }
        else
        {
            ThisCPU = 0;
        }

        BYTE * pbHistory = g_pCPUHistory[ListIndex];
        MoveMemory((LPVOID) (pbHistory + 1),
                   (LPVOID) (pbHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );
        pbHistory[0] = ThisCPU;

        BYTE ThisKernel;
        if (DeltaCPUTotalTime.QuadPart != 0)
        {
            ThisKernel = static_cast<BYTE>(((DeltaCPUKernelTime.QuadPart * 100) / DeltaCPUTotalTime.QuadPart));
        }
        else
        {
            ThisKernel = 0;
        }

        pbHistory = g_pKernelHistory[ListIndex];
        MoveMemory((LPVOID) (pbHistory + 1),
                   (LPVOID) (pbHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );
        pbHistory[0] = ThisKernel;


        PreviousCPUTotalTime[ListIndex].QuadPart = CPUTotalTime[ListIndex].QuadPart;
        PreviousCPUIdleTime[ListIndex].QuadPart  = CPUIdleTime[ListIndex].QuadPart;
        PreviousCPUKernelTime[ListIndex].QuadPart = CPUKernelTime[ListIndex].QuadPart;
    }

    if (SumTotalTime.QuadPart != 0)
    {
        g_CPUUsage =  (BYTE) (100 - ((SumIdleTime.QuadPart * 100) / SumTotalTime.QuadPart));
    }
    else
    {
        g_CPUUsage = 0;
    }

    if (fUpdateHistory)
    {
        if (SumTotalTime.QuadPart != 0)
        {
            g_KernelUsage =  (BYTE) ((SumKernelTime.QuadPart * 100) / SumTotalTime.QuadPart);
        }
        else
        {
            g_KernelUsage = 0;
        }

        //
        // Get the commit size
        //

        SYSTEM_PERFORMANCE_INFORMATION PerfInfo;

        Status = NtQuerySystemInformation(
                    SystemPerformanceInformation,
                    &PerfInfo,
                    sizeof(PerfInfo),
                    NULL);

        if (!NT_SUCCESS(Status))
        {
            return;
        }

        g_MEMUsage = PerfInfo.CommittedPages * (g_PageSize / 1024);
        MoveMemory((LPVOID) (g_pMEMHistory + 1),
                   (LPVOID) (g_pMEMHistory),
                   sizeof(BYTE) * (HIST_SIZE - 1) );

        g_pMEMHistory[0] = (BYTE) (( g_MEMUsage * 100 ) / g_MEMMax );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\pages.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       pages.h
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------
// CPage class
//
// Each of our tabs is represented by an instance of a class derived
// from the CPage class.  This way, the main window can call a standard
// set of methods (size, paint, etc) on each page without concern about
// the particular functionality each page provides.
class CPage
{
public:

    // Sent when page is being created

    virtual HRESULT     Initialize(HWND hwndParent)                 PURE;
    
    // Sent when page is being displayed

    virtual HRESULT     Activate()                                  PURE;
    
    // Sent when page is being hidden
    
    virtual void        Deactivate()                                PURE;
    
    // Send when page is being shut down
    
    virtual HRESULT     Destroy()                                   PURE;
    
    // Returns the title of the page for use on the tab control

    virtual void        GetTitle(LPTSTR pszText, size_t bufsize)    PURE;
    
    // Returns the handle to the page's main dialog
    
    virtual HWND        GetPageWindow()                             PURE;

    // Sent when a timer event (update display) occurs

    virtual void        TimerEvent()                                PURE;

};

#define CPU_PENS 8
#define CUSTOM_PENS 1
#define NUM_PENS (CPU_PENS + CUSTOM_PENS)

typedef struct tagGRAPH 
{
    HWND hwndFrame;
    HWND hwndGraph;

} GRAPH, *PGRAPH;

enum ADAPTER_HISTORY 
{
    BYTES_SENT_UTIL     = 0,
    BYTES_RECEIVED_UTIL = 1
};

extern "C" {
    //
    //  IPHLPAPI does not have this function defines in the header file.
    //
    DWORD
    NhGetInterfaceNameFromDeviceGuid(
        IN      GUID    *pGuid,
        OUT     PWCHAR  pwszBuffer,
        IN  OUT PULONG  pulBufferSize,
        IN      BOOL    bCache,
        IN      BOOL    bRefresh
        );
}

#define MAX_ADAPTERS    32
#define GUID_STR_LENGTH 38

typedef struct tagADAPTER_INFOEX 
{
    MIB_IFROW ifRowStartStats;
    MIB_IFROW ifRowStats[2];
    ULONG     ulHistory[2][HIST_SIZE];
    ULONGLONG ullLinkspeed;
    BOOLEAN   bAdjustLinkSpeed;
    WCHAR     wszDesc[MAXLEN_IFDESCR]; 
    WCHAR     wszConnectionName[MAXLEN_IFDESCR];
    WCHAR     wszGuid[GUID_STR_LENGTH + 1];
    ULONGLONG ullLastTickCount;
    ULONGLONG ullTickCountDiff;
    DWORD     dwScale;

} ADAPTER_INFOEX, *PADAPTER_INFOEX, **PPADAPTER_INFOEX;

class CAdapter
{
public:
    CAdapter();
    HRESULT    Update(BOOLEAN & bAdapterListChange);    
    LPWSTR     GetAdapterText(DWORD dwAdapter, NETCOLUMNID nStatValue);
    ULONGLONG  GetAdapterStat(DWORD dwAdapter, NETCOLUMNID nStatValue, BOOL bAccumulative = FALSE);
    HRESULT    Reset();
    ULONG      *GetAdapterHistory(DWORD dwAdapter, ADAPTER_HISTORY nHistoryType);
    DWORD      GetScale(DWORD dwAdapter);
    void       SetScale(DWORD dwAdapter, DWORD dwScale);
    void       RefreshConnectionNames();
    DWORD      GetNumberOfAdapters();    
    ~CAdapter();

private:
    HRESULT RefreshAdapterTable();    
    HRESULT InitializeAdapter(PPADAPTER_INFOEX ppaiAdapterStats, PIP_ADAPTER_INDEX_MAP pAdapterDescription);
    void    AdjustLinkSpeed(PADAPTER_INFOEX pAdapterInfo);
    HRESULT GetConnectionName(LPWSTR pwszAdapterGuid, LPWSTR pwszConnectionName, DWORD cchConnectionName );
    BOOLEAN AdvanceAdapterHistory(DWORD dwAdapter);

private:    
    PIP_INTERFACE_INFO m_pifTable;
    PPADAPTER_INFOEX   m_ppaiAdapterStats;
    DWORD              m_dwAdapterCount;
    BOOLEAN            m_bToggle;
    DWORD              m_dwLastReportedNumberOfAdapters;
};



// CNetworkPage
//
// Class describing the network page
//
class CNetPage : public CPage
{

public:
    CNetPage();
    HRESULT Initialize(HWND hwndParent);
    DWORD   GetNumberOfGraphs();
    HRESULT SetupColumns();
    void    ScrollGraphs(WPARAM wParam);
    void    SaveColumnWidths();
    void    RememberColumnOrder(HWND hwndList);
    void    RestoreColumnOrder(HWND hwndList);
    void    PickColumns();
    HRESULT Activate();
    void    Deactivate();
    void    DrawAdapterGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane);
    void    SizeNetPage();    
    void    TimerEvent();
    void    UpdateGraphs();
    void    Reset();
    void    Refresh();
    HWND    GetPageWindow()
    {
        return m_hPage;
    }

    ~CNetPage();

private:	
    DWORD   GraphsPerPage(DWORD dwHeight, DWORD dwAdapterCount);
    void    SizeGraph(HDWP hdwp, GRAPH *pGraph, RECT *pRect, RECT *pDimRect);
    void    HideGraph(HDWP hdwp, GRAPH *pGraph);    
    HRESULT UpdatePage();
    void    CreatePens();
    void    ReleasePens();
    void    CalcNetTime( void );
    DWORD   DrawGraph(LPRECT prc, HPEN hPen, DWORD dwZoom, ULONG *pHistory, ULONG *pHistory2 = NULL);
    HRESULT CreateMemoryBitmaps(int x, int y);
    void    FreeMemoryBitmaps();
    HRESULT Destroy();
    void    GetTitle(LPTSTR pszText, size_t bufsize);
    void    ReleaseScaleFont();
    void    CreateScaleFont(HDC hdc);
    ULONG   DrawAdapterGraphPaper(HDC hdcGraph, RECT * prcGraph, DWORD dwZoom);
    INT     DrawScale(HDC hdcGraph, RECT *prcGraph, DWORD dwZoom);
    WCHAR * CommaNumber(ULONGLONG ullValue, WCHAR *pwsz, int cchNumber);
    WCHAR * SimplifyNumber(ULONGLONG ullValue, WCHAR *psz, DWORD cch);
    WCHAR * FloatToString(ULONGLONG ulValue, WCHAR *psz, DWORD cch, BOOLEAN bDisplayDecimal = FALSE);


private:
    CAdapter   m_Adapter;
    HWND       m_hPage;                    // Handle to this page's dlg
    HWND       m_hwndTabs;                 // Parent window
    HDC        m_hdcGraph;                 // Inmemory dc for cpu hist
    HBITMAP    m_hbmpGraph;                // Inmemory bmp for cpu hist
    HGDIOBJ    m_hOldObject;               // Previous object in m_hdcGraph
    HPEN       m_hPens[3];                 // Our box of crayons
    RECT       m_rcGraph;    
    BOOL       m_bReset;    
    BOOL       m_bPageActive;              // Tells the class if the Network tab is active (i.e. the user is looking at it)
                                           // If the tab is not active we will not collect network data unless the user selects 
                                           // the menu option to do so. (We same some CPU usage then.    .  
    HFONT      m_hScaleFont;
    LONG       m_lScaleFontHeight;
    LONG       m_lScaleWidth;    

private:
    HRESULT CreateGraphs(DWORD dwGraphsRequired);
    void    DestroyGraphs();
    DWORD   GetFirstVisibleAdapter();
    void    LabelGraphs();


private:
    PGRAPH     m_pGraph;
    DWORD      m_dwGraphCount;
    DWORD      m_dwFirstVisibleAdapter;    
    DWORD      m_dwGraphsPerPage;
    HWND       m_hScrollBar;
    HWND       m_hListView;
    HWND       m_hNoAdapterText;
};


// CPerfPage
//
// Class describing the performance page

class CPerfPage : public CPage
{
    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    HBITMAP     m_hStripUnlit;              // Digits bitmap
    HBITMAP     m_hStripLitRed;             // Digits bitmap
    HBITMAP     m_hStripLit;                // Digits bitmap
    HDC         m_hdcGraph;                 // Inmemory dc for cpu hist
    HBITMAP     m_hbmpGraph;                // Inmemory bmp for cpu hist
    HGDIOBJ     m_hObjOld;                  // Original object
    HPEN        m_hPens[NUM_PENS];          // Our box of crayons
    RECT        m_rcGraph;

public:

    CPerfPage()
    {
        ZeroMemory((LPVOID) m_hPens, sizeof(m_hPens));
    }

    virtual ~CPerfPage()
    {
    };

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        SizePerfPage();
    void        TimerEvent();
    HWND        GetPageWindow()
    {
        return m_hPage;
    }
    
    void        DrawCPUGraph(LPDRAWITEMSTRUCT lpdi, UINT iPane);
    void        DrawMEMGraph(LPDRAWITEMSTRUCT lpdi);
    void        DrawCPUDigits(LPDRAWITEMSTRUCT lpdi);
    void        DrawMEMMeter(LPDRAWITEMSTRUCT lpdi);
    void        UpdateCPUHistory();
    void        FreeMemoryBitmaps();
    HRESULT     CreateMemoryBitmaps(int x, int y);
    void        SetTimer(HWND hwnd, UINT milliseconds);
    void        CreatePens();
    void        ReleasePens();
    void        UpdateGraphs();
};

// CSysInfo
//
// Some misc global info about the system

class CSysInfo
{
public:

    // These fields MUST all be DWORDS because we manually index into
    // them individually in procperf.cpp
        
    DWORD   m_cHandles;
    DWORD   m_cThreads;
    DWORD   m_cProcesses;
    DWORD   m_dwPhysicalMemory;
    DWORD   m_dwPhysAvail;
    DWORD   m_dwFileCache;
    DWORD   m_dwKernelPaged;
    DWORD   m_dwKernelNP;
    DWORD   m_dwKernelTotal;
    DWORD   m_dwCommitTotal;
    DWORD   m_dwCommitLimit;
    DWORD   m_dwCommitPeak;

    CSysInfo()
    {
        ZeroMemory(this, sizeof(CSysInfo));
    }
};

// CProcessPage
//
// Class describing the process list page

class CPtrArray;                            // Forward reference
class CProcInfo;

class CProcPage : public CPage
{
    
friend BOOL WINAPI WowTaskCallback(
    DWORD dwThreadId,
    WORD hMod16,
    WORD hTask16,
    CHAR *pszModName,
    CHAR *pszFileName,
    LPARAM lparam
    );

    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pProcArray;               // Ptr array of running processes
    LPVOID      m_pvBuffer;                 // Buffer for NtQuerySystemInfo
    size_t      m_cbBuffer;                 // Size of the above buffer, in bytes
    CSysInfo    m_SysInfo;
    BOOL        m_fPaused;                  // Updates paused (during trackpopupmenu)
    LPTSTR      m_pszDebugger;              // Debugger command in registry

public:

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();
    HWND        GetPageWindow() { return m_hPage; };

    void        PickColumns();
    void        SaveColumnWidths();
    void        SizeProcPage();
    HRESULT     SetupColumns();
    HRESULT     UpdateProcInfoArray();
    HRESULT     UpdateProcListview();
    HRESULT     GetProcessInfo();
    INT         HandleProcPageNotify(LPNMHDR);
    void        HandleProcListContextMenu(INT xPos, INT yPos);
    CProcInfo * GetSelectedProcess();
    void        HandleWMCOMMAND( WORD , HWND );
    BOOL        IsSystemProcess(DWORD pid, CProcInfo * pProcInfo);
    BOOL        KillProcess(DWORD pid, BOOL bBatch = FALSE);
    BOOL        KillAllChildren(DWORD dwTaskPid, DWORD pid, BYTE* pbBuffer, LARGE_INTEGER CreateTime);
    BOOL        SetPriority(CProcInfo * pProc, DWORD idCmd);
    BOOL        AttachDebugger(DWORD pid);
    UINT        QuickConfirm(UINT idTitle, UINT idBody);
    BOOL        SetAffinity(DWORD pid);

    typedef struct _TASK_LIST 
    {
        DWORD       dwProcessId;
        DWORD       dwInheritedFromProcessId;
        ULARGE_INTEGER CreateTime;
        BOOL        flags;
    } TASK_LIST, *PTASK_LIST;

    BOOL        RecursiveKill(DWORD pid);
    BYTE*       GetTaskListEx();
    
    // Constructor
    CProcPage()
    {
        m_hPage         = NULL;
        m_hwndTabs      = NULL;
        m_pProcArray    = NULL;
        m_pvBuffer      = NULL;
        m_cbBuffer      = 0;
        m_fPaused       = FALSE;
        m_pszDebugger   = NULL;
    }

    virtual ~CProcPage();


    // The dialog proc needs to be able to set the m_hPage member, so
    // make it a friend

    friend INT_PTR CALLBACK ProcPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );

    // The WOW task callback proc needs to be able to get m_pProcArray,
    // so make it a friend.

    friend BOOL WINAPI WowTaskCallback(
                           DWORD dwThreadId,
                           WORD hTask16,
                           PSZ pszFileName,
                           LPARAM lparam
                           );

private:
    void Int64ToCommaSepString(LONGLONG n, LPTSTR pszOut, int cchOut);
    void Int64ToCommaSepKString(LONGLONG n, LPTSTR pszOut, int cchOut);
    void RememberColumnOrder(HWND hwndList);
    void RestoreColumnOrder(HWND hwndList);
};

class TASK_LIST_ENUM;                       // Forward ref

// THREADPARAM 
//
// Uses as a communication struct between task page and its worker thread
class THREADPARAM
{
public:

    WINSTAENUMPROC  m_lpEnumFunc;
    LPARAM          m_lParam;

    HANDLE          m_hEventChild;
    HANDLE          m_hEventParent;
    BOOL            m_fThreadExit;
    BOOL            m_fSuccess;

    THREADPARAM::THREADPARAM()
    {
        ZeroMemory(this, sizeof(THREADPARAM));
    }
};

// CTaskPage
//
// Class describing the task manager page

class CTaskPage : public CPage
{
private:

    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pTaskArray;               // Array of active tasks
    BOOL        m_fPaused;                  // BOOL, is display refresh paused for menu
    HIMAGELIST  m_himlSmall;                // Image lists
    HIMAGELIST  m_himlLarge;
    VIEWMODE    m_vmViewMode;               // Large or small icon mode
    UINT        m_cSelected;                // Count of items selected
    THREADPARAM m_tp;
    HANDLE      m_hEventChild;                   
    HANDLE      m_hEventParent;
    HANDLE      m_hThread;

    typedef struct _open_failures_
    {
        WCHAR                   *_pszWindowStationName;
        WCHAR                   *_pszDesktopName;
        struct _open_failures_  *_pofNext;
    } OPEN_FAILURE, *LPOPEN_FAILURE;

    OPEN_FAILURE    *m_pofFailures;

protected:
    void    RemoveAllTasks();
    HRESULT LoadDefaultIcons();

public:

    CTaskPage()
    {
        m_hPage        = NULL;
        m_hwndTabs     = NULL;
        m_fPaused      = FALSE;
        m_pTaskArray   = NULL;
        m_himlSmall    = NULL;
        m_himlLarge    = NULL;
        m_hEventChild  = NULL;
        m_hEventParent = NULL;
        m_hThread      = NULL;
        m_vmViewMode   = g_Options.m_vmViewMode;
        m_cSelected    = 0;
        m_pofFailures  = NULL;
    }

    virtual ~CTaskPage();
    

    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();

    HWND        GetPageWindow() { return m_hPage; };

    void        SizeTaskPage();
    HRESULT     SetupColumns();
    void        GetRunningTasks(TASK_LIST_ENUM * te);
    void        HandleWMCOMMAND(INT id);
    
    HRESULT     UpdateTaskListview();
    INT         HandleTaskPageNotify(LPNMHDR pnmhdr);
    void        HandleTaskListContextMenu(INT xPos, INT yPos);
    BOOL        CreateNewDesktop();
    CPtrArray * GetSelectedTasks();
    void        UpdateUIState();
    HWND      * GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount);
    void        EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount);
    BOOL        HasAlreadyOpenFailed(WCHAR *pszWindowStationName, WCHAR *pszDesktopName);
    void        SetOpenFailed(WCHAR *pszWindowStationName, WCHAR *pszDesktopName);
    void        FreeOpenFailures(void);
    BOOL        DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam);

    void        OnSettingsChange();
    
    void        Pause() { m_fPaused = TRUE; };
    void        Unpause() { m_fPaused = FALSE; };

    // The dialog proc needs to be able to set the m_hPage member, so
    // make it a friend

    friend INT_PTR CALLBACK TaskPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );

    // The enum callback needs to get at our imagelists as it encounters
    // new tasls, so it can add their icons to the lists

    friend BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam);

};

// TASK_LIST_ENUM
//
// Object passed around during window enumeration

class TASK_LIST_ENUM 
{
public:
    CPtrArray *     m_pTasks;
    LPWSTR          lpWinsta;
    LPWSTR          lpDesk;
    LARGE_INTEGER   uPassCount;
    CTaskPage *     m_pPage;

    TASK_LIST_ENUM()
    {
        ZeroMemory(this, sizeof(TASK_LIST_ENUM));
    }
};
typedef TASK_LIST_ENUM *PTASK_LIST_ENUM;



// CUserPage
//
// Class describing the task manager page

class CUserPage : public CPage
{
private:

    HWND        m_hPage;                    // Handle to this page's dlg
    HWND        m_hwndTabs;                 // Parent window
    CPtrArray * m_pUserArray;               // Array of active users
    BOOL        m_fPaused;                  // BOOL, is display refresh paused for menu
    UINT        m_cSelected;                // Count of items selected
    HIMAGELIST  m_himlUsers;                // Image list for user icons
    UINT        m_iUserIcon;
    UINT        m_iCurrentUserIcon;
    THREADPARAM m_tp;
    HANDLE      m_hEventChild;
    HANDLE      m_hEventParent;
    HANDLE      m_hThread;

protected:
    void    RemoveAllUsers();
    HRESULT LoadDefaultIcons();

public:

    CUserPage()
    {
        m_hPage             = NULL;
        m_hwndTabs          = NULL;
        m_fPaused           = FALSE;
        m_pUserArray        = NULL;
        m_hEventChild       = NULL;
        m_hEventParent      = NULL;
        m_hThread           = NULL;
        m_cSelected         = 0;
        m_himlUsers         = NULL;
        m_iUserIcon         = 0;
        m_iCurrentUserIcon  = 0;
    }

    virtual ~CUserPage();


    HRESULT     Initialize(HWND hwndParent);
    HRESULT     Activate();
    void        Deactivate();
    HRESULT     Destroy();
    void        GetTitle(LPTSTR pszText, size_t bufsize);
    void        TimerEvent();
    void        OnInitDialog(HWND hPage);

    HWND        GetPageWindow() { return m_hPage; };

    void        SizeUserPage();
    HRESULT     SetupColumns();
    void        GetRunningUsers(TASK_LIST_ENUM * te);
    void        HandleWMCOMMAND(INT id);

    HRESULT     UpdateUserListview();
    INT         HandleUserPageNotify(LPNMHDR pnmhdr);
    void        HandleUserListContextMenu(INT xPos, INT yPos);
    CPtrArray * GetSelectedUsers();
    void        UpdateUIState();
    HWND      * GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount);
    void        EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount);
    BOOL        DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam);

    void OnSettingsChange();

    void        Pause() { m_fPaused = TRUE; };
    void        Unpause() { m_fPaused = FALSE; };
};

INT_PTR CALLBACK UserPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,               // message
                WPARAM      wParam,             // first message parameter
                LPARAM      lParam              // second message parameter
                );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\main.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       Main.CPP
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"
#define DECL_CRTFREE
#include <crtfree.h>

static UINT g_msgTaskbarCreated = 0;
static const UINT idTrayIcons[] =
{
    IDI_TRAY0, IDI_TRAY1, IDI_TRAY2, IDI_TRAY3, IDI_TRAY4, IDI_TRAY5,
    IDI_TRAY6, IDI_TRAY7, IDI_TRAY8, IDI_TRAY9, IDI_TRAY10, IDI_TRAY11
};

HICON g_aTrayIcons[ARRAYSIZE(idTrayIcons)];
UINT  g_cTrayIcons = ARRAYSIZE(idTrayIcons);
#define MIN_MEMORY_REQUIRED 8       // If the system has less than 8 megs of memory only load the first two tabs.

//
// Control IDs
//

#define IDC_STATUSWND   100

//
// Globals - this app is (effectively) single threaded and these values
//           are used by all pages
//

const WCHAR cszStartupMutex[] = L"NTShell Taskman Startup Mutex";
#define FINDME_TIMEOUT 10000                // Wait to to 10 seconds for a response
typedef BOOLEAN (*PFNSETSUSPENDSTATE)(BOOLEAN, BOOLEAN, BOOLEAN);

void MainWnd_OnSize(HWND hwnd, UINT state, int cx, int cy);

HANDLE      g_hStartupMutex = NULL;
BOOL        g_fMenuTracking = FALSE;
HWND        g_hMainWnd      = NULL;
HDESK       g_hMainDesktop  = NULL;
HWND        g_hStatusWnd    = NULL;
HINSTANCE   g_hInstance     = NULL;
HACCEL      g_hAccel        = NULL;
BYTE        g_cProcessors   = (BYTE) 0;
HMENU       g_hMenu         = NULL;
BOOL        g_fCantHide     = FALSE;
BOOL        g_fInPopup      = FALSE;
DWORD       g_idTrayThread  = 0;
HANDLE      g_hTrayThread   = NULL;
LONG        g_minWidth      = 0;
LONG        g_minHeight     = 0;
LONG        g_DefSpacing    = 0;
LONG        g_InnerSpacing  = 0;
LONG        g_TopSpacing    = 0;
LONG        g_cxEdge        = 0;

LONG        g_ControlWidthSpacing = 0;
LONG        g_ControlHeightSpacing = 0;

HRGN        g_hrgnView      = NULL;
HRGN        g_hrgnClip      = NULL;

HBRUSH      g_hbrWindow     = NULL;

COptions    g_Options;

static BOOL fAlreadySetPos  = FALSE;

BOOL g_bMirroredOS = FALSE;

//
// Global strings - short strings used too often to be LoadString'd
//                  every time
//
WCHAR       g_szRealtime    [SHORTSTRLEN];
WCHAR       g_szNormal      [SHORTSTRLEN];
WCHAR       g_szHigh        [SHORTSTRLEN];
WCHAR       g_szLow         [SHORTSTRLEN];
WCHAR       g_szUnknown     [SHORTSTRLEN];
WCHAR       g_szAboveNormal [SHORTSTRLEN];
WCHAR       g_szBelowNormal [SHORTSTRLEN];
WCHAR       g_szHung        [SHORTSTRLEN];
WCHAR       g_szRunning     [SHORTSTRLEN];
WCHAR       g_szfmtTasks    [SHORTSTRLEN];
WCHAR       g_szfmtProcs    [SHORTSTRLEN];
WCHAR       g_szfmtCPU      [SHORTSTRLEN];  
WCHAR       g_szfmtMEMK     [SHORTSTRLEN];  
WCHAR       g_szfmtMEMM     [SHORTSTRLEN];  
WCHAR       g_szfmtCPUNum   [SHORTSTRLEN];
WCHAR       g_szTotalCPU    [SHORTSTRLEN];
WCHAR       g_szKernelCPU   [SHORTSTRLEN];
WCHAR       g_szMemUsage    [SHORTSTRLEN];
WCHAR       g_szBytes       [SHORTSTRLEN];
WCHAR       g_szPackets     [SHORTSTRLEN];
WCHAR       g_szBitsPerSec  [SHORTSTRLEN];
WCHAR       g_szScaleFont   [SHORTSTRLEN];
WCHAR       g_szPercent     [SHORTSTRLEN];
WCHAR       g_szZero            [SHORTSTRLEN];
WCHAR       g_szNonOperational  [SHORTSTRLEN];
WCHAR       g_szUnreachable     [SHORTSTRLEN];
WCHAR       g_szDisconnected    [SHORTSTRLEN];
WCHAR       g_szConnecting      [SHORTSTRLEN];
WCHAR       g_szConnected       [SHORTSTRLEN];
WCHAR       g_szOperational     [SHORTSTRLEN];
WCHAR       g_szUnknownStatus   [SHORTSTRLEN];
WCHAR       g_szTimeSep         [SHORTSTRLEN];
WCHAR       g_szGroupThousSep   [SHORTSTRLEN];
WCHAR       g_szDecimal         [SHORTSTRLEN];
ULONG       g_ulGroupSep;

WCHAR       g_szG[10];                     // Localized "G"igabyte symbol
WCHAR       g_szM[10];                     // Localized "M"egabyte symbol
WCHAR       g_szK[10];                     // Localized "K"ilobyte symbol



// Page Array
// 
// Each of the page objects is delcared here, and g_pPages is an array
// of pointers to those instantiated objects (at global scope).  The main
// window code can call through the base members of the CPage class to
// do things like sizing, etc., without worrying about whatever specific
// stuff each page might do

int     g_nPageCount        = 0;
CPage * g_pPages[NUM_PAGES] = { NULL };

typedef DWORD (WINAPI * PFNCM_REQUEST_EJECT_PC) (void);
PFNCM_REQUEST_EJECT_PC  gpfnCM_Request_Eject_PC = NULL;

// Terminal Services
BOOL  g_fIsTSEnabled = FALSE;
BOOL  g_fIsSingleUserTS = FALSE;
BOOL  g_fIsTSServer = FALSE;
DWORD g_dwMySessionId = 0;


/*
   Superclass of GROUPBOX
 
   We need to turn on clipchildren for our dialog which contains the
   history graphs, so they don't get erased during the repaint cycle.
   Unfortunately, group boxes don't erase their backgrounds, so we
   have to superclass them and provide a control that does.

   This is a lot of extra work, but the painting is several orders of
   magnitude nicer with it...

*/

/*++ DavesFrameWndProc

Routine Description:

    WndProc for the custom group box class.  Primary difference from
    standard group box is that this one knows how to erase its own
    background, and doesn't rely on the parent to do it for it.
    These controls also have CLIPSIBLINGS turn on so as not to stomp
    on the ownderdraw graphs they surround.
    
Arguments:

    standard wndproc fare

Revision History:

      Nov-29-95 Davepl  Created

--*/

WNDPROC oldButtonWndProc = NULL;
                               
LRESULT DavesFrameWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    if (msg == WM_CREATE)
    {
        //
        // Turn on clipsiblings for the frame
        //

        DWORD dwStyle = GetWindowLong(hWnd, GWL_STYLE);
        dwStyle |= WS_CLIPSIBLINGS;
        SetWindowLong(hWnd, GWL_STYLE, dwStyle);
    }
    else if (msg == WM_ERASEBKGND)
    {
        return DefWindowProc( hWnd, msg, wParam, lParam );
    }

    // For anything else, we defer to the standard button class code

    return CallWindowProc(oldButtonWndProc, hWnd, msg, wParam, lParam);
}

/*++ COptions::Save 

Routine Description:

   Saves current options to the registy
 
Arguments:

Returns:
    
    HRESULT

Revision History:

      Jan-01-95 Davepl  Created

--*/

const WCHAR szTaskmanKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\TaskManager");
const WCHAR szOptionsKey[] = TEXT("Preferences");

HRESULT COptions::Save()
{
    DWORD dwDisposition;
    HKEY  hkSave;

    if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER,
                                        szTaskmanKey,
                                        0,
                                        TEXT("REG_BINARY"),
                                        REG_OPTION_NON_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hkSave,
                                        &dwDisposition))
    {
        return GetLastHRESULT();
    }

    if (ERROR_SUCCESS != RegSetValueEx(hkSave,
                                       szOptionsKey,
                                       0,
                                       REG_BINARY,
                                       (LPBYTE) this,
                                       sizeof(COptions)))
    {
        RegCloseKey(hkSave);
        return GetLastHRESULT();
    }

    RegCloseKey(hkSave);
    return S_OK;
}

/*++ COptions::Load

Routine Description:

   Loads current options to the registy
 
Arguments:

Returns:
    
    HRESULT

Revision History:

      Jan-01-95 Davepl  Created

--*/

HRESULT COptions::Load()
{
    HKEY  hkSave;

    // If ctrl-alt-shift is down at startup, "forget" registry settings

    if (GetKeyState(VK_SHIFT) < 0 &&
        GetKeyState(VK_MENU)  < 0 &&
        GetKeyState(VK_CONTROL) < 0)
    {
        SetDefaultValues();
        return S_FALSE;
    }

    if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_CURRENT_USER,
                                      szTaskmanKey,
                                      0,
                                      KEY_READ,
                                      &hkSave))
    {
        return S_FALSE;
    }

    DWORD dwType;
    DWORD dwSize = sizeof(COptions);
    if (ERROR_SUCCESS       != RegQueryValueEx(hkSave,
                                               szOptionsKey,
                                               0,
                                               &dwType,
                                               (LPBYTE) this,
                                               &dwSize) 
        
        // Validate type and size of options info we got from the registry

        || dwType           != REG_BINARY 
        || dwSize           != sizeof(COptions)

        // Validate options, revert to default if any are invalid (like if
        // the window would be offscreen)

        || MonitorFromRect(&m_rcWindow, MONITOR_DEFAULTTONULL) == NULL
        //number of available pages might be less than NUM_PAGES
        || m_iCurrentPage    > g_nPageCount - 1)
        

    {
        // Reset to default values

        SetDefaultValues();
        RegCloseKey(hkSave);
        return S_FALSE;
    }

    RegCloseKey(hkSave);

    return S_OK;
}


/*++ COptions::SetDefaultValues

Routine Description:

   Used to init the options to a default state when the saved copy
   cannot be found, is damaged, or is not the correct version
 
Arguments:

Returns:
    
    nothing

Revision History:

      Dec-06-00 jeffreys Moved from taskmgr.h

--*/

BOOL IsUserAdmin();

// Columns which are visible, by default, in the process view
const COLUMNID    g_aDefaultCols[]    = { COL_IMAGENAME, COL_USERNAME, COL_CPU, COL_MEMUSAGE, (COLUMNID)-1 };
const COLUMNID    g_aTSCols[]         = { COL_IMAGENAME, COL_USERNAME, COL_SESSIONID, COL_CPU, COL_MEMUSAGE, (COLUMNID)-1 };
const NETCOLUMNID g_aNetDefaultCols[] = { COL_ADAPTERNAME, COL_NETWORKUTIL, COL_LINKSPEED, COL_STATE, (NETCOLUMNID)-1 };

void COptions::SetDefaultValues()
{
    ZeroMemory(this, sizeof(COptions));

    m_cbSize           = sizeof(COptions);

    BOOL bScreenReader = FALSE;
    if (SystemParametersInfo(SPI_GETSCREENREADER, 0, (PVOID) &bScreenReader, 0) && bScreenReader)
    {
        // No automatic updates for machines with screen readers
        m_dwTimerInterval = 0;
    }
    else
    {
        m_dwTimerInterval  = 1000;
    }

    m_vmViewMode       = VM_DETAILS;
    m_cmHistMode       = CM_PANES;
    m_usUpdateSpeed    = US_NORMAL;
    m_fMinimizeOnUse   = TRUE;
    m_fConfirmations   = TRUE;
    m_fAlwaysOnTop     = TRUE;
    m_fShow16Bit       = TRUE;
    m_iCurrentPage     = -1;
    m_rcWindow.top     = 10;
    m_rcWindow.left    = 10;
    m_rcWindow.bottom  = 10 + g_minHeight;
    m_rcWindow.right   = 10 + g_minWidth;

    m_bShowAllProcess = (g_fIsTSEnabled && !g_fIsSingleUserTS && IsUserAdmin());

    const COLUMNID *pcol = (g_fIsTSEnabled && !g_fIsSingleUserTS) ? g_aTSCols : g_aDefaultCols;

    for (int i = 0; i < NUM_COLUMN + 1 ; i++, pcol++)
    {
        m_ActiveProcCol[i] = *pcol;

        if ((COLUMNID)-1 == *pcol)
            break;
    }

    // Set all of the columns widths to -1

    FillMemory(m_ColumnWidths, sizeof(m_ColumnWidths), 0xFF);
    FillMemory(m_ColumnPositions, sizeof(m_ColumnPositions), 0xFF);

    // Set the Network default values
    //
    const NETCOLUMNID *pnetcol = g_aNetDefaultCols;

    for (int i = 0; i < NUM_NETCOLUMN + 1 ; i++, pnetcol++)
    {
        m_ActiveNetCol[i] = *pnetcol;
        if ((NETCOLUMNID)-1 == *pnetcol)
            break;
    }

    // Set all of the columns widths to -1
    //
    FillMemory(m_NetColumnWidths, sizeof(m_NetColumnWidths), 0xFF);
    FillMemory(m_NetColumnPositions, sizeof(m_NetColumnPositions), 0xFF);

    m_bAutoSize = TRUE;
    m_bGraphBytesSent = FALSE;
    m_bGraphBytesReceived = FALSE;
    m_bGraphBytesTotal = TRUE;
    m_bNetShowAll = FALSE;
    m_bShowScale = TRUE;
    m_bTabAlwaysActive = FALSE;

}

BOOL FPalette(void)
{
    HDC hdc = GetDC(NULL);
    BOOL fPalette = (GetDeviceCaps(hdc, NUMCOLORS) != -1);
    ReleaseDC(NULL, hdc);
    return fPalette;
}

/*++ InitDavesControls

Routine Description:

   Superclasses GroupBox for better drawing
 
   Note that I'm not very concerned about failure here, since it
   something goes wrong the dialog creation will fail awayway, and
   it will be handled there
    
Arguments:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void InitDavesControls()
{
    static const WCHAR szControlName[] = TEXT("DavesFrameClass");

    WNDCLASS wndclass;

    // 
    // Get the class info for the Button class (which is what group
    // boxes really are) and create a new class based on it
    //

    if (!GetClassInfo(g_hInstance, TEXT("Button"), &wndclass))
        return; // Ungraceful exit, but better than random unit'd lpfnWndProc

    oldButtonWndProc = wndclass.lpfnWndProc;

    wndclass.hInstance = g_hInstance;
    wndclass.lpfnWndProc = DavesFrameWndProc;
    wndclass.lpszClassName = szControlName;
    wndclass.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);

    (ATOM)RegisterClass(&wndclass);

    return;
}

/*++ SetTitle

Routine Description:

    Sets the app's title in the title bar (we do this on startup and
    when coming out of notitle mode).
    
Arguments:
    
    none

Return Value:

    none

Revision History:

    Jan-24-95 Davepl  Created

--*/

void SetTitle()
{
    WCHAR szTitle[MAX_PATH];
    LoadString(g_hInstance, IDS_APPTITLE, szTitle, MAX_PATH);
    SetWindowText(g_hMainWnd, szTitle);
}

/*++ UpdateMenuStates

Routine Description:

    Updates the menu checks / ghosting based on the
    current settings and options
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void UpdateMenuStates()
{
    HMENU hMenu = GetMenu(g_hMainWnd);
    if (hMenu)
    {
        CheckMenuRadioItem(hMenu, VM_FIRST, VM_LAST, VM_FIRST + (UINT) g_Options.m_vmViewMode, MF_BYCOMMAND);
        CheckMenuRadioItem(hMenu, CM_FIRST, CM_LAST, CM_FIRST + (UINT) g_Options.m_cmHistMode, MF_BYCOMMAND);
        CheckMenuRadioItem(hMenu, US_FIRST, US_LAST, US_FIRST + (UINT) g_Options.m_usUpdateSpeed, MF_BYCOMMAND);

        CheckMenuItem(hMenu, IDM_ALWAYSONTOP,       MF_BYCOMMAND | (g_Options.m_fAlwaysOnTop   ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_MINIMIZEONUSE,     MF_BYCOMMAND | (g_Options.m_fMinimizeOnUse ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_KERNELTIMES,       MF_BYCOMMAND | (g_Options.m_fKernelTimes   ? MF_CHECKED : MF_UNCHECKED));    
        CheckMenuItem(hMenu, IDM_NOTITLE,           MF_BYCOMMAND | (g_Options.m_fNoTitle       ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_HIDEWHENMIN,       MF_BYCOMMAND | (g_Options.m_fHideWhenMin   ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_SHOW16BIT,         MF_BYCOMMAND | (g_Options.m_fShow16Bit     ? MF_CHECKED : MF_UNCHECKED));
        CheckMenuItem(hMenu, IDM_SHOWDOMAINNAMES,   MF_BYCOMMAND | (g_Options.m_fShowDomainNames ? MF_CHECKED : MF_UNCHECKED));

    // Remove the CPU history style options on single processor machines

        if (g_cProcessors < 2)
        {
            DeleteMenu(hMenu, IDM_ALLCPUS, MF_BYCOMMAND);
        }

        CheckMenuItem(hMenu,IDM_SHOWSCALE,       g_Options.m_bShowScale          ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_AUTOSIZE,        g_Options.m_bAutoSize           ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESSENT,       g_Options.m_bGraphBytesSent     ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESRECEIVED,   g_Options.m_bGraphBytesReceived ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_BYTESTOTAL,      g_Options.m_bGraphBytesTotal    ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_SHOWALLDATA,     g_Options.m_bNetShowAll         ? MF_CHECKED:MF_UNCHECKED);
        CheckMenuItem(hMenu,IDM_TABALWAYSACTIVE, g_Options.m_bTabAlwaysActive    ? MF_CHECKED:MF_UNCHECKED);
    }

}

/*++ SizeChildPage

Routine Description:

    Size the active child page based on the tab control
    
Arguments:

    hwndMain    - Main window

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void SizeChildPage(HWND hwndMain)
{
    if (g_Options.m_iCurrentPage >= 0 && g_Options.m_iCurrentPage < g_nPageCount )
    {
        // If we are in maximum viewing mode, the page gets the whole
        // window area
        
        HWND hwndPage = g_pPages[g_Options.m_iCurrentPage]->GetPageWindow();

        DWORD dwStyle = GetWindowLong (g_hMainWnd, GWL_STYLE);
    
        if (g_Options.m_fNoTitle)
        {
            RECT rcMainWnd;
            GetClientRect(g_hMainWnd, &rcMainWnd);
            SetWindowPos(hwndPage, HWND_TOP, rcMainWnd.left, rcMainWnd.top,
                    rcMainWnd.right - rcMainWnd.left, 
                    rcMainWnd.bottom - rcMainWnd.top, SWP_NOZORDER | SWP_NOACTIVATE);
    
            // remove caption & menu bar, etc.

            dwStyle &= ~(WS_DLGFRAME | WS_SYSMENU | WS_MINIMIZEBOX | WS_MAXIMIZEBOX);
            // SetWindowLong (g_hMainWnd, GWL_ID, 0);            
            SetWindowLong (g_hMainWnd, GWL_STYLE, dwStyle);
            SetMenu(g_hMainWnd, NULL);

        }
        else
        {                                
            // If we have a page being displayed, we need to size it also
            // put menu bar & caption back in 

            dwStyle = WS_TILEDWINDOW | dwStyle;
            SetWindowLong (g_hMainWnd, GWL_STYLE, dwStyle);

            if (g_hMenu)
            {
                SetMenu(g_hMainWnd, g_hMenu);
                UpdateMenuStates();
            }

            SetTitle();
              
            if (hwndPage)
            {
                RECT rcCtl;
                HWND hwndCtl = GetDlgItem(hwndMain, IDC_TABS);
                GetClientRect(hwndCtl, &rcCtl);

                MapWindowPoints(hwndCtl, hwndMain, (LPPOINT)&rcCtl, 2);
                TabCtrl_AdjustRect(hwndCtl, FALSE, &rcCtl);

                SetWindowPos(hwndPage, HWND_TOP, rcCtl.left, rcCtl.top,
                        rcCtl.right - rcCtl.left, rcCtl.bottom - rcCtl.top, SWP_NOZORDER | SWP_NOACTIVATE);
            }
        }
        if( g_Options.m_iCurrentPage == NET_PAGE )
        {
            // The network page is dynamic adapters can be added and removed. If taskmgr is minimized and
            // a Adapter is added or removed. When taskmgr is maximized/restored again the netpage must be
            // resized so the change is reflected. Thus the size change must be reported to the adapter.
            //
            ((CNetPage *)g_pPages[g_Options.m_iCurrentPage])->SizeNetPage();
        }
    }
}

/*++ UpdateStatusBar

Routine Description:

    Draws the status bar with test based on data accumulated by all of
    the various pages (basically a summary of most important info)
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void UpdateStatusBar()
{
    //
    // If we're in menu-tracking mode (sticking help text in the stat
    // bar), we don't draw our standard text
    //

    if (FALSE == g_fMenuTracking)
    {
        WCHAR szText[MAX_PATH];

        StringCchPrintf(szText, ARRAYSIZE(szText), g_szfmtProcs, g_cProcesses);
        SendMessage(g_hStatusWnd, SB_SETTEXT, 0, (LPARAM) szText);

        StringCchPrintf(szText, ARRAYSIZE(szText), g_szfmtCPU, g_CPUUsage);
        SendMessage(g_hStatusWnd, SB_SETTEXT, 1, (LPARAM) szText);

        //
        //  If more than 900 megs are in the machine switch to M mode.
        //

        if ( g_MEMMax > 900 * 1024 )
        {
            StringCchPrintf(szText, ARRAYSIZE(szText), g_szfmtMEMM, g_MEMUsage / 1024, g_MEMMax / 1024);
        }
        else
        {
            StringCchPrintf(szText, ARRAYSIZE(szText), g_szfmtMEMK, g_MEMUsage, g_MEMMax);
        }

        SendMessage(g_hStatusWnd, SB_SETTEXT, 2, (LPARAM) szText);
    }
}

/*++ MainWnd_OnTimer

Routine Description:

    Called when the refresh timer fires, we pass a timer event on to
    each of the child pages.  

Arguments:

    hwnd    - window timer was received at
    id      - id of timer that was received

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/

void MainWnd_OnTimer(HWND hwnd)
{
    static const cchTipTextSize = (2 * SHORTSTRLEN);
    
    if (GetForegroundWindow() == hwnd && GetKeyState(VK_CONTROL) < 0)
    {
        // CTRL alone means pause

        return;
    }

    // Notify each of the pages in turn that they need to updatre

    for (int i = 0; i < g_nPageCount; i++)
    {
        g_pPages[i]->TimerEvent();
    }

    // Update the tray icon

    UINT iIconIndex = (g_CPUUsage * g_cTrayIcons) / 100;
    if (iIconIndex >= g_cTrayIcons)
    {
        iIconIndex = g_cTrayIcons - 1;      // Handle 100% case
    }


    LPWSTR pszTipText = (LPWSTR) HeapAlloc( GetProcessHeap( ), 0, cchTipTextSize * sizeof(WCHAR) );
    if ( NULL != pszTipText )
    {
        //  UI only - don't care if it gets truncated
        StringCchPrintf( pszTipText, cchTipTextSize, g_szfmtCPU, g_CPUUsage );
    }

    BOOL b = PostThreadMessage( g_idTrayThread, PM_NOTIFYWAITING, iIconIndex, (LPARAM) pszTipText );
    if ( !b )
    {
        HeapFree( GetProcessHeap( ), 0, pszTipText );
    }

    UpdateStatusBar();
}

/*++ MainWnd_OnInitDialog

Routine Description:

    Processes WM_INITDIALOG for the main window (a modeless dialog)
    
Revision History:

      Nov-29-95 Davepl  Created

--*/

BOOL MainWnd_OnInitDialog(HWND hwnd)
{
    RECT rcMain;
    GetWindowRect(hwnd, &rcMain);

    g_minWidth  = rcMain.right - rcMain.left;
    g_minHeight = rcMain.bottom - rcMain.top;

    g_DefSpacing   = (DEFSPACING_BASE   * LOWORD(GetDialogBaseUnits())) / DLG_SCALE_X;
    g_InnerSpacing = (INNERSPACING_BASE * LOWORD(GetDialogBaseUnits())) / DLG_SCALE_X; 
    g_TopSpacing   = (TOPSPACING_BASE   * HIWORD(GetDialogBaseUnits())) / DLG_SCALE_Y;

    g_ControlWidthSpacing  = (CONTROL_WIDTH_SPACING  * LOWORD(GetDialogBaseUnits())) / DLG_SCALE_X; 
    g_ControlHeightSpacing = (CONTROL_HEIGHT_SPACING * HIWORD(GetDialogBaseUnits())) / DLG_SCALE_Y;

    // Load the user's defaults

    g_Options.Load();

    //
    // On init, save away the window handle for all to see
    //

    g_hMainWnd = hwnd;
    g_hMainDesktop = GetThreadDesktop(GetCurrentThreadId());

    // init some globals

    g_cxEdge = GetSystemMetrics(SM_CXEDGE);
    g_hrgnView = CreateRectRgn(0, 0, 0, 0);
    g_hrgnClip = CreateRectRgn(0, 0, 0, 0);
    g_hbrWindow = CreateSolidBrush(GetSysColor(COLOR_WINDOW));

    // If we're supposed to be TOPMOST, start out that way

    if (g_Options.m_fAlwaysOnTop)
    {
        SetWindowPos(hwnd, HWND_TOPMOST, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
    }

    //        
    // Create the status window
    //

    g_hStatusWnd = CreateStatusWindow(WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE | SBARS_SIZEGRIP,
                                      NULL,
                                      hwnd,
                                      IDC_STATUSWND);
    if (NULL == g_hStatusWnd)
    {
        return FALSE;
    }

    //
    // Base the panes in the status bar off of the LOGPIXELSX system metric
    //

    HDC hdc = GetDC(NULL);
    INT nInch = GetDeviceCaps(hdc, LOGPIXELSX);
    ReleaseDC(NULL, hdc);

    int ciParts[] = {             nInch, 
                     ciParts[0] + (nInch * 5) / 4, 
                     ciParts[1] + (nInch * 5) / 2, 
                     -1};

    if (g_hStatusWnd) 
    {
        SendMessage(g_hStatusWnd, SB_SETPARTS, ARRAYSIZE(ciParts), (LPARAM)ciParts);
    }

    //
    // Load our app icon
    //

    HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN));
    if (hIcon)
    {
        SendMessage(hwnd, WM_SETICON, TRUE, LPARAM(hIcon));
    }

    //
    //  Add the tray icons using the tray thread.
    //

    PostThreadMessage( g_idTrayThread, PM_INITIALIZEICONS, 0, 0 );

    //
    // Turn on TOPMOST for the status bar so it doesn't slide under the
    // tab control
    //

    SetWindowPos(g_hStatusWnd,
                 HWND_TOPMOST,
                 0,0,0,0,
                 SWP_NOMOVE | SWP_NOSIZE | SWP_NOACTIVATE | SWP_NOREDRAW);

    //
    // Intialize each of the the pages in turn
    //

    HWND hwndTabs = GetDlgItem(hwnd, IDC_TABS);

    for (int i = 0; i < g_nPageCount; i++)
    {
        HRESULT hr;
                
        hr = g_pPages[i]->Initialize(hwndTabs);

        if (SUCCEEDED(hr))
        {
            //
            // Get the title of the new page, and use it as the title of
            // the page which we insert into the tab control
            //

            WCHAR szTitle[MAX_PATH];
            
            g_pPages[i]->GetTitle(szTitle, ARRAYSIZE(szTitle));

            TC_ITEM tcitem =
            {
                TCIF_TEXT,          // value specifying which members to retrieve or set 
                NULL,               // reserved; do not use 
                NULL,               // reserved; do not use 
                szTitle,            // pointer to string containing tab text 
                ARRAYSIZE(szTitle), // size of buffer pointed to by the pszText member 
                0,                  // index to tab control's image 
                NULL                // application-defined data associated with tab 
            };

            //
            //  If the item doesn't get inserted, no harm - no foul. He just sits out
            //  this game.
            //
            TabCtrl_InsertItem(hwndTabs, i, &tcitem);
        }
        else
        {
            //
            //  Bail! All the tabs must at least initialize.
            //
            TerminateProcess( GetCurrentProcess(), 0 );
        }
    }

    //
    // Set the inital menu states
    //

    UpdateMenuStates();

    //
    // Activate a page (pick page 0 if no preference is set)
    //

    if (g_Options.m_iCurrentPage < 0 || g_Options.m_iCurrentPage >= g_nPageCount )
    {
        g_Options.m_iCurrentPage = 0;
    }
    
    TabCtrl_SetCurSel(GetDlgItem(g_hMainWnd, IDC_TABS), g_Options.m_iCurrentPage);
    
    g_pPages[g_Options.m_iCurrentPage]->Activate();

    RECT rcMainClient;
    GetClientRect(hwnd, &rcMainClient);
    MainWnd_OnSize(g_hMainWnd, 0, rcMainClient.right - rcMainClient.left, rcMainClient.bottom - rcMainClient.top);

    //
    // Create the update timer
    //

    if (g_Options.m_dwTimerInterval)        // 0 == paused
    {
        SetTimer(g_hMainWnd, 0, g_Options.m_dwTimerInterval, NULL);
    }
    
    // Force at least one intial update so that we don't need to wait
    // for the first timed update to come through

    MainWnd_OnTimer(g_hMainWnd);

    //
    // Disable the MP-specific menu items
    //

    if (g_cProcessors <= 1)
    {
        HMENU hMenu = GetMenu(g_hMainWnd);
        EnableMenuItem(hMenu, IDM_MULTIGRAPH, MF_BYCOMMAND | MF_GRAYED);
    }

    return TRUE;   // have the system set the default focus.
}

//
// Draw an edge just below menu bar
//
void MainWnd_Draw(HWND hwnd, HDC hdc)
{
    RECT rc;
    GetClientRect(hwnd, &rc);
    DrawEdge(hdc, &rc, EDGE_ETCHED, BF_TOP);
}

void MainWnd_OnPrintClient(HWND hwnd, HDC hdc)
{
    MainWnd_Draw(hwnd, hdc);
}

/*++ MainWnd_OnPaint

Routine Description:

    Just draws a thin edge just below the main menu bar
    
Arguments:

    hwnd    - Main window

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnPaint(HWND hwnd)
{
    PAINTSTRUCT ps;

    //
    // Don't waste our time if we're minimized
    //

    if (FALSE == IsIconic(hwnd))
    {
        BeginPaint(hwnd, &ps);
        MainWnd_Draw(hwnd, ps.hdc);
        EndPaint(hwnd, &ps);
    }
    else
    {
        FORWARD_WM_PAINT(hwnd, DefWindowProc);
    }
}


/*++ MainWnd_OnMenuSelect

Routine Description:

    As the user browses menus in the app, writes help text to the
    status bar.  Also temporarily sets it to be a plain status bar
    with no panes

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnMenuSelect(HWND /*hwnd*/, HMENU hmenu, int item, HMENU /*hmenuPopup*/, UINT flags)
{
    //
    // If menu is dismissed, restore the panes in the status bar, turn off the
    // global "menu tracking" flag, and redraw the status bar with normal info
    //

    if ((0xFFFF == LOWORD(flags) && NULL == hmenu) ||       // dismissed the menu
        (flags & (MF_SYSMENU | MF_SEPARATOR)))              // sysmenu or separator
    {
        SendMessage(g_hStatusWnd, SB_SIMPLE, FALSE, 0L);    // Restore sb panes
        g_fMenuTracking = FALSE;
        g_fCantHide = FALSE;
        UpdateStatusBar();
        return;
    }
    else
    {
        //
        // If its a popup, go get the submenu item that is selected instead
        //

        if (flags & MF_POPUP)
        {
            MENUITEMINFO miiSubMenu;

            miiSubMenu.cbSize = sizeof(MENUITEMINFO);
            miiSubMenu.fMask = MIIM_ID;
            miiSubMenu.cch = 0;             

            if (FALSE == GetMenuItemInfo(hmenu, item, TRUE, &miiSubMenu))
            {
                return;
            }

            //
            // Change the parameters to simulate a "normal" menu item
            //

            item = miiSubMenu.wID;
            flags &= ~MF_POPUP;
        }

        //
        // Our menus always have the same IDs as the strings that describe
        // their functions... 
        //

        WCHAR szStatusText[MAX_PATH];
        LoadString(g_hInstance, item, szStatusText, ARRAYSIZE(szStatusText));

        g_fMenuTracking = TRUE;

        SendMessage(g_hStatusWnd, SB_SETTEXT, SBT_NOBORDERS | 255, (LPARAM)szStatusText);
        SendMessage(g_hStatusWnd, SB_SIMPLE, TRUE, 0L);  // Remove sb panes
        SendMessage(g_hStatusWnd, SB_SETTEXT, SBT_NOBORDERS | 0, (LPARAM) szStatusText);
    }
}

/*++ MainWnd_OnTabCtrlNotify

Routine Description:

    Handles WM_NOTIFY messages sent to the main window on behalf of the
    tab control

Arguments:

    pnmhdr - ptr to the notification block's header

Return Value:

    BOOL - depends on message

Revision History:

      Nov-29-95 Davepl  Created

--*/

BOOL MainWnd_OnTabCtrlNotify(LPNMHDR pnmhdr)
{
    HWND hwndTab = pnmhdr->hwndFrom;

    //
    // Selection is changing (new page coming to the front), so activate
    // the appropriate page
    //

    if (TCN_SELCHANGE == pnmhdr->code)
    {
        INT iTab = TabCtrl_GetCurSel(hwndTab);
        
        if (-1 != iTab)
        {
            if (-1 != g_Options.m_iCurrentPage)
            {
                g_pPages[g_Options.m_iCurrentPage]->Deactivate();
            }

            if (FAILED(g_pPages[iTab]->Activate()))
            {
                // If we weren't able to activate the new page,
                // reactivate the old page just to be sure

                if (-1 != g_Options.m_iCurrentPage)
                {
                    g_pPages[iTab]->Activate();                    
                    SizeChildPage(g_hMainWnd);
                }

            }
            else
            {
                g_Options.m_iCurrentPage = iTab;
                SizeChildPage(g_hMainWnd);
                return TRUE;
            }
        }
    }
    return FALSE;    
}

/*++ MainWnd_OnSize

Routine Description:

    Sizes the children of the main window as the size of the main
    window itself changes

Arguments:

    hwnd    - main window
    state   - window state (not used here)
    cx      - new x size
    cy      - new y size

Return Value:

    BOOL - depends on message

Revision History:

      Nov-29-95 Davepl  Created

--*/

void MainWnd_OnSize(HWND hwnd, UINT state, int cx, int cy)
{
    if (state == SIZE_MINIMIZED)
    {
        // If there's a tray, we can just hide since we have a
        // tray icon anyway.

        if (GetShellWindow() && g_Options.m_fHideWhenMin)
        {
            ShowWindow(hwnd, SW_HIDE);
        }
    }

    //
    // Let the status bar adjust itself first, and we will work back
    // from its new position
    //

    HDWP hdwp = BeginDeferWindowPos(20);

    FORWARD_WM_SIZE(g_hStatusWnd, state, cx, cy, SendMessage);

    if (hdwp)
    {
        RECT rcStatus;
        GetClientRect(g_hStatusWnd, &rcStatus);
        MapWindowPoints(g_hStatusWnd, g_hMainWnd, (LPPOINT) &rcStatus, 2);

        //
        // Size the tab controls based on where the status bar is
        //

        HWND hwndTabs = GetDlgItem(hwnd, IDC_TABS);
        RECT rcTabs;
        GetWindowRect(hwndTabs, &rcTabs);
        MapWindowPoints(HWND_DESKTOP, g_hMainWnd, (LPPOINT) &rcTabs, 2);
    
        INT dx = cx - 2 * rcTabs.left;
    
        DeferWindowPos(hdwp, hwndTabs, NULL, 0, 0, 
                      dx, 
                      cy - (cy - rcStatus.top) - rcTabs.top * 2,
                      SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

        EndDeferWindowPos(hdwp);
    }

    //
    // Now size the front page and its children
    //

    if (cx || cy)               // Don't size in minimized case
        SizeChildPage(hwnd);   
}

/*++ RunDlg

Routine Description:

    Loads shell32.dll and invokes its Run dialog

Arguments:

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/
void RunDlg()
{
    //
    // Put up the RUN dialog for the user
    //

    HICON hIcon = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_MAIN), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR | LR_DEFAULTSIZE);
    if (hIcon)
    {
        WCHAR szCurDir[MAX_PATH];
        WCHAR szTitle [MAX_PATH];
        WCHAR szPrompt[MAX_PATH];

        LoadStringW(g_hInstance, IDS_RUNTITLE, szTitle, MAX_PATH);
        LoadStringW(g_hInstance, IDS_RUNTEXT, szPrompt, MAX_PATH);
        GetCurrentDirectoryW(MAX_PATH, szCurDir);

        RunFileDlg(g_hMainWnd, hIcon, (LPTSTR) szCurDir, 
                                (LPTSTR) szTitle, 
                                (LPTSTR) szPrompt, RFD_USEFULLPATHDIR | RFD_WOW_APP);

        DestroyIcon(hIcon);
    }
}

//  --------------------------------------------------------------------------
//  DeterminePowerCapabilities
//
//  Arguments:  pfHasHibernate  =   Has hibernate capability.
//              pfHasSleep      =   Has sleep capability.
//              pfHasPowerOff   =   Has power off capability.
//
//  Returns:    <none>
//
//  Purpose:    Returns whether power capabilities are present. Specify NULL
//              for power capabilities not required.
//
//  History:    2000-02-29  vtan        created
//  --------------------------------------------------------------------------

void    DeterminePowerCapabilities (BOOL *pfHasHibernate, BOOL *pfHasSleep, BOOL *pfHasPowerOff)

{
    static  BOOL    s_fHasHibernate     =   FALSE;
    static  BOOL    s_fHasSleep         =   FALSE;
    static  BOOL    s_fHasPowerOff      =   FALSE;

    SYSTEM_POWER_CAPABILITIES   spc;
    NTSTATUS status;

    CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

    status = NtPowerInformation( SystemPowerCapabilities, NULL, 0, &spc, sizeof(spc));
    if ( NOERROR == status )
    {
        if (pfHasHibernate != NULL)
        {
            *pfHasHibernate = spc.SystemS4 && spc.HiberFilePresent;
        }
        if (pfHasSleep != NULL)
        {
            *pfHasSleep = spc.SystemS1 || spc.SystemS2 || spc.SystemS3;
        }
        if (pfHasPowerOff != NULL)
        {
            *pfHasPowerOff = spc.SystemS5;
        }
    }
    //
    //  otherwize leave out parameters in their "caller initialize" state.
    //
}

//  --------------------------------------------------------------------------
//  LoadEjectFunction
//
//  Arguments:  <none>
//
//  Returns:    <none>
//
//  Purpose:    Loads cfgmgr32 and gets the address of CM_Request_Eject_PC.
//              It does NOT free the library intentionally.
//
//  History:    2000-04-03  vtan        created
//  --------------------------------------------------------------------------

void    LoadEjectFunction (void)

{
    static  BOOL    s_fAttempted    =   FALSE;

    if ((gpfnCM_Request_Eject_PC == NULL) && (s_fAttempted == FALSE))
    {
        s_fAttempted = TRUE;

        HMODULE hModule = LoadLibrary(L"cfgmgr32");
        if (hModule != NULL)
        {
            gpfnCM_Request_Eject_PC = reinterpret_cast<PFNCM_REQUEST_EJECT_PC>(GetProcAddress(hModule, "CM_Request_Eject_PC"));
        }
    }
}

//  --------------------------------------------------------------------------
//  AdjustMenuBar
//
//  Arguments:  hMenu   =   Handle to the main menu.
//
//  Returns:    <none>
//
//  Purpose:    Removes the shutdown menu in the case of classic GINA logon.
//
//  History:    2000-02-29  vtan        created (split AdjustShutdownMenu)
//              2000-04-24  vtan        split RemoveShutdownMenu
//  --------------------------------------------------------------------------

void AdjustMenuBar (HMENU hMenu)

{
    if( !IsOS(OS_FRIENDLYLOGONUI))
    {
        //
        //  Classic GINA UI - Find the "shutdown" menu and remove it.
        //

        MENUITEMINFO mii;

        ZeroMemory(&mii, sizeof(mii));
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_ID;

        int iMenuItemCount = GetMenuItemCount(hMenu);
        for ( int i = 0; i < iMenuItemCount; i++ ) 
        {
            if ( GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE
              && IDM_MENU_SHUTDOWN == mii.wID
               )
            {
                RemoveMenu(hMenu, i, MF_BYPOSITION);
                return; // done
            }
        }
    }
}

//  --------------------------------------------------------------------------
//  AdjustShutdownMenu
//
//  Arguments:  hMenu   =   Handle to the main menu.
//
//  Returns:    <none>
//
//  Purpose:    Dynamically replaces the entire contents of the "Shut Down"
//              popup menu and adjusts the enabled items based on user token
//              privileges as well as machine capabilities. This is done
//              dynamically to allow console disconnect and remoting to be
//              correctly reflected in the state without restarting taskmgr.
//
//  History:    2000-02-29  vtan        created
//              2000-03-29  vtan        reworked for new menu
//  --------------------------------------------------------------------------

void AdjustShutdownMenu (HMENU hMenu)

//  Adjusts the shutdown menu in the menu bar to reflect the machine
//  capabilities and user privileges. Items that aren't accessible
//  are disabled or removed. The menu contains the following:

//  MENUITEM "Stand &By"                    IDM_STANDBY                 SE_SHUTDOWN_PRIVILEGE && S1-S3  !NoClose
//  MENUITEM "&Hibernate"                   IDM_HIBERNATE               SE_SHUTDOWN_PRIVILEGE && S4     !NoClose
//  MENUITEM "Sh&ut Down"                   IDM_SHUTDOWN                SE_SHUTDOWN_PRIVILEGE           !NoClose
//  MENUITEM "&Restart"                     IDM_RESTART                 SE_SHUTDOWN_PRIVILEGE           !NoClose
//  MENUITEM "&Log Off <user>"              IDM_LOGOFF_CURRENTUSER      <everyone>                      !NoClose && !NoLogoff
//  MENUITEM "&Switch User"                 IDM_SWITCHUSER              <everyone>                      !Remote && !NoDisconnect
//  MENUITEM "&Disconnect"                  IDM_DISCONNECT_CURRENTUSER  <everyone>                      Remote && !NoDisconnect
//  MENUITEM "&Eject Computer"              IDM_EJECT                   SE_UNDOCK_PRIVILEGE
//  MENUITEM "Loc&k Computer"               IDM_LOCKWORKSTATION         <everyone>                      !DisableLockWorkstation

{
    int             i, iMenuItemCount;
    BOOL            fFound;
    MENUITEMINFO    mii;

    //
    //  First find the "Shut Down" menu item in the given menu bar.
    //

    ZeroMemory(&mii, sizeof(mii));
    mii.cbSize = sizeof(mii);

    iMenuItemCount = GetMenuItemCount(hMenu);
    for (fFound = FALSE, i = 0; !fFound && (i < iMenuItemCount); ++i)
    {
        mii.fMask = MIIM_ID;
        if ( GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE
          && IDM_MENU_SHUTDOWN == mii.wID 
           )
        {
            fFound = TRUE;

            //
            //  Once found get the submenu currently in place for it.
            //

            mii.fMask = MIIM_SUBMENU;
            if (GetMenuItemInfo(hMenu, i, TRUE, &mii) != FALSE)
            {
                //
                //  If one exists then remove it.
                //

                if (mii.hSubMenu != NULL)
                {
                    DestroyMenu(mii.hSubMenu);
                }

                //
                //  Now replace it with the freshly loaded menu.
                //

                mii.hSubMenu = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_POPUP_SHUTDOWN));
                if ( NULL != mii.hSubMenu )
                {
                    BOOL b = SetMenuItemInfo(hMenu, i, TRUE, &mii);
                    if ( !b )
                    {
                        b = DestroyMenu( mii.hSubMenu );
                        // what happens if this fails?
                    }
                }
            }
        }
    }

    //  Now adjust the options based on privilege and availability if the
    //  menu was replaced with a fresh menu. Otherwise this menu has been
    //  removed because the machine is in classic GINA mode.

    if (fFound)
    {
        BOOL    fHasHibernate, fHasSleep, fHasShutdownPrivilege, fIsRemote, fIsDocked,
                fPolicyDisableLockWorkstation, fPolicyNoLogoff, fPolicyNoClose, fPolicyNoDisconnect;
        WCHAR   szMenuString[256];

        //  Friendly UI is active - adjust shutdown menu enabled/disabled items.
        //  This can be more efficient but for making the logic clear and easy to
        //  understand it is multiple tests.

        fHasHibernate = FALSE;
        fHasSleep = FALSE;

        DeterminePowerCapabilities(&fHasHibernate, &fHasSleep, NULL);
        LoadEjectFunction();

        fHasShutdownPrivilege = (SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME) != FALSE);
        fIsRemote = GetSystemMetrics(SM_REMOTESESSION);
        fIsDocked = (SHGetMachineInfo(GMI_DOCKSTATE) == GMID_DOCKED);

        //
        //  System/Explorer policies to be respected.
        //

        fPolicyDisableLockWorkstation = fPolicyNoLogoff = fPolicyNoClose = fPolicyNoDisconnect = FALSE;
        {
            HKEY    hKey;
            DWORD   dwValue, dwValueSize;

            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                              TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies\\system"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey))
            {
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("DisableLockWorkstation"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyDisableLockWorkstation = (dwValue != 0);
                }
                RegCloseKey(hKey);
            }
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER,
                                              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\Explorer"),
                                              0,
                                              KEY_QUERY_VALUE,
                                              &hKey))
            {
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("DisableLockWorkstation"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyDisableLockWorkstation = fPolicyDisableLockWorkstation || (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoLogoff"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoLogoff = (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoClose"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoClose = (dwValue != 0);
                }
                dwValueSize = sizeof(dwValue);
                if (ERROR_SUCCESS == RegQueryValueEx(hKey,
                                                     TEXT("NoDisconnect"),
                                                     NULL,
                                                     NULL,
                                                     reinterpret_cast<LPBYTE>(&dwValue),
                                                     &dwValueSize))
                {
                    fPolicyNoDisconnect = (dwValue != 0);
                }
                RegCloseKey(hKey);
            }
        }

        //  IDM_STANDBY

        if (!fHasShutdownPrivilege || !fHasSleep || fIsRemote || fPolicyNoClose)
        {
            EnableMenuItem(hMenu, IDM_STANDBY, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_HIBERNATE

        if (!fHasShutdownPrivilege || !fHasHibernate || fIsRemote || fPolicyNoClose)
        {
            EnableMenuItem(hMenu, IDM_HIBERNATE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_SHUTDOWN

        if (!fHasShutdownPrivilege || fPolicyNoClose)
        {
            EnableMenuItem(hMenu, IDM_SHUTDOWN, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_RESTART

        if (!fHasShutdownPrivilege || fPolicyNoClose)
        {
            EnableMenuItem(hMenu, IDM_RESTART, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_LOGOFF_CURRENTUSER

        //  This expects "Log Off %s and End Session". It will fill in the
        //  %s with the display name. If no display name is present then it
        //  will use the login name. If the string insertions fail for some
        //  reason then it will remove the "%s" by searching for it and
        //  copying the rest of the string over it.

        mii.fMask = MIIM_TYPE;
        mii.dwTypeData = szMenuString;
        mii.cch = ARRAYSIZE(szMenuString);
        if (GetMenuItemInfo(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND ,&mii) != FALSE)
        {
            WCHAR   szDisplayName[UNLEN + 1];
            WCHAR   szTemp[256 + UNLEN + 1];

            *szDisplayName = TEXT('\0');

            ULONG cchLen = ARRAYSIZE(szDisplayName);
            SHGetUserDisplayName(szDisplayName, &cchLen); // Ignore errors.

            HRESULT hr = StringCchPrintf(szTemp, ARRAYSIZE(szTemp), szMenuString, szDisplayName);
            if (SUCCEEDED( hr ))
            {
                StringCchCopy( szMenuString, ARRAYSIZE(szMenuString), szTemp );
            }
            else
            {
                WCHAR   *pszSubString;

                pszSubString = StrStrI(szMenuString, TEXT("%s "));
                if (pszSubString != NULL)
                {
                    *pszSubString = L'\0'; // terminate
                    StringCchCopy( szTemp, ARRAYSIZE(szTemp), szMenuString );
                    StringCchCat( szTemp, ARRAYSIZE(szTemp), pszSubString + 3 );
                }
            }

            SetMenuItemInfo(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND, &mii);
        }

        if ((SHRestricted(REST_STARTMENULOGOFF) == 1) || fPolicyNoClose || fPolicyNoLogoff)
        {
            EnableMenuItem(hMenu, IDM_LOGOFF_CURRENTUSER, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
        }

        //  IDM_SWITCHUSER
        if (fIsRemote || !IsOS(OS_FASTUSERSWITCHING) || fPolicyNoDisconnect)
        {
            DeleteMenu(hMenu, IDM_SWITCHUSER, MF_BYCOMMAND);
        }

        //  IDM_DISCONNECT_CURRENTUSER

        if (!fIsRemote || !IsOS(OS_FASTUSERSWITCHING) || fPolicyNoDisconnect)
        {
            DeleteMenu(hMenu, IDM_DISCONNECT_CURRENTUSER, MF_BYCOMMAND);
        }

        //  IDM_EJECT

        if (!fIsDocked || (SHTestTokenPrivilege(NULL, SE_UNDOCK_NAME) == FALSE) || (gpfnCM_Request_Eject_PC == NULL))
        {
            DeleteMenu(hMenu, IDM_EJECT, MF_BYCOMMAND);
        }

        //  IDM_LOCKWORKSTATION

        if (fIsRemote || IsOS(OS_FASTUSERSWITCHING) || fPolicyDisableLockWorkstation)
        {
            DeleteMenu(hMenu, IDM_LOCKWORKSTATION, MF_BYCOMMAND);
        }
    }
}

//  --------------------------------------------------------------------------
//  PowerActionThreadProc
//
//  Arguments:  pv = POWER_ACTION to invoke
//
//  Returns:    DWORD
//
//  Purpose:    Invokes NtInitiatePowerAction on a different thread so that
//              the UI thread is not blocked.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  PowerActionThreadProc (void* pv)

{
    POWER_ACTION pa = (POWER_ACTION)PtrToInt(pv);

    CPrivilegeEnable privilege(SE_SHUTDOWN_NAME);

    NTSTATUS status = NtInitiatePowerAction(pa,
                                            PowerSystemSleeping1,
                                            POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED,
                                            FALSE);

    return NT_SUCCESS(status);
}

//  --------------------------------------------------------------------------
//  CreatePowerActionThread
//
//  Arguments:  paPowerAction   =   POWER_ACTION to invoke.
//
//  Returns:    <none>
//
//  Purpose:    Creates the thread that invokes NtInitiatePowerAction on a
//              different thread. If thread creation fails then do the code
//              inline. It can't be invoked because the memory allocation
//              could fail so the code is copied.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

void    CreatePowerActionThread (POWER_ACTION paPowerAction)
{
    DWORD dwThreadID;

    HANDLE hThread = CreateThread(NULL,
                                  0,
                                  PowerActionThreadProc,
                                  (void*)paPowerAction,
                                  0,
                                  &dwThreadID);
    if (hThread != NULL)
    {
        CloseHandle(hThread);
    }
    else
    {
        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        NtInitiatePowerAction(paPowerAction,
                              PowerSystemSleeping1,
                              POWER_ACTION_QUERY_ALLOWED | POWER_ACTION_UI_ALLOWED,
                              FALSE
                              );
    }
}

//  --------------------------------------------------------------------------
//  ExitWindowsThreadProc
//
//  Arguments:  pv = uiFlags
//
//  Returns:    DWORD
//
//  Purpose:    Invokes ExitWindowsEx on a different thread so that
//              the UI thread is not blocked.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

DWORD   WINAPI  ExitWindowsThreadProc (void *pv)
{
    UINT uiFlags = PtrToUint(pv);

    CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

    BOOL bRet = ExitWindowsEx(uiFlags, 0);

    return (DWORD)bRet;
}

//  --------------------------------------------------------------------------
//  CreateExitWindowsThread
//
//  Arguments:  uiFlags     =   EWX_ flag to pass to ExitWindowsEx.
//
//  Returns:    <none>
//
//  Purpose:    Creates the thread that invokes ExitWindowsEx on a
//              different thread. If thread creation fails then do the code
//              inline. It can't be invoked because the memory allocation
//              could fail so the code is copied.
//
//  History:    2000-04-05  vtan        created
//  --------------------------------------------------------------------------

void    CreateExitWindowsThread (UINT uiFlags)
{
    DWORD   dwThreadID;
    HANDLE  hThread;

    hThread = CreateThread(NULL,
                           0,
                           ExitWindowsThreadProc,
                           UintToPtr(uiFlags),
                           0,
                           &dwThreadID);
    if (hThread != NULL)
    {
        CloseHandle(hThread);
    }
    else
    {
        CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

        ExitWindowsEx(uiFlags, 0);
    }
}

//  --------------------------------------------------------------------------
//  ExecuteShutdownMenuOption
//
//  Arguments:  hwnd    =   Parent HWND if a dialog is required.
//              iID     =   ID of menu item to execute.
//
//  Returns:    <none>
//
//  Purpose:    Executes the given shut down menu option doing the right
//              thing if prompting is required.
//
//  History:    2000-03-29  vtan        created
//  --------------------------------------------------------------------------

void ExecuteShutdownMenuOption(int iID)
{
    switch (iID)
    {
    case IDM_STANDBY:        
        CreatePowerActionThread(PowerActionSleep);
        break;

    case IDM_HIBERNATE:
        CreatePowerActionThread(PowerActionHibernate);
        break;

    case IDM_SHUTDOWN:
        {
            BOOL fControlKey = (GetAsyncKeyState(VK_CONTROL) < 0);
            if (fControlKey)
            {
                CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

                NtShutdownSystem(ShutdownPowerOff);
            }
            else
            {
                BOOL    fHasPowerOff = FALSE;
                UINT    uiFlags;

                DeterminePowerCapabilities(NULL, NULL, &fHasPowerOff);
                if (fHasPowerOff != FALSE)
                {
                    uiFlags = EWX_POWEROFF;
                }
                else
                {
                    uiFlags = EWX_SHUTDOWN;
                }
                CreateExitWindowsThread(uiFlags);
            }
        }
        break;

    case IDM_RESTART:
        {
            BOOL fControlKey = (GetAsyncKeyState(VK_CONTROL) < 0);
            if (fControlKey)
            {
                CPrivilegeEnable    privilege(SE_SHUTDOWN_NAME);

                NtShutdownSystem(ShutdownReboot);
            }
            else
            {
                CreateExitWindowsThread(EWX_REBOOT);
            }
        }
        break;

    case IDM_LOGOFF_CURRENTUSER:
        ExitWindowsEx(EWX_LOGOFF, 0);
        break;

    case IDM_SWITCHUSER:
    case IDM_DISCONNECT_CURRENTUSER:
        ShellSwitchUser(FALSE);
        break;

    case IDM_EJECT:
        gpfnCM_Request_Eject_PC();
        break;

    case IDM_LOCKWORKSTATION:
        LockWorkStation();
        break;
    }
}


/*++ MainWnd_OnCommand

Routine Description:

    Processes WM_COMMAND messages received at the main window

Revision History:

      Nov-30-95 Davepl  Created

--*/

void MainWnd_OnCommand(HWND hwnd, int id)
{
    switch (id)
    {
    case IDM_HIDE:
        ShowWindow(hwnd, SW_MINIMIZE);
        break;

    case IDM_HELP:
        HtmlHelpA(GetDesktopWindow(), "taskmgr.chm", HH_DISPLAY_TOPIC, 0);
        break;

    case IDCANCEL:
    case IDM_EXIT:
        DestroyWindow(hwnd);
        break;

    case IDM_RESTORETASKMAN:
        ShowRunningInstance();
        break;

    //
    // these guys need to get forwarded to the page for handling
    //

    case IDC_SWITCHTO:
    case IDC_BRINGTOFRONT:
    case IDC_ENDTASK:
        switch (g_Options.m_iCurrentPage)
        {
        case PROC_PAGE:
            {
                // procpage only deals with ENDTASK, but will ignore the others
                CProcPage * pPage = ((CProcPage *) (g_pPages[PROC_PAGE]));
                pPage->HandleWMCOMMAND(LOWORD(id), NULL);
            }
            break;

        case TASK_PAGE:
            {
                CTaskPage * pPage = ((CTaskPage *) (g_pPages[TASK_PAGE]));
                pPage->HandleWMCOMMAND(id);
            }
            break;
        }
        break;

    case IDC_NEXTTAB:
    case IDC_PREVTAB:
        {
            INT iPage = g_Options.m_iCurrentPage;
            iPage += (id == IDC_NEXTTAB) ? 1 : -1;

            iPage = iPage < 0 ? g_nPageCount - 1 : iPage;
            iPage = iPage >= g_nPageCount ? 0 : iPage;

            // Activate the new page.  If it fails, revert to the current

            TabCtrl_SetCurSel(GetDlgItem(g_hMainWnd, IDC_TABS), iPage);

            // SetCurSel doesn't do the page change (that would make too much
            // sense), so we have to fake up a TCN_SELCHANGE notification

            NMHDR nmhdr;
            nmhdr.hwndFrom = GetDlgItem(g_hMainWnd, IDC_TABS);
            nmhdr.idFrom   = IDC_TABS;
            nmhdr.code     = TCN_SELCHANGE;

            if (MainWnd_OnTabCtrlNotify(&nmhdr))
            {
                g_Options.m_iCurrentPage = iPage;
            }
        }
        break;

    case IDM_ALWAYSONTOP:
        g_Options.m_fAlwaysOnTop = !g_Options.m_fAlwaysOnTop;
        SetWindowPos(hwnd, g_Options.m_fAlwaysOnTop ? HWND_TOPMOST : HWND_NOTOPMOST, 
                        0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
        UpdateMenuStates();
        break;

    case IDM_HIDEWHENMIN:
        g_Options.m_fHideWhenMin = !g_Options.m_fHideWhenMin;
        UpdateMenuStates();
        break;

    case IDM_MINIMIZEONUSE:
        g_Options.m_fMinimizeOnUse = !g_Options.m_fMinimizeOnUse;
        UpdateMenuStates();
        break;

    case IDM_NOTITLE:
        g_Options.m_fNoTitle = !g_Options.m_fNoTitle;
        UpdateMenuStates();
        SizeChildPage(hwnd);
        break;

    case IDM_SHOW16BIT:
        g_Options.m_fShow16Bit = !g_Options.m_fShow16Bit;
        UpdateMenuStates();
        if ( PROC_PAGE < g_nPageCount )
        {
            g_pPages[PROC_PAGE]->TimerEvent();
        }
        break;

    case IDM_SHOWDOMAINNAMES:
        g_Options.m_fShowDomainNames = !g_Options.m_fShowDomainNames;
        UpdateMenuStates();
        if (USER_PAGE < g_nPageCount )
        {
            g_pPages[USER_PAGE]->TimerEvent();
        }
        break;

    case IDM_HIBERNATE:
    case IDM_SHUTDOWN:
    case IDM_STANDBY:
    case IDM_RESTART:
    case IDM_LOGOFF_CURRENTUSER:
    case IDM_SWITCHUSER:
    case IDM_DISCONNECT_CURRENTUSER:
    case IDM_EJECT:
    case IDM_LOCKWORKSTATION:
        ExecuteShutdownMenuOption(id);
        break;

    case IDM_KERNELTIMES:
        g_Options.m_fKernelTimes = !g_Options.m_fKernelTimes;
        UpdateMenuStates();
        if (PERF_PAGE < g_nPageCount)
        {
            g_pPages[PERF_PAGE]->TimerEvent();
        }
        break;

    case IDM_RUN:
        if (GetKeyState(VK_CONTROL) >= 0)
        {
            RunDlg();
        }
        else
        {
            //
            //  Holding down the CONTROL key and click the RUN menu will
            //  invoke a CMD prompt. This helps work around low memory situations
            //  where trying to load the extra GUI stuff from SHELL32 is too 
            //  heavy weight.
            //

            STARTUPINFO             startupInfo = { 0 };
            PROCESS_INFORMATION     processInformation = { 0 };
            WCHAR                   szCommandLine[MAX_PATH];

            startupInfo.cb = sizeof(startupInfo);
            startupInfo.dwFlags = STARTF_USESHOWWINDOW;
            startupInfo.wShowWindow = SW_SHOWNORMAL;
            if (ExpandEnvironmentStrings(TEXT("\"%ComSpec%\""), szCommandLine, ARRAYSIZE(szCommandLine)) == 0)
            {
                if (ExpandEnvironmentStrings(TEXT("\"%windir%\\system32\\cmd.exe\""), szCommandLine, ARRAYSIZE(szCommandLine)) == 0)
                {
                    StringCchCopy( szCommandLine, ARRAYSIZE(szCommandLine), TEXT("\"cmd.exe\"") );
                }
            }

            if (CreateProcess(NULL,
                              szCommandLine,
                              NULL,
                              NULL,
                              FALSE,
                              CREATE_DEFAULT_ERROR_MODE | CREATE_NEW_PROCESS_GROUP,
                              NULL,
                              NULL,
                              &startupInfo,
                              &processInformation) != FALSE)
            {
                CloseHandle(processInformation.hThread);
                CloseHandle(processInformation.hProcess);
            }
        }
        break;

    case IDM_SMALLICONS:
    case IDM_DETAILS:
    case IDM_LARGEICONS:
        g_Options.m_vmViewMode = (VIEWMODE) (id - VM_FIRST);
        UpdateMenuStates();
        if (TASK_PAGE < g_nPageCount)
        {
            g_pPages[TASK_PAGE]->TimerEvent();
        }
        break;

    //
    // The following few messages get deferred off to the task page
    //

    case IDM_TASK_CASCADE:
    case IDM_TASK_MINIMIZE:
    case IDM_TASK_MAXIMIZE:
    case IDM_TASK_TILEHORZ:
    case IDM_TASK_TILEVERT:
    case IDM_TASK_BRINGTOFRONT:
        SendMessage(g_pPages[TASK_PAGE]->GetPageWindow(), WM_COMMAND, id, NULL);
        break; 

    case IDM_PROCCOLS:
        if (PROC_PAGE < g_nPageCount)
        {
            ((CProcPage *) (g_pPages[PROC_PAGE]))->PickColumns();
        }
        break;

    case IDM_NETCOL:
        if (NET_PAGE < g_nPageCount)
        {                
            ((CNetPage *) (g_pPages[NET_PAGE]))->PickColumns();
        }
        break;

    case IDM_USERCOLS:
        if (USER_PAGE < g_nPageCount)
        {
            SendMessage(g_pPages[USER_PAGE]->GetPageWindow(), WM_COMMAND, id, NULL);
        }
        break;

    case IDM_ALLCPUS:
    case IDM_MULTIGRAPH:
        g_Options.m_cmHistMode = (CPUHISTMODE) (id - CM_FIRST);
        UpdateMenuStates();
        if (PERF_PAGE < g_nPageCount)
        {
            ((CPerfPage *)(g_pPages[PERF_PAGE]))->UpdateGraphs();
            g_pPages[PERF_PAGE]->TimerEvent();
        }
        break;

    case IDM_REFRESH:
        if (NET_PAGE < g_nPageCount && g_Options.m_iCurrentPage == NET_PAGE)
        {
            ((CNetPage *)(g_pPages[NET_PAGE]))->Refresh();
        }
        MainWnd_OnTimer(hwnd);
        break;

    case IDM_SHOWALLDATA:
        g_Options.m_bNetShowAll = !g_Options.m_bNetShowAll;
        UpdateMenuStates();
        break;

    case IDM_TABALWAYSACTIVE:
        g_Options.m_bTabAlwaysActive = !g_Options.m_bTabAlwaysActive;
        UpdateMenuStates();
        break;

    case IDM_BYTESSENT:
        g_Options.m_bGraphBytesSent = !g_Options.m_bGraphBytesSent;
        UpdateMenuStates();
        MainWnd_OnTimer(hwnd);
        break;

    case IDM_NETRESET:
        if ( NET_PAGE < g_nPageCount)
        {
            ((CNetPage *)(g_pPages[NET_PAGE]))->Reset();
            MainWnd_OnTimer(hwnd);
        }
        break;

    case IDM_SHOWSCALE:
        g_Options.m_bShowScale = !g_Options.m_bShowScale;
        UpdateMenuStates();
        if ( NET_PAGE < g_nPageCount )
        {
            ((CNetPage *)(g_pPages[NET_PAGE]))->SizeNetPage();
        }            
        break;

    case IDM_AUTOSIZE:
        g_Options.m_bAutoSize = !g_Options.m_bAutoSize;
        UpdateMenuStates();
        break;

    case IDM_BYTESRECEIVED:
        g_Options.m_bGraphBytesReceived = !g_Options.m_bGraphBytesReceived;
        UpdateMenuStates();
        break;

    case IDM_BYTESTOTAL:
        g_Options.m_bGraphBytesTotal = !g_Options.m_bGraphBytesTotal;
        UpdateMenuStates();
        break;

    case IDM_HIGH:
    case IDM_NORMAL:
    case IDM_LOW:
    case IDM_PAUSED:
        {
            static const int TimerDelays[] = { 500, 2000, 4000, 0, 0xFFFFFFFF };

            g_Options.m_usUpdateSpeed = (UPDATESPEED) (id - US_FIRST);
            ASSERT(g_Options.m_usUpdateSpeed <= ARRAYSIZE(TimerDelays));

            int cTicks = TimerDelays[ (INT) g_Options.m_usUpdateSpeed ];
            g_Options.m_dwTimerInterval = cTicks;

            KillTimer(g_hMainWnd, 0);
            if (cTicks)
            {
                SetTimer(g_hMainWnd, 0, g_Options.m_dwTimerInterval, NULL);
            }

            UpdateMenuStates();
        }
        break;

    case IDM_ABOUT:
        {
            //
            // Display the "About Task Manager" dialog
            //
        
            HICON hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_MAIN));
            if (hIcon)
            {
                WCHAR szTitle[MAX_PATH];
                LoadString(g_hInstance, IDS_APPTITLE, szTitle, MAX_PATH);
                ShellAbout(hwnd, szTitle, NULL, hIcon);
                DestroyIcon(hIcon);
            }
        }
        break;
    }
}

/*++ CheckParentDeferrals

Routine Description:

    Called by the child pages, each child gives the main parent the
    opportunity to handle certain messages on its behalf

Arguments:

    MSG, WPARAM, LPARAM

Return Value:

    TRUE if parent handle the message on the childs behalf

Revision History:

    Jan-24-95 Davepl  Created

--*/

BOOL CheckParentDeferrals(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
        case WM_RBUTTONDOWN:
        case WM_NCRBUTTONDOWN:
        case WM_RBUTTONUP:
        case WM_NCRBUTTONUP:
        case WM_NCLBUTTONDBLCLK:
        case WM_LBUTTONDBLCLK:
        {
            SendMessage(g_hMainWnd, uMsg, wParam, lParam);
            return TRUE;
        }
    
        default:
            return FALSE;
    }
}

/*++ ShowRunningInstance

Routine Description:

    Brings this running instance to the top, and out of icon state

Revision History:

    Jan-27-95 Davepl  Created

--*/

void ShowRunningInstance()
{
    OpenIcon(g_hMainWnd);
    SetForegroundWindow(g_hMainWnd);
    SetWindowPos(g_hMainWnd, g_Options.m_fAlwaysOnTop ? HWND_TOPMOST : HWND_TOP, 
                 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE);
}

/*++ MainWindowProc

Routine Description:

    Initializes the gloab setting variables. Everytime the settings change this function is called.

Arguments:

    void

Return Value:

Revision History:

      created April 23, 2001 omiller

--*/
void OnSettingsChange()
{
    WCHAR  wszGroupSep[8];    

    GetLocaleInfo(LOCALE_USER_DEFAULT,  LOCALE_STIME,     g_szTimeSep, ARRAYSIZE(g_szTimeSep));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_STHOUSAND, g_szGroupThousSep, ARRAYSIZE(g_szGroupThousSep));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SDECIMAL , g_szDecimal, ARRAYSIZE(g_szDecimal));
    GetLocaleInfoW(LOCALE_USER_DEFAULT, LOCALE_SGROUPING, wszGroupSep, ARRAYSIZE(wszGroupSep));
    g_ulGroupSep = wcstol(wszGroupSep,NULL,10);

}

/*++ MainWindowProc

Routine Description:

    WNDPROC for the main window

Arguments:

    Standard wndproc fare

Return Value:

Revision History:

      Nov-30-95 Davepl  Created

--*/

INT_PTR CALLBACK MainWindowProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    static BOOL fIsHidden = FALSE;

    //
    // If this is a size or a move, update the position in the user's options
    //

    if (uMsg == WM_SIZE || uMsg == WM_MOVE)
    {
        // We don't want to start recording the window pos until we've had
        // a chance to set it to the intialial position, or we'll lose the
        // user's preferences

        if (fAlreadySetPos)
        {
            if (!IsIconic(hwnd) && !IsZoomed(hwnd))
            {
                GetWindowRect(hwnd, &g_Options.m_rcWindow);
            }
        }
    }

    if (uMsg == g_msgTaskbarCreated) 
    {
        // This is done async do taskmgr doesn't hand when the shell
        // is hung

        PostThreadMessage( g_idTrayThread, PM_NOTIFYWAITING, 0, 0 );
    }


    switch(uMsg)
    {
    case WM_PAINT:
        MainWnd_OnPaint(hwnd);
        return TRUE;

    case WM_INITDIALOG:
        return MainWnd_OnInitDialog( hwnd );

    HANDLE_MSG(hwnd, WM_MENUSELECT, MainWnd_OnMenuSelect);
    HANDLE_MSG(hwnd, WM_SIZE,       MainWnd_OnSize);

    case WM_COMMAND:
        MainWnd_OnCommand( hwnd, LOWORD(wParam) );
        break;

    case WM_TIMER:
        MainWnd_OnTimer( hwnd );
        break;

    case WM_PRINTCLIENT:
        MainWnd_OnPrintClient(hwnd, (HDC)wParam);
        break;

    // Don't let the window get too small when the title and
    // menu bars are ON

    case WM_GETMINMAXINFO:
        if (FALSE == g_Options.m_fNoTitle)
        {
            LPMINMAXINFO lpmmi   = (LPMINMAXINFO) lParam;
            lpmmi->ptMinTrackSize.x = g_minWidth;
            lpmmi->ptMinTrackSize.y = g_minHeight;
            return FALSE;
        }
        break;
            
    // Handle notifications from out tray icon

    case PWM_TRAYICON:
        Tray_Notify(hwnd, lParam);
        break;

    // Someone externally is asking us to wake up and be shown
    case PWM_ACTIVATE:
         ShowRunningInstance();            

         // Return PWM_ACTIVATE to the caller as just a little
         // more assurance that we really did handle this
         // message correctly.
         
         SetWindowLongPtr(hwnd, DWLP_MSGRESULT, PWM_ACTIVATE);
         return TRUE;

    case WM_INITMENU:
        AdjustShutdownMenu(reinterpret_cast<HMENU>(wParam));

        // Don't let the right button hide the window during
        // menu operations

        g_fCantHide = TRUE;
        break;

    case WM_NCHITTEST:
        // If we have no title/menu bar, clicking and dragging the client
        // area moves the window. To do this, return HTCAPTION.
        // Note dragging not allowed if window maximized, or if caption
        // bar is present.
        //

        wParam = DefWindowProc(hwnd, uMsg, wParam, lParam);
        if (g_Options.m_fNoTitle && (wParam == HTCLIENT) && !IsZoomed(g_hMainWnd))
        {
            SetWindowLongPtr(hwnd, DWLP_MSGRESULT, HTCAPTION);
            return TRUE;
        }
        return FALSE;       // Not handled

    case WM_NCLBUTTONDBLCLK:
        // If we have no title, an NC dbl click means we should turn
        // them back on

        if (FALSE == g_Options.m_fNoTitle)
        {
            break;
        }
        // Else, fall though

    case WM_LBUTTONDBLCLK:
        {
            g_Options.m_fNoTitle = ~g_Options.m_fNoTitle;

            RECT rcMainWnd;
            GetWindowRect(g_hMainWnd, &rcMainWnd);

            if ( PERF_PAGE < g_nPageCount )
            {
                ((CPerfPage *)(g_pPages[PERF_PAGE]))->UpdateGraphs();
                g_pPages[PERF_PAGE]->TimerEvent();
            }
        
            if ( NET_PAGE < g_nPageCount )
            {
                ((CNetPage *)(g_pPages[NET_PAGE]))->UpdateGraphs();
                g_pPages[NET_PAGE]->TimerEvent();
            }
        
            // Force a WM_SIZE event so that the window checks the min size
            // when coming out of notitle mode

            MoveWindow(g_hMainWnd, 
                       rcMainWnd.left, 
                       rcMainWnd.top, 
                       rcMainWnd.right - rcMainWnd.left,
                       rcMainWnd.bottom - rcMainWnd.top,
                       TRUE);

            SizeChildPage(hwnd);
        }
        break;

    // Someone (the task page) wants us to look up a process in the 
    // process view.  Switch to that page and send it the FINDPROC
    // message

    case WM_FINDPROC:
        if (-1 != TabCtrl_SetCurSel(GetDlgItem(hwnd, IDC_TABS), PROC_PAGE))
        {
            // SetCurSel doesn't do the page change (that would make too much
            // sense), so we have to fake up a TCN_SELCHANGE notification

            NMHDR nmhdr;
            nmhdr.hwndFrom = GetDlgItem(hwnd, IDC_TABS);
            nmhdr.idFrom   = IDC_TABS;
            nmhdr.code     = TCN_SELCHANGE;

            if (MainWnd_OnTabCtrlNotify(&nmhdr))
            {
                if ( g_Options.m_iCurrentPage != -1 )
                {
                    SendMessage( g_pPages[g_Options.m_iCurrentPage]->GetPageWindow(), WM_FINDPROC, wParam, lParam );
                }
            }
        }
        else
        {
            MessageBeep(0);
        }
        break;

    case WM_NOTIFY:
        if ( IDC_TABS == wParam)
        {
                return MainWnd_OnTabCtrlNotify((LPNMHDR) lParam);
        }
        break;
    
    case WM_ENDSESSION:
        if (wParam)
        {
            DestroyWindow(g_hMainWnd);
        }
        break;

    case WM_CLOSE:
        DestroyWindow(g_hMainWnd);
        break;

    case WM_NCDESTROY:
        // If there's a tray thread, tell is to exit

        if (g_idTrayThread)
        {
            PostThreadMessage(g_idTrayThread, PM_QUITTRAYTHREAD, 0, 0);
        }

        // Wait around for some period of time for the tray thread to
        // do its cleanup work.  If the wait times out, worst case we
        // orphan the tray icon.

        if (g_hTrayThread)
        {
            WaitForSingleObject(g_hTrayThread, 3000);
            CloseHandle(g_hTrayThread);
        }
        break;

    case WM_SYSCOLORCHANGE:
    case WM_SETTINGCHANGE:
        {
            // Initialzie the global variables, i.e. comma, decimal time etc
            //
            OnSettingsChange();

            // pass these to the status bar
            SendMessage(g_hStatusWnd, uMsg, wParam, lParam);
        
            // also pass along to the pages
            for (int i = 0; i < g_nPageCount; i++)
            {
                SendMessage(g_pPages[i]->GetPageWindow(), uMsg, wParam, lParam);
            }   

            if (uMsg == WM_SETTINGCHANGE)
            {
                // force a resizing of the main dialog
                RECT rcMainClient;
                GetClientRect(g_hMainWnd, &rcMainClient);
                MainWnd_OnSize(g_hMainWnd, 0, rcMainClient.right - rcMainClient.left, rcMainClient.bottom - rcMainClient.top);
            }            
        }
        break; 

    case WM_DESTROY:
        {       
            // Before shutting down, deactivate the current page, then 
            // destroy all pages

            if ( g_Options.m_iCurrentPage >= 0 && g_Options.m_iCurrentPage < g_nPageCount )
            {
                g_pPages[g_Options.m_iCurrentPage]->Deactivate();
            }

            for (int i = 0; i < g_nPageCount; i++)
            {
                g_pPages[i]->Destroy();
            }

            // Save the current options

            g_Options.Save();

            PostQuitMessage(0);
        }
        break;
    }

    return FALSE;
}

/*++ LoadGlobalResources

Routine Description:

    Loads those resources that are used frequently or that are expensive to
    load a single time at program startup

Return Value:

    BOOLEAN success value

Revision History:

      Nov-30-95 Davepl  Created

--*/

static const struct
{
    LPTSTR  psz;
    DWORD   len;
    UINT    id;
}
g_aStrings[] =
{
    { g_szG,          ARRAYSIZE(g_szG),          IDS_G          },
    { g_szM,          ARRAYSIZE(g_szM),          IDS_M          },
    { g_szK,          ARRAYSIZE(g_szK),          IDS_K          },
    { g_szBitsPerSec, ARRAYSIZE(g_szBitsPerSec), IDS_BITSPERSEC },
    { g_szPercent,    ARRAYSIZE(g_szPercent),    IDS_PERCENT    },
    { g_szRealtime,   ARRAYSIZE(g_szRealtime),   IDS_REALTIME   },
    { g_szNormal,     ARRAYSIZE(g_szNormal),     IDS_NORMAL     },
    { g_szLow,        ARRAYSIZE(g_szLow),        IDS_LOW        },
    { g_szHigh,       ARRAYSIZE(g_szHigh),       IDS_HIGH       },
    { g_szUnknown,    ARRAYSIZE(g_szUnknown),    IDS_UNKNOWN    },
    { g_szAboveNormal,ARRAYSIZE(g_szAboveNormal),IDS_ABOVENORMAL},
    { g_szBelowNormal,ARRAYSIZE(g_szBelowNormal),IDS_BELOWNORMAL},
    { g_szRunning,    ARRAYSIZE(g_szRunning),    IDS_RUNNING    },
    { g_szHung,       ARRAYSIZE(g_szHung),       IDS_HUNG       },
    { g_szfmtTasks,   ARRAYSIZE(g_szfmtTasks),   IDS_FMTTASKS   },
    { g_szfmtProcs,   ARRAYSIZE(g_szfmtProcs),   IDS_FMTPROCS   },
    { g_szfmtCPU,     ARRAYSIZE(g_szfmtCPU),     IDS_FMTCPU     },
    { g_szfmtMEMK,    ARRAYSIZE(g_szfmtMEMK),            IDS_FMTMEMK    },
    { g_szfmtMEMM,    ARRAYSIZE(g_szfmtMEMM),            IDS_FMTMEMM    },
    { g_szfmtCPUNum,  ARRAYSIZE(g_szfmtCPUNum),          IDS_FMTCPUNUM  },
    { g_szTotalCPU,   ARRAYSIZE(g_szTotalCPU),           IDS_TOTALTIME  },
    { g_szKernelCPU,  ARRAYSIZE(g_szKernelCPU),          IDS_KERNELTIME },
    { g_szMemUsage,   ARRAYSIZE(g_szMemUsage),           IDS_MEMUSAGE   },
    { g_szZero,           ARRAYSIZE(g_szZero),           IDS_ZERO           },
    { g_szScaleFont,      ARRAYSIZE(g_szScaleFont),      IDS_SCALEFONT      },
    { g_szNonOperational, ARRAYSIZE(g_szNonOperational), IDS_NONOPERATIONAL },
    { g_szUnreachable,    ARRAYSIZE(g_szUnreachable),    IDS_UNREACHABLE    },
    { g_szDisconnected,   ARRAYSIZE(g_szDisconnected),   IDS_DISCONNECTED   },
    { g_szConnecting,     ARRAYSIZE(g_szConnecting),     IDS_CONNECTING     },
    { g_szConnected,      ARRAYSIZE(g_szConnected),      IDS_CONNECTED      },
    { g_szOperational,    ARRAYSIZE(g_szOperational),    IDS_OPERATIONAL    },
    { g_szUnknownStatus,  ARRAYSIZE(g_szUnknownStatus),  IDS_UNKNOWNSTATUS  },

};

//
//
//
void LoadGlobalResources()
{
    //
    // If we don't get accelerators, its not worth failing the load
    //
    
    g_hAccel = LoadAccelerators(g_hInstance, MAKEINTRESOURCE(IDR_ACCELERATORS));
    Assert(g_hAccel);   // Missing resource?

    for (UINT i = 0; i < g_cTrayIcons; i++)
    {
        g_aTrayIcons[i] = (HICON) LoadImage(g_hInstance, 
                                            MAKEINTRESOURCE(idTrayIcons[i]), 
                                            IMAGE_ICON, 
                                            0, 0, 
                                            LR_DEFAULTCOLOR);
        Assert( NULL != g_aTrayIcons[i] );  // missing resource?
    }

    for (i = 0; i < ARRAYSIZE(g_aStrings); i++)
    {
        int iRet = LoadString( g_hInstance, g_aStrings[i].id, g_aStrings[i].psz, g_aStrings[i].len );
        Assert( 0 != iRet );    // missing string?
        iRet = 0; // silence the compiler warning - this gets optmized out
    }
}

//
// IsTerminalServicesEnabled
//
void IsTerminalServicesEnabled( LPBOOL pfIsTSEnabled, LPBOOL pfIsSingleUserTS, LPBOOL pfIsTSServer  )
{
    *pfIsTSEnabled = FALSE;
    *pfIsSingleUserTS = FALSE;
    *pfIsTSServer = FALSE;

    OSVERSIONINFOEX osVersionInfo;
    ZeroMemory(&osVersionInfo, sizeof(OSVERSIONINFOEX));
    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if(GetVersionEx((OSVERSIONINFO*)&osVersionInfo))
    {
        if(osVersionInfo.wSuiteMask & (VER_SUITE_TERMINAL | VER_SUITE_SINGLEUSERTS))
        {
            *pfIsTSEnabled = TRUE;

            if(osVersionInfo.wProductType == VER_NT_SERVER ||
                osVersionInfo.wProductType == VER_NT_DOMAIN_CONTROLLER)
            {
                *pfIsTSServer = TRUE;
                return;
            }

            if(osVersionInfo.wProductType == VER_NT_WORKSTATION &&
                osVersionInfo.wSuiteMask == VER_SUITE_SINGLEUSERTS)
            {
                HKEY hKey;

                *pfIsSingleUserTS = TRUE;   // single user unless overridden.

                if (ERROR_SUCCESS == RegOpenKeyEx( HKEY_LOCAL_MACHINE
                                                 , TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
                                                 , 0
                                                 , KEY_QUERY_VALUE
                                                 , &hKey
                                                 ) )
                {
                    DWORD dwType;
                    DWORD dwValue;
                    DWORD dwValueSize = sizeof(dwValue);

                    if ( ERROR_SUCCESS == RegQueryValueEx( hKey
                                                         , TEXT("AllowMultipleTSSessions")
                                                         , NULL
                                                         , &dwType
                                                         , reinterpret_cast<LPBYTE>(&dwValue)
                                                         , &dwValueSize 
                                                         )
                        && ( REG_DWORD == dwType ) 
                        && ( 0 != dwValue )
                        )
                    {
                        *pfIsSingleUserTS  = FALSE; // multiple users
                    }
                    
                    RegCloseKey(hKey);
                }
            }
        }
    }

}

/*++

Routine Description:

    Determines if the system is low on memory. If the system has less than8 Mbytes of
    memory than the system is low on memory. 

Arguments:

    void 

Return Value:

    TRUE -- System is low on memory
    FALSE -- System is not low on memory

Revision History:

      1-6-2000  Created by omiller

--*/

BOOLEAN IsMemoryLow()
{

    SYSTEM_PERFORMANCE_INFORMATION PerfInfo;
    SYSTEM_BASIC_INFORMATION Basic;
    ULONG ulPagesPerMeg;
    ULONG ulPageSize;
    NTSTATUS Status;
    BOOLEAN  bMemoryLow = TRUE;

    //
    // Get the page size 
    //
    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       &Basic,
                                       sizeof(Basic),
                                       0 );
    if ( SUCCEEDED(Status) )
    {
        ulPagesPerMeg = 1024*1024 / Basic.PageSize;
        ulPageSize = Basic.PageSize;

        //
        // Determine if we are low on memory
        //
        Status = NtQuerySystemInformation( SystemPerformanceInformation,
                                           &PerfInfo,
                                           sizeof(PerfInfo),
                                           0 );

        if ( SUCCEEDED(Status) )
        {
            //
            // Compute the number of free megs.
            //
            ULONG ulFreeMeg = (ULONG)((PerfInfo.CommitLimit - PerfInfo.CommittedPages) / ulPagesPerMeg);

            if ( ulFreeMeg > MIN_MEMORY_REQUIRED )
            {
                //
                // We are not low on memory we have about 8 megs of memory.
                // We could get this value from Reg key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\ContentIndex
                // Value MinWordlistMemory
                //
                bMemoryLow = FALSE;
            }
        }
    }
    return bMemoryLow;
}

/*++ WinMain

Routine Description:

    Windows app startup.  Does basic initialization and creates the main window

Arguments:

    Standard winmain

Return Value:

    App exit code

Revision History:

      Nov-30-95 Davepl  Created

--*/
int WINAPI WinMainT(
                HINSTANCE   hInstance,          // handle to current instance
                HINSTANCE   /*hPrevInstance*/,  // handle to previous instance (n/a)
                LPTSTR      /*lpCmdLine*/,      // pointer to command line
                int         nShowCmd            // show state of window
                )
{
    int retval    = TRUE;
    HKEY hKeyPolicy;
    DWORD dwType;
    DWORD dwData = 0;
    DWORD dwSize;
    int cx;
    int cy;

    g_hInstance = hInstance;

    g_msgTaskbarCreated = RegisterWindowMessage(TEXT("TaskbarCreated"));

    // Try to create or grab the startup mutex.  Only in the case
    // where everything goes well and the mutex already existed AND
    // we were able to grab it do we deem ourselves to be a secondary instance

    g_hStartupMutex = CreateMutex(NULL, TRUE, cszStartupMutex);
    if (g_hStartupMutex && GetLastError() == ERROR_ALREADY_EXISTS)
    {
        // Give the other instance (the one that owns the startup mutex) 10
        // seconds to do its thing

        WaitForSingleObject(g_hStartupMutex, FINDME_TIMEOUT);
    }

    // Determine if Terminal Services is Enabled and if so,
    // find out on what session we're running.

    IsTerminalServicesEnabled(&g_fIsTSEnabled, &g_fIsSingleUserTS, &g_fIsTSServer);
    if (g_fIsTSEnabled)
    {
        ProcessIdToSessionId( GetCurrentProcessId(), &g_dwMySessionId );
    }

    // 
    // Locate and activate a running instance if it exists.  
    //

    WCHAR szTitle[MAX_PATH];
    if (LoadString(hInstance, IDS_APPTITLE, szTitle, ARRAYSIZE(szTitle)))
    {
        HWND hwndOld = FindWindow(WC_DIALOG, szTitle);
        if (hwndOld)
        {
            // Send the other copy of ourselves a PWM_ACTIVATE message.  If that
            // succeeds, and it returns PWM_ACTIVATE back as the return code, it's
            // up and alive and we can exit this instance.

            DWORD dwPid = 0;
            GetWindowThreadProcessId(hwndOld, &dwPid);
            AllowSetForegroundWindow(dwPid);

            ULONG_PTR dwResult;
            if (SendMessageTimeout(hwndOld, 
                                   PWM_ACTIVATE, 
                                   0, 0, 
                                   SMTO_ABORTIFHUNG, 
                                   FINDME_TIMEOUT, 
                                   &dwResult))
            {
                if (dwResult == PWM_ACTIVATE)
                {
                    goto cleanup;
                }
            }
        }
    }


    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Policies\\System"),
                      0, KEY_READ, &hKeyPolicy) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwData);

        RegQueryValueEx (hKeyPolicy, TEXT("DisableTaskMgr"), NULL, &dwType, (LPBYTE) &dwData, &dwSize);

        RegCloseKey (hKeyPolicy);

        if (dwData)
        {
            WCHAR szTitle[25];
            WCHAR szMessage[200];
            int iRet;

            iRet = LoadString (hInstance, IDS_TASKMGR, szTitle, ARRAYSIZE(szTitle));
            Assert( 0 != iRet );    // missing string?

            iRet = LoadString (hInstance, IDS_TASKMGRDISABLED , szMessage, ARRAYSIZE(szMessage));
            Assert( 0 != iRet );    // missing string?

            MessageBox (NULL, szMessage, szTitle, MB_OK | MB_ICONSTOP);
            retval = FALSE;
            goto cleanup;
        }
    }

    //
    // No running instance found, so we run as normal
    //

    InitCommonControls();

    InitDavesControls();
                
    // Start the worker thread.  If it fails, you just don't
    // get tray icons

    g_hTrayThread = CreateThread(NULL, 0, TrayThreadMessageLoop, NULL, 0, &g_idTrayThread);
    ASSERT( NULL != g_hTrayThread );

    //
    // Init the page table
    //

    g_nPageCount = ARRAYSIZE(g_pPages);

    g_pPages[0] = new CTaskPage;
    if (NULL == g_pPages[0])
    {
        retval = FALSE;
        goto cleanup;
    }

    g_pPages[1] = new CProcPage;
    if (NULL == g_pPages[1])
    {
        retval = FALSE;
        goto cleanup;
    }

    if( !IsMemoryLow() )
    {
        g_pPages[2] = new CPerfPage;
        if (NULL == g_pPages[2])
        {
            retval = FALSE;
            goto cleanup;
        }

        g_pPages[3] = new CNetPage;
        if (NULL == g_pPages[3])
        {
           retval = FALSE;
           goto cleanup;
        }

        if (g_fIsTSEnabled && !g_fIsSingleUserTS)
        {
            g_pPages[4] = new CUserPage;
            if (NULL == g_pPages[4])
            {
                retval = FALSE;
                goto cleanup;
            }
        }
        else
        {
            --g_nPageCount;     //  Decrement count if users pane is disabled
        }
    }
    else
    {
        //
        // We are low on memory, only load the first two tabs.
        //
        g_nPageCount = 2;
    }

    //
    // Load whatever resources that we need available globally
    //

    LoadGlobalResources();

    //
    // Initialize the history buffers
    //

    if (0 == InitPerfInfo())
    {
        retval = FALSE;
        goto cleanup;
    }

    if (0 == InitNetInfo())
    {
        retval = FALSE;
        goto cleanup;
    }

    //
    // Create the main window (it's a modeless dialog, to be precise)
    //

    g_hMainWnd = CreateDialog( hInstance, MAKEINTRESOURCE(IDD_MAINWND), NULL, MainWindowProc );
    if (NULL == g_hMainWnd)
    {
        retval = FALSE;
        goto cleanup;
    }

    //
    // Initialize the gloabl setting variables, Comma, decimal point, group seperation etc
    //

    OnSettingsChange();

    fAlreadySetPos = TRUE;

    cx = g_Options.m_rcWindow.right  - g_Options.m_rcWindow.left;
    cy = g_Options.m_rcWindow.bottom - g_Options.m_rcWindow.top;

    SetWindowPos( g_hMainWnd, NULL, g_Options.m_rcWindow.left, g_Options.m_rcWindow.top, cx, cy, SWP_NOZORDER );
    ShowWindow( g_hMainWnd, nShowCmd );

    //
    // We're out of the "starting up" phase so release the startup mutex
    //

    if (NULL != g_hStartupMutex)
    {
        ReleaseMutex(g_hStartupMutex);
        CloseHandle(g_hStartupMutex);
        g_hStartupMutex = NULL;
    }

    //
    // If we're the one, true, task manager, we can hang around till the
    // bitter end in case the user has problems during shutdown
    //

    SetProcessShutdownParameters(1, SHUTDOWN_NORETRY);

    MSG msg;
    while (GetMessage(&msg, NULL, 0, 0))
    {
        if (!TranslateAccelerator(g_hMainWnd, g_hAccel, &msg))
        {
            if (!IsDialogMessage(g_hMainWnd, &msg))
            {
                TranslateMessage(&msg);          // Translates virtual key codes 
                DispatchMessage(&msg);           // Dispatches message to window 
            }
        }
    }

cleanup:

    //
    // We're no longer "starting up"
    //

    if (g_hStartupMutex)
    {
        ReleaseMutex(g_hStartupMutex);
        CloseHandle(g_hStartupMutex);
        g_hStartupMutex = NULL;
    }

    // Yes, I could use virtual destructors, but I could also poke
    // myself in the eye with a sharp stick.  Either way you wouldn't
    // be able to see what's going on.

    if (g_pPages[TASK_PAGE])
        delete (CTaskPage *) g_pPages[TASK_PAGE];

    if (g_pPages[PROC_PAGE])
        delete (CProcPage *) g_pPages[PROC_PAGE];

    if (g_pPages[PERF_PAGE])
        delete (CPerfPage *) g_pPages[PERF_PAGE];

    if (g_pPages[NET_PAGE])
        delete (CNetPage *) g_pPages[NET_PAGE];

    if (g_pPages[USER_PAGE])
        delete (CUserPage *) g_pPages[USER_PAGE];

    ReleasePerfInfo();

    return (retval);
}

//
// And now the magic begins.  The normal C++ CRT code walks a set of vectors
// and calls through them to perform global initializations.  Those vectors
// are always in data segments with a particular naming scheme.  By delcaring
// the variables below, I can determine where in my code they get stuck, and
// then call them myself
//

typedef void (__cdecl *_PVFV)(void);

// This is all ridiculous.
#ifdef _M_IA64
#pragma section(".CRT$XIA",long,read)
#pragma section(".CRT$XIZ",long,read)
#pragma section(".CRT$XCA",long,read)
#pragma section(".CRT$XCZ",long,read)
#define _CRTALLOC(x) __declspec(allocate(x))
#else  /* _M_IA64 */
#define _CRTALLOC(x)
#endif  /* _M_IA64 */

#pragma data_seg(".CRT$XIA")
_CRTALLOC(".CRT$XIA") _PVFV __xi_a[] = { NULL };

#pragma data_seg(".CRT$XIZ")
_CRTALLOC(".CRT$XIZ") _PVFV __xi_z[] = { NULL };

#pragma data_seg(".CRT$XCA")                                 
_CRTALLOC(".CRT$XCA") _PVFV __xc_a[] = { NULL };

#pragma data_seg(".CRT$XCZ")
_CRTALLOC(".CRT$XCZ") _PVFV __xc_z[] = { NULL };

#pragma data_seg(".data")

/*++ _initterm

Routine Description:

    Walk the table of function pointers from the bottom up, until
    the end is encountered.  Do not skip the first entry.  The initial
    value of pfbegin points to the first valid entry.  Do not try to
    execute what pfend points to.  Only entries before pfend are valid.

Arguments:

    pfbegin - first pointer
    pfend   - last pointer

Revision History:

      Nov-30-95 Davepl  Created

--*/

static void __cdecl _initterm ( _PVFV * pfbegin, _PVFV * pfend )
{
    while ( pfbegin < pfend )
    {
        
         // if current table entry is non-NULL, call thru it.
         
        if ( *pfbegin != NULL )
        {
            (**pfbegin)();
        }
        ++pfbegin;
    }
}

/*++ WinMain

Routine Description:

    Windows app startup.  Does basic initialization and creates the main window

Arguments:

    Standard winmain

Return Value:

    App exit code

Revision History:

      Nov-30-95 Davepl  Created

--*/

void _stdcall ModuleEntry(void)
{
    int i;
    STARTUPINFO si;

    SetPriorityClass(GetCurrentProcess(), HIGH_PRIORITY_CLASS);

    //
    // Do runtime startup initializers.
    //

    _initterm( __xi_a, __xi_z );
    
    //
    // do C++ constructors (initializers) specific to this EXE
    //

    _initterm( __xc_a, __xc_z );

    LPTSTR pszCmdLine = GetCommandLine();

    if ( *pszCmdLine == TEXT('\"') ) {
        /*
         * Scan, and skip over, subsequent characters until
         * another double-quote or a null is encountered.
         */
        while ( *++pszCmdLine && (*pszCmdLine
             != TEXT('\"')) );
        /*
         * If we stopped on a double-quote (usual case), skip
         * over it.
         */
        if ( *pszCmdLine == TEXT('\"') )
            pszCmdLine++;
    }
    else {
        while (*pszCmdLine > TEXT(' '))
            pszCmdLine++;
    }

    /*
     * Skip past any white space preceeding the second token.
     */
    while (*pszCmdLine && (*pszCmdLine <= TEXT(' '))) {
        pszCmdLine++;
    }

    si.dwFlags = 0;
    GetStartupInfo(&si);

    g_bMirroredOS = IS_MIRRORING_ENABLED();

    i = WinMainT(GetModuleHandle(NULL), NULL, pszCmdLine,
                   si.dwFlags & STARTF_USESHOWWINDOW ? si.wShowWindow : SW_SHOWDEFAULT);
    ExitProcess(i);
}

// DisplayFailureMsg
//
// Displays a generic error message based on the error code
// and message box title provided

void DisplayFailureMsg(HWND hWnd, UINT idTitle, DWORD dwError)
{
    WCHAR szTitle[MAX_PATH];
    WCHAR szMsg[MAX_PATH * 2];
    WCHAR szError[MAX_PATH];

    if (0 == LoadString(g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle)))
    {
        return;
    }

    if (0 == LoadString(g_hInstance, IDS_GENFAILURE, szMsg, ARRAYSIZE(szMsg)))
    {
        return;
    }
    
    // "incorrect paramter" doesn't make a lot of sense for the user, so
    // massage it to be "Operation not allowed on this process".
                                                                             
    if (dwError == ERROR_INVALID_PARAMETER)
    {
        if (0 == LoadString(g_hInstance, IDS_BADPROC, szError, ARRAYSIZE(szError)))
        {
            return;
        }
    }
    else if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
                                NULL,
                                dwError,
                                LANG_USER_DEFAULT,
                                szError,
                                ARRAYSIZE(szError),
                                NULL))
    {
        return;
    }

    StringCchCat(szMsg, ARRAYSIZE(szMsg), szError);

    MessageBox(hWnd, szMsg, szTitle, MB_OK | MB_ICONERROR);
}

/*++ LoadPopupMenu

Routine Description:

    Loads a popup menu from a resource.  Needed because USER
    does not support popup menus (yes, really)
    
Arguments:

    hinst       - module instance to look for resource in
    id          - resource id of popup menu

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

HMENU LoadPopupMenu(HINSTANCE hinst, UINT id)
{
    HMENU hmenuParent = LoadMenu(hinst, MAKEINTRESOURCE(id));
    if (NULL != hmenuParent) 
    {
        HMENU hpopup = GetSubMenu(hmenuParent, 0);
        if ( NULL != hpopup )
        {
            RemoveMenu(hmenuParent, 0, MF_BYPOSITION);
            DestroyMenu(hmenuParent);
        }

        return hpopup;
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\precomp.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       Precomp.H
//
//  History:    Nov-10-95   DavePl  Created
//
//--------------------------------------------------------------------------

//
// Warnings turned off to appease our header files
//
#pragma warning(disable:4127)       // Conditional expression is constant

#define  STRICT

#if DBG
#define DEBUG 1
#endif

#ifndef UNICODE
#define  UNICODE
#endif

#ifndef  _UNICODE
#define  _UNICODE
#endif

extern "C"
{
    #include <nt.h>
    #include <ntrtl.h>
    #include <nturtl.h>
    #include <ntexapi.h>
}

#include <windows.h>
#include <windowsx.h>
#include <Iphlpapi.h>
#include <objbase.h>
#include <winuserp.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <shlapip.h>
#include <vdmdbg.h>
#include <ccstock.h>
#include <wtsapi32.h>
#include <hydrix.h>     // internal hydra defines
#include <msginaexports.h>
#include <strsafe.h>
#include <TokenUtil.h>      // CPrivilegeEnable
#include <winsta.h>         // WinStationGetProcessSid
#include <utildll.h>        // CachedGetUserFromSid
#include <htmlhelp.h>
#include <lmcons.h>
#include <sspi.h>
#include <secext.h>  // for GetUserNameEx
#include <security.h>


//
// Global data externs
//

#define PWM_TRAYICON    WM_USER + 10
#define PWM_ACTIVATE    WM_USER + 11

#define DEFSPACING_BASE      3
#define INNERSPACING_BASE    2
#define TOPSPACING_BASE      10

extern long g_DefSpacing;
extern long g_InnerSpacing;
extern long g_TopSpacing;

#define CONTROL_WIDTH_SPACING   13
#define CONTROL_HEIGHT_SPACING  2

extern long g_ControlWidthSpacing;
extern long g_ControlHeightSpacing;

#define MAX_NETWORKCARDS 32      // Maximum number of Network cards (i.e. max number of network graphs)
#define HIST_SIZE        2000   // Number of data points to track in the history windows

extern HINSTANCE g_hInstance;
extern HWND      g_hMainWnd;
extern HDESK     g_hMainDesktop;
extern DWORD     g_cTasks;
extern DWORD     g_cProcesses;
extern BYTE      g_cProcessors;
extern BYTE      g_CPUUsage;
extern __int64   g_MEMUsage;
extern __int64   g_MEMMax;
extern HMENU     g_hMenu;

extern BYTE      g_CPUUsage;
extern BYTE *    g_pCPUHistory[MAXIMUM_PROCESSORS];
extern BYTE *    g_pKernelHistory[MAXIMUM_PROCESSORS];

extern BOOL      g_fInPopup;

extern WCHAR     g_szK[];
extern WCHAR     g_szRealtime[];
extern WCHAR     g_szNormal[];
extern WCHAR     g_szHigh[];
extern WCHAR     g_szLow[];
extern WCHAR     g_szUnknown[];
extern WCHAR     g_szAboveNormal[];
extern WCHAR     g_szBelowNormal[];
extern WCHAR     g_szHung[];
extern WCHAR     g_szRunning[];
extern WCHAR     g_szfmtCPUNum[];
extern WCHAR     g_szfmtCPU[];
extern WCHAR     g_szTotalCPU[];
extern WCHAR     g_szKernelCPU[];
extern WCHAR     g_szMemUsage[];

extern HICON     g_aTrayIcons[];
extern UINT      g_cTrayIcons;

class  COptions;
extern COptions  g_Options;

//
// Prototypes
//
BYTE InitNetInfo();                         // netpage.cpp
void CalcCpuTime(BOOL);                     // perfpage.cpp
BYTE InitPerfInfo();                        // perfpage.cpp
void ReleasePerfInfo();                     // perfpage.cpp
void DisplayFailureMsg(HWND hWnd, UINT idTitle, DWORD dwError); // main.cpp
BOOL CreateNewDesktop();                    // main.cpp
void ShowRunningInstance();
HMENU LoadPopupMenu(HINSTANCE hinst, UINT id); // main.cpp
BOOL CheckParentDeferrals(UINT uMsg, WPARAM wParam, LPARAM lParam);

void Tray_Notify(HWND hWnd, LPARAM lParam);
void UpdateTrayIcon(HWND hWnd);

#include "taskmgr.h"
#include "resource.h"
#include "pages.h"
#include "ptrarray.h"


/*++ ShiftArrayWorker

Routine Description:

    Shifts a section of an array up or down.  If shifting
    down, the given element is lost.  For up, an empty slot
    (with an undefined value) is opened.

Arguments:

    pArray        - Array starting address
    cbArraySize   - Size of Array (in BYTES)
    cElementSize  - Size of array elements
    iFirstElement - First element to move
    Direction     - SHIFT_UP or SHIFT_DOWN

Return Value:

    None.  No error checking either.  Should compile out to
    a movememory

Notes:
    
    Call this with the ShiftArray macro which does the size
    calcs for you

Revision History:

    Jan-26-95 Davepl  Created

--*/

#define ShiftArray(array, index, direction) \
					    \
	ShiftArrayWorker((LPBYTE) array, sizeof(array), sizeof(array[0]), index, direction)

typedef enum SHIFT_DIRECTION { SHIFT_UP, SHIFT_DOWN };

static inline void ShiftArrayWorker(const LPBYTE          pArray, 
				    const size_t          cbArraySize, 
				    const size_t          cElementSize, 
				    const UINT            iFirstElement,
				    const SHIFT_DIRECTION Direction)
{
    ASSERT( ((cbArraySize / cElementSize) * cElementSize) == cbArraySize);
    ASSERT( (iFirstElement + 1) * cElementSize <= cbArraySize );

    const LPBYTE pFirst       = pArray + (iFirstElement * cElementSize);
    const LPBYTE pLast        = pArray + cbArraySize - cElementSize;
    const UINT   cBytesToMove = (UINT)(pLast - pFirst);

    ASSERT (pLast >= pFirst);

    if (cBytesToMove)
    {
	    if (SHIFT_DOWN == Direction)
	    {
	        CopyMemory(pFirst, pFirst + cElementSize, cBytesToMove);
	    }    
	    else if (Direction == SHIFT_UP)
	    {
	        CopyMemory(pFirst + cElementSize, pFirst, cBytesToMove);
	    }
        else
        {
            ASSERT( FALSE );
        }
    }
}

//////////////////////////////////////////////////////////////////////////////
//
// MACRO
// DEBUG_BREAK
//
// Description:
//      Because the system expection handler can hick-up over INT 3s and
//      DebugBreak()s, This x86 only macro causes the program to break in the
//      right spot.
//
//////////////////////////////////////////////////////////////////////////////
#if defined( _X86_ )
#define DEBUG_BREAK         do { _try { _asm int 3 } _except (EXCEPTION_EXECUTE_HANDLER) {;} } while (0)
#else
#define DEBUG_BREAK         DebugBreak()
#endif

//
// Assert
//

#ifdef Assert
#undef Assert
#endif

#ifdef DEBUG

#define Assert(x) \
do \
{ \
    if ( !(x) ) \
    { \
	    DEBUG_BREAK; \
    } \
} while (0)

#else
#define Assert(x)
#endif


#ifdef ASSERT
#undef ASSERT
#endif

#define ASSERT(x)               Assert(x)

extern const WCHAR szTaskmanKey[];

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\procpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       procpage.cpp
//
//  History:    Nov-16-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Project-scope globals
//

DWORD g_cProcesses = 0;

extern WCHAR g_szTimeSep[];
extern WCHAR g_szGroupThousSep[];
extern ULONG g_ulGroupSep;

//--------------------------------------------------------------------------
// TERMINAL SERVICES

//-- cache this state
BOOL IsUserAdmin( )
{
    // Note that local static initialization is not thread safe,
    // but this function is only called from the process page dialog
    // proc (i.e. single thread).
    static BOOL sbIsUserAdmin = SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS);
    
    return sbIsUserAdmin;
}

// get/set current session id.

// we use this session id to filter the processes for current session.

DWORD        gdwSessionId = static_cast<DWORD>(-1);

inline DWORD GetCurrentSessionID( )
{
    return gdwSessionId;
}

inline VOID SetCurrentSessionID( DWORD dwSessionId )
{
    gdwSessionId = dwSessionId;
}

// END OF TERMINAL SERVICES DECLs
//--------------------------------------------------------------------------

//
// File-scope globals
//

SYSTEM_BASIC_INFORMATION g_BasicInfo;

//
// Table of which resource IDs in the column selection dialog
// correspond to which columns
//

const int g_aDlgColIDs[] =
{
    IDC_IMAGENAME,
    IDC_PID,
    IDC_USERNAME,
    IDC_SESSIONID,
    IDC_CPU,
    IDC_CPUTIME,
    IDC_MEMUSAGE,
    IDC_MEMPEAK,
    IDC_MEMUSAGEDIFF,
    IDC_PAGEFAULTS,
    IDC_PAGEFAULTSDIFF,
    IDC_COMMITCHARGE,
    IDC_PAGEDPOOL,
    IDC_NONPAGEDPOOL,
    IDC_BASEPRIORITY,
    IDC_HANDLECOUNT,
    IDC_THREADCOUNT,
    IDC_USEROBJECTS,
    IDC_GDIOBJECTS,
    IDC_READOPERCOUNT,
    IDC_WRITEOPERCOUNT,
    IDC_OTHEROPERCOUNT,
    IDC_READXFERCOUNT,
    IDC_WRITEXFERCOUNT,
    IDC_OTHERXFERCOUNT
};

//
// Column ID on which to sort in the listview, and for
// compares in general
//

COLUMNID g_iProcSortColumnID = COL_PID;
INT      g_iProcSortDirection = 1;          // 1 = asc, -1 = desc

//
// Column Default Info
//

struct
{
    INT Format;
    INT Width;
} ColumnDefaults[NUM_COLUMN] =
{
    { LVCFMT_LEFT,     0x6B },       // COL_IMAGENAME
    { LVCFMT_RIGHT,      50 },       // COL_PID
    { LVCFMT_LEFT,     0x6B },       // COL_USERNAME
    { LVCFMT_RIGHT,      70 },       // COL_SESSIONID
    { LVCFMT_RIGHT,      35},        // COL_CPU
    { LVCFMT_RIGHT,      70 },       // COL_CPUTIME
    { LVCFMT_RIGHT,      70 },       // COL_MEMUSAGE
    { LVCFMT_RIGHT,     100 },       // COL_MEMPEAK
    { LVCFMT_RIGHT,      70 },       // COL_MEMUSAGEDIFF
    { LVCFMT_RIGHT,      70 },       // COL_PAGEFAULTS
    { LVCFMT_RIGHT,      70 },       // COL_PAGEFAULTSDIFF
    { LVCFMT_RIGHT,      70 },       // COL_COMMITCHARGE
    { LVCFMT_RIGHT,      70 },       // COL_PAGEDPOOL
    { LVCFMT_RIGHT,      70 },       // COL_NONPAGEDPOOL
    { LVCFMT_RIGHT,      60 },       // COL_BASEPRIORITY
    { LVCFMT_RIGHT,      60 },       // COL_HANDLECOUNT
    { LVCFMT_RIGHT,      60 },       // COL_THREADCOUNT
    { LVCFMT_RIGHT,      60 },       // COL_USEROBJECTS
    { LVCFMT_RIGHT,      60 },       // COL_GDIOBJECTS
    { LVCFMT_RIGHT,      70 },       // COL_READOPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_WRITEOPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_OTHEROPERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_READXFERCOUNT
    { LVCFMT_RIGHT,      70 },       // COL_WRITEXFERCOUNT
    { LVCFMT_RIGHT,      70 }        // COL_OTHERXFERCOUNT
};


/*++ class CProcInfo

Class Description:

    Represents the last known information about a running process

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

class CProcInfo
{
public:

    LARGE_INTEGER     m_uPassCount;
    DWORD             m_UniqueProcessId;
    LPWSTR            m_pszUserName;
    ULONG             m_SessionId;
    BYTE              m_CPU;
    BYTE              m_DisplayCPU;
    LARGE_INTEGER     m_CPUTime;
    LARGE_INTEGER     m_DisplayCPUTime;
    SIZE_T            m_MemUsage;
    SSIZE_T           m_MemDiff;
    ULONG             m_PageFaults;
    LONG              m_PageFaultsDiff;
    ULONG_PTR         m_CommitCharge;
    ULONG_PTR         m_PagedPool;
    ULONG_PTR         m_NonPagedPool;
    KPRIORITY         m_PriClass;
    ULONG             m_HandleCount;
    ULONG             m_ThreadCount;
    ULONG             m_GDIObjectCount;
    ULONG             m_USERObjectCount;
    LONGLONG          m_IoReadOperCount;
    LONGLONG          m_IoWriteOperCount;
    LONGLONG          m_IoOtherOperCount;
    LONGLONG          m_IoReadXferCount;
    LONGLONG          m_IoWriteXferCount;
    LONGLONG          m_IoOtherXferCount;
    LPWSTR            m_pszImageName;
    CProcInfo *       m_pWowParentProcInfo;    // non-NULL for WOW tasks
    WORD              m_htaskWow;              // non-zero for WOW tasks
    BOOL              m_fWowProcess:1;         // TRUE for real WOW process
    BOOL              m_fWowProcessTested:1;   // TRUE once fWowProcess is valid
    SIZE_T            m_MemPeak;

    //
    // This is a union of who (which column) is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

    union
    {
        DWORD                m_fDirty;
#pragma warning(disable:4201)       // Nameless struct or union
        struct
        {
            DWORD            m_fDirty_COL_CPU            :1;
            DWORD            m_fDirty_COL_CPUTIME        :1;
            DWORD            m_fDirty_COL_MEMUSAGE       :1;
            DWORD            m_fDirty_COL_MEMUSAGEDIFF   :1;
            DWORD            m_fDirty_COL_PAGEFAULTS     :1;
            DWORD            m_fDirty_COL_PAGEFAULTSDIFF :1;
            DWORD            m_fDirty_COL_COMMITCHARGE   :1;
            DWORD            m_fDirty_COL_PAGEDPOOL      :1;
            DWORD            m_fDirty_COL_NONPAGEDPOOL   :1;
            DWORD            m_fDirty_COL_BASEPRIORITY   :1;
            DWORD            m_fDirty_COL_HANDLECOUNT    :1;
            DWORD            m_fDirty_COL_IMAGENAME      :1;
            DWORD            m_fDirty_COL_PID            :1;
            DWORD            m_fDirty_COL_SESSIONID      :1;
            DWORD            m_fDirty_COL_USERNAME       :1;
            DWORD            m_fDirty_COL_THREADCOUNT    :1;
            DWORD            m_fDirty_COL_GDIOBJECTS     :1;
            DWORD            m_fDirty_COL_USEROBJECTS    :1;
            DWORD            m_fDirty_COL_MEMPEAK        :1;
            DWORD            m_fDirty_COL_READOPERCOUNT  :1;
            DWORD            m_fDirty_COL_WRITEOPERCOUNT :1;
            DWORD            m_fDirty_COL_OTHEROPERCOUNT :1;
            DWORD            m_fDirty_COL_READXFERCOUNT  :1;
            DWORD            m_fDirty_COL_WRITEXFERCOUNT :1;
            DWORD            m_fDirty_COL_OTHERXFERCOUNT :1;
        };
#pragma warning(default:4201)       // Nameless struct or union
    };

    HRESULT SetData(LARGE_INTEGER                TotalTime,
                    PSYSTEM_PROCESS_INFORMATION  pInfo,
                    LARGE_INTEGER                uPassCount,
                    CProcPage *                  pProcPage,
                    BOOL                         fUpdateOnly);

    HRESULT SetProcessUsername(const FILETIME *CreationTime);

    HRESULT SetDataWowTask(LARGE_INTEGER  TotalTime,
                           DWORD          dwThreadId,
                           CHAR *         pszFilePath,
                           LARGE_INTEGER  uPassCount,
                           CProcInfo *    pParentProcInfo,
                           LARGE_INTEGER *pTimeLeft,
                           WORD           htask,
                           BOOL           fUpdateOnly);

    CProcInfo()
    {
        ZeroMemory(this, sizeof(*this));
        m_SessionId = 832;
    }

    ~CProcInfo()
    {
        if (m_pszImageName)
        {
            LocalFree( m_pszImageName );
        }

        if( m_pszUserName != NULL )
        {
            LocalFree( m_pszUserName );
        }
    }

    BOOL OkToShowThisProcess ()
    {
        // this function determines if the process should be listed in the view.

        return GetCurrentSessionID() == m_SessionId;
    }


    // Invalidate() marks this proc with a bogus pid so that it is removed
    // on the next cleanup pass

    void Invalidate()
    {
        m_UniqueProcessId = PtrToUlong(INVALID_HANDLE_VALUE);
    }

    LONGLONG GetCPUTime() const
    {
        return m_CPUTime.QuadPart;
    }

    INT Compare(CProcInfo * pOther);

    //
    // Is this a WOW task psuedo-process?
    //

    INT_PTR IsWowTask(void) const
    {
        return (INT_PTR) m_pWowParentProcInfo;
    }

    //
    // Get the Win32 PID for this task
    //

    DWORD GetRealPID(void) const
    {
        return m_pWowParentProcInfo
               ? m_pWowParentProcInfo->m_UniqueProcessId
               : m_UniqueProcessId;
    }

    void SetCPU(LARGE_INTEGER CPUTimeDelta,
                LARGE_INTEGER TotalTime,
                BOOL          fDisplayOnly);
};

/*++ ColSelectDlgProc

Function Description:

    Dialog Procedure for the column selection dialog

Arguments:

    Standard wndproc stuff

Revision History:

      Jan-05-96 Davepl  Created

--*/

INT_PTR CALLBACK ColSelectDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static CProcPage * pPage = NULL;

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            pPage = (CProcPage *) lParam;

            //
            // Start with none of the boxes checked
            //

            for (int i = 0; i < NUM_COLUMN; i++)
            {
                CheckDlgButton(hwndDlg, g_aDlgColIDs[i], BST_UNCHECKED);
            }

            //
            // HIDE the Username and SessionId if its not Terminal Server.
            //

            if( !g_fIsTSEnabled )
            {
                ShowWindow( GetDlgItem( hwndDlg , IDC_USERNAME ) , SW_HIDE );
                ShowWindow( GetDlgItem( hwndDlg , IDC_SESSIONID ) , SW_HIDE );
            }

            //
            // Then turn on the ones for the columns we have active
            //

            for (i = 0; i < NUM_COLUMN + 1; i++)
            {
                if (g_Options.m_ActiveProcCol[i] == -1)
                {
                    break;
                }

                CheckDlgButton(hwndDlg, g_aDlgColIDs[g_Options.m_ActiveProcCol[i]], BST_CHECKED);
            }

        }
        return TRUE;    // don't set focus

    case WM_COMMAND:
        //
        // If user clicked OK, add the columns to the array and reset the listview
        //
        if (LOWORD(wParam) == IDOK)
        {
            // First, make sure the column width array is up to date

            pPage->SaveColumnWidths();

            INT iCol = 1;

            g_Options.m_ActiveProcCol[0] = COL_IMAGENAME;

            for (int i = 1; i < NUM_COLUMN && g_aDlgColIDs[i] >= 0; i++)
            {
                if (BST_CHECKED == IsDlgButtonChecked(hwndDlg, g_aDlgColIDs[i]))
                {
                    // It is checked

                    if (g_Options.m_ActiveProcCol[iCol] != (COLUMNID) i)
                    {
                        // If the column wasn't already there, insert its column
                        // width into the column width array

                        ShiftArray(g_Options.m_ColumnWidths, iCol, SHIFT_UP);
                        ShiftArray(g_Options.m_ActiveProcCol, iCol, SHIFT_UP);
                        g_Options.m_ColumnWidths[iCol] = ColumnDefaults[ i ].Width;
                        g_Options.m_ActiveProcCol[iCol] = (COLUMNID) i;
                    }
                    iCol++;
                }
                else
                {
                    // Not checked, column not active.  If it used to be active,
                    // remove its column width from the column width array

                    if (g_Options.m_ActiveProcCol[iCol] == (COLUMNID) i)
                    {
                        ShiftArray(g_Options.m_ColumnWidths, iCol, SHIFT_DOWN);
                        ShiftArray(g_Options.m_ActiveProcCol, iCol, SHIFT_DOWN);
                    }
                }
            }

            // Terminate the column list
                            
            g_Options.m_ActiveProcCol[iCol] = (COLUMNID) -1;
            pPage->SetupColumns();
            pPage->TimerEvent();
            EndDialog(hwndDlg, IDOK);

        }
        else if (LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, IDCANCEL);
        }
        break;
    }

    return FALSE;
}

/*++ CProcPage::~CProcPage()

        - Destructor
*/

CProcPage::~CProcPage()
{
    Destroy( );
}

/*++ CProcPage::PickColumns()

Function Description:

    Puts up UI that lets the user select what columns to display in the
    process page, and then resets the listview with the new column list

Arguments:

    none

Return Value:

    none

Revision History:

    Jan-05-96 Davepl  Created

--*/

void CProcPage::PickColumns()
{
    DialogBoxParam(g_hInstance, 
                   MAKEINTRESOURCE(IDD_SELECTPROCCOLS), 
                   g_hMainWnd, 
                   ColSelectDlgProc,
                   (LPARAM) this);
}

/*++ GetPriRanking

Function Description:

    Since the priority class defines aren't in order, this helper
    exists to make comparisons between pri classes easier.  It returns
    a larger number for "higher" priority classes

Arguments:

Return Value:

    rank of priority (0 to 5)

Revision History:

      Nov-27-95 Davepl  Created

--*/


DWORD GetPriRanking(DWORD dwClass)
{
    switch(dwClass)
    {
    case REALTIME_PRIORITY_CLASS:
        return 5;

    case HIGH_PRIORITY_CLASS:
        return 4;

    case ABOVE_NORMAL_PRIORITY_CLASS:
        return 3;

    case NORMAL_PRIORITY_CLASS:
        return 2;

    case BELOW_NORMAL_PRIORITY_CLASS:
        return 1;

    default:
        return 0;
    }
}

/*++ QuickConfirm

Function Description:

    Gets a confirmation for things like terminating/debugging processes

Arguments:

    idtitle - string ID of title for message box
    idmsg   - string ID of message body

Return Value:

    IDNO/IDYES, whatever comes back from MessageBox

Revision History:

      Nov-28-95 Davepl  Created

--*/

UINT CProcPage::QuickConfirm(UINT idTitle, UINT idBody)
{
    //
    // Get confirmation before we dust the process, or something similar
    //

    WCHAR szTitle[MAX_PATH];
    WCHAR szBody[MAX_PATH];

    if (0 == LoadString(g_hInstance, idTitle, szTitle, ARRAYSIZE(szTitle)) ||
        0 == LoadString(g_hInstance, idBody,    szBody,  ARRAYSIZE(szBody)))
    {
        return IDNO;
    }

    if (IDYES == MessageBox(m_hPage, szBody, szTitle, MB_ICONEXCLAMATION | MB_YESNO))
    {
        return IDYES;
    }

    return IDNO;
}

/*++ class CProcPage::SetupColumns

Class Description:

    Removes any existing columns from the process listview and
    adds all of the columns listed in the g_Options.m_ActiveProcCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-16-95 Davepl  Created

--*/

static const _aIDColNames[NUM_COLUMN] =
{
    IDS_COL_IMAGENAME,     
    IDS_COL_PID,
    IDS_COL_USERNAME,
    IDS_COL_SESSIONID,
    IDS_COL_CPU,           
    IDS_COL_CPUTIME,       
    IDS_COL_MEMUSAGE,      
    IDS_COL_MEMPEAK,       
    IDS_COL_MEMUSAGEDIFF,  
    IDS_COL_PAGEFAULTS,    
    IDS_COL_PAGEFAULTSDIFF,
    IDS_COL_COMMITCHARGE,  
    IDS_COL_PAGEDPOOL,     
    IDS_COL_NONPAGEDPOOL,  
    IDS_COL_BASEPRIORITY,  
    IDS_COL_HANDLECOUNT,   
    IDS_COL_THREADCOUNT,   
    IDS_COL_USEROBJECTS,   
    IDS_COL_GDIOBJECTS,
    IDS_COL_READOPERCOUNT,
    IDS_COL_WRITEOPERCOUNT,
    IDS_COL_OTHEROPERCOUNT,
    IDS_COL_READXFERCOUNT,
    IDS_COL_WRITEXFERCOUNT,
    IDS_COL_OTHERXFERCOUNT
};

HRESULT CProcPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_PROCLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }

    ListView_DeleteAllItems(hwndList);

    // Remove all existing columns

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(hwndList, 0))
    {
        NULL;
    }

    // Add all of the new columns

    INT iColumn = 0;
    while (g_Options.m_ActiveProcCol[iColumn] >= 0)
    {
        
        INT idColumn = g_Options.m_ActiveProcCol[iColumn];

        // idc_username or IDC_SESSIONID are available only for terminalserver.

        ASSERT((idColumn != COL_USERNAME && idColumn != COL_SESSIONID) || g_fIsTSEnabled);

        WCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, _aIDColNames[idColumn], szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = ColumnDefaults[ idColumn ].Format;

        // If no width preference has been recorded for this column, use the
        // default

        if (-1 == g_Options.m_ColumnWidths[iColumn])
        {
            lvcolumn.cx = ColumnDefaults[ idColumn ].Width;
        }
        else
        {
            lvcolumn.cx = g_Options.m_ColumnWidths[iColumn];
        }

        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }

        iColumn++;
    }

    return S_OK;
}

//
//  Take two unsigned 64-bit values and compare them in a manner
//  that CProcInfo::Compare likes.
//
int Compare64(unsigned __int64 First, unsigned __int64 Second)
{
    if (First < Second)
    {
        return -1;
    }
    else if (First > Second)
    {
        return 1;
    }
    else
    {
        return 0;
    }
}

/*++ class CProcInfo::Compare

Class Description:

    Compares this CProcInfo object to another, and returns its ranking
    based on the g_iProcSortColumnID field.

    Note that if the objects are equal based on the current sort column,
    the PID is used as a secondary sort key to prevent items from 
    jumping around in the listview

    WOW psuedo-processes always sort directly after their parent
    ntvdm.exe process.  So really the sort order is:

    1. WOW task psuedo-processes under parent in alpha order
    2. User's selected order.
    3. PID

Arguments:

    pOther  - the CProcInfo object to compare this to

Return Value:

    < 0      - This CProcInfo is "less" than the other
      0      - Equal (Can't happen, since PID is used to sort)
    > 0      - This CProcInfo is "greater" than the other

Revision History:

      Nov-20-95 Davepl  Created

--*/

INT CProcInfo::Compare(CProcInfo * pOther)
{
    CProcInfo * pMyThis;
    CProcInfo * pMyOther;
    INT iRet = 0;

    //
    // Wow psuedo-processes don't have any performance information,
    // so use the parent "real" ntvdm.exe CProcInfo for sorting.
    //

    ASSERT(this != pOther);

    pMyThis = this->IsWowTask()
              ? this->m_pWowParentProcInfo
              : this;

    pMyOther = pOther->IsWowTask()
               ? pOther->m_pWowParentProcInfo
               : pOther;

    if (pMyThis == pMyOther) {

        //
        // This implies one or the other or both this and pOther
        // are WOW tasks, and they're in the same WOW VDM.  Sort
        // the "real" process entry first, followed by its associated
        // WOW task entries alphabetical.
        //

        if (this->IsWowTask()) {

            if (pOther->IsWowTask()) {

                //
                // They are siblings and we sort by
                // image name.
                //

                ASSERT(this->m_pWowParentProcInfo == pOther->m_pWowParentProcInfo);

                iRet = lstrcmpi(this->m_pszImageName, pOther->m_pszImageName);

            } else {

                //
                // pOther is not a Wow task, it must be ntvdm.exe
                // the parent of this.  this sorts after pOther.
                //

                ASSERT(pOther == this->m_pWowParentProcInfo);

                iRet = 1;
            }
        } else {

            //
            // this is not a Wow task, pOther must be and
            // this must be pOther's parent.
            //

            ASSERT(pOther->IsWowTask());

            iRet = -1;
        }
    }


    if (0 == iRet) 
    {
        switch (g_iProcSortColumnID)
        {
        case COL_CPU:
            iRet = Compare64(pMyThis->m_CPU, pMyOther->m_CPU);
            break;

        case COL_CPUTIME:
            iRet = Compare64(pMyThis->m_CPUTime.QuadPart, pMyOther->m_CPUTime.QuadPart);
            break;

        case COL_MEMUSAGE:
            iRet = Compare64(pMyThis->m_MemUsage, pMyOther->m_MemUsage);
            break;

        case COL_MEMUSAGEDIFF:
            iRet = Compare64(pMyThis->m_MemDiff, pMyOther->m_MemDiff);
            break;

        case COL_MEMPEAK:
            iRet = Compare64(pMyThis->m_MemPeak, pMyOther->m_MemPeak);
            break;

        case COL_PAGEFAULTS:
            iRet = Compare64(pMyThis->m_PageFaults, pMyOther->m_PageFaults);
            break;

        case COL_PAGEFAULTSDIFF:
            iRet = Compare64(pMyThis->m_PageFaultsDiff, pMyOther->m_PageFaultsDiff);
            break;

        case COL_COMMITCHARGE:
            iRet = Compare64(pMyThis->m_CommitCharge, pMyOther->m_CommitCharge);
            break;

        case COL_PAGEDPOOL:
            iRet = Compare64(pMyThis->m_PagedPool, pMyOther->m_PagedPool);
            break;

        case COL_NONPAGEDPOOL:
            iRet = Compare64(pMyThis->m_NonPagedPool, pMyOther->m_NonPagedPool);
            break;

        case COL_BASEPRIORITY:
            iRet = Compare64(GetPriRanking(pMyThis->m_PriClass), GetPriRanking(pMyOther->m_PriClass));
            break;

        case COL_HANDLECOUNT:
            iRet = Compare64(pMyThis->m_HandleCount, pMyOther->m_HandleCount);
            break;

        case COL_THREADCOUNT:
            iRet = Compare64(pMyThis->m_ThreadCount, pMyOther->m_ThreadCount);
            break;

        case COL_PID:
            iRet = Compare64(pMyThis->m_UniqueProcessId, pMyOther->m_UniqueProcessId);
            break;

        case COL_SESSIONID:                
            iRet = Compare64(pMyThis->m_SessionId, pMyOther->m_SessionId);
            break;

        case COL_USERNAME:                
            iRet = lstrcmpi( pMyThis->m_pszUserName , pMyOther->m_pszUserName );
            break;

        case COL_IMAGENAME:
            iRet = lstrcmpi(pMyThis->m_pszImageName, pMyOther->m_pszImageName);
            break;

        case COL_USEROBJECTS:
            iRet = Compare64(pMyThis->m_USERObjectCount, pMyOther->m_USERObjectCount);
            break;

        case COL_GDIOBJECTS:
            iRet = Compare64(pMyThis->m_GDIObjectCount, pMyOther->m_GDIObjectCount);
            break;

        case COL_READOPERCOUNT:
            iRet = Compare64(pMyThis->m_IoReadOperCount, pMyOther->m_IoReadOperCount);
            break;

        case COL_WRITEOPERCOUNT:
            iRet = Compare64(pMyThis->m_IoWriteOperCount, pMyOther->m_IoWriteOperCount);
            break;

        case COL_OTHEROPERCOUNT:
            iRet = Compare64(pMyThis->m_IoOtherOperCount, pMyOther->m_IoOtherOperCount);
            break;

        case COL_READXFERCOUNT:
            iRet = Compare64(pMyThis->m_IoReadXferCount, pMyOther->m_IoReadXferCount);
            break;

        case COL_WRITEXFERCOUNT:
            iRet = Compare64(pMyThis->m_IoWriteXferCount, pMyOther->m_IoWriteXferCount);
            break;

        case COL_OTHERXFERCOUNT:
            iRet = Compare64(pMyThis->m_IoOtherXferCount, pMyOther->m_IoOtherXferCount);
            break;

        default:
            ASSERT(FALSE);
            iRet = 0;
            break;
        }

        iRet *= g_iProcSortDirection;
    }

    // If objects look equal, compare on PID as secondary sort column
    // so that items don't jump around in the listview

    if (0 == iRet)
    {
        iRet = Compare64(pMyThis->m_UniqueProcessId, pMyOther->m_UniqueProcessId) * g_iProcSortDirection;
    }

    return iRet;
}


/*++ class CProcInfo::SetCPU

Method Description:

    Sets the CPU percentage.

Arguments:

    CPUTime   - Time for this process
    TotalTime - Total elapsed time, used as the denominator in calculations

Return Value:

Revision History:

      19-Feb-96  DaveHart  Created

--*/

void CProcInfo::SetCPU(LARGE_INTEGER CPUTimeDelta,
                       LARGE_INTEGER TotalTime,
                       BOOL fDisplayOnly)
{
    // Calc CPU time based on this process's ratio of the total process time used

    INT cpu = (BYTE) (((CPUTimeDelta.QuadPart / ((TotalTime.QuadPart / 1000) ?
                                                 (TotalTime.QuadPart / 1000) : 1)) + 5)
                                              / 10);
    if (cpu > 99)
    {
        cpu = 99;
    }
    
    if (m_DisplayCPU != cpu)
    {
        m_fDirty_COL_CPU = TRUE;
        m_DisplayCPU = (BYTE) cpu;

        if ( ! fDisplayOnly )
        {
            m_CPU = (BYTE) cpu;
        }
    }

}
/*++ CProcPage::GetProcessInfo

Class Description:

    Reads the process info table into a virtual alloc'd buffer, resizing
    the buffer if needed

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

static const int PROCBUF_GROWSIZE = 4096;

HRESULT CProcPage::GetProcessInfo()
{
    HRESULT  hr = S_OK;
    NTSTATUS status;

    while(hr == S_OK)
    {
        if (m_pvBuffer)
        {
            status = NtQuerySystemInformation(SystemProcessInformation,
                                              m_pvBuffer,
                                              static_cast<ULONG>(m_cbBuffer),
                                              NULL);

            //
            // If we succeeded, great, get outta here.  If not, any error other
            // than "buffer too small" is fatal, in which case we bail
            //

            if (NT_SUCCESS(status))
            {
                break;
            }

            if (status != STATUS_INFO_LENGTH_MISMATCH)
            {
                hr = E_FAIL;
                break;
            }
        }

        //
        // Buffer wasn't large enough to hold the process info table, so resize it
        // to be larger, then retry.
        //

        if (m_pvBuffer)
        {
            HeapFree( GetProcessHeap( ), 0, m_pvBuffer );
            m_pvBuffer = NULL;
        }

        m_cbBuffer += PROCBUF_GROWSIZE;

        m_pvBuffer = HeapAlloc( GetProcessHeap( ), 0, m_cbBuffer );
        if (m_pvBuffer == NULL)
        {
            hr = E_OUTOFMEMORY;
            break;
        }
    }

    return hr;
}

//
//
//
void
CProcPage::Int64ToCommaSepString(
    LONGLONG n,
    LPTSTR pszOut,
    int cchOut
    )
{
    NUMBERFMT nfmt = { 0 };
    WCHAR szText[32];

    //
    // Convert the 64-bit int to a text string.
    //

    _i64tow( n, szText, 10 );
    
    //
    // Format the number with commas according to locale conventions.
    //

    nfmt.Grouping      = UINT(g_ulGroupSep); 
    nfmt.lpDecimalSep  = nfmt.lpThousandSep = g_szGroupThousSep;

    GetNumberFormat(LOCALE_USER_DEFAULT, 0, szText, &nfmt, pszOut, cchOut);
}


/*++ CProcPage::Int64ToCommaSepKString

Class Description:

    Convert a 64-bit integer to a string with commas appended
    with the "K" units designator.

    (2^64)-1 = "18,446,744,073,709,600,000 K"  (29 chars).

Arguments:

    n           - 64-bit integer.
    pszOut      - Destination character buffer.

Return Value:

    None.

Revision History:

      Jan-11-99 BrianAu  Created

--*/

void
CProcPage::Int64ToCommaSepKString(
    LONGLONG n,
    LPTSTR pszOut,
    int cchOut
    )
{
    //
    //  Destined for UI - don't care if it truncates.
    //

    Int64ToCommaSepString(n, pszOut, cchOut);
    StringCchCat( pszOut, cchOut, L" " );
    StringCchCat( pszOut, cchOut, g_szK );
}


/*++ CProcPage::RestoreColumnOrder

Routine Description:

    Sets the column order from the per-user preference data stored 
    in the global COptions object.
    
Arguments:

    hwndList - Listview window handle.

Return Value:

Revision History:

      Jan-11/99 BrianAu  Created

--*/

void
CProcPage::RestoreColumnOrder(
    HWND hwndList
    )
{
    INT rgOrder[ARRAYSIZE(g_Options.m_ColumnPositions)];
    INT cOrder = 0;
    INT iOrder = 0;

    for (int i = 0; i < ARRAYSIZE(g_Options.m_ColumnPositions); i++)
    {
        iOrder = g_Options.m_ColumnPositions[i];
        if (-1 == iOrder)
            break;

        rgOrder[cOrder++] = iOrder;
    }

    if (0 < cOrder)
    {
        const HWND hwndHeader = ListView_GetHeader(hwndList);
        ASSERT(Header_GetItemCount(hwndHeader) == cOrder);
        Header_SetOrderArray(hwndHeader, Header_GetItemCount(hwndHeader), rgOrder);
    }
}


/*++ CProcPage::RememberColumnOrder

Routine Description:

    Saves the current column order to the global COptions object
    which is later saved to the registry for per-user preferences.
    
Arguments:

    hwndList - Listview window handle.

Return Value:

Revision History:

      Jan-11/99 BrianAu  Created

--*/

void
CProcPage::RememberColumnOrder(
    HWND hwndList
    )
{
    const HWND hwndHeader = ListView_GetHeader(hwndList);

    ASSERT(Header_GetItemCount(hwndHeader) <= ARRAYSIZE(g_Options.m_ColumnPositions));

    FillMemory(&g_Options.m_ColumnPositions, sizeof(g_Options.m_ColumnPositions), 0xFF);
    Header_GetOrderArray(hwndHeader, 
                         Header_GetItemCount(hwndHeader),
                         g_Options.m_ColumnPositions);
}



/*++ FindProcInArrayByPID

Class Description:

    Walks the ptrarray given and looks for the CProcInfo object
    that has the PID supplied.  If not found, returns NULL

Arguments:

    pArray      - The CPtrArray where the CProcInfos could live
    pid         - The pid to search for

Return Value:

    CProcInfo * in the array, if found, or NULL if not

Revision History:

      Nov-20-95 Davepl  Created

--*/

CProcInfo * FindProcInArrayByPID(CPtrArray * pArray, DWORD pid)
{
    for (int i = 0; i < pArray->GetSize(); i++)
    {
        CProcInfo * pTmp = (CProcInfo *) (pArray->GetAt(i));
        
        if (pTmp->m_UniqueProcessId == pid)
        {
            // Found it

            return pTmp;
        }
    }

    // Not found

    return NULL;
}

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CProcInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CProcInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 Davepl  Created

--*/

BOOL InsertIntoSortedArray(CPtrArray * pArray, CProcInfo * pProc)
{
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CProcInfo * pTmp = (CProcInfo *) pArray->GetAt(iIndex);
        
        if (pProc->Compare(pTmp) > 0)
        {
            return pArray->InsertAt(iIndex, pProc);
        }
    }

    return pArray->Add(pProc);
}

/*++ ResortArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 Davepl  Created

--*/

BOOL ResortArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
        return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CProcInfo * pItem = (CProcInfo *) (*ppArray)->GetAt(i);
      
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}

//
//
//
typedef struct
{
    LARGE_INTEGER               uPassCount;
    CProcPage *                 pProcPage;
    CProcInfo *                 pParentProcInfo;
    LARGE_INTEGER               TotalTime;
    LARGE_INTEGER               TimeLeft;
} WOWTASKCALLBACKPARMS, *PWOWTASKCALLBACKPARMS;

//
//
//
BOOL WINAPI WowTaskCallback(
    DWORD dwThreadId,
    WORD hMod16,
    WORD hTask16,
    CHAR *pszModName,
    CHAR *pszFileName,
    LPARAM lparam
    )
{
    PWOWTASKCALLBACKPARMS pParms = (PWOWTASKCALLBACKPARMS)lparam;
    HRESULT hr;

    hMod16;     // unrefernced
    pszModName; // unreferenced

    //
    // See if this task is already in the list.
    //
    
    CProcInfo * pOldProcInfo;
    pOldProcInfo = FindProcInArrayByPID(
                       pParms->pProcPage->m_pProcArray,
                       dwThreadId);

    if (NULL == pOldProcInfo)
    {
        //
        // We don't already have this process in our array, so create a new one
        // and add it to the array
        //

        CProcInfo * pNewProcInfo = new CProcInfo;
        if (NULL == pNewProcInfo)
        {
            goto done;
        }

        hr = pNewProcInfo->SetDataWowTask(pParms->TotalTime,
                                                    dwThreadId,
                                                    pszFileName,
                                                    pParms->uPassCount,
                                                    pParms->pParentProcInfo,
                                                    &pParms->TimeLeft,
                                                    hTask16,
                                                    FALSE);

        if (FAILED(hr) ||
            FALSE == pParms->pProcPage->m_pProcArray->Add(pNewProcInfo))
        {
            delete pNewProcInfo;
            goto done;
        }
    }
    else
    {
        //
        // This process already existed in our array, so update its info
        //

        pOldProcInfo->SetDataWowTask(pParms->TotalTime,
                                     dwThreadId,
                                     pszFileName,
                                     pParms->uPassCount,
                                     pParms->pParentProcInfo,
                                     &pParms->TimeLeft,
                                     hTask16,
                                     TRUE);
    }

done:
    return FALSE;  // continue enumeration
}


/*++ class CProcInfo::SetDataWowTask

Method Description:

    Sets up a single CProcInfo object based on the parameters.
    This is a WOW task pseudo-process entry.

Arguments:

    dwThreadId

    pszFilePath    Fully-qualified path from VDMEnumTaskWOWEx.

Return Value:

Revision History:

      18-Feb-96  DaveHart  created

--*/

HRESULT CProcInfo::SetDataWowTask(LARGE_INTEGER  TotalTime,
                                  DWORD          dwThreadId,
                                  CHAR *         pszFilePath,
                                  LARGE_INTEGER  uPassCount,
                                  CProcInfo *    pParentProcInfo,
                                  LARGE_INTEGER *pTimeLeft,
                                  WORD           htask,
                                  BOOL           fUpdateOnly)
{
    CHAR *pchExe;

    //
    // Touch this CProcInfo to indicate the process is still alive
    //

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // Update the thread's execution times.
    //

    HANDLE             hThread;
    NTSTATUS           Status;
    OBJECT_ATTRIBUTES  obja;
    CLIENT_ID          cid;
    ULONGLONG          ullCreation;

    InitializeObjectAttributes(
            &obja,
            NULL,
            0,
            NULL,
            0 );

    cid.UniqueProcess = 0;      // 0 means any process
    cid.UniqueThread  = IntToPtr(dwThreadId);

    Status = NtOpenThread(
                &hThread,
                THREAD_QUERY_INFORMATION,
                &obja,
                &cid );

    if ( NT_SUCCESS(Status) )
    {
        ULONGLONG ullExit, ullKernel, ullUser;

        if (GetThreadTimes(
                hThread,
                (LPFILETIME) &ullCreation,
                (LPFILETIME) &ullExit,
                (LPFILETIME) &ullKernel,
                (LPFILETIME) &ullUser
                ) )
        {
            LARGE_INTEGER TimeDelta, Time;

            Time.QuadPart = (LONGLONG)(ullUser + ullKernel);

            TimeDelta.QuadPart = Time.QuadPart - m_CPUTime.QuadPart;

            if (TimeDelta.QuadPart < 0)
            {
                ASSERT(0 && "WOW tasks's cpu total usage went DOWN since last refresh - Bug 247473, Shaunp");
                Invalidate();
                return E_FAIL;
            }

            if (TimeDelta.QuadPart)
            {
                m_fDirty_COL_CPUTIME = TRUE;
                m_CPUTime.QuadPart = Time.QuadPart;
            }

            //
            // Don't allow sum of WOW child task times to
            // exceed ntvdm.exe total.  We call GetThreadTimes
            // substantially after we get process times, so
            // this can happen.
            //

            if (TimeDelta.QuadPart > pTimeLeft->QuadPart)
            {
                TimeDelta.QuadPart = pTimeLeft->QuadPart;
                pTimeLeft->QuadPart = 0;
            }
            else
            {
                pTimeLeft->QuadPart -= TimeDelta.QuadPart;
            }

            SetCPU( TimeDelta, TotalTime, FALSE );

            //
            // When WOW tasks are being displayed, the line for ntvdm.exe
            // should show times only for overhead or historic threads,
            // not including any active task threads.
            //

            if (pParentProcInfo->m_DisplayCPUTime.QuadPart > m_CPUTime.QuadPart)
            {
                pParentProcInfo->m_DisplayCPUTime.QuadPart -= m_CPUTime.QuadPart;
            }
            else
            {
                pParentProcInfo->m_DisplayCPUTime.QuadPart = 0;
            }

            m_DisplayCPUTime.QuadPart = m_CPUTime.QuadPart;
        }

        NtClose(hThread);
    }

    if (m_PriClass != pParentProcInfo->m_PriClass) {
        m_fDirty_COL_BASEPRIORITY = TRUE;
        m_PriClass = pParentProcInfo->m_PriClass;
    }

    if( m_SessionId != pParentProcInfo->m_SessionId )
    {
        m_fDirty_COL_SESSIONID = TRUE;

        m_SessionId = pParentProcInfo->m_SessionId;
    }

    if (FALSE == fUpdateOnly)
    {
        DWORD cchLen;

        //
        // Set the task's image name, thread ID, thread count,
        // htask, and parent CProcInfo which do not change over
        // time.
        //

        m_htaskWow = htask;

        m_fDirty_COL_PID = TRUE;
        m_fDirty_COL_IMAGENAME = TRUE;
        m_fDirty_COL_THREADCOUNT = TRUE;
        m_fDirty_COL_USERNAME = TRUE;
        m_fDirty_COL_SESSIONID = TRUE;
        m_UniqueProcessId = dwThreadId;
        m_ThreadCount = 1;

        //
        // We're only interested in the filename of the EXE
        // with the path stripped.
        //

        pchExe = strrchr(pszFilePath, '\\');
        if (NULL == pchExe) 
        {
            pchExe = pszFilePath;
        }
        else
        {
            // skip backslash
            pchExe++;
        }

        cchLen = lstrlenA(pchExe);

        //
        // Indent the EXE name by two spaces
        // so WOW tasks look subordinate to
        // their ntvdm.exe
        //
        m_pszImageName = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszImageName) * ( cchLen + 3 ) );
        if (NULL == m_pszImageName)
        {
            return E_OUTOFMEMORY;
        }

        m_pszImageName[0] = m_pszImageName[1] = TEXT(' ');

        MultiByteToWideChar(
            CP_ACP,
            0,
            pchExe,
            cchLen,
            &m_pszImageName[2],
            cchLen
            );
        m_pszImageName[cchLen + 2] = 0;   // make sure it is terminated

        //
        // WOW EXE filenames are always uppercase, so lowercase it.
        //

        CharLowerBuff( &m_pszImageName[2], cchLen );

        m_pWowParentProcInfo = pParentProcInfo;
        
        if( g_fIsTSEnabled )
        {
            SetProcessUsername( LPFILETIME( &ullCreation ) );
        }      
    }

    return S_OK;
}


/*++ class CProcInfo::SetData

Class Description:

    Sets up a single CProcInfo object based on the data contained in a
    SYSTEM_PROCESS_INFORMATION block.

    If fUpdate is set, the imagename and icon fields are not processed, 
    since they do not change throughout the lifetime of the process

Arguments:

    TotalTime - Total elapsed time, used as the denominator in calculations
                for the process' CPU usage, etc
    pInfo     - The SYSTEM_PROCESS_INFORMATION block for this process
    uPassCount- Current passcount, used to timestamp the last update of 
                this objectg
    fUpdate   - See synopsis

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/


HRESULT CProcInfo::SetData(LARGE_INTEGER                TotalTime, 
                           PSYSTEM_PROCESS_INFORMATION  pInfo, 
                           LARGE_INTEGER                uPassCount,
                           CProcPage *                  pProcPage,
                           BOOL                         fUpdateOnly)
{
    HRESULT hr = S_OK;
    DWORD dwTemp;
    HANDLE hProcess;

    // Touch this CProcInfo to indicate the process is still alive

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    // Calc this process's total time as the sum of its user and kernel time

    LARGE_INTEGER TimeDelta;
    LARGE_INTEGER Time;

    if (pInfo->UserTime.QuadPart + pInfo->KernelTime.QuadPart < m_CPUTime.QuadPart)
    {
        // ASSERT(0 && "Proc's cpu total usage went DOWN since last refresh. - Davepl x69731, 425-836-1939 (res)");
        Invalidate();
        return hr = E_FAIL;
    }

    Time.QuadPart = pInfo->UserTime.QuadPart +
                    pInfo->KernelTime.QuadPart;

    TimeDelta.QuadPart = Time.QuadPart - m_CPUTime.QuadPart;

    if (TimeDelta.QuadPart)
    {
        m_CPUTime.QuadPart = m_DisplayCPUTime.QuadPart = Time.QuadPart;
        m_fDirty_COL_CPUTIME = TRUE;
    }

    SetCPU( TimeDelta, TotalTime, FALSE );

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    // Miscellaneous fields

    if (m_UniqueProcessId != PtrToUlong(pInfo->UniqueProcessId))
    {
        m_fDirty_COL_PID = TRUE;
        m_UniqueProcessId = PtrToUlong(pInfo->UniqueProcessId);
    }

    if( m_SessionId != pInfo->SessionId )
    {
        m_fDirty_COL_SESSIONID = TRUE;
        m_SessionId = pInfo->SessionId;
    }

    if (m_MemDiff != ((SSIZE_T)pInfo->WorkingSetSize / 1024) - (SSIZE_T)m_MemUsage )
    {
        m_fDirty_COL_MEMUSAGEDIFF = TRUE;
        m_MemDiff =  ((SSIZE_T)pInfo->WorkingSetSize / 1024) - (SSIZE_T)m_MemUsage;
    }

    if (m_MemPeak != (pInfo->PeakWorkingSetSize / 1024))
    {
        m_fDirty_COL_MEMPEAK = TRUE;
        m_MemPeak = (pInfo->PeakWorkingSetSize / 1024);
    }

    if (m_MemUsage != pInfo->WorkingSetSize / 1024)
    {
        m_fDirty_COL_MEMUSAGE = TRUE;
        m_MemUsage = (pInfo->WorkingSetSize / 1024);
    }

    if (m_PageFaultsDiff != ((LONG)(pInfo->PageFaultCount) - (LONG)m_PageFaults))
    {
        m_fDirty_COL_PAGEFAULTSDIFF = TRUE;
        m_PageFaultsDiff = ((LONG)(pInfo->PageFaultCount) - (LONG)m_PageFaults);
    }

    if (m_PageFaults != (pInfo->PageFaultCount))
    {
        m_fDirty_COL_PAGEFAULTS = TRUE;
        m_PageFaults = (pInfo->PageFaultCount);
    }

    if (m_CommitCharge != pInfo->PrivatePageCount / 1024)
    {
        m_fDirty_COL_COMMITCHARGE = TRUE;
        m_CommitCharge = pInfo->PrivatePageCount / 1024;
    }

    if (m_PagedPool != pInfo->QuotaPagedPoolUsage / 1024)
    {
        m_fDirty_COL_PAGEDPOOL = TRUE;
        m_PagedPool = pInfo->QuotaPagedPoolUsage / 1024;
    }

    if (m_NonPagedPool != pInfo->QuotaNonPagedPoolUsage / 1024)
    {
        m_fDirty_COL_NONPAGEDPOOL = TRUE;
        m_NonPagedPool = pInfo->QuotaNonPagedPoolUsage / 1024;
    }

    if (m_PriClass != pInfo->BasePriority)
    {
        m_fDirty_COL_BASEPRIORITY = TRUE;
        m_PriClass = pInfo->BasePriority;
    }

    if (m_HandleCount != pInfo->HandleCount)
    {
        m_fDirty_COL_HANDLECOUNT = TRUE;
        m_HandleCount = pInfo->HandleCount;
    }

    if (m_ThreadCount != pInfo->NumberOfThreads)
    {
        m_fDirty_COL_HANDLECOUNT = TRUE;
        m_ThreadCount = pInfo->NumberOfThreads;
    }

    if (m_IoReadOperCount != pInfo->ReadOperationCount.QuadPart)
    {
        m_fDirty_COL_READOPERCOUNT = TRUE;
        m_IoReadOperCount = pInfo->ReadOperationCount.QuadPart;
    }

    if (m_IoWriteOperCount != pInfo->WriteOperationCount.QuadPart)
    {
        m_fDirty_COL_WRITEOPERCOUNT = TRUE;
        m_IoWriteOperCount = pInfo->WriteOperationCount.QuadPart;
    }

    if (m_IoOtherOperCount != pInfo->OtherOperationCount.QuadPart)
    {
        m_fDirty_COL_OTHEROPERCOUNT = TRUE;
        m_IoOtherOperCount = pInfo->OtherOperationCount.QuadPart;
    }

    if (m_IoReadXferCount != pInfo->ReadTransferCount.QuadPart)
    {
        m_fDirty_COL_READXFERCOUNT = TRUE;
        m_IoReadXferCount = pInfo->ReadTransferCount.QuadPart;
    }

    if (m_IoWriteXferCount != pInfo->WriteTransferCount.QuadPart)
    {
        m_fDirty_COL_WRITEXFERCOUNT = TRUE;
        m_IoWriteXferCount = pInfo->WriteTransferCount.QuadPart;
    }

    if (m_IoOtherXferCount != pInfo->OtherTransferCount.QuadPart)
    {
        m_fDirty_COL_OTHERXFERCOUNT = TRUE;
        m_IoOtherXferCount = pInfo->OtherTransferCount.QuadPart;
    }

    hProcess = OpenProcess( PROCESS_QUERY_INFORMATION , FALSE, m_UniqueProcessId);
    if ( NULL != hProcess )
    {    
        dwTemp = GetGuiResources(hProcess, GR_USEROBJECTS);
        if ( m_USERObjectCount != dwTemp )
        {
            m_fDirty_COL_USEROBJECTS = TRUE;
            m_USERObjectCount = dwTemp;
        }

        dwTemp = GetGuiResources(hProcess, GR_GDIOBJECTS);
        if ( m_GDIObjectCount != dwTemp )
        {
            m_fDirty_COL_GDIOBJECTS = TRUE;
            m_GDIObjectCount = dwTemp;
        }

        CloseHandle(hProcess);
    }

    if (FALSE == fUpdateOnly)
    {
        //
        // Set the process' image name.  If its NULL it could be the "Idle Process" or simply
        // a process whose image name is unknown.  In both cases we load a string resource
        // with an appropriate replacement name.
        //

        m_fDirty_COL_IMAGENAME = TRUE;

        if (pInfo->ImageName.Buffer == NULL)
        {
            // No image name, so replace it with "Unknown"

            WCHAR szTmp[MAX_PATH];
            szTmp[0] = TEXT('\0');
            UINT  cchLen = LoadString(g_hInstance, IDS_SYSPROC, szTmp, MAX_PATH);
            cchLen ++;  // add one for NULL char.

            m_pszImageName = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszImageName) * cchLen );
            if (NULL == m_pszImageName)
            {
                return hr = E_OUTOFMEMORY;
            }

            StringCchCopy( m_pszImageName, cchLen, szTmp);  // should never be truncated
        }
        else
        {
            //
            // We have a valid image name, so allocate enough space and then
            // make a copy of it
            //
            DWORD cchLen = pInfo->ImageName.Length / sizeof(WCHAR) + 1;

            m_pszImageName = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszImageName) * cchLen );
            if (NULL == m_pszImageName)
            {
                    return hr = E_OUTOFMEMORY;
            }

            StringCchCopy( m_pszImageName, cchLen, pInfo->ImageName.Buffer ); // should never be truncated
        }

        if( g_fIsTSEnabled )
        {
            SetProcessUsername(LPFILETIME(&(pInfo->CreateTime)));
        }
    }

    //
    // Check if this process is a WOW process.  There is some latency
    // between the time a WOW process is created and the time
    // the shared memory used by VDMEnumTaskWOWEx reflects the new
    // process and tasks.  However, once a process becomes a WOW
    // process, it is always a WOW process until it dies.
    //

    if (g_Options.m_fShow16Bit)
    {
        if ( m_fWowProcess ||
             ! m_fWowProcessTested)
        {
#if !defined (_WIN64)

            if ( ( m_pszImageName != NULL ) && ( ! _wcsicmp(m_pszImageName, TEXT("ntvdm.exe")) ) )
            {

                WOWTASKCALLBACKPARMS WowTaskCallbackParms;

                WowTaskCallbackParms.uPassCount = uPassCount;
                WowTaskCallbackParms.pProcPage = pProcPage;
                WowTaskCallbackParms.pParentProcInfo = this;
                WowTaskCallbackParms.TotalTime.QuadPart = TotalTime.QuadPart;
                WowTaskCallbackParms.TimeLeft.QuadPart = TimeDelta.QuadPart;

                if (VDMEnumTaskWOWEx(m_UniqueProcessId,
                                     WowTaskCallback,
                                     (LPARAM) &WowTaskCallbackParms))
                {
                    if ( ! m_fWowProcess )
                    {
                        m_fWowProcessTested =
                            m_fWowProcess = TRUE;
                    }

                    SetCPU( WowTaskCallbackParms.TimeLeft, TotalTime, TRUE );
                }
                else
                {
                    //
                    // We avoid calling VDMEnumTaskWOWEx if the process has an
                    // execution time of more than 10 seconds and has not so
                    // far been seen as a WOW process.
                    //

                    if (GetCPUTime() > (10 * 10 * 1000 * 1000))
                    {
                        m_fWowProcessTested = TRUE;
                    }
                }
            }
            else
            {
                m_fWowProcessTested = TRUE;
            }
#else
            pProcPage; // unreferenced
            m_fWowProcessTested = TRUE;
#endif
        }
    }

    return S_OK;
}

//----------------------------------------------------------------
//
// No creation info
//
// Reviewed by alhen 9 - 3 - 98
//
HRESULT CProcInfo::SetProcessUsername(const FILETIME *pCreateTime)
{
    DWORD dwError = NO_ERROR;
    
    // in case of wow tasks assign username same as its parent process's

    if( IsWowTask( ) )
    {
        if( m_pWowParentProcInfo->m_pszUserName == NULL )
        {
            return E_FAIL;
        }

        DWORD cchLen = lstrlen( m_pWowParentProcInfo->m_pszUserName ) + 1;
        m_pszUserName = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszUserName) * cchLen );

        if( NULL == m_pszUserName )
        {
            return E_OUTOFMEMORY;
        }

        StringCchCopy( m_pszUserName, cchLen, m_pWowParentProcInfo->m_pszUserName );    // should never truncate

        return S_OK;
    }

    if( m_UniqueProcessId == 0 )     // this is a system idle process.
    {
        const WCHAR szIdleProcessOwner[] = L"SYSTEM";
        
        m_pszUserName = (LPWSTR) LocalAlloc( LPTR, sizeof(szIdleProcessOwner) );

        if( NULL == m_pszUserName )
        {
            return E_OUTOFMEMORY;
        }

        StringCbCopy( m_pszUserName, sizeof(szIdleProcessOwner), szIdleProcessOwner );  // should never truncate
    }
    else
    {
        PSID pUserSid = NULL;

        DWORD dwSize = 0;

        if( !WinStationGetProcessSid( NULL , GetRealPID( ) , *pCreateTime, ( PBYTE )pUserSid , &dwSize ) )
        {
            pUserSid = (PSID) LocalAlloc( LPTR, dwSize );
            if( pUserSid != NULL )
            {
                if( WinStationGetProcessSid( NULL , GetRealPID( ) , *pCreateTime, ( PBYTE )pUserSid , &dwSize ) )
                {
                    if( IsValidSid( pUserSid ) )
                    {
                        WCHAR szTmpName[MAX_PATH];

                        DWORD dwTmpNameSize = MAX_PATH;

                        CachedGetUserFromSid( pUserSid , szTmpName , &dwTmpNameSize );

                        m_pszUserName = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszUserName) * ( dwTmpNameSize + 1 ) );

                        if( m_pszUserName != NULL )
                        {
                            StringCchCopy( m_pszUserName, dwTmpNameSize + 1, szTmpName);    // don't care if it truncates - used in UI only
                        }
                    }
                }

                LocalFree( pUserSid );
            }
            else
            {
                dwError = GetLastError();
            }

        } // this would mean that a sid of size zero was returned
    }

    return HRESULT_FROM_WIN32(dwError);
}


/*++ CProcPage::UpdateProcListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by PID are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-20-95 Davepl  Created

--*/

HRESULT CProcPage::UpdateProcListview ()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_PROCLIST);

    //
    // Stop repaints while we party on the listview
    //

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);

    INT cListViewItems = ListView_GetItemCount(hListView);
    INT cProcArrayItems = m_pProcArray->GetSize();

    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //

    CProcInfo * pSelected = GetSelectedProcess();

    for (int iCurrent = 0, iCurrListViewItem = 0;
          iCurrListViewItem < cListViewItems  && iCurrent < cProcArrayItems;
         iCurrent++) // for each process
    {

        CProcInfo * pProc = (CProcInfo *) m_pProcArray->GetAt(iCurrent);
        
        //get only processes we need to show
        if(g_fIsTSEnabled && !g_Options.m_bShowAllProcess && !pProc->OkToShowThisProcess() ) {
            continue;
        }
        
        LV_ITEM lvitem = { 0 };
        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
        lvitem.iItem = iCurrListViewItem;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CProcInfo * pTmp = (CProcInfo *) lvitem.lParam;

        if (pTmp != pProc)
        {
            // If the objects aren't the same, we need to replace this line

            lvitem.pszText = pProc->m_pszImageName;
            lvitem.lParam = (LPARAM) pProc;

            if (pProc == pSelected)
            {
                lvitem.state |= LVIS_SELECTED | LVIS_FOCUSED;
            }
            else
            {
                lvitem.state &= ~(LVIS_SELECTED | LVIS_FOCUSED);
            }

            lvitem.stateMask |= LVIS_SELECTED | LVIS_FOCUSED;

            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrListViewItem, iCurrListViewItem);
        }
        else if (pProc->m_fDirty)
        {
            // Same PID, but item needs updating

            ListView_RedrawItems(hListView, iCurrListViewItem, iCurrListViewItem);
            pProc->m_fDirty = 0;
        }

        iCurrListViewItem++;
    }

    //
    // We've either run out of listview items or run out of proc array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrListViewItem < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrListViewItem);
        cListViewItems--;
    }

    while (iCurrent < cProcArrayItems)
    {
        // Need to add new items to the listview (new processes appeared)

        CProcInfo * pProc = (CProcInfo *)m_pProcArray->GetAt(iCurrent++);
        
        //get only processes we need to show
        if(g_fIsTSEnabled && !g_Options.m_bShowAllProcess && !pProc->OkToShowThisProcess() ) {
            continue;
        }

        LV_ITEM lvitem  = { 0 };
        lvitem.mask     = LVIF_PARAM | LVIF_TEXT;
        lvitem.iItem    = iCurrListViewItem;
        lvitem.pszText  = pProc->m_pszImageName;
        lvitem.lParam   = (LPARAM) pProc;

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrListViewItem == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
    
        ListView_InsertItem(hListView, &lvitem);
        iCurrListViewItem++;
    }

    ASSERT(iCurrListViewItem == ListView_GetItemCount(hListView));
    ASSERT(iCurrent == cProcArrayItems);

    // Let the listview paint again

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ class CProcPage::UpdateProcInfoArray

Class Description:

    Retrieves the list of process info blocks from the system,
    and runs through our array of CProcInfo items.  Items which
    already exist are updated, and those that do not are added.
    At the end, any process which has not been touched by this
    itteration of the function are considered to have completed
    and are removed from the array.

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

// See comments near the usage of this table below for info on why it exists

static struct
{
    size_t cbOffset;
    UINT   idString;
}
g_OffsetMap[] =
{
    { FIELD_OFFSET(CSysInfo, m_cHandles),         IDC_TOTAL_HANDLES   },
    { FIELD_OFFSET(CSysInfo, m_cThreads),         IDC_TOTAL_THREADS   },
    { FIELD_OFFSET(CSysInfo, m_cProcesses),       IDC_TOTAL_PROCESSES },
    { FIELD_OFFSET(CSysInfo, m_dwPhysicalMemory), IDC_TOTAL_PHYSICAL  },
    { FIELD_OFFSET(CSysInfo, m_dwPhysAvail),      IDC_AVAIL_PHYSICAL  },
    { FIELD_OFFSET(CSysInfo, m_dwFileCache),      IDC_FILE_CACHE      },
    { FIELD_OFFSET(CSysInfo, m_dwCommitTotal),    IDC_COMMIT_TOTAL    },
    { FIELD_OFFSET(CSysInfo, m_dwCommitLimit),    IDC_COMMIT_LIMIT    },
    { FIELD_OFFSET(CSysInfo, m_dwCommitPeak),     IDC_COMMIT_PEAK     },
    { FIELD_OFFSET(CSysInfo, m_dwKernelPaged),    IDC_KERNEL_PAGED    },
    { FIELD_OFFSET(CSysInfo, m_dwKernelNP),       IDC_KERNEL_NONPAGED },
    { FIELD_OFFSET(CSysInfo, m_dwKernelTotal),    IDC_KERNEL_TOTAL    },
};

//
//
//
HRESULT CProcPage::UpdateProcInfoArray()
{
    HRESULT  hr;
    INT      i;
    INT      iField;
    ULONG    cbOffset   = 0;
    CSysInfo SysInfoTemp;
    NTSTATUS Status;

    SYSTEM_BASIC_INFORMATION        BasicInfo;
    PSYSTEM_PROCESS_INFORMATION     pCurrent;
    SYSTEM_PERFORMANCE_INFORMATION  PerfInfo;
    SYSTEM_FILECACHE_INFORMATION    FileCache;

    LARGE_INTEGER TotalTime = {0,0};
    LARGE_INTEGER LastTotalTime = {0,0};

    //
    // Pass-count for this function.  It ain't thread-safe, of course, but I
    // can't imagine a scenario where we'll have mode than one thread running
    // through this (the app is currently single threaded anyway).  If we
    // overflow LARGE_INTEGER updates, I'll already be long gone, so don't bug me.
    //

    static LARGE_INTEGER uPassCount = {0,0};

    //
    // Get some non-process specific info, like memory status
    //

    Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL
             );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    SysInfoTemp.m_dwPhysicalMemory = (ULONG)(BasicInfo.NumberOfPhysicalPages * 
                                          (BasicInfo.PageSize / 1024));

    Status = NtQuerySystemInformation(
                SystemPerformanceInformation,
                &PerfInfo,
                sizeof(PerfInfo),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    SysInfoTemp.m_dwPhysAvail   = PerfInfo.AvailablePages    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwCommitTotal = (DWORD)(PerfInfo.CommittedPages    * (g_BasicInfo.PageSize / 1024));
    SysInfoTemp.m_dwCommitLimit = (DWORD)(PerfInfo.CommitLimit       * (g_BasicInfo.PageSize / 1024));
    SysInfoTemp.m_dwCommitPeak  = (DWORD)(PerfInfo.PeakCommitment    * (g_BasicInfo.PageSize / 1024));
    SysInfoTemp.m_dwKernelPaged = PerfInfo.PagedPoolPages    * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwKernelNP    = PerfInfo.NonPagedPoolPages * (g_BasicInfo.PageSize / 1024);
    SysInfoTemp.m_dwKernelTotal = SysInfoTemp.m_dwKernelNP + SysInfoTemp.m_dwKernelPaged;

    g_MEMMax = SysInfoTemp.m_dwCommitLimit;

    Status = NtQuerySystemInformation(
                SystemFileCacheInformation,
                &FileCache,
                sizeof(FileCache),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    //
    // The DWORD cast below must be fixed as this value can be greater than
    // 32 bits.
    //

    SysInfoTemp.m_dwFileCache = (DWORD)(FileCache.CurrentSizeIncludingTransitionInPages * (g_BasicInfo.PageSize / 1024));

    //
    // Read the process info structures into the flat buffer
    //

    hr = GetProcessInfo();
    if (FAILED(hr))
    {
        goto done;
    }

    //
    // First walk all of the process info blocks and sum their times, so that we can 
    // calculate a CPU usage ratio (%) for each individual process
    //

    cbOffset = 0;
    do
    {
        CProcInfo * pOldProcInfo;
        pCurrent = (PSYSTEM_PROCESS_INFORMATION)&((LPBYTE)m_pvBuffer)[cbOffset];

        if (pCurrent->UniqueProcessId == NULL && pCurrent->NumberOfThreads == 0)
        {
            // Zombie process, just skip it

            goto next;
        }

        pOldProcInfo = FindProcInArrayByPID(m_pProcArray, PtrToUlong(pCurrent->UniqueProcessId));
        if (pOldProcInfo)
        {
            if (pOldProcInfo->GetCPUTime() > pCurrent->KernelTime.QuadPart + pCurrent->UserTime.QuadPart)
            {
                // If CPU has gone DOWN, its because the PID has been reused, so invalidate this
                // CProcInfo such that it is removed and the new one added

                pOldProcInfo->Invalidate();
                goto next;
            }
            else if (pCurrent->UniqueProcessId == 0 &&
                     pCurrent->KernelTime.QuadPart == 0 && 
                     pCurrent->UserTime.QuadPart == 0)
            {
                pOldProcInfo->Invalidate();
                goto next;
            }
            else
            {
                LastTotalTime.QuadPart += pOldProcInfo->GetCPUTime();
            }
        }

        TotalTime.QuadPart += pCurrent->KernelTime.QuadPart + pCurrent->UserTime.QuadPart;
    
        SysInfoTemp.m_cHandles += pCurrent->HandleCount;
        SysInfoTemp.m_cThreads += pCurrent->NumberOfThreads;
        SysInfoTemp.m_cProcesses++;

next:
        cbOffset += pCurrent->NextEntryOffset;

        // if current session id is not set yet, set it now
        //
        // REVIEWER:  Previous dev didnot document this, but taskmgr session id
        // is cached so that when the user deselects "show all the processes", only
        // processes with session id's equal to taskmgr session id are listed
        // --alhen

        if( ( GetCurrentSessionID() == -1 ) && ( PtrToUlong(pCurrent->UniqueProcessId) == GetCurrentProcessId( ) ) )
        {
            SetCurrentSessionID( ( DWORD )pCurrent->SessionId );
        }

    } while (pCurrent->NextEntryOffset);


    LARGE_INTEGER TimeDelta;
    TimeDelta.QuadPart = TotalTime.QuadPart - LastTotalTime.QuadPart;

    ASSERT(TimeDelta.QuadPart >= 0);

    // Update the global count (visible to the status bar)

    g_cProcesses = SysInfoTemp.m_cProcesses;

    //
    // We have a number of text fields in the dialog that are based on counts we accumulate
    // here.  Rather than painting all of the time, we only change the ones whose values have
    // really changed.  We have a table up above of the offsets into the CSysInfo object
    // where these values live (the same offset in the real g_SysInfo object and the temp
    // working copy, of course), and what control ID they correspond to.  We then loop through
    // and compare each real one to the temp working copy, updating as needed.  Hard to
    // read, but smaller than a dozen if() statements.
    //

    extern CPage * g_pPages[];

    if (g_pPages[PERF_PAGE])
    {
        for (iField = 0; iField < ARRAYSIZE(g_OffsetMap); iField++)
        {
            DWORD * pdwRealCopy = (DWORD *)(((LPBYTE)&m_SysInfo)   + g_OffsetMap[iField].cbOffset);
            DWORD * pdwTempCopy = (DWORD *)(((LPBYTE)&SysInfoTemp) + g_OffsetMap[iField].cbOffset);

            *pdwRealCopy = *pdwTempCopy;

            WCHAR szText[32];
            StringCchPrintf( szText, ARRAYSIZE(szText), L"%d", *pdwRealCopy);   // don't care if it truncates - UI only

            HWND hPage = g_pPages[PERF_PAGE]->GetPageWindow();
            
            // Updates can come through before page is created, so verify
            // that it exists before we party on its children

            if (hPage)
            {
                SetWindowText(GetDlgItem(hPage, g_OffsetMap[iField].idString), szText);
            }
        }
    }

    //
    // Now walk the process info blocks again and refresh the CProcInfo array for each
    // individual process
    //

    cbOffset = 0;
    do
    {
        //
        // Grab a PROCESS_INFORMATION struct from the buffer
        //

        pCurrent = (PSYSTEM_PROCESS_INFORMATION)&((LPBYTE)m_pvBuffer)[cbOffset];

        if (pCurrent->UniqueProcessId == NULL && pCurrent->NumberOfThreads == 0)
        {
            // Zombie process, just skip it
            goto nextprocinfo;
        }

        //
        // This is really ugly, but... NtQuerySystemInfo has too much latency, and if you
        // change a process' priority, you don't see it reflected right away.  And, if you
        // don't have autoupdate on, you never do.  So, we use GetPriorityClass() to get
        // the value instead.  This means BasePriority is now the pri class, not the pri value.
        //

        if (pCurrent->UniqueProcessId)
        {
            HANDLE hProcess;
            hProcess = OpenProcess( PROCESS_QUERY_INFORMATION, FALSE, PtrToUlong(pCurrent->UniqueProcessId) );
            DWORD dwPriClass;
            dwPriClass = 0;

            if (hProcess) 
            {
                dwPriClass = GetPriorityClass(hProcess);
                if (dwPriClass)
                {
                    pCurrent->BasePriority = dwPriClass;
                }

                CloseHandle( hProcess );
            }

            if (NULL == hProcess || dwPriClass == 0)
            {
                // We're not allowed to open this process, so convert what NtQuerySystemInfo
                // gave us into a priority class... its the next best thing

                if (pCurrent->BasePriority <= 4)
                {
                    pCurrent->BasePriority = IDLE_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <= 6)
                {
                    pCurrent->BasePriority = BELOW_NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <= 8)
                {
                    pCurrent->BasePriority = NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <=  10)
                {
                    pCurrent->BasePriority = ABOVE_NORMAL_PRIORITY_CLASS;
                }
                else if (pCurrent->BasePriority <=  13)
                {
                    pCurrent->BasePriority = HIGH_PRIORITY_CLASS;
                }
                else
                {
                    pCurrent->BasePriority = REALTIME_PRIORITY_CLASS;
                }
            }
        }

        //
        // Try to find an existing CProcInfo instance which corresponds to this process
        //

        CProcInfo * pProcInfo;
        pProcInfo = FindProcInArrayByPID(m_pProcArray, PtrToUlong(pCurrent->UniqueProcessId));

        if (NULL == pProcInfo)
        {
            //
            // We don't already have this process in our array, so create a new one
            // and add it to the array
            //

            pProcInfo = new CProcInfo;
            if (NULL == pProcInfo)
            {
                hr = E_OUTOFMEMORY;
                goto done;
            }

            hr = pProcInfo->SetData(TimeDelta,
                                    pCurrent,
                                    uPassCount,
                                    this,
                                    FALSE);

            if (FAILED(hr) || FALSE == m_pProcArray->Add(pProcInfo))
            {
                delete pProcInfo;
                goto done;
            }
        }
        else
        {
            //
            // This process already existed in our array, so update its info
            //

            hr = pProcInfo->SetData(TimeDelta,
                                    pCurrent,
                                    uPassCount,
                                    this,
                                    TRUE);
            if (FAILED(hr))
            {
                goto done;
            }
        }

        nextprocinfo:

        cbOffset += pCurrent->NextEntryOffset;

    } while (pCurrent->NextEntryOffset);

    //
    // Run through the CProcInfo array and remove anyone that hasn't been touched
    // by this pass through this function (which indicates the process is no
    // longer alive)
    //

    i = 0;
    while (i < m_pProcArray->GetSize())
    {
        CProcInfo * pProcInfo = (CProcInfo *)(m_pProcArray->GetAt(i));
        ASSERT(pProcInfo);

        //
        // If passcount doesn't match, delete the CProcInfo instance and remove
        // its pointer from the array.  Note that we _don't_ increment the index
        // if we remove an element, since the next element would now live at
        // the current index after the deletion
        //

        if (pProcInfo->m_uPassCount.QuadPart != uPassCount.QuadPart)
        {
            delete pProcInfo;
            m_pProcArray->RemoveAt(i, 1);
        }
        else
        {
            i++;
        }
    }

done:

    ResortArray(&m_pProcArray);
    uPassCount.QuadPart++;

    return hr;
}

/*++ CPerfPage::SizeProcPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::SizeProcPage()
{
    // Get the coords of the outer dialog

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos(3);
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcTerminate;
    HWND hwndTerminate = GetDlgItem(m_hPage, IDC_TERMINATE);
    GetWindowRect(hwndTerminate, &rcTerminate);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcTerminate, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcTerminate.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcTerminate.bottom);

    // Move the EndProcess button

    DeferWindowPos(hdwp, hwndTerminate, NULL, 
                     rcTerminate.left + dx, 
                     rcTerminate.top + dy,
                     0, 0,
                     SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);

    HWND hwndShowall = GetDlgItem(m_hPage, IDC_SHOWALL);

    if( IsWindow( hwndShowall ) )
    {
        if( g_fIsTSEnabled )
        {
            RECT rcShowall;
            
            GetWindowRect(hwndShowall, &rcShowall);
            
            MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcShowall, 2);
            
            DeferWindowPos(hdwp, hwndShowall, NULL, rcShowall.left, rcShowall.top + dy, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
        }
        else
        {
            // this window must be hidden.
        
            ShowWindow(hwndShowall, SW_HIDE);
        }
    }

    //
    // Size the listbox
    //

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_PROCLIST);
    RECT rcListbox;
    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);
    DeferWindowPos(hdwp, hwndListbox, NULL,
                        0, 0,
                        rcTerminate.right - rcListbox.left + dx,
                        rcTerminate.top - rcListbox.top + dy - g_DefSpacing,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    EndDeferWindowPos(hdwp);
}

/*++ CProcPage::HandleTaskManNotify

Routine Description:

    Processes WM_NOTIFY messages received by the procpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-20-95 Davepl  Created

--*/
INT CProcPage::HandleProcPageNotify(LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
    case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
        
            if (g_iProcSortColumnID == g_Options.m_ActiveProcCol[pnmv->iSubItem])
            {
                g_iProcSortDirection  *= -1;
            }
            else
            {
                g_iProcSortColumnID = g_Options.m_ActiveProcCol[pnmv->iSubItem];
                g_iProcSortDirection  = -1;
            }
            ResortArray(&m_pProcArray);
            TimerEvent();
        }
        break;

    case LVN_ITEMCHANGED:
        {
            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_PROCLIST));
                EnableWindow(GetDlgItem(m_hPage, IDC_TERMINATE), cSelected ? TRUE : FALSE);   
            }
        }
        break;

    case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
        
            // Listview needs a text string

            if (plvitem->mask & LVIF_TEXT)
            {
                COLUMNID columnid = (COLUMNID) g_Options.m_ActiveProcCol[plvitem->iSubItem];
                const CProcInfo  * pProcInfo   = (const CProcInfo *)   plvitem->lParam;

                //
                // Most columns are blank for WOW tasks.
                //

                if (pProcInfo->IsWowTask() &&
                    columnid != COL_IMAGENAME &&
                    columnid != COL_BASEPRIORITY &&
                    columnid != COL_THREADCOUNT &&
                    columnid != COL_CPUTIME &&
                    columnid != COL_USERNAME &&
                    columnid != COL_SESSIONID &&
                    columnid != COL_CPU) {

                    plvitem->pszText[0] = L'\0';
                    goto done;
                }

                switch(columnid)
                {
                case COL_PID:
                    //  don't care if it truncates - UI only
                    StringCchPrintf(plvitem->pszText, plvitem->cchTextMax, L"%d", (ULONG) pProcInfo->m_UniqueProcessId );
                    break;

                case COL_USERNAME:
                    if( pProcInfo->m_pszUserName )
                    {
                        //  don't care if it truncates - UI only
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pProcInfo->m_pszUserName );
                    }
                    break;

                case COL_SESSIONID:
                    //  don't care if it truncates - UI only
                    StringCchPrintf( plvitem->pszText, plvitem->cchTextMax, L"%d", pProcInfo->m_SessionId );
                    break;

                case COL_CPU:
                    //  don't care if it truncates - UI only
                    StringCchPrintf(plvitem->pszText, plvitem->cchTextMax, L"%02d %", pProcInfo->m_DisplayCPU );
                    break;

                case COL_IMAGENAME:
                    //  don't care if it truncates - UI only
                    StringCchCopy(plvitem->pszText, plvitem->cchTextMax, pProcInfo->m_pszImageName );
                    break;
            
                case COL_CPUTIME:
                {
                    TIME_FIELDS TimeOut;
                
                    RtlTimeToElapsedTimeFields ( (LARGE_INTEGER *)&(pProcInfo->m_DisplayCPUTime), &TimeOut);
                    TimeOut.Hour = static_cast<CSHORT>(TimeOut.Hour + static_cast<SHORT>(TimeOut.Day * 24));
                
                    //  don't care if it truncates - UI only
                    StringCchPrintf( plvitem->pszText
                                   , plvitem->cchTextMax
                                   , L"%2d%s%02d%s%02d"
                                   , TimeOut.Hour
                                   , g_szTimeSep
                                   , TimeOut.Minute
                                   , g_szTimeSep
                                   , TimeOut.Second
                                   );
                    break;
                }
                case COL_MEMUSAGE:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemUsage), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_MEMUSAGEDIFF:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemDiff), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_MEMPEAK:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_MemPeak), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_PAGEFAULTS:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_PageFaults), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_PAGEFAULTSDIFF:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_PageFaultsDiff), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_COMMITCHARGE:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_CommitCharge), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_PAGEDPOOL:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_PagedPool), plvitem->pszText, plvitem->cchTextMax);
                    break;
                
                case COL_NONPAGEDPOOL:
                    Int64ToCommaSepKString(LONGLONG(pProcInfo->m_NonPagedPool), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_BASEPRIORITY:
                {
                    LPCTSTR pszClass = NULL;

                    switch(pProcInfo->m_PriClass)
                    {
                    case REALTIME_PRIORITY_CLASS:
                        pszClass = g_szRealtime;
                        break;

                    case HIGH_PRIORITY_CLASS:
                        pszClass = g_szHigh;
                        break;

                    case ABOVE_NORMAL_PRIORITY_CLASS:
                        pszClass = g_szAboveNormal;
                        break;

                    case NORMAL_PRIORITY_CLASS:
                        pszClass = g_szNormal;
                        break;

                    case BELOW_NORMAL_PRIORITY_CLASS:
                        pszClass = g_szBelowNormal;
                        break;

                    case IDLE_PRIORITY_CLASS:
                        pszClass = g_szLow;
                        break;

                    default:
                        pszClass = g_szUnknown;
                        break;
                    }

                    //  don't care if it truncates - UI only
                    StringCchCopy(plvitem->pszText, plvitem->cchTextMax, pszClass );
                    break;
                }

                case COL_HANDLECOUNT:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_HandleCount), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_THREADCOUNT:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_ThreadCount), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_USEROBJECTS:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_USERObjectCount), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_GDIOBJECTS:
                    Int64ToCommaSepString(LONGLONG(pProcInfo->m_GDIObjectCount), plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_READOPERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoReadOperCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_WRITEOPERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoWriteOperCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_OTHEROPERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoOtherOperCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_READXFERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoReadXferCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_WRITEXFERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoWriteXferCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                case COL_OTHERXFERCOUNT:
                    Int64ToCommaSepString(pProcInfo->m_IoOtherXferCount, plvitem->pszText, plvitem->cchTextMax);
                    break;

                default:
                    Assert( 0 && "Unknown listview subitem" );
                    break;

                } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
        break;
    
    } // end switch(pnmhdr->code)

done:
    return 1;
}

/*++ CProcPage::TimerEvent

Routine Description:

    Called by main app when the update time fires
    
Arguments:

Return Value:

Revision History:

      Nov-20-95 Davepl  Created

--*/

void CProcPage::TimerEvent()
{
    if (FALSE == m_fPaused)
    {
        // We only process updates when the display is not paused, ie:
        // not during trackpopupmenu loop
        UpdateProcInfoArray();
        UpdateProcListview();
    }
}

/*++ CProcPage::HandleProcListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the proc list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

void CProcPage::HandleProcListContextMenu(INT xPos, INT yPos)
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_PROCLIST);

    INT iItem = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);

    if (-1 != iItem)
    {
        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            RECT rcItem;
            ListView_GetItemRect(hTaskList, iItem, &rcItem, LVIR_ICON);
            MapWindowRect(hTaskList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }

        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_PROC_CONTEXT);
        if (hPopup)
        {
            if (hPopup && SHRestricted(REST_NORUN))
            {
                DeleteMenu(hPopup, IDM_RUN, MF_BYCOMMAND);
            }

            CProcInfo * pProc = GetSelectedProcess();
            if (NULL == pProc)
            {
                return;
            }

            //
            // If no debugger is installed or it's a 16-bit app
            // ghost the debug menu item
            //

            if (NULL == m_pszDebugger || pProc->IsWowTask())
            {
                EnableMenuItem(hPopup, IDM_PROC_DEBUG, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If it's a 16-bit task grey the priority choices
            //

            if (pProc->IsWowTask())
            {
                EnableMenuItem(hPopup, IDM_PROC_REALTIME,   MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_ABOVENORMAL,MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_NORMAL,     MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_BELOWNORMAL,MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_HIGH,       MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_PROC_LOW,        MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If not an MP machine, remove the affinity option
            //

            if (1 == g_cProcessors || pProc->IsWowTask())
            {
                DeleteMenu(hPopup, IDM_AFFINITY, MF_BYCOMMAND);
            }
                    
            DWORD dwPri   = pProc->m_PriClass;
            INT   idCheck = 0;

            //
            // These constants are listed in the SDK
            //

            if (dwPri == IDLE_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_LOW;    
            }
            else if (dwPri == BELOW_NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_BELOWNORMAL;
            }
            else if (dwPri == NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_NORMAL;
            }
            else if (dwPri == ABOVE_NORMAL_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_ABOVENORMAL;
            }
            else if (dwPri == HIGH_PRIORITY_CLASS)
            {
                idCheck = IDM_PROC_HIGH;
            }
            else
            {
                Assert(dwPri == REALTIME_PRIORITY_CLASS);
                idCheck = IDM_PROC_REALTIME;
            }

            // Check the appropriate radio menu for this process' priority class

            CheckMenuRadioItem(hPopup, IDM_PROC_REALTIME, IDM_PROC_LOW, idCheck, MF_BYCOMMAND);

            m_fPaused = TRUE;
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;
            m_fPaused = FALSE;
            
            //
            // If one of the context menu actions (ie: Kill) requires that the display
            // get updated, do it now
            //

            DestroyMenu(hPopup);
        }
    }
}

/*++ AffinityDlgProc

Routine Description:

    Dialog procedure for the affinity mask dialog.  Basically just tracks 32 check
    boxes that represent the processors
    
Arguments:

    standard dlgproc fare 0 - initial lParam is pointer to affinity mask

Revision History:

      Jan-17-96 Davepl  Created

--*/

INT_PTR CALLBACK AffinityDlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static DWORD_PTR * pdwAffinity = NULL;      // One of the joys of single threadedness

    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            pdwAffinity = (DWORD_PTR *) lParam;

            WCHAR szName[ 64 ];
            WCHAR szFormatString[ 64 ];
            RECT rcCPU0;
            HFONT hFont;
            HWND hwndCPU0 = GetDlgItem( hwndDlg, IDC_CPU0 );

            GetWindowRect( hwndCPU0, &rcCPU0 );
            MapWindowPoints(HWND_DESKTOP, hwndDlg, (LPPOINT) &rcCPU0, 2);

            GetWindowText( hwndCPU0, szFormatString, ARRAYSIZE(szFormatString) );
            hFont = (HFONT) SendMessage( hwndCPU0, WM_GETFONT, 0, 0 );

            StringCchPrintf( szName, ARRAYSIZE(szName), szFormatString, 0 );
            SetWindowText( hwndCPU0, szName );
            CheckDlgButton(hwndDlg, IDC_CPU0, ((*pdwAffinity & 1 ) != 0));

            int width = rcCPU0.right - rcCPU0.left + g_ControlWidthSpacing;
            int height = rcCPU0.bottom - rcCPU0.top + g_ControlHeightSpacing;

            int cProcessors = (int) ( g_cProcessors > sizeof(*pdwAffinity) * 8 ? sizeof(*pdwAffinity) * 8 : g_cProcessors );

            for ( int i = 1; i < cProcessors; i ++ )
            {
                StringCchPrintf( szName, ARRAYSIZE(szName), szFormatString, i );

                HWND hwnd = CreateWindow( L"BUTTON"
                                        , szName
                                        , BS_AUTOCHECKBOX | WS_TABSTOP | WS_VISIBLE | WS_CHILD
                                        , rcCPU0.left + width * ( i % 4 )
                                        , rcCPU0.top + height * ( i / 4)
                                        , rcCPU0.right - rcCPU0.left
                                        , rcCPU0.bottom - rcCPU0.top
                                        , hwndDlg
                                        , (HMENU) ((ULONGLONG) IDC_CPU0 + i)
                                        , NULL // ignored
                                        , NULL
                                        );
                if ( NULL != hwnd )
                {
                    SendMessage( hwnd, WM_SETFONT, (WPARAM) hFont, TRUE );

                    if ( *pdwAffinity & (1ULL << i) )
                    {
                        CheckDlgButton(hwndDlg, IDC_CPU0 + i, TRUE);
                    }
                }
            }

            if ( cProcessors > 4 )
            {
                //
                //  Need to make the dialog bigger and move some stuff around.
                //

                int delta = height * (( cProcessors / 4 ) + ( cProcessors % 4 == 0 ? 0 : 1 ) );

                RECT rc;
                HWND hwnd;

                hwnd = GetDlgItem( hwndDlg, IDOK );
                GetWindowRect( hwnd, &rc );
                MapWindowPoints(HWND_DESKTOP, hwndDlg, (LPPOINT) &rc, 2);
                SetWindowPos( hwnd, NULL, rc.left, rcCPU0.top + delta, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );

                hwnd = GetDlgItem( hwndDlg, IDCANCEL );
                GetWindowRect( hwnd, &rc );
                MapWindowPoints(HWND_DESKTOP, hwndDlg, (LPPOINT) &rc, 2);
                SetWindowPos( hwnd, NULL, rc.left, rcCPU0.top + delta, 0, 0, SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE );

                GetClientRect( hwndDlg, &rc );
                SetWindowPos( hwndDlg, NULL, 0, 0, rc.right, rc.bottom + delta + g_ControlHeightSpacing, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE );
            }

            SetFocus( hwndCPU0 );
        }
        return FALSE;    // do not set the default focus.

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDCANCEL:
            EndDialog(hwndDlg, IDCANCEL);
            break;

        case IDOK:
            *pdwAffinity = 0;
            for (int i = 0; i < g_cProcessors; i++)
            {
                if (IsDlgButtonChecked(hwndDlg, IDC_CPU0 + i))
                {
                    *pdwAffinity |= 1ULL << i;
                }
            }

            if (*pdwAffinity == 0)
            {
                // Can't set affinity to "none"

                WCHAR szTitle[MAX_PATH];
                WCHAR szBody[MAX_PATH];

                if (0 == LoadString(g_hInstance, IDS_INVALIDOPTION, szTitle, ARRAYSIZE(szTitle)) ||
                    0 == LoadString(g_hInstance, IDS_NOAFFINITYMASK, szBody,  ARRAYSIZE(szBody)))
                {
                    break;
                }
                MessageBox(hwndDlg, szBody, szTitle, MB_ICONERROR);
                break;
            }

            EndDialog(hwndDlg, IDOK);
            break;
        }
        break;
    }

    return FALSE;
}

/*++ SetAffinity

Routine Description:

    Puts up a dialog that lets the user adjust the processor affinity
    for a process
    
Arguments:

    pid - process Id of process to modify

Return Value:

    boolean success

Revision History:

      Jan-17-96 Davepl  Created

--*/

BOOL CProcPage::SetAffinity(DWORD pid)
{
    BOOL fSuccess = FALSE;

    HANDLE hProcess = OpenProcess( PROCESS_SET_INFORMATION | PROCESS_QUERY_INFORMATION, FALSE, pid );
    if (hProcess) 
    {
        DWORD_PTR dwAffinity;
        DWORD_PTR dwUnusedSysAfin;

        if (GetProcessAffinityMask(hProcess, &dwAffinity, &dwUnusedSysAfin))
        {
            if (IDOK == DialogBoxParam(g_hInstance, 
                                       MAKEINTRESOURCE(IDD_AFFINITY), 
                                       m_hPage, 
                                       AffinityDlgProc, 
                                       (LPARAM) &dwAffinity))
            {
                if (SetProcessAffinityMask(hProcess, dwAffinity))
                {
                    fSuccess = TRUE;
                }
            }
            else
            {
                fSuccess = TRUE;        // Cancel, so no failure
            }
        }
   
        CloseHandle(hProcess);
    }

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        DisplayFailureMsg(m_hPage, IDS_CANTSETAFFINITY, dwError);
    }
   
    return fSuccess;
}

//
//
//
BOOL CProcPage::IsSystemProcess(DWORD pid, CProcInfo * pProcInfo)
{
    // We don't allow the following set of critical system processes to be terminated,
    // since the system would bugcheck immediately, no matter who you are.

    static const LPCTSTR apszCantKill[] =
    {
        TEXT("csrss.exe"), TEXT("winlogon.exe"), TEXT("smss.exe"), TEXT("services.exe"), TEXT("lsass.exe")
    };

    // if they pass in a pProcInfo we'll use it, otherwise find it ourselves
    if (!pProcInfo)
    {
        pProcInfo = FindProcInArrayByPID(m_pProcArray, pid);
    }
    if (!pProcInfo)
    {
        return FALSE;
    }

    for (int i = 0; i < ARRAYSIZE(apszCantKill); ++i)
    {
        if (0 == lstrcmpi(pProcInfo->m_pszImageName, apszCantKill[i]))
        {
            WCHAR szTitle[MAX_PATH];
            WCHAR szBody[MAX_PATH];

            if (0 != LoadString(g_hInstance, IDS_CANTKILL, szTitle, ARRAYSIZE(szTitle)) &&
                0 != LoadString(g_hInstance, IDS_KILLSYS,  szBody,  ARRAYSIZE(szBody)))
            {
                MessageBox(m_hPage, szBody, szTitle, MB_ICONEXCLAMATION | MB_OK);
            }
            return TRUE;
        }
    }

    return FALSE;
}

/*++ KillProcess

Routine Description:

    Kills a process 
    
Arguments:

    pid - process Id of process to kill

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

BOOL CProcPage::KillProcess(DWORD pid, BOOL bBatchKill)
{
    DWORD dwError = ERROR_SUCCESS;

    //
    // Special-case killing WOW tasks
    //

    CProcInfo * pProcInfo;
    pProcInfo = FindProcInArrayByPID(m_pProcArray, pid);

    if (NULL == pProcInfo)
        return FALSE;

    if (IsSystemProcess(pid, pProcInfo))
        return FALSE;

    // Grab info from pProcInfo (because once we call QuickConfirm(), the
    // pProcInfo pointer may be invalid)
    INT_PTR fWowTask = pProcInfo->IsWowTask();
#if defined (_WIN64)
#else
    DWORD dwRealPID = pProcInfo->GetRealPID();
    WORD hTaskWow = pProcInfo->m_htaskWow;
#endif

    // OK so far, now confirm that the user really wants to do this.

    if (!bBatchKill && (IDYES != QuickConfirm(IDS_WARNING, IDS_KILL)))
    {
        return FALSE;
    }

    // We can't use this pointer after QuickConfirm() is called.
    // NULL it out to prevent subtle bugs.
    pProcInfo = NULL;

    
    if (fWowTask) {

#if defined (_WIN64)
        return FALSE;
#else
        return VDMTerminateTaskWOW(dwRealPID, hTaskWow);
#endif
    }

    //
    // If possible, enable the Debug privilege. This allows us to kill
    // processes not owned by the current user, including processes
    // running in other TS sessions.
    //
    // Alternatively, we could first open the process for WRITE_DAC,
    // grant ourselves PROCESS_TERMINATE access, and then reopen the
    // process to kill it.
    //
    CPrivilegeEnable privilege(SE_DEBUG_NAME);

    HANDLE hProcess = OpenProcess( PROCESS_TERMINATE, FALSE, pid );
    if (hProcess) 
    {
        if (FALSE == TerminateProcess( hProcess, 1 )) 
        {
            dwError = GetLastError();
        }
        else
        {
            TimerEvent();
        }
        CloseHandle( hProcess );
    }
    else
    {
        dwError = GetLastError();
    }
    
    if (ERROR_SUCCESS != dwError)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTKILL, dwError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }

}

/*++ AttachDebugger

Routine Description:

    Attaches the debugger listed in the AeDebug reg key to the specified
    running process
    
Arguments:

    pid - process Id of process to debug

Return Value:

Revision History:

      Nov-27-95 Davepl  Created

--*/

BOOL CProcPage::AttachDebugger(DWORD pid)
{
    if (IDYES != QuickConfirm(IDS_WARNING, IDS_DEBUG))
    {
        return FALSE;
    }

    WCHAR szCmdline[MAX_PATH * 2];

    //
    //  Don't construct an incomplete string.
    //

    HRESULT hr = StringCchPrintf( szCmdline, ARRAYSIZE(szCmdline), L"%s -p %ld", m_pszDebugger, pid );
    if ( S_OK == hr )
    {
        STARTUPINFO sinfo =
        {
            sizeof(STARTUPINFO),
        };
        PROCESS_INFORMATION pinfo;

        if (FALSE == CreateProcess(NULL,
                                   szCmdline,
                                   NULL,
                                   NULL,
                                   FALSE,
                                   CREATE_NEW_CONSOLE,
                                   NULL,
                                   NULL,
                                   &sinfo,
                                   &pinfo))
        {
            hr = GetLastHRESULT();
        }
        else
        {
            CloseHandle(pinfo.hThread);
            CloseHandle(pinfo.hProcess);
        }
    }

    if (S_OK != hr)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTDEBUG, hr);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

/*++ SetPriority

Routine Description:

    Sets a process' priority class
    
Arguments:

    pid - process Id of process to change
    pri - ID_CMD_XXXXXX menu choice of priority

Return Value:

Revision History:

      Nov-27-95 Davepl  Created

--*/

BOOL CProcPage::SetPriority(CProcInfo * pProc, DWORD idCmd)
{
    DWORD dwError = ERROR_SUCCESS;

    DWORD oldPri;
    DWORD pri;

    // Determine which priority class we need to use based
    // on the menu selection

    switch (idCmd)
    {
    case IDM_PROC_LOW:
        pri = IDLE_PRIORITY_CLASS;
        break;

    case IDM_PROC_BELOWNORMAL:
        pri = BELOW_NORMAL_PRIORITY_CLASS;
        break;

    case IDM_PROC_ABOVENORMAL:
        pri = ABOVE_NORMAL_PRIORITY_CLASS;
        break;

    case IDM_PROC_HIGH:
        pri = HIGH_PRIORITY_CLASS;
        break;

    case IDM_PROC_REALTIME:
        pri = REALTIME_PRIORITY_CLASS;
        break;

    default:
        Assert(idCmd == IDM_PROC_NORMAL);
        pri = NORMAL_PRIORITY_CLASS;
        break;
    }

    oldPri = (DWORD) pProc->m_PriClass;

    if ( oldPri == pri )
    {
        return FALSE;   // nothing to do.
    }

    //
    // Get confirmation before we change the priority
    //

    if (IDYES != QuickConfirm(IDS_WARNING, IDS_PRICHANGE))
    {
        return FALSE;
    }
    
    HANDLE hProcess = OpenProcess( PROCESS_SET_INFORMATION, FALSE, pProc->m_UniqueProcessId);
    if (hProcess) 
    {
        if (FALSE == SetPriorityClass( hProcess, pri )) 
        {
            dwError = GetLastError();
        }
        else
        {
            TimerEvent();
        }

        CloseHandle( hProcess );
    }
    else
    {
        dwError = GetLastError();
    }

    if (ERROR_SUCCESS != dwError)
    {
        DisplayFailureMsg(m_hPage, IDS_CANTCHANGEPRI, dwError);
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}


/*++ CProcPage::GetSelectedProcess

Routine Description:

    Returns the CProcInfo * of the currently selected process
    
Arguments:

Return Value:

    CProcInfo * on success, NULL on error or nothing selected

Revision History:

      Nov-22-95 Davepl  Created

--*/

CProcInfo * CProcPage::GetSelectedProcess()
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_PROCLIST);
    INT iItem = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);

    CProcInfo * pProc;

    if (-1 != iItem)
    {
        LV_ITEM lvitem = { LVIF_PARAM };
        lvitem.iItem = iItem;
    
        if (ListView_GetItem(hTaskList, &lvitem))
        {
            pProc = (CProcInfo *) (lvitem.lParam);
        }
        else
        {
            pProc = NULL;
        }
    }
    else
    {
        pProc = NULL;
    }

    return pProc;
}

/*++ CProcPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Nov-22-95 Davepl  Created

--*/

void CProcPage::HandleWMCOMMAND( WORD id , HWND hCtrl )
{
    CProcInfo * pProc = GetSelectedProcess();

    switch(id)
    {
    case IDC_DEBUG:
    case IDM_PROC_DEBUG:
        if (pProc && m_pszDebugger)
        {
            AttachDebugger( pProc->m_UniqueProcessId);
        }
        break;

    case IDC_ENDTASK:
    case IDC_TERMINATE:
    case IDM_PROC_TERMINATE:
        if (pProc)
        {
            KillProcess( pProc->m_UniqueProcessId);
        }
        break;

    case IDM_ENDTREE:
        if (pProc)
        {
            RecursiveKill( pProc->m_UniqueProcessId);
        }
        break;

    case IDM_AFFINITY:
        if (pProc)
        {
            SetAffinity( pProc->m_UniqueProcessId);
        }
        break;

    case IDM_PROC_REALTIME:
    case IDM_PROC_HIGH:
    case IDM_PROC_ABOVENORMAL:
    case IDM_PROC_NORMAL:
    case IDM_PROC_BELOWNORMAL:
    case IDM_PROC_LOW:
        if (pProc)
        {
            SetPriority( pProc, id);
        }
        break;

    case IDC_SHOWALL:
        g_Options.m_bShowAllProcess = SendMessage( hCtrl , BM_GETCHECK , 0 , 0 ) == BST_CHECKED;
        break;
    }
}

/*++ ProcPageProc

Routine Description:

    Dialogproc for the process page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:

    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-16-95 Davepl  Created

--*/

INT_PTR CALLBACK ProcPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    CProcPage * thispage = (CProcPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CProcPage * thispage = (CProcPage *) lParam;

            thispage->m_hPage = hwnd;

            // Turn on SHOWSELALWAYS so that the selection is still highlighted even
            // when focus is lost to one of the buttons (for example)

            HWND hTaskList = GetDlgItem(hwnd, IDC_PROCLIST);

            SetWindowLong(hTaskList, GWL_STYLE, GetWindowLong(hTaskList, GWL_STYLE) | LVS_SHOWSELALWAYS);
            ListView_SetExtendedListViewStyle(hTaskList, LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP | LVS_EX_DOUBLEBUFFER);

            //
            // This was removed from CProcPage::Activate
            // 
            HWND hchk = GetDlgItem( hwnd , IDC_SHOWALL );

            if( hchk != NULL )
            {
                if( g_fIsTSEnabled )
                {
                    // Disable the IDC_SHOWALL checkbox for non-admin. YufengZ  03/23/98

                    ShowWindow(hchk, TRUE);

                    if( !IsUserAdmin( ) )
                    {
                        EnableWindow( hchk, FALSE );
                    }
                    else
                    {
                        WPARAM wp = g_Options.m_bShowAllProcess ? BST_CHECKED : BST_UNCHECKED;

                        SendMessage( hchk , BM_SETCHECK , wp  , 0 );
                        //Button_SetCheck( hchk , BST_CHECKED );
                    }
                }
                else
                {
                    // hide the IDC_SHOWALL checkbox if its not terminal server.

                    ShowWindow( hchk , SW_HIDE );
                }
            }

        }
        // We handle focus during Activate(). Return FALSE here so the
        // dialog manager doesn't try to set focus.
        return FALSE;

    case WM_DESTROY:
        thispage->RememberColumnOrder(GetDlgItem(hwnd, IDC_PROCLIST));
        break;

    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        if (g_Options.m_fNoTitle)
        {
            SendMessage(g_hMainWnd, 
                        uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
                        HTCAPTION, 
                        lParam);
        }
        break;

    case WM_NCLBUTTONDBLCLK:
    case WM_LBUTTONDBLCLK:
        SendMessage(g_hMainWnd, uMsg, wParam, lParam);
        break;

    // We have been asked to find and select a process 

    case WM_FINDPROC:
        {
            DWORD cProcs = thispage->m_pProcArray->GetSize();
            DWORD dwProcessId;

            for (INT iPass = 0; iPass < 2; iPass++)
            {
                //
                // On the first pass we try to find a WOW
                // task with a thread ID which matches the
                // one given in wParam.  If we don't find
                // such a task, we look for a process which
                // matches the PID in lParam.
                //

                for (UINT i = 0; i < cProcs; i++)
                {
                    CProcInfo *pProc = (CProcInfo *)thispage->m_pProcArray->GetAt(i);
                    dwProcessId = pProc->m_UniqueProcessId;

                    if ((!iPass && wParam == (WPARAM) dwProcessId) ||
                        ( iPass && lParam == (LPARAM) dwProcessId))
                    {
                        // TS filters items out of the view so cannot assume
                        // that m_pProcArray is in sync with the listview.
                        HWND hwndLV = GetDlgItem(hwnd, IDC_PROCLIST);
                        LVFINDINFO fi;
                        fi.flags = LVFI_PARAM;
                        fi.lParam = (LPARAM)pProc;

                        int iItem = ListView_FindItem(hwndLV, -1, &fi);
                        if (iItem >= 0)
                        {
                            ListView_SetItemState (hwndLV,
                                                   iItem,
                                                   LVIS_FOCUSED | LVIS_SELECTED,
                                                   0x000F);
                            ListView_EnsureVisible(hwndLV, iItem, FALSE);
                        }
                        else
                        {
                            // We found the process but the user isn't allowed
                            // to see it; remove the selection
                            ListView_SetItemState (hwndLV,
                                                   -1,
                                                   0,
                                                   LVIS_FOCUSED | LVIS_SELECTED);
                        }
                        goto FoundProc;
                    }
                }
            }
        }
FoundProc:
        break;

    case WM_COMMAND:
        thispage->HandleWMCOMMAND( LOWORD(wParam) , ( HWND )lParam );
        break;

    case WM_CONTEXTMENU:
        {
            CProcInfo * pProc = thispage->GetSelectedProcess();
            if (pProc && pProc->m_UniqueProcessId)
            {
        
                if ((HWND) wParam == GetDlgItem(hwnd, IDC_PROCLIST))
                {
                    thispage->HandleProcListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
                    return TRUE;
                }
            }
        }
        break;

    case WM_NOTIFY:
        return thispage->HandleProcPageNotify((LPNMHDR) lParam);

    case WM_SIZE:
        //
        // Size our kids
        //
        thispage->SizeProcPage();
        return TRUE;

    case WM_SYSCOLORCHANGE:
        SendMessage(GetDlgItem(hwnd, IDC_PROCLIST), uMsg, wParam, lParam);
        return TRUE;
    }

    return FALSE;
}

/*++ CProcPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_PROCPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CProcPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it

Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Activate()
{
    //
    // Make this page visible
    //

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE);

    //
    // Change the menu bar to be the menu for this page
    //

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_PROC));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_PROCLIST));
    }

    return S_OK;
}

/*++ CProcPage::Initialize

Routine Description:

    Initializes the process page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct
                  
Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Initialize(HWND hwndParent)
{
    //
    // Find out what debbuger is configured on this system
    //

    HKEY hkDebug;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                      TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\AeDebug"),
                                      0, KEY_READ, &hkDebug))
    {
        WCHAR szDebugger[MAX_PATH * 2];
        DWORD cbString = sizeof(szDebugger);

        LRESULT lr = RegQueryValueEx(hkDebug, TEXT("Debugger"), NULL, NULL, (LPBYTE) szDebugger, &cbString);
        
        RegCloseKey(hkDebug);   // always close the key.

        if ( ERROR_SUCCESS == lr )
        {
            // Find the first token (which is the debugger exe name/path)
            szDebugger[ ARRAYSIZE(szDebugger) - 1 ] = L'\0';    //  make sure it is terminated
               
            LPTSTR pszCmdLine = szDebugger;
            
            if ( *pszCmdLine == TEXT('\"') ) 
            {
                //
                // Scan, and skip over, subsequent characters until
                // another double-quote or a null is encountered.
                //
                
                while ( *++pszCmdLine && (*pszCmdLine != TEXT('\"')) )
                {
                    NULL;
                }

                //
                // If we stopped on a double-quote (usual case), skip
                // over it.
                //
                
                if ( *pszCmdLine == TEXT('\"') )
                {
                    pszCmdLine++;
                }
            }
            else 
            {
                while (*pszCmdLine > TEXT(' '))
                {
                    pszCmdLine++;
                }
            }
            *pszCmdLine = TEXT('\0');   // Don't need the rest of the args, etc

            // If the doctor is in, we don't allow the Debug action

            if (lstrlen(szDebugger) && lstrcmpi(szDebugger, TEXT("drwtsn32")) && lstrcmpi(szDebugger, TEXT("drwtsn32.exe")))
            {
                DWORD cchLen = lstrlen(szDebugger) + 1;
                m_pszDebugger = (LPWSTR) LocalAlloc( LPTR, sizeof(*m_pszDebugger) * cchLen );
                if (NULL == m_pszDebugger)
                {
                    return E_OUTOFMEMORY;
                }

                //  Bail if the string copy fails.
                HRESULT hr = StringCchCopy( m_pszDebugger, cchLen, szDebugger );
                if(FAILED( hr ))
                {
                    return hr;
                }
            }
        }
    }

    //
    // Get basic info like page size, etc.
    //

    NTSTATUS Status = NtQuerySystemInformation(
                SystemBasicInformation,
                &g_BasicInfo,
                sizeof(g_BasicInfo),
                NULL
                );

    if (!NT_SUCCESS(Status))
    {
        return E_FAIL;
    }

    //
    // Create the ptr array used to hold the info on running processes
    //

    m_pProcArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pProcArray)
    {
        return E_OUTOFMEMORY;
    }

    // Our pseudo-parent is the tab contrl, and is what we base our
    // sizing on.  However, in order to keep tab order right among
    // the controls, we actually create ourselves with the main
    // window as the parent

    m_hwndTabs = hwndParent;

    //
    // Create the dialog which represents the body of this page
    //

    m_hPage = CreateDialogParam(
                    g_hInstance,                        // handle to application instance
                    MAKEINTRESOURCE(IDD_PROCPAGE),      // identifies dialog box template name  
                    g_hMainWnd,                     // handle to owner window
                    ProcPageProc,                   // pointer to dialog box procedure
                    (LPARAM) this );                // User data (our this pointer)

    if (NULL == m_hPage)
    {
        return GetLastHRESULT();
    }

    // Set up the columns in the listview

    if (FAILED(SetupColumns()))
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
        return E_FAIL;
    }

    // Restore the column positions.

    RestoreColumnOrder(GetDlgItem(m_hPage, IDC_PROCLIST));

    // Do one initial calculation

    TimerEvent();

    return S_OK;
}

/*++ CProcPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call
    
Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CProcPage::Destroy()
{
    if (m_pProcArray)
    {
        INT c = m_pProcArray->GetSize();

        while (c)
        {
            delete (CProcInfo *) (m_pProcArray->GetAt(c - 1));
            c--;
        }

        delete m_pProcArray;

        m_pProcArray = NULL;
    }

    if ( m_pvBuffer != NULL )
    {
        HeapFree( GetProcessHeap( ), 0, m_pvBuffer );
        m_pvBuffer = NULL;
    }
    
    if (m_hPage != NULL)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_pszDebugger != NULL)
    {
        LocalFree(m_pszDebugger);
        m_pszDebugger = NULL;
    }
    return S_OK;
}

/*++ CProcPage::SaveColumnWidths

Routine Description:

    Saves the widths of all of the columns in the global options structure
    
Revision History:

    Jan-26-95 Davepl  Created

--*/

void CProcPage::SaveColumnWidths()
{
    UINT i = 0;
    LV_COLUMN col = { 0 };

    while (g_Options.m_ActiveProcCol[i] != (COLUMNID) -1)
    {
        col.mask = LVCF_WIDTH;
        if (ListView_GetColumn(GetDlgItem(m_hPage, IDC_PROCLIST), i, &col) )
        {
            g_Options.m_ColumnWidths[i] = col.cx;
        }
        else
        {
            ASSERT(0 && "Couldn't get the column width");
        }
        i++;
    }
}

/*++ CProcPage::Deactivate

Routine Description:

    Called when this page is losing its place up front

Arguments:

Return Value:

Revision History:

      Nov-16-95 Davepl  Created

--*/

void CProcPage::Deactivate()
{

    SaveColumnWidths();

    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}


/*++ CProcPage::KillAllChildren

Routine Description:

    Given a pid, recursively kills it and all of its descendants
    
Arguments:

Return Value:

Revision History:

      2-26-01 Bretan  Created

--*/

BOOL CProcPage::KillAllChildren(
                                DWORD dwTaskPid, 
                                DWORD pid, 
                                BYTE* pbBuffer, 
                                LARGE_INTEGER CreateTime
                                )
{
    ASSERT(pbBuffer);

    BOOL rval = TRUE;
    PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;
    ULONG TotalOffset = 0;
    
    for ( ;; ) // ever
    {
        // If we are a child of pid and not pid itself
        // and if we have been created after pid (we can't be a child if we were created first)
        if (PtrToUlong(ProcessInfo->InheritedFromUniqueProcessId) == pid &&
            PtrToUlong(ProcessInfo->UniqueProcessId) != pid &&
            CreateTime.QuadPart < ProcessInfo->CreateTime.QuadPart)
        {
            DWORD newpid = PtrToUlong(ProcessInfo->UniqueProcessId);
            
            //
            // Recurse down to the next level
            //
            rval = KillAllChildren(dwTaskPid, newpid, pbBuffer, ProcessInfo->CreateTime);
            
            // Kill it if it is not task manager
            if (newpid != dwTaskPid) 
            {
                BOOL tval = KillProcess(newpid, TRUE);
                
                //
                // If it has failed earlier in the recursion
                // we want to keep that failure (not overwrite it)
                //
                if (rval == TRUE) 
                {
                    rval = tval;
                }
            }
        }
            
        if (ProcessInfo->NextEntryOffset == 0) 
        {
            break;
        }
        TotalOffset += ProcessInfo->NextEntryOffset;
        ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &pbBuffer[ TotalOffset ];
    }
    
    return rval;
}

/*++ CProcPage::RecursiveKill

Routine Description:

    Given a pid, starts the recursive function that kills all the pid's descendents
    
Arguments:

Return Value:

Revision History:

      8-4-98  Davepl  Created
      2-26-01 Bretan  Modified

--*/

#define MAX_TASKS 4096

BOOL CProcPage::RecursiveKill(DWORD pid)
{
    BYTE* pbBuffer = NULL;
    BOOL  rval = TRUE;
    DWORD dwTaskPid = GetCurrentProcessId();

    if (IsSystemProcess(pid, NULL))
    {
        return FALSE;
    }
    
    if (IDYES != QuickConfirm(IDS_WARNING, IDS_KILLTREE))
    {
        return FALSE;
    }
    
    //
    // get the task list for the system
    //
    pbBuffer = GetTaskListEx();

    if (pbBuffer)
    {
        PSYSTEM_PROCESS_INFORMATION ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) pbBuffer;
        ULONG TotalOffset = 0;
        
        for ( ;; ) // ever
        {
            if (PtrToUlong(ProcessInfo->UniqueProcessId) == pid)
            {
                rval = KillAllChildren(dwTaskPid, pid, pbBuffer, ProcessInfo->CreateTime);

                //
                // Kill the parent process if it is not task manager
                //
                if (pid != dwTaskPid)
                {
                    KillProcess(pid, TRUE);
                }

                // We will not run into this pid again (since its unique)
                // so we might as well break outta this for loop
                break;
            }
            
            //
            // Advance to next task
            //
            if (ProcessInfo->NextEntryOffset == 0) 
            {
                break;
            }
            TotalOffset += ProcessInfo->NextEntryOffset;
            ProcessInfo = (PSYSTEM_PROCESS_INFORMATION) &pbBuffer[ TotalOffset ];
        }
    }
    else
    {
        rval = FALSE;
    }

    if (rval != TRUE)
    {
        // We failed to kill at least one of the processes
        WCHAR szTitle[MAX_PATH];
        WCHAR szBody[MAX_PATH];

        if (0 != LoadString(g_hInstance, IDS_KILLTREEFAIL, szTitle, ARRAYSIZE(szTitle)) &&
            0 != LoadString(g_hInstance, IDS_KILLTREEFAILBODY, szBody,  ARRAYSIZE(szBody)))
        {
            MessageBox(m_hPage, szBody, szTitle, MB_ICONERROR);
        }
    }

    //
    // Buffer allocated in call to GetTaskListEx
    //
    HeapFree( GetProcessHeap( ), 0, pbBuffer );

    return rval;
}

/*++  CProcPage::GetTaskListEx

Routine Description:

    Provides an API for getting a list of tasks running at the time of the
    API call.  This function uses internal NT apis and data structures.  This
    api is MUCH faster that the non-internal version that uses the registry.

Arguments:

    dwNumTasks       - maximum number of tasks that the pTask array can hold

Return Value:

    Number of tasks placed into the pTask array.

--*/


BYTE* CProcPage::GetTaskListEx()
{
    BYTE*       pbBuffer = NULL;
    NTSTATUS    status;
    
    DWORD  dwBufferSize = sizeof(SYSTEM_PROCESS_INFORMATION) * 100; // start with ~100 processes

retry:
    ASSERT( NULL == pbBuffer );
    pbBuffer = (BYTE *) HeapAlloc( GetProcessHeap( ), 0, dwBufferSize );
    if (pbBuffer == NULL) 
    {
        return FALSE;
    }

    status = NtQuerySystemInformation( SystemProcessInformation
                                     , pbBuffer
                                     , dwBufferSize
                                     , NULL
                                     );
    if ( status != ERROR_SUCCESS )
    {
        HeapFree( GetProcessHeap( ), 0, pbBuffer );
        pbBuffer = NULL;
    }

    if (status == STATUS_INFO_LENGTH_MISMATCH) {
        dwBufferSize += 8192;
        goto retry;
    }

    if (!NT_SUCCESS(status))
    {
        return FALSE;
    }

    return pbBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\trayicon.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       trayicon.CPP
//
//  History:    Jan-27-96   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

/*++ TrayThreadMessageLoop (WORKER THREAD CODE)

Routine Description:

   Waits for messages telling it a notification packet is ready
   in the queue, then dispatches it to the tray  
    
   Mar-27-95 Davepl  Created
   May-28-99 Jonburs Check for NIM_DELETE during PM_QUITTRAYTHREAD

--*/

DWORD TrayThreadMessageLoop(LPVOID)
{
    MSG msg;

    //
    //  Loop forever and process our messages
    //

    while( GetMessage( &msg, NULL, 0, 0 ) )
    {
        switch(msg.message)
        {
        case PM_INITIALIZEICONS:
            {
                //
                //  Add the tray icons to the tray icon cache by adding them all hidden.
                //

                NOTIFYICONDATA NotifyIconData;

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize           = sizeof(NotifyIconData);
                NotifyIconData.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_STATE;
                NotifyIconData.dwState          = NIS_HIDDEN;
                NotifyIconData.dwStateMask      = NotifyIconData.dwState;
                NotifyIconData.hWnd             = g_hMainWnd;
                NotifyIconData.uCallbackMessage = PWM_TRAYICON;

                for ( UINT idx = 0; idx < g_cTrayIcons; idx ++ )
                {
                    NotifyIconData.uID   = ~idx; // anything but zero
                    NotifyIconData.hIcon = g_aTrayIcons[ idx ];

                    Shell_NotifyIcon( NIM_ADD, &NotifyIconData );
                }

                //
                //  We now add the zero-th icon which we will used to refer to the hidden
                //  cached icons we added above. This is the visible icon that users see
                //  in notification area.
                //

                NotifyIconData.uFlags  = NIF_MESSAGE | NIF_ICON | NIF_TIP;
                NotifyIconData.uID     = 0;
                NotifyIconData.hIcon   = g_aTrayIcons[ 0 ];

                //
                // Initialize with the app title, so that the tray knows that it is
                // task manager starting up, rather than "CPU Usage blah blah.."...
                //

                LoadString( g_hInstance, IDS_APPTITLE, NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip) );

                Shell_NotifyIcon( NIM_ADD, &NotifyIconData );
            }
            break;

        case PM_NOTIFYWAITING:
            {
                NOTIFYICONDATA NotifyIconData;

                UINT    uIcon      = (UINT) msg.wParam;
                LPCWSTR pszTipText = (LPCWSTR) msg.lParam;

                //
                //  We need to update the icon. To do this, we tell the tray to 
                //  use one of the icons we cached using NIS_HIDDEN into the
                //  zero-th position and make it visible. The hIcon indicates
                //  which icon to retrieve and display.
                //

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize           = sizeof(NotifyIconData);
                NotifyIconData.hWnd             = g_hMainWnd;
                // NotifyIconData.uID              = 0; - zero'ed above
                NotifyIconData.uFlags           = NIF_STATE | NIF_ICON;
                NotifyIconData.dwStateMask      = NIS_SHAREDICON;
                NotifyIconData.dwState          = NotifyIconData.dwStateMask;
                NotifyIconData.hIcon            = g_aTrayIcons[ uIcon ];

                //
                //  If there is tool tip data to update, add it here and free
                //  the buffer.
                //

                if ( NULL != pszTipText) 
                {
                    NotifyIconData.uFlags |= NIF_TIP;
                    StringCchCopy( NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip), pszTipText );
                    HeapFree( GetProcessHeap( ), 0, (LPVOID) pszTipText );
                } 

                Shell_NotifyIcon( NIM_MODIFY, &NotifyIconData );
            }
            break;

        case PM_QUITTRAYTHREAD:
            {
                //
                //  Remove the hidden tray icons.
                //

                NOTIFYICONDATA NotifyIconData;

                ZeroMemory( &NotifyIconData, sizeof(NotifyIconData) );

                NotifyIconData.cbSize      = sizeof(NotifyIconData);
                NotifyIconData.hWnd        = g_hMainWnd;

                for ( UINT idx = 0; idx < g_cTrayIcons; idx ++ )
                {
                    NotifyIconData.uID = ~idx;
                    Shell_NotifyIcon( NIM_DELETE, &NotifyIconData );
                }
            
                //
                //  Before we leave, update the tool tip so the "notification
                //  area manager" has something better than "CPU Usage: 49%"
                //  to show.
                //

                LoadString( g_hInstance, IDS_APPTITLE, NotifyIconData.szTip, ARRAYSIZE(NotifyIconData.szTip) );

                NotifyIconData.uID    = 0;
                NotifyIconData.uFlags = NIF_TIP;

                Shell_NotifyIcon( NIM_MODIFY, &NotifyIconData );

                //
                //  And now delete the last icon (the one we actually show).
                //

                NotifyIconData.uFlags = 0;
                Shell_NotifyIcon( NIM_DELETE, &NotifyIconData );

                g_idTrayThread = 0;
                PostQuitMessage(0);
            }
            break;

        default:
            ASSERT(0 && "Taskman tray worker got unexpected message");
            break;
        }
    }
    
    return 0;
}

/*++ Tray_Notify (MAIN THREAD CODE)

Routine Description:

   Handles notifications sent by the tray
    
Revision History:

    Jan-27-95 Davepl  Created

--*/

void Tray_Notify(HWND hWnd, LPARAM lParam)
{                                                                              
    switch (lParam) 
    {
        case WM_LBUTTONDBLCLK:                                                 
            ShowRunningInstance();
            break;                                                             

        case WM_RBUTTONDOWN:
        {
            HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TRAYMENU);

            // Display the tray icons context menu at the current cursor location
                        
            if (hPopup)
            {
                POINT pt;
                GetCursorPos(&pt);

                if (IsWindowVisible(g_hMainWnd))
                {
                    DeleteMenu(hPopup, IDM_RESTORETASKMAN, MF_BYCOMMAND);
                }
                else
                {
                    SetMenuDefaultItem(hPopup, IDM_RESTORETASKMAN, FALSE);
                }

                CheckMenuItem(hPopup, IDM_ALWAYSONTOP,   
                    MF_BYCOMMAND | (g_Options.m_fAlwaysOnTop ? MF_CHECKED : MF_UNCHECKED));

                SetForegroundWindow(hWnd);
                g_fInPopup = TRUE;
                TrackPopupMenuEx(hPopup, 0, pt.x, pt.y, hWnd, NULL);
                g_fInPopup = FALSE;
                DestroyMenu(hPopup);
            }
            break;
        }
    }                                                                          
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by taskmgr.rc
//
#define LED_STRIP_LIT                   103
#define LED_STRIP_UNLIT                 104
#define IDD_MAINWND                     105
#define IDR_MAINMENU                    106
#define IDR_MAINMENU_TASK               106
#define IDI_MAIN                        107
#define IDD_PERFPAGE                    108
#define IDD_NETPAGE                     109     //omiller netpage
#define IDD_PROCPAGE                    110
#define IDR_PROC_CONTEXT                111
#define IDD_TASKPAGE                    112
#define IDD_CREATEDESKTOP               116
#define IDR_TASK_CONTEXT                117
#define IDI_DEFAULT                     118
#define IDR_TASKVIEW                    119
#define IDR_ACCELERATORS                120
#define IDR_MAINMENU_PERF               120
#define IDD_SELECTPROCCOLS              121
#define IDR_MAINMENU_PROC               121
#define IDD_BENCHWARN                   122
#define IDD_AFFINITY                    124
#define LED_STRIP_LIT_RED               125
#define IDB_TRAYUNLIT                   126
#define IDB_TRAYLIT                     127
#define IDI_TRAY0                       127
#define IDI_TRAY1                       128
#define IDR_TRAYMENU                    128
#define IDI_TRAY2                       129
#define IDD_SELECTUSERCOLUMNS           129
#define IDI_TRAY3                       130
#define IDI_TRAY4                       131
#define IDI_TRAY5                       132
#define IDI_TRAY6                       133
#define IDI_TRAY7                       134
#define IDI_TRAY8                       135
#define IDI_TRAY9                       136
#define IDI_TRAY10                      137
#define IDI_TRAY11                      138
#define IDD_DIALOG_SHADOWWARN           214
#define IDD_SHADOWSTART                 240
#define IDC_SHADOWSTART_HOTKEY          241
#define IDC_SHADOWSTART_SHIFT           242
#define IDC_SHADOWSTART_CTRL            243
#define IDC_SHADOWSTART_ALT             244
#define IDD_MESSAGE                     250
#define IDC_MESSAGE_TITLE               251
#define IDC_MESSAGE_MESSAGE             252
#define IDC_PRESS_NUMKEYPAD             396
#define IDC_PRESS_KEY                   397
#define IDD_CONNECT_PASSWORD            440
#define IDL_CPDLG_PROMPT                441
#define IDC_CPDLG_PASSWORD              442
#define IDC_TABS                        1000
#define IDC_CPUFRAME                    1001
#define IDC_MEMFRAME                    1002
#define IDC_LEGENDFRAME                 1003
#define IDC_CPUMETER                    1004
#define IDC_MEMMETER                    1005
#define IDC_MEMGRAPH                    1006
#define IDC_SHOWALL                     1008
#define IDC_PROCLIST                    1009
#define IDC_LEGEND                      1009
#define IDC_TERMINATE                   1010
#define IDC_DEBUG                       1011
#define IDC_TOTAL_PHYSICAL              1012
#define IDC_AVAIL_PHYSICAL              1013
#define IDC_COMMIT_TOTAL                1014
#define IDC_FILE_CACHE                  1015
#define IDC_COMMIT_LIMIT                1017
#define IDC_COMMIT_PEAK                 1018
#define IDC_KERNEL_TOTAL                1019
#define IDC_STATIC1                     1020
#define IDC_STATIC2                     1021
#define IDC_STATIC3                     1022
#define IDC_STATIC4                     1023
#define IDC_STATIC5                     1024
#define IDC_STATIC6                     1025
#define IDC_KERNEL_PAGED                1026
#define IDC_STATIC8                     1027
#define IDC_STATIC9                     1028
#define IDC_STATIC10                    1029
#define IDC_STATIC11                    1030
#define IDC_STATIC12                    1031
#define IDC_STATIC13                    1032
#define IDC_STATIC14                    1033
#define IDC_TOTAL_HANDLES               1034
#define IDC_STATIC15                    1035
#define IDC_TOTAL_THREADS               1036
#define IDC_STATIC16                    1037
#define IDC_TOTAL_PROCESSES             1038
#define IDC_STATIC17                    1039
#define IDC_KERNEL_NONPAGED             1040
#define IDC_DUMMY                       1041
#define IDC_TILEHORZ                    1043
#define IDC_TILEVERT                    1044
#define IDC_CASCADE                     1045
#define IDC_MINIMIZE                    1046
#define IDC_MAXIMIZE                    1047
#define IDC_SWITCHTO                    1048
#define IDC_BRINGTOFRONT                1049
#define IDC_ENDTASK                     1050
#define IDC_WINFRAME                    1051
#define IDC_TASKFRAME                   1052
#define IDC_TASKLIST                    1053
#define IDC_BACK                        1054
#define IDC_FORWARD                     1055
#define IDC_DESKTOPFRAME                1057
#define IDC_DESKTOPNAME                 1058
#define IDC_STARTEXPLORER               1059
#define IDC_CURDESKTOP                  1060
#define IDC_IMAGENAME                   1061
#define IDC_PID                         1062
#define IDC_CPU                         1063
#define IDC_CPUTIME                     1064
#define IDC_MEMBARFRAME                 1064
#define IDC_MEMUSAGE                    1065
#define IDC_MEMUSAGEDIFF                1066
#define IDC_PAGEFAULTS                  1067
#define IDC_PAGEFAULTSDIFF              1068
#define IDC_COMMITCHARGE                1069
#define IDC_PAGEDPOOL                   1070
#define IDC_NONPAGEDPOOL                1071
#define IDC_BASEPRIORITY                1072
#define IDC_HANDLECOUNT                 1073
#define IDC_THREADCOUNT                 1074
#define IDC_MEMPEAK                     1075
#define IDC_USER_NAME                   1076
#define IDC_SESSION_ID                  1077
#define IDC_SESSION_STATUS              1078
#define IDC_IDLE_TIME                   1079
#define IDC_WINSTA_NAME                 1079
#define IDC_LOGON_TIME                  1080
#define IDC_CLIENT_NAME                 1081
#define IDC_NOMOREWARN                  1083
#define IDC_USEROBJECTS                 1084
#define IDC_GDIOBJECTS                  1085
#define IDC_SESSIONID                   1087
#define IDC_USERNAME                    1088
#define IDC_CPU0                        2000
#define IDC_CPU1                        2001
#define IDC_CPU2                        2002
#define IDC_CPU3                        2003
#define IDC_CPU4                        2004
#define IDC_CPU5                        2005
#define IDC_CPU6                        2006
#define IDC_CPU7                        2007
#define IDC_CPU8                        2008
#define IDC_CPU9                        2009
#define IDC_CPU10                       2010
#define IDC_CPU11                       2011
#define IDC_CPU12                       2012
#define IDC_CPU13                       2013
#define IDC_CPU14                       2014
#define IDC_CPU15                       2015
#define IDC_CPU16                       2016
#define IDC_CPU17                       2017
#define IDC_CPU18                       2018
#define IDC_CPU19                       2019
#define IDC_CPU20                       2020
#define IDC_CPU21                       2021
#define IDC_CPU22                       2022
#define IDC_CPU23                       2023
#define IDC_CPU24                       2024
#define IDC_CPU25                       2025
#define IDC_CPU26                       2026
#define IDC_CPU27                       2027
#define IDC_CPU28                       2028
#define IDC_CPU29                       2029
#define IDC_CPU30                       2030
#define IDC_CPU31                       2031
#define IDC_READOPERCOUNT               2032
#define IDC_WRITEOPERCOUNT              2033
#define IDC_OTHEROPERCOUNT              2034
#define IDC_READXFERCOUNT               2035
#define IDC_WRITEXFERCOUNT              2036
#define IDC_OTHERXFERCOUNT              2037

#define IDR_MAINMENU_NET                2400
#define IDM_BYTESSENT                   2401
#define IDM_BYTESRECEIVED               2402
#define IDM_BYTESTOTAL                  2403
#define IDM_NETCOL                      2404
#define IDM_SHOWALLDATA                 2405
#define IDM_NETRESET                    2406
#define IDM_AUTOSIZE                    2407
#define IDM_SHOWSCALE                   2408
#define IDD_SELECTNETCOLS               2409
#define IDM_TABALWAYSACTIVE             2410


#define IDC_NICGRAPH                    2500
#define IDC_NETSCALE                    2501

#define IDC_NICTOTALS                   2600
#define IDC_RESET                       2601
#define IDC_TROUBLESHOOT                2602
#define IDC_NOADAPTERS                  2603
#define IDC_GRAPHSCROLLVERT             2606

#define IDC_TOTAL                       2700
#define IDC_TOTALBYTESSENT              2700
#define IDC_TOTALBYTERECEIVED           2701
#define IDC_TOTALPACKETSSENT            2702
#define IDC_TOTALPACKETSRECEIVED        2703
#define IDC_TOTALDBYTERECEIVED          2704
#define IDC_TOTALDPACKETSRECEIVED       2705

#define IDC_TOTALVALUE                  2800
#define IDC_TOTALBYTESSENTVALUE         2800
#define IDC_TOTALBYTERECEIVEDVALUE      2801
#define IDC_TOTALPACKETSSENTVALUE       2802
#define IDC_TOTALPACKETSRECEIVEDVALUE   2803
#define IDC_TOTALDBYTERECEIVEDVALUE     2804
#define IDC_TOTALDPACKETSRECEIVEDVALUE  2805


#define IDD_USERSPAGE                   3000
#define IDS_USERPAGETITLE               3001
#define IDC_USERLIST                    3002
#define IDI_CURRENTUSER                 3003
#define IDI_USER                        3004
#define IDS_STAT_ACTIVE                 3020
#define IDS_STAT_DISCONNECT             3021
#define IDS_STAT_SHADOW                 3022
#define IDS_STAT_UNKNOWN                3023
#define IDS_COL_USER                    3100
#define IDS_USR_COL_USERNAME            3100
#define IDS_COL_SESSION                 3101
#define IDS_USR_COL_SESSION_ID          3101
#define IDS_COL_STATUS                  3102
#define IDS_USR_COL_SESSION_STATUS      3102
#define IDS_COL_CLIENTNAME              3103
#define IDS_USR_COL_CLIENT_NAME         3103
#define IDS_COL_SESSIONNAME             3104
#define IDS_USR_COL_WINSTA_NAME         3104
#define IDR_MAINMENU_USER               3200
#define IDR_USER_CONTEXT                3201
#define IDM_SENDMESSAGE                 3210
#define IDM_CONNECT                     3211
#define IDM_DISCONNECT                  3212
#define IDM_REMOTECONTROL               3213
#define IDM_RESET                       3214
#define IDM_LOGOFF                      3215
#define IDM_SHOWDOMAINNAMES             3220
#define IDS_ERR_SENDMESSAGE             3300
#define IDS_ERR_LOGOFF                  3301
#define IDS_ERR_DISCONNECT              3302
#define IDS_WARN_LOGOFF                 3310
#define IDS_WARN_DISCONNECT             3311
#define IDM_MENU_SHUTDOWN               4000
#define IDR_POPUP_SHUTDOWN              4001
#define IDM_HIBERNATE                   4002
#define IDM_SHUTDOWN                    4003
#define IDM_STANDBY                     4004
#define IDM_RESTART                     4005
#define IDM_LOGOFF_CURRENTUSER          4006
#define IDM_SWITCHUSER                  4007
#define IDM_DISCONNECT_CURRENTUSER      4008
#define IDM_EJECT                       4009
#define IDM_LOCKWORKSTATION             4010
#define IDS_SHUTDOWN_REMOTE             4050
#define IDS_SHUTDOWN_REMOTE_OTHERUSERS  4051
#define IDS_SHUTDOWN_OTHERUSERS         4052
#define IDS_RESTART_OTHERUSERS          4053

//
//  5000-5999 reserved for dynamic creation of CPU graphs
//
#define IDC_CPUGRAPH                    5000


#define IDS_PERFPAGETITLE               10000
#define IDS_RUNTITLE                    10001
#define IDS_RUNTEXT                     10002
#define IDS_APPTITLE                    10003
#define IDS_PROCPAGETITLE               10004
#define IDS_SYSPROC                     10005
#define IDS_K                           10006
#define IDS_WARNING                     10007
#define IDS_PRICHANGE                   10008
#define IDS_KILL                        10009
#define IDS_DEBUG                       10010
#define IDS_LOW                         10011
#define IDS_HIGH                        10012
#define IDS_REALTIME                    10013
#define IDS_NORMAL                      10014
#define IDS_UNKNOWN                     10015
#define IDS_GENFAILURE                  10016
#define IDS_CANTKILL                    10017
#define IDS_CANTDEBUG                   10018
#define IDS_CANTCHANGEPRI               10019
#define IDS_BADPROC                     10020
#define IDS_TASKPAGETITLE               10021
#define IDS_HUNG                        10022
#define IDS_RUNNING                     10023
#define IDS_CANTCREATEDESKTOP           10024
#define IDS_TASKMGR                     10025
#define IDS_TASKMGRDISABLED             10026
#define IDS_ABOVENORMAL                 10027
#define IDS_BELOWNORMAL                 10028
#define IDS_KILLSYS                     10029
#define IDS_NETPAGETITLE                10030       //omiller net page
#define IDS_COL_IMAGENAME               20001
#define IDS_COL_PID                     20002
#define IDS_COL_CPU                     20003
#define IDS_COL_CPUTIME                 20004
#define IDS_COL_MEMUSAGE                20005
#define IDS_COL_MEMUSAGEDIFF            20006
#define IDS_COL_PAGEFAULTS              20007
#define IDS_COL_PAGEFAULTSDIFF          20008
#define IDS_COL_COMMITCHARGE            20009
#define IDS_COL_PAGEDPOOL               20010
#define IDS_COL_NONPAGEDPOOL            20011
#define IDS_COL_BASEPRIORITY            20012
#define IDS_COL_HANDLECOUNT             20013
#define IDS_COL_THREADCOUNT             20014
#define IDS_COL_USEROBJECTS             20015
#define IDS_COL_GDIOBJECTS              20016
#define IDS_COL_SESSIONID               20017
#define IDS_COL_USERNAME                20018
#define IDS_COL_TASKNAME                21000
#define IDS_COL_TASKSTATUS              21001
#define IDS_COL_TASKWINSTATION          21002
#define IDS_COL_TASKDESKTOP             21003
#define IDS_COL_MEMPEAK                 21004
#define IDS_COL_READOPERCOUNT           21005
#define IDS_COL_WRITEOPERCOUNT          21006
#define IDS_COL_OTHEROPERCOUNT          21007
#define IDS_COL_READXFERCOUNT           21008
#define IDS_COL_WRITEXFERCOUNT          21009
#define IDS_COL_OTHERXFERCOUNT          21010
#define IDS_G                           21011
#define IDS_M                           21012
#define IDS_ZERO                        21013
#define IDS_BITSPERSEC                  21015
#define IDS_SCALEFONT                   21016
#define IDS_PERCENT                     21017
#define IDS_NONOPERATIONAL              21018
#define IDS_UNREACHABLE                 21019
#define IDS_DISCONNECTED                21020
#define IDS_CONNECTING                  21021
#define IDS_CONNECTED                   21022
#define IDS_OPERATIONAL                 21023
#define IDS_UNKNOWNSTATUS               21024


// Network Columns
#define IDS_COL_ADAPTERNAME              21100
#define IDS_COL_ADAPTERDESC              21101   
#define IDS_COL_NETWORKUTIL              21102   
#define IDS_COL_LINKSPEED                21103   
#define IDS_COL_STATE                    21104   
#define IDS_COL_BYTESSENTTHRU            21105 
#define IDS_COL_BYTESRECTHRU             21106  
#define IDS_COL_BYTESTOTALTHRU           21107
#define IDS_COL_BYTESSENT                21108
#define IDS_COL_BYTESREC                 21109
#define IDS_COL_BYTESTOTAL               21110
#define IDS_COL_BYTESSENTPERINTER        21111
#define IDS_COL_BYTESRECPERINTER         21112
#define IDS_COL_BYTESTOTALPERINTER       21113
#define IDS_COL_UNICASTSSSENT            21114
#define IDS_COL_UNICASTSREC              21115
#define IDS_COL_UNICASTSTOTAL            21116
#define IDS_COL_UNICASTSSENTPERINTER     21117
#define IDS_COL_UNICASTSRECPERINTER      21118
#define IDS_COL_UNICASTSTOTALPERINTER    21119
#define IDS_COL_NONUNICASTSSSENT         21120
#define IDS_COL_NONUNICASTSREC           21121
#define IDS_COL_NONUNICASTSTOTAL         21122
#define IDS_COL_NONUNICASTSSENTPERINTER  21123
#define IDS_COL_NONUNICASTSRECPERINTER   21124
#define IDS_COL_NONUNICASTSTOTALPERINTER 21125

#define IDS_FMTTASKS                    30038
#define IDS_FMTPROCS                    30039
#define IDS_FMTMEMK                     30040
#define IDS_FMTCPU                      30041
#define IDM_TASK_TILEVERT               30043
#define IDS_FMTMEMM                     30044
#define IDS_CANTSETAFFINITY             30056
#define IDM_RUN                         40001
#define IDM_EXIT                        40002
#define IDM_ENDTASK                     40003
#define IDM_SWITCHTO                    40004
#define IDM_BRINGTOFONT                 40005
#define IDM_ALWAYSONTOP                 40006
#define IDM_MINIMIZEONUSE               40007
#define IDM_MINIMIZE                    40008
#define IDM_MAXIMIZE                    40009
#define IDM_RESTORE                     40011
#define IDM_CASCADE                     40012
#define IDM_TILEHORIZONTALLY            40013
#define IDM_TILEVERTICALLY              40014
#define IDM_LARGEICONS                  40015
#define IDM_SMALLICONS                  40016
#define IDM_DETAILS                     40017
#define IDM_ALLCPUS                     40018
#define IDM_MULTIGRAPH                  40019
#define IDM_ABOUT                       40021
#define IDM_HIGH                        40022
#define IDM_NORMAL                      40023
#define IDM_LOW                         40024
#define IDM_PAUSED                      40025
#define IDM_PROC_DEBUG                  40027
#define IDM_PROC_TERMINATE              40028

#define IDM_PROC_REALTIME               40029
#define IDM_PROC_ABOVENORMAL            40030
#define IDM_PROC_HIGH                   40031
#define IDM_PROC_NORMAL                 40032
#define IDM_PROC_BELOWNORMAL            40033
#define IDM_PROC_LOW                    40034

#define IDM_NEWDESKTOP                  40038
#define IDM_TASK_MINIMIZE               40039
#define IDM_TASK_MAXIMIZE               40040
#define IDM_TASK_CASCADE                40041
#define IDM_TASK_TILEHORZ               40042
#define IDM_TASK_SWITCHTO               40044
#define IDM_TASK_BRINGTOFRONT           40045
#define IDM_TASK_ENDTASK                40046
#define IDM_TASK_FINDPROCESS            40047
#define IDM_HELP                        40049
#define IDM_PROCCOLS                    40052
#define IDM_REFRESH                     40053
#define IDM_WHATSTHIS                   40054
#define IDM_AFFINITY                    40055
#define IDM_KERNELTIMES                 40056
#define IDS_NOAFFINITYMASK              40057
#define IDS_INVALIDOPTION               40058
#define IDS_FMTCPUNUM                   40059
#define IDS_TOTALTIME                   40060
#define IDS_KERNELTIME                  40061
#define IDS_MEMUSAGE                    40062
#define IDM_HIDE                        40063
#define IDM_RESTORETASKMAN              40064
#define IDM_HIDEWHENMIN                 40065
#define IDM_TRAYMENU                    40069
#define IDM_SHOW16BIT                   40098
#define IDM_NOTITLE                     40099
#define IDC_NEXTTAB                     40100
#define IDC_PREVTAB                     40101
#define IDM_ENDTREE                     40105
#define IDS_KILLTREE                    40106
#define IDS_KILLTREEFAIL                40107
#define IDS_KILLTREEFAILBODY            40108
#define IDM_USERCOLS                    40109
#define IDS_DEFAULT_MESSAGE_TITLE       40122
#define IDS_ERR_CONNECT                 40123
#define IDS_PWDDLG_USER                 40124
#define IDS_ERR_SHADOW                  40125
#define IDS_ERR_SHADOW_DISABLED         40126
#define IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON 40127
#define IDS_PWDDLG_USER2                40128
#define ID_HELP                         0xE146  

#define IDC_ADAPTERNAME                 50100
#define IDC_ADAPTERDESC                 50101
#define IDC_NETWORKUTIL                 50102
#define IDC_LINKSPEED                   50103
#define IDC_STATE                       50104
#define IDC_BYTESSENTTHRU               50105
#define IDC_BYTESRECTHRU                50106
#define IDC_BYTESTOTALTHRU              50107
#define IDC_BYTESSENT                   50108
#define IDC_BYTESREC                    50109
#define IDC_BYTESTOTAL                  50110
#define IDC_BYTESSENTPERINTER           50111
#define IDC_BYTESRECPERINTER            50112
#define IDC_BYTESTOTALPERINTER          50113
#define IDC_UNICASTSSSENT               50114
#define IDC_UNICASTSREC                 50115
#define IDC_UNICASTSTOTAL               50116
#define IDC_UNICASTSSENTPERINTER        50117
#define IDC_UNICASTSRECPERINTER         50118
#define IDC_UNICASTSTOTALPERINTER       50119
#define IDC_NONUNICASTSSSENT            50120
#define IDC_NONUNICASTSREC              50121
#define IDC_NONUNICASTSTOTAL            50122
#define IDC_NONUNICASTSSENTPERINTER     50123
#define IDC_NONUNICASTSRECPERINTER      50124
#define IDC_NONUNICASTSTOTALPERINTER    50125

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        129
#define _APS_NEXT_COMMAND_VALUE         40129
#define _APS_NEXT_CONTROL_VALUE         1064
#define _APS_NEXT_SYMED_VALUE           106
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\userdlgs.cpp ===
//
//  Copyright 1995-2002 by Microsoft Corporation
//
#include "precomp.h"
#include "userdlgs.h"


//***********************************************************************************
//CUsrDialog class
//base class for simple dialogs
//***********************************************************************************

INT_PTR CUsrDialog::DoDialog(HWND hwndParent)
{
    return DialogBoxParam(
                      g_hInstance,
                      MAKEINTRESOURCE(m_wDlgID),
                      hwndParent,
                      DlgProc,
                      (LPARAM) this);
}

//
//
//
INT_PTR CALLBACK CUsrDialog::DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUsrDialog * thisdlg = (CUsrDialog *) GetWindowLongPtr(hwndDlg, GWLP_USERDATA);

    switch(uMsg)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hwndDlg, GWLP_USERDATA, lParam);
	    thisdlg = (CUsrDialog *) lParam;
        thisdlg->OnInitDialog(hwndDlg);
        return FALSE;   // don't set focus.

    case WM_COMMAND:
        if (LOWORD(wParam) == IDOK)
        {
            thisdlg->OnOk(hwndDlg);

            EndDialog(hwndDlg, IDOK);
            return TRUE;
        }
        else if (LOWORD(wParam) == IDCANCEL)
        {
            EndDialog(hwndDlg, IDCANCEL);
            return TRUE;
        }
        else
        {
            thisdlg->OnCommand(hwndDlg,HIWORD(wParam), LOWORD(wParam));
        }
        break;
    }

    return FALSE;
}


//***********************************************************************************
//CShadowStartDlg class
//Remote Control dialog
//***********************************************************************************
const int KBDSHIFT      = 0x01;
const int KBDCTRL       = 0x02;
const int KBDALT        = 0x04;

struct {
    LPCTSTR String;
    DWORD VKCode;
} HotkeyLookupTable[] =
    {
        TEXT("0"),            '0',
        TEXT("1"),            '1',
        TEXT("2"),            '2',
        TEXT("3"),            '3',
        TEXT("4"),            '4',
        TEXT("5"),            '5',
        TEXT("6"),            '6',
        TEXT("7"),            '7',
        TEXT("8"),            '8',
        TEXT("9"),            '9',
        TEXT("A"),            'A',
        TEXT("B"),            'B',
        TEXT("C"),            'C',
        TEXT("D"),            'D',
        TEXT("E"),            'E',
        TEXT("F"),            'F',
        TEXT("G"),            'G',
        TEXT("H"),            'H',
        TEXT("I"),            'I',
        TEXT("J"),            'J',
        TEXT("K"),            'K',
        TEXT("L"),            'L',
        TEXT("M"),            'M',
        TEXT("N"),            'N',
        TEXT("O"),            'O',
        TEXT("P"),            'P',
        TEXT("Q"),            'Q',
        TEXT("R"),            'R',
        TEXT("S"),            'S',
        TEXT("T"),            'T',
        TEXT("U"),            'U',
        TEXT("V"),            'V',
        TEXT("W"),            'W',
        TEXT("X"),            'X',
        TEXT("Y"),            'Y',
        TEXT("Z"),            'Z',
        TEXT("{backspace}"),  VK_BACK,
        TEXT("{delete}"),     VK_DELETE,
        TEXT("{down}"),       VK_DOWN,
        TEXT("{end}"),        VK_END,
        TEXT("{enter}"),      VK_RETURN,
///        TEXT("{esc}"),        VK_ESCAPE,                           // KLB 07-16-95
///        TEXT("{F1}"),         VK_F1,
        TEXT("{F2}"),         VK_F2,
        TEXT("{F3}"),         VK_F3,
        TEXT("{F4}"),         VK_F4,
        TEXT("{F5}"),         VK_F5,
        TEXT("{F6}"),         VK_F6,
        TEXT("{F7}"),         VK_F7,
        TEXT("{F8}"),         VK_F8,
        TEXT("{F9}"),         VK_F9,
        TEXT("{F10}"),        VK_F10,
        TEXT("{F11}"),        VK_F11,
        TEXT("{F12}"),        VK_F12,
        TEXT("{home}"),       VK_HOME,
        TEXT("{insert}"),     VK_INSERT,
        TEXT("{left}"),       VK_LEFT,
        TEXT("{-}"),          VK_SUBTRACT,
        TEXT("{pagedown}"),   VK_NEXT,
        TEXT("{pageup}"),     VK_PRIOR,
        TEXT("{+}"),          VK_ADD,
        TEXT("{prtscrn}"),    VK_SNAPSHOT,
        TEXT("{right}"),      VK_RIGHT,
        TEXT("{spacebar}"),   VK_SPACE,
        TEXT("{*}"),          VK_MULTIPLY,
        TEXT("{tab}"),        VK_TAB,
        TEXT("{up}"),         VK_UP,
        NULL,           NULL
    };

LPCTSTR CShadowStartDlg::m_szShadowHotkeyKey = TEXT("ShadowHotkeyKey");
LPCTSTR CShadowStartDlg::m_szShadowHotkeyShift = TEXT("ShadowHotkeyShift");

//
//
//
CShadowStartDlg::CShadowStartDlg()
{
    m_wDlgID = IDD_SHADOWSTART;
    //set default values
    m_ShadowHotkeyKey = VK_MULTIPLY;
    m_ShadowHotkeyShift = KBDCTRL;
    
    //get las saved values from the registry
    HKEY hKey;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, KEY_READ, &hKey))
    {
        DWORD dwTmp;
        DWORD dwType;
        DWORD dwSize = sizeof(DWORD);

        if ( ERROR_SUCCESS == RegQueryValueEx(hKey, m_szShadowHotkeyKey, 0, &dwType, (LPBYTE) &dwTmp, &dwSize)
          && dwType == REG_DWORD
           )
        {
            m_ShadowHotkeyKey = dwTmp;
        }

        dwSize = sizeof(DWORD);
        if ( ERROR_SUCCESS == RegQueryValueEx(hKey, m_szShadowHotkeyShift, 0, &dwType, (LPBYTE) &dwTmp, &dwSize)
          && dwType == REG_DWORD
           )
        {
            m_ShadowHotkeyShift = dwTmp;
        }

        RegCloseKey(hKey);
    }
}

//
//
//
CShadowStartDlg::~CShadowStartDlg()
{
    //save values into the registry
    HKEY hKey;

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, TEXT("REG_BINARY"),
                                        REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, 
                                        &hKey, NULL))
    {
        DWORD dwType = REG_DWORD;
        DWORD dwSize = sizeof(DWORD);

        RegSetValueEx(hKey, m_szShadowHotkeyKey, 0, 
            dwType, (LPBYTE) &m_ShadowHotkeyKey, dwSize);

        RegSetValueEx(hKey, m_szShadowHotkeyShift, 0, 
            dwType, (LPBYTE) &m_ShadowHotkeyShift, dwSize);

        RegCloseKey(hKey);
    }
}

//
//
//
void CShadowStartDlg::OnInitDialog(HWND hwndDlg)
{
    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_NUMKEYPAD), SW_HIDE);
   	ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_KEY), SW_SHOW);

	LRESULT index, match = -1;
    HWND hComboBox = GetDlgItem(hwndDlg, IDC_SHADOWSTART_HOTKEY);

    //
    // Initialize the hotkey combo box.
    //

    for(int i=0; HotkeyLookupTable[i].String; i++ ) 
    {
        if((index = SendMessage(hComboBox,CB_ADDSTRING,0,LPARAM(HotkeyLookupTable[i].String))) < 0) 
        {
            break;
        }

        if(SendMessage(hComboBox,CB_SETITEMDATA, index, LPARAM(HotkeyLookupTable[i].VKCode)) < 0) 
        {
            SendMessage(hComboBox,CB_DELETESTRING,index,0);
            break;
        }

        //  If this is our current hotkey key, save it's index.
        if(m_ShadowHotkeyKey == (int)HotkeyLookupTable[i].VKCode)
        {
            match = index;
            switch ( HotkeyLookupTable[i].VKCode)
            {
                case VK_ADD :
                case VK_MULTIPLY:
                case VK_SUBTRACT:
                // change the text
               	    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_KEY), SW_HIDE);
               	    ShowWindow(GetDlgItem(hwndDlg, IDC_PRESS_NUMKEYPAD), SW_SHOW);
                    break;
            }
        }
    }

    //
    // Select the current hotkey string in the combo box.
    //

    if(match)
    {
        SendMessage(hComboBox,CB_SETCURSEL,match,0);
    }

    //
    // Initialize shift state checkboxes.
    //

    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_SHIFT,(m_ShadowHotkeyShift & KBDSHIFT) ? TRUE : FALSE );
    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_CTRL,(m_ShadowHotkeyShift & KBDCTRL) ? TRUE : FALSE );
    CheckDlgButton(hwndDlg, IDC_SHADOWSTART_ALT,(m_ShadowHotkeyShift & KBDALT) ? TRUE : FALSE );
}

//
//
//
void CShadowStartDlg::OnOk(HWND hwndDlg)
{
   HWND hComboBox = GetDlgItem(hwndDlg, IDC_SHADOWSTART_HOTKEY);

    // Get the current hotkey selection.
   m_ShadowHotkeyKey = (DWORD)SendMessage(hComboBox,CB_GETITEMDATA,
                            SendMessage(hComboBox,CB_GETCURSEL,0,0),0);
    
	// Get shift state checkbox states and form hotkey shift state.
    m_ShadowHotkeyShift = 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_SHIFT) ?
            KBDSHIFT : 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_CTRL) ?
            KBDCTRL : 0;
    m_ShadowHotkeyShift |=
        IsDlgButtonChecked(hwndDlg, IDC_SHADOWSTART_ALT) ?
            KBDALT : 0;
}


//***********************************************************************************
//CUserColSelectDlg class
//***********************************************************************************

const WCHAR g_szUsrColumns[] = L"UsrColumnSettings";

UserColumn CUserColSelectDlg::m_UsrColumns[USR_MAX_COLUMN]=
{
    {IDS_USR_COL_USERNAME,      IDC_USER_NAME,      LVCFMT_LEFT,       120, TRUE},
    {IDS_USR_COL_SESSION_ID,    IDC_SESSION_ID,     LVCFMT_RIGHT,      35,  TRUE},
    {IDS_USR_COL_SESSION_STATUS,IDC_SESSION_STATUS, LVCFMT_LEFT,       93,  TRUE},
    {IDS_USR_COL_CLIENT_NAME,   IDC_CLIENT_NAME,    LVCFMT_LEFT,       100, TRUE},
    {IDS_USR_COL_WINSTA_NAME,   IDC_WINSTA_NAME,    LVCFMT_LEFT,       120, TRUE}
};


//
//  get last saved values from the registry
//
BOOL CUserColSelectDlg::Load()
{
    BOOL bResult=FALSE;

    UserColumn * pdata = (UserColumn *) LocalAlloc( 0, sizeof(m_UsrColumns) );
    if ( NULL != pdata )
    {
        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, szTaskmanKey, 0, KEY_READ, &hKey))
        {
            DWORD dwType;
            DWORD dwSize = sizeof(m_UsrColumns);

            if ( ERROR_SUCCESS == RegQueryValueEx(hKey, g_szUsrColumns, 0, &dwType, (LPBYTE) pdata, &dwSize) 
              && dwType == REG_BINARY && dwSize == sizeof(m_UsrColumns) )
            {
                bResult = TRUE;

                //
                //  Validate the data
                //

                for ( ULONG idx = 0; idx < ARRAYSIZE(m_UsrColumns); idx ++ )
                { 
                    if ( pdata->dwNameID != m_UsrColumns->dwNameID 
                      || pdata->dwChkBoxID != m_UsrColumns->dwChkBoxID
                      || pdata->Align != pdata->Align
                       )
                    {
                        bResult = FALSE;
                        break;
                    }
                }
            }

            RegCloseKey(hKey);
        }
        
        if ( bResult )
        {
            CopyMemory( m_UsrColumns, pdata, sizeof(m_UsrColumns) );
        }

        LocalFree( pdata );
    }

    return bResult;
}

//
//  save values into the registry
//
BOOL CUserColSelectDlg::Save()
{
    HKEY hKey;
    BOOL bResult=FALSE;

    if (ERROR_SUCCESS == RegCreateKeyEx( HKEY_CURRENT_USER
                                       , szTaskmanKey
                                       , 0
                                       , NULL
                                       , REG_OPTION_NON_VOLATILE
                                       , KEY_WRITE
                                       , NULL
                                       , &hKey
                                       , NULL
                                       ))
    {
        DWORD dwSize = sizeof(m_UsrColumns);

        if ( ERROR_SUCCESS == RegSetValueEx(hKey, g_szUsrColumns, 0, REG_BINARY, (LPBYTE) m_UsrColumns, dwSize) )
        {
            bResult = TRUE;            
        }

        RegCloseKey(hKey);
    }

    return bResult;
}

//
//  check checkboxes for all active columns
//
void CUserColSelectDlg::OnInitDialog(HWND hwndDlg)
{
    for (int i = 0; i < USR_MAX_COLUMN; i++)
    {
        CheckDlgButton( hwndDlg, m_UsrColumns[i].dwChkBoxID, 
            m_UsrColumns[i].bActive ? BST_CHECKED : BST_UNCHECKED );
    }
}

//
//  First, make sure the column width array is up to date
//
void CUserColSelectDlg::OnOk(HWND hwndDlg)
{
    for (int i = 1; i < USR_MAX_COLUMN; i++)
    {
        (BST_CHECKED == IsDlgButtonChecked(hwndDlg, m_UsrColumns[i].dwChkBoxID)) ?
            m_UsrColumns[i].bActive=TRUE : m_UsrColumns[i].bActive=FALSE;
    }
}

//***********************************************************************************
//CSendMessageDlg class
//***********************************************************************************

//
//  Handles "Send Message" dialog
//
void CSendMessageDlg::OnInitDialog(HWND hwndDlg)
{
    RECT    parentRect, childRect;
    INT     xPos, yPos;

    GetWindowRect(GetParent(hwndDlg), &parentRect);
    GetWindowRect(hwndDlg, &childRect);
    xPos = ( (parentRect.right + parentRect.left) -
        (childRect.right - childRect.left)) / 2;
    yPos = ( (parentRect.bottom + parentRect.top) -
        (childRect.bottom - childRect.top)) / 2;
    SetWindowPos(hwndDlg,
                 NULL,
                 xPos, yPos,
                 0, 0,
                 SWP_NOSIZE | SWP_NOACTIVATE);

    SendMessage(GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE), EM_LIMITTEXT, 
        MSG_MESSAGE_LENGTH, 0L );
    EnableWindow(GetDlgItem(hwndDlg, IDOK), FALSE);

    //
    //  Prepare default title
    //

    WCHAR szTime[MAX_DATE_TIME_LENGTH+1];
    WCHAR szTemplate[MSG_TITLE_LENGTH+1];
    WCHAR szUserName[MAX_PATH+1];
            
    DWORD dwLen = LoadString( g_hInstance, IDS_DEFAULT_MESSAGE_TITLE, szTemplate, ARRAYSIZE(szTemplate) );
    ASSERT( 0 != dwLen );   // Missing resource string?
    dwLen;  // unreferenced on FRE builds.

    CurrentDateTimeString(szTime);
        
    //
    //  Get user name. 
    //  User does not always have "display name"
    //  in this case get his "sam compatible" name
    //

    ULONG MaxUserNameLength = ARRAYSIZE(szUserName);
    if ( !GetUserNameEx( NameDisplay, szUserName, &MaxUserNameLength ) )
    {
        MaxUserNameLength = ARRAYSIZE(szUserName);
        if ( !GetUserNameEx( NameSamCompatible, szUserName, &MaxUserNameLength) )
        {
            szUserName[ 0 ] = L'\0';
        }
    }

    //  UI only - don't care if it truncates
    StringCchPrintf( m_szTitle, ARRAYSIZE(m_szTitle), szTemplate, szUserName, szTime );

    SetDlgItemText(hwndDlg, IDC_MESSAGE_TITLE, m_szTitle);
    SendMessage(GetDlgItem(hwndDlg, IDC_MESSAGE_TITLE), EM_LIMITTEXT, MSG_TITLE_LENGTH, 0L );
}

//
//
//
void CSendMessageDlg::OnOk(HWND hwndDlg)
{
    GetWindowText( GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE), m_szMessage, ARRAYSIZE(m_szMessage) );
    GetWindowText( GetDlgItem(hwndDlg, IDC_MESSAGE_TITLE), m_szTitle, ARRAYSIZE(m_szTitle) );
}

//
//
//
void CSendMessageDlg::OnCommand(HWND hwndDlg,WORD NotifyId, WORD ItemId)
{
    if (ItemId == IDC_MESSAGE_MESSAGE)
    {
        if (NotifyId == EN_CHANGE)
        {
            EnableWindow(GetDlgItem(hwndDlg, IDOK),
                GetWindowTextLength(GetDlgItem(hwndDlg, IDC_MESSAGE_MESSAGE)) != 0);
        }
    }
}

//***********************************************************************************
//CConnectPasswordDlg class
//***********************************************************************************

//
//
//
void CConnectPasswordDlg::OnInitDialog(HWND hwndDlg)
{
    WCHAR szPrompt[MAX_PATH+1];
                
    LoadString( g_hInstance, m_ids, szPrompt, ARRAYSIZE(szPrompt) );
    SetDlgItemText(hwndDlg, IDL_CPDLG_PROMPT, szPrompt);
    SendMessage(GetDlgItem(hwndDlg, IDC_CPDLG_PASSWORD), EM_LIMITTEXT, PASSWORD_LENGTH, 0L );
}

//
//
//
void CConnectPasswordDlg::OnOk(HWND hwndDlg)
{
    GetWindowText(GetDlgItem(hwndDlg, IDC_CPDLG_PASSWORD), m_szPassword, PASSWORD_LENGTH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\userdlgs.h ===
#include "resource.h"

//Base class for simple dialogs
class CUsrDialog
{
protected:
    WORD m_wDlgID;
public:
    INT_PTR DoDialog(HWND hwndParent);
    virtual void OnInitDialog(HWND){ }
    virtual void OnOk(HWND){ }
    virtual void OnCommand(HWND, WORD, WORD){ }
    static INT_PTR CALLBACK DlgProc(HWND hwndDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
};

//-----------------------------------------------------------------------------------------
//"Remote Control" dialog class
class CShadowStartDlg : public CUsrDialog
{
protected:
    static LPCTSTR m_szShadowHotkeyKey;
    static LPCTSTR m_szShadowHotkeyShift;
    DWORD m_ShadowHotkeyKey;
    DWORD m_ShadowHotkeyShift;
public:
    CShadowStartDlg();
    ~CShadowStartDlg();
    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    DWORD GetShadowHotkeyKey(){return m_ShadowHotkeyKey;};
    DWORD GetShadowHotkeyShift(){return m_ShadowHotkeyShift;};
};


//-----------------------------------------------------------------------------------------
//
// Column ID enumeration
//

enum USERCOLUMNID
{
    USR_COL_USERSNAME = 0,
    USR_COL_USERSESSION_ID,
    USR_COL_SESSION_STATUS,
    USR_COL_CLIENT_NAME,
    USR_COL_WINSTA_NAME,
    USR_MAX_COLUMN
};

struct UserColumn
{
    DWORD dwNameID;
    DWORD dwChkBoxID;
    int Align;
    int Width;
    BOOL bActive;
};

//-----------------------------------------------------------------------------------------
//"Select Columns" dialog class
class CUserColSelectDlg : public CUsrDialog
{
protected:
    static UserColumn m_UsrColumns[USR_MAX_COLUMN];
public:
    CUserColSelectDlg()
    {
        m_wDlgID=IDD_SELECTUSERCOLUMNS;
        Load();
    }
    //BUGBUG cannot use destructors for global objects
    //because of peculiar initialization procedure (look at main.cpp (2602))
    //~CUserColSelectDlg(){Save();};
    BOOL Load();
    BOOL Save();

    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    UserColumn *GetColumns(){return m_UsrColumns;};
};

//-----------------------------------------------------------------------------------------
//"Send Message" dialog class
const USHORT MSG_TITLE_LENGTH = 64;
const USHORT MSG_MESSAGE_LENGTH = MAX_PATH*2;

class CSendMessageDlg : public CUsrDialog
{
protected:
    WCHAR m_szTitle[MSG_TITLE_LENGTH+1];
    WCHAR m_szMessage[MSG_MESSAGE_LENGTH+1];
public:
    CSendMessageDlg(){m_wDlgID=IDD_MESSAGE;}
                      
    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);
    void OnCommand(HWND hwndDlg,WORD NotifyId, WORD ItemId);

    LPCTSTR GetTitle(){return m_szTitle;};
    LPCTSTR GetMessage(){return m_szMessage;};

};

//-----------------------------------------------------------------------------------------
//"Connect Password Required" dialog class
class CConnectPasswordDlg : public CUsrDialog
{
protected:
    WCHAR m_szPassword[PASSWORD_LENGTH+1];
    UINT  m_ids;	// prompt string
public:
    CConnectPasswordDlg(UINT ids){m_wDlgID=IDD_CONNECT_PASSWORD; m_ids = ids;}

    void OnInitDialog(HWND hwndDlg);
    void OnOk(HWND hwndDlg);

    LPCTSTR GetPassword(){return m_szPassword;};
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\taskmgr.h ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       TaskMan.H
//
//  History:    Nov-10-95   DavePl  Created
//              Jun-30-98   Alhen   Adding code for TerminalServer  
//
//--------------------------------------------------------------------------

#define WM_FINDPROC         (WM_USER + 1)
#define PM_NOTIFYWAITING    (WM_USER + 2)
#define PM_QUITTRAYTHREAD   (WM_USER + 3)
#define PM_INITIALIZEICONS  (WM_USER + 4)

extern  DWORD             g_idTrayThread;
extern  LONG              g_minWidth;
extern  LONG              g_minHeight;

extern  BOOL              g_fIsTSEnabled;
extern  BOOL              g_fIsSingleUserTS;
extern  BOOL              g_fIsTSServer;
extern  DWORD             g_dwMySessionId;
extern  int               g_nPages;

DWORD TrayThreadMessageLoop(LPVOID);

#define TASK_PAGE 0
#define PROC_PAGE 1
#define PERF_PAGE 2
#define NET_PAGE  3
#define USER_PAGE 4
#define NUM_PAGES 5
#define SHORTSTRLEN         32

#define MIN_DLG_SIZE_X 203
#define MIN_DLG_SIZE_Y 224
#define DLG_SCALE_X    4
#define DLG_SCALE_Y    8

//
// Process Page Column ID enumeration
//

typedef enum COLUMNID
{
    COL_IMAGENAME           = 0,
    COL_PID                 = 1,

    // _HYDRA

    COL_USERNAME            = 2,

    COL_SESSIONID           = 3,

    //
    COL_CPU                 = 4,
    COL_CPUTIME             = 5,
    COL_MEMUSAGE            = 6,
    COL_MEMPEAK             = 7,
    COL_MEMUSAGEDIFF        = 8,
    COL_PAGEFAULTS          = 9,
    COL_PAGEFAULTSDIFF      = 10,
    COL_COMMITCHARGE        = 11,
    COL_PAGEDPOOL           = 12,
    COL_NONPAGEDPOOL        = 13,
    COL_BASEPRIORITY        = 14,
    COL_HANDLECOUNT         = 15,
    COL_THREADCOUNT         = 16,
    COL_USEROBJECTS         = 17,
    COL_GDIOBJECTS          = 18,
    COL_READOPERCOUNT       = 19,
    COL_WRITEOPERCOUNT      = 20,
    COL_OTHEROPERCOUNT      = 21,
    COL_READXFERCOUNT       = 22,
    COL_WRITEXFERCOUNT      = 23,
    COL_OTHERXFERCOUNT      = 24
};

typedef enum NETCOLUMNID
{
    COL_ADAPTERNAME                 = 0,
    COL_ADAPTERDESC                 = 1,   
    COL_NETWORKUTIL                 = 2,   
    COL_LINKSPEED                   = 3,   
    COL_STATE                       = 4,   
    COL_BYTESSENTTHRU               = 5, 
    COL_BYTESRECTHRU                = 6,  
    COL_BYTESTOTALTHRU              = 7,
    COL_BYTESSENT                   = 8,     
    COL_BYTESREC                    = 9,      
    COL_BYTESTOTAL                  = 10,    
    COL_BYTESSENTPERINTER           = 11,    
    COL_BYTESRECPERINTER            = 12,      
    COL_BYTESTOTALPERINTER          = 13,    
    COL_UNICASTSSSENT               = 14,     
    COL_UNICASTSREC                 = 15,     
    COL_UNICASTSTOTAL               = 16,     
    COL_UNICASTSSENTPERINTER        = 17,     
    COL_UNICASTSRECPERINTER         = 18,     
    COL_UNICASTSTOTALPERINTER       = 19,     
    COL_NONUNICASTSSSENT            = 20,     
    COL_NONUNICASTSREC              = 21,     
    COL_NONUNICASTSTOTAL            = 22,     
    COL_NONUNICASTSSENTPERINTER     = 23,     
    COL_NONUNICASTSRECPERINTER      = 24,     
    COL_NONUNICASTSTOTALPERINTER    = 25
};

#define MAX_COLUMN      24
#define NUM_COLUMN      (MAX_COLUMN + 1)
#define NUM_NETCOLUMN   26

#define IDS_FIRSTCOL    20001       // 20000 is first column name ID in rc file

// GetLastHRESULT
//
// Little wrapper func that returns the GetLastError value as an HRESULT

inline HRESULT GetLastHRESULT()
{
    return HRESULT_FROM_WIN32(GetLastError());
}

// Possible values for the viewmode

typedef enum
{
    VM_LARGEICON,
    VM_SMALLICON,
    VM_DETAILS,
    VM_INVALID
} VIEWMODE;
#define VM_FIRST IDM_LARGEICONS
#define VM_LAST  IDM_DETAILS

// Possible values for the cpu history mode

typedef enum
{
    CM_SUM,
    CM_PANES
} CPUHISTMODE;
#define CM_FIRST IDM_ALLCPUS
#define CM_LAST  IDM_MULTIGRAPH

// Possible values for the update speed option

typedef enum
{
    US_HIGH,
    US_NORMAL,
    US_LOW,
    US_PAUSED
} UPDATESPEED;
#define US_FIRST IDM_HIGH
#define US_LAST  IDM_PAUSED



// PtrToFns for RPC calls

typedef BOOLEAN ( WINAPI *pfnWinStationGetProcessSid )( HANDLE hServer, DWORD ProcessId , FILETIME ProcessStartTime , PBYTE pProcessUserSid , PDWORD dwSidSize );

typedef void ( WINAPI *pfnCachedGetUserFromSid )( PSID pSid , PWCHAR pUserName , PULONG cbUserName );

typedef BOOLEAN (WINAPI *pfnWinStationTerminateProcess)( HANDLE hServer, ULONG ProcessId, ULONG ExitCode);

typedef BOOLEAN (WINAPI *pfnWinStationDisconnect) ( HANDLE hServer, ULONG SessionId, BOOL bWait );

extern pfnWinStationGetProcessSid gpfnWinStationGetProcessSid;

extern pfnCachedGetUserFromSid gpfnCachedGetUserFromSid;


// COptions
//
// App's persistent state across sessions, saved in the registry

class COptions
{
public:

    DWORD       m_cbSize;
    DWORD       m_dwTimerInterval;
    VIEWMODE    m_vmViewMode;
    CPUHISTMODE m_cmHistMode;
    UPDATESPEED m_usUpdateSpeed;
    RECT        m_rcWindow;
    INT         m_iCurrentPage;

    NETCOLUMNID m_ActiveNetCol[NUM_NETCOLUMN + 1];
    SHORT       m_NetColumnWidths[NUM_NETCOLUMN + 1];
    INT         m_NetColumnPositions[NUM_NETCOLUMN + 1];
    BOOL        m_bAutoSize;
    BOOL        m_bGraphBytesSent;
    BOOL        m_bGraphBytesReceived;
    BOOL        m_bGraphBytesTotal;
    BOOL        m_bNetShowAll;
    BOOL        m_bShowScale;
    BOOL        m_bTabAlwaysActive;


    COLUMNID    m_ActiveProcCol[NUM_COLUMN + 1];
    INT         m_ColumnWidths[NUM_COLUMN + 1];
    INT         m_ColumnPositions[NUM_COLUMN + 1];

    BOOL        m_fMinimizeOnUse    : 1;
    BOOL        m_fConfirmations    : 1;
    BOOL        m_fAlwaysOnTop      : 1;
    BOOL        m_fKernelTimes      : 1;
    BOOL        m_fNoTitle          : 1;
    BOOL        m_fHideWhenMin      : 1;
    BOOL        m_fShow16Bit        : 1;
    BOOL        m_fShowDomainNames  : 1;
    BOOL        bUnused;
    BOOL        bUnused2;
    BOOL        m_bShowAllProcess;

    HRESULT     Load();
    HRESULT     Save();

    void SetDefaultValues();

    COptions()
    {
        SetDefaultValues();
    }
};

// CTrayNotification
//
// Class to encapsulate all of the info needed to do a tray notification

class CTrayNotification
{
private:
    CTrayNotification(void);    // make the constructor private to prevent access
public:

    CTrayNotification(HWND    hWnd,
                      UINT    uCallbackMessage,
                      DWORD   Message,
                      HICON   hIcon,
                      LPTSTR  pszTip)
    {
        m_hWnd              = hWnd;
        m_uCallbackMessage  = uCallbackMessage;
        m_Message           = Message;
        m_hIcon             = hIcon;

        if ( NULL != pszTip )
        {
            StringCchCopy( m_szTip, ARRAYSIZE(m_szTip), pszTip );
        }
        else
        {
            m_szTip[0] = TEXT('\0');
        }
    }

    HWND    m_hWnd;
    UINT    m_uCallbackMessage;
    DWORD   m_Message;
    HICON   m_hIcon;
    WCHAR   m_szTip[MAX_PATH];
};

void AdjustMenuBar(HMENU hMenu);
int Compare64(unsigned __int64 First, unsigned __int64 Second);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\taskpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       taskpage.cpp
//
//  History:    Nov-29-95   DavePl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Project-scope globals
//

DWORD       g_cTasks        = 0;

//
// Local file prototypes
//

BOOL CALLBACK EnumWindowStationsFunc(LPTSTR  lpstr, LPARAM lParam);
BOOL CALLBACK EnumDesktopsFunc(LPTSTR  lpstr, LPARAM lParam);
BOOL CALLBACK EnumWindowsProc(HWND    hwnd, LPARAM   lParam);

//
// Column ID enumeration
//

typedef enum TASKCOLUMNID
{
    COL_TASKNAME            = 0,
    COL_TASKSTATUS          = 1,
    COL_TASKWINSTATION      = 2,
    COL_TASKDESKTOP         = 3,
};

#define MAX_TASK_COLUMN      3
#define NUM_TASK_COLUMN      (MAX_TASK_COLUMN + 1)

#define IDS_FIRSTTASKCOL    21000       // 21000 is first column name ID in rc file

//
// Column ID on which to sort in the listview, and for
// compares in general
//

TASKCOLUMNID g_iTaskSortColumnID  = COL_TASKNAME;
INT          g_iTaskSortDirection = 1;          // 1 = asc, -1 = desc

//
// Column Default Info
//

struct 
{
    INT Format;
    INT Width;
} TaskColumnDefaults[NUM_TASK_COLUMN] =
{
    { LVCFMT_LEFT,       250},       // COL_TASKNAME
    { LVCFMT_LEFT,       97 },      // COL_TASKSTATUS       
    { LVCFMT_LEFT,       70 },       // COL_TASKWINSTATION
    { LVCFMT_LEFT,       70 },       // COL_TASKDESKTOP   
};


//
// Active Columns
//

TASKCOLUMNID g_ActiveTaskCol[NUM_TASK_COLUMN + 1] =
{
    COL_TASKNAME,     
//  COL_TASKDESKTOP,
    COL_TASKSTATUS,

    (TASKCOLUMNID) -1
};

/*++ class CTaskInfo

Class Description:

    Represents the last known information about a running task

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

class CTaskInfo
{
public:

    HWND            m_hwnd;
    LPWSTR          m_pszWindowTitle;
    LPWSTR          m_lpWinsta;
    LPWSTR          m_lpDesktop;
    BOOL            m_fHung;
    LARGE_INTEGER   m_uPassCount;
    INT             m_iSmallIcon;
    HICON           m_hSmallIcon;
    INT             m_iLargeIcon;
    HICON           m_hLargeIcon;

    //
    // This is a union of which attribute is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

#pragma warning(disable:4201)       // Nameless struct or union
    union
    {
        DWORD                m_fDirty;
        struct 
        {
            DWORD            m_fDirty_COL_HWND           :1;
            DWORD            m_fDirty_COL_TITLE          :1;
            DWORD            m_fDirty_COL_STATUS         :1;
            DWORD            m_fDirty_COL_WINSTA         :1;
            DWORD            m_fDirty_COL_DESKTOP        :1;
        };                                                
    };
#pragma warning(default:4201)       // Nameless struct or union

    HRESULT        SetData(HWND                         hwnd,
                           LPTSTR                       lpTitle,
                           LPTSTR                       lpWinsta,
                           LPTSTR                       lpDesktop,
                           LARGE_INTEGER                uPassCount,
                           BOOL                         fUpdateOnly);

    CTaskInfo()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CTaskInfo()
    {
        if (m_pszWindowTitle)
        {
            LocalFree(m_pszWindowTitle);
        }

        if (m_lpWinsta)
        {
            LocalFree(m_lpWinsta);
        }

        if (m_lpDesktop)
        {
            LocalFree(m_lpDesktop);
        }
    }

    INT Compare(CTaskInfo * pOther);

};

/*++ class CTaskInfo::Compare

Class Description:

    Compares this CTaskInfo object to another, and returns its ranking
    based on the g_iTaskSortColumnID field.

    Note that if the objects are equal based on the current sort column,
    the HWND is used as a secondary sort key to prevent items from 
    jumping around in the listview

Arguments:

    pOther  - the CTaskInfo object to compare this to

Return Value:

    < 0      - This CTaskInfo is "less" than the other
      0      - Equal (Can't happen, since HWND is secondary sort)
    > 0      - This CTaskInfo is "greater" than the other

Revision History:

      Nov-29-95 Davepl  Created

--*/

INT CTaskInfo::Compare(CTaskInfo * pOther)
{
    INT iRet;

    switch (g_iTaskSortColumnID)
    {
    case COL_TASKNAME:
        iRet = lstrcmpi(this->m_pszWindowTitle, pOther->m_pszWindowTitle);
        break;

    case COL_TASKWINSTATION:
        iRet = lstrcmpi(this->m_lpWinsta, pOther->m_lpWinsta);
        break;

    case COL_TASKDESKTOP:
        iRet = lstrcmpi(this->m_lpDesktop, pOther->m_lpDesktop);
        break;

    case COL_TASKSTATUS:
        iRet = Compare64(this->m_fHung, pOther->m_fHung);
        break;

    default:        
        Assert(0 && "Invalid task sort column");
        iRet = 0;
        break;
    }

    // If objects look equal, compare on HWND as secondary sort column
    // so that items don't jump around in the listview

    if (0 == iRet)
    {
        iRet = Compare64((LPARAM)this->m_hwnd, (LPARAM)pOther->m_hwnd);
    }

    return (iRet * g_iTaskSortDirection);
}

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CTaskInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CTaskInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 Davepl  Created

--*/

BOOL InsertIntoSortedArray(CPtrArray * pArray, CTaskInfo * pTask)
{
    
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CTaskInfo * pTmp = (CTaskInfo *) pArray->GetAt(iIndex);
        
        if (pTask->Compare(pTmp) < 0)
        {
            return pArray->InsertAt(iIndex, pTask);
        }
    }

    return pArray->Add(pTask);
}

/*++ ResortTaskArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 Davepl  Created

--*/

BOOL ResortTaskArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
        return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CTaskInfo * pItem = (CTaskInfo *) (*ppArray)->GetAt(i);
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}

/*++ CTaskPage::~CTaskPage()

     Destructor

*/

CTaskPage::~CTaskPage()
{
    FreeOpenFailures();
    RemoveAllTasks();
    delete m_pTaskArray;
}

//
//
//
void CTaskPage::RemoveAllTasks()
{
    if (m_pTaskArray)
    {
        INT c = m_pTaskArray->GetSize();

        while (c)
        {
            delete (CTaskInfo *) (m_pTaskArray->GetAt(c - 1));
            c--;
        }
    }
}

/*++ CTaskPage::UpdateTaskListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by HWND are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.
    
Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 Davepl  Created

--*/

HRESULT CTaskPage::UpdateTaskListview()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_TASKLIST);

    //
    // Stop repaints while we party on the listview
    //

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);

    //
    // If the view mode has changed, update it now
    //

    if (m_vmViewMode != g_Options.m_vmViewMode)
    {
        m_vmViewMode = g_Options.m_vmViewMode;

        DWORD dwStyle = GetWindowLong(hListView, GWL_STYLE);
        dwStyle &= ~(LVS_TYPEMASK);
        
        if (g_Options.m_vmViewMode == VM_SMALLICON)
        {
            ListView_SetImageList(hListView, m_himlSmall, LVSIL_SMALL);
            dwStyle |= LVS_SMALLICON | LVS_AUTOARRANGE;
        }
        else if (g_Options.m_vmViewMode == VM_DETAILS)
        {
            ListView_SetImageList(hListView, m_himlSmall, LVSIL_SMALL);
            dwStyle |= LVS_REPORT;
        }
        else 
        {
            Assert(g_Options.m_vmViewMode == VM_LARGEICON);
            ListView_SetImageList(hListView, m_himlLarge, LVSIL_NORMAL);
            dwStyle |= LVS_ICON | LVS_AUTOARRANGE;
        }

        ListView_DeleteAllItems(hListView);
        SetWindowLong(hListView, GWL_STYLE, dwStyle);
    }

    INT cListViewItems = ListView_GetItemCount(hListView);
    INT CTaskArrayItems = m_pTaskArray->GetSize();
    
    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //

    for (INT iCurrent = 0; 
         iCurrent < cListViewItems && iCurrent < CTaskArrayItems; 
         iCurrent++)
    {
        LV_ITEM lvitem = { 0 };
        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = iCurrent;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CTaskInfo * pTmp = (CTaskInfo *) lvitem.lParam;
        CTaskInfo * pTask = (CTaskInfo *) m_pTaskArray->GetAt(iCurrent);        
        
        if (pTmp != pTask || pTask->m_fDirty)
        {
            // If the objects aren't the same, we need to replace this line

            lvitem.pszText = pTask->m_pszWindowTitle;
            lvitem.lParam  = (LPARAM) pTask;
            
            if (g_Options.m_vmViewMode == VM_LARGEICON)
            {
                lvitem.iImage  = pTask->m_iLargeIcon;
            }
            else
            {
                lvitem.iImage  = pTask->m_iSmallIcon;
            }
            
            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrent, iCurrent);
            pTask->m_fDirty = 0;
        }
    }

    // 
    // We've either run out of listview items or run out of Task array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrent < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrent);
        cListViewItems--;
    }

    while (iCurrent < CTaskArrayItems)
    {
        // Need to add new items to the listview (new tasks appeared)

        CTaskInfo * pTask = (CTaskInfo *)m_pTaskArray->GetAt(iCurrent);
        LV_ITEM lvitem  = { 0 };
        lvitem.mask     = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem    = iCurrent;
        lvitem.pszText  = pTask->m_pszWindowTitle;
        lvitem.lParam   = (LPARAM) pTask;
        lvitem.iImage   = pTask->m_iLargeIcon;

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrent == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
                
        ListView_InsertItem(hListView, &lvitem);
        pTask->m_fDirty = 0;
        iCurrent++;        
    }    

    // Let the listview paint again

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ CTasKPage::EnsureWindowsNotMinimized

Routine Description:

    Walks an array of HWNDS and ensure the windows are not
    minimized, which would prevent them from being 
    cascaded to tiles properly
    
Arguments:

    aHwnds - Array of window handles
    dwCount- Number of HWNDS in table

Return Value:

Revision History:

      Dec-06-95 Davepl  Created

--*/

void CTaskPage::EnsureWindowsNotMinimized(HWND aHwnds[], DWORD dwCount)
{
    for (UINT i = 0; i < dwCount; i++)
    {
        if (IsIconic(aHwnds[i]))
        {
            ShowWindow(aHwnds[i], SW_RESTORE);
        }
    }
}

/*++ CTaslPage::GetSelectedHWNDS

Routine Description:

    Returns a dynamically allocated array of HWNDS based on the
    ones selected in the task list
    
Arguments:

    pdwCount- Number of HWNDS in t`able

Return Value:

    HWND[], or NULL on failure

Revision History:

      Dec-05-95 Davepl  Created

--*/

HWND * CTaskPage::GetHWNDS(BOOL fSelectedOnly, DWORD * pdwCount)
{
    CPtrArray * pArray = NULL;

    if (fSelectedOnly)
    {
        // If we only want selected tasks, go and get the array
        // of selected listview tasks

        pArray = GetSelectedTasks();
        if (NULL == pArray)
        {
            return NULL;
        }
    }
    else
    {
        // If we want everything, just make a copy of the TaskArray

        pArray = new CPtrArray(GetProcessHeap());

        if (pArray)
        {
            if (FALSE == pArray->Copy(*m_pTaskArray))
            {
                delete pArray;
                *pdwCount = 0;
                return NULL;
            }
        }
        else
        {
            *pdwCount = 0;
            return NULL;
        }
    }

    //
    // No windows to speak of, so bail
    //

    *pdwCount = pArray->GetSize();
    if (*pdwCount == 0)
    {
        delete pArray;
        return NULL;
    }

    HWND * pHwnds = (HWND *) LocalAlloc(0, *pdwCount * sizeof(HWND));

    if (NULL == pHwnds)
    {
        *pdwCount = 0;
    }
    else
    {
        for (UINT i = 0; i < *pdwCount; i++)
        {
            pHwnds[i] = (((CTaskInfo *) (pArray->GetAt(i)) )->m_hwnd);
        }
    }

    delete pArray;

    return pHwnds;
}


/*++ CTaskPage::GetSelectedTasks

Routine Description:

    Returns a CPtrArray of the selected tasks
    
Arguments:

Return Value:

    CPtrArray on success, NULL on failure

Revision History:

      Dec-01-95 Davepl  Created

--*/

CPtrArray * CTaskPage::GetSelectedTasks()
{
    BOOL fSuccess = TRUE;

    //
    // Get the count of selected items
    //

    HWND hTaskList = GetDlgItem(m_hPage, IDC_TASKLIST);
    INT cItems = ListView_GetSelectedCount(hTaskList);
    if (0 == cItems)
    {
        return NULL;
    }

    //
    // Create a CPtrArray to hold the task items
    //

    CPtrArray * pArray = new CPtrArray(GetProcessHeap());
    if (NULL == pArray)
    {
        return NULL;
    }

    INT iLast = -1;
    for (INT i = 0; i < cItems; i++)
    {
        //
        // Get the Nth selected item
        // 

        INT iItem = ListView_GetNextItem(hTaskList, iLast, LVNI_SELECTED);

        if (-1 == iItem)
        {
            fSuccess = FALSE;
            break;
        }

        iLast = iItem;

        //
        // Pull the item from the listview and add it to the selected array
        //

        LV_ITEM lvitem = { LVIF_PARAM };
        lvitem.iItem = iItem;
    
        if (ListView_GetItem(hTaskList, &lvitem))
        {
            LPVOID pTask = (LPVOID) (lvitem.lParam);
            if (FALSE == pArray->Add(pTask))
            {
                fSuccess = FALSE;
                break;
            }
        }
        else
        {
            fSuccess = FALSE;
            break;
        }
    }

    //
    // Any errors, clean up the array and bail.  We don't release the
    // tasks in the array, since they are owned by the listview.
    //

    if (FALSE == fSuccess && NULL != pArray)
    {
        delete pArray;
        return NULL;
    }

    return pArray;
}

/*++ CProcPage::HandleTaskListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the task list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Dec-01-95 Davepl  Created

--*/

void CTaskPage::HandleTaskListContextMenu(INT xPos, INT yPos)
{
    HWND hTaskList = GetDlgItem(m_hPage, IDC_TASKLIST);

    CPtrArray * pArray = GetSelectedTasks();

    if (pArray)
    {
        // If non-mouse-based context menu, use the currently selected
        // item as the coords

        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            int iSel = ListView_GetNextItem(hTaskList, -1, LVNI_SELECTED);
            RECT rcItem;
            ListView_GetItemRect(hTaskList, iSel, &rcItem, LVIR_ICON);
            MapWindowRect(hTaskList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }

        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TASK_CONTEXT);

        if (hPopup)
        {
            SetMenuDefaultItem(hPopup, IDM_TASK_SWITCHTO, FALSE);

            //
            // If single-selection, disable the items that require multiple
            // selections to make sense
            //

            if (pArray->GetSize() < 2)
            {
                EnableMenuItem(hPopup, IDM_TASK_CASCADE, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_TASK_TILEHORZ, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_TASK_TILEVERT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            EnableMenuItem(hPopup, IDM_TASK_BRINGTOFRONT, MF_BYCOMMAND | ((pArray->GetSize() == 1) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED)));


            Pause();
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;

            // Note that we don't "unpause" until one of the menu commands (incl CANCEL) is
            // selected or the menu is dismissed
        
            DestroyMenu(hPopup);
        }

        delete pArray;
    }
    else
    {
        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_TASKVIEW);

        if (hPopup && SHRestricted(REST_NORUN))
        {
            DeleteMenu(hPopup, IDM_RUN, MF_BYCOMMAND);
        }

        UINT id;
        if (m_vmViewMode == VM_LARGEICON)
        {
            id = IDM_LARGEICONS;
        } 
        else if (m_vmViewMode == VM_SMALLICON)
        {
            id = IDM_SMALLICONS;
        }
        else
        {
            Assert(m_vmViewMode == VM_DETAILS);
            id = IDM_DETAILS;
        }

        if (hPopup)
        {
            CheckMenuRadioItem(hPopup, IDM_LARGEICONS, IDM_DETAILS, id, MF_BYCOMMAND);
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;
            DestroyMenu(hPopup);
        }
    }
}

//
// Controls which are enabled only for any selection
//
static const UINT g_aSingleIDs[] =
{
    IDC_ENDTASK,
    IDC_SWITCHTO,

};

/*++ CTaskPage::UpdateUIState

Routine Description:

    Updates the enabled/disabled states, etc., of the task UI
    
Arguments:

Return Value:

Revision History:

      Dec-04-95 Davepl  Created

--*/

void CTaskPage::UpdateUIState()
{
    INT i;
    
    // Set the state for controls which require a selection (1 or more items)

    for (i = 0; i < ARRAYSIZE(g_aSingleIDs); i++)
    {
        EnableWindow(GetDlgItem(m_hPage, g_aSingleIDs[i]), m_cSelected > 0);
    }    

    if (g_Options.m_iCurrentPage == 0)
    {
        CPtrArray * pArray = GetSelectedTasks();

        if (pArray)
        {
            UINT state;
            if (pArray->GetSize() == 1)
            {
                state = MF_GRAYED | MF_DISABLED;
            }
            else
            {
                state = MF_ENABLED;
            }

            HMENU hMain  = GetMenu(g_hMainWnd);

            EnableMenuItem(hMain , IDM_TASK_CASCADE, state | MF_BYCOMMAND);
            EnableMenuItem(hMain , IDM_TASK_TILEHORZ, state | MF_BYCOMMAND);
            EnableMenuItem(hMain , IDM_TASK_TILEVERT, state | MF_BYCOMMAND);

            EnableMenuItem(hMain, IDM_TASK_BRINGTOFRONT, MF_BYCOMMAND | ((pArray->GetSize() == 1) ? MF_ENABLED : (MF_DISABLED | MF_GRAYED)));
            delete pArray;
        }
    }
}

/*++ CTaskPage::HandleTaskPageNotify

Routine Description:

    Processes WM_NOTIFY messages received by the taskpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-29-95 Davepl  Created

--*/

INT CTaskPage::HandleTaskPageNotify(LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
    case NM_DBLCLK:
        SendMessage(m_hPage, WM_COMMAND, IDC_SWITCHTO, 0);
        break;    

    // If the (selection) state of an item is changing, see if
    // the count has changed, and if so, update the UI

    case LVN_ITEMCHANGED:
        {
            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_TASKLIST));
                if (cSelected != m_cSelected)
                {
                    m_cSelected = cSelected;
                    UpdateUIState();
                }
            }
        }
        break;

    case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
        
            if (g_iTaskSortColumnID == g_ActiveTaskCol[pnmv->iSubItem])
            {
                g_iTaskSortDirection  *= -1;
            }
            else
            {
                g_iTaskSortColumnID = g_ActiveTaskCol[pnmv->iSubItem];
                g_iTaskSortDirection  = -1;
            }
            ResortTaskArray(&m_pTaskArray);
            TimerEvent();
        }
        break;

    case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
        
            //
            // Listview needs a text string
            //

            if (plvitem->mask & LVIF_TEXT)
            {
                TASKCOLUMNID columnid = (TASKCOLUMNID) g_ActiveTaskCol[plvitem->iSubItem];
                const CTaskInfo  * pTaskInfo   = (const CTaskInfo *)   plvitem->lParam;

                switch(columnid)
                {
                case COL_TASKNAME:
                    //  UI only - don't care if it is truncated.
                    StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pTaskInfo->m_pszWindowTitle );
                    plvitem->mask |= LVIF_DI_SETITEM;
                    break;

                case COL_TASKSTATUS:
                    if (pTaskInfo->m_fHung)
                    {
                        //  UI only - don't care if it is truncated.
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, g_szHung );
                    }
                    else
                    {
                        //  UI only - don't care if it is truncated.
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, g_szRunning );
                    }
                    break;

                case COL_TASKWINSTATION:
                    //  UI only - don't care if it is truncated.
                    StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pTaskInfo->m_lpWinsta );
                    plvitem->mask |= LVIF_DI_SETITEM;
                    break;

                case COL_TASKDESKTOP:
                    //  UI only - don't care if it is truncated.
                    StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pTaskInfo->m_lpDesktop );
                    plvitem->mask |= LVIF_DI_SETITEM;
                    break;

                default:
                    Assert( 0 && "Unknown listview subitem" );
                    break;

                } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
        break;
    
    } // end switch(pnmhdr->code)

    return 1;
}

/*++ CTaskPage::HasAlreadyOpenFailed

Routine Description:

    Checks to see whether a particular open has already failed.
    
Arguments:

    pszWindowStationName - Name of window station to check
    pszDesktopName       - Name of desktop to check, or NULL to check window station only

Return Value:

    BOOL "did it fail already"

Revision History:

      Mar-01-01 BobDay  Created

--*/

BOOL
CTaskPage::HasAlreadyOpenFailed(WCHAR *pszWindowStationName, WCHAR *pszDesktopName)
{
    OPEN_FAILURE *pofFailure;

    pofFailure = m_pofFailures;
    while (NULL != pofFailure)
    {
        if (NULL == pszDesktopName)
        {
            if (NULL == pofFailure->_pszDesktopName)
            {
                if (lstrcmp(pofFailure->_pszWindowStationName,pszWindowStationName) == 0)
                {
                    return TRUE;
                }
            }
        }
        else
        {
            if (NULL != pofFailure->_pszDesktopName)
            {
                if (lstrcmp(pofFailure->_pszWindowStationName,pszWindowStationName) == 0 &&
                    lstrcmp(pofFailure->_pszDesktopName,pszDesktopName) == 0)
                {
                    return TRUE;
                }
            }

        }
        pofFailure = pofFailure->_pofNext;
    }
    return FALSE;
}

/*++ CTaskPage::SetOpenFailed

Routine Description:

    Remebers the fact that an open failed, so that we don't reattempt it
    
Arguments:

    pszWindowStationName - Name of window station that open failed in
    pszDesktopName       - Name of desktop that failed, or NULL if window station failed

Return Value:

    -none-

Revision History:

      Mar-01-01 BobDay  Created

--*/

void
CTaskPage::SetOpenFailed(WCHAR *pszWindowStationName, WCHAR *pszDesktopName)
{
    LPWSTR pszWindowStationNameFailure = NULL;
    LPWSTR pszDesktopNameFailure = NULL;
    OPEN_FAILURE *pofFailure;
    BOOL fValid = TRUE;

    int cchLengthWindowStation = lstrlen(pszWindowStationName) + 1;
    int cchLengthDesktop = lstrlen(pszDesktopName) + 1;

    pszWindowStationNameFailure = (LPWSTR) LocalAlloc( 0, cchLengthWindowStation * sizeof(*pszWindowStationNameFailure) );
    if (NULL == pszWindowStationNameFailure)
    {
        fValid = FALSE;
    }

    if (NULL != pszDesktopName)
    {
        pszDesktopNameFailure = (LPWSTR) LocalAlloc( 0, cchLengthDesktop * sizeof(*pszDesktopNameFailure) );
        if (NULL == pszDesktopNameFailure)
        {
            fValid = FALSE;
        }
    }

    if (fValid)
    {
        pofFailure = (OPEN_FAILURE *) LocalAlloc( 0, sizeof(*pofFailure) );
        if (NULL != pofFailure)
        {
            pofFailure->_pszWindowStationName = pszWindowStationNameFailure;
            pofFailure->_pszDesktopName = pszDesktopNameFailure;

            HRESULT hr = StringCchCopy( pszWindowStationNameFailure, cchLengthWindowStation, pszWindowStationName );
            ASSERT( S_OK == hr );   // this shouldn't truncate as we sized it out above.

            if (NULL != pszDesktopNameFailure)
            {
                hr = StringCchCopy( pszDesktopNameFailure, cchLengthDesktop, pszDesktopName );
                ASSERT( S_OK == hr );   // this shouldn't truncate as we sized it out above.
            }

            pofFailure->_pofNext = m_pofFailures;
            m_pofFailures = pofFailure;
            pofFailure = NULL;
            pszWindowStationNameFailure = NULL;
            pszDesktopNameFailure = NULL;
        }
    }

    if (NULL != pszWindowStationNameFailure)
    {
        LocalFree(pszWindowStationNameFailure);
        pszWindowStationNameFailure = NULL;
    }
    if (NULL != pszDesktopNameFailure)
    {
        LocalFree(pszDesktopNameFailure);
        pszDesktopNameFailure = NULL;
    }
}

/*++ CTaskPage::FreeOpenFailures

Routine Description:

    Frees up all of the open failure structures
    
Arguments:

    -none-

Return Value:

    -none-

Revision History:

      Mar-01-01 BobDay  Created

--*/

void
CTaskPage::FreeOpenFailures(void)
{
    OPEN_FAILURE *pofFailure;
    OPEN_FAILURE *pofNext;

    pofNext = m_pofFailures;
    while (pofNext != NULL)
    {
        pofFailure = pofNext;
        pofNext = pofFailure->_pofNext;

        if (NULL != pofFailure->_pszWindowStationName)
        {
            LocalFree(pofFailure->_pszWindowStationName);
            pofFailure->_pszWindowStationName = NULL;
        }
        if (NULL != pofFailure->_pszDesktopName)
        {
            LocalFree(pofFailure->_pszDesktopName);
            pofFailure->_pszDesktopName = NULL;
        }
        LocalFree(pofFailure);
    }
}


/*++ DoEnumWindowStations

Routine Description:

    Does an EnumWindowStations on a new thread, since the thread needs
    to bop around to various window stations, which isn't allow for the
    main thread since it owns windows.

    This app is really single-threaded, and written with assumptions
    based on that, so the calling thread blocks until the new thread
    has completed the job.
    
Arguments:

    Same as EnumWindowStations

Return Value:

    Same as EnumWindowStations

Revision History:

      Nov-29-95 Davepl  Created

--*/

DWORD WorkerThread(LPVOID pv)
{
    THREADPARAM * ptp = (THREADPARAM *) pv;

    while(1)
    {
        // Wait for a signal from the main thread before proceeding

        WaitForSingleObject(ptp->m_hEventChild, INFINITE);

        // If we are flagged for shutdown, exit now.  Main thread will
        // be waiting on the event for us to signal that we are done with
        // the THREADPARAM block

        if (ptp->m_fThreadExit)
        {
            SetEvent(ptp->m_hEventParent);
            return 0;
        }

        ptp->m_fSuccess = EnumWindowStations(ptp->m_lpEnumFunc, ptp->m_lParam);
        SetEvent(ptp->m_hEventParent);
    }
    return 0;
}

//
//
//
BOOL CTaskPage::DoEnumWindowStations(WINSTAENUMPROC lpEnumFunc, LPARAM lParam)
{
    DWORD dwThreadId;
    
    if (NULL == m_hEventChild)
    {
        m_hEventChild = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hEventChild)
        {
            return FALSE;
        }
    }

    if (NULL == m_hEventParent)
    {
        m_hEventParent = CreateEvent(NULL, FALSE, FALSE, NULL);
        if (NULL == m_hEventParent)
        {
            return FALSE;
        }
    }

    // Save the args away for the worker thread to pick up when it starts
    
    m_tp.m_lpEnumFunc   = lpEnumFunc;
    m_tp.m_lParam       = lParam;
    m_tp.m_hEventChild  = m_hEventChild;
    m_tp.m_hEventParent = m_hEventParent;
    m_tp.m_fThreadExit  = FALSE;

    if (NULL == m_hThread)
    {
        // Run the function call on this new thread, and wait for completion

        m_hThread = CreateThread(NULL, 0, WorkerThread, (LPVOID) &m_tp, 0, &dwThreadId);
        if (NULL == m_hThread)
        {
            return FALSE;
        }
    }

    SetEvent(m_hEventChild);
    WaitForSingleObject(m_hEventParent, INFINITE);

    // Return the result from the worker thread

    return (BOOL) m_tp.m_fSuccess;
}
   
/*++ CTaskPage::TimerEvent

Routine Description:

    Called by main app when the update time fires.  Walks every window
    in the system (on every desktop, in every windowstation) and adds
    or updates it in the task array, then removes any stale processes,
    and filters the results into the listview
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

VOID CTaskPage::TimerEvent()
{
    //
    // If this page is paused (ie: it has a context menu up, etc), we do
    // nothing
    //

    if (m_fPaused)
    {
        return;
    }

    static LARGE_INTEGER uPassCount = {0, 0};

    TASK_LIST_ENUM te;
    
    te.m_pTasks = m_pTaskArray;
    te.m_pPage  = this;
    te.lpWinsta = NULL;
    te.lpDesk   = NULL;
    te.uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // enumerate all windows and try to get the window
    // titles for each task
    //
    
    if ( DoEnumWindowStations( EnumWindowStationsFunc, (LPARAM) &te ))
    {
        INT i = 0;
        while (i < m_pTaskArray->GetSize())
        {
            CTaskInfo * pTaskInfo = (CTaskInfo *)(m_pTaskArray->GetAt(i));
            ASSERT(pTaskInfo);

            //
            // If passcount doesn't match, delete the CTaskInfo instance and remove
            // its pointer from the array.  Note that we _don't_ increment the index
            // if we remove an element, since the next element would now live at
            // the current index after the deletion
            //

            if (pTaskInfo->m_uPassCount.QuadPart != uPassCount.QuadPart)
            {
                // Find out what icons this task was using

                INT iLargeIcon = pTaskInfo->m_iLargeIcon;
                INT iSmallIcon = pTaskInfo->m_iSmallIcon;

                // Remove the task from the task array

                delete pTaskInfo;
                m_pTaskArray->RemoveAt(i, 1);

                // Remove its images from the imagelist

                if (iSmallIcon > 0)
                {
                    ImageList_Remove(m_himlSmall, iSmallIcon);
                }
                if (iLargeIcon > 0)
                {
                    ImageList_Remove(m_himlLarge, iLargeIcon);
                }

                // Fix up the icon indexes for any other tasks (whose icons were
                // at a higher index than the deleted process, and hence now shifted)

                for (int iTmp = 0; iTmp < m_pTaskArray->GetSize(); iTmp++)
                {
                    CTaskInfo * pTaskTmp = (CTaskInfo *)(m_pTaskArray->GetAt(iTmp));
                    
                    if (iLargeIcon && pTaskTmp->m_iLargeIcon > iLargeIcon)
                    {
                        pTaskTmp->m_iLargeIcon--;
                    }

                    if (iSmallIcon && pTaskTmp->m_iSmallIcon > iSmallIcon)
                    {
                        pTaskTmp->m_iSmallIcon--;
                    }
                }
            }
            else
            {
                i++;
            }
        }

        // Selectively filter the new array into the task listview

        UpdateTaskListview();
    }

    if (te.lpWinsta)
    {
        LocalFree(te.lpWinsta);
    }

    if (te.lpDesk)
    {
        LocalFree(te.lpDesk);
    }

    g_cTasks = m_pTaskArray->GetSize();

    uPassCount.QuadPart++;
}

/*++ class CTaskInfo::SetData

Class Description:

    Updates (or initializes) the info about a running task

Arguments:


    hwnd      - taks's hwnd
    lpTitle   - Window title
    uPassCount- Current passcount, used to timestamp the last update of 
                this object
    lpDesktop - task's current desktop
    lpWinsta  - task's current windowstation
    fUpdate   - only worry about information that can change during a
                task's lifetime

Return Value:

    HRESULT

Revision History:

      Nov-16-95 Davepl  Created

--*/

HRESULT CTaskInfo::SetData(HWND                         hwnd,
                           LPTSTR                       lpTitle,
                           LPTSTR                       lpWinsta,
                           LPTSTR                       lpDesktop,
                           LARGE_INTEGER                uPassCount,
                           BOOL                         fUpdateOnly)
{

    // Touch this CTaskInfo to indicate that it's still alive

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    // Window Station

    if (!fUpdateOnly || lstrcmp(m_lpWinsta, lpWinsta))
    {
        if (m_lpWinsta)
        {
            LocalFree(m_lpWinsta);
        }

        DWORD cchLen = lstrlen(lpWinsta) + 1;
        m_lpWinsta = (LPWSTR) LocalAlloc( 0,  cchLen * sizeof(*m_lpWinsta) );
        if (NULL == m_lpWinsta)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            HRESULT hr = StringCchCopy( m_lpWinsta, cchLen, lpWinsta);
            ASSERT( S_OK == hr );   // shouldn't get truncated because we allocated it above
            hr; // unreferenced on FRE builds.
        }
        m_fDirty_COL_WINSTA = TRUE;
    }

    // Desktop

    if (!fUpdateOnly || lstrcmp(m_lpDesktop, lpDesktop))
    {
        if (m_lpDesktop)
        {
            LocalFree(m_lpDesktop);
        }

        DWORD cchLen = lstrlen(lpDesktop) + 1;
        m_lpDesktop = (LPWSTR) LocalAlloc( 0, cchLen * sizeof(*m_lpDesktop) );
        if (NULL == m_lpDesktop)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            HRESULT hr = StringCchCopy( m_lpDesktop, cchLen, lpDesktop );
            ASSERT( S_OK == hr );   // shouldn't get truncated because we allocated it above
            hr; // unreferenced on FRE builds.
        }
        m_fDirty_COL_DESKTOP = TRUE;
    }

    // Title

    if (!fUpdateOnly || lstrcmp(m_pszWindowTitle, lpTitle))
    {
        if (m_pszWindowTitle)
        {
            LocalFree(m_pszWindowTitle);
        }

        DWORD cchLen = lstrlen(lpTitle) + 1;
        m_pszWindowTitle = (LPWSTR) LocalAlloc( 0, cchLen * sizeof(*m_pszWindowTitle ) );
        if (NULL == m_pszWindowTitle)
        {
            return E_OUTOFMEMORY;
        }
        else
        {
            HRESULT hr = StringCchCopy( m_pszWindowTitle, cchLen, lpTitle );
            ASSERT( S_OK == hr );   // shouldn't get truncated because we allocated it above
            hr; // unreferenced on FRE builds.
        }
        m_fDirty_COL_TITLE = TRUE;
    }

    // App status (hung / not hung)

    BOOL fHung = IsHungAppWindow(hwnd);
    if (fHung != m_fHung)
    {
        m_fHung = fHung;
        m_fDirty_COL_STATUS = TRUE;
    }

    // Window handle

    if (m_hwnd != hwnd)
    {
        m_hwnd = hwnd;
        m_fDirty_COL_HWND = TRUE;
    }

    // Icons
    
    #define ICON_FETCH_TIMEOUT 100

    if (!fUpdateOnly)
    {
        m_hSmallIcon = NULL;
        m_hLargeIcon = NULL;

        if (!SendMessageTimeout(hwnd, WM_GETICON, 0, 0, 
                SMTO_BLOCK | SMTO_ABORTIFHUNG, ICON_FETCH_TIMEOUT, (PULONG_PTR) &m_hSmallIcon)
            || NULL == m_hSmallIcon)
        {
            m_hSmallIcon = (HICON) GetClassLongPtr(hwnd, GCLP_HICONSM);
        }
        if (!SendMessageTimeout(hwnd, WM_GETICON, 1, 0, 
                SMTO_BLOCK | SMTO_ABORTIFHUNG, ICON_FETCH_TIMEOUT, (PULONG_PTR) &m_hLargeIcon)
            || NULL == m_hLargeIcon)
        {
            m_hLargeIcon = (HICON) GetClassLongPtr(hwnd, GCLP_HICON);
        }
    }
    
    return S_OK;
}

/*++

Routine Description:

    Callback function for windowstation enumeration.

Arguments:

    lpstr            - windowstation name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumWindowStationsFunc(LPTSTR  lpstr, LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HWINSTA           hwinsta;
    HWINSTA           hwinstaSave;
    DWORD             ec;

    //
    // Don't fiddle with things which we already failed to open before
    //
    if (te->m_pPage->HasAlreadyOpenFailed(lpstr, NULL))
    {
        return TRUE;
    }

    //
    // open the windowstation
    //
    hwinsta = OpenWindowStation( lpstr, FALSE, WINSTA_ENUMDESKTOPS );
    if (!hwinsta) 
    {
        te->m_pPage->SetOpenFailed(lpstr, NULL);

        // If we fail because we don't have sufficient access to this
        // window station, we should continue the enumeration anyway.
        return TRUE;
    }

    //
    // save the current windowstation
    //

    hwinstaSave = GetProcessWindowStation();

    //
    // change the context to the new windowstation
    //

    if (!SetProcessWindowStation( hwinsta )) 
    {
        ec = GetLastError();
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
        
        if (hwinsta != hwinstaSave)
        {
            CloseWindowStation( hwinstaSave );
        }
        
        return TRUE;
    }

    //
    // Update the windowstation in the enumerator
    //

    if (te->lpWinsta)
    {
        LocalFree(te->lpWinsta);
    }

    DWORD cchLen = lstrlen(lpstr) + 1;
    te->lpWinsta = (LPWSTR) LocalAlloc( 0, cchLen * sizeof(*te->lpWinsta) );
    if (NULL == te->lpWinsta)
    {
        if (hwinsta != hwinstaSave) 
        {
            SetProcessWindowStation( hwinstaSave );
            CloseWindowStation( hwinsta );
        }
        CloseWindowStation( hwinstaSave );

        // We technically could continue, but if we're this strapped for
        // memory, there's not much point.  Let's bail on the winsta enumeration.
        return FALSE;
    }
    else
    {
        HRESULT hr = StringCchCopy( te->lpWinsta, cchLen, lpstr );
        ASSERT( S_OK == hr );   // shouldn't get truncated because we allocated it above
        hr; // unreferenced on FRE builds.
    }

    //
    // enumerate all the desktops for this windowstation
    //
    
    EnumDesktops( hwinsta, EnumDesktopsFunc, lParam );

    //
    // restore the context to the previous windowstation
    //

    if (hwinsta != hwinstaSave) 
    {
        SetProcessWindowStation( hwinstaSave );
        CloseWindowStation( hwinsta );
    }

    //
    // continue the enumeration
    //

    return TRUE;
}

/*++

Routine Description:

    Callback function for desktop enumeration.

Arguments:

    lpstr            - desktop name
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumDesktopsFunc(LPTSTR  lpstr, LPARAM lParam)
{
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    HDESK             hdeskSave;
    HDESK             hdesk;
    DWORD             ec;

    //
    // Don't fiddle with things which we already failed to open before
    //
    if (te->m_pPage->HasAlreadyOpenFailed(te->lpWinsta, lpstr))
    {
        return TRUE;
    }

    //
    // open the desktop
    //
    hdesk = OpenDesktop( lpstr, 0, FALSE, DESKTOP_READOBJECTS );
    if (!hdesk) 
    {
        te->m_pPage->SetOpenFailed(te->lpWinsta, lpstr);

        // If we fail because we don't have sufficient access to this
        // desktop, we should continue the enumeration anyway.
        return TRUE;
    }

    //
    // save the current desktop
    //

    hdeskSave = GetThreadDesktop( GetCurrentThreadId() );

    //
    // change the context to the new desktop
    //

    if (!SetThreadDesktop( hdesk )) 
    {
        ec = GetLastError();
        SetThreadDesktop( hdeskSave );
        if (g_hMainDesktop != hdesk)
        {
            CloseDesktop( hdesk );
        }
        if (g_hMainDesktop != hdeskSave)
        {
            CloseDesktop( hdeskSave );
        }
        return TRUE;
    }

    //
    // Update the desktop in the enumerator
    //

    if (te->lpDesk)
    {
        LocalFree(te->lpDesk);
    }

    DWORD cchLen = lstrlen(lpstr) + 1;
    te->lpDesk = (LPWSTR) LocalAlloc( 0, cchLen * sizeof(*te->lpDesk) );
    if (NULL == te->lpDesk)
    {   
        if (hdesk != hdeskSave) 
        {
            SetThreadDesktop( hdeskSave );
        }
        if (g_hMainDesktop != hdesk)
        {
            CloseDesktop( hdesk );
        }
        if (g_hMainDesktop != hdeskSave)
        {
            CloseDesktop( hdeskSave );
        }
        return FALSE;
    }
    else
    {
        HRESULT hr = StringCchCopy(te->lpDesk, cchLen, lpstr);
        ASSERT( S_OK == hr );   // shouldn't get truncated because we allocated it above
        hr; // unreferenced on FRE builds.
    }

    //
    // enumerate all windows in the new desktop
    //

    EnumWindows( EnumWindowsProc, lParam ); 

    //
    // restore the previous desktop
    //

    if (hdesk != hdeskSave)
    {
        SetThreadDesktop( hdeskSave );
    }
    
    if (g_hMainDesktop != hdesk)
    {
        CloseDesktop( hdesk );
    }
    if (g_hMainDesktop != hdeskSave)
    {
        CloseDesktop( hdeskSave );
    }

    return TRUE;
}

/*++

Routine Description:

    Callback function for window enumeration.

Arguments:

    hwnd             - window handle
    lParam           - ** not used **

Return Value:

    TRUE  - continues the enumeration

--*/

BOOL CALLBACK EnumWindowsProc(HWND    hwnd, LPARAM   lParam)
{
    DWORD             i;
    PTASK_LIST_ENUM   te = (PTASK_LIST_ENUM)lParam;
    DWORD             numTasks = te->m_pTasks->GetSize();
    WCHAR             szTitle[MAX_PATH];

    if ((GetWindow( hwnd, GW_OWNER ))   || 
        (!IsWindowVisible(hwnd)))
        
    {
        //
        // not a top level window, or not visible
        //

        return TRUE;
    }

    if (FALSE == InternalGetWindowText(hwnd, szTitle, ARRAYSIZE(szTitle)))
    {
        // Can't get the title - something weird going on.. but continue anyway

        return TRUE;
    }

    if (TEXT('\0') == szTitle[0])
    {
        // Empty title - of little value in the task list

        return TRUE;
    }

    if (hwnd == g_hMainWnd)
    {
        // Don't show the Task Manager in the list

        return TRUE;
    }

    if (0 == lstrcmpi(szTitle, TEXT("Program Manager")))
    {
        // Don't show the Program Manager (explorer) in the list

        return TRUE;
    }

    //
    // look for the task in the task list for this window
    //

    for (i=0; i < numTasks; i++) 
    {
        CTaskInfo * pTask = (CTaskInfo *) te->m_pTasks->GetAt(i);

        if (pTask->m_hwnd == hwnd)
        {
            //
            // Update the task info
            //

            if (FAILED(pTask->SetData(hwnd, szTitle, te->lpWinsta, te->lpDesk, te->uPassCount, TRUE)))
            {
                return FALSE;
            }
            pTask->m_uPassCount.QuadPart = te->uPassCount.QuadPart;

            break;
        }
    }

    if (i >= numTasks)
    {
        // Didn't find the task, it must be a new one

        CTaskInfo * pTask = new CTaskInfo;
        if (NULL == pTask)
        {
            return FALSE;
        }

        // Init the task data.  If fails, delete and bail

        if (FAILED(pTask->SetData(hwnd, szTitle, te->lpWinsta, te->lpDesk, te->uPassCount, FALSE)))
        {
            delete pTask;
            return FALSE;
        }
        else
        {
            // Add the icons to the page's imagelist

            if (!pTask->m_hLargeIcon && !pTask->m_hSmallIcon)
            {
                pTask->m_iLargeIcon = 0;
                pTask->m_iSmallIcon = 0;
            }
            else
            {
                // The indices to the small and large icons for a task must
                // always be the same; so, if one size is missing, use the icon
                // of the other size (stretched).  All the resizing is taken
                // care of for us by ImageList_AddIcon(), since it's already
                // had a fixed size set on it and will force any added icon
                // into that size.                
                pTask->m_iLargeIcon = ImageList_AddIcon(te->m_pPage->m_himlLarge, 
                                                        pTask->m_hLargeIcon ? 
                                                                pTask->m_hLargeIcon
                                                            :   pTask->m_hSmallIcon);
                if (-1 == pTask->m_iLargeIcon)
                {
                    delete pTask;
                    return FALSE;
                }

                pTask->m_iSmallIcon = ImageList_AddIcon(te->m_pPage->m_himlSmall, 
                                                        pTask->m_hSmallIcon ? 
                                                                pTask->m_hSmallIcon
                                                            :   pTask->m_hLargeIcon);
                if (-1 == pTask->m_iSmallIcon)
                {
                    ImageList_Remove(te->m_pPage->m_himlLarge, pTask->m_iLargeIcon);
                    delete pTask;
                    return FALSE;
                }           
            }

            // All went well, so add it to the array

            if (!(te->m_pTasks->Add( (LPVOID) pTask)))
            {
                delete pTask;
                return FALSE;
            }
        }
    }

    //
    // continue the enumeration
    //

    return TRUE;
}

/*++ CTaskPage::SizeTaskPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-29-95 Davepl  Created

--*/

static const INT aTaskControls[] =
{
    IDC_SWITCHTO,
    IDC_ENDTASK,
    IDM_RUN
};

void CTaskPage::SizeTaskPage()
{
    // Get the coords of the outer dialog

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos( 1 + ARRAYSIZE(aTaskControls) );
    if (!hdwp)
        return;

    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDM_RUN);
    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcMaster.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    // Size the listbox

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_TASKLIST);
    RECT rcListbox;
    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);

    INT lbX = rcMaster.right - rcListbox.left + dx;
    INT lbY = rcMaster.top - rcListbox.top + dy - g_DefSpacing;

    DeferWindowPos(hdwp, hwndListbox, NULL,
                        0, 0,
                        lbX, 
                        lbY,
                        SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);


    // Adjust the first column width to be the width of the listbox
    // less the size of the status column

    INT cxStatus = ListView_GetColumnWidth(hwndListbox, 1);

    if (lbX - cxStatus > 0)
    {
        ListView_SetColumnWidth(hwndListbox, 0, lbX - cxStatus);
    }

    // Move each of the child controls by the above delta

    for (int i = 0; i < ARRAYSIZE(aTaskControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aTaskControls[i]);
        RECT rcCtrl;
        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL, 
                         rcCtrl.left + dx, 
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }


    EndDeferWindowPos(hdwp);
}

/*++ CTaskPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Dec-01-95 Davepl  Created

--*/

void CTaskPage::HandleWMCOMMAND(INT id)
{
    switch(id)
    {
    case IDM_TASK_FINDPROCESS:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);

            // Send a message to the main window telling it to
            // switch pages and select the process in question in
            // the process view

            if (pHwnds)
            {
                DWORD pid = 0;
                DWORD tid;

                tid = GetWindowThreadProcessId(pHwnds[0], &pid);
                if (pid)
                {
                    PostMessage(g_hMainWnd, WM_FINDPROC, tid, pid);
                }

                LocalFree(pHwnds);
            }
        }
        break;

    case IDM_LARGEICONS:
    case IDM_SMALLICONS:
    case IDM_DETAILS:
    case IDM_RUN:
        //
        // These menu items (from the popup) have matching ones in the main menu,
        // so just pass them along to the main menu
        //
        SendMessage(g_hMainWnd, WM_COMMAND, MAKELPARAM(id, 0), 0);
        break;

    case IDM_TASK_SWITCHTO:
    case IDC_SWITCHTO:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                // If target is minimized, restore it

                if (IsIconic(pHwnds[0]))
                {
                    ShowWindow(pHwnds[0], SW_RESTORE);
                }

                // Switch to the target window, and if the options dictate,
                // minimize the taskmanager

                HWND hwndLastActive = GetLastActivePopup(pHwnds[0]);
                if (!IsWindow(hwndLastActive)) {
                    MessageBeep(0);
                    LocalFree(pHwnds);
                    break;
                }

                // Can really only switch if the window is not disabled

                LONG lTemp = GetWindowLong(hwndLastActive, GWL_STYLE);
                if (0 == (lTemp & WS_DISABLED)) 
                {
                    //  Use SwitchToThisWindow() to bring dialog parents as well.
                    SwitchToThisWindow(hwndLastActive, TRUE);
                    if (g_Options.m_fMinimizeOnUse)
                    {
                        ShowWindow(g_hMainWnd, SW_MINIMIZE);
                    }
                } 
                else 
                {
                    MessageBeep(0);
                }
                LocalFree(pHwnds);
            }
        }
        break;

    case IDC_TILEHORZ:
    case IDM_TASK_TILEHORZ:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            TileWindows(GetDesktopWindow(),
                        MDITILE_HORIZONTAL,
                        NULL,
                        dwCount,
                        pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
        }
        break;

    case IDM_TASK_TILEVERT:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            TileWindows(GetDesktopWindow(),
                        MDITILE_VERTICAL,
                        NULL,
                        dwCount,
                        pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
        }
        break;

    case IDM_TASK_CASCADE:
        {
            DWORD dwCount;

            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
            }

            CascadeWindows(GetDesktopWindow(),
                   0,
                   NULL,
                   dwCount,
                   pHwnds);
            if (pHwnds)
            {
                LocalFree(pHwnds);
            }
        }
        break;

    case IDM_TASK_MINIMIZE:
    case IDM_TASK_MAXIMIZE:
        {
            DWORD dwCount;
        
            // If some selected, just get them, else get all
         
            HWND * pHwnds = GetHWNDS(m_cSelected, &dwCount);

            if (pHwnds)
            {
                for (UINT i = 0; i < dwCount; i++)
                {
                    ShowWindowAsync(pHwnds[i], (id == IDC_MINIMIZE || id == IDM_TASK_MINIMIZE) ?
                                                SW_MINIMIZE : SW_MAXIMIZE);
                }
                LocalFree(pHwnds);
            }
        }
        break;

    case IDC_BRINGTOFRONT:
    case IDM_TASK_BRINGTOFRONT:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);
            if (pHwnds)
            {
                EnsureWindowsNotMinimized(pHwnds, dwCount);
                            
                // Walk backwards through the list so that the first window selected
                // in on top

                for (INT i = (INT) dwCount - 1; i >= 0 ; i--)
                {
                    SetWindowPos(pHwnds[i], HWND_TOP, 0, 0, 0, 0, SWP_NOSIZE | SWP_NOMOVE);
                }

                DWORD dwProc;
                if (GetWindowThreadProcessId(pHwnds[0], &dwProc))
                {
                    AllowSetForegroundWindow(dwProc);
                }

                SetForegroundWindow(pHwnds[0]);
                LocalFree(pHwnds);
            }        
        }
        break;

    case IDC_ENDTASK:
    case IDM_TASK_ENDTASK:
        {
            DWORD dwCount;
            HWND * pHwnds = GetHWNDS(TRUE, &dwCount);
            if (pHwnds)
            {
                BOOL fForce = GetKeyState(VK_CONTROL) & ( 1 << 16) ? TRUE : FALSE;
                for(UINT i = 0; i < dwCount; i++)
                {
                    // SetActiveWindow(aHwnds[i]);
                    EndTask(pHwnds[i], FALSE, fForce);
                }

                LocalFree(pHwnds);
            }
        }
        break;
    }

    Unpause();
}

/*++ TaskPageProc

Routine Description:

    Dialogproc for the task manager page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:
    
    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-28-95 Davepl  Created

--*/

INT_PTR CALLBACK TaskPageProc(
                HWND        hwnd,               // handle to dialog box
                UINT        uMsg,                   // message
                WPARAM      wParam,                 // first message parameter
                LPARAM      lParam                  // second message parameter
                )
{
    CTaskPage * thispage = (CTaskPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    // See if the parent wants this message

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CTaskPage * thispage = (CTaskPage *) lParam;

            thispage->m_hPage = hwnd;

            HWND hTaskList = GetDlgItem(hwnd, IDC_TASKLIST);
            ListView_SetImageList(hTaskList, thispage->m_himlSmall, LVSIL_SMALL);

            // Turn on SHOWSELALWAYS so that the selection is still highlighted even
            // when focus is lost to one of the buttons (for example)

            SetWindowLong(hTaskList, GWL_STYLE, GetWindowLong(hTaskList, GWL_STYLE) | LVS_SHOWSELALWAYS);

            if (SHRestricted(REST_NORUN))
            {
                EnableWindow (GetDlgItem(hwnd, IDM_RUN), FALSE);
            }

            ListView_SetExtendedListViewStyle(hTaskList, LVS_EX_DOUBLEBUFFER);
        
        }
        // We handle focus during Activate(). Return FALSE here so the
        // dialog manager doesn't try to set focus.
        return FALSE;

    
    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        if (g_Options.m_fNoTitle)
        {
            SendMessage(g_hMainWnd, 
                        uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
                        HTCAPTION, 
                        lParam);
        }
        break;

    case WM_COMMAND:
        thispage->HandleWMCOMMAND(LOWORD(wParam));
        break;

    case WM_NOTIFY:
        return thispage->HandleTaskPageNotify((LPNMHDR) lParam);

    case WM_MENUSELECT:
        if ((UINT) HIWORD(wParam) == 0xFFFF)
        {
            // Menu dismissed, resume display

            thispage->Unpause();
        }
        break;

    case WM_CONTEXTMENU:
        if ((HWND) wParam == GetDlgItem(hwnd, IDC_TASKLIST))
        {
            thispage->HandleTaskListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            return TRUE;
        }
        break;

    case WM_SIZE:
        //
        // Size our kids
        //
        thispage->SizeTaskPage();
        return TRUE;

    case WM_SETTINGCHANGE:
        thispage->OnSettingsChange();
        // fall through

    case WM_SYSCOLORCHANGE:
        SendMessage(GetDlgItem(hwnd, IDC_TASKLIST), uMsg, wParam, lParam);
        return TRUE;
    }

    return FALSE;
}

//
//
//
void CTaskPage::OnSettingsChange()
{
    // in going between large-font settings and normal settings, the size of small 
    // icons changes; so throw away all our icons and change the size of images in 
    // our lists
    
    BOOL fPaused = m_fPaused; // pause the page so we can get through
    m_fPaused = TRUE;         // the below without being updated  

    RemoveAllTasks();
    m_pTaskArray->RemoveAll();
    
    m_vmViewMode = VM_INVALID;      // cause an update to the list view
    
    // you'd think that since SetIconSize does a RemoveAll anyway, the
    // explicit RemoveAll calls are redundant; however, if SetIconSize
    // gets size parameters which aren't different from what it has,
    // it fails without doing a RemoveAll!
    ImageList_RemoveAll(m_himlLarge);
    ImageList_RemoveAll(m_himlSmall);
    ImageList_SetIconSize(m_himlLarge, GetSystemMetrics(SM_CXICON),
                                        GetSystemMetrics(SM_CYICON));
    ImageList_SetIconSize(m_himlSmall, GetSystemMetrics(SM_CXSMICON),
                                        GetSystemMetrics(SM_CYSMICON));

    LoadDefaultIcons();     // this could return an error, but if it does,
                            // we just have to press on

    m_fPaused = fPaused;            // restore the paused state
    TimerEvent();           // even if we're paused, we'll want to redraw
}

/*++ CTaskPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

void CTaskPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_TASKPAGETITLE, pszText, static_cast<int>(bufsize));
}

/*++ CTaskPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it
    
Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-28-95 Davepl  Created

--*/
 
HRESULT CTaskPage::Activate()
{
    // Make this page visible

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(m_hPage,
                 HWND_TOP,
                 0, 0, 0, 0,
                 SWP_NOMOVE | SWP_NOSIZE);


    //
    // Change the menu bar to be the menu for this page
    //

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_TASK));

    AdjustMenuBar(hMenuNew);

    if (hMenuNew && SHRestricted(REST_NORUN))
    {
        DeleteMenu(hMenuNew, IDM_RUN, MF_BYCOMMAND);
    }

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }

    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_TASKLIST));
    }

    return S_OK;
}


/*++ class CTaskPage::SetupColumns

Class Description:

    Removes any existing columns from the taskmanager listview and
    adds all of the columns listed in the g_ActiveTaskCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 Davepl  Created

--*/

HRESULT CTaskPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_TASKLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }    

    ListView_DeleteAllItems(hwndList);

    //
    // Remove all existing columns
    //

    LV_COLUMN lvcolumn;
    while(ListView_DeleteColumn(hwndList, 0))
    {
        NULL;
    }

    //
    // Add all of the new columns
    //

    INT iColumn = 0;
    while (g_ActiveTaskCol[iColumn] >= 0)
    {
        INT idColumn = g_ActiveTaskCol[iColumn];

        WCHAR szTitle[MAX_PATH];
        LoadString(g_hInstance, IDS_FIRSTTASKCOL + idColumn, szTitle, ARRAYSIZE(szTitle));

        lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_TEXT | LVCF_WIDTH;
        lvcolumn.fmt        = TaskColumnDefaults[ idColumn ].Format;
        lvcolumn.cx         = TaskColumnDefaults[ idColumn ].Width;
        lvcolumn.pszText    = szTitle;
        lvcolumn.iSubItem   = iColumn;

        if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
        {
            return E_FAIL;
        }
        iColumn++;
    }

    return S_OK;
}

/*++ CTaskPage::Initialize

Routine Description:

    Initializes the task manager page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
                  since the main app window is always used as the parent in
                  order to keep tab order correct
                  
Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

HRESULT CTaskPage::Initialize(HWND hwndParent)
{
    HRESULT hr = S_OK;
    UINT flags = ILC_MASK | ILC_COLOR32;

    //
    // Create the ptr array used to hold the info on running tasks
    //

    m_pTaskArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pTaskArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Our pseudo-parent is the tab contrl, and is what we base our
        // sizing on.  However, in order to keep tab order right among
        // the controls, we actually create ourselves with the main
        // window as the parent

        m_hwndTabs = hwndParent;

        //
        // Create the image lists
        //

        if(IS_WINDOW_RTL_MIRRORED(hwndParent))
        {
            flags |= ILC_MIRROR;
        }

        m_himlSmall = ImageList_Create( GetSystemMetrics(SM_CXSMICON)
                                      , GetSystemMetrics(SM_CYSMICON)
                                      , flags
                                      , 1
                                      , 1
                                      );
    
        if (NULL == m_himlSmall)
        {
            hr = E_FAIL;    
        }
    }

    if (SUCCEEDED(hr))
    {
        m_himlLarge = ImageList_Create(
                    GetSystemMetrics(SM_CXICON),
                    GetSystemMetrics(SM_CYICON),
                    flags,
                    1,
                    1
                    );
        if (NULL == m_himlLarge)
        {
            hr = E_FAIL;
        }
    }

    // Load the default icons
    hr = LoadDefaultIcons();

    if (SUCCEEDED(hr))
    {
        //
        // Create the dialog which represents the body of this page
        //

        m_hPage = CreateDialogParam(
                        g_hInstance,                    // handle to application instance
                        MAKEINTRESOURCE(IDD_TASKPAGE),  // identifies dialog box template name  
                        g_hMainWnd,                     // handle to owner window
                        TaskPageProc,                   // pointer to dialog box procedure
                        (LPARAM) this );                // User data (our this pointer)

        if (NULL == m_hPage)
        {
            hr = GetLastHRESULT();
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set up the columns in the listview

        hr = SetupColumns();
    }

    if (SUCCEEDED(hr))
    {
        TimerEvent();
    }

    //
    // If any failure along the way, clean up what got allocated
    // up to that point
    //

    if (FAILED(hr))
    {
        if (m_hPage)
        {
            DestroyWindow(m_hPage);
        }

        m_hwndTabs = NULL;
    }

    return hr;
}

//
//
//
HRESULT CTaskPage::LoadDefaultIcons()
{
    HICON   hDefLarge;
    HICON   hDefSmall;
    HRESULT hr = S_OK;
    
    hDefSmall = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DEFAULT), IMAGE_ICON, 
                            GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0);
    if (!hDefSmall)
    {
        return GetLastHRESULT();
    }
    if (-1 == ImageList_AddIcon(m_himlSmall, hDefSmall))
    {
        hr = E_FAIL;
    }
    DestroyIcon(hDefSmall);

    hDefLarge = (HICON) LoadImage(g_hInstance, MAKEINTRESOURCE(IDI_DEFAULT), IMAGE_ICON, 
                            GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0);
    if (!hDefLarge)
    {
        return GetLastHRESULT();
    }
    if (-1 == ImageList_AddIcon(m_himlLarge, hDefLarge))
    {
        hr = E_FAIL;
    }
    DestroyIcon(hDefLarge);
    
    return hr;
}

/*++ CTaskPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

HRESULT CTaskPage::Destroy()
{
    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    if (m_hThread)
    {
        // Signal the child thead to exit, and wait for it to do so

        m_tp.m_fThreadExit = TRUE;
        SetEvent(m_hEventChild);
        WaitForSingleObject(m_hEventParent, INFINITE);
        CloseHandle(m_hThread);
        m_hThread = NULL;
    }

    if (m_hEventChild)
    {
        CloseHandle(m_hEventChild);
        m_hEventChild = NULL;
    }

    if (m_hEventParent)
    {
        CloseHandle(m_hEventParent);
        m_hEventParent = NULL;
    }

    // These are freed automatically by listview

    m_himlSmall = NULL;
    m_himlLarge = NULL;

    return S_OK;
}

/*++ CTaskPage::Deactivate

Routine Description:

    Called when this page is losing its place up front
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 Davepl  Created

--*/

void CTaskPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\ptrarray.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ptrarray.h
//
//  Contents:   Handles dynamic arrays of void *
//
//  History:    7-13-95  Davepl  Created
//
//--------------------------------------------------------------------------

class CPtrArray
{

public:

    //
    // Constructor / Destructor
    //

    CPtrArray();
    CPtrArray(HANDLE hHeap);
    virtual ~CPtrArray();

    //
    // Attributes
    //

    int     GetSize() const
    {
        return m_nSize;
    }

    int     GetUpperBound() const
    {
        return m_nSize-1;
    }

    BOOL    SetSize(int nNewSize, int nGrowBy = -1);

    BOOL    FreeExtra();
    BOOL    RemoveAll()
    {
        return SetSize(0);
    }

    void*   GetAt(int nIndex) const
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex];
    }

    void    SetAt(int nIndex, void* newElement)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        m_pData[nIndex] = newElement;
    }

    void*&  ElementAt(int nIndex)
    {
        ASSERT(nIndex >= 0 && nIndex < m_nSize);
        return m_pData[nIndex];
    }

    // Direct Access to the element data (may return NULL)

    const void** GetData() const
    {
        return (const void**)m_pData;
    }

    void**  GetData()
    {
        return (void**)m_pData;
    }

    // Potentially growing the array

    BOOL SetAtGrow(int nIndex, void* newElement)
    {
        ASSERT(nIndex >= 0);

        if (nIndex >= m_nSize)
        {
            if (FALSE == SetSize(nIndex+1))
            {
                return FALSE;
            }
        }
        m_pData[nIndex] = newElement;

        return TRUE;
    }

    BOOL Add(void* newElement, int * pIndex = NULL)
    {
        if (pIndex)
        {
            *pIndex = m_nSize;
        }
        return SetAtGrow(m_nSize, newElement);
    }


    BOOL Append(const CPtrArray& src, int * pOldSize = NULL)
    {
        ASSERT(this != &src);   // cannot append to itself

        int nOldSize = m_nSize;

        if (FALSE == SetSize(m_nSize + src.m_nSize))
        {
            return TRUE;
        }

        CopyMemory(m_pData + nOldSize, src.m_pData, src.m_nSize * sizeof(*m_pData));

        if (pOldSize)
        {
            *pOldSize = nOldSize;
        }

        return TRUE;
    }

    BOOL Copy(const CPtrArray& src)
    {
        ASSERT(this != &src);   // cannot append to itself

        if (FALSE == SetSize(src.m_nSize))
        {
            return FALSE;
        }

        CopyMemory(m_pData, src.m_pData, src.m_nSize * sizeof(*m_pData));

        return TRUE;

    }

    // overloaded operator helpers

    void*   operator[](int nIndex) const
    {
        return GetAt(nIndex);
    }


    void*&  operator[](int nIndex)
    {
        return ElementAt(nIndex);
    }


    // Operations that move elements around

    BOOL InsertAt(int nIndex, void* newElement, int nCount = 1);
    BOOL InsertAt(int nStartIndex, CPtrArray* pNewArray);

    void RemoveAt(int nIndex, int nCount)
    {
        ASSERT(nIndex >= 0);
        ASSERT(nCount >= 0);
        ASSERT(nIndex + nCount <= m_nSize);

        // just remove a range
        int nMoveCount = m_nSize - (nIndex + nCount);

        if (nMoveCount > 0)
        {
            CopyMemory(&m_pData[nIndex], &m_pData[nIndex + nCount], nMoveCount * sizeof(*m_pData));
        }

        m_nSize -= nCount;
    }


// Implementation

protected:

    void**  m_pData;     // the actual array of data
    int     m_nSize;     // # of elements (upperBound - 1)
    int     m_nMaxSize;  // max allocated
    int     m_nGrowBy;   // grow amount
    HANDLE  m_hHeap;     // heap to allocate from
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\ptrarray.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995
//
//  File:       ptrarray.cpp
//
//  Contents:   Handles dynamic arrays of void *.  Stolen from MFC
//
//  History:    7-13-95  Davepl  Created
//
//--------------------------------------------------------------------------

#include "precomp.h"

//
// Default contstructor just invokes normal constructor, using the
// current process' heap as the heap handle
//

CPtrArray::CPtrArray()
{
    CPtrArray::CPtrArray(GetProcessHeap());
}

//
// Constructor save a handle to the heap supplied to use for future 
// allocations
//

CPtrArray::CPtrArray(HANDLE hHeap)
{
    m_hHeap     = hHeap;
    m_pData     = NULL;
    m_nSize     = 0;
    m_nMaxSize  = 0;
    m_nGrowBy   = 0;
}

CPtrArray::~CPtrArray()
{
    HeapFree(m_hHeap, 0, m_pData);
}

BOOL CPtrArray::SetSize(int nNewSize, int nGrowBy)
{
    ASSERT(nNewSize >= 0);

    //
    // Set the new size
    //

    if (nGrowBy != -1)
    {
        m_nGrowBy = nGrowBy;
    }

    if ( -1 == nGrowBy )
    {
        nGrowBy = m_nGrowBy;
    }

    if (nNewSize == 0)
    {
        //
        // Shrink to nothing
        //

        HeapFree(m_hHeap, 0, m_pData);
        m_pData = NULL;
        m_nSize = m_nMaxSize = 0;
    }
    else if (m_pData == NULL)
    {
        //
        // Data array doesn't exist yet, allocate it now
        //

        LPVOID * pnew = (LPVOID *) HeapAlloc(m_hHeap, HEAP_ZERO_MEMORY, nNewSize * sizeof(*m_pData));

        if (pnew)
        {
            m_pData     = pnew;
            m_nSize     = nNewSize;
            m_nMaxSize  = nNewSize;
        }
        else
        {
            return FALSE;
        }
    }
    else if (nNewSize <= m_nMaxSize)
    {
        //
        // It fits
        //

        if (nNewSize > m_nSize)
        {
            // initialize the new elements

            ZeroMemory(&m_pData[m_nSize], (nNewSize-m_nSize) * sizeof(*m_pData));
        }

        m_nSize = nNewSize;
    }
    else
    {
        Assert( -1 != nGrowBy );

        //
        //  It doesn't fit: grow the array
        //

        m_nGrowBy = nGrowBy;
        if (nGrowBy == 0)
        {
            //
            // Heuristically determine growth when nGrowBy == 0
            //  (this avoids heap fragmentation in many situations)
            //

            nGrowBy = min(1024, max(4, m_nSize / 8));
        }

        int nNewMax;

        if (nNewSize < m_nMaxSize + nGrowBy)
        {
            nNewMax = m_nMaxSize + nGrowBy;     // granularity
        }
        else
        {
            nNewMax = nNewSize;                 // no slush
        }

        ASSERT(nNewMax >= m_nMaxSize);          // no wrap around

        LPVOID * pNewData = (LPVOID *) HeapReAlloc(m_hHeap, HEAP_ZERO_MEMORY, m_pData, nNewMax * sizeof(*m_pData));

        if (NULL == pNewData)
        {
            return FALSE;
        }

        ASSERT(nNewSize > m_nSize);

        m_pData = pNewData;
        m_nSize = nNewSize;
        m_nMaxSize = nNewMax;
    }

    return TRUE;
}

BOOL CPtrArray::FreeExtra()
{

    if (m_nSize != m_nMaxSize)
    {
        //
        // shrink to desired size
        //
        void** pNewData = NULL;
        if (m_nSize != 0)
        {
            pNewData = (void**) HeapAlloc(m_hHeap, 0, m_nSize * sizeof(*m_pData));
            if (NULL == pNewData)
            {
                return FALSE;
            }

            //
            // copy new data from old
            //

            CopyMemory(pNewData, m_pData, m_nSize * sizeof(*m_pData));
        }

        //
        // get rid of old stuff (note: no destructors called)
        //

        HeapFree(m_hHeap, 0, m_pData);
        m_pData = pNewData;
        m_nMaxSize = m_nSize;
    }

    return TRUE;
}


BOOL CPtrArray::InsertAt(int nIndex, void* newElement, int nCount)
{
    ASSERT(nIndex >= 0);    // will expand to meet need
    ASSERT(nCount > 0);     // zero or negative size not allowed

    if (nIndex >= m_nSize)
    {
        //
        // adding after the end of the array
        //

        if (FALSE == SetSize(nIndex + nCount))  // grow so nIndex is valid
        {
            return FALSE;
        }
    }
    else
    {
        //
        // inserting in the middle of the array
        //

        int nOldSize = m_nSize;

        if (FALSE == SetSize(m_nSize + nCount))  // grow it to new size
        {
            return FALSE;
        }

        //
        // shift old data up to fill gap
        //

        MoveMemory(&m_pData[nIndex+nCount], &m_pData[nIndex], (nOldSize-nIndex) * sizeof(*m_pData));

        // re-init slots we copied from

        ZeroMemory(&m_pData[nIndex], nCount * sizeof(*m_pData));

    }

    // insert new value in the gap

    ASSERT(nIndex + nCount <= m_nSize);

    while (nCount--)
    {
        m_pData[nIndex++] = newElement;
    }

    return TRUE;
}

BOOL CPtrArray::InsertAt(int nStartIndex, CPtrArray* pNewArray)
{
    ASSERT(nStartIndex >= 0);

    if (pNewArray->GetSize() > 0)
    {
        if (FALSE == InsertAt(nStartIndex, pNewArray->GetAt(0), pNewArray->GetSize()))
        {
            return FALSE;
        }

        for (int i = 0; i < pNewArray->GetSize(); i++)
        {
            SetAt(nStartIndex + i, pNewArray->GetAt(i));
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\taskmgr\userpage.cpp ===
//+-------------------------------------------------------------------------
//
//  TaskMan - NT TaskManager
//  Copyright (C) Microsoft
//
//  File:       userpage.cpp
//
//  History:    07-July-1999    BradG   Created
//
//--------------------------------------------------------------------------
#include "precomp.h"
#include "userdlgs.h"

#define IsActiveConsoleSession() (USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId)

CUserColSelectDlg ColSelectDlg;


//
// The following arrays map WTS sessions state codes into strings
//

#define     MAX_STAT_STRINGS    4
#define     FIRST_STAT_STRING   IDS_STAT_ACTIVE

LPTSTR      g_pszStatString[MAX_STAT_STRINGS];
const int   g_aWTSStateToString[] = {
    (IDS_STAT_ACTIVE - FIRST_STAT_STRING),          // WTSActive
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WTSConnected
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WTSConnectQuery
    (IDS_STAT_SHADOW - FIRST_STAT_STRING),          // WTSShadow
    (IDS_STAT_DISCONNECT - FIRST_STAT_STRING),      // WTSDisconnected
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // Waiting for client to connect
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is listening for connection
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is being reset
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING),         // WinStation is down due to error
    (IDS_STAT_UNKNOWN - FIRST_STAT_STRING)          // WinStation in initialization
};
    
/*++ class CUserInfo

Class Description:

    Represents the last known information about a running task

Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created
      Mar-23-00 a-skuzin Revised

--*/

class CUserInfo
{
public:

    DWORD           m_dwSessionId;
    BOOL            m_fShowDomainName;
    WCHAR           m_szUserName[USERNAME_LENGTH + 1];
    WCHAR           m_szDomainName[DOMAIN_LENGTH + 1];
    WCHAR           m_szClientName[CLIENTNAME_LENGTH + 1 ];
    LPTSTR          m_pszWinStaName;

    WTS_CONNECTSTATE_CLASS    m_wtsState;
    LARGE_INTEGER             m_uPassCount;

    //
    // This is a union of which attribute is dirty.  You can look at
    // or set any particular column's bit, or just inspect m_fDirty
    // to see if anyone at all is dirty.  Used to optimize listview
    // painting
    //

#pragma warning(disable:4201)       // Nameless struct or union
    union
    {
        DWORD                m_fDirty;
        struct 
        {
            DWORD            m_fDirty_COL_USERNAME       :1;
            DWORD            m_fDirty_COL_USERSESSIONID  :1;
            DWORD            m_fDirty_COL_SESSIONSTATUS  :1;
            DWORD            m_fDirty_COL_CLIENTNAME     :1;
            DWORD            m_fDirty_COL_WINSTANAME     :1;
        };                                                
    };
#pragma warning(default:4201)       // Nameless struct or union

    HRESULT SetData(
               LPTSTR                   lpszClientName,
               LPTSTR                   lpszWinStaName,
               WTS_CONNECTSTATE_CLASS   wtsState,
               BOOL                     fShowDomainName,
               LARGE_INTEGER            uPassCount,
               BOOL                     fUpdateOnly);

    CUserInfo()
    {
        ZeroMemory(this, sizeof(*this));
    }

    ~CUserInfo()
    {
        if (m_pszWinStaName)
        {
            LocalFree(m_pszWinStaName);
            m_pszWinStaName = NULL;
        }
    }

    INT Compare(CUserInfo * pOther);
private:
    //
    // Column ID on which to sort in the listview, and for
    // compares in general
    //
    static USERCOLUMNID m_iUserSortColumnID;
    static INT          m_iUserSortDirection;          // 1 = asc, -1 = desc
public:
    static void SetUserSortColumnID(USERCOLUMNID id)
    {
        m_iUserSortColumnID = id;
        m_iUserSortDirection = 1;
    }

    static USERCOLUMNID GetUserSortColumnID()
    {
        return m_iUserSortColumnID;
    }

    static void SwitchUserSortDirection()
    {
        m_iUserSortDirection *= -1;    
    }
};

USERCOLUMNID CUserInfo::m_iUserSortColumnID  = USR_COL_USERSNAME;
INT          CUserInfo::m_iUserSortDirection = 1;          // 1 = asc, -1 = desc

void Shadow(HWND, CUserInfo * );

/*++ class CUserInfo::Compare

Class Description:

    Compares this CUserInfo object to another, and returns its ranking
    based on the g_iUserSortColumnID field.

Arguments:

    pOther  - the CUserInfo object to compare this to

Return Value:

    < 0      - This CUserInfo is "less" than the other
      0      - Equal (Can't happen, since HWND is secondary sort)
    > 0      - This CUserInfo is "greater" than the other

Revision History:

      Nov-29-95 BradG  Created

--*/

INT CUserInfo::Compare(CUserInfo * pOther)
{
    INT iRet;

    switch (m_iUserSortColumnID)
    {
    case USR_COL_USERSNAME:
        if (g_Options.m_fShowDomainNames)
        {
            iRet = lstrcmpi(this->m_szDomainName, pOther->m_szDomainName);
            if (iRet != 0)
                break;
        }
        iRet = lstrcmpi(this->m_szUserName, pOther->m_szUserName);
        break;

    case USR_COL_USERSESSION_ID:
        iRet = Compare64(this->m_dwSessionId, pOther->m_dwSessionId);
        break;

    case USR_COL_SESSION_STATUS:
        Assert(g_pszStatString[g_aWTSStateToString[this->m_wtsState]]);
        Assert(g_pszStatString[g_aWTSStateToString[pOther->m_wtsState]]);

        iRet = lstrcmpi(
                   g_pszStatString[g_aWTSStateToString[this->m_wtsState]],
                   g_pszStatString[g_aWTSStateToString[pOther->m_wtsState]]
               );
        break;

    case USR_COL_WINSTA_NAME:
        iRet = lstrcmpi(
                   (this->m_pszWinStaName) ? this->m_pszWinStaName : TEXT(""),
                   (pOther->m_pszWinStaName) ? pOther->m_pszWinStaName : TEXT("")
               );
        break;

    case USR_COL_CLIENT_NAME:
        iRet = lstrcmpi(
                   (this->m_wtsState != WTSDisconnected) ? this->m_szClientName : TEXT(""),
                   (pOther->m_wtsState != WTSDisconnected) ? pOther->m_szClientName : TEXT("")
                );
        break;

    default:
        Assert(0 && "Invalid task sort column");
        iRet = 0;
        break;
    }

    return (iRet * m_iUserSortDirection);
}

/*++ InsertIntoSortedArray

Class Description:

    Sticks a CUserInfo ptr into the ptrarray supplied at the
    appropriate location based on the current sort column (which
    is used by the Compare member function)

Arguments:

    pArray      - The CPtrArray to add to
    pProc       - The CUserInfo object to add to the array

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-20-95 BradG  Created

--*/

BOOL InsertIntoSortedArray(CPtrArray * pArray, CUserInfo * pUser)
{
    INT cItems = pArray->GetSize();
    
    for (INT iIndex = 0; iIndex < cItems; iIndex++)
    {
        CUserInfo * pTmp = (CUserInfo *) pArray->GetAt(iIndex);

        if (pUser->Compare(pTmp) < 0)
        {
            return pArray->InsertAt(iIndex, pUser);
        }
    }

    return pArray->Add(pUser);
}

/*++ ResortUserArray

Function Description:

    Creates a new ptr array sorted in the current sort order based
    on the old array, and then replaces the old with the new

Arguments:

    ppArray     - The CPtrArray to resort

Return Value:

    TRUE if successful, FALSE if fails

Revision History:

      Nov-21-95 BradG  Created

--*/

BOOL ResortUserArray(CPtrArray ** ppArray)
{
    // Create a new array which will be sorted in the new 
    // order and used to replace the existing array

    CPtrArray * pNew = new CPtrArray(GetProcessHeap());
    if (NULL == pNew)
    {
        return FALSE;
    }

    // Insert each of the existing items in the old array into
    // the new array in the correct spot

    INT cItems = (*ppArray)->GetSize();
    for (int i = 0; i < cItems; i++)
    {
        CUserInfo * pItem = (CUserInfo *) (*ppArray)->GetAt(i);
        if (FALSE == InsertIntoSortedArray(pNew, pItem))
        {
            delete pNew;
            return FALSE;
        }
    }

    // Kill off the old array, replace it with the new

    delete (*ppArray);
    (*ppArray) = pNew;
    return TRUE;
}



//*****************************************************************************
//class CUserPage
//*****************************************************************************

//
//
//
CUserPage::~CUserPage()
{
    RemoveAllUsers();
    delete m_pUserArray;
}

//
//
//
void CUserPage::RemoveAllUsers()
{
    if (m_pUserArray)
    {
        INT c = m_pUserArray->GetSize();

        while (c)
        {
            delete (CUserInfo *) (m_pUserArray->GetAt(c - 1));
            c--;
        }
    }
}

/*++ CUserPage::UpdateUserListview

Class Description:

    Walks the listview and checks to see if each line in the
    listview matches the corresponding entry in our process
    array.  Those which differe by HWND are replaced, and those
    that need updating are updated.

    Items are also added and removed to/from the tail of the
    listview as required.
    
Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 BradG  Created

--*/

HRESULT CUserPage::UpdateUserListview()
{
    HWND hListView = GetDlgItem(m_hPage, IDC_USERLIST);

    //
    // Stop repaints while we party on the listview
    //

    SendMessage(hListView, WM_SETREDRAW, FALSE, 0);

    INT cListViewItems = ListView_GetItemCount(hListView);
    INT CUserArrayItems = m_pUserArray->GetSize();
    
    //
    // Walk the existing lines in the listview and replace/update
    // them as needed
    //
    for (INT iCurrent = 0; 
         iCurrent < cListViewItems && iCurrent < CUserArrayItems; 
         iCurrent++)
    {
        LV_ITEM lvitem = { 0 };
        WCHAR   szDisplayName[ USERNAME_LENGTH + 1 + DOMAIN_LENGTH + 1 ];

        lvitem.mask = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem = iCurrent;

        if (FALSE == ListView_GetItem(hListView, &lvitem))
        {
            SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
            return E_FAIL;
        }

        CUserInfo * pTmp = (CUserInfo *) lvitem.lParam;
        CUserInfo * pUser = (CUserInfo *) m_pUserArray->GetAt(iCurrent);        

        if (pTmp != pUser || pUser->m_fDirty)
        {
            // If the objects aren't the same, we need to replace this line

            if (g_Options.m_fShowDomainNames)
            {
                //  UI only - don't care if it gets truncated.
                StringCchCopy( szDisplayName, ARRAYSIZE(szDisplayName), pUser->m_szDomainName );
                StringCchCat( szDisplayName, ARRAYSIZE(szDisplayName), L"\\" );
            }
            else
            {
                szDisplayName[ 0 ] = L'\0';
            }

            //  UI only - don't care if it gets truncated.
            StringCchCat( szDisplayName, ARRAYSIZE(szDisplayName), pUser->m_szUserName );

            lvitem.pszText = szDisplayName;
            lvitem.lParam  = (LPARAM) pUser;

            if (g_dwMySessionId == pUser->m_dwSessionId)
            {
                lvitem.iImage  = m_iCurrentUserIcon;
            }
            else
            {
                lvitem.iImage  = m_iUserIcon;
            }
    
            ListView_SetItem(hListView, &lvitem);
            ListView_RedrawItems(hListView, iCurrent, iCurrent);
            pUser->m_fDirty = 0;
        }
    }

    // 
    // We've either run out of listview items or run out of User array
    // entries, so remove/add to the listview as appropriate
    //

    while (iCurrent < cListViewItems)
    {
        // Extra items in the listview (processes gone away), so remove them

        ListView_DeleteItem(hListView, iCurrent);
        cListViewItems--;
    }

    while (iCurrent < CUserArrayItems)
    {
        // Need to add new items to the listview (new user appeared)

        CUserInfo * pUser = (CUserInfo *)m_pUserArray->GetAt(iCurrent);
        LV_ITEM lvitem  = { 0 };
        WCHAR   szDisplayName[ USERNAME_LENGTH + 1 + DOMAIN_LENGTH + 1 ];

        lvitem.mask     = LVIF_PARAM | LVIF_TEXT | LVIF_IMAGE;
        lvitem.iItem    = iCurrent;
        lvitem.lParam   = (LPARAM) pUser;

        if (g_Options.m_fShowDomainNames)
        {
            //  UI only - don't care if it gets truncated.
            StringCchCopy( szDisplayName, ARRAYSIZE(szDisplayName), pUser->m_szDomainName );
            StringCchCat( szDisplayName, ARRAYSIZE(szDisplayName), L"\\" );
        }
        else
        {
            szDisplayName[0] = L'\0';
        }

        //  UI only - don't care if it gets truncated.
        StringCchCat( szDisplayName, ARRAYSIZE(szDisplayName), pUser->m_szUserName );

        lvitem.pszText  = szDisplayName;

        if (g_dwMySessionId == pUser->m_dwSessionId)
        {
            lvitem.iImage = m_iCurrentUserIcon;
        }
        else
        {
            lvitem.iImage = m_iUserIcon;
        }

        // The first item added (actually, every 0 to 1 count transition) gets
        // selected and focused

        if (iCurrent == 0)
        {
            lvitem.state = LVIS_SELECTED | LVIS_FOCUSED;
            lvitem.stateMask = lvitem.state;
            lvitem.mask |= LVIF_STATE;
        }
    
        ListView_InsertItem(hListView, &lvitem);
        pUser->m_fDirty = 0;
        iCurrent++;        
    }    

    //
    // Let the listview paint again
    //

    SendMessage(hListView, WM_SETREDRAW, TRUE, 0);
    return S_OK;
}


/*++ CUserPage::GetSelectedUsers

Routine Description:

    Returns a CPtrArray of the selected tasks
    
Arguments:

Return Value:

    CPtrArray on success, NULL on failure

Revision History:

      Dec-01-95 BradG  Created

--*/

CPtrArray * CUserPage::GetSelectedUsers()
{
    BOOL fSuccess = TRUE;

    //
    // Get the count of selected items
    //

    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);
    INT cItems = ListView_GetSelectedCount(hUserList);
    if (0 == cItems)
    {
        return NULL;
    }

    //
    // Create a CPtrArray to hold the task items
    //

    CPtrArray * pArray = new CPtrArray(GetProcessHeap());
    if (NULL == pArray)
    {
        return NULL;
    }

    INT iLast = -1;
    for (INT i = 0; i < cItems; i++)
    {
        //
        // Get the Nth selected item
        // 

        INT iItem = ListView_GetNextItem(hUserList, iLast, LVNI_SELECTED);

        if (-1 == iItem)
        {
            fSuccess = FALSE;
            break;
        }

        iLast = iItem;

        //
        // Pull the item from the listview and add it to the selected array
        //

        LV_ITEM lvitem = { LVIF_PARAM };
        lvitem.iItem = iItem;
    
        if (ListView_GetItem(hUserList, &lvitem))
        {
            LPVOID pUser = (LPVOID) (lvitem.lParam);
            if (FALSE == pArray->Add(pUser))
            {
                fSuccess = FALSE;
                break;
            }
        }
        else
        {
            fSuccess = FALSE;
            break;
        }
    }

    //
    // Any errors, clean up the array and bail.  We don't release the
    // tasks in the array, since they are owned by the listview.
    //

    if (FALSE == fSuccess && NULL != pArray)
    {
        delete pArray;
        return NULL;
    }

    return pArray;
}


/*++ CProcPage::HandleUserListContextMenu

Routine Description:

    Handles right-clicks (context menu) in the task list
    
Arguments:

    xPos, yPos  - coords of where the click occurred

Return Value:

Revision History:

      Dec-01-95 BradG  Created

--*/

void CUserPage::HandleUserListContextMenu(INT xPos, INT yPos)
{
    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);

    CPtrArray * pArray = GetSelectedUsers();

    if (pArray)
    {
        // If non-mouse-based context menu, use the currently selected
        // item as the coords

        if (0xFFFF == LOWORD(xPos) && 0xFFFF == LOWORD(yPos))
        {
            int iSel = ListView_GetNextItem(hUserList, -1, LVNI_SELECTED);
            RECT rcItem;
            ListView_GetItemRect(hUserList, iSel, &rcItem, LVIR_ICON);
            MapWindowRect(hUserList, NULL, &rcItem);
            xPos = rcItem.right;
            yPos = rcItem.bottom;
        }

        HMENU hPopup = LoadPopupMenu(g_hInstance, IDR_USER_CONTEXT);

        if (hPopup)
        {
            SetMenuDefaultItem(hPopup, IDM_SENDMESSAGE, FALSE);
            
            //
            //If our current session is a console session, 
            //we cannot do remote control
            //
            if(IsActiveConsoleSession())
            {
                EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // If multiple-selection, disable the items that require single
            // selections to make sense
            //

            if (pArray->GetSize() > 1)
            {
                EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                EnableMenuItem(hPopup, IDM_CONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
            }

            //
            // See if we have our own session selected
            //
            for (int i = 0; i < pArray->GetSize(); i++)
            {
                CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
                if (g_dwMySessionId == pUser->m_dwSessionId)
                {
                    //
                    // The current session is in the list
                    //
                    EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    EnableMenuItem(hPopup, IDM_CONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);

                    if (SHRestricted(REST_NODISCONNECT))
                    {
                        EnableMenuItem(hPopup, IDM_DISCONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    }

                    if (pArray->GetSize() == 1)
                    {
                        //
                        // My session is the only one selected
                        //
                        EnableMenuItem(hPopup, IDM_SENDMESSAGE, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    }
                }

                if (pUser->m_wtsState == WTSDisconnected)
                {
                    // EnableMenuItem(hPopup, IDM_REMOTECONTROL, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                    EnableMenuItem(hPopup, IDM_DISCONNECT, MF_GRAYED | MF_DISABLED | MF_BYCOMMAND);
                }

            }

            Pause();
            g_fInPopup = TRUE;
            TrackPopupMenuEx(hPopup, 0, xPos, yPos, m_hPage, NULL);
            g_fInPopup = FALSE;

            // Note that we don't "unpause" until one of the menu commands (incl CANCEL) is
            // selected or the menu is dismissed
        
            DestroyMenu(hPopup);
        }

        delete pArray;
    }
    else
    {
        // Nothing is selected
    }
}


/*++ CUserPage::UpdateUIState

Routine Description:

    Updates the enabled/disabled states, etc., of the task UI
    
Arguments:

Return Value:

Revision History:

      Dec-04-95 BradG  Created

--*/

// Controls which are enabled only for any selection

static const UINT g_aUserSingleIDs[] =
{
    IDM_DISCONNECT,
    IDM_LOGOFF,
    IDM_SENDMESSAGE
};

void CUserPage::UpdateUIState()
{
    INT i;

    //
    // Set the state for controls which require a selection (1 or more items)
    //

    for (i = 0; i < ARRAYSIZE(g_aUserSingleIDs); i++)
    {
        EnableWindow(GetDlgItem(m_hPage, g_aUserSingleIDs[i]), m_cSelected > 0);
    }    

    CPtrArray * pArray = GetSelectedUsers();

    if (pArray)
    {
        //
        // See if we have our own session selected
        //

        for (int i = 0; i < pArray->GetSize(); i++)
        {
            CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
            if (g_dwMySessionId == pUser->m_dwSessionId)
            {
                if (SHRestricted(REST_NODISCONNECT))
                {
                    EnableWindow(GetDlgItem(m_hPage, IDM_DISCONNECT), FALSE);
                }

                if (pArray->GetSize() == 1)
                {
                    //
                    // My session is the only one selected
                    //
                    EnableWindow(GetDlgItem(m_hPage, IDM_SENDMESSAGE), FALSE);
                }
            }

            if (pUser->m_wtsState == WTSDisconnected)
            {
                EnableWindow(GetDlgItem(m_hPage, IDM_DISCONNECT), FALSE);
            }

        }

        delete pArray;
    }

}


/*++ CUserPage::HandleUserPageNotify

Routine Description:

    Processes WM_NOTIFY messages received by the taskpage dialog
    
Arguments:

    hWnd    - Control that generated the WM_NOTIFY
    pnmhdr  - Ptr to the NMHDR notification stucture

Return Value:

    BOOL "did we handle it" code

Revision History:

      Nov-29-95 BradG  Created

--*/

INT CUserPage::HandleUserPageNotify(LPNMHDR pnmhdr)
{
    switch(pnmhdr->code)
    {
    case LVN_ITEMCHANGED:
        {
            //
            // If the (selection) state of an item is changing, see if
            // the count has changed, and if so, update the UI
            //

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            if (pnmv->uChanged & LVIF_STATE)
            {
                UINT cSelected = ListView_GetSelectedCount(GetDlgItem(m_hPage, IDC_USERLIST));
                if (cSelected != m_cSelected)
                {
                    m_cSelected = cSelected;
                    UpdateUIState();
                }
            }
        }
        break;

    case LVN_COLUMNCLICK:
        {
            // User clicked a header control, so set the sort column.  If its the
            // same as the current sort column, just invert the sort direction in
            // the column.  Then resort the task array

            const NM_LISTVIEW * pnmv = (const NM_LISTVIEW *) pnmhdr;
            LV_COLUMN lvcolumn;

            lvcolumn.mask = LVCF_SUBITEM;

            if(!ListView_GetColumn(GetDlgItem(m_hPage, IDC_USERLIST), pnmv->iSubItem, &lvcolumn))
            {
                break;
            }

            if (CUserInfo::GetUserSortColumnID() == lvcolumn.iSubItem)
            {
                CUserInfo::SwitchUserSortDirection();
            }
            else
            {
                CUserInfo::SetUserSortColumnID((USERCOLUMNID)lvcolumn.iSubItem);
            }

            ResortUserArray(&m_pUserArray);
            TimerEvent();
        }
        break;

    case LVN_GETDISPINFO:
        {
            LV_ITEM * plvitem = &(((LV_DISPINFO *) pnmhdr)->item);
        
            //
            // Listview needs a text string
            //

            if (plvitem->mask & LVIF_TEXT)
            {
                LV_COLUMN lvcolumn;
                lvcolumn.mask = LVCF_SUBITEM;

                if(!ListView_GetColumn(GetDlgItem(m_hPage, IDC_USERLIST),
                                plvitem->iSubItem, &lvcolumn))
                {
                    break;
                }

                USERCOLUMNID columnid = (USERCOLUMNID) lvcolumn.iSubItem;
                const CUserInfo  * pUserInfo   = (const CUserInfo *)   plvitem->lParam;

                switch(columnid)
                {
                case USR_COL_USERSNAME:
                    plvitem->mask |= LVIF_DI_SETITEM;

                    if (g_Options.m_fShowDomainNames)
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy(plvitem->pszText, plvitem->cchTextMax, pUserInfo->m_szDomainName );
                        StringCchCat(plvitem->pszText, plvitem->cchTextMax, L"\\" );
                        StringCchCat(plvitem->pszText, plvitem->cchTextMax, pUserInfo->m_szUserName );
                    }
                    else
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy(plvitem->pszText, plvitem->cchTextMax, pUserInfo->m_szUserName );
                    }                    
                    break;

                case USR_COL_USERSESSION_ID:
                    //  UI only - don't care if it gets truncated
                    StringCchPrintf(plvitem->pszText, plvitem->cchTextMax, L"%d", (ULONG) (pUserInfo->m_dwSessionId));
                    break;

                case USR_COL_SESSION_STATUS:
                    if ( NULL != g_pszStatString[ g_aWTSStateToString[ pUserInfo->m_wtsState ] ] )
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText
                                     , plvitem->cchTextMax
                                     , g_pszStatString[ g_aWTSStateToString[ pUserInfo->m_wtsState ] ] 
                                     );
                    }
                    else
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, L"" );
                    }
                    break;

                case USR_COL_CLIENT_NAME:
                    if ( pUserInfo->m_wtsState != WTSDisconnected )
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pUserInfo->m_szClientName );
                    }
                    else
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, L"" );
                    }
                    break;

                case USR_COL_WINSTA_NAME:
                    if ( NULL != pUserInfo->m_pszWinStaName )
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, pUserInfo->m_pszWinStaName );
                    }
                    else
                    {
                        //  UI only - don't care if it gets truncated
                        StringCchCopy( plvitem->pszText, plvitem->cchTextMax, L"" );
                    }
                    break;

                default:
                    Assert( 0 && "Unknown listview subitem" );
                    break;

                 } // end switch(columnid)

            } // end LVIF_TEXT case

        } // end LVN_GETDISPINFO case
        break;
    
    } // end switch(pnmhdr->code)

    return 1;
}

   
/*++ CUserPage::TimerEvent

Routine Description:

    Called by main app when the update time fires.  Walks every window
    in the system (on every desktop, in every windowstation) and adds
    or updates it in the task array, then removes any stale processes,
    and filters the results into the listview
    
Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created

--*/

VOID CUserPage::TimerEvent()
{
    //
    // If this page is paused (ie: it has a context menu up, etc), we do
    // nothing
    //

    if (m_fPaused)
    {
        return;
    }

    static LARGE_INTEGER uPassCount = {0, 0};

    //
    // TODO:    BRADG
    //          This should be done on a separate thread
    //

    PWTS_SESSION_INFO   pSession;
    DWORD               nSessions;
    DWORD               dwSize;
    LPTSTR              pszClientName;
    LPTSTR              pszUserName;
    LPTSTR              pszDomainName;
    HRESULT             hr;
    BOOL                b;
    BOOL                bDelete;
    INT                 i;
    DWORD               j;
    CUserInfo           *pNewUser;

    b = WTSEnumerateSessions(
                   WTS_CURRENT_SERVER_HANDLE,
                   0,
                   1,
                   &pSession,
                   &nSessions);
    if ( b )
    {
        i = 0;
        while (i < m_pUserArray->GetSize())
        {
            CUserInfo * pUserInfo = (CUserInfo *)(m_pUserArray->GetAt(i));
            ASSERT(pUserInfo);

            //
            // See if this item has a matching session.  If so, update it.
            //

            bDelete = FALSE;

            for (j = 0; j < nSessions; j++)
            {
                if (pUserInfo->m_dwSessionId == pSession[j].SessionId)
                {
                    break;
                }
            }

            if (j < nSessions)
            {
                //
                // This session is still alive.  See what it's doing
                //

                switch( pSession[j].State )
                {
                case WTSActive:
                case WTSDisconnected:
                case WTSShadow:
                    //
                    //If we log off user from disconnected session 0
                    //it does not change its state but remains disconnected
                    //we must not display disconnected session 0 if nobody 
                    //is logged on to it.
                    //

                    b = WTSQuerySessionInformation(
                               WTS_CURRENT_SERVER_HANDLE,
                               pSession[j].SessionId,
                               WTSUserName,
                               &pszUserName,
                               &dwSize
                            );

                    if (!b || pszUserName == NULL)
                    {
                        bDelete = TRUE;
                        pSession[j].State = WTSIdle; //see "MAJOR HACK" below
                        break;
                    }
                    
                    //
                    //pszUserName[0] == 0 - means that nobody is logged on to session 0.
                    //It might also happen, though very unlikely, that session number got
                    //reused by some other user while taskmgr was busy doing something.
                    //In this case we'll treat this session as a new one
                    //

                    if(lstrcmp(pUserInfo->m_szUserName,pszUserName))
                    {
                        bDelete = TRUE;
                        if(pszUserName[0] == 0)
                        {
                            pSession[j].State = WTSIdle; //see "MAJOR HACK" below
                        }
                    }
                    
                    WTSFreeMemory(pszUserName);
                    pszUserName = NULL;
                    
                    if(bDelete)
                    {
                        break;
                    }
                    
                    //
                    // It's still doing something interesting, so go and
                    // update the item's status
                    //

                    pszClientName = NULL;

                    b = WTSQuerySessionInformation(
                                   WTS_CURRENT_SERVER_HANDLE,
                                   pSession[j].SessionId,
                                   WTSClientName,
                                   &pszClientName,
                                   &dwSize
                        );

                    hr = pUserInfo->SetData(
                                        (pszClientName == NULL) ? TEXT("") : pszClientName,
                                        pSession[j].pWinStationName,
                                        pSession[j].State,
                                        g_Options.m_fShowDomainNames,
                                        uPassCount,
                                        TRUE
                                    );
                    if (pszClientName)
                    {
                        // Free the ClientName buffer
                        WTSFreeMemory(pszClientName);
                        pszClientName = NULL;
                    }

                    //
                    // MAJOR HACK -- Set the State to WTSIdle so we skip it
                    //               when we check for new sessions.
                    //

                    pSession[j].State = WTSIdle;

                    break;

                default:
                    //
                    // It's no longer in a state we care about, delete it.
                    //
                    bDelete = TRUE;
                    break;
                }
            }
            else
            {
                //
                // The list item doesn't have any matching information, so this means
                // that the user probably has logged off.  Delete it.
                //

                bDelete = TRUE;
            }

            if (bDelete)
            {
                //
                // This item needs to be deleted from the list.
                //

                delete pUserInfo;
                m_pUserArray->RemoveAt(i, 1);

                //
                // Loop back without incrementing i.
                //
                continue;
            }

            i++;
        }

        //
        // Now that we updated all entries in the m_pUserArray, we need double
        // check the session data to see if we have any new sessions.  See the
        // MAJOR HACK comment above.  We change the state of all updated
        // sessions to WTSIdle so we skip them in the loop below.
        //

        for (j = 0; j < nSessions; j++)
        {
            switch( pSession[j].State )
            {
            case WTSActive:
            case WTSDisconnected:
            case WTSShadow:
                //
                // OK, we've discovered a NEW session that's in a
                // state that we care about.  Add it to the list.
                //

                pNewUser = new CUserInfo;
                if (pNewUser == NULL)
                {
                    // Not much we can do here.
                    break;
                }

                pNewUser->m_dwSessionId = pSession[j].SessionId;

                // 
                //  TODO:   BRADG
                //          See about writing this as a loop
                //

                //
                // Query all the cool info about the session.
                //

                b = WTSQuerySessionInformation(
                               WTS_CURRENT_SERVER_HANDLE,
                               pSession[j].SessionId,
                               WTSClientName,
                               &pszClientName,
                               &dwSize
                    );
                if (!b)
                {
                    delete pNewUser;
                    break;
                }

                hr = pNewUser->SetData(
                                   (pszClientName == NULL) ? TEXT("") : pszClientName,
                                   pSession[j].pWinStationName,
                                   pSession[j].State,
                                   g_Options.m_fShowDomainNames,
                                   uPassCount,
                                   FALSE
                               );
                if (pszClientName != NULL)
                {
                    WTSFreeMemory(pszClientName);
                    pszClientName = NULL;
                }

                if (FAILED(hr))
                {
                    delete pNewUser;
                    break;
                }

                
                b = WTSQuerySessionInformation(
                               WTS_CURRENT_SERVER_HANDLE,
                               pSession[j].SessionId,
                               WTSUserName,
                               &pszUserName,
                               &dwSize
                    );
                if (!b || pszUserName == NULL)
                {
                    delete pNewUser;
                    break;
                }
                
                //
                //This is case of disconnected session 0 
                //when nobody is logged on.
                //
                if(pszUserName[0] == 0)
                {
                    WTSFreeMemory(pszUserName);
                    pszUserName = NULL;
                    delete pNewUser;
                    break;
                }

                StringCchCopy( pNewUser->m_szUserName, ARRAYSIZE(pNewUser->m_szUserName), pszUserName );
                WTSFreeMemory(pszUserName);
                pszUserName = NULL;

                b = WTSQuerySessionInformation(
                               WTS_CURRENT_SERVER_HANDLE,
                               pSession[j].SessionId,
                               WTSDomainName,
                               &pszDomainName,
                               &dwSize
                    );
                if (!b || pszDomainName == NULL)
                {
                    delete pNewUser;
                    break;
                }
                StringCchCopy( pNewUser->m_szDomainName, ARRAYSIZE(pNewUser->m_szDomainName), pszDomainName );
                WTSFreeMemory(pszDomainName);
                pszDomainName = NULL;

                pNewUser->m_fDirty = 1;

                // All went well, so add it to the array

                if (!(m_pUserArray->Add( (LPVOID) pNewUser)))
                {
                    delete pNewUser;
                }

                break;

            default:
                // Don't care about this one.
                break;
            }
        }

        //
        // Free up the memory allocated on the WTSEnumerateSessions call
        //

        WTSFreeMemory( pSession );
        pSession = NULL;
    }
            
    UpdateUserListview();

    uPassCount.QuadPart++;
}


/*++ class CUserInfo::SetData

Class Description:

    Updates (or initializes) the info about a running task

Arguments:

    uPassCount- Current passcount, used to timestamp the last update of 
        this object
    fUpdate   - only worry about information that can change during a
        task's lifetime

Return Value:

    HRESULT

Revision History:

      Nov-16-95 BradG  Created

--*/

HRESULT CUserInfo::SetData(
               LPTSTR                   lpszClientName,
               LPTSTR                   lpszWinStaName,
               WTS_CONNECTSTATE_CLASS   wtsState,
               BOOL                     fShowDomainName,
               LARGE_INTEGER            uPassCount,
               BOOL                     fUpdateOnly)
{
    HRESULT hr = S_OK;

    m_uPassCount.QuadPart = uPassCount.QuadPart;

    //
    // For each of the fields, we check to see if anything has changed, and if
    // so, we mark that particular column as having changed, and update the value.
    // This allows me to opimize which fields of the listview to repaint, since
    // repainting an entire listview column causes flicker and looks bad in
    // general
    //

    //
    // WinStation
    //

    if (!fUpdateOnly || lstrcmp(m_pszWinStaName, lpszWinStaName))
    {
        LPTSTR   pszOld = m_pszWinStaName;
        DWORD    cchLen = lstrlen(lpszWinStaName) + 1;

        m_pszWinStaName = (LPTSTR) LocalAlloc( 0, cchLen * sizeof(*m_pszWinStaName) );
        if (NULL == m_pszWinStaName)
        {
            m_pszWinStaName = pszOld;
            hr = E_OUTOFMEMORY;
        }
        else
        {
            //  UI only - don't care if it gets truncated
            StringCchCopy( m_pszWinStaName, cchLen, lpszWinStaName );
            m_fDirty_COL_WINSTANAME = TRUE;
            if ( NULL != pszOld )
            {
                LocalFree(pszOld);
            }
        }
    }

    //
    // Client Name
    //

    if ( NULL != lpszClientName && lstrcmp(m_szClientName, lpszClientName) )
    {
        //  UI only - don't care if it gets truncated
        StringCchCopy(m_szClientName, ARRAYSIZE(m_szClientName), lpszClientName);
        m_fDirty_COL_CLIENTNAME = TRUE;
    }

    //
    // Session Status
    //

    if (wtsState != m_wtsState) {
        m_wtsState = wtsState;
        m_fDirty_COL_SESSIONSTATUS = TRUE;
    }

    //
    // Domain Name Status
    //

    if (fShowDomainName != m_fShowDomainName)
    {
        m_fShowDomainName = fShowDomainName;
        m_fDirty_COL_USERNAME = TRUE;
    }

    return hr;
}


/*++ CUserPage::SizeUserPage

Routine Description:

    Sizes its children based on the size of the
    tab control on which it appears.  

Arguments:

Return Value:

Revision History:

      Nov-29-95 BradG  Created

--*/

static const INT aUserControls[] =
{
    IDM_DISCONNECT,
    IDM_LOGOFF,
    IDM_SENDMESSAGE
};

void CUserPage::SizeUserPage()
{
    //
    // Get the coords of the outer dialog
    //

    RECT rcParent;
    GetClientRect(m_hPage, &rcParent);

    HDWP hdwp = BeginDeferWindowPos( 1 + ARRAYSIZE(aUserControls) );

    //
    // Calc the deltas in the x and y positions that we need to
    // move each of the child controls
    //

    RECT rcMaster;
    HWND hwndMaster = GetDlgItem(m_hPage, IDM_SENDMESSAGE);

    GetWindowRect(hwndMaster, &rcMaster);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcMaster, 2);

    INT dx = ((rcParent.right - g_DefSpacing * 2) - rcMaster.right);
    INT dy = ((rcParent.bottom - g_DefSpacing * 2) - rcMaster.bottom);

    //
    // Size the listbox
    //

    HWND hwndListbox = GetDlgItem(m_hPage, IDC_USERLIST);
    RECT rcListbox;

    GetWindowRect(hwndListbox, &rcListbox);
    MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcListbox, 2);

    INT lbX = rcMaster.right - rcListbox.left + dx;
    INT lbY = rcMaster.top - rcListbox.top + dy - g_DefSpacing;

    DeferWindowPos(hdwp, hwndListbox, NULL,
            0, 0,
            lbX, 
            lbY,
            SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

    //
    // Move each of the child controls by the above delta
    //

    for (int i = 0; i < ARRAYSIZE(aUserControls); i++)
    {
        HWND hwndCtrl = GetDlgItem(m_hPage, aUserControls[i]);
        RECT rcCtrl;

        GetWindowRect(hwndCtrl, &rcCtrl);
        MapWindowPoints(HWND_DESKTOP, m_hPage, (LPPOINT) &rcCtrl, 2);

        DeferWindowPos(hdwp, hwndCtrl, NULL, 
                         rcCtrl.left + dx, 
                         rcCtrl.top + dy,
                         0, 0,
                         SWP_NOSIZE | SWP_NOZORDER | SWP_NOACTIVATE);
    }

    EndDeferWindowPos(hdwp);
}

/*++ CUserPage::HandleWMCOMMAND

Routine Description:

    Handles WM_COMMANDS received at the main page dialog
    
Arguments:

    id - Command id of command received

Return Value:

Revision History:

      Dec-01-95 BradG  Created

--*/

void CUserPage::HandleWMCOMMAND(INT id)
{
    int     iResult;
    INT     i;
    INT     iFinalOne = -1;
    BOOL    bFinalOne = FALSE;
    BOOL    bNeedToRefresh = FALSE;
    DWORD   dwSize;
    LPTSTR  psz;
    WCHAR   szCaption[ MAX_PATH ];
    WCHAR   szText1[ MAX_PATH * 2 ];
    WCHAR   szText2[ MAX_PATH * 2 ];

    LoadString(g_hInstance, IDS_APPTITLE, szCaption, MAX_PATH);

    CPtrArray * pArray = GetSelectedUsers();

    if (!pArray)
    {
        //Assert( 0 && "WM_COMMAND but nothing selected" );
        goto done;
    }

    if (id == IDM_SENDMESSAGE)
    {
        
        CSendMessageDlg SMDlg;
        if(SMDlg.DoDialog(m_hwndTabs)!=IDOK)
        {
            goto done;
        }
        
        //  UI - only - don't care if it gets truncated
        StringCchCopy( szText1, ARRAYSIZE(szText1), SMDlg.GetTitle() );
        StringCchCopy( szText2, ARRAYSIZE(szText2), SMDlg.GetMessage() );
    }
    else if (id == IDM_LOGOFF || id == IDM_DISCONNECT)
    {
        //
        // Verify this is what the user wants done
        //
        LoadString(
            g_hInstance,
            (id == IDM_LOGOFF) ? IDS_WARN_LOGOFF : IDS_WARN_DISCONNECT,
            szText1,
            ARRAYSIZE(szText1)
        );

        iResult = MessageBox(m_hwndTabs, szText1, szCaption, MB_YESNO | MB_DEFBUTTON2 | MB_ICONEXCLAMATION);
        if (iResult == IDNO)
            goto done;
    }

    BOOL    b;

    for( i = 0; i < pArray->GetSize(); i++ )
    {
finalretry:
        CUserInfo * pUser = (CUserInfo *) pArray->GetAt(i);
        if (pUser == NULL)
        {
            Assert(0);
            if (bFinalOne)
            {
                break;      // Bail out, nothing left to process
            }
            else
            {
                continue;   // try the next one
            }
        }

retry:
        b = TRUE;

        switch(id)
        {  
        case IDM_SENDMESSAGE:
            b = WTSSendMessage(
                           WTS_CURRENT_SERVER_HANDLE,
                           pUser->m_dwSessionId,
                           szText1,
                           lstrlen(szText1) * sizeof(WCHAR),
                           szText2,
                           lstrlen(szText2) * sizeof(WCHAR),
                           MB_OK | MB_TOPMOST | MB_ICONINFORMATION,
                           0,         // ignored
                           &dwSize,   // ignored, but it won't accept a NULL
                           FALSE
                );
            break;
        
        case IDM_DISCONNECT:
            if (g_dwMySessionId == pUser->m_dwSessionId && !bFinalOne)
            {
                // I don't want to kill of myself before everything else is complete,
                // so I'll set a flag and skip myself for now.
                iFinalOne = i;
                continue;
            }
            b = WTSDisconnectSession(
                           WTS_CURRENT_SERVER_HANDLE,
                           pUser->m_dwSessionId,
                           FALSE
                );
            if (b)
            {
                bNeedToRefresh = TRUE;
            }
            break;

        case IDM_LOGOFF:
            if (g_dwMySessionId == pUser->m_dwSessionId && !bFinalOne)
            {
                // I don't want to kill of myself before everything else is complete,
                // so I'll set a flag and skip myself for now.
                iFinalOne = i;
                continue;
            }
            b = WTSLogoffSession(
                           WTS_CURRENT_SERVER_HANDLE,
                           pUser->m_dwSessionId,
                           FALSE
                );
            if (b)
            {
                bNeedToRefresh = TRUE;
            }
            break;

        case IDM_CONNECT:
            {
                WCHAR szPassword[ PASSWORD_LENGTH + 1 ];
                BOOL bFirstTime = TRUE;
                HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;

                // Start the connect loop with null password to try first.
                szPassword[0] = '\0';
                for( ;; )
                {
                    DWORD  Error;
                    BOOL   fRet;
                    DWORD  cch;
                    LPWSTR pszErrString;

                    fRet = WinStationConnect(hServer, pUser->m_dwSessionId, LOGONID_CURRENT, szPassword, TRUE);
                    if( fRet )
                        break;  // success - break out of loop

                    Error = GetLastError();
                    
                    // If a 'logon failure' brought us here, issue password dialog.
                    if(Error == ERROR_LOGON_FAILURE)
                    {
                        UINT ids = ( bFirstTime ? IDS_PWDDLG_USER : IDS_PWDDLG_USER2 );
                        CConnectPasswordDlg CPDlg( ids );
                            
                        bFirstTime = FALSE;
                        
                        if (CPDlg.DoDialog(m_hwndTabs) != IDOK)
                        {
                            break;  // user CANCEL: break connect loop
                        }
                        else
                        {
                            StringCchCopy( szPassword, ARRAYSIZE(szPassword), CPDlg.GetPassword( ) );    
                            continue;   // try again with new password.
                        }
                    }

                    //
                    //  Unhandled error occured. Pop up a message box and then bail the loop.
                    //
                            
                    LoadString(g_hInstance, IDS_ERR_CONNECT, szText2, MAX_PATH);

                    //  Retrieve system string for error.
                    cch = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER
                                         | FORMAT_MESSAGE_FROM_SYSTEM
                                         | FORMAT_MESSAGE_IGNORE_INSERTS,
                                         NULL,
                                         Error,
                                         0,
                                         (LPWSTR) &pszErrString,
                                         0,
                                         NULL
                                         );
                    if ( cch == 0 )
                    {
                        pszErrString = L'\0';
                    }
                    
                    StringCchPrintf( szText1, ARRAYSIZE(szText1), szText2, Error, pszErrString );
                            
                    MessageBox( m_hwndTabs, szText1, szCaption, MB_OK | MB_ICONEXCLAMATION );

                    if ( cch != 0 )
                    {
                        LocalFree( pszErrString );
                    }
                            
                    break;  // exit 
                }
                
                //
                //  Destroy the password.
                //
                ZeroMemory( szPassword, sizeof(szPassword) );
            }
            break;

        case IDM_REMOTECONTROL:
            Shadow(m_hwndTabs, pUser);
            break;
        }

        if (!b)
        {
            DWORD   dwLastError = GetLastError();
            UINT    uiStr = 0;

            //
            // An error happened while processing the command
            //

            switch (id)
            {
            case IDM_DISCONNECT:
                uiStr = IDS_ERR_DISCONNECT;
                break;
            case IDM_LOGOFF:
                uiStr = IDS_ERR_LOGOFF;
                break;
            case IDM_SENDMESSAGE:
                uiStr = IDS_ERR_SENDMESSAGE;
                break;
            }

            if (uiStr)
            {
                LoadString(g_hInstance, uiStr, szText1, ARRAYSIZE(szText1));
                //  UI - only - don't care if it gets truncated
                StringCchPrintf( szText2, ARRAYSIZE(szText2), szText1, pUser->m_szUserName, pUser->m_dwSessionId);
            }
            else
            {
                szText1[0] = L'\0';
            }

            psz = szText2 + lstrlen(szText2);
            dwSize = ARRAYSIZE(szText2) - lstrlen(szText2) - 1;
            FormatMessage(
                FORMAT_MESSAGE_FROM_SYSTEM,
                NULL,
                dwLastError,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                psz,
                dwSize,
                NULL
            );
            szText2[ ARRAYSIZE(szText2) - 1 ] = L'\0';  // make sure it is terminated.

            iResult = MessageBox(
                          m_hwndTabs,
                          szText2,
                          szCaption,
                          MB_ICONSTOP | MB_ABORTRETRYIGNORE
                      );
            if (iResult == IDCANCEL || iResult == IDABORT)
            {
                goto done;
            }
            else if (iResult == IDRETRY)
            {
                goto retry;
            }
        }

        //
        // Break out of the loop if we just went back to handle
        // the special case of performing a disconnect or logoff
        // on our own session.
        //

        if (bFinalOne)
            break;

    } // next i;

    //
    // Check here to see if we skiped our own session
    //

    if (iFinalOne != -1 && !bFinalOne)
    {
        // Yep, we skipped ourself.  Lets put i back to the
        // right location and try again.
        bFinalOne = TRUE;
        i = iFinalOne;
        goto finalretry;
    }

done:
    if (pArray)
    {
        delete pArray;
    }

    Unpause();

    //
    // If we disconnected or logged off a user, go ahead and
    // refresh the list.  It should be up to date by now.
    //

    if (bNeedToRefresh)
    {
        TimerEvent();
    }
}


/*++ UserPageProc

Routine Description:

    Dialogproc for the task manager page.  
    
Arguments:

    hwnd        - handle to dialog box
    uMsg        - message
    wParam      - first message parameter
    lParam      - second message parameter

Return Value:
    
    For WM_INITDIALOG, TRUE == user32 sets focus, FALSE == we set focus
    For others, TRUE == this proc handles the message

Revision History:

      Nov-28-95 BradG  Created

--*/

INT_PTR CALLBACK UserPageProc(
        HWND        hwnd,               // handle to dialog box
        UINT        uMsg,                   // message
        WPARAM      wParam,                 // first message parameter
        LPARAM      lParam                  // second message parameter
        )
{
    CUserPage * thispage = (CUserPage *) GetWindowLongPtr(hwnd, GWLP_USERDATA);

    //
    // See if the parent wants this message
    //

    if (TRUE == CheckParentDeferrals(uMsg, wParam, lParam))
    {
        return TRUE;
    }

    switch(uMsg)
    {
    case WM_INITDIALOG:
        {
            SetWindowLongPtr(hwnd, GWLP_USERDATA, lParam);
            CUserPage * thispage = (CUserPage *) lParam;
            thispage->OnInitDialog(hwnd);
        }
        // We handle focus during Activate(). Return FALSE here so the
        // dialog manager doesn't try to set focus.
        return FALSE;

    case WM_LBUTTONUP:
    case WM_LBUTTONDOWN:
        // We need to fake client mouse clicks in this child to appear as nonclient
        // (caption) clicks in the parent so that the user can drag the entire app
        // when the title bar is hidden by dragging the client area of this child
        if (g_Options.m_fNoTitle)
        {
            SendMessage(g_hMainWnd, 
                    uMsg == WM_LBUTTONUP ? WM_NCLBUTTONUP : WM_NCLBUTTONDOWN, 
                    HTCAPTION, 
                    lParam);
        }
        break;
 
    case WM_COMMAND:
        if(LOWORD(wParam) == IDM_USERCOLS)
        {
            if(ColSelectDlg.DoDialog(hwnd) == IDOK)
            {
                // Set up the columns in the listview
                if (SUCCEEDED(thispage->SetupColumns()))
                {
                    thispage->TimerEvent();
                }
            }
        }
        else
        {
            thispage->HandleWMCOMMAND(LOWORD(wParam));
        }
        break;

    case WM_NOTIFY:
        return thispage->HandleUserPageNotify((LPNMHDR) lParam);

    case WM_MENUSELECT:
        if ((UINT) HIWORD(wParam) == 0xFFFF)
        {
            // Menu dismissed, resume display
            thispage->Unpause();
        }
        break;

    case WM_CONTEXTMENU:
        if ((HWND) wParam == GetDlgItem(hwnd, IDC_USERLIST))
        {
            thispage->HandleUserListContextMenu(GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam));
            return TRUE;
        }
        break;

    case WM_SIZE:
        //
        // Size our kids
        //
        thispage->SizeUserPage();
        return TRUE;

    case WM_SETTINGCHANGE:
        thispage->OnSettingsChange();
        // fall through

    case WM_SYSCOLORCHANGE:
        SendMessage(GetDlgItem(hwnd, IDC_USERLIST), uMsg, wParam, lParam);
        return TRUE;
    }

    return FALSE;
}

//
//
//
void CUserPage::OnInitDialog(HWND hPage)
{
    m_hPage = hPage;

    HWND hUserList = GetDlgItem(m_hPage, IDC_USERLIST);
    ListView_SetImageList(hUserList, m_himlUsers, LVSIL_SMALL);

    //
    // Turn on SHOWSELALWAYS so that the selection is still highlighted even
    // when focus is lost to one of the buttons (for example)
    //

    SetWindowLong(hUserList, GWL_STYLE, GetWindowLong(hUserList, GWL_STYLE) | LVS_SHOWSELALWAYS);
    ListView_SetExtendedListViewStyle(hUserList, LVS_EX_DOUBLEBUFFER);
}

//
//
//
void CUserPage::OnSettingsChange()
{
    // in going between large-font settings and normal settings, the size of small 
    // icons changes; so throw away all our icons and change the size of images in 
    // our lists
    
    BOOL fPaused = m_fPaused; // pause the page so we can get through
    m_fPaused = TRUE;         // the below without being updated  

    RemoveAllUsers();
    m_pUserArray->RemoveAll();

    m_fPaused = fPaused;            // restore the paused state
    TimerEvent();           // even if we're paused, we'll want to redraw
}


/*++ CUserPage::GetTitle

Routine Description:

    Copies the title of this page to the caller-supplied buffer
    
Arguments:

    pszText     - the buffer to copy to
    bufsize     - size of buffer, in characters

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

void CUserPage::GetTitle(LPTSTR pszText, size_t bufsize)
{
    LoadString(g_hInstance, IDS_USERPAGETITLE, pszText, static_cast<int>(bufsize));
}


/*++ CUserPage::Activate

Routine Description:

    Brings this page to the front, sets its initial position,
    and shows it
    
Arguments:

Return Value:

    HRESULT (S_OK on success)

Revision History:

      Nov-28-95 BradG  Created

--*/
 
HRESULT CUserPage::Activate()
{
    //
    // Make this page visible
    //

    ShowWindow(m_hPage, SW_SHOW);

    SetWindowPos(
        m_hPage,
        HWND_TOP,
        0, 0, 0, 0,
        SWP_NOMOVE | SWP_NOSIZE
    );

    //
    // Change the menu bar to be the menu for this page
    //

    HMENU hMenuOld = GetMenu(g_hMainWnd);
    HMENU hMenuNew = LoadMenu(g_hInstance, MAKEINTRESOURCE(IDR_MAINMENU_USER));
    
    AdjustMenuBar(hMenuNew);

    g_hMenu = hMenuNew;
    if (g_Options.m_fNoTitle == FALSE)
    {
        SetMenu(g_hMainWnd, hMenuNew);
    }

    if (hMenuOld)
    {
        DestroyMenu(hMenuOld);
    }
    
    UpdateUIState();

    //
    // If the tab control has focus, leave it there. Otherwise, set focus
    // to the listview.  If we don't set focus, it may stay on the previous
    // page, now hidden, which can confuse the dialog manager and may cause
    // us to hang.
    //

    if (GetFocus() != m_hwndTabs)
    {
        SetFocus(GetDlgItem(m_hPage, IDC_USERLIST));
    }

    return S_OK;
}


/*++ class CUserPage::SetupColumns

Class Description:

    Removes any existing columns from the taskmanager listview and
    adds all of the columns listed in the g_ActiveUserCol array.

Arguments:

Return Value:

    HRESULT

Revision History:

      Nov-29-95 BradG  Created

--*/

HRESULT CUserPage::SetupColumns()
{
    HWND hwndList = GetDlgItem(m_hPage, IDC_USERLIST);
    if (NULL == hwndList)
    {
        return E_UNEXPECTED;
    }    

    ListView_DeleteAllItems(hwndList);

    //
    // Remove all existing columns
    // save column widths.
    //

    LV_COLUMN lvcolumn;
    lvcolumn.mask = LVCF_SUBITEM | LVCF_WIDTH;

    UserColumn *pCol = ColSelectDlg.GetColumns();

    do
    {
        if(ListView_GetColumn(hwndList, 0, &lvcolumn))
        {
            if(lvcolumn.iSubItem >= USR_COL_USERSNAME &&
                lvcolumn.iSubItem < USR_MAX_COLUMN)
            {
                pCol[lvcolumn.iSubItem].Width=lvcolumn.cx;
            }
        }
    
    } while( ListView_DeleteColumn(hwndList, 0) );

    //
    // Add all of the new columns
    //

    INT iColumn = 0;
    for (int i=0; i<USR_MAX_COLUMN; i++)
    {
        if(pCol[i].bActive)
        {
            WCHAR szTitle[MAX_PATH];
            LoadString( g_hInstance, pCol[i].dwNameID, szTitle, ARRAYSIZE(szTitle) );

            lvcolumn.mask       = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
            lvcolumn.fmt        = pCol[i].Align;
            lvcolumn.cx         = pCol[i].Width;
            lvcolumn.pszText    = szTitle;
            lvcolumn.iSubItem   = i;

            if (-1 == ListView_InsertColumn(hwndList, iColumn, &lvcolumn))
            {
                return E_FAIL;
            }
            
            iColumn++;
        }
    }

    return S_OK;
}



/*++ CUserPage::Initialize

Routine Description:

    Initializes the task manager page

Arguments:

    hwndParent  - Parent on which to base sizing on: not used for creation,
          since the main app window is always used as the parent in
          order to keep tab order correct
          
Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

HRESULT CUserPage::Initialize(HWND hwndParent)
{
    HRESULT hr = S_OK;

    //
    // Create the ptr array used to hold the info on running tasks
    //

    m_pUserArray = new CPtrArray(GetProcessHeap());
    if (NULL == m_pUserArray)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        // Our pseudo-parent is the tab contrl, and is what we base our
        // sizing on.  However, in order to keep tab order right among
        // the controls, we actually create ourselves with the main
        // window as the parent

        m_hwndTabs = hwndParent;

        //
        // Create the image lists
        //

        UINT flags = ILC_MASK;
        
        if(IS_WINDOW_RTL_MIRRORED(hwndParent))
        {
            flags |= ILC_MIRROR;
        }

        m_himlUsers = ImageList_Create(
                          GetSystemMetrics(SM_CXSMICON),
                          GetSystemMetrics(SM_CYSMICON),
                          flags,
                          2,
                          1
                      );
        if (NULL == m_himlUsers)
        {
            hr = E_FAIL;
        }
    }

    if (SUCCEEDED(hr))
    {
        // Load the default icons
        hr = LoadDefaultIcons();
    }

    if (SUCCEEDED(hr))
    {
        //
        // Load the status strings
        //

        WCHAR   szText[ MAX_PATH ];

        for( int i = 0; i < MAX_STAT_STRINGS; i++ )
        {
            if ( LoadString(g_hInstance, FIRST_STAT_STRING + i, szText, ARRAYSIZE(szText) ) )
            {
                DWORD cchLen = lstrlen(szText) + 1; 
                g_pszStatString[i] = (LPWSTR) LocalAlloc( 0, cchLen * sizeof(*g_pszStatString[i]) );
                if (g_pszStatString[i])
                {
                    //  shouldn't be truncated as we dynamically allocated the array above
                    HRESULT hr = StringCchCopy( g_pszStatString[i], cchLen, szText);
                    ASSERT( S_OK == hr );
                    hr; // unreferenced on FRE builds.
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;
                break;
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Create the dialog which represents the body of this page
        //

        m_hPage = CreateDialogParam(
                      g_hInstance,                    // handle to application instance
                      MAKEINTRESOURCE(IDD_USERSPAGE), // identifies dialog box template name  
                      g_hMainWnd,                     // handle to owner window
                      UserPageProc,                   // pointer to dialog box procedure
                      (LPARAM) this                   // User data (our this pointer)
                   );

        if (NULL == m_hPage)
        {
            hr = GetLastHRESULT();
        }
    }

    if (SUCCEEDED(hr))
    {
        // Set up the columns in the listview

        hr = SetupColumns();
    }

    if (SUCCEEDED(hr))
    {
        TimerEvent();
    }

    //
    // If any failure along the way, clean up what got allocated
    // up to that point
    //

    if (FAILED(hr))
    {
        if (m_hPage)
        {
            DestroyWindow(m_hPage);
        }

        m_hwndTabs = NULL;
    }

    return hr;
}

//
//
//
HRESULT CUserPage::LoadDefaultIcons()
{
    HICON   hIcon;

    hIcon = (HICON) LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(IDI_USER),
                        IMAGE_ICON, 
                        GetSystemMetrics(SM_CXSMICON),
                        GetSystemMetrics(SM_CYSMICON),
                        0
                    );
    if (!hIcon)
    {
        return GetLastHRESULT();
    }

    m_iUserIcon = ImageList_AddIcon(m_himlUsers, hIcon);
    DestroyIcon(hIcon);
    if (-1 == m_iUserIcon)
    {
        return E_FAIL;
    }

    hIcon = (HICON) LoadImage(
                        g_hInstance,
                        MAKEINTRESOURCE(IDI_CURRENTUSER),
                        IMAGE_ICON, 
                        GetSystemMetrics(SM_CXSMICON),
                        GetSystemMetrics(SM_CYSMICON),
                        0
                    );
    if (!hIcon)
    {
        return GetLastHRESULT();
    }

    m_iCurrentUserIcon = ImageList_AddIcon(m_himlUsers, hIcon);
    DestroyIcon(hIcon);
    if (-1 == m_iUserIcon)
    {
        return E_FAIL;
    }

    return S_OK;
}


/*++ CUserPage::Destroy

Routine Description:

    Frees whatever has been allocated by the Initialize call and saves last 
    column settings.
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

HRESULT CUserPage::Destroy()
{
    //
    //  Get current column widths
    //

    HWND hwndList = GetDlgItem(m_hPage, IDC_USERLIST);
    if (hwndList)
    {

        LV_COLUMN lvcolumn;
        lvcolumn.mask = LVCF_SUBITEM | LVCF_WIDTH;

        UserColumn *pCol = ColSelectDlg.GetColumns();
    
        for(int i=0; ListView_GetColumn(hwndList, i, &lvcolumn); i++)
        {
            if(lvcolumn.iSubItem >= USR_COL_USERSNAME &&
                lvcolumn.iSubItem < USR_MAX_COLUMN)
            {
                pCol[lvcolumn.iSubItem].Width=lvcolumn.cx;
            }
        }
    }

    //
    // Save settings
    //

    ColSelectDlg.Save();

    //
    //  Page cleanup
    //

    if (m_hPage)
    {
        DestroyWindow(m_hPage);
        m_hPage = NULL;
    }

    return S_OK;
}

/*++ CUserPage::Deactivate

Routine Description:

    Called when this page is losing its place up front
    
Arguments:

Return Value:

Revision History:

      Nov-28-95 BradG  Created

--*/

void CUserPage::Deactivate()
{
    if (m_hPage)
    {
        ShowWindow(m_hPage, SW_HIDE);
    }
}


DWORD Shadow_WarningProc(HWND *phwnd);
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM wp , LPARAM lp );
void CenterDlg(HWND hwndToCenterOn , HWND hDlg );

/*++ Shadow

Routine Description:

    remote control session
    
Arguments:

Return Value:

Revision History:

      Feb-8-2000 a-skuzin  Created

--*/
void Shadow(HWND hwnd, CUserInfo * pUser)
{
    WINSTATIONCONFIG WSConfig;
    SHADOWCLASS Shadow;
    ULONG ReturnLength;
    HANDLE hServer = WTS_CURRENT_SERVER_HANDLE;
    
    //Error handling
    WCHAR szMsgText[MAX_PATH+1];
    WCHAR szCaption[MAX_PATH+1];
    WCHAR szTemplate[MAX_PATH+1];

    LoadString(g_hInstance, IDS_APPTITLE, szCaption, MAX_PATH);

    //
    // Determine the WinStation's shadow state.
    //

    if(!WinStationQueryInformation(hServer,
                                pUser->m_dwSessionId,
                                WinStationConfiguration,
                                &WSConfig, sizeof(WINSTATIONCONFIG),
                                &ReturnLength ) ) 
    {
        // Can't query WinStation configuration; complain and return
        return;
    }

    Shadow = WSConfig.User.Shadow;

    //
    // If shadowing is disabled, let the user know and return
    //

    if(Shadow == Shadow_Disable )
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW_DISABLED,szTemplate,MAX_PATH);
        //  UI only - don't care it if gets truncated.
        StringCchPrintf(szMsgText, ARRAYSIZE(szMsgText), szTemplate, pUser->m_dwSessionId );
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    //
    // If the WinStation is disconnected and shadow notify is 'on',
    // let the user know and break out.
    //

    if((pUser->m_wtsState == WTSDisconnected) &&
        ((Shadow == Shadow_EnableInputNotify) ||
        (Shadow == Shadow_EnableNoInputNotify)) ) 
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW_DISCONNECTED_NOTIFY_ON,szTemplate,MAX_PATH);
        //  UI only - don't care it if gets truncated.
        StringCchPrintf( szMsgText, ARRAYSIZE(szMsgText), szTemplate, pUser->m_dwSessionId );
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);
        return;
    }

    //
    // Display the 'start shadow' dialog for hotkey reminder and
    // final 'ok' prior to shadowing.
    //

    CShadowStartDlg SSDlg;

    if (SSDlg.DoDialog(hwnd) != IDOK)
    {
        return;
    }

    //
    // launch UI thread (???)
    //
    
    HWND hwndShadowWarn = NULL;
     
    hwndShadowWarn = CreateDialogParam( g_hInstance
                                      , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) 
                                      , hwnd 
                                      , ShadowWarn_WndProc
                                      , (LPARAM) 0
                                      );
    if(hwndShadowWarn)
    {
        ShowWindow( hwndShadowWarn, SW_SHOW );
        UpdateWindow( hwndShadowWarn );
    }

    //
    // Invoke the shadow DLL.
    //

    HCURSOR hOldCursor = SetCursor(LoadCursor(NULL,IDC_WAIT));

    //
    // allow UI thread to init window (??? but this is the same thread)
    //

    Sleep( 900 );

    //
    // Shadow API always connects to local server,
    // passing target servername as a parameter.
    //

    WCHAR szCompName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD dwSize=MAX_COMPUTERNAME_LENGTH;

    GetComputerName(szCompName,&dwSize);

    BOOL bOK = WinStationShadow(WTS_CURRENT_SERVER_HANDLE, szCompName, pUser->m_dwSessionId,
                               (BYTE)(SSDlg.GetShadowHotkeyKey()),(WORD)(SSDlg.GetShadowHotkeyShift()));

    if( hwndShadowWarn != NULL )
    {
        DestroyWindow(hwndShadowWarn);
    }

    if( !bOK )
    {
        LoadString(g_hInstance,IDS_ERR_SHADOW,szTemplate,MAX_PATH);
        //  UI only - don't care it if gets truncated.
        StringCchPrintf( szMsgText, ARRAYSIZE(szMsgText), szTemplate, pUser->m_dwSessionId );
        MessageBox(hwnd, szMsgText, szCaption, MB_OK | MB_ICONEXCLAMATION);
    }

    SetCursor(hOldCursor);
}  

//
//
//
DWORD Shadow_WarningProc(HWND *phwnd)
{
    
    DialogBoxParam( g_hInstance , MAKEINTRESOURCE( IDD_DIALOG_SHADOWWARN ) , NULL , ShadowWarn_WndProc,
        (LPARAM)phwnd);
    
    return( 0 );
}

//
//
//
INT_PTR CALLBACK ShadowWarn_WndProc( HWND hwnd , UINT msg , WPARAM , LPARAM )
{
    switch( msg )
    {
    case WM_INITDIALOG:
        CenterDlg( GetDesktopWindow( ) , hwnd );    
        break;
    }

    return FALSE;
}

//
//
//
void CenterDlg(HWND hwndToCenterOn , HWND hDlg )
{
    RECT rc, rcwk, rcToCenterOn;

    SetRect( &rcToCenterOn , 0 , 0 , GetSystemMetrics(SM_CXSCREEN) , GetSystemMetrics( SM_CYSCREEN ) );

    if (hwndToCenterOn != NULL)
    {
        GetWindowRect(hwndToCenterOn, &rcToCenterOn);
    }

    GetWindowRect( hDlg , &rc);

    UINT uiWidth = rc.right - rc.left;
    UINT uiHeight = rc.bottom - rc.top;

    rc.left = (rcToCenterOn.left + rcToCenterOn.right)  / 2 - ( rc.right - rc.left )   / 2;
    rc.top  = (rcToCenterOn.top  + rcToCenterOn.bottom) / 2 - ( rc.bottom - rc.top ) / 2;

    //
    //  Ensure the dialog always with the work area
    //

    if(SystemParametersInfo(SPI_GETWORKAREA, 0, &rcwk, 0))
    {
        UINT wkWidth = rcwk.right - rcwk.left;
        UINT wkHeight = rcwk.bottom - rcwk.top;

        if(rc.left + uiWidth > wkWidth)     //right cut
            rc.left = wkWidth - uiWidth;

        if(rc.top + uiHeight > wkHeight)    //bottom cut
            rc.top = wkHeight - uiHeight;

        if(rc.left < rcwk.left)             //left cut
            rc.left += rcwk.left - rc.left;

        if(rc.top < rcwk.top)               //top cut
            rc.top +=  rcwk.top - rc.top;

    }

    SetWindowPos( hDlg, NULL, rc.left, rc.top, 0, 0, SWP_NOSIZE | SWP_NOZORDER |
            SWP_NOCOPYBITS | SWP_DRAWFRAME);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\tourstart\resource.h ===
// icon for the app
#define IDI_WIZ_ICON                    100

// dialog IDs
#define IDD_INTRO                       101

// bitmap iDs
#define IDB_WATERMARK                   200

// dialog control ids
#define IDC_TEXT_WELCOME                1000
#define IDC_TEXT_HEADER                 1001
#define IDC_RADIO_FLASH                 1010
#define IDC_RADIO_HTML                  1011

// stringtable ids
#define IDS_DISPLAYNAME                    1
#define IDS_INFOTIP                        2
#define IDS_TITLELOGFONT                1500
#define IDS_DIR_FLASH                   1510
#define IDS_DIR_HTML                    1511
#define IDS_EXE_FLASH                   1512
#define IDS_EXE_HTML                    1513
#define IDS_FLASH_LOCALIZED             1520
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseinfo\makefile.inc ===
$(O)\sbrlist.inc:
    perl.exe gensbrlists.pl .. $(O)

!if "$(BUILD_PASS)" == "PASS2"

!include $(O)\sbrlist.inc

$(O)\shell.bsc: $(SBRLIST) 
    $(MAKEDIR)\tools\x86\bscmake -nologo -o $@ @<<
$(SBRLIST: =
)
<<NOKEEP

!else

$(O)\shell.bsc: 

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\accdel.cpp ===
#include "priv.h"
#include "accdel.h"

CDelegateAccessibleImpl::CDelegateAccessibleImpl()
{
    ASSERT(NULL == m_pDelegateAccObj);
}

CDelegateAccessibleImpl::~CDelegateAccessibleImpl()
{ 
    if (NULL != m_pDelegateAccObj)
    {
        m_pDelegateAccObj->Release();
    }
}

HRESULT CDelegateAccessibleImpl::_DefQueryInterface(REFIID riid, void **ppvObj)
{
    *ppvObj = NULL;
    
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAccessible) ||
        IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IAccessible*);
        AddRef();
    }
    else if ((NULL != m_pDelegateAccObj) && IsEqualIID(riid, IID_IEnumVARIANT))
    {
        //  Yikes! breaking COM identity rules -- trident does it, just following their lead here :)
        m_pDelegateAccObj->QueryInterface(IID_IEnumVARIANT, ppvObj);
    }

    return (NULL == *ppvObj) ? E_NOINTERFACE : S_OK;
}

// *** IDispatch ***
STDMETHODIMP CDelegateAccessibleImpl::GetTypeInfoCount(
    UINT* pctinfo)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetTypeInfoCount(pctinfo);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
    
STDMETHODIMP CDelegateAccessibleImpl::GetTypeInfo(
    UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetTypeInfo(itinfo, lcid, pptinfo);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::GetIDsOfNames(
    REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
    }
    else
    {
        return E_UNEXPECTED;
    }
}


STDMETHODIMP CDelegateAccessibleImpl::Invoke(
    DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
    DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
    UINT* puArgErr)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->Invoke(dispidMember, riid, lcid, wFlags,
                                 pdispparams, pvarResult, pexcepinfo, puArgErr);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

// *** IAccessible ***
STDMETHODIMP CDelegateAccessibleImpl::get_accParent( 
    IDispatch  **ppdispParent)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accParent(ppdispParent);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accChildCount( 
    long  *pcountChildren)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accChildCount(pcountChildren);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accChild( 
    VARIANT varChild,
    IDispatch  **ppdispChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accChild(varChild, ppdispChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accName( 
    VARIANT varChild,
    BSTR  *pszName)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accName(varChild, pszName);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accValue( 
    VARIANT varChild,
    BSTR  *pszValue)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accValue(varChild, pszValue);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accDescription( 
    VARIANT varChild,
    BSTR  *pszDescription)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accDescription(varChild, pszDescription);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accRole( 
    VARIANT varChild,
    VARIANT  *pvarRole)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accRole(varChild, pvarRole);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accState( 
    VARIANT varChild,
    VARIANT  *pvarState)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accState(varChild, pvarState);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accHelp( 
    VARIANT varChild,
    BSTR  *pszHelp)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accHelp(varChild, pszHelp);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accHelpTopic( 
    BSTR  *pszHelpFile,
    VARIANT varChild,
    long  *pidTopic)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accHelpTopic(pszHelpFile, varChild, pidTopic);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accKeyboardShortcut( 
    VARIANT varChild,
    BSTR  *pszKeyboardShortcut)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accKeyboardShortcut(varChild, pszKeyboardShortcut);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accFocus( 
    VARIANT  *pvarChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accFocus(pvarChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accSelection( 
    VARIANT  *pvarChildren)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accSelection(pvarChildren);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::get_accDefaultAction( 
    VARIANT varChild,
    BSTR  *pszDefaultAction)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->get_accDefaultAction(varChild, pszDefaultAction);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accSelect( 
    long flagsSelect,
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accSelect(flagsSelect, varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accLocation( 
    long  *pxLeft,
    long  *pyTop,
    long  *pcxWidth,
    long  *pcyHeight,
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accLocation(pxLeft, pyTop, pcxWidth, pcyHeight, varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accNavigate( 
    long navDir,
    VARIANT varStart,
    VARIANT  *pvarEndUpAt)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accNavigate(navDir, varStart, pvarEndUpAt);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accHitTest( 
    long xLeft,
    long yTop,
    VARIANT  *pvarChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accHitTest(xLeft, yTop, pvarChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::accDoDefaultAction( 
    VARIANT varChild)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->accDoDefaultAction(varChild);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::put_accName( 
    VARIANT varChild,
    BSTR szName)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->put_accName(varChild, szName);
    }
    else
    {
        return E_UNEXPECTED;
    }
}

STDMETHODIMP CDelegateAccessibleImpl::put_accValue( 
    VARIANT varChild,
    BSTR szValue)
{
    if (NULL != m_pDelegateAccObj)
    {
        return m_pDelegateAccObj->put_accValue(varChild, szValue);
    }
    else
    {
        return E_UNEXPECTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\accdel.h ===
#ifndef _ACCDEL_HPP_
#define _ACCDEL_HPP_

// REARCHITECT (lamadio): Conflicts with one defined in winuserp.h
#undef WINEVENT_VALID       //It's tripping on this...
#include "winable.h"
#include "oleacc.h"

class CDelegateAccessibleImpl : public IAccessible
{
public:
    CDelegateAccessibleImpl();

    // *** IDispatch ***
    STDMETHODIMP GetTypeInfoCount(
        UINT* pctinfo);
        
    STDMETHODIMP GetTypeInfo(
        UINT itinfo, LCID lcid, ITypeInfo** pptinfo);

    STDMETHODIMP GetIDsOfNames(
        REFIID riid, OLECHAR** rgszNames, UINT cNames, LCID lcid, DISPID* rgdispid);

    STDMETHODIMP Invoke(
        DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
        DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
        UINT* puArgErr);

    // *** IAccessible ***
    STDMETHODIMP get_accParent( 
        IDispatch  **ppdispParent);
    
    STDMETHODIMP get_accChildCount( 
        long  *pcountChildren);
    
    STDMETHODIMP get_accChild( 
        VARIANT varChild,
        IDispatch  **ppdispChild);
    
    STDMETHODIMP get_accName( 
        VARIANT varChild,
        BSTR  *pszName);
    
    STDMETHODIMP get_accValue( 
        VARIANT varChild,
        BSTR  *pszValue);
    
    STDMETHODIMP get_accDescription( 
        VARIANT varChild,
        BSTR  *pszDescription);
        
    STDMETHODIMP get_accRole( 
        VARIANT varChild,
        VARIANT  *pvarRole);
    
    STDMETHODIMP get_accState( 
        VARIANT varChild,
        VARIANT  *pvarState);
    
    STDMETHODIMP get_accHelp( 
        VARIANT varChild,
        BSTR  *pszHelp);
    
    STDMETHODIMP get_accHelpTopic( 
        BSTR  *pszHelpFile,
        VARIANT varChild,
        long  *pidTopic);
        
    STDMETHODIMP get_accKeyboardShortcut( 
        VARIANT varChild,
        BSTR  *pszKeyboardShortcut);
    
    STDMETHODIMP get_accFocus( 
        VARIANT  *pvarChild);
    
    STDMETHODIMP get_accSelection( 
        VARIANT  *pvarChildren);
    
    STDMETHODIMP get_accDefaultAction( 
        VARIANT varChild,
        BSTR  *pszDefaultAction);
    
    STDMETHODIMP accSelect( 
        long flagsSelect,
        VARIANT varChild);
    
    STDMETHODIMP accLocation( 
        long  *pxLeft,
        long  *pyTop,
        long  *pcxWidth,
        long  *pcyHeight,
        VARIANT varChild);
    
    STDMETHODIMP accNavigate( 
        long navDir,
        VARIANT varStart,
        VARIANT  *pvarEndUpAt);
    
    STDMETHODIMP accHitTest( 
        long xLeft,
        long yTop,
        VARIANT  *pvarChild);
    
    STDMETHODIMP accDoDefaultAction( 
        VARIANT varChild);
    
    STDMETHODIMP put_accName( 
        VARIANT varChild,
        BSTR szName);
    
    STDMETHODIMP put_accValue( 
        VARIANT varChild,
        BSTR szValue);

protected:
    IAccessible     *m_pDelegateAccObj;

    HRESULT _DefQueryInterface(REFIID riid, void **ppvObj);
    virtual ~CDelegateAccessibleImpl();
};



#endif // _ACCDEL_HPP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclhist.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLHIST_H_
#define _ACLHIST_H_

// Enum options
enum
{
    ACEO_ALTERNATEFORMS = ACEO_FIRSTUNUSED, // return alternate forms of the url 
};

class CACLHistory
                : public IEnumACString
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

    // *** IEnumACString ***
    virtual STDMETHODIMP NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex);
    virtual STDMETHODIMP SetEnumOptions(DWORD dwOptions);
    virtual STDMETHODIMP GetEnumOptions(DWORD *pdwOptions);

protected:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLHistory(void);
    ~CACLHistory(void);

    // Instance creator
    friend HRESULT CACLHistory_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD               _cRef;              // COM reference count
    IUrlHistoryStg*     _puhs;              // URL History storage
    IEnumSTATURL*       _pesu;              // URL enumerator
    LPOLESTR            _pwszAlternate;     // Alternate string
    FILETIME            _ftAlternate;       // Last visited time for _pwszAlternate
    HDSA                _hdsaAlternateData; // Contains alternate mappings
    DWORD               _dwOptions;         // Options flag

    // Private functions
    HRESULT _Next(LPOLESTR* ppsz, ULONG cch, FILETIME* pftLastVisited);
    void _CreateAlternateData(void);
    void _CreateAlternateItem(LPCTSTR pszUrl);
    void _SetAlternateItem(LPCTSTR pszUrl);
    void _AddAlternateDataItem(LPCTSTR pszProtocol, LPCTSTR pszDomain, BOOL fMoveSlashes);
    void _ReadAndSortHistory(void);
    static int _FreeAlternateDataItem(LPVOID p, LPVOID d);
};

#endif // _ACLHIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclhist.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclhist.h"

static const TCHAR c_szSlashSlash[] = TEXT("//");
static const TCHAR c_szEmpty[] = TEXT("");
static const TCHAR c_szFile[] = TEXT("file://");

#define SZ_REGKEY_URLPrefixesKeyA      "Software\\Microsoft\\Windows\\CurrentVersion\\URL\\Prefixes"

const TCHAR c_szDefaultURLPrefixKey[]   = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\URL\\DefaultPrefix");

/* IUnknown methods */

HRESULT CACLHistory::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLHistory, IEnumString),
        QITABENT(CACLHistory, IEnumACString),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLHistory::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLHistory::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;
    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

STDAPI PrepareURLForDisplayUTF8W(LPCWSTR pwz, LPWSTR pwzOut, DWORD * pcbOut, BOOL fUTF8Enabled);

HRESULT CACLHistory::_Next(LPOLESTR* ppsz, ULONG cch, FILETIME* pftLastVisited)
{
    ASSERT(ppsz);

    HRESULT hr = S_FALSE;

    if (_pwszAlternate)
    {
        //
        // There is an alternate version of the string we produced last time.
        // Hand them the alternate string now.
        //
        if (cch == 0)
        {
            // Return the allocated memory
            *ppsz = _pwszAlternate;
        }
        else
        {
            // Copy into the caller's buffer
            StringCchCopy(*ppsz, cch, _pwszAlternate);
            CoTaskMemFree(_pwszAlternate);
        }
        _pwszAlternate = NULL;
        hr = S_OK;
    }

    else if (NULL != _pesu)
    {
        STATURL rsu[1] = { { SIZEOF(STATURL) } };
        ULONG celtFetched;
        while (SUCCEEDED(_pesu->Next(1, rsu, &celtFetched)) && celtFetched)
        {
            ASSERT(IS_VALID_STRING_PTRW(rsu[0].pwcsUrl, -1));

            // We didn't ask for the title!
            ASSERT(NULL == rsu[0].pwcsTitle);

            //
            // Ignore if a frame or an error URL
            //
            if (!(rsu[0].dwFlags & STATURLFLAG_ISTOPLEVEL) ||
                 IsErrorUrl(rsu[0].pwcsUrl))
            {
                CoTaskMemFree(rsu[0].pwcsUrl);
                rsu[0].pwcsUrl = NULL;
                continue;
            }

            // WARNING (IE #54924): It would look pretty to
            //    unescape the URL but that would incure data-loss
            //    so don't do it!!!  This breaks more things that
            //    you could imagine. -BryanSt
            //
            // Unescape the URL (people don't like to type %F1, etc).
            //
            // Unescaping is definitely a problem for ftp, but it should be
            // safe for http and https (stevepro).

            hr = S_OK; // we're done already, unless we have to muck around with UTF8 decoding

            if (StrChr(rsu[0].pwcsUrl, L'%'))
            {
                DWORD dwScheme = GetUrlScheme(rsu[0].pwcsUrl);
                if ((dwScheme == URL_SCHEME_HTTP) || (dwScheme == URL_SCHEME_HTTPS))
                {
                    WCHAR   szBuf[MAX_URL_STRING];
                    DWORD   cchBuf = ARRAYSIZE(szBuf);

                    HRESULT hr2 = PrepareURLForDisplayUTF8W(rsu[0].pwcsUrl, szBuf, &cchBuf, TRUE);

                    if (SUCCEEDED(hr2))
                    {
                        // normally StringCchCopy's cch limit should be the size of the destination
                        // buffer, but in this case, we know that the number of characters that
                        // were written into szBuf is <= the number of characters in
                        // rsu[0].pwcsUrl since if anything changes, it is the reduction of
                        // URL escaped sequences into single characters, and the reduction of
                        // UTF8 character sequences into single unicode characters.
                    
                        ASSERT(cchBuf <= (DWORD)lstrlenW(rsu[0].pwcsUrl));
                        StringCchCopy(rsu[0].pwcsUrl, cchBuf+1, szBuf);
                    }
                }
            }

            if (cch == 0)
            {
                // Return the allocated memory
                *ppsz = rsu[0].pwcsUrl;
            }
            else
            {
                // Copy into the caller's buffer
                StringCchCopy(*ppsz, cch, rsu[0].pwcsUrl);
                CoTaskMemFree(rsu[0].pwcsUrl);
            }

            // Save the time in case an alternate form is needed
            _ftAlternate = rsu[0].ftLastVisited;
            break;
        }
    }

    // Provide alternate forms of the same url
    if ((_dwOptions & ACEO_ALTERNATEFORMS) && hr == S_OK)
    {
        USES_CONVERSION;
        _CreateAlternateItem(*ppsz);
    }

    if (pftLastVisited)
    {
        *pftLastVisited = _ftAlternate;
    }

    return hr;
}

HRESULT CACLHistory::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;

    *pceltFetched = 0;

    if (!celt)
    {
        return S_OK;
    }

    if (!rgelt)
    {
        return E_FAIL;
    }

    hr = _Next(&rgelt[0], 0, NULL);
    if (S_OK == hr)
    {
        *pceltFetched = 1;
    }
    return hr;
}


HRESULT CACLHistory::Skip(ULONG celt)
{
    return E_NOTIMPL;
}

HRESULT CACLHistory::Reset(void)
{
    HRESULT hr = S_OK;

    //
    // Since Reset() is always called before Next() we will
    // delay opening the History folder until that last 
    // moment.
    //
    if (!_puhs)
    {
        hr = CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, 
                        IID_PPV_ARG(IUrlHistoryStg, &_puhs));
    }

    if ((SUCCEEDED(hr)) && (_puhs) && (!_pesu))
    {
        hr = _puhs->EnumUrls(&_pesu);
    }

    if ((SUCCEEDED(hr)) && (_puhs) && (_pesu))
    {
        hr = _pesu->Reset();

         // We only want top-level pages
        _pesu->SetFilter(NULL, STATURL_QUERYFLAG_TOPLEVEL | STATURL_QUERYFLAG_NOTITLE);
   }

    if (_pwszAlternate)
    {
        CoTaskMemFree(_pwszAlternate);
        _pwszAlternate = NULL;
    }

    return hr;
}

/****************************************************************\
    FUNCTION: Clone

    DESCRIPTION:
        This function will clone the current enumerator.

    WARNING:
        This function will not implement the full functionality
    of Clone().  It will not create an enumerator that is pointing
    to the same location in the list as the original enumerator.
\****************************************************************/
HRESULT CACLHistory::Clone(IEnumString **ppenum)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;
    CACLHistory * p = new CACLHistory();

    if (p) 
    {
        hr = p->Reset();
        if (FAILED(hr))
            p->Release();
        else
            *ppenum = SAFECAST(p, IEnumString *);
    }

    return hr;
}

// *** IEnumACString ***
HRESULT CACLHistory::NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    if (NULL == pszUrl || cchMax == 0 || NULL == pulSortIndex)
    {
        return E_INVALIDARG;
    }

    *pulSortIndex = 0;

    FILETIME ftLastVisited;
    HRESULT hr = _Next(&pszUrl, cchMax, &ftLastVisited);

    // See if we want the results sorted by most recently used first
    if (S_OK == hr && (_dwOptions & ACEO_MOSTRECENTFIRST))
    {
        // Get the current system time
        FILETIME ftTimeNow;
        CoFileTimeNow(&ftTimeNow);

        ULONGLONG t1=0,t2=0,t3;

        // Put the current time into 64-bit 
        t1 = ((ULONGLONG)ftTimeNow.dwHighDateTime << 32);
        t1 += ftTimeNow.dwLowDateTime;

        // Ditto for the last visited time
        t2 = ((ULONGLONG)ftLastVisited.dwHighDateTime << 32);
        t2 += ftLastVisited.dwLowDateTime;

        // Take the difference and convert into seconds
        t3 = (t1-t2) / 10000000;

        // If t3 overflows, then set the low byte to the highest possible value
        if (t3 > (ULONGLONG)MAXULONG) 
        {
            t3 = MAXULONG;
        }

        *pulSortIndex = (ULONG)t3;
    }
    return hr;
}

STDMETHODIMP CACLHistory::SetEnumOptions(DWORD dwOptions)
{
    _dwOptions = dwOptions;
    return S_OK;
}

STDMETHODIMP CACLHistory::GetEnumOptions(DWORD *pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = _dwOptions;
        hr = S_OK;
    }
    return hr;
}

/* Constructor / Destructor / CreateInstance */

CACLHistory::CACLHistory()
{
    DllAddRef();
    ASSERT(_puhs == 0);
    ASSERT(_pesu == 0);
    _cRef = 1;
    _dwOptions = ACEO_ALTERNATEFORMS;
}

CACLHistory::~CACLHistory()
{
    if (_pesu)
    {
        _pesu->Release();
        _pesu = NULL;
    }

    if (_puhs)
    {
        _puhs->Release();
        _puhs = NULL;
    }

    if (_hdsaAlternateData)
    {
        DSA_DestroyCallback(_hdsaAlternateData, _FreeAlternateDataItem, 0);
        _hdsaAlternateData = NULL;
    }

    DllRelease();
}

HRESULT CACLHistory_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory
    *ppunk = NULL;
    CACLHistory * p = new CACLHistory();
    if (p) 
    {
        *ppunk = SAFECAST(p, IEnumString *);
        return NOERROR;
    }
    return E_OUTOFMEMORY;
}

/* Private functions */

typedef struct _tagAlternateData
{
    LPTSTR pszProtocol;
    int cchProtocol;
    LPTSTR pszDomain;
    int cchDomain;
} ALTERNATEDATA;


//
// Add one protocol/domain combination to the HDSA.
// Information is stored in the registry as
// Protocol="ftp://" and Domain="ftp." but we want to
// store it as Protocol="ftp:" and Domain="//ftp."
// when fMoveSlashes is TRUE.
//
void CACLHistory::_AddAlternateDataItem(LPCTSTR pszProtocol, LPCTSTR pszDomain, BOOL fMoveSlashes)
{
    ALTERNATEDATA ad;

    ZeroMemory(&ad, SIZEOF(ad));

    ad.cchProtocol = lstrlen(pszProtocol);
    ad.cchDomain = lstrlen(pszDomain);

    if (fMoveSlashes)
    {
        //
        // Validate that there are slashes to move.
        //
        if (ad.cchProtocol > 2 &&
            pszProtocol[ad.cchProtocol - 2] == TEXT('/') &&
            pszProtocol[ad.cchProtocol - 1] == TEXT('/'))
        {
            ad.cchProtocol -= 2;
            ad.cchDomain += 2;
        }
        else
        {
            fMoveSlashes = FALSE;
        }
    }

    ad.pszProtocol = (LPTSTR)LocalAlloc(LPTR, (ad.cchProtocol + 1) * SIZEOF(TCHAR));
    ad.pszDomain = (LPTSTR)LocalAlloc(LPTR, (ad.cchDomain + 1) * SIZEOF(TCHAR));

    if (ad.pszProtocol && ad.pszDomain)
    {
        StringCchCopy(ad.pszProtocol, ad.cchProtocol + 1, pszProtocol);

        if (fMoveSlashes)
        {
            StringCchCopy(ad.pszDomain, ad.cchDomain + 1, c_szSlashSlash);
            StringCchCopy(ad.pszDomain + 2, ad.cchDomain - 1, pszDomain);
        }
        else
        {
            StringCchCopy(ad.pszDomain, ad.cchDomain + 1, pszDomain);
        }

        DSA_AppendItem(_hdsaAlternateData, &ad);
    }
    else
    {
        _FreeAlternateDataItem(&ad, 0);
    }
}

//
// This fills in the HDSA from the registry.
//
void CACLHistory::_CreateAlternateData(void)
{
    HKEY hkey;
    DWORD cbProtocol;
    TCHAR szProtocol[MAX_PATH];
    DWORD cchDomain;
    TCHAR szDomain[MAX_PATH];
    DWORD dwType;

    ASSERT(_hdsaAlternateData == NULL);

    _hdsaAlternateData = DSA_Create(SIZEOF(ALTERNATEDATA), 10);
    if (!_hdsaAlternateData)
    {
        return;
    }

    //
    // Add default protocol.
    //
    cbProtocol = SIZEOF(szProtocol);
    if (SHGetValue(HKEY_LOCAL_MACHINE, c_szDefaultURLPrefixKey, NULL, NULL, (void *)szProtocol, (DWORD *)&cbProtocol) == ERROR_SUCCESS)
    {
        _AddAlternateDataItem(szProtocol, c_szEmpty, TRUE);
    }

    //
    // Add "file://" prefix.  Since "file://foo.txt" doesn't navigate to
    // the same place as "//foo.txt" we have to pass in FALSE to fMoveSlashes.
    //
    _AddAlternateDataItem(c_szFile, c_szEmpty, FALSE);

    //
    // Add all registered prefixes.
    //
    if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, SZ_REGKEY_URLPrefixesKeyA, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        cchDomain = ARRAYSIZE(szDomain);
        cbProtocol = SIZEOF(szProtocol);

        for (int i=0;
             SHEnumValue(hkey, i, szDomain, &cchDomain, &dwType,
                          (PBYTE)szProtocol, &cbProtocol) == ERROR_SUCCESS;
             i++)
        {
            _AddAlternateDataItem(szProtocol, szDomain, TRUE);

            cchDomain = ARRAYSIZE(szDomain);
            cbProtocol = SIZEOF(szProtocol);
        }

        RegCloseKey(hkey);
    }
}

//
// Given a pszUrl, attempts to create an alternate URL
// and store it into _pwszAlternate.
//
//  URL                 Alternate
//  =================   ========================
//  http://one.com      //one.com
//  //one.com           one.com
//  one.com             (no alternate available)
//  ftp://ftp.two.com   //ftp.two.com
//  //ftp.two.com       ftp.two.com
//  ftp.two.com         (no alternate available)
//  ftp://three.com     (no alternate available)
//  file://four.txt     four.txt
//  four.txt            (no alternate available)
//
// In a sense, this is the opposite of IURLQualify().
//
void CACLHistory::_CreateAlternateItem(LPCTSTR pszUrl)
{
    ASSERT(_pwszAlternate == NULL);

    //
    // If an URL begins with "//" we can always remove it.
    //
    if (pszUrl[0] == TEXT('/') && pszUrl[1] == TEXT('/'))
    {
        _SetAlternateItem(pszUrl + 2);
        return;
    }

    //
    // Create the HDSA if necessary.
    //
    if (!_hdsaAlternateData)
    {
        _CreateAlternateData();

        if (!_hdsaAlternateData)
        {
            return;
        }
    }

    //
    // Look for matches in the HDSA.
    //
    // For instance, if pszProtocol="ftp:" and pszDomain="//ftp."
    // and the given url is of the format "ftp://ftp.{other stuff}"
    // then we strip off the pszProtocol and offer "//ftp.{other stuff}"
    // as the alternate.
    //
    for (int i=0; i<DSA_GetItemCount(_hdsaAlternateData); i++)
    {
        ALTERNATEDATA ad;

        if (DSA_GetItem(_hdsaAlternateData, i, &ad) != -1)
        {
            if ((StrCmpNI(ad.pszProtocol, pszUrl, ad.cchProtocol) == 0) &&
                (StrCmpNI(ad.pszDomain, pszUrl + ad.cchProtocol, ad.cchDomain) == 0))
            {
                _SetAlternateItem(pszUrl + ad.cchProtocol);
                return;
            }
        }
    }
}

//
// Given an URL, set _pwszAlternate.  This takes care
// of all ANSI/UNICODE issues and allocates memory for
// _pwszAlternate via CoTaskMemAlloc.
//
void CACLHistory::_SetAlternateItem(LPCTSTR pszUrl)
{
    ASSERT(_pwszAlternate == NULL);

    int cch;

#ifdef UNICODE
    cch = lstrlen(pszUrl) + 1;
#else
    cch = MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, NULL, 0);
#endif

    _pwszAlternate = (LPOLESTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
    if (_pwszAlternate)
    {
#ifdef UNICODE
        StringCchCopy(_pwszAlternate, cch, pszUrl);
#else
        MultiByteToWideChar(CP_ACP, 0, pszUrl, -1, _pwszAlternate, cch);
#endif
    }
}

//
// Handy routine for calling directly or via DSA callback.
//
int CACLHistory::_FreeAlternateDataItem(void * p, void * d)
{
    ALTERNATEDATA *pad = (ALTERNATEDATA *)p;

    if (pad->pszProtocol)
    {
        LocalFree((HANDLE)pad->pszProtocol);
    }
    if(pad->pszDomain)
    {
        LocalFree((HANDLE)pad->pszDomain);
    }

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\applets\tourstart\tourstart.cpp ===
#include <shlobj.h>
#include <windowsx.h>
#include <shellapi.h>
#include <shlwapi.h>
#include <resource.h>
#include <regstr.h>
#include <shpriv.h>
#include <ccstock.h>
#include <strsafe.h>

// device bit entries

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x) / sizeof((x)[0]))
#endif

#define NUMPAGES 1

HFONT     g_hTitleFont = NULL;
HINSTANCE g_hInstance = NULL;

////////////////////////////////////////////////////////

HRESULT _LoadPath(BOOL fFlash, LPTSTR pszBuffer, UINT cchBuffer)
{
    HRESULT hr;
    
    if (!GetWindowsDirectory(pszBuffer, cchBuffer))
    {
        hr = E_FAIL;
    }
    else
    {        
        TCHAR szTemp[MAX_PATH];
        if (!LoadString(g_hInstance, fFlash ? IDS_DIR_FLASH : IDS_DIR_HTML, szTemp, ARRAYSIZE(szTemp)))
        {
            hr = E_FAIL;
        }
        else
        {
            if (!PathAppend(pszBuffer, szTemp))
            {
                hr = E_FAIL;
            }
            else
            {
                if (GetSystemDefaultUILanguage() == GetUserDefaultUILanguage()) // not on MUI
                {
                    hr = S_OK;
                }
                else
                {
                    TCHAR szMUITemplate[16];
                    LANGID langid = GetUserDefaultUILanguage();

                    hr = StringCchPrintf(szMUITemplate, ARRAYSIZE(szMUITemplate), TEXT("mui\\%04lx"), langid);

                    if (SUCCEEDED(hr))
                    {
                        if (!PathAppend(pszBuffer, szMUITemplate))
                        {
                            hr = E_FAIL;
                        }
                        else
                        {
                            hr = S_OK;
                        }
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT _DeleteTourBalloon()
{
    IShellReminderManager* psrm;
    HRESULT hr = CoCreateInstance(CLSID_PostBootReminder, NULL, CLSCTX_INPROC_SERVER,
                                  IID_PPV_ARG(IShellReminderManager, &psrm));

    if (SUCCEEDED(hr))
    {
        hr = psrm->Delete(L"Microsoft.OfferTour");
        psrm->Release();
    }

    return hr;
}

HRESULT _ExecuteTour(BOOL fFlash)
{
    TCHAR szDir[MAX_PATH];
    HRESULT hr = _LoadPath(fFlash, szDir, ARRAYSIZE(szDir));
    if (SUCCEEDED(hr))
    {
        TCHAR szTarget[MAX_PATH];
        if (!LoadString(g_hInstance, fFlash ? IDS_EXE_FLASH : IDS_EXE_HTML, szTarget, ARRAYSIZE(szTarget)))
        {
            hr = E_FAIL;
        }
        else
        {
            if (32 < (INT_PTR)ShellExecute(NULL, NULL, szTarget, NULL, szDir, SW_SHOWNORMAL))
            {
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
    }
    return hr;
}

HRESULT _HaveFlashTour()
{
    HRESULT hr;

    TCHAR szHaveLocalizedTour[6];
    if (!LoadString(g_hInstance, IDS_FLASH_LOCALIZED, szHaveLocalizedTour, ARRAYSIZE(szHaveLocalizedTour)))
    {
        hr = E_FAIL;
    }
    else
    {
        // if the string in the .rc is not "TRUE", then we know we don't have a flash tour
        if (0 != StrCmp(szHaveLocalizedTour, TEXT("TRUE"))) 
        {
            hr = S_FALSE;
        }
        else
        {
            // if the string in the .rc is "TRUE", then we still check if the tour.exe is there
            TCHAR szPath[MAX_PATH];
            hr = _LoadPath(TRUE, szPath, ARRAYSIZE(szPath));
            if (SUCCEEDED(hr))
            {
                TCHAR szTarget[MAX_PATH];            
                if (!LoadString(g_hInstance, IDS_EXE_FLASH, szTarget, ARRAYSIZE(szTarget)))
                {
                    hr = E_FAIL;
                }
                else
                {
                    if (!PathAppend(szPath, szTarget))
                    {
                        hr = E_FAIL;
                    }
                    else
                    {
                        if (PathFileExists(szPath))
                        {
                            hr = S_OK;
                        }
                        else
                        {
                            hr = S_FALSE;
                        }
                    }
                }
            }
        }
    }

    return hr;
}

///////////////////////////////////////////////////////////

INT_PTR _IntroDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR ipRet = FALSE;
    
    switch (wMsg)
    {                
        case WM_INITDIALOG:
        {
            SetWindowFont(GetDlgItem(hDlg, IDC_TEXT_WELCOME), g_hTitleFont, TRUE);                        
        }
        break;
            
        case WM_NOTIFY :
        {
            LPNMHDR lpnm = (LPNMHDR) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE: 	 
                    PropSheet_SetWizButtons(GetParent(hDlg), PSWIZB_NEXT);
                    SendMessage(GetDlgItem(hDlg, IDC_RADIO_FLASH), BM_CLICK, 0, 0);
                    break;
                case PSN_WIZNEXT:
                    if (BST_CHECKED == SendMessage(GetDlgItem(hDlg, IDC_RADIO_FLASH), BM_GETCHECK, 0, 0))
                    {
                        _ExecuteTour(TRUE);
                    }
                    else
                    {
                        _ExecuteTour(FALSE);
                    }
                    PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
                    break;
            }
            break;
        }            
    }    
    return ipRet;
}

///////////////////////////////////////////////////////////

HRESULT Run()
{
    // Disable the balloon tip
    DWORD dwCount = 0; 
    SHRegSetUSValue(REGSTR_PATH_SETUP TEXT("\\Applets\\Tour"), TEXT("RunCount"), REG_DWORD, &dwCount, sizeof(DWORD), SHREGSET_FORCE_HKCU);
    _DeleteTourBalloon();

    // Before we do anything, check to see if we have the choice of a FLASH tour.  If we don't,
    // then we don't need to launch any wizard.
    if (S_OK == _HaveFlashTour())
    {
        // Init common controls
        INITCOMMONCONTROLSEX icex;

        icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
        icex.dwICC = ICC_USEREX_CLASSES;
        InitCommonControlsEx(&icex);

        //
        //Create the Wizard page
        //
        PROPSHEETPAGE psp = {0}; //defines the property sheet page
        HPROPSHEETPAGE rghpsp[NUMPAGES];  // an array to hold the page's HPROPSHEETPAGE handles
        psp.dwSize = sizeof(psp);
        psp.hInstance = g_hInstance;

        psp.dwFlags = PSP_DEFAULT|PSP_HIDEHEADER;
        psp.pszHeaderTitle = NULL;
        psp.pszHeaderSubTitle = NULL;
        psp.pszTemplate = MAKEINTRESOURCE(IDD_INTRO);
        psp.pfnDlgProc = _IntroDlgProc;
        rghpsp[0] =  CreatePropertySheetPage(&psp);

        // create the font
        NONCLIENTMETRICS ncm = {0};
        ncm.cbSize = sizeof(ncm);
        SystemParametersInfo(SPI_GETNONCLIENTMETRICS, 0, &ncm, 0);
        LOGFONT TitleLogFont = ncm.lfMessageFont;
        TitleLogFont.lfWeight = FW_BOLD;
        LoadString(g_hInstance, IDS_TITLELOGFONT, TitleLogFont.lfFaceName, LF_FACESIZE);
        HDC hdc = GetDC(NULL); //gets the screen DC
        if (hdc)
        {
            TitleLogFont.lfHeight = 0 - GetDeviceCaps(hdc, LOGPIXELSY) * 12 / 72;
            g_hTitleFont = CreateFontIndirect(&TitleLogFont);
            ReleaseDC(NULL, hdc);
        }

        //Create the property sheet
        PROPSHEETHEADER _psh;
        _psh.hInstance =         g_hInstance;
        _psh.hwndParent =        NULL;
        _psh.phpage =            rghpsp;
        _psh.dwSize =            sizeof(_psh);
        _psh.dwFlags =           PSH_WIZARD97|PSH_WATERMARK|PSH_USEICONID;
        _psh.pszbmWatermark =    MAKEINTRESOURCE(IDB_WATERMARK);
        _psh.pszIcon =           MAKEINTRESOURCE(IDI_WIZ_ICON);
        _psh.nStartPage =        0;
        _psh.nPages =            NUMPAGES;


        // run property sheet
        PropertySheet(&_psh);

        // clean up font
        if (g_hTitleFont)
        {
            DeleteObject(g_hTitleFont);
        }
    }
    else
    {
        _ExecuteTour(FALSE);
    }

    return S_OK;
}

///////////////////////////////////////////////////////////

INT WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpszCmdLine, INT nCmdShow)
{
    OleInitialize(NULL);
    
    g_hInstance = hInstance;

    Run();

    OleUninitialize();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclisf.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclisf.h"
#include "shellurl.h"


#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE

//
// CACLIShellFolder -- An AutoComplete List COM object that
//                  opens an IShellFolder for enumeration.
//



/* IUnknown methods */

HRESULT CACLIShellFolder::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLIShellFolder, IEnumString),
        QITABENT(CACLIShellFolder, IACList),
        QITABENT(CACLIShellFolder, IACList2),
        QITABENT(CACLIShellFolder, IShellService),
        QITABENT(CACLIShellFolder, ICurrentWorkingDirectory),
        QITABENT(CACLIShellFolder, IPersistFolder),
        { 0 },
    };
    
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLIShellFolder::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLIShellFolder::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}


/* ICurrentWorkingDirectory methods */
HRESULT CACLIShellFolder::SetDirectory(LPCWSTR pwzPath)
{
    HRESULT hr;
    LPITEMIDLIST pidl = NULL;

    hr = IECreateFromPathW(pwzPath, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = Initialize(pidl);
        ILFree(pidl);
    }

    return hr;
}


/* IPersistFolder methods */
HRESULT CACLIShellFolder::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;

    hr = _Init();
    if (FAILED(hr))
        return hr;

    if (pidl)
    {
#ifdef DEBUG
        TCHAR szPath[MAX_URL_STRING];
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szPath, SIZECHARS(szPath), NULL);
        TraceMsg(AC_GENERAL, "ACListISF::Initialize(%s), SetCurrentWorking Directory happening", szPath);
#endif // DEBUG

        hr = _pshuLocation->SetCurrentWorkingDir(pidl);

        SetDefaultShellPath(_pshuLocation);

    }
    Pidl_Set(&_pidlCWD, pidl);

    return hr;
}

HRESULT CACLIShellFolder::GetClassID(CLSID *pclsid)
{
    *pclsid = CLSID_ACListISF;
    return S_OK;
}


/* IEnumString methods */
HRESULT CACLIShellFolder::Reset(void)
{
    HRESULT hr;
    LPITEMIDLIST pidl = NULL;
    TraceMsg(AC_GENERAL, "ACListISF::Reset()");
    _fExpand = FALSE;
    _nPathIndex = 0;

    hr = _Init();

    // See if we should show hidden files
    SHELLSTATE ss;
    ss.fShowAllObjects = FALSE;
    SHGetSetSettings(&ss, SSF_SHOWALLOBJECTS /*| SSF_SHOWSYSFILES*/, FALSE);
    _fShowHidden = BOOLIFY(ss.fShowAllObjects);
//    _fShowSysFiles = BOOLIFY(ss.fShowSysFiles);

    if (SUCCEEDED(hr) && IsFlagSet(_dwOptions, ACLO_CURRENTDIR))
    {
        // Set the Browser's Current Directory.
        if (_pbs)
        {
            _pbs->GetPidl(&pidl);

            if (pidl)
                Initialize(pidl);
        }

        hr = _SetLocation(pidl);
        if (FAILED(hr))
            hr = S_FALSE;   // If we failed, keep going, we will just end up now doing anything.

        ILFree(pidl);
    }
    
    return hr;
}


// If this is an FTP URL, skip it if:
// 1) It's absolute (has a FTP scheme), and
// 2) it contains a '/' after the server name.
BOOL CACLIShellFolder::_SkipForPerf(LPCWSTR pwzExpand)
{
    BOOL fSkip = FALSE;

    if ((URL_SCHEME_FTP == GetUrlScheme(pwzExpand)))
    {
        // If it's FTP, we want to prevent from hitting the server until
        // after the user has finished AutoCompleting the Server name.
        // Since we can't enum server names, the server names will need
        // to come from the MRU.
        if ((7 >= lstrlen(pwzExpand)) ||                    // There's more than 7 chars "ftp://"
            (NULL == StrChr(&(pwzExpand[7]), TEXT('/'))))   // There is a '/' after the server, "ftp://serv/"
        {
            fSkip = TRUE;
        }
    }

    return fSkip;
}



/* IACList methods */
/****************************************************\
    FUNCTION: Expand

    DESCRIPTION:
        This function will attempt to use the pszExpand
    parameter to bind to a location in the Shell Name Space.
    If that succeeds, this AutoComplete List will then
    contain entries which are the display names in that ISF.
\****************************************************/
HRESULT CACLIShellFolder::Expand(LPCOLESTR pszExpand)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl = NULL;
    DWORD dwParseFlags = SHURL_FLAGS_NOUI;

    TraceMsg(AC_GENERAL, "ACListISF::Expand(%ls)", pszExpand);
    _fExpand = FALSE;
    _nPathIndex = 0;

    hr = StringCchCopy( _szExpandStr, ARRAYSIZE(_szExpandStr), pszExpand);
    if (SUCCEEDED(hr))
    {
        if (_SkipForPerf(pszExpand)) // Do we want to skip this item for perf reasons?
        {
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
        }
        else
        {
            hr = _Init();
        }
    }

    if (FAILED(hr))
        return hr;

    // See if the string points to a location in the Shell Name Space
    hr = _pshuLocation->ParseFromOutsideSource(_szExpandStr, dwParseFlags);
    if (SUCCEEDED(hr))
    {
        // Yes it did, so now AutoComplete from that ISF
        hr = _pshuLocation->GetPidl(&pidl);
        // This may fail if it's something like "ftp:/" and not yet valid".

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(AC_GENERAL, "ACListISF::Expand() Pidl=>%s<", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));
    }

    // Set the ISF that we need to enumerate for AutoComplete.
    hr = _SetLocation(pidl);
    if (pidl)
    {
        ILFree(pidl);


        if (SUCCEEDED(hr))
        {
            _fExpand = TRUE;
        }
    }

    return hr;
}

/* IACList2 methods */
//+-------------------------------------------------------------------------
// Enables/disables various autocomplete features (see ACLO_* flags)
//--------------------------------------------------------------------------
HRESULT CACLIShellFolder::SetOptions(DWORD dwOptions)
{
    _dwOptions = dwOptions;
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns the current option settings
//--------------------------------------------------------------------------
HRESULT CACLIShellFolder::GetOptions(DWORD* pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = _dwOptions;
        hr = S_OK;
    }

    return hr;
}


HRESULT CACLIShellFolder::_GetNextWrapper(LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl = NULL;
    ULONG celtFetched = 0;

    // If this directory (ISF) doesn't contain any more items to enum,
    // then go on to the next directory (ISF) to enum.
    do
    {
        BOOL fFilter;

        do
        {
            fFilter = FALSE;
            hr = _peidl->Next(1, &pidl, &celtFetched);
            if (S_OK == hr)
            {
                hr = _PassesFilter(pidl, pszName, cchSize);
                if (FAILED(hr))
                {
                    fFilter = TRUE;
                }

                ILFree(pidl);
            }
        }
        while (fFilter);
    }
    while ((S_OK != hr) && (S_OK == _TryNextPath()));

    return hr;
}


HRESULT CACLIShellFolder::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidl;
    ULONG celtFetched;
    BOOL fUsingCachePidl = FALSE;
    WCHAR szDisplayName[MAX_PATH];

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    // If there isn't a Current Working Directory, skip to another
    // Path to enum.
    if (!_peidl)
        hr = _TryNextPath();

    if ((!_peidl) || (!rgelt))
        return S_FALSE;

    // Get the next PIDL.
    if (_pidlInFolder)
    {
        // We have a cached, SHGDN_INFOLDER, so lets try that.
        pidl = _pidlInFolder;
        celtFetched = 1;
        _pidlInFolder = NULL;
        fUsingCachePidl = TRUE;

        hr = _GetPidlName(pidl, fUsingCachePidl, szDisplayName, ARRAYSIZE(szDisplayName));
        ILFree(pidl);
        AssertMsg((S_OK == hr), TEXT("CACLIShellFolder::Next() hr doesn't equal S_OK, so we need to call _GetNextWrapper() but we aren't.  Please call BryanSt."));
    }
    else
    {
        hr = _GetNextWrapper(szDisplayName, ARRAYSIZE(szDisplayName));
    }

//         This is giving us entries (favorites without .url extension) that cannot be navigated to.
//         So I'm disabling this for IE5B2. (stevepro)
//
//        else
//            Pidl_Set(&_pidlInFolder, pidl);  // We will try (SHGDN_INFOLDER) next time.

    if (SUCCEEDED(hr))
    {
        LPOLESTR pwszPath;

        // Allocate a return buffer (caller will free it).
        DWORD cch = lstrlenW(szDisplayName) + 1;
        pwszPath = (LPOLESTR)CoTaskMemAlloc(cch * SIZEOF(WCHAR));
        if (pwszPath)
        {
            StringCchCopy(pwszPath, cch, szDisplayName);
            TraceMsg(AC_GENERAL, "ACListISF::Next() Str=%s, _nPathIndex=%d", pwszPath, _nPathIndex);

            if (SUCCEEDED(hr))
            {
                rgelt[0] = pwszPath;
                *pceltFetched = 1;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

HRESULT CACLIShellFolder::_GetPidlName(LPCITEMIDLIST pidl, BOOL fUsingCachePidl, LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    WCHAR szName[MAX_PATH];

    // Get the display name of the PIDL.
    if (!fUsingCachePidl)
    {
        hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szName, ARRAYSIZE(szName));

        // some namespaces don't understand _FORADDRESSBAR -- default to IE4 behavior
        if (FAILED(hr))
            hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szName, ARRAYSIZE(szName));
    }


    if (fUsingCachePidl || FAILED(hr))
    {
        hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER | SHGDN_FORADDRESSBAR, szName, ARRAYSIZE(szName));

        // some namespaces don't understand _FORADDRESSBAR -- default to IE4 behavior
        if (FAILED(hr))
            hr = DisplayNameOf(_psf, pidl, SHGDN_INFOLDER, szName, ARRAYSIZE(szName));
    }

    if (SUCCEEDED(hr))
    {
        pszName[0] = 0;     // Init the out buffer.

        // First, prepend the _szExpandStr if necessary.
        // This is needed for sections that don't give
        // the entire path, like "My Computer" items
        // which is (3 == _nPathIndex)
        if (_fExpand && ((_nPathIndex == 0) /*|| (_nPathIndex == 3)*/))
        {
            DWORD cchExpand = lstrlen(_szExpandStr);
            // Make sure that for UNC paths the "\\share" is not already
            // prepended.  NT5 returns the name in this final form.
            if ((StrCmpNI(szName, _szExpandStr, cchExpand) != 0) ||
                (szName[0] != L'\\') || (szName[1] != L'\\'))
            {
                hr = StringCchCopy(pszName,  cchSize, _szExpandStr);
            }
        }

        if(SUCCEEDED(hr))
        {
            // Next, append the display name.
            hr = StringCchCat(pszName, cchSize, szName);
            TraceMsg(AC_GENERAL, "ACListISF::_GetPidlName() Str=%s, _nPathIndex=%d", szName, _nPathIndex);
        }
    }
    return hr;
}


HRESULT CACLIShellFolder::_PassesFilter(LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize)
{
    HRESULT hr = S_OK;
    DWORD dwAttributes = (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM);

    hr = _GetPidlName(pidl, FALSE, pszName, cchSize);
    if (SUCCEEDED(hr))
    {
        if (((ACLO_FILESYSONLY & _dwOptions) || (ACLO_FILESYSDIRS & _dwOptions)) &&
            SUCCEEDED(_psf->GetAttributesOf(1, (LPCITEMIDLIST *) &pidl, &dwAttributes)))
        {
            if (!(dwAttributes & (SFGAO_FILESYSANCESTOR | SFGAO_FILESYSTEM)))
            {
                // We reject it because it's not in the file system.
                hr = E_FAIL;        // Skip this item.

                TraceMsg(AC_GENERAL, "ACListISF::_PassesFilter() We are skipping\"%s\" because it doesn't match the filter", pszName);
            }
            else
            {
                if ((ACLO_FILESYSDIRS & _dwOptions) && !PathIsDirectory(pszName))
                {
                    hr = E_FAIL;        // Skip this item since it's not a directory
                }
            }
        }
    }

    return hr;
}


HRESULT CACLIShellFolder::_Init(void)
{
    HRESULT hr = S_OK;

    if (!_pshuLocation)
    {
        _pshuLocation = new CShellUrl();
        if (!_pshuLocation)
            return E_OUTOFMEMORY;

    }

    return hr;
}


HRESULT CACLIShellFolder::_SetLocation(LPCITEMIDLIST pidl)
{
    HRESULT hr;

    // Free old location
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_psf);

    // Set to new location (Valid if NULL)
    Pidl_Set(&_pidl, pidl);
    if (_pidl)
    {
        hr = IEBindToObject(_pidl, &_psf);
        if (SUCCEEDED(hr))
        {
            DWORD grfFlags = (_fShowHidden ? SHCONTF_INCLUDEHIDDEN : 0) |
                             SHCONTF_FOLDERS | SHCONTF_NONFOLDERS;

            hr = IShellFolder_EnumObjects(_psf, NULL, grfFlags, &_peidl);
            if (hr != S_OK) 
            {
                hr = E_FAIL;    // S_FALSE -> empty enumerator
            }
        }
    }
    else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr))
    {
        // Clear if we could not get all the info
        ATOMICRELEASE(_peidl);
        ATOMICRELEASE(_psf);
        Pidl_Set(&_pidl, NULL);
    }

    //
    // NOTE: This is necessary because this memory is alloced in a ACBG thread, but not
    //       freed until the next call to Reset() or the destructor, which will 
    //       happen in the main thread or another ACBG thread.
    //
    return hr;
}


HRESULT CACLIShellFolder::_TryNextPath(void)
{
    HRESULT hr = S_FALSE;
    if (0 == _nPathIndex)
    {
        _nPathIndex = 1;
        if (_pidlCWD && IsFlagSet(_dwOptions, ACLO_CURRENTDIR))
        {
            hr = _SetLocation(_pidlCWD);
            if (SUCCEEDED(hr))
            {
                goto done;
            }
        }
    }

    if (1 == _nPathIndex)
    {
        _nPathIndex = 2;
        if(IsFlagSet(_dwOptions, ACLO_DESKTOP))
        {
            //  we used to autocomplete g_pidlRoot in the rooted explorer
            //  case, but this was a little weird.  if we want to add this,
            //  we should add ACLO_ROOTED or something.
            
            //  use the desktop...
            hr = _SetLocation(&s_idlNULL);
            if (SUCCEEDED(hr))
            {
                goto done;
            }
        }
    }

    if (2 == _nPathIndex)
    {
        _nPathIndex = 3;
        if (IsFlagSet(_dwOptions, ACLO_MYCOMPUTER))
        {
            LPITEMIDLIST pidlMyComputer;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_DRIVES, &pidlMyComputer)))
            {
                hr = _SetLocation(pidlMyComputer);
                ILFree(pidlMyComputer);
                if (SUCCEEDED(hr))
                {
                    goto done;
                }
            }
        }
    }

    // Also search favorites
    if (3 == _nPathIndex)
    {
        _nPathIndex = 4;
        if (IsFlagSet(_dwOptions, ACLO_FAVORITES))
        {
            LPITEMIDLIST pidlFavorites;
            if (SUCCEEDED(SHGetSpecialFolderLocation(NULL, CSIDL_FAVORITES, &pidlFavorites)))
            {
                hr = _SetLocation(pidlFavorites);
                ILFree(pidlFavorites);
                if (SUCCEEDED(hr))
                {
                    goto done;
                }
            }
        }
    }

    if (FAILED(hr))
        hr = S_FALSE;  // This is how we want our errors returned.

done:

    return hr;
}


//================================
// *** IShellService Interface ***

/****************************************************\
    FUNCTION: SetOwner

    DESCRIPTION:
        Update the connection to the Browser window so
    we can always get the PIDL of the current location.
\****************************************************/
HRESULT CACLIShellFolder::SetOwner(IUnknown* punkOwner)
{
    HRESULT hr = S_OK;
    IBrowserService * pbs = NULL;

    ATOMICRELEASE(_pbs);

    if (punkOwner)
        hr = punkOwner->QueryInterface(IID_IBrowserService, (LPVOID *) &pbs);

    if (EVAL(SUCCEEDED(hr)))
        _pbs = pbs;

    return S_OK;
}


/* Constructor / Destructor / CreateInstance */

CACLIShellFolder::CACLIShellFolder()
{
    DllAddRef();
    ASSERT(!_peidl);
    ASSERT(!_psf);
    ASSERT(!_pbs);
    ASSERT(!_pidl);
    ASSERT(!_pidlCWD);
    ASSERT(!_fExpand);
    ASSERT(!_pshuLocation);
    ASSERT(0==_szExpandStr[0]);

    _cRef = 1;

    // Default search paths
    _dwOptions = ACLO_CURRENTDIR | ACLO_MYCOMPUTER;
}

CACLIShellFolder::~CACLIShellFolder()
{
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_psf);
    ATOMICRELEASE(_pbs);

    Pidl_Set(&_pidl, NULL);
    Pidl_Set(&_pidlCWD, NULL);
    Pidl_Set(&_pidlInFolder, NULL);

    if (_pshuLocation)
        delete _pshuLocation;
    DllRelease();
}

HRESULT CACLIShellFolder_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CACLIShellFolder *paclSF = new CACLIShellFolder();
    if (paclSF)
    {
        *ppunk = SAFECAST(paclSF, IEnumString *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclmulti.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLMULTI_H_
#define _ACLMULTI_H_

//
// CACLMulti is an AutoComplete List that simply contains
// other AutoComplete Lists.  Objects are added via IObjMgr
// methods, and each IEnumString method is
// just passed on to each sub list in turn.
//

class CACLMulti
                : public IEnumACString
                , public IObjMgr
                , public IACList
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt);
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum);

    // *** IEnumACString **
    virtual STDMETHODIMP NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex);
    virtual STDMETHODIMP SetEnumOptions(DWORD dwOptions) { return E_NOTIMPL; };
    virtual STDMETHODIMP GetEnumOptions(DWORD *pdwOptions) { return E_NOTIMPL; };

    // *** IObjMgr ***
    virtual STDMETHODIMP Append(IUnknown *punk);
    virtual STDMETHODIMP Remove(IUnknown *punk);

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand);

protected:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLMulti(void);
    ~CACLMulti(void);

    // Instance creator
    friend HRESULT CACLMulti_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
    friend HRESULT CACLMulti_Create(IEnumString **ppenum, CACLMulti * paclMultiToCopy);

    // Private variables
    DWORD   _cRef;          // COM reference count
    int     _iSubList;      // Current sublist for Next() operations
    HDSA    _hdsa;          // HDSA of sublists

    // Private methods
    static int _FreeListItem(LPVOID p, LPVOID d);
};

#endif // _ACLMULTI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclmru.cpp ===
/* Copyright 1996-1997 Microsoft */


#include <priv.h>
#include "sccls.h"
#include "aclisf.h"
#include "shellurl.h"

#define AC_GENERAL          TF_GENERAL + TF_AUTOCOMPLETE

//
// CACLMRU -- An AutoComplete List COM object that
//                  enumerates the Type-in MRU.
//


class CACLMRU
                : public IEnumString
                , public IACList
                , public IACLCustomMRU
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand) {return E_NOTIMPL;}

    // *** IACLCustomMRU ***
    virtual STDMETHODIMP Initialize(LPCWSTR pszMRURegKey, DWORD dwMax);
    virtual STDMETHODIMP AddMRUString(LPCWSTR pszEntry);
    
private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLMRU();
    ~CACLMRU(void);

    // Instance creator
    friend HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);
    friend HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU);
    friend HRESULT CACLCustomMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD           m_cRef;      // COM reference count
    HKEY            m_hKey;      // HKey of MRU Location
    BOOL            m_bBackCompat; //  true for run dialog and address bar
    DWORD           m_nMRUIndex; // Current Index into MRU
    DWORD           m_dwRunMRUSize;
    HANDLE          m_hMRU;
};

/* IUnknown methods */

HRESULT CACLMRU::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CACLMRU, IEnumString), 
        QITABENT(CACLMRU, IACList), 
        QITABENT(CACLMRU, IACLCustomMRU),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACLMRU::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}

ULONG CACLMRU::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

HRESULT CACLMRU::Reset(void)
{
    TraceMsg(AC_GENERAL, "CACLMRU::Reset()");
    m_nMRUIndex = 0;

    return S_OK;
}


HRESULT CACLMRU::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    TCHAR szMRUEntry[MAX_URL_STRING+1];
    LPWSTR pwzMRUEntry = NULL;

    *pceltFetched = 0;
    if (!celt)
        return S_OK;

    if (!rgelt)
        return S_FALSE;

    if (!m_hMRU)
    {
        hr = GetMRUEntry(m_hKey, m_nMRUIndex++, szMRUEntry, SIZECHARS(szMRUEntry), NULL);
        if (S_OK != hr)
        {
            hr = S_FALSE; // This will indicate that no more items are in the list.
        }
    }
    else
    {
        hr = S_FALSE;
        if (m_nMRUIndex < m_dwRunMRUSize && EnumMRUList(m_hMRU, m_nMRUIndex++, szMRUEntry, ARRAYSIZE(szMRUEntry)) > 0)
        {
            if (m_bBackCompat)
            {
                // old MRU format has a slash at the end with the show cmd
                LPTSTR pszField = StrRChr(szMRUEntry, NULL, TEXT('\\'));
                if (pszField)
                    pszField[0] = TEXT('\0');
            }
            hr = S_OK;
        }
    }

    if (S_OK == hr)
    {
        hr = SHStrDup(szMRUEntry, rgelt);
        if (SUCCEEDED(hr))
            *pceltFetched = 1;
    }

    return hr;
}

/* Constructor / Destructor / CreateInstance */
CACLMRU::CACLMRU() : m_cRef(1), m_bBackCompat(TRUE)
{
    DllAddRef();
    // Require object to be in heap and Zero-Inited
    ASSERT(!m_hKey);
    ASSERT(!m_nMRUIndex);
    ASSERT(!m_hMRU);
}

CACLMRU::~CACLMRU()
{
    if (m_hKey)
        RegCloseKey(m_hKey);

    if (m_hMRU)
        FreeMRUList(m_hMRU);

    DllRelease();
}

/****************************************************\
    FUNCTION: CACLMRU_CreateInstance

    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  The caller didn't specify which MRU
    list to use, so we default to the TYPE-IN CMD
    MRU, which is used in the Start->Run dialog and
    in AddressBars that are floating or in the Taskbar.
\****************************************************/
HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    return CACLMRU_CreateInstance(punkOuter, ppunk, poi, SZ_REGKEY_TYPEDCMDMRU);
}

/****************************************************\
    FUNCTION: CACLMRU_CreateInstance

    DESCRIPTION:
        This function create an instance of the AutoComplete
    List "MRU".  This will point to either the MRU for
    a browser or for a non-browser (Start->Run or
    the AddressBar in the Taskbar or floating) depending
    on the pszMRU parameter.
\****************************************************/
HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU)
{
    *ppunk = NULL;
    HRESULT hr = E_OUTOFMEMORY;
    BOOL fUseRunDlgMRU = (StrCmpI(pszMRU, SZ_REGKEY_TYPEDCMDMRU) ? FALSE : TRUE);

    CACLMRU *paclSF = new CACLMRU();
    if (paclSF)
    {
        hr = paclSF->Initialize(pszMRU, 26);
        if (SUCCEEDED(hr))
        {
            paclSF->AddRef();
            *ppunk = SAFECAST(paclSF, IEnumString *);
        }
        paclSF->Release();
    }

    return hr;
}

HRESULT CACLCustomMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    *ppunk = NULL;

    CACLMRU *pmru = new CACLMRU();
    if (pmru)
    {
        *ppunk = SAFECAST(pmru, IEnumString *);
        return S_OK;
    }

    return E_OUTOFMEMORY;
}

#define SZ_REGKEY_TYPEDURLMRUW       L"Software\\Microsoft\\Internet Explorer\\TypedURLs"
#define SZ_REGKEY_TYPEDCMDMRUW       L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"

HRESULT CACLMRU::Initialize(LPCWSTR pszMRURegKey, DWORD dwMax)
{
    HRESULT hr = S_OK;
    BOOL bURL = StrCmpIW(pszMRURegKey, SZ_REGKEY_TYPEDURLMRUW) ? FALSE : TRUE;
    
    if (!bURL)
    {
        MRUINFO mi =  {
            SIZEOF(MRUINFO),
            dwMax,
            MRU_CACHEWRITE,
            HKEY_CURRENT_USER,
            pszMRURegKey,
            NULL        // NOTE: use default string compare
                        // since this is a GLOBAL MRU
        };

        m_bBackCompat = StrCmpIW(pszMRURegKey, SZ_REGKEY_TYPEDCMDMRUW) ? FALSE : TRUE;
        m_hMRU = CreateMRUList(&mi);
        if (m_hMRU)
            m_dwRunMRUSize = EnumMRUList(m_hMRU, -1, NULL, 0);
        else
            hr = E_FAIL;
    }
    else
    {
        m_bBackCompat = TRUE;
        if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_CURRENT_USER, pszMRURegKey, 0, NULL, 0, KEY_READ, NULL, &m_hKey, NULL))
            hr = E_FAIL;
    }

    return hr;
}

HRESULT CACLMRU::AddMRUString(LPCWSTR pszEntry)
{
    HRESULT hr = E_FAIL;

    if (m_hMRU)
    {
        if (::AddMRUString(m_hMRU, pszEntry) != -1)
            hr = S_OK;
    }
    //else We don't support saving for address bar MRU

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\acthread.cpp ===
// Copyright 1998 Microsoft

#include "priv.h"
#include "autocomp.h"

#define AC_GIVEUP_COUNT           1000
#define AC_TIMEOUT          (60 * 1000)

//
// Thread messages
//
enum
{
    ACM_FIRST = WM_USER,
    ACM_STARTSEARCH,
    ACM_STOPSEARCH,
    ACM_SETFOCUS,
    ACM_KILLFOCUS,
    ACM_QUIT,
    ACM_LAST,
};


// Special prefixes that we optionally filter out
const struct{
    int cch;
    LPCWSTR psz;
} 
g_rgSpecialPrefix[] =
{
    {4,  L"www."},
    {11, L"http://www."},   // This must be before "http://"
    {7,  L"http://"},
    {8,  L"https://"},
};


//+-------------------------------------------------------------------------
// CACString functions - Hold autocomplete strings
//--------------------------------------------------------------------------
ULONG CACString::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CACString::Release()
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CACString* CreateACString(LPCWSTR pszStr, int iIgnore, ULONG ulSortIndex)
{
    ASSERT(pszStr);

    int cChars = lstrlen(pszStr);

    // Allocate the CACString class with enough room for the new string
    CACString* pStr = (CACString*)LocalAlloc(LPTR, cChars * sizeof(WCHAR) + sizeof(CACString));
    if (pStr)
    {
        StringCchCopy(pStr->m_sz, cChars + sizeof(CACString)/sizeof(WCHAR), pszStr);

        pStr->m_ulSortIndex = ulSortIndex;
        pStr->m_cRef  = 1;
        pStr->m_cChars      = cChars;
        pStr->m_iIgnore     = iIgnore;
    }
    return pStr;
}

int CACString::CompareSortingIndex(CACString& r)
{
    int iRet;

    // If the sorting indices are equal, just do a string compare
    if (m_ulSortIndex == r.m_ulSortIndex)
    {
        iRet = StrCmpI(r);
    }
    else
    {
        iRet = (m_ulSortIndex > r.m_ulSortIndex) ? 1 : -1;
    }

    return iRet;
}

HRESULT CACThread::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = { { 0 }, };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CACThread::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CACThread::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

CACThread::CACThread(CAutoComplete& rAutoComp) : m_pAutoComp(&rAutoComp), m_cRef(1)
{
    ASSERT(!m_fWorkItemQueued); 
    ASSERT(!m_idThread);
    ASSERT(!m_hCreateEvent);  
    ASSERT(!m_fDisabled); 
    ASSERT(!m_pszSearch);   
    ASSERT(!m_hdpa_list);    
    ASSERT(!m_pes);
    ASSERT(!m_pacl);

    DllAddRef();
}

CACThread::~CACThread()
{
    SyncShutDownBGThread();  // In case somehow

    // These should have been freed.
    ASSERT(!m_idThread);
    ASSERT(!m_hdpa_list);

    SAFERELEASE(m_pes);
    SAFERELEASE(m_peac);
    SAFERELEASE(m_pacl);

    DllRelease();
}

BOOL CACThread::Init(IEnumString* pes,   // source of the autocomplete strings
                     IACList* pacl)      // optional interface to call Expand
{
    // REARCHITECT: We need to marshal these interfaces to this thread!
    ASSERT(pes);
    m_pes = pes;
    m_pes->AddRef();

    m_peac = NULL;
    pes->QueryInterface(IID_PPV_ARG(IEnumACString, &m_peac));

    if (pacl)
    {
        m_pacl = pacl;
        m_pacl->AddRef();
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
// Called when the edit box recieves focus. We use this event to create
// a background thread or to keep the backgroung thread from shutting down
//--------------------------------------------------------------------------
void CACThread::GotFocus()
{
    TraceMsg(AC_GENERAL, "CACThread::GotFocus()");

    // Should not be NULL if the foreground thread is calling us!
    ASSERT(m_pAutoComp);

    //
    // Check to see if autocomplete is supposed to be enabled.
    //
    if (m_pAutoComp && m_pAutoComp->IsEnabled())
    {
        m_fDisabled = FALSE;

        if (m_fWorkItemQueued)
        {
            // If the thread hasn't started yet, wait for a thread creation event
            if (0 == m_idThread && m_hCreateEvent)
            {
                WaitForSingleObject(m_hCreateEvent, 1000);
            }

            if (m_idThread)
            {
                //
                // Tell the thread to cancel its timeout and stay alive.
                //
                // REARCHITECT: We have a race condition here.  The thread can be
                // in the process of shutting down!
                PostThreadMessage(m_idThread, ACM_SETFOCUS, 0, 0);
            }
        }
        else
        {
            //
            // The background thread signals an event when it starts up.
            // We wait on this event before trying a synchronous shutdown
            // because any posted messages would be lost.
            //
            if (NULL == m_hCreateEvent)
            {
                m_hCreateEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            }
            else
            {
                ResetEvent(m_hCreateEvent);
            }

            //
            // Make sure we have a background search thread.
            //
            // If we start it any later, we run the risk of not
            // having its message queue available by the time
            // we post a message to it.
            //
            // AddRef ourselves now, to prevent us getting freed
            // before the thread proc starts running.
            //
            AddRef();

            // Call to Shlwapi thread pool
            if (SHQueueUserWorkItem(_ThreadProc,
                                     this,
                                     0,
                                     (DWORD_PTR)NULL,
                                     NULL,
                                     "browseui.dll",
                                     TPS_LONGEXECTIME | TPS_DEMANDTHREAD
                                     ))
            {
                InterlockedExchange(&m_fWorkItemQueued, TRUE);
            }
            else
            {
                // Couldn't get thread
                Release();
            }
        }
    }
    else
    {
        m_fDisabled = TRUE;
        _SendAsyncShutDownMsg(FALSE);
    }
}   

//+-------------------------------------------------------------------------
// Called when the edit box loses focus.
//--------------------------------------------------------------------------
void CACThread::LostFocus()
{
    TraceMsg(AC_GENERAL, "CACThread::LostFocus()");

    //
    // If there is a thread around, tell it to stop searching.
    //
    if (m_idThread)
    {
        StopSearch();
        PostThreadMessage(m_idThread, ACM_KILLFOCUS, 0, 0);
    }
}

//+-------------------------------------------------------------------------
// Sends the search request to the background thread.
//--------------------------------------------------------------------------
BOOL CACThread::StartSearch
(
    LPCWSTR pszSearch,  // String to search
    DWORD dwOptions     // ACO_* flags
)
{
    BOOL fRet = FALSE;

    // If the thread hasn't started yet, wait for a thread creation event
    if (0 == m_idThread && m_fWorkItemQueued && m_hCreateEvent)
    {
        WaitForSingleObject(m_hCreateEvent, 1000);
    }

    if (m_idThread)
    {
        LPWSTR pszSrch = StrDup(pszSearch);
        if (pszSrch)
        {
            //
            // This is being sent to another thread, remove it from this thread's
            // memlist.
            //
            // 
            // If the background thread is already searching, abort that search
            //
            StopSearch();

            //
            // Send request off to the background search thread.
            //
            if (PostThreadMessage(m_idThread, ACM_STARTSEARCH, dwOptions, (LPARAM)pszSrch))
            {
                fRet = TRUE;
            }
            else
            {
                TraceMsg(AC_GENERAL, "CACThread::_StartSearch could not send message to thread!");
                LocalFree(pszSrch);
            }
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Tells the background thread to stop and pending search
//--------------------------------------------------------------------------
void CACThread::StopSearch()
{
    TraceMsg(AC_GENERAL, "CACThread::_StopSearch()");

    //
    // Tell the thread to stop.
    //
    if (m_idThread)
    {
        PostThreadMessage(m_idThread, ACM_STOPSEARCH, 0, 0);
    }
}

//+-------------------------------------------------------------------------
// Posts a quit message to the background thread
//--------------------------------------------------------------------------
void CACThread::_SendAsyncShutDownMsg(BOOL fFinalShutDown)
{
    if (0 == m_idThread && m_fWorkItemQueued && m_hCreateEvent)
    {
        //
        // Make sure that the thread has started up before posting a quit
        // message or the quit message will be lost!
        //
        WaitForSingleObject(m_hCreateEvent, 3000);
    }

    if (m_idThread)
    {
        // Stop the search because it can hold up the thread for quite a
        // while by waiting for disk data.
        StopSearch();

        // Tell the thread to go away, we won't be needing it anymore.  Note that we pass
        // the dropdown window because during the final shutdown we need to asynchronously
        // destroy the dropdown to avoid a crash.  The background thread will keep browseui
        // mapped in memory until the dropdown is destroyed.
        HWND hwndDropDown = (fFinalShutDown ? m_pAutoComp->m_hwndDropDown : NULL);

        PostThreadMessage(m_idThread, ACM_QUIT, 0, (LPARAM)hwndDropDown);
    }
}

//+-------------------------------------------------------------------------
// Synchroniously shutdown the background thread
//
// Note: this is no longer synchronous because we now orphan this object
// when the associated autocomplet shuts down.
// 
//--------------------------------------------------------------------------
void CACThread::SyncShutDownBGThread()
{
    _SendAsyncShutDownMsg(TRUE);

    // Block shutdown if background thread is about to use this variable
    ENTERCRITICAL;
    m_pAutoComp = NULL;
    LEAVECRITICAL;

    if (m_hCreateEvent)
    {
        CloseHandle(m_hCreateEvent);
        m_hCreateEvent = NULL;
    }
}

void CACThread::_FreeThreadData()
{
    if (m_hdpa_list)
    {
        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
        m_hdpa_list = NULL;
    }

    if (m_pszSearch)
    {
        LocalFree(m_pszSearch);
        m_pszSearch = NULL;
    }

    InterlockedExchange(&m_idThread, 0);
    InterlockedExchange(&m_fWorkItemQueued, 0);
}

DWORD WINAPI CACThread::_ThreadProc(void *pv)
{
    CACThread *pThis = (CACThread *)pv;
    HRESULT hrInit = SHCoInitialize();
    if (SUCCEEDED(hrInit))
    {
        pThis->_ThreadLoop();
    }
    pThis->Release();
    SHCoUninitialize(hrInit);

    return 0;
}


HRESULT CACThread::_ProcessMessage(MSG * pMsg, DWORD * pdwTimeout, BOOL * pfStayAlive)
{
    TraceMsg(AC_GENERAL, "AutoCompleteThread: Message %x received.", pMsg->message);

    switch (pMsg->message)
    {
    case ACM_STARTSEARCH:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search started.");
        *pdwTimeout = INFINITE;
        _Search((LPWSTR)pMsg->lParam, (DWORD)pMsg->wParam);
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search completed.");
        break;

    case ACM_STOPSEARCH:
        while (PeekMessage(pMsg, pMsg->hwnd, ACM_STOPSEARCH, ACM_STOPSEARCH, PM_REMOVE))
        {
            NULL;
        }
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search stopped.");
        break;

    case ACM_SETFOCUS:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Got Focus.");
        *pdwTimeout = INFINITE;
        break;

    case ACM_KILLFOCUS:
        TraceMsg(AC_GENERAL, "AutoCompleteThread: Lost Focus.");
        *pdwTimeout = AC_TIMEOUT;
        break;

    case ACM_QUIT:
        {
            TraceMsg(AC_GENERAL, "AutoCompleteThread: ACM_QUIT received.");
            *pfStayAlive = FALSE;

            //
            // If a hwnd was passed in then we are shutting down and we need to
            // wait until the dropdown window is destroyed before exiting this
            // thread.  That way browseui will stay mapped in memory.
            //
            HWND hwndDropDown = (HWND)pMsg->lParam;
            if (hwndDropDown)
            {
                //  We wait 5 seconds for the window to go away, checking every 100ms
                int cSleep = 50;
                while (IsWindow(hwndDropDown) && (--cSleep > 0))
                {
                    MsgWaitForMultipleObjects(0, NULL, FALSE, 100, QS_TIMER);
                }
            }
        }
        break;

    default:
        // pump any ole-based window message that might also be on this thread
        TranslateMessage(pMsg);
        DispatchMessage(pMsg);
        break;
    }

    return S_OK;
}


//+-------------------------------------------------------------------------
// Message pump for the background thread
//--------------------------------------------------------------------------
HRESULT CACThread::_ThreadLoop()
{
    MSG Msg;
    DWORD dwTimeout = INFINITE;
    BOOL fStayAlive = TRUE;

    TraceMsg(AC_WARNING, "AutoComplete service thread started.");

    //
    // We need to call a window's api for a message queue to be created
    // so we call peekmessage.  Then we get the thread id and thread handle
    // and we signal an event to tell the forground thread that we are listening.
    //
    while (PeekMessage(&Msg, NULL, ACM_FIRST, ACM_LAST, PM_REMOVE))
    {
        // purge any messages we care about from previous owners of this thread.
    }

    // The forground thread needs this is so that it can post us messages
    InterlockedExchange(&m_idThread, GetCurrentThreadId());

    if (m_hCreateEvent)
    {
        SetEvent(m_hCreateEvent);
    }

    HANDLE hThread = GetCurrentThread();
    int nOldPriority = GetThreadPriority(hThread);
    SetThreadPriority(hThread, THREAD_PRIORITY_BELOW_NORMAL);

    while (fStayAlive)
    {
        while (fStayAlive && PeekMessage(&Msg, NULL, 0, (UINT)-1, PM_NOREMOVE))
        {
            if (-1 != GetMessage(&Msg, NULL, 0, 0))
            {
                if (!Msg.hwnd)
                {
                    // No hwnd means it's a thread message, so it's ours.
                    _ProcessMessage(&Msg, &dwTimeout, &fStayAlive);
                }
                else
                {
                    // It has an hwnd then it's not ours.  We will not allow windows on our thread.
                    // If anyone creates their windows on their thread, file a bug against them
                    // to remove it.
                }
            }
        }

        if (fStayAlive)
        {
            TraceMsg(AC_GENERAL, "AutoCompleteThread: Sleeping for%s.", dwTimeout == INFINITE ? "ever" : " one minute");
            DWORD dwWait = MsgWaitForMultipleObjects(0, NULL, FALSE, dwTimeout, QS_ALLINPUT);
#ifdef DEBUG
            switch (dwWait)
            {
            case 0xFFFFFFFF:
                ASSERT(dwWait != 0xFFFFFFFF);
                break;

            case WAIT_TIMEOUT:
                TraceMsg(AC_GENERAL, "AutoCompleteThread: Timeout expired.");
                break;
            }
#endif
            fStayAlive = (dwWait == WAIT_OBJECT_0);
        }
    }

    TraceMsg(AC_GENERAL, "AutoCompleteThread: Thread dying.");

    _FreeThreadData();
    SetThreadPriority(hThread, nOldPriority);


    // Purge any remaining messages before returning this thread to the pool.
    while (PeekMessage(&Msg, NULL, ACM_FIRST, ACM_LAST, PM_REMOVE))
    {}

    TraceMsg(AC_WARNING, "AutoCompleteThread: Thread dead.");
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns true if the search string matches one or more characters of a
// prefix that we filter out matches to
//--------------------------------------------------------------------------
BOOL CACThread::MatchesSpecialPrefix(LPCWSTR pszSearch)
{
    BOOL fRet = FALSE;
    int cchSearch = lstrlen(pszSearch);
    for (int i = 0; i < ARRAYSIZE(g_rgSpecialPrefix); ++i)
    {
        // See if the search string matches one or more characters of the prefix
        if (cchSearch <= g_rgSpecialPrefix[i].cch && 
            StrCmpNI(g_rgSpecialPrefix[i].psz, pszSearch, cchSearch) == 0)
        {
            fRet = TRUE;
            break;
        }
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Returns the length of the prefix it the string starts with a special
// prefix that we filter out matches to.  Otherwise returns zero.
//--------------------------------------------------------------------------
int CACThread::GetSpecialPrefixLen(LPCWSTR psz)
{
    int nRet = 0;
    int cch = lstrlen(psz);
    for (int i = 0; i < ARRAYSIZE(g_rgSpecialPrefix); ++i)
    {
        if (cch >= g_rgSpecialPrefix[i].cch && 
            StrCmpNI(g_rgSpecialPrefix[i].psz, psz, g_rgSpecialPrefix[i].cch) == 0)
        {
            nRet = g_rgSpecialPrefix[i].cch;
            break;
        }
    }
    return nRet;
}

//+-------------------------------------------------------------------------
// Returns the next autocomplete string
//--------------------------------------------------------------------------
HRESULT CACThread::_Next(LPWSTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    ASSERT(pulSortIndex);

    HRESULT hr;

    // Use the new interface if we have it
    if (m_peac)
    {
        hr = m_peac->NextItem(pszUrl, cchMax, pulSortIndex);
    }

    // Fall back to the old IEnumString interface
    else
    {
        LPWSTR pszNext;
        ULONG ulFetched;

        hr = m_pes->Next(1, &pszNext, &ulFetched);
        if (S_OK == hr)
        {
            StringCchCopy(pszUrl, cchMax, pszNext);
            if (pulSortIndex)
            {
                *pulSortIndex = 0;
            }
            CoTaskMemFree(pszNext);
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
// Searches for items that match pszSearch.
//--------------------------------------------------------------------------
void CACThread::_Search
(
    LPWSTR pszSearch,   // String to search for (we must free this)
    DWORD dwOptions     // ACO_* flags
)
{
    if (pszSearch)
    {
        TraceMsg(AC_GENERAL, "CACThread(BGThread)::_Search(pszSearch=0x%x)", pszSearch);

        // Save the search string in our thread data so it is still freed if this thread is killed
        m_pszSearch = pszSearch;

        // If we were passed a wildcard string, then everything matches
        BOOL fWildCard = ((pszSearch[0] == CH_WILDCARD) && (pszSearch[1] == L'\0'));

        // To avoid huge number of useless matches, avoid matches
        // to common prefixes
        BOOL fFilter = (dwOptions & ACO_FILTERPREFIXES) && MatchesSpecialPrefix(pszSearch);
        BOOL fAppendOnly = IsFlagSet(dwOptions, ACO_AUTOAPPEND) && IsFlagClear(dwOptions, ACO_AUTOSUGGEST);

        if (m_pes)    // paranoia
        {
            // If this fails, the m_pes->Next() will likely do something
            // bad, so we will avoid it altogether.
            if (SUCCEEDED(m_pes->Reset()))
            {
                BOOL fStopped = FALSE;
                m_dwSearchStatus = 0;

                _DoExpand(pszSearch);
                int cchSearch = lstrlen(pszSearch);

                WCHAR szUrl[MAX_URL_STRING];
                ULONG ulSortIndex;

                while (!fStopped && IsFlagClear(m_dwSearchStatus, SRCH_LIMITREACHED) &&
                       (_Next(szUrl, ARRAYSIZE(szUrl), &ulSortIndex) == S_OK))
                {
                    //
                    // First check for a simple match
                    //
                    if (fWildCard ||
                        (StrCmpNI(szUrl, pszSearch, cchSearch) == 0) &&

                        // Filter out matches to common prefixes
                        (!fFilter || GetSpecialPrefixLen(szUrl) == 0))
                    {
                        _AddToList(szUrl, 0, ulSortIndex);
                    }

                    // If the dropdown is enabled, check for matches after common prefixes.
                    if (!fAppendOnly)
                    {
                        //
                        // Also check for a match if we skip the protocol. We
                        // assume that szUrl has been cononicalized (protocol
                        // in lower case).
                        //
                        LPCWSTR psz = szUrl;
                        if (StrCmpN(szUrl, L"http://", 7) == 0) 
                        {
                            psz += 7;
                        }
                        if (StrCmpN(szUrl, L"https://", 8) == 0 ||
                            StrCmpN(szUrl, L"file:///", 8) == 0)
                        {
                            psz += 8;
                        }

                        if (psz != szUrl &&
                            StrCmpNI(psz, pszSearch, cchSearch) == 0 &&

                            // Filter out "www." prefixes
                            (!fFilter || GetSpecialPrefixLen(psz) == 0))
                        {
                            _AddToList(szUrl, (int)(psz - szUrl), ulSortIndex);
                        }

                        //
                        // Finally check for a match if we skip "www." after
                        // the optional protocol
                        //
                        if (StrCmpN(psz, L"www.", 4) == 0 &&
                            StrCmpNI(psz + 4, pszSearch, cchSearch) == 0)
                        {
                            _AddToList(szUrl, (int)(psz + 4 - szUrl), ulSortIndex);
                        }
                    }

                    // Check to see if the search was canceled
                    MSG msg;
                    fStopped = PeekMessage(&msg, NULL, ACM_STOPSEARCH, ACM_STOPSEARCH, PM_NOREMOVE);
    #ifdef DEBUG
    fStopped = FALSE;
                    if (fStopped)
                        TraceMsg(AC_GENERAL, "AutoCompleteThread: Search TERMINATED");
    #endif
                }

                if (fStopped)
                {
                    // Search aborted so free the results
                    if (m_hdpa_list)
                    { 
                        // clear the list
                        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
                        m_hdpa_list = NULL;
                    }
                }
                else
                {
                    //
                    // Sort the results and remove duplicates
                    //
                    if (m_hdpa_list)
                    {
                        DPA_Sort(m_hdpa_list, _DpaCompare, 0);

                        //
                        // Perge duplicates. 
                        //
                        for (int i = DPA_GetPtrCount(m_hdpa_list) - 1; i > 0; --i)
                        {
                            CACString& rStr1 = *(CACString*)DPA_GetPtr(m_hdpa_list, i-1);
                            CACString& rStr2 = *(CACString*)DPA_GetPtr(m_hdpa_list, i);

                            // Since URLs are case sensitive, we can't ignore case.                    
                            if (rStr1.StrCmpI(rStr2) == 0)
                            {
                                // We have a match, so keep the longest string.
                                if (rStr1.GetLength() > rStr2.GetLength())
                                {
                                    // Use the smallest sort index
                                    if (rStr2.GetSortIndex() < rStr1.GetSortIndex())
                                    {
                                        rStr1.SetSortIndex(rStr2.GetSortIndex());
                                    }
                                    DPA_DeletePtr(m_hdpa_list, i);
                                    rStr2.Release();
                                }
                                else
                                {
                                    // Use the smallest sort index
                                    if (rStr1.GetSortIndex() < rStr2.GetSortIndex())
                                    {
                                        rStr2.SetSortIndex(rStr1.GetSortIndex());
                                    }
                                    DPA_DeletePtr(m_hdpa_list, i-1);
                                    rStr1.Release();
                                }
                            }
                            else
                            {
                                //
                                // Special case: If this is a web site and the entries
                                // are identical except one has an extra slash on the end
                                // from a redirect, remove the redirected one.
                                //
                                int cch1 = rStr1.GetLengthToCompare();
                                int cch2 = rStr2.GetLengthToCompare();
                                int cchDiff = cch1 - cch2;

                                if (
                                    // Length must differ by one
                                    (cchDiff == 1 || cchDiff == -1) &&

                                    // One string must have a terminating slash
                                    ((cch1 > 0 && rStr1[rStr1.GetLength() - 1] == L'/') ||
                                     (cch2 > 0 && rStr2[rStr2.GetLength() - 1] == L'/')) &&

                                    // Must be a web site
                                    ((StrCmpN(rStr1, L"http://", 7) == 0 || StrCmpN(rStr1, L"https://", 8) == 0) ||
                                     (StrCmpN(rStr2, L"http://", 7) == 0 || StrCmpN(rStr2, L"https://", 8) == 0)) &&

                                    // Must be identical up to the slash (ignoring prefix)
                                    StrCmpNI(rStr1.GetStrToCompare(), rStr2.GetStrToCompare(), (cchDiff > 0) ? cch2 : cch1) == 0)
                                {
                                    // Remove the longer string with the extra slash
                                    if (cchDiff > 0)
                                    {
                                        // Use the smallest sort index
                                        if (rStr1.GetSortIndex() < rStr2.GetSortIndex())
                                        {
                                            rStr2.SetSortIndex(rStr1.GetSortIndex());
                                        }
                                        DPA_DeletePtr(m_hdpa_list, i-1);
                                        rStr1.Release();
                                    }
                                    else
                                    {
                                        // Use the smallest sort index
                                        if (rStr2.GetSortIndex() < rStr1.GetSortIndex())
                                        {
                                            rStr1.SetSortIndex(rStr2.GetSortIndex());
                                        }
                                        DPA_DeletePtr(m_hdpa_list, i);
                                        rStr2.Release();
                                    }
                                }
                            }
                        }
                    }

                    // Pass the results to the foreground thread
                    ENTERCRITICAL;
                    if (m_pAutoComp)
                    {
                        HWND hwndEdit = m_pAutoComp->m_hwndEdit;
                        UINT uMsgSearchComplete = m_pAutoComp->m_uMsgSearchComplete;
                        LEAVECRITICAL;

                        // Unix loses keys if we post the message, so we send the message
                        // outside our critical section
                        SendMessage(hwndEdit, uMsgSearchComplete, m_dwSearchStatus, (LPARAM)m_hdpa_list);
                    }
                    else
                    {
                        LEAVECRITICAL;

                        // We've been orphaned, so free the list and bail
                        CAutoComplete::_FreeDPAPtrs(m_hdpa_list);
                    }

                    // The foreground thread owns the list now
                    m_hdpa_list = NULL;
                }
            } 
            else
            {
                ASSERT(0);    // m_pes->Reset Failed!!
            }
        }

        // We must free the search string
        m_pszSearch = NULL;

        // Note if the thread is killed here, we leak the string
        // but at least we will not try to free it twice (which is worse)
        // because we nulled m_pszSearch first.
        LocalFree(pszSearch);
    }
}

//+-------------------------------------------------------------------------
// Used to sort items alphabetically
//--------------------------------------------------------------------------
int CALLBACK CACThread::_DpaCompare(void *p1, void *p2, LPARAM lParam)
{
    CACString* ps1 = (CACString*)p1;
    CACString* ps2 = (CACString*)p2;

    return ps1->StrCmpI(*ps2);
}


//+-------------------------------------------------------------------------
// Adds a string to our HDPA.  Returns TRUE is successful.
//--------------------------------------------------------------------------
BOOL CACThread::_AddToList
(
    LPTSTR pszUrl,    // string to add
    int cchMatch,     // offset into string where the match occurred
    ULONG ulSortIndex // controls order of items displayed
)
{
    TraceMsg(AC_GENERAL, "CACThread(BGThread)::_AddToList(pszUrl = %s)", 
        (pszUrl ? pszUrl : TEXT("(null)")));

    BOOL fRet = TRUE;

    //
    // Create a new list if necessary.
    //
    if (!m_hdpa_list)
    {
        m_hdpa_list = DPA_Create(AC_LIST_GROWTH_CONST);
    }

    if (m_hdpa_list && DPA_GetPtrCount(m_hdpa_list) < AC_GIVEUP_COUNT)
    {
        CACString* pStr = CreateACString(pszUrl, cchMatch, ulSortIndex);
        if (pStr)
        {
            if (DPA_AppendPtr(m_hdpa_list, pStr) == -1)
            {
                pStr->Release();
                m_dwSearchStatus |= SRCH_LIMITREACHED;
                fRet = FALSE;
            }

            // If we have a nonzero sort index, the forground thread will need
            // to use it to order the results
            else if (ulSortIndex)
            {
                m_dwSearchStatus |= SRCH_USESORTINDEX;
            }
        }
    }
    else
    {
        m_dwSearchStatus |= SRCH_LIMITREACHED;
        fRet = FALSE;
    }

    return fRet;
}

//+-------------------------------------------------------------------------
// This function will attempt to use the autocomplete list to bind to a
// location in the Shell Name Space. If that succeeds, the AutoComplete List
// will then contain entries which are the display names in that ISF.
//--------------------------------------------------------------------------
void CACThread::_DoExpand(LPCWSTR pszSearch)
{
    LPCWSTR psz;

    if (!m_pacl)
    {
        //
        // Doesn't support IAutoComplete, doesn't have Expand method.
        //
        return;
    }

    if (*pszSearch == 0)
    {
        //
        // No string means no expansion necessary.
        //
        return;
    }

    //
    // psz points to last character.
    //
    psz = pszSearch + lstrlen(pszSearch);
    psz = CharPrev(pszSearch, psz);

    //
    // Search backwards for an expand break character.
    //
    while (psz != pszSearch && *psz != TEXT('/') && *psz != TEXT('\\'))
    {
        psz = CharPrev(pszSearch, psz);
    }

    if (*psz == TEXT('/') || *psz == TEXT('\\'))
    {
        SHSTR ss;

        psz++;
        if (SUCCEEDED(ss.SetStr(pszSearch)))
        {
            //
            // Trim ss so that it contains everything up to the last
            // expand break character.
            //
            LPTSTR pszTemp = ss.GetInplaceStr();

            pszTemp[psz - pszSearch] = TEXT('\0');

            //
            // Call expand on the string.
            //
            m_pacl->Expand(ss);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclisf.h ===
/* Copyright 1996 Microsoft */

#ifndef _ACLISF_H_
#define _ACLISF_H_

#include "shellurl.h"

class CACLIShellFolder
                : public IEnumString
                , public IACList2
                , public ICurrentWorkingDirectory
                , public IShellService
                , public IPersistFolder
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IEnumString ***
    virtual STDMETHODIMP Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched);
    virtual STDMETHODIMP Skip(ULONG celt) {return E_NOTIMPL;}
    virtual STDMETHODIMP Reset(void);
    virtual STDMETHODIMP Clone(IEnumString **ppenum) {return E_NOTIMPL;}

    // *** IACList ***
    virtual STDMETHODIMP Expand(LPCOLESTR pszExpand);

    // *** IACList2 ***
    virtual STDMETHODIMP SetOptions(DWORD dwFlag);
    virtual STDMETHODIMP GetOptions(DWORD* pdwFlag);

    // *** ICurrentWorkingDirectory ***
    virtual STDMETHODIMP GetDirectory(LPWSTR pwzPath, DWORD cchSize) {return E_NOTIMPL;};
    virtual STDMETHODIMP SetDirectory(LPCWSTR pwzPath);

    // *** IPersistFolder ***
    virtual STDMETHODIMP Initialize(LPCITEMIDLIST pidl);        // Save as SetDirectory() but for pidls
    virtual STDMETHODIMP GetClassID(CLSID *pclsid);

    // *** IShellService ***
    virtual STDMETHODIMP SetOwner(IUnknown* punkOwner);


private:
    // Constructor / Destructor (protected so we can't create on stack)
    CACLIShellFolder();
    ~CACLIShellFolder(void);

    HRESULT _SetLocation(LPCITEMIDLIST pidl);
    HRESULT _TryNextPath(void);
    HRESULT _Init(void);
    BOOL _SkipForPerf(LPCWSTR pwzExpand);
    HRESULT _PassesFilter(LPCITEMIDLIST pidl, LPWSTR pszName, DWORD cchSize);
    HRESULT _GetNextWrapper(LPWSTR pszName, DWORD cchSize);
    HRESULT _GetPidlName(LPCITEMIDLIST pidl, BOOL fUsingCachePidl, LPWSTR pszName, DWORD cchSize);

    // Instance creator
    friend HRESULT CACLIShellFolder_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    // Private variables
    DWORD           _cRef;          // COM reference count
    IEnumIDList*    _peidl;         // PIDL enumerator
    IShellFolder*   _psf;           // Shell folder
    IBrowserService* _pbs;          // Browser Service to find Current Location in Shell Name Space.
    LPITEMIDLIST    _pidl;          // PIDL of current directory.
    LPITEMIDLIST    _pidlCWD;       // PIDL of current working directory. 
    LPITEMIDLIST    _pidlInFolder;  // Sometimes the user string matches SHGDN_INFOLDER, but not (SHGDN_INFOLDER | SHGDN_FORPARSING).  My Computer for example.
    BOOL            _fExpand;       // Are we expanding?
    TCHAR           _szExpandStr[ MAX_PATH ];  // String we are expanding
    CShellUrl *     _pshuLocation; 
    int             _nPathIndex; 
    DWORD           _dwOptions;     // ACLO_* flags
    BOOL            _fShowHidden;   // Enumerate hidden files?
//    BOOL            _fShowSysFiles; // Enumerate system files?
};

#endif // _ACLISF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aclmulti.cpp ===
/* Copyright 1996 Microsoft */

#include <priv.h>
#include "sccls.h"
#include "aclmulti.h"

//
// CACLMulti -- An AutoComplete List COM object that
//                  contains other AutoComplete Lists and
//                  has them do all the work.
//

struct _tagListItem
{
    IUnknown        *punk;
    IEnumString     *pes;
    IEnumACString   *peacs;
    IACList         *pacl;
};
typedef struct _tagListItem LISTITEM;

#define MULTILIST_GROWTH_CONST 8

/* IUnknown methods */

HRESULT CACLMulti::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IEnumString))
    {
        *ppvObj = SAFECAST(this, IEnumString*);
    }
    else if (IsEqualIID(riid, IID_IEnumACString))
    {
        *ppvObj = SAFECAST(this, IEnumACString*);
    }
    else if (IsEqualIID(riid, IID_IObjMgr))
    {
        *ppvObj = SAFECAST(this, IObjMgr*);
    }
    else if (IsEqualIID(riid, IID_IACList))
    {
        *ppvObj = SAFECAST(this, IACList*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CACLMulti::AddRef(void)
{
    _cRef++;
    return _cRef;
}

ULONG CACLMulti::Release(void)
{
    ASSERT(_cRef > 0);

    _cRef--;

    if (_cRef > 0)
    {
        return _cRef;
    }

    delete this;
    return 0;
}

/* IEnumString methods */

HRESULT CACLMulti::Next(ULONG celt, LPOLESTR *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_FALSE;    // nothing found... stop

    *pceltFetched = 0;

    if (celt == 0)
    {
        return S_OK;
    }

    if (!rgelt)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr) && _hdsa)
    {
        //
        // Keep calling Next() starting with the current list
        // until somebody returns something.
        //
        for( ; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;

            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                hr = li.pes->Next(1, rgelt, pceltFetched);
                if (hr == S_OK)
                    break;

                if (FAILED(hr))  // Why is the caller failing? 
                    hr = S_FALSE;   // Probably because it failed to conntect to the source (ftp)
            }
        }
    }
    ASSERT(SUCCEEDED(hr));

    return hr;
}

HRESULT CACLMulti::Skip(ULONG)
{
    return E_NOTIMPL;
}

HRESULT CACLMulti::Reset(void)
{
    HRESULT hr = S_OK;
    TraceMsg(TF_BAND|TF_GENERAL, "ACLMulti::Reset() Beginning");

    if (_hdsa)
    {
        // Call Reset() on each sublist.
        for (_iSubList=0; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;
            
            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                hr = li.pes->Reset();
                if (FAILED(hr))
                    break;
            }
        }
    }

    // Reset ourselves to point to the first list.
    _iSubList = 0;

    return hr;
}

HRESULT CACLMulti::Clone(IEnumString **ppenum)
{
    return CACLMulti_Create(ppenum, this);
}

// IEnumAutocomplete methods
HRESULT CACLMulti::NextItem(LPOLESTR pszUrl, ULONG cchMax, ULONG* pulSortIndex)
{
    HRESULT hr = S_FALSE;    // nothing found... stop

    if (!pszUrl)
    {
        hr = E_FAIL;
    }

    if (SUCCEEDED(hr) && _hdsa)
    {
        //
        // Keep calling Next() starting with the current list
        // until somebody returns something.
        //
        for( ; _iSubList < DSA_GetItemCount(_hdsa); _iSubList++)
        {
            LISTITEM li;

            if ((DSA_GetItem(_hdsa, _iSubList, &li) != -1) && (li.pes != NULL))
            {
                // Use the IEnumACString interface if we have it
                if (NULL != li.peacs)
                {
                    hr = li.peacs->NextItem(pszUrl, cchMax, pulSortIndex);
                }

                // Fall back to the old IEnumString interface
                else
                {
                    LPWSTR pszNext;
                    ULONG ulFetched;

                    hr = li.pes->Next(1, &pszNext, &ulFetched);
                    if (S_OK == hr)
                    {
                        StringCchCopy(pszUrl, cchMax, pszNext);
                        if (pulSortIndex)
                        {
                            *pulSortIndex = 0;
                        }
                        CoTaskMemFree(pszNext);
                    }
                }
                if (hr == S_OK)
                    break;

                if (FAILED(hr))  // Why is the caller failing? 
                    hr = S_FALSE;   // Probably because it failed to conntect to the source (ftp)
            }
        }
    }
    ASSERT(SUCCEEDED(hr));

    return hr;
}

/* IObjMgr methods */

HRESULT CACLMulti::Append(IUnknown *punk)
{
    HRESULT hr = E_FAIL;

    if (punk)
    {
        if (!_hdsa)
        {
            _hdsa = DSA_Create(SIZEOF(LISTITEM), MULTILIST_GROWTH_CONST);
        }

        if (_hdsa)
        {
            LISTITEM li = { 0 };

            //
            // Call QI to get the necessary interfaces,
            // and append the interfaces to the internal list.
            //
            li.punk = punk;
            li.punk->AddRef();

            li.punk->QueryInterface(IID_IEnumString, (LPVOID *)&li.pes);
            li.punk->QueryInterface(IID_IEnumACString, (LPVOID *)&li.peacs);
            li.punk->QueryInterface(IID_IACList, (LPVOID *)&li.pacl);

            if (DSA_AppendItem(_hdsa, &li) != -1)
            {
                hr = S_OK;
            }
            else
            {
                _FreeListItem(&li, 0);
                hr = E_FAIL;
            }
        }
    }

    return hr;
}

HRESULT CACLMulti::Remove(IUnknown *punk)
{
    HRESULT hr = E_FAIL;
    int i;

    if (punk && _hdsa)
    {
        for(i=DPA_GetPtrCount(_hdsa); i>=0; i--)
        {
            LISTITEM li;

            if (DSA_GetItem(_hdsa, i, &li) != -1)
            {
                if (punk == li.punk)
                {
                    _FreeListItem(&li, 0);
                    if (DSA_DeleteItem(_hdsa, i))
                    {
                        hr = S_OK;
                    }
                    break;
                }
            }
        }
    }

    return hr;
}


/* IACList methods */

HRESULT CACLMulti::Expand(LPCOLESTR pszExpand)
{
    HRESULT hr = S_OK;
    int i;

    if (_hdsa)
    {
        // Call Expand() on each sublist.
        for (i=0; i < DSA_GetItemCount(_hdsa); i++)
        {
            LISTITEM li;
            
            if ((DSA_GetItem(_hdsa, i, &li) != -1) && (li.pacl != NULL))
            {
                hr = li.pacl->Expand(pszExpand);
                if (hr == S_OK)
                    break;
            }
        }
    }
    
    if (E_NOTIMPL == hr)
        hr = S_OK;

    return hr;
}

/* Constructor / Destructor / CreateInstance */

CACLMulti::CACLMulti()
{
    DllAddRef();
    ASSERT(!_hdsa);
    ASSERT(!_iSubList);
    _cRef = 1;
}

CACLMulti::~CACLMulti()
{
    if (_hdsa)
    {
        DSA_DestroyCallback(_hdsa, _FreeListItem, 0);
        _hdsa = NULL;
    }

    DllRelease();
}

HRESULT CACLMulti_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory


    *ppunk = NULL;
    CACLMulti * p = new CACLMulti();
    if (p) 
    {
        *ppunk = SAFECAST(p, IEnumString *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}

HRESULT CACLMulti_Create(IEnumString **ppenum, CACLMulti * paclMultiToCopy)
{
    HRESULT hr = E_OUTOFMEMORY;
    *ppenum = NULL;
    CACLMulti * p = new CACLMulti();
    if (p) 
    {
        if (paclMultiToCopy->_hdsa)
        {
            // Clone data
            int iSize = DSA_GetItemCount(paclMultiToCopy->_hdsa);
            int iIndex;
            LISTITEM li;

            hr = S_OK;
            p->_hdsa = DSA_Create(SIZEOF(LISTITEM), MULTILIST_GROWTH_CONST);

            // We need to copy the source HDSA
            for (iIndex = 0; (iIndex < iSize) && (S_OK == hr); iIndex++)
            {
                if (DSA_GetItem(paclMultiToCopy->_hdsa, iIndex, &li) != -1)
                    hr = p->Append(li.punk);
                else
                    hr = E_FAIL;
            }
            p->_iSubList = paclMultiToCopy->_iSubList;

            if (SUCCEEDED(hr))
                *ppenum = SAFECAST(p, IEnumString *);
            else
                p->Release();
        }
        else
        {
            p->Release();
        }
    }

    return hr;
}

//
// Frees all the contents of one list item.
//
int CACLMulti::_FreeListItem(LPVOID p, LPVOID d)
{
    LISTITEM *pli = (LISTITEM *)p;

    SAFERELEASE(pli->pacl);
    SAFERELEASE(pli->pes);
    SAFERELEASE(pli->peacs);
    SAFERELEASE(pli->punk);

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\address.h ===
/**************************************************************\
    FILE: address.h

    DESCRIPTION:
        The Class CAddressBand exists to support a "Address" Band
    ToolBar.  This will be used in the Browser's toolbar or can
    be used in the Start Menu.
\**************************************************************/

#ifndef _ADDRESS_H
#define _ADDRESS_H

#include "bands.h"
#include "bandprxy.h"


///////////////////////////////////////////////////////////////////
// #DEFINEs

///////////////////////////////////////////////////////////////////
// Data Structures

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CAddressBand

    DESCRIPTION:
        This Class CAddressBand exists to support a "Address" Band
    ToolBar.  This will be used in the Browser's toolbar or can
    be used in the Start Menu/Taskbar.  If the Band is part of
    a Browser toolbar, any modifications made to the AddressBar
    will go the the browser window.  

        By default, the this AddressBand will not point to a
    browser window when it is on the Taskbar or Start Menu.  
    Anything "executed" in the AddressBar will create a new
    browser window.  Future support may allow for the AddressBand
    in the taskbar/start menu to reference a currently existing
    browser window.
\**************************************************************/
class CAddressBand 
                : public CToolBand
                , public IWinEventHandler
                , public IAddressBand
                , public IInputObjectSite
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void) { return CToolBand::AddRef(); };
    virtual STDMETHODIMP_(ULONG) Release(void){ return CToolBand::Release(); };
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                        OLECMD rgCmds[], OLECMDTEXT *pcmdtext);        // Interface forwarding
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);        // Interface forwarding

    // *** IDockingWindow methods ***
    virtual STDMETHODIMP ShowDW(BOOL fShow);
    virtual STDMETHODIMP CloseDW(DWORD dw);

    // *** IObjectWithSite methods ***
    virtual STDMETHODIMP SetSite(IUnknown* punkSite);

    // *** IInputObject methods ***
    virtual STDMETHODIMP TranslateAcceleratorIO(LPMSG lpMsg);
    virtual STDMETHODIMP HasFocusIO(void);
    
    // *** IInputObjectSite methods ***
    virtual STDMETHODIMP OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus);

    // *** IShellToolband methods ***
    STDMETHOD(GetBandInfo)    (THIS_ DWORD dwBandID, DWORD fViewMode, 
                                DESKBANDINFO* pdbi) ;
    
    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IAddressBand methods ***
    virtual STDMETHODIMP FileSysChange(DWORD dwEvent, LPCITEMIDLIST * ppidl);        
    virtual STDMETHODIMP Refresh(VARIANT * pvarType);        

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_AddressBand; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm);
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty);
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressBand();
    virtual ~CAddressBand();

    HRESULT _CreateAddressBand(IUnknown * punkSite);
    static LRESULT CALLBACK _ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _ComboExEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    BOOL _CreateGoButton();
    void _InitGoButton();
    void _OnGetInfoTip(LPNMTBGETINFOTIP pnmTT);


    // Friend Functions
    friend HRESULT CAddressBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);   

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    BOOL                _fVertical :1;

    // Only valid if _fInited == TRUE
    HWND                _hwndEdit;      // Address edit control child Window
    HWND                _hwndCombo;     // Address combo control child Window
    BOOL                _fVisible:1;    // TRUE when the toolbar is visible.
    BOOL                _fGoButton:1;   // TRUE if go button is visible
    IAddressEditBox*    _paeb;          // IAddressEditBox that controls
    IWinEventHandler*   _pweh;          // IWinEventHandler interface for the AddressEditBox object.  (Cached for Perf)
    HIMAGELIST          _himlDefault;   // default gray-scale go button
    HIMAGELIST          _himlHot;       // color go button
    HWND                _hwndTools;     // toolbar containing go button
    WNDPROC             _pfnOldWndProc; // Former WndProc of ComboBoxEx
    WNDPROC             _pfnOldEditProc;// Former WndProc of Edit control in ComboBoxEx
};


#endif /* _ADDRESS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\address.cpp ===
/**************************************************************\
    FILE: address.cpp

    DESCRIPTION:
        The Class CAddressBand exists to support the Address
    ToolBand in either the main browser toolbar or as a
    ShellToolBand.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "aclhist.h"
#include "aclmulti.h"
#include "autocomp.h"
#include "address.h"
#include "shellurl.h"
#include "resource.h"
#include "uemapp.h"
#include <tb_ids.h>
#include "apithk.h"

#include "mluisupp.h"

#define SUPERCLASS CToolBand
#define MIN_DROPWIDTH 200
const static TCHAR c_szAddressBandProp[]   = TEXT("CAddressBand_This");

//=================================================================
// Implementation of CAddressBand
//=================================================================

//===========================
// *** IUnknown Interface ***

HRESULT CAddressBand::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IAddressBand))
    {
        *ppvObj = SAFECAST(this, IAddressBand*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IServiceProvider))
    {
        *ppvObj = SAFECAST(this, IServiceProvider*);
    }
    else if (IsEqualIID(riid, IID_IInputObjectSite))
    {
        *ppvObj = SAFECAST(this, IInputObjectSite*);
    }
    else
    {
        return SUPERCLASS::QueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}


//================================
// *** IDockingWindow Interface ***
/****************************************************\
    FUNCTION: ShowDW

    DESCRIPTION:
        fShow == TRUE means show the window, FALSE means
    remove the window from the view.  The window will
    be created if needed.
\****************************************************/
HRESULT CAddressBand::ShowDW(BOOL fShow)
{
    if (!_hwnd)
        return S_FALSE; // The window needs to be created first.

    ShowWindow(_hwnd, fShow ? SW_SHOW : SW_HIDE);

    // Refresh if we are becoming visible because we could have
    // received and ignored FileSysChange() events while
    // we where hidden.
    if (fShow && !_fVisible)
        Refresh(NULL);

    _fVisible = BOOLIFY(fShow);
    return SUPERCLASS::ShowDW(fShow);
}


HRESULT CAddressBand::CloseDW(DWORD dw)
{
    if(_paeb)
        _paeb->Save(0);

    return SUPERCLASS::CloseDW(dw);
}



/****************************************************\
    FUNCTION: SetSite

    DESCRIPTION:
        This function will be called to have this
    Toolband try to obtain enough information about its
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.
\****************************************************/
HRESULT CAddressBand::SetSite(IUnknown *punkSite)
{
    HRESULT hr;
    BOOL fSameHost = punkSite == _punkSite;

    if (!punkSite && _paeb)
    {
        IShellService * pss;

        hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
        if (SUCCEEDED(hr))
        {
            hr = pss->SetOwner(NULL);
            pss->Release();
        }
    }

    hr = SUPERCLASS::SetSite(punkSite);
    if (punkSite && !fSameHost)
    {
        hr = _CreateAddressBand(punkSite);
        // This call failing is expected when the host doesn't have a Browser Window.
    }

    // Set or reset the AddressEditBox's Browser IUnknown.
    if (_paeb)
    {
        IShellService * pss;

        hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
        if (SUCCEEDED(hr))
        {
            // CAddressBand and the BandSite(host) have a ref count cycle.  This cycle
            // is broken when BandSite calls SetSite(NULL) which will cause
            // CAddressBand to break the cycle by releasing it's punk to the BandSite.
            //
            // CAddressEditBox and CAddressBand have the same method of breaking the
            // cycle.  This is accomplished by passing NULL to IAddressEditBox(NULL, NULL)
            // if our caller is breaking the cycle.  This will cause CAddressEditBox to
            // release it's ref count on CAddressBand.
            hr = pss->SetOwner((punkSite ? SAFECAST(this, IAddressBand *) : NULL));
            pss->Release();
        }
    }

    // setsite must succeed
    return S_OK;
}


//================================
// *** IInputObject Methods ***
HRESULT CAddressBand::TranslateAcceleratorIO(LPMSG lpMsg)
{
    BOOL fForwardToView = FALSE;
    static CHAR szAccel[2] = "\0"; // Alt-D needs to be localizable

    switch (lpMsg->message)
    {
    case WM_KEYDOWN:    // process these
        if (IsVK_TABCycler(lpMsg))
        {
            // If we are tabbing away, let the edit box know so
            // that it clears its dirty flag.
            SendMessage(_hwndEdit, WM_KEYDOWN, VK_TAB, 0);
        }
        else
        {
            fForwardToView = TRUE;
        }

        switch (lpMsg->wParam)
        {
            case VK_F1:     // help
            {
                //
                // FEATURE: Should add and accelerator for this and simply return S_FALSE, but that
                // causes two instances of the help dialog to come up when focus is in Trident.
                // This is the quick fix for IE5B2.
                //
                IOleCommandTarget* poct;
                IServiceProvider* psp;
                if (_punkSite && SUCCEEDED(_punkSite->QueryInterface(IID_IServiceProvider, (void**)&psp)))
                {
                    if (SUCCEEDED(psp->QueryService(SID_STopLevelBrowser, IID_IOleCommandTarget, (LPVOID*)&poct)))
                    {
                        poct->Exec(&CGID_ShellBrowser, DVIDM_HELPSEARCH, 0, NULL, NULL);
                        poct->Release();
                    }
                    psp->Release();
                }
                return S_FALSE;
            }
            case VK_F11:    // fullscreen
            {
                return S_FALSE;
            }

            case VK_F4:
            {
                if (_fVisible)
                {
                    if (HasFocusIO() == S_FALSE)
                        SetFocus(_hwnd);

                    // toggle the dropdown state
                    SendMessage(_hwnd, CB_SHOWDROPDOWN,
                                !SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0L), 0);

                    // Leave focus in the edit box so you can keep typing
                    if (_hwndEdit)
                        SetFocus(_hwndEdit);
                }
                else
                {
                    ASSERT(0); // Should this really be ignored?
                }

                return S_OK;
            }
            case VK_TAB:
            {
                // See if the editbox wants the tab character
                if (SendMessage(_hwndEdit, WM_GETDLGCODE, lpMsg->wParam, (LPARAM)lpMsg) == DLGC_WANTTAB)
                {
                    // We want the tab character
                    return S_OK;
                }
                break;
            }

            case VK_RETURN:
            {
                //
                // Ctrl-enter is used for quick complete, so pass it through
                //
                if (GetKeyState(VK_CONTROL) & 0x80000000)
                {
                    TranslateMessage(lpMsg);
                    DispatchMessage(lpMsg);
                    return S_OK;
                }
                break;
            }
        }
        break;
    case WM_KEYUP:      // eat any that WM_KEYDOWN processes
        switch (lpMsg->wParam)
        {
            case VK_F1:     // help
            case VK_F11:    // fullscreen
                return S_FALSE;

            case VK_RETURN:
            case VK_F4:
            case VK_TAB:
                return S_OK;
            default:
                break;
        }
        break;

    case WM_SYSCHAR:
        {
            CHAR   szChar [2] = "\0";
            if ('\0' == szAccel[0]) {
                MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR,szAccel,ARRAYSIZE(szAccel));
            }
            szChar[0] = (CHAR)lpMsg->wParam;

            if (lstrcmpiA(szChar,szAccel) == 0)
            {
                ASSERT(_fVisible);
                if (_fVisible && (HasFocusIO() == S_FALSE))
                {
                    SetFocus(_hwnd);
                }
                return S_OK;
            }
        }
        break;

    case WM_SYSKEYUP:   // eat any that WM_SYSKEYDOWN processes
        if ('\0' == szAccel[0]) {
            MLLoadStringA(IDS_ADDRBAND_ACCELLERATOR,szAccel,ARRAYSIZE(szAccel));
        }

        if ((CHAR)lpMsg->wParam == szAccel[0]) {
            return S_OK;
        }
        break;
    }

    HRESULT hres = EditBox_TranslateAcceleratorST(lpMsg);

    if (hres == S_FALSE && fForwardToView)
    {
        IShellBrowser *psb;
        // we did not process this try the view before we return
        if (SUCCEEDED(IUnknown_QueryService(_punkSite, SID_STopLevelBrowser, IID_IShellBrowser, (void **)&psb)))
        {
            IShellView *psv;

            if (SUCCEEDED(psb->QueryActiveShellView(&psv)))
            {
                hres = psv->TranslateAccelerator(lpMsg);
                psv->Release();
            }
            psb->Release();
        }
    }

    return hres;
}


HRESULT CAddressBand::HasFocusIO()
{
    if ((_hwndEdit&& (GetFocus() == _hwndEdit)) ||
        SendMessage(_hwnd, CB_GETDROPPEDSTATE, 0, 0))
        return S_OK;

    return S_FALSE;
}


//=====================================
// *** IInputObjectSite Interface ***
HRESULT CAddressBand::OnFocusChangeIS(IUnknown *punk, BOOL fSetFocus)
{
    HRESULT hr;

    ASSERT(_punkSite);
    hr = IUnknown_OnFocusChangeIS(_punkSite, punk, fSetFocus);
    return hr;
}


//=====================================
// *** IOleCommandTarget Interface ***
HRESULT CAddressBand::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    ASSERT(_paeb);
    return IUnknown_QueryStatus(_paeb, pguidCmdGroup, cCmds, rgCmds, pcmdtext);
}


HRESULT CAddressBand::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        // nothing
    }
    else if (IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {

        switch (nCmdID)
        {
        case SBCMDID_GETADDRESSBARTEXT:
            hr = S_OK;

            TCHAR wz[MAX_URL_STRING];
            UINT   cb = 0;
            BSTR   bstr = NULL;
            VariantInit(pvarargOut);

            if (_hwndEdit)
                cb = Edit_GetText(_hwndEdit, (TCHAR *)&wz, ARRAYSIZE(wz));
            if (cb)
                bstr = SysAllocStringLen(NULL, cb);
            if (bstr)
            {
                SHTCharToUnicode(wz, bstr, cb);
                pvarargOut->vt = VT_BSTR|VT_BYREF;
                pvarargOut->byref = bstr;
            }
            else
            {
                // VariantInit() might do this for us.
                pvarargOut->vt = VT_EMPTY;
                pvarargOut->byref = NULL;
                return E_FAIL;   // Edit_GetText gave us nothing
            }
            break;
        }
    }
    else if (IsEqualGUID(CGID_DeskBand, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case DBID_SETWINDOWTHEME:
            if (pvarargIn && pvarargIn->vt == VT_BSTR)
            {
                if (_hwnd)
                {
                    Comctl32_SetWindowTheme(_hwnd, pvarargIn->bstrVal);
                    Comctl32_SetWindowTheme(_hwndTools, pvarargIn->bstrVal);
                    _BandInfoChanged();
                }
            }

            hr = S_OK;
            break;
        }
    }

    if (FAILED(hr))
    {
        hr = IUnknown_Exec(_paeb, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut);
    }

    return(hr);
}

extern HRESULT IsDesktopBrowser(IUnknown *punkSite);

//================================
// *** IDeskBand Interface ***
/****************************************************\
    FUNCTION: GetBandInfo

    DESCRIPTION:
        This function will give the caller information
    about this Band, mainly the size of it.
\****************************************************/
HRESULT CAddressBand::GetBandInfo(DWORD dwBandID, DWORD fViewMode,
                                DESKBANDINFO* pdbi)
{
    HRESULT hr  = S_OK;

    _dwBandID = dwBandID;
    _fVertical = ((fViewMode & (DBIF_VIEWMODE_VERTICAL | DBIF_VIEWMODE_FLOATING)) != 0);

    pdbi->dwModeFlags = DBIMF_FIXEDBMP;

    pdbi->ptMinSize.x = 0;
    pdbi->ptMinSize.y = 0;
    if (_fVertical) {
        pdbi->ptMinSize.y = GetSystemMetrics(SM_CXSMICON);
        pdbi->ptMaxSize.y = -1; // random
        pdbi->ptIntegral.y = 1;
        pdbi->dwModeFlags |= DBIMF_VARIABLEHEIGHT;
    } else {
        if (_hwnd) {
            HWND hwndCombo;
            RECT rcCombo;

            hwndCombo = (HWND)SendMessage(_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
            ASSERT(hwndCombo);
            GetWindowRect(hwndCombo, &rcCombo);
            pdbi->ptMinSize.y = RECTHEIGHT(rcCombo);
        }
        ASSERT(pdbi->ptMinSize.y < 200);

    }

    MLLoadStringW(IDS_BAND_ADDRESS2, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    if (IsDesktopBrowser(_punkSite) != S_FALSE) {
        // non- shell browser host (e.g. desktop or tray)
        //
        // this is slightly (o.k., very) hoaky.  the only time we want to
        // show a mnemonic is when we're in a browser app.  arguably we
        // should generalize this to all bands/bandsites by having a
        // DBIMF_WITHMNEMONIC or somesuch, but that would mean adding a
        // CBandSite::_dwModeFlag=0 and overriding it in itbar::CBandSite.
        // that seems like a lot of work for a special case so instead we
        // hack it in here based on knowledge of our host.
        TraceMsg(DM_TRACE, "cab.gbi: nuke Address mnemonic");
        MLLoadStringW(IDS_BAND_ADDRESS, pdbi->wszTitle, ARRAYSIZE(pdbi->wszTitle));
    }

    return hr;
}

//================================
//  ** IWinEventHandler Interface ***
/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressBand::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    switch (uMsg)
    {
    case WM_WININICHANGE:
        if (SHIsExplorerIniChange(wParam, lParam) & (EICH_KINET | EICH_KINETMAIN))
        {
            _InitGoButton();
        }

        if (wParam == SPI_SETNONCLIENTMETRICS)
        {
            // Tell the combobox so that it can update its font
            SendMessage(_hwnd, uMsg, wParam, lParam);

            // Inform the band site that our height may have changed
            _BandInfoChanged();
        }
        break;

    case WM_COMMAND:
        {
            UINT idCmd = GET_WM_COMMAND_ID(wParam, lParam);
            if (idCmd == FCIDM_VIEWGOBUTTON)
            {
                // Toggle the go-button visibility
                BOOL fShowGoButton = !SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
                    TEXT("ShowGoButton"), FALSE, /*default*/TRUE);

                SHRegSetUSValue(REGSTR_PATH_MAIN,
                            TEXT("ShowGoButton"),
                            REG_SZ,
                            (LPVOID)(fShowGoButton ? L"yes" : L"no"),
                            (fShowGoButton ? 4 : 3)*sizeof(TCHAR),
                            SHREGSET_FORCE_HKCU);

                // Tell the world that something has changed
                SendShellIEBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAIN, 3000);
            }
        }
    }

    if (_pweh)
        return _pweh->OnWinEvent(_hwnd, uMsg, wParam, lParam, plres);
    else
        return S_OK;
}


/****************************************************\
    FUNCTION: IsWindowOwner

    DESCRIPTION:
        This function will return TRUE if the HWND
    passed in is a HWND owned by this band.
\****************************************************/
HRESULT CAddressBand::IsWindowOwner(HWND hwnd)
{
    if (_pweh)
        return _pweh->IsWindowOwner(hwnd);
    else
        return S_FALSE;
}


//================================
// *** IAddressBand Interface ***
/****************************************************\
    FUNCTION: FileSysChange

    DESCRIPTION:
        This function will handle file system change
    notifications.
\****************************************************/
HRESULT CAddressBand::FileSysChange(DWORD dwEvent, LPCITEMIDLIST * ppidl)
{
    HRESULT hr = S_OK;

    if (_fVisible)
    {
        hr = IUnknown_FileSysChange(_paeb, dwEvent, ppidl);
    }
    return hr;
}


/****************************************************\
    FUNCTION: Refresh

    PARAMETERS:
        pvarType - NULL for a refress of everything.
                   OLECMD_REFRESH_TOPMOST will only update the top most.

    DESCRIPTION:
        This function will force a refress of part
    or all of the AddressBand.
\****************************************************/
HRESULT CAddressBand::Refresh(VARIANT * pvarType)
{
    HRESULT hr = S_OK;
    IAddressBand * pab;

    if (_paeb)
    {
        hr = _paeb->QueryInterface(IID_IAddressBand, (LPVOID *)&pab);
        if (SUCCEEDED(hr))
        {
            hr = pab->Refresh(pvarType);
            pab->Release();
        }
    }

    return hr;
}

/****************************************************\
    Address Band Constructor
\****************************************************/
CAddressBand::CAddressBand()
{
    TraceMsg(TF_SHDLIFE, "ctor CAddressBand %x", this);

    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!_hwndEdit);
    ASSERT(!_paeb);
    ASSERT(!_pweh);

    _fCanFocus = TRUE;      // we accept focus (see CToolBand::UIActivateIO)
}


/****************************************************\
    Address Band destructor
\****************************************************/
CAddressBand::~CAddressBand()
{
    ATOMICRELEASE(_paeb);
    ATOMICRELEASE(_pweh);

    //
    // Make sure the toolbar is destroyed before we free
    // the image lists
    //
    if (_hwndTools && IsWindow(_hwndTools))
    {
        DestroyWindow(_hwndTools);
    }
    if (_himlDefault) ImageList_Destroy(_himlDefault);
    if (_himlHot)  ImageList_Destroy(_himlHot);

    //
    // Our window must be destroyed before we are freed
    // so that the window doesn't try to reference us.
    //
    if (_hwnd && IsWindow(_hwnd))
    {
        DestroyWindow(_hwnd);

        // Null out base classes window handle because
        // its destructor is next
        _hwnd = NULL;
    }

    TraceMsg(TF_SHDLIFE, "dtor CAddressBand %x", this);
}


/****************************************************\
    FUNCTION: CAddressBand_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    AddressBand COM object.
\****************************************************/
HRESULT CAddressBand_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    *ppunk = NULL;
    CAddressBand * p = new CAddressBand();
    if (p)
    {
        *ppunk = SAFECAST(p, IDeskBand *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: _CreateAddressBand

    DESCRIPTION:
        This function will create the AddressBand window
    with the ComboBox.
\****************************************************/
HRESULT CAddressBand::_CreateAddressBand(IUnknown * punkSite)
{
    HRESULT hr = S_OK;

    if (_hwnd)
    {
        IShellService * pss;

        if (_hwndTools)
        {
            DestroyWindow(_hwndTools);
            _hwndTools = NULL;
        }

        DestroyWindow(_hwnd);
        _hwnd = NULL;

        ASSERT(_punkSite);
        if (_paeb)
        {
            hr = _paeb->QueryInterface(IID_IShellService, (LPVOID *)&pss);
            if (SUCCEEDED(hr))
            {
                hr = pss->SetOwner(NULL);
                pss->Release();
            }
        }
        ATOMICRELEASE(_paeb);
        ATOMICRELEASE(_pweh);
    }

    //
    // Create address window.
    //

    ASSERT(_hwndParent);        // Call us after SetSite()
    if (!_hwndParent)
    {
            // The caller hasn't called SetSite(), so we can't
            // create our window because we can't find out our parent's
            // HWND.
            return E_FAIL;
    }
    _InitComCtl32();    // don't check result, if this fails our CreateWindows will fail


    DWORD dwWindowStyles = WS_TABSTOP | WS_CHILD | WS_CLIPCHILDREN | WS_TABSTOP | CBS_DROPDOWN | CBS_AUTOHSCROLL;

    // WARNING: MSN and other Rooted Explorers may not have implemented all
    // of the ParseDisplayName and other IShellFolder members
    // If we want to continue to support MSN, we will need to turn on the
    // CBS_DROPDOWNLIST if ISROOTEDCLASS() and the clsid is equal to the MSN clsid.

    // dwWindowStyles |= CBS_DROPDOWNLIST; // (This turns off the ComboBox's Editbox)

    DWORD dwExStyle = WS_EX_TOOLWINDOW;

    if (IS_WINDOW_RTL_MIRRORED(_hwndParent))
    {
        // If the parent window is mirrored then the ComboBox window will inheret the mirroring flag
        // And we need the reading order to be Left to right, which is the right to left in the mirrored mode.
        dwExStyle |= WS_EX_RTLREADING;
    }

    _hwnd = CreateWindowEx(dwExStyle, WC_COMBOBOXEX, NULL, dwWindowStyles,
                           0, 0, 100, 250, _hwndParent,
                           (HMENU) FCIDM_VIEWADDRESS, HINST_THISDLL, NULL);

    if (_hwnd)
    {
        // Initial combobox parameters.
        SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE,
                CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE,
                CBES_EX_NOSIZELIMIT | CBES_EX_CASESENSITIVE);

        // NOTE: _hwndEdit will be NULL if the CBS_DROPDOWNLIST flag has been turned on
        _hwndEdit  = (HWND)SendMessage(_hwnd, CBEM_GETEDITCONTROL, 0, 0L);
        _hwndCombo = (HWND)SendMessage(_hwnd, CBEM_GETCOMBOCONTROL, 0, 0L);

        // Subclass the Edit control's procedure to handle ModeBias issue.
        if ( _hwndEdit  && SetProp(_hwndEdit, c_szAddressBandProp, this))
        {
           _pfnOldEditProc = (WNDPROC) SetWindowLongPtr(_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _ComboExEditProc);
        }

        ASSERT(!_paeb && !_pweh);
        hr = CoCreateInstance(CLSID_AddressEditBox, NULL, CLSCTX_INPROC_SERVER, IID_IAddressEditBox, (void **)&_paeb);
        // If this object fails to initialize, it won't work!!!  Make sure you REGSVR32ed and RUNDLL32ed shdocvw.dll
        if (SUCCEEDED(hr))
        {
            hr = _paeb->QueryInterface(IID_IWinEventHandler, (LPVOID *)&_pweh);
            ASSERT(SUCCEEDED(hr));
            hr = _paeb->Init(_hwnd, _hwndEdit, AEB_INIT_AUTOEXEC, SAFECAST(this, IAddressBand *));
        }

        // Create the go button if it's enabled
        _InitGoButton();
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


//================================
// *** IPersistStream Interface ***

/****************************************************\
    FUNCTION: Load

    DESCRIPTION:
        This function will currently only persist the
    CAddressEditBox object.

    HISTORY:
    Ver 1: Contains the CAddressEditBox::Save() stream.
\****************************************************/
#define STREAM_VERSION_CADDRESSBAND      0x00000001

HRESULT CAddressBand::Load(IStream *pstm)
{
    HRESULT hr;
    DWORD dwSize;
    DWORD dwVersion;

    hr = LoadStreamHeader(pstm, STREAMHEADER_SIG_CADDRESSBAND, STREAM_VERSION_CADDRESSBAND,
        STREAM_VERSION_CADDRESSBAND, &dwSize, &dwVersion);
    ASSERT(SUCCEEDED(hr));

    if (S_OK == hr)
    {
        switch (dwVersion)
        {
        case 1:     // Ver 1.
            // Nothing.
            break;
        default:
            ASSERT(0);  // Should never get here.
            break;
        }
    }
    else if (S_FALSE == hr)
        hr = S_OK;  // We already have our default data set.

    return hr;
}


/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
        This function will currently only persist the
    CAddressEditBox object.

    HISTORY:
    Ver 1: Contains the CAddressEditBox::Save() stream.
\****************************************************/
HRESULT CAddressBand::Save(IStream *pstm, BOOL fClearDirty)
{
    HRESULT hr;

    hr = SaveStreamHeader(pstm, STREAMHEADER_SIG_CADDRESSBAND,
                STREAM_VERSION_CADDRESSBAND, 0);
    ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
    {
        IPersistStream * pps;

        ASSERT(_paeb);
        if (_paeb)
        {
            hr = _paeb->QueryInterface(IID_IPersistStream, (LPVOID *)&pps);
            if(EVAL(SUCCEEDED(hr)))
            {
                hr = pps->Save(pstm, fClearDirty);
                pps->Release();
            }
        }
    }

    return hr;
}


void CAddressBand::_OnGetInfoTip(LPNMTBGETINFOTIP pnmTT)
{
    // Format a tooltip: "go to <contents of address bar>"
    WCHAR szAddress[MAX_PATH];
    if (GetWindowText(_hwndEdit, szAddress, ARRAYSIZE(szAddress)))
    {
        WCHAR szFormat[MAX_PATH];
        const int MAX_TOOLTIP_LENGTH = 100;
        int cchMax = (pnmTT->cchTextMax < MAX_TOOLTIP_LENGTH) ? pnmTT->cchTextMax : MAX_TOOLTIP_LENGTH;

        MLLoadString(IDS_GO_TOOLTIP, szFormat, ARRAYSIZE(szFormat));
        int cch;
        if(SUCCEEDED(StringCchPrintf(pnmTT->pszText, cchMax, szFormat, szAddress)))
        {
            cch = lstrlen(pnmTT->pszText);

            // Append ellipses?
            if (cch == cchMax - 1)
            {
                // Note that Japan has a single character for ellipses, so we load
                // as a resource.
                WCHAR szEllipses[10];
                cch = MLLoadString(IDS_ELLIPSES, szEllipses, ARRAYSIZE(szEllipses));
                StringCchCopy(pnmTT->pszText + cchMax - cch - 1,  cch + 1, szEllipses);
            }
        }
    }
    else if (pnmTT->cchTextMax > 0)
    {
        // Use button text for tooltip
        *pnmTT->pszText = L'\0';
    }
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the combobox Edit control in the address band
//--------------------------------------------------------------------------
LRESULT CALLBACK CAddressBand::_ComboExEditProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAddressBand* pThis = (CAddressBand*)GetProp(hwnd, c_szAddressBandProp);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldEditProc = pThis->_pfnOldEditProc;

    switch (uMsg)
    {
    case WM_KILLFOCUS :

        SetModeBias(MODEBIASMODE_DEFAULT);
        break;

    case WM_SETFOCUS:

        SetModeBias(MODEBIASMODE_URLHISTORY);
        break;

    case WM_DESTROY:
        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, c_szAddressBandProp);
        if (pfnOldEditProc)
        {
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldEditProc);
            pThis->_pfnOldEditProc = NULL;
        }
        break;
    default:
        break;
    }

    return CallWindowProc(pfnOldEditProc, hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Subclassed window procedure of the combobox in the address band
//--------------------------------------------------------------------------
LRESULT CALLBACK CAddressBand::_ComboExWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CAddressBand* pThis = (CAddressBand*)GetProp(hwnd, c_szAddressBandProp);

    if (!pThis)
        return DefWindowProcWrap(hwnd, uMsg, wParam, lParam);

    WNDPROC pfnOldWndProc = pThis->_pfnOldWndProc;

    switch (uMsg)
    {
    case WM_NOTIFYFORMAT:
        if (NF_QUERY == lParam)
        {
            return (DLL_IS_UNICODE ? NFR_UNICODE : NFR_ANSI);
        }
        break;

    case WM_WINDOWPOSCHANGING:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Make room for the go button on the right side
            //
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOCOPYBITS;

            WINDOWPOS wp = *(LPWINDOWPOS)lParam;

            // Get the dimensions of our 'go' button
            RECT rc;
            SendMessage(pThis->_hwndTools, TB_GETITEMRECT, 0, (LPARAM)&rc);
            int cxGo = RECTWIDTH(rc);
            int cyGo = RECTHEIGHT(rc);

            // Make room for the go button on the right side
            wp.cx -= cxGo + 2;
            CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, (LPARAM)&wp);

            // Paint underneath the 'go' button
            RECT rcGo = {wp.cx, 0, wp.cx + cxGo + 2, wp.cy};
            InvalidateRect(pThis->_hwnd, &rcGo, TRUE);

            // The outer window can be much higher than the internal combobox.
            // We want to center the go button on the combobox
            int y;
            if (pThis->_hwndCombo)
            {
                // Center vertically with inner combobox
                RECT rcCombo;
                GetWindowRect(pThis->_hwndCombo, &rcCombo);
                y = (rcCombo.bottom - rcCombo.top - cyGo)/2;
            }
            else
            {
                y = (wp.cy - cyGo)/2;
            }

            // Position the 'go' button on the right.  Note that the height will always be ok
            // because the addressbar displays 16x16 icons within it.
            SetWindowPos(pThis->_hwndTools, NULL, wp.cx + 2, y, cxGo, cyGo, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            // Adjust the drop-down width
            SendMessage(pThis->_hwndCombo, CB_SETDROPPEDWIDTH, MIN_DROPWIDTH, 0L);
            return 0;
        }
    case WM_SIZE:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Make room for the go button on the right side
            //
            int cx = LOWORD(lParam);
            int cy = HIWORD(lParam);

            // Get the dimensions of our 'go' button
            RECT rc;
            SendMessage(pThis->_hwndTools, TB_GETITEMRECT, 0, (LPARAM)&rc);
            int cxGo = RECTWIDTH(rc);
            int cyGo = RECTHEIGHT(rc);

            // Make room for the go button on the right side
            LPARAM lParamTemp = MAKELONG(cx - cxGo - 2, cy);
            CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParamTemp);

            // Paint underneath the 'go' button
            RECT rcGo = {cx-cxGo, 0, cx, cy};
            InvalidateRect(pThis->_hwnd, &rcGo, TRUE);

            // The outer window can be much higher than the internal combobox.
            // We want to center the go button on the combobox
            int y;
            if (pThis->_hwndCombo)
            {
                // Center vertically with inner combobox
                RECT rcCombo;
                GetWindowRect(pThis->_hwndCombo, &rcCombo);
                y = (rcCombo.bottom - rcCombo.top - cyGo)/2;
            }
            else
            {
                y = (cy - cyGo)/2;
            }

            // Position the 'go' button on the right.  Note that the height will always be ok
            // because the addressbar displays 16x16 icons within it.
            SetWindowPos(pThis->_hwndTools, NULL, cx - cxGo, y, cxGo, cyGo, SWP_SHOWWINDOW | SWP_NOACTIVATE | SWP_NOOWNERZORDER);

            // Adjust the drop-down width
            SendMessage(pThis->_hwndCombo, CB_SETDROPPEDWIDTH, MIN_DROPWIDTH, 0L);
            return 0;
        }
    case WM_NOTIFY:
        {
            LPNMHDR pnm = (LPNMHDR)lParam;
            if (pnm->hwndFrom == pThis->_hwndTools)
            {
                switch (pnm->code)
                {
                case NM_CLICK:
                    // Simulate an enter key press in the combobox
                    SendMessage(pThis->_hwndEdit, WM_KEYDOWN, VK_RETURN, 0);
                    SendMessage(pThis->_hwndEdit, WM_KEYUP, VK_RETURN, 0);
                    // n.b. we also got a NAVADDRESS from the simulate
                    UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVGO);
                    break;

                case NM_TOOLTIPSCREATED:
                {
                    //
                    // Make the tooltip show up even when the app is nit active
                    //
                    NMTOOLTIPSCREATED* pnmTTC = (NMTOOLTIPSCREATED*)pnm;
                    SHSetWindowBits(pnmTTC->hwndToolTips, GWL_STYLE, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX, TTS_ALWAYSTIP | TTS_TOPMOST | TTS_NOPREFIX);
                }
                break;
                case TBN_GETINFOTIP:
                    pThis->_OnGetInfoTip((LPNMTBGETINFOTIP)pnm);
                    break;
                }
                return 0;
            }
            break;
        }
    case WM_ERASEBKGND:
        {
            // Break out if the go button is hidden
            if (!pThis->_fGoButton)
                break;

            //
            // Forward the erase background to the parent so that
            // we appear transparent under the go button
            //
            HDC hdc = (HDC)wParam;
            HWND hwndParent = GetParent(hwnd);
            LRESULT lres = 0;

            if (hwndParent)
            {
                // Adjust the origin so the parent paints in the right place
                POINT pt = {0,0};

                MapWindowPoints(hwnd, hwndParent, &pt, 1);
                OffsetWindowOrgEx(hdc,
                                  pt.x,
                                  pt.y,
                                  &pt);

                lres = SendMessage(hwndParent, WM_ERASEBKGND, (WPARAM)hdc, 0L);

                SetWindowOrgEx(hdc, pt.x, pt.y, NULL);
            }

            if (lres != 0)
            {
                // We handled it
                return lres;
            }

            break;
         }

    case WM_DESTROY:
        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, c_szAddressBandProp);
        if (pfnOldWndProc)
        {
            SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) pfnOldWndProc);
            pThis->_pfnOldWndProc = NULL;
        }
        break;
    default:
        break;
    }

    return CallWindowProc(pfnOldWndProc, hwnd, uMsg, wParam, lParam);
}

//+-------------------------------------------------------------------------
// Creates and shows the go button
//--------------------------------------------------------------------------
BOOL CAddressBand::_CreateGoButton()
{
    ASSERT(_hwndTools == NULL);

    BOOL fRet = FALSE;
    BOOL bUseClassicGlyphs = SHUseClassicToolbarGlyphs();
    COLORREF crMask = RGB(255, 0, 255);

    if (_himlDefault == NULL)
    {
        if (bUseClassicGlyphs)
        {
            _himlDefault = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GO), 16, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);

        }
        else
        {
            _himlDefault = ImageList_LoadImage(GetModuleHandle(TEXT("shell32.dll")), MAKEINTRESOURCE(IDB_TB_GO_DEF_20), 20, 0, crMask,
                                                   IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
    }
    if (_himlHot == NULL)
    {
        if (bUseClassicGlyphs)
        {
            _himlHot  = ImageList_LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDB_GOHOT), 16, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
        else
        {
            _himlHot  = ImageList_LoadImage(GetModuleHandle(TEXT("shell32.dll")), MAKEINTRESOURCE(IDB_TB_GO_HOT_20), 20, 0, crMask,
                                               IMAGE_BITMAP, LR_CREATEDIBSECTION);
        }
    }

    // If we have the image lists, go ahead and create the toolbar control for the go button
    if (_himlDefault && _himlHot)
    {
        //
        // Subclass the comboboxex so that we can place the go botton within it.  The toolbad class
        // assumes one window per band, so this trick allows us to add the button using existing windows.
        // Note that comboex controls have a separate window used to wrap the internal combobox.  This
        // is the window that we use to host our "go" button.  We must subclass before creating the
        // go button so that we respond to WM_NOTIFYFORMAT with NFR_UNICODE.
        //
        //
        if (SetProp(_hwnd, c_szAddressBandProp, this))
        {
           _pfnOldWndProc = (WNDPROC) SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR) _ComboExWndProc);
        }

        // Create the toolbar control for the go button
        _hwndTools = CreateWindowEx(WS_EX_TOOLWINDOW, TOOLBARCLASSNAME, NULL,
                                WS_CHILD | TBSTYLE_FLAT |
                                TBSTYLE_TOOLTIPS |
                                TBSTYLE_LIST |
                                WS_CLIPCHILDREN |
                                WS_CLIPSIBLINGS | CCS_NODIVIDER | CCS_NOPARENTALIGN |
                                CCS_NORESIZE,
                                0, 0, 0, 0, _hwnd, NULL, HINST_THISDLL, NULL);
    }

    if (_hwndTools)
    {
        // Init the toolbar control
        SendMessage(_hwndTools, TB_BUTTONSTRUCTSIZE, SIZEOF(TBBUTTON), 0);
        SendMessage(_hwndTools, TB_SETMAXTEXTROWS, 1, 0L);
        SendMessage(_hwndTools, TB_SETBUTTONWIDTH, 0, (LPARAM) MAKELONG(0, 500));
        SendMessage(_hwndTools, TB_SETIMAGELIST, 0, (LPARAM)_himlDefault);
        SendMessage(_hwndTools, TB_SETHOTIMAGELIST, 0, (LPARAM)_himlHot);

        LRESULT nRet = SendMessage(_hwndTools, TB_ADDSTRING, (WPARAM)MLGetHinst(), (LPARAM)IDS_ADDRESS_TB_LABELS);
        ASSERT(nRet == 0);

        static const TBBUTTON tbb[] =
        {
            {0, 1, TBSTATE_ENABLED, BTNS_BUTTON, {0,0}, 0, 0},
        };
        SendMessage(_hwndTools, TB_ADDBUTTONS, ARRAYSIZE(tbb), (LPARAM)tbb);

        fRet = TRUE;
    }
    else
    {
        // If no toolbar control, don't subclass the comboboxex
        if (_pfnOldWndProc)
        {
            RemoveProp(_hwnd, c_szAddressBandProp);
            SetWindowLongPtr(_hwnd, GWLP_WNDPROC, (LONG_PTR) _pfnOldWndProc);
            _pfnOldWndProc = NULL;
        }
    }

    return fRet;
}


//+-------------------------------------------------------------------------
// Shows/hides the go button depending on the current registry settings
//--------------------------------------------------------------------------
void CAddressBand::_InitGoButton()
{
    BOOL fUpdate = FALSE;
    //
    // Create the go button if it's enabled
    //
    // down-level client fix: only show Go in shell areas when NT5 or greater
    // or on a window that was originally IE

    BOOL fShowGoButton = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,
        TEXT("ShowGoButton"), FALSE, /*default*/TRUE)
        && (WasOpenedAsBrowser(_punkSite) || GetUIVersion() >= 5);

    if (fShowGoButton && (_hwndTools || _CreateGoButton()))
    {
        ShowWindow(_hwndTools, SW_SHOW);
        _fGoButton = TRUE;
        fUpdate = TRUE;
    }
    else if (_hwndTools && IsWindowVisible(_hwndTools))
    {
        ShowWindow(_hwndTools, SW_HIDE);
        _fGoButton = FALSE;
        fUpdate = TRUE;
    }

    // If the go button was hidden or shown, get the combobox to adjust itself
    if (fUpdate)
    {
        // Resetting the item height gets the combobox to update the size of the editbox
        LRESULT iHeight = SendMessage(_hwnd, CB_GETITEMHEIGHT, -1, 0);
        if (iHeight != CB_ERR)
        {
            SendMessage(_hwnd, CB_SETITEMHEIGHT, -1, iHeight);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\addrlist.h ===
/**************************************************************\
    FILE: addrlist.h

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.
\**************************************************************/

#ifndef _ADDRLIST_H
#define _ADDRLIST_H

#include "shellurl.h"
#define ACP_LIST_MAX_CONST            25

/**************************************************************\
    CLASS: CAddressList

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.

    NOTE:
        This is a virtual class!
\**************************************************************/

class CAddressList 
                : public IAddressList   // (Includes IWinEventHandler)
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////
    
    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent(HWND hwnd, UINT dwMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd) { return E_NOTIMPL; }

    // *** IAddressList methods ***
    virtual STDMETHODIMP Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac);
    virtual STDMETHODIMP NavigationComplete(LPVOID pvCShellUrl);
    virtual STDMETHODIMP Refresh(DWORD dwType) { return S_OK; }      // Force subclasses to handle.
    virtual STDMETHODIMP Load(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP Save(void) {return E_NOTIMPL;}
    virtual STDMETHODIMP SetToListIndex(int nIndex, LPVOID pvShelLUrl);
    virtual STDMETHODIMP FileSysChangeAL(DWORD dw, LPCITEMIDLIST* ppidl);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressList();
    virtual ~CAddressList(void);        // This is now an OLE Object and cannot be used as a normal Class.


    // Address Band Specific Functions
    virtual LRESULT _OnNotify(LPNMHDR pnm);
    virtual LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    virtual void _InitCombobox(void);
    virtual HRESULT _Populate(void) = 0;        // This is a PURE function.
    virtual void _PurgeComboBox();

    // Helper Functions 
    void _ComboBoxInsertURL(LPCTSTR pszURL, int cchStrSize, int nMaxComboBoxSize);
    BOOL _MoveAddressToTopOfList(int iSel);
    HRESULT _GetUrlUI(CShellUrl * psu, LPCTSTR szUrl, int *piImage, int *piImageSelected);
    HRESULT _GetFastPathIcons(LPCTSTR pszPath, int *piImage, int *piSelectedImage);
    HRESULT _GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage);
    virtual LPITEMIDLIST _GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe);
    LRESULT  _OnDragBeginW(LPNMCBEDRAGBEGINW pnmcbe);
    LRESULT  _OnDragBeginA(LPNMCBEDRAGBEGINA pnmcbe) ;
    HRESULT _SetPreferedDropEffect(IDataObject *pdtobj, DWORD dwEffect);

    //////////////////////////////////////////////////////
    //  Private Member Variables 
    //////////////////////////////////////////////////////
    int                 _cRef;
    BOOL                _fVisible:1;        // TRUE when the toolbar is visible.
    HWND                _hwnd;              // The window
    IBrowserService *   _pbs;
    IBandProxy *        _pbp;
    CShellUrl *         _pshuUrl;
};



HRESULT GetCBListIndex(HWND hwnd, int iItem, LPTSTR szAddress, int cchAddressSize);


IAddressList * CSNSList_Create(void);
IAddressList * CMRUList_Create(void);
IAddressList * CACPList_Create(void);

//===========================================================================
// IMRU: Interface to CMRUList.  Note that this interface never leaves browseui

#undef INTERFACE
#define INTERFACE IMRU
DECLARE_INTERFACE_(IMRU, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, void **ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMRU Methods ***
    STDMETHOD(AddEntry) (THIS_ LPCWSTR pszEntry) PURE;
};

#endif // _ADDRLIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\addrlist.cpp ===
/**************************************************************\
    FILE: addrlist.cpp

    DESCRIPTION:
        This is a class that all Address Lists can inherite
    from.  This will give them the IAddressList interface
    so they can work in the AddressBand/Bar.
\**************************************************************/

#include "priv.h"
#include "util.h"
#include "itbdrop.h"
#include "autocomp.h"
#include "addrlist.h"
#include "apithk.h"
#include "shui.h"
#include "shlguid.h"

CAddressList::CAddressList() : _cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // Assert that all Member Variables are inited to Zero.
    ASSERT(!_pbp);
}

CAddressList::~CAddressList()
{
    if (_pbp)
        _pbp->Release();
    if (_pbs)
        _pbs->Release();
    if (_pshuUrl)
        delete _pshuUrl;
}

ULONG CAddressList::AddRef()
{
    _cRef++;
    return _cRef;
}

ULONG CAddressList::Release()
{
    ASSERT(_cRef > 0);
    _cRef--;

    if (_cRef > 0)
        return _cRef;

    delete this;
    return 0;
}

HRESULT CAddressList::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IWinEventHandler) ||
        IsEqualIID(riid, IID_IAddressList))
    {
        *ppvObj = SAFECAST(this, IAddressList*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}


//================================
//  ** IWinEventHandler Interface ***

/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressList::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    LRESULT lres = 0;

    switch (uMsg)
    {
    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
        lres = _OnNotify((LPNMHDR)lParam);
        break;
    }

    if (plres)
        *plres = lres;

    return S_OK;
}


//================================
// *** IAddressList Interface ***

/****************************************************\
    FUNCTION: Connect

    DESCRIPTION:
        We are either becoming the selected list for
    the AddressBand's combobox, or lossing this status.
    We need to populate or unpopulate the combobox
    as appropriate.
\****************************************************/
HRESULT CAddressList::Connect(BOOL fConnect, HWND hwnd, IBrowserService * pbs, IBandProxy * pbp, IAutoComplete * pac)
{
    HRESULT hr = S_OK;

    ASSERT(hwnd);
    _fVisible = fConnect;
    _hwnd = hwnd;

    // Copy the (IBandProxy *) parameter
    if (_pbp)
        _pbp->Release();
    _pbp = pbp;
    if (_pbp)
        _pbp->AddRef();

    if (_pbs)
        _pbs->Release();
    _pbs = pbs;
    if (_pbs)
        _pbs->AddRef();

    if (fConnect)
    {
        //
        // Initial combobox parameters.
        //
        _InitCombobox();
    }
    else
    {
        // Remove contents of the List
        _PurgeComboBox();
    }

    return hr;
}


/****************************************************\
    FUNCTION: _InitCombobox

    DESCRIPTION:
        Prepare the combo box for this list.  This normally
    means that the indenting and icon are either turned
    on or off.
\****************************************************/
void CAddressList::_InitCombobox()
{
     SendMessage(_hwnd, CB_SETDROPPEDWIDTH, 200, 0L);
     SendMessage(_hwnd, CB_SETEXTENDEDUI, TRUE, 0L);
     SendMessage(_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOSIZELIMIT, CBES_EX_NOSIZELIMIT);
}


/****************************************************\
    FUNCTION: _PurgeComboBox

    DESCRIPTION:
        Removes all items from the combobox.
\****************************************************/
void CAddressList::_PurgeComboBox()
{
    if (_hwnd)
    {
        SendMessage(_hwnd, CB_RESETCONTENT, 0, 0L);
    }
}

/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
        This function will handle WM_COMMAND messages.
\****************************************************/
LRESULT CAddressList::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (uCmd)
    {
        case CBN_DROPDOWN:
            {
                HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

                //
                // DOH! The user wants to see the full combo contents.
                // Better go fill it in now.
                //
                _Populate();
                SetCursor(hCursorOld);
            }
            break;
    }
    return 0;
}


void ChangeUrl(LPCTSTR pszUrl, LPTSTR pszDisplayName, DWORD cchSize)
{
    TCHAR szTemp[MAX_URL_STRING];

    StringCchCopy(szTemp,  ARRAYSIZE(szTemp), pszUrl);     // This is necessary because pszUrl points into the buffer of pszDisplayName
    StringCchCopy(pszDisplayName, cchSize, szTemp);
}


/****************************************************\
    FUNCTION: NavigationComplete

    DESCRIPTION:
        Update the URL in the Top of the list.
\****************************************************/
HRESULT CAddressList::NavigationComplete(LPVOID pvCShellUrl)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    CShellUrl * psu = (CShellUrl *) pvCShellUrl;
    LPITEMIDLIST pidl;
    ASSERT(pvCShellUrl);
    hr = psu->GetDisplayName(szDisplayName, SIZECHARS(szDisplayName));

    if (SUCCEEDED(hr))
    {
        //
        // Don't display the url to internal error pages.  The url that should get
        // displayed is appended after the #.
        //
        // All error urls start with res:// so do a quick check first.
        //
        BOOL fChangeURL = TRUE;
        if (TEXT('r') == szDisplayName[0] && TEXT('e') == szDisplayName[1])
        {
            if (IsErrorUrl(szDisplayName))
            {
                TCHAR* pszUrl = StrChr(szDisplayName, TEXT('#'));
                if (pszUrl)
                {
                    pszUrl += 1;

                    DWORD dwScheme = GetUrlScheme(pszUrl);
                    fChangeURL = ((URL_SCHEME_HTTP == dwScheme) ||
                                  (URL_SCHEME_HTTPS == dwScheme) ||
                                  (URL_SCHEME_FTP == dwScheme) ||
                                  (URL_SCHEME_GOPHER == dwScheme));

                    // Don't blast in the stuff after the # into address bar
                    // unless it is a 'safe' url.  If it's not safe leave the
                    // addressbar alone to preserve what the user typed in.
                    //
                    // The issue here is that a web page could navigate to our internal
                    // error page with "format c:" after the '#'.  The error page
                    // suggests that the user refreshed the page which would be very bad!
                    if (fChangeURL)
                    {
                        ChangeUrl(pszUrl, szDisplayName, ARRAYSIZE(szDisplayName));
                    }
                }
            }
        }

        if (fChangeURL)
        {
            SHRemoveURLTurd(szDisplayName);
            SHCleanupUrlForDisplay(szDisplayName);

            hr = psu->GetPidl(&pidl);
            if (SUCCEEDED(hr))
            {
                COMBOBOXEXITEM cbexItem = {0};
                cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
                cbexItem.iItem = -1;
                cbexItem.pszText = szDisplayName;
                cbexItem.cchTextMax = ARRAYSIZE(szDisplayName);

                hr = _GetPidlIcon(pidl, &(cbexItem.iImage), &(cbexItem.iSelectedImage));
                SendMessage(_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);

                ILFree(pidl);
            }
        }
    }

    TraceMsg(TF_BAND|TF_GENERAL, "CAddressList: NavigationComplete(), URL=%s", szDisplayName);
    return hr;
}

/*******************************************************************
    FUNCTION: _MoveAddressToTopOfList

    PARAMETERS:
        iSel - index of item in combo box to move

    DESCRIPTION:
        Moves the specified selection in the combo box
    to be the first item in the combo box
********************************************************************/
BOOL CAddressList::_MoveAddressToTopOfList(int iSel)
{
    BOOL fRet = FALSE;

    ASSERT(iSel >= 0);   // must have valid index

    COMBOBOXEXITEM cbexItem = {0};
    TCHAR szAddress[MAX_URL_STRING+1];

    cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
    cbexItem.pszText = szAddress;
    cbexItem.cchTextMax = ARRAYSIZE(szAddress);
    cbexItem.iItem = iSel;

    
    // get the specified item from combo box
    if (SendMessage(_hwnd,CBEM_GETITEM,0,(LPARAM) &cbexItem)) {

        SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)iSel, (LPARAM)0);

        // re-insert it at index 0 to put it at the top
        cbexItem.iItem = 0;

        // sending CBEM_INSERTITEM should return the index we specified
                // (0) if successful
        fRet = (SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0,
            (LPARAM)(LPVOID)&cbexItem) == 0);
    }

    return fRet;
}



/*******************************************************************
    FUNCTION: _ComboBoxInsertURL

    DESCRIPTION:
        Adds the specified URL to the top of the address bar
    combo box.  Limits the number of URLs in combo box to
    nMaxComboBoxSize.
********************************************************************/
void CAddressList::_ComboBoxInsertURL(LPCTSTR pszURL, int cchStrSize, int nMaxComboBoxSize)
{
    // Since we own it and it's populated,
    // we will add it directly to the ComboBox.
    int iPrevInstance;

    int iImage, iSelectedImage ;

    COMBOBOXEXITEM cbexItem = {0};
    cbexItem.mask = CBEIF_TEXT | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
    cbexItem.iItem = 0;

    cbexItem.cchTextMax = cchStrSize;
    cbexItem.pszText = (LPTSTR)pszURL;

    _GetUrlUI(NULL, (LPTSTR)pszURL, &iImage, &iSelectedImage);

    cbexItem.iImage = iImage;
    cbexItem.iSelectedImage = iSelectedImage;


    iPrevInstance = (int)SendMessage(_hwnd, CB_FINDSTRINGEXACT, (WPARAM)-1,  (LPARAM)pszURL);
    if (iPrevInstance != CB_ERR) {
        _MoveAddressToTopOfList(iPrevInstance);
        return;
    }

    // insert the URL as the first item in combo box
    SendMessage(_hwnd, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);

    // limit number of items in combo box to nMaxComboBoxSize
    if (ComboBox_GetCount(_hwnd) > nMaxComboBoxSize)
    {
        // if we're ever over the limit, we should only be over the limit
        // by exactly one item
        ASSERT(ComboBox_GetCount(_hwnd) == nMaxComboBoxSize+1);

        // if over the limit, delete the least recently used
        // (the one with the highest index)

        SendMessage(_hwnd, CBEM_DELETEITEM, (WPARAM)nMaxComboBoxSize, (LPARAM)0);

    }
}


/*******************************************************************
    FUNCTION: SetToListIndex

    DESCRIPTION:
        This function will set the CShellUrl parameter to the item
    in the Drop Down list that is indexed by nIndex.
********************************************************************/
HRESULT CAddressList::SetToListIndex(int nIndex, LPVOID pvShelLUrl)
{
    HRESULT hr = S_OK;
    TCHAR szBuffer[MAX_URL_STRING];
    CShellUrl * psuURL = (CShellUrl *) pvShelLUrl;

    if (SUCCEEDED(GetCBListIndex(_hwnd, nIndex, szBuffer, SIZECHARS(szBuffer))))
    {
        hr = psuURL->ParseFromOutsideSource(szBuffer, SHURL_FLAGS_NOUI);
        ASSERT(SUCCEEDED(hr));  // We should not have added it to the Drop Down list if it's invalid.
    }

    return hr;
}

HRESULT CAddressList::FileSysChangeAL(DWORD dw, LPCITEMIDLIST *ppidl)
{
    return S_OK;
}


/****************************************************\
    FUNCTION: GetCBListIndex

    DESCRIPTION:
        This function will get the text of a specified
    element in the combobox.
\****************************************************/
HRESULT GetCBListIndex(HWND hwnd, int iItem, LPTSTR szAddress, int cchAddressSize)
{
    HRESULT hr = E_FAIL;
    COMBOBOXEXITEM cbexItem = {0};

    cbexItem.mask = CBEIF_TEXT;
    cbexItem.pszText = szAddress;
    cbexItem.cchTextMax = cchAddressSize;
    cbexItem.iItem = iItem;

    if (SendMessage(hwnd, CBEM_GETITEM, 0, (LPARAM) &cbexItem))
        hr = S_OK;

    return hr;
}


// Helper Function
// We need to really becareful of perf in this function.
HRESULT CAddressList::_GetUrlUI(CShellUrl *psu, LPCTSTR szUrl, int *piImage, int *piSelectedImage)
{
    CShellUrl * psuUrl;
    HRESULT hr = E_FAIL;

    if (psu)
        psuUrl = psu;
    else
    {
        psuUrl = new CShellUrl();
        if (psuUrl)
        {
            // Set the parent for error messageboxes.  Note that this could end up disabing the taskbar.
            // If this is deemed to be a problem we can first check to see where the addressbar is hosted.
            psuUrl->SetMessageBoxParent(_hwnd);

            SetDefaultShellPath(psuUrl);
        }
    }

    //Initialize the values to 0
    *piImage = 0;
    *piSelectedImage = 0;

    //if object is not created return with default value
    if (!psuUrl)
        return E_OUTOFMEMORY;

#ifdef DISABLED // Why not show the correct icon for removable drives?
    int iDrive;

    // See if we have a drive specified in the path
    if ((iDrive = PathGetDriveNumber(szUrl)) >= 0)
    {
        // See if the drive is removable ?
        if(DriveType(iDrive) == DRIVE_REMOVABLE)
            hr = S_OK;    //Drive is removable so pass the default icons
    }
#endif

    // Do we still need to get the icons?
    if (FAILED(hr))
    {
        // Yes, so try the fast way first.
        hr = _GetFastPathIcons(szUrl, piImage, piSelectedImage);
        if (FAILED(hr))
        {
            LPITEMIDLIST pidl = NULL;

            // If that failed because it the string probably uses advanced parsing, 
            // let CShellUrl do it the slower but more thurough way.
            hr = psuUrl->ParseFromOutsideSource(szUrl, SHURL_FLAGS_NOUI);
            if(SUCCEEDED(hr))
                hr = psuUrl->GetPidl(&pidl);

            if(SUCCEEDED(hr))
            {
                hr = _GetPidlIcon(pidl, piImage, piSelectedImage);
                ILFree(pidl);
            }
        }
    }

    if (psu != psuUrl)
        delete psuUrl;

    return hr;
}


// IECreateFromPath() and CShellUrl::ParseFromOutsideSource() both
// touch the disk which causes unconnected network cases to be really
// slow.  This will create icons for file system paths w/o hitting
// the disk.
HRESULT CAddressList::_GetFastPathIcons(LPCTSTR pszPath, int *piImage, int *piSelectedImage)
{
    SHFILEINFO shFileInfo = {0};

    // SHGetFileInfo() with those flags will be fast because it's won't filter out
    // garbage passed to it.  So it will think URLs are actually relative paths
    // and accept them.  We will fall back to the slow advanced parser which is still
    // fast with URLs.
    if (PathIsRelative(pszPath))
        return E_FAIL;

    HIMAGELIST himl = (HIMAGELIST) SHGetFileInfo(pszPath, FILE_ATTRIBUTE_DIRECTORY, &shFileInfo, sizeof(shFileInfo), (SHGFI_SYSICONINDEX | SHGFI_SMALLICON | SHGFI_USEFILEATTRIBUTES));
    if (!himl || !shFileInfo.iIcon)
        return E_FAIL;

    *piImage = shFileInfo.iIcon;
    *piSelectedImage = shFileInfo.iIcon;
    // I don't need to free himl.

    return S_OK;
}


HRESULT CAddressList::_GetPidlIcon(LPCITEMIDLIST pidl, int *piImage, int *piSelectedImage)
{
    IShellFolder *psfParent;
    LPCITEMIDLIST pidlChild;
    HRESULT hr = IEBindToParentFolder(pidl, &psfParent, &pidlChild);
    if (SUCCEEDED(hr))
    {
        *piImage = IEMapPIDLToSystemImageListIndex(psfParent, pidlChild, piSelectedImage);
        psfParent->Release();
    }
    return hr;
}

LPITEMIDLIST CAddressList::_GetDragDropPidl(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl = NULL;
    CShellUrl *psuUrl = new CShellUrl();
    if (psuUrl)
    {
        // Set the parent for error messageboxes.  Note that this could end up disabing the taskbar.
        // If this is deemed to be a problem we can first check to see where the addressbar is hosted.
        psuUrl->SetMessageBoxParent(_hwnd);

        HRESULT hr = SetDefaultShellPath(psuUrl);
        if (SUCCEEDED(hr))
        {
            hr = psuUrl->ParseFromOutsideSource(pnmcbe->szText, SHURL_FLAGS_NOUI, NULL);
            if (SUCCEEDED(hr))
            {
                hr = psuUrl->GetPidl(&pidl);
            }
        }

        delete psuUrl;
    }
    return pidl;
}

LRESULT CAddressList::_OnDragBeginA(LPNMCBEDRAGBEGINA pnmcbe)
{
    NMCBEDRAGBEGINW  nmcbew;

    nmcbew.hdr = pnmcbe->hdr;
    nmcbew.iItemid = pnmcbe->iItemid;
    SHAnsiToUnicode(pnmcbe->szText, nmcbew.szText, SIZECHARS(nmcbew.szText));

    return _OnDragBeginW(&nmcbew);
}


LRESULT CAddressList::_OnDragBeginW(LPNMCBEDRAGBEGINW pnmcbe)
{
    LPITEMIDLIST pidl = _GetDragDropPidl(pnmcbe);
    if (pidl) 
    {
        IOleCommandTarget *pcmdt = NULL;

        IUnknown *punk;
        if (_pbp && SUCCEEDED(_pbp->GetBrowserWindow(&punk)))
        {
            punk->QueryInterface(IID_IOleCommandTarget, (void **)&pcmdt);
            punk->Release(); 
        }

        DoDragDropWithInternetShortcut(pcmdt, pidl, _hwnd);

        if (pcmdt)
            pcmdt->Release();

        ILFree(pidl);
    }

    return 0;
}

// handle WM_NOTIFY messages.
LRESULT CAddressList::_OnNotify(LPNMHDR pnm)
{
    LRESULT lReturn = 0;

    switch (pnm->code)
    {
    case NM_SETCURSOR:
        if (!(SendMessage(_hwnd, CBEM_GETEXTENDEDSTYLE, 0, 0) & CBES_EX_NOEDITIMAGE))
        {
            RECT rc;
            POINT pt;
            int cx, cy;
            GetCursorPos(&pt);
            GetClientRect(_hwnd, &rc);
            MapWindowRect(_hwnd, HWND_DESKTOP, &rc);
            ImageList_GetIconSize((HIMAGELIST)SendMessage(_hwnd, CBEM_GETIMAGELIST, 0, 0), &cx, &cy);

            rc.right = rc.left + cx + GetSystemMetrics(SM_CXEDGE);
            if (PtInRect(&rc, pt)) 
            {
                // this means there's an image, which means we can drag
                SetCursor(LoadHandCursor(0));
                return 1;
            }
        }
        break;

        case CBEN_DRAGBEGINA:
            lReturn = _OnDragBeginA((LPNMCBEDRAGBEGINA)pnm);
            break;

        case CBEN_DRAGBEGINW:
            lReturn = _OnDragBeginW((LPNMCBEDRAGBEGINW)pnm);
            break;
    }

    return lReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\aeditbox.cpp ===
/**************************************************************\
    FILE: aeditbox.cpp

    DESCRIPTION:
        The Class CAddressEditBox exists to support a typical
    set of functionality used in Editboxes or ComboBoxes.  This
    object will add AutoComplete functionality to the EditBox and
    specify default "AutoComplete" Lists.  If the control is a
    ComboBoxEd, this object will populate the drop down list
    appropriately.
\**************************************************************/

#include "priv.h"
#include "sccls.h"
#include "addrlist.h"
#include "itbar.h"
#include "itbdrop.h"
#include "util.h"
#include "aclhist.h"
#include "aclmulti.h"
#include "autocomp.h"
#include "address.h"
#include "shellurl.h"
#include "bandprxy.h"
#include "uemapp.h"
#include "apithk.h"
#include "accdel.h"

#include "resource.h"
#include "mluisupp.h"


extern DWORD g_dwStopWatchMode;

// Needed in order to track down NTRAID#187504-Bryanst-Tracking Winsta for corruption
HWINSTA g_hWinStationBefore = NULL;
HWINSTA g_hWinStationAfter = NULL;
HWINSTA g_hWinStationAfterEx = NULL;

// Internal message for async processing of the IDList when navigating
UINT    g_nAEB_AsyncNavigation = 0;

///////////////////////////////////////////////////////////////////
// #DEFINEs
#define SZ_ADDRESSCOMBO_PROP            TEXT("CAddressCombo_This")
#define SZ_ADDRESSCOMBOEX_PROP          TEXT("CAddressComboEx_This")
#define SEL_ESCAPE_PRESSED  (-2)



///////////////////////////////////////////////////////////////////
// Data Structures
enum ENUMLISTTYPE
{
    LT_NONE,
    LT_SHELLNAMESPACE,
    LT_TYPEIN_MRU,
};

///////////////////////////////////////////////////////////////////
// class AsyncNav: this object contains all the necessary information
//                 to execute an asynchronous navigation task, so that
//                 the user doesn't have to wait for navigation to
//                 finish before doing anything, and the navigation
//                 can be canceled if it takes too long.

class AsyncNav
{
public:
// Public Functions ***************************************

    AsyncNav()
    {
        _cRef = 1;
        _pShellUrl = NULL;
        _pszUrl = NULL;
    }

    LONG AddRef()
    {
        return InterlockedIncrement(&_cRef);
    }

    LONG Release()
    {
        ASSERT( 0 != _cRef );
        LONG cRef = InterlockedDecrement(&_cRef);
        if ( 0 == cRef )
        {
            delete this;
        }
        return cRef;
    }
    void    SetCanceledFlag() {_fWasCanceled = TRUE;}

// Data members ***************************************
    
    CShellUrl * _pShellUrl;
    DWORD       _dwParseFlags;
    BOOL        _fWasCorrected;
    BOOL        _fPidlCheckOnly;
    HRESULT     _hr;
    LPTSTR      _pszUrl;
    BOOL        _fWasCanceled;

    HWND        _hwnd;  // HWND that receives the message when processing is done.
    
    BOOL        _fReady; // This ensures that we will not try to use the object before it's ready
                         // CONSIDER: the memory can be released and then re-used by the same object
                         // CONSIDER: which would have us believe that the navigation should be done.
                         // CONSIDER: But if the navigation had been canceled and the memory re-used by the next AsyncNav alloc
                         // CONSIDER: we would handle the message g_nAEB_AsyncNavigation with an
                         // CONSIDER: unprocessed AsyncNav object. (See the handler for g_nAEB_AsyncNavigation).

private:
    LONG _cRef;
    ~AsyncNav()
    {
        delete _pShellUrl;
        _pShellUrl = NULL;
        Str_SetPtr(&_pszUrl, NULL);
    }
};

///////////////////////////////////////////////////////////////////
// Prototypes

/**************************************************************\
    CLASS: CAddressEditBox
\**************************************************************/
class CAddressEditBox
                : public IWinEventHandler
                , public IDispatch
                , public IAddressBand
                , public IAddressEditBox
                , public IOleCommandTarget
                , public IPersistStream
                , public IShellService
{
public:
    //////////////////////////////////////////////////////
    // Public Interfaces
    //////////////////////////////////////////////////////

    // *** IUnknown ***
    virtual STDMETHODIMP_(ULONG) AddRef(void);
    virtual STDMETHODIMP_(ULONG) Release(void);
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IOleCommandTarget methods ***
    virtual STDMETHODIMP QueryStatus(const GUID *pguidCmdGroup, ULONG cCmds,
                        OLECMD rgCmds[], OLECMDTEXT *pcmdtext);
    virtual STDMETHODIMP Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut);

    // *** IWinEventHandler methods ***
    virtual STDMETHODIMP OnWinEvent (HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* plre);
    virtual STDMETHODIMP IsWindowOwner(HWND hwnd);

    // *** IDispatch methods ***
    virtual STDMETHODIMP GetTypeInfoCount(UINT *pctinfo) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetTypeInfo(UINT itinfo,LCID lcid,ITypeInfo **pptinfo) {return E_NOTIMPL;}
    virtual STDMETHODIMP GetIDsOfNames(REFIID riid,OLECHAR **rgszNames,UINT cNames, LCID lcid, DISPID * rgdispid) {return E_NOTIMPL;}
    virtual STDMETHODIMP Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo,UINT * puArgErr);

    // *** IPersistStream methods ***
    virtual STDMETHODIMP GetClassID(CLSID *pClassID){ *pClassID = CLSID_AddressEditBox; return S_OK; }
    virtual STDMETHODIMP Load(IStream *pStm) {return S_OK;}
    virtual STDMETHODIMP Save(IStream *pStm, BOOL fClearDirty) { Save(0); return S_OK;}
    virtual STDMETHODIMP IsDirty(void) {return S_OK;}       // Indicate that we are dirty and ::Save() needs to be called.
    virtual STDMETHODIMP GetSizeMax(ULARGE_INTEGER *pcbSize) {return E_NOTIMPL;}

    // *** IAddressBand methods ***
    virtual STDMETHODIMP FileSysChange(DWORD dwEvent, LPCITEMIDLIST *ppidl);
    virtual STDMETHODIMP Refresh(VARIANT * pvarType);

    // *** IAddressEditBox methods ***
    virtual STDMETHODIMP Init(HWND hwndComboBox, HWND hwndEditBox, DWORD dwFlags, IUnknown * punkParent);
    virtual STDMETHODIMP SetCurrentDir(LPCOLESTR pwzDir);
    virtual STDMETHODIMP ParseNow(DWORD dwFlags);
    virtual STDMETHODIMP Execute(DWORD dwExecFlags);
    virtual STDMETHODIMP Save(DWORD dwReserved);

    // *** IShellService methods ***
    STDMETHODIMP SetOwner(IUnknown* punkOwner);

protected:
    //////////////////////////////////////////////////////
    // Private Member Functions
    //////////////////////////////////////////////////////

    // Constructor / Destructor
    CAddressEditBox();
    ~CAddressEditBox(void);        // This is now an OLE Object and cannot be used as a normal Class.

    LRESULT _OnNotify(LPNMHDR pnm);
    LRESULT _OnCommand(WPARAM wParam, LPARAM lParam);
    LRESULT _OnBeginEdit(LPNMHDR pnm) ;
    LRESULT _OnEndEditW(LPNMCBEENDEDITW pnmW);
    LRESULT _OnEndEditA(LPNMCBEENDEDITA pnmA);

    HRESULT _ConnectToBrwsrConnectionPoint(BOOL fConnect, IUnknown * punk);
    HRESULT _ConnectToBrwsrWnd(IUnknown* punk);
    HRESULT _UseNewList(ENUMLISTTYPE eltNew);
    HRESULT _CreateCShellUrl(void);

    HRESULT _HandleUserAction(LPCTSTR pszUrl, int iNewSelection);
    HRESULT _NavigationComplete(LPCTSTR pszUrl, BOOL fChangeLists, BOOL fAddToMRU);
    void    _SetAutocompleteOptions();
    void    _GetUrlAndCache(void);
    BOOL _IsShellUrl(void);

    static HRESULT _NavigateToUrlCB(LPARAM lParam, LPTSTR lpUrl);
    static LRESULT CALLBACK _ComboSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);

    // Functions for keeping dirty contents from getting clobbered
    BOOL    _IsDirty();
    void    _ClearDirtyFlag();
    void    _InstallHookIfDirty();
    void    _RemoveHook();
    LRESULT _MsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs);
    static LRESULT CALLBACK CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _ComboExSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static LRESULT CALLBACK _EditSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam);
    static BOOL CALLBACK _EnumFindWindow(HWND hwnd, LPARAM lParam);

    HRESULT _FinishNavigate();
    static DWORD WINAPI _AsyncNavigateThreadProc(LPVOID pvData); // do async navigation: figure out the PIDL on a separate thread.
    
    void _JustifyAddressBarText( void );
    HRESULT _AsyncNavigate(AsyncNav *pAsyncNav);
    HRESULT _CancelNavigation();

    // Friend Functions
    friend HRESULT CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi);

    //////////////////////////////////////////////////////
    //  Private Member Variables
    //////////////////////////////////////////////////////
    int             m_cRef;              // COM Object Ref Count

    IUnknown *      m_punkParent;        // Our Parent that will receive events if something happens.
    DWORD           m_dwFlags;           // Flags that will modify the behavior of this object.
    HWND            m_hwnd;              // Address ComboBoxEx Control if we control a ComboBoxEx.
    HWND            m_hwndEdit;          // Address EditBox Control Window
    WNDPROC         m_lpfnComboWndProc;  // Former WndProc of Combo child
    int             m_nOldSelection;     // Previous Drop Down Selection.

    // Objects for Navigation
    IBandProxy *    m_pbp;               // The BandProxy that will take care of finding the window to Navigate.
    IBrowserService*m_pbs;               // Only valid when we are in a Browser Windows Toolbar. (Not Toolband)
    DWORD           m_dwcpCookie;        // ConnectionPoint cookie for DWebBrowserEvents2 from the Browser Window.
    LPTSTR          m_pszCurrentUrl;     // Needed in case refresh occurs.
    LPTSTR          m_pszPendingURL;     // Pending URL.  We hang on to it until navigation finished before adding to MRU.
    LPTSTR          m_pszUserEnteredURL; // Keep the exact text the user entered just in case we need to do a search.
    LPTSTR          m_pszHttpErrorUrl;
    BOOL            m_fDidShellExec;     // Was the last navigation handled by calleding ShellExec()? (Used when refreshing)
    BOOL            m_fConnectedToBrowser; // Are we connected to a browser?

    AsyncNav *      m_pAsyncNav;

    // AutoComplete Functionality
    IAutoComplete2* m_pac;               // AutoComplete object
    IShellService * m_pssACLISF;         // AutoComplete ISF List.  Needed if we need to change browsers.

    // AddressLists
    ENUMLISTTYPE    m_elt;
    ENUMLISTTYPE    m_eltPrevious;
    IAddressList *  m_palCurrent;        // CurrentList.
    IAddressList *  m_palSNS;            // Shell Name Space List.
    IAddressList *  m_palMRU;            // Type-in MRU List.
    IMRU *          m_pmru;              // MRU List.
    CShellUrl *     m_pshuUrl;

    // Variables for keeping dirty contens from getting clobbered
    static CAssociationList m_al;        // associate thread id with this class
    WNDPROC         m_lpfnComboExWndProc;// Former WndProc of ComboBoxEx
    WNDPROC         m_lpfnEditWndProc;   // Former WndProc of Edit control in ComboBox
    HHOOK           m_hhook;             // mouse message hook
    COMBOBOXEXITEM  m_cbex;              // last change received while dirty
    HWND            m_hwndBrowser;       // top-level browser window
    BOOL            m_fAssociated;       // if we are entered in m_al for this thread
    BOOL            m_fAsyncNavInProgress; // tells if we have a pending async navigate already in progress
};

class CAddressEditAccessible : public CDelegateAccessibleImpl
{
public:
    CAddressEditAccessible(HWND hwndCombo, HWND hwndEdit);

    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);

    // *** IAccessible ***
    STDMETHODIMP get_accName(VARIANT varChild, BSTR  *pszName);
    STDMETHODIMP get_accValue(VARIANT varChild, BSTR  *pszValue);

protected:
    virtual ~CAddressEditAccessible();

private:
    LONG    m_cRefCount;
    HWND    m_hwndEdit;
    LPWSTR  m_pwszName;
};


//=================================================================
// Static variables
//=================================================================
CAssociationList CAddressEditBox::m_al;

//=================================================================
// Implementation of CAddressEditBox
//=================================================================

//===========================
// *** IUnknown Interface ***

HRESULT CAddressEditBox::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IWinEventHandler))
    {
        *ppvObj = SAFECAST(this, IWinEventHandler*);
    }
    else if (IsEqualIID(riid, IID_IDispatch))
    {
        *ppvObj = SAFECAST(this, IDispatch*);
    }
    else if (IsEqualIID(riid, IID_IAddressBand))
    {
        *ppvObj = SAFECAST(this, IAddressBand*);
    }
    else if (IsEqualIID(riid, IID_IAddressEditBox))
    {
        *ppvObj = SAFECAST(this, IAddressEditBox*);
    }
    else if (IsEqualIID(riid, IID_IOleCommandTarget))
    {
        *ppvObj = SAFECAST(this, IOleCommandTarget*);
    }
    else if (IsEqualIID(riid, IID_IPersistStream))
    {
        *ppvObj = SAFECAST(this, IPersistStream*);
    }
    else if (IsEqualIID(riid, IID_IShellService))
    {
        *ppvObj = SAFECAST(this, IShellService*);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }

    AddRef();
    return S_OK;
}

ULONG CAddressEditBox::AddRef(void)
{
    m_cRef++;
    return m_cRef;
}

ULONG CAddressEditBox::Release(void)
{
    ASSERT(m_cRef > 0);

    m_cRef--;

    if (m_cRef > 0)
    {
        return m_cRef;
    }

    delete this;
    return 0;
}


//=====================================
// *** IOleCommandTarget Interface ***

HRESULT CAddressEditBox::QueryStatus(const GUID *pguidCmdGroup,
    ULONG cCmds, OLECMD rgCmds[], OLECMDTEXT *pcmdtext)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (rgCmds == NULL)
    {
        return(E_INVALIDARG);
    }

    if (pguidCmdGroup==NULL)
    {
        hr = S_OK;

        for (UINT i=0; i<cCmds; i++)
        {
            ULONG l;
            rgCmds[i].cmdf = 0;

            switch (rgCmds[i].cmdID)
            {
            case OLECMDID_PASTE:
                if (m_hwndEdit && OpenClipboard(m_hwndEdit))
                {
                    // IDEA: We might want to support CF_URL here (SatoNa)
                    if (GetClipboardData(CF_TEXT))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                    CloseClipboard();
                }
                break;

            case OLECMDID_COPY:
            case OLECMDID_CUT:
                if (m_hwndEdit)
                {
                    l=(ULONG)SendMessage(m_hwndEdit, EM_GETSEL, 0, 0);
                    if (LOWORD(l) != HIWORD(l))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                }
                break;
            case OLECMDID_SELECTALL:
                if (m_hwndEdit)
                {
                    // Select All -- not allowed if there's no text or if everything is
                    // selected.   Latter case takes care of first one.
                    int ichMinSel;
                    int ichMaxSel;
                    int cch = (int)SendMessage(m_hwndEdit, WM_GETTEXTLENGTH, 0, 0);
                    SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&ichMinSel, (LPARAM)&ichMaxSel);

                    if ((ichMinSel != 0) || (ichMaxSel != cch))
                    {
                        rgCmds[i].cmdf = OLECMDF_ENABLED;
                    }
                }
            }
        }
    }

    return(hr);
}

HRESULT CAddressEditBox::Exec(const GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt,
                        VARIANTARG *pvarargIn, VARIANTARG *pvarargOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (pguidCmdGroup == NULL)
    {
        hr = S_OK;

        switch(nCmdID)
        {
        case OLECMDID_COPY:
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_COPY, 0, 0);
            break;

        case OLECMDID_PASTE:
            // IDEA: We might want to support CF_URL here (SatoNa)
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_PASTE, 0, 0);
            break;

        case OLECMDID_CUT:
            if (m_hwndEdit)
                SendMessage(m_hwndEdit, WM_CUT, 0, 0);
            break;

        case OLECMDID_SELECTALL:
            if (m_hwndEdit)
                Edit_SetSel(m_hwndEdit, 0, (LPARAM)-1);
            break;

        default:
            hr = OLECMDERR_E_UNKNOWNGROUP;
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_Explorer, *pguidCmdGroup))
    {
        hr = S_OK;

        switch (nCmdID)
        {
        case SBCMDID_ERRORPAGE:
            {
                // We save urls to error pages so that they don't get placed
                // into the MRU
                if (pvarargIn && pvarargIn->vt == VT_BSTR)
                {
                    // Save the location where the error occured
                    Str_SetPtr(&m_pszHttpErrorUrl, pvarargIn->bstrVal);
                }
                break;
            }
        case SBCMDID_AUTOSEARCHING:
            {
                // The address did not resolve so the string is about to be sent
                // to the search engine or autoscanned.  There is a good chance
                // the pending url had "http:\\" prefixed which is a bogus url.
                // So let's put what the user typed into the mru instead.
                //
                Str_SetPtr(&m_pszPendingURL, m_pszUserEnteredURL);
                break;
            }

        case SBCMDID_GETUSERADDRESSBARTEXT:
            UINT cb = (m_pszUserEnteredURL ? (lstrlen(m_pszUserEnteredURL) + 1) : 0);
            BSTR bstr = NULL;

            VariantInit(pvarargOut);

            if (cb)
                bstr = SysAllocStringLen(NULL, cb);
            if (bstr)
            {
                SHTCharToUnicode(m_pszUserEnteredURL, bstr, cb);
                pvarargOut->vt = VT_BSTR|VT_BYREF;
                pvarargOut->byref = bstr;
            }
            else
            {
                // VariantInit() might do this for us.
                pvarargOut->vt = VT_EMPTY;
                pvarargOut->byref = NULL;
                return E_FAIL;   // Edit_GetText gave us nothing
            }
            break;
        }
    }
    else if (pguidCmdGroup && IsEqualGUID(CGID_AddressEditBox, *pguidCmdGroup))
    {
        switch (nCmdID)
        {
        case AECMDID_SAVE:
            hr = Save(0);
            break;
        default:
            hr = E_NOTIMPL;
            break;
        }
    }
    return(hr);
}


//================================
//  ** IWinEventHandler Interface ***

/****************************************************\
    FUNCTION: OnWinEvent

    DESCRIPTION:
        This function will give receive events from
    the parent ShellToolbar.
\****************************************************/
HRESULT CAddressEditBox::OnWinEvent(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT *plres)
{
    LRESULT lres = 0;

    switch (uMsg) {
    case WM_WININICHANGE:
        {
            HWND hwndLocal = (m_hwnd ? m_hwnd : m_hwndEdit);
            if (hwndLocal)
                SendMessage(hwndLocal, uMsg, wParam, lParam);

            // MRU Needs it because it May Need to purge the MRU even if it isn't the current list.
            if ((m_palCurrent != m_palMRU) && m_palMRU)
                m_palMRU->OnWinEvent(m_hwnd, uMsg, wParam, lParam, plres);

            _SetAutocompleteOptions();
        }
        break;

    case WM_COMMAND:
        lres = _OnCommand(wParam, lParam);
        break;

    case WM_NOTIFY:
        lres = _OnNotify((LPNMHDR)lParam);
        break;
    }

    if (plres)
        *plres = lres;

    // All Events get all events, and they need to determine
    // if they are active to act on most of the events.

    if (m_hwnd)
    {
        if (m_palCurrent)
        {
            m_palCurrent->OnWinEvent(m_hwnd, uMsg, wParam, lParam, plres);
        }

        // If we are dropping down the list, the above call could have
        // changed the selection, so grab it again...

        if ((uMsg == WM_COMMAND) && (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_DROPDOWN))
        {
            m_nOldSelection = ComboBox_GetCurSel(m_hwnd);

            // If nothing selected, and something matches the contents of the editbox, select that
            if (m_nOldSelection == -1)
            {
                TCHAR szBuffer[MAX_URL_STRING];
                GetWindowText(m_hwnd, szBuffer, SIZECHARS(szBuffer));

                m_nOldSelection = (int)SendMessage(m_hwnd, CB_FINDSTRINGEXACT, (WPARAM)-1,  (LPARAM)szBuffer);
                if (m_nOldSelection != CB_ERR)
                {
                    ComboBox_SetCurSel(m_hwnd, m_nOldSelection);
                }
            }
        }
    }

    return S_OK;
}


/****************************************************\
    FUNCTION: IsWindowOwner

    DESCRIPTION:
        This function will return TRUE if the HWND
    passed in is a HWND owned by this band.
\****************************************************/
HRESULT CAddressEditBox::IsWindowOwner(HWND hwnd)
{
    if (hwnd == m_hwnd)
        return S_OK;

    if (m_hwndEdit && (hwnd == m_hwndEdit))
        return S_OK;

    return S_FALSE;
}


void CAddressEditBox::_GetUrlAndCache(void)
{
    TCHAR szTemp[MAX_URL_STRING];

    // This will fail when the browser first opens and the first navigation to the
    // default home page doesn't start downloading yet.
    if (SUCCEEDED(m_pshuUrl->GetUrl(szTemp, SIZECHARS(szTemp))))
    {
        SHRemoveURLTurd(szTemp);
        SHCleanupUrlForDisplay(szTemp);
        Str_SetPtr(&m_pszCurrentUrl, szTemp);      // Used when refreshing
    }
    else
    {
        Str_SetPtr(&m_pszCurrentUrl, NULL);
    }
}


//================================
// *** IDispatch Interface ***
/****************************************************\
    FUNCTION: Invoke

    DESCRIPTION:
        This function will give receive events from
    the Browser Window if this band is connected
    to one.  This will allow this band to remain up
    todate when the browser window changes URL by
    another means.
\****************************************************/
HRESULT CAddressEditBox::Invoke(DISPID dispidMember,REFIID riid,LCID lcid,WORD wFlags,
                  DISPPARAMS * pdispparams, VARIANT * pvarResult,
                  EXCEPINFO * pexcepinfo,UINT * puArgErr)
{
    HRESULT hr = S_OK;

    ASSERT(pdispparams);
    if (!pdispparams)
        return E_INVALIDARG;

    switch(dispidMember)
    {
        case DISPID_NAVIGATECOMPLETE: // This is when we have bits back?
            ASSERT(0);      // We didn't ask to synch these.
            break;

        // The event DISPID_NAVIGATECOMPLETE2 may be sent several times during
        // redirects.
        // The event DISPID_DOCUMENTCOMPLETE will only happen after navigation is
        // finished.
        case DISPID_DOCUMENTCOMPLETE:
            Str_SetPtr(&m_pszUserEnteredURL, NULL);
            break;

        case DISPID_NAVIGATECOMPLETE2:
        {
            DWORD dwCurrent;
            BOOL fFound = FALSE;

            ASSERT(m_elt != LT_NONE);
            IBrowserService* pbs = NULL;

            for (dwCurrent = 0; dwCurrent < pdispparams->cArgs; dwCurrent++)
            {
                if (pdispparams->rgvarg[dwCurrent].vt == VT_DISPATCH)
                {
                    // See who's sending us this event
                    hr = IUnknown_QueryService(pdispparams->rgvarg[dwCurrent].pdispVal, SID_SShellBrowser, IID_IBrowserService, (void**)&pbs);
                    if (pbs)
                    {
                        // We don't really need this interface, just its address
                        pbs->Release();
                    }
                    if (FAILED(hr) || pbs != m_pbs)
                    {
                        // Notification must have come from a frame, so ignore it because
                        // it doesn't affect the URL in the address bar.
                        return S_OK;
                    }
                }
                else if (!fFound)
                {
                    if ((pdispparams->rgvarg[dwCurrent].vt == VT_BSTR) ||
                        ((pdispparams->rgvarg[dwCurrent].vt == (VT_VARIANT|VT_BYREF)) &&
                        (pdispparams->rgvarg[dwCurrent].pvarVal->vt == VT_BSTR)))
                    {
                        fFound = TRUE;
                    }
                }
            }
            ASSERT(fFound);
            hr = _CreateCShellUrl();
            if (FAILED(hr))
                return hr;

            // Yes, so let's set our current working directory to the current window.
            ASSERT(m_pbs);
            LPITEMIDLIST pidl;

            if (SUCCEEDED(hr = m_pbs->GetPidl(&pidl)))
            {
                DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
                TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::Invoke(), Current Pidl in TravelLog. PIDL=%s;", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

                ASSERT(pidl);
                // m_pshuUrl will free pshuCurrWorkDir, so we can't.

                hr = m_pshuUrl->SetPidl(pidl);
                ILFree(pidl);

                _GetUrlAndCache();      // We call this function so stack space is only used temporarily.  It will set m_pszCurrentUrl.
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszTempURL = NULL;

                    // WARNING: This code looks really strange, but it is necessary.  Normally,
                    // I would like to pass m_pszCurrentUrl as an arg to _NavigationComplete.  The problem
                    // is that the _NavigationComplete calls m_palCurrent->NavigationComplete() which will replace
                    // the value in m_pszCurrentUrl.  So I need to pass a value that will still be valid when 
                    // m_pszCurrentUrl gets reoplaced.
                    // (That function causes the string to change values indirectly because it ends up sending
                    // a CBEM_SETITEM message to the combobox which will update m_pszCurrentUrl.)
                    //
                    // We put this string on the heap because it can be very large (MAX_URL_STRING) and
                    // this code that calls us and the code we call, use an incredible amount of stack space.
                    // This code needs to highly optimize on how much stack space it uses or it will cause
                    // out of memory faults when trying to grow the stack.
                    Str_SetPtr(&pszTempURL, m_pszCurrentUrl);

                    if (pszTempURL)
                    {
                        hr = _NavigationComplete(pszTempURL, TRUE, TRUE);
                    }
                    Str_SetPtr(&pszTempURL, NULL);
                }
            }
            else
            {
                Str_SetPtr(&m_pszCurrentUrl, NULL);      // Init incase it's null
            }
        }
        break;
        default:
            hr = E_INVALIDARG;
    }

    return hr;
}


/****************************************************\
    FUNCTION: _UseNewList

    DESCRIPTION:
        This function will switch the list we use to
    populate the contents of the combobox.
\****************************************************/
HRESULT CAddressEditBox::_UseNewList(ENUMLISTTYPE eltNew)
{
    HRESULT hr = S_OK;

    ASSERT(m_hwnd);     // It's invalid for use to use a AddressList if we are only and EditBox.
    if (m_elt == eltNew)
        return S_OK;  // We are already using this list.

    if (m_palCurrent)
    {
        m_palCurrent->Connect(FALSE, m_hwnd, m_pbs, m_pbp, m_pac);
        m_palCurrent->Release();
    }

    switch(eltNew)
    {
    case LT_SHELLNAMESPACE:
        ASSERT(m_palSNS);
        m_palCurrent = m_palSNS;
        break;

    case LT_TYPEIN_MRU:
        ASSERT(m_palMRU);
        m_palCurrent = m_palMRU;
        break;
    default:
        ASSERT(0); // Someone messed up.
        m_palCurrent = NULL;
        break;
    }
    if (m_palCurrent)
    {
        m_palCurrent->AddRef();
        m_palCurrent->Connect(TRUE, m_hwnd, m_pbs, m_pbp, m_pac);
    }
    m_elt = eltNew;

    return hr;
}


//================================
// *** IAddressEditBox Interface ***

/****************************************************\
    FUNCTION: Save

    DESCRIPTION:
\****************************************************/
HRESULT CAddressEditBox::Save(DWORD dwReserved)
{
    HRESULT hr = S_OK;

    ASSERT(0 == dwReserved);        // Reserved for later.

    if (m_palMRU)
        hr = m_palMRU->Save();

    return hr;
}



/****************************************************\
    FUNCTION: Init

    PARAMETERS:
        hwnd - Points to ComboBoxEx otherwise NULL.
        hwndEditBox - EditBox.
        dwFlags - AEB_INIT_XXXX flags (Defined in iedev\inc\shlobj.w)
        punkParent - Pointer to parent object that should receive events.

    DESCRIPTION:
        This function will Hook this CAddressEditBox
    object to the ComboBoxEx or EditBox control.  If
    this object is being hooked up to a ComboBoxEx control,
    then hwnd is of the ComboBoxEx control and hwndEditBox
    is of that ComboBox's edit control.  If this is
    being hooked up to only an EditBox, then hwnd is NULL
    and hwndEditBox points to the edit box.  If punkParent
    is NULL, we will not be connected to a browser window
    at all.
\****************************************************/
HRESULT CAddressEditBox::Init(HWND hwnd,              OPTIONAL
                        HWND hwndEditBox,
                        DWORD dwFlags,
                        IUnknown * punkParent)  OPTIONAL
{
    HRESULT hr = S_OK;

    ASSERT(!m_hwnd);
    m_hwnd = hwnd;
    m_hwndEdit = hwndEditBox;
    m_dwFlags = dwFlags;
    IUnknown_Set(&m_punkParent, punkParent);

    // Get and save our top-level window
    m_hwndBrowser = hwnd;
    HWND hwndParent;
    while (hwndParent = GetParent(m_hwndBrowser))
    {
        m_hwndBrowser = hwndParent;
    }

    ASSERT(!(AEB_INIT_SUBCLASS &dwFlags));       // We don't support this yet.
    if (hwnd)  // Is this a ComboBox?
    {
        // Yes,

        ASSERT(!m_palSNS && !m_palMRU /*&& !m_palACP*/);

        m_palSNS = CSNSList_Create();
        m_palMRU = CMRUList_Create();
        if (!m_palSNS || !m_palMRU /*|| !m_palACP*/)
        {
            hr = E_FAIL;
        }

        if (SUCCEEDED(hr))
        {
            HWND hwndCombo;

            hwndCombo = (HWND)SendMessage(m_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
            if (!hwndCombo)
                hr = E_FAIL;  // This will happen if the user passed in a ComboBox instead of a ComboBoxEx for hwnd.
            if (hwndCombo && SetProp(hwndCombo, SZ_ADDRESSCOMBO_PROP, this))
            {
                g_hWinStationBefore = GetProcessWindowStation();
                // Subclass combobox for various tweaks.
                ASSERT(!m_lpfnComboWndProc);
                m_lpfnComboWndProc = (WNDPROC) SetWindowLongPtr(hwndCombo, GWLP_WNDPROC, (LONG_PTR) _ComboSubclassWndProc);

                TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::Init() wndproc=%x", m_lpfnComboWndProc);

                // Subclass the comboboxex too
                if (SetProp(hwnd, SZ_ADDRESSCOMBOEX_PROP, this))
                {
                    ASSERT(!m_lpfnComboExWndProc);
                    m_lpfnComboExWndProc = (WNDPROC)SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)_ComboExSubclassWndProc);
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        //
        // Set g_himl*
        //
        ASSERT(!m_pbp);
        hr = QueryService_SID_IBandProxy(punkParent, IID_IBandProxy, &m_pbp, NULL);

        // We need to set the list to MRU for the first time.
        // We need to do this to initialize the list because
        // it will be used even when other lists are selected.
        if (m_hwnd && LT_NONE == m_elt)
            _UseNewList(LT_TYPEIN_MRU);
    }

    if (hwndEditBox) {
        SendMessage(hwndEditBox, EM_SETLIMITTEXT, INTERNET_MAX_PATH_LENGTH - 1, 0);
    }

    return hr;
}


/****************************************************\
    FUNCTION: SetOwner

    PARAMETERS:
        punkOwner - Pointer to the parent object.

    DESCRIPTION:
        This function will be called to have this
    object try to obtain enough information about it's
    parent Toolbar to create the Band window and maybe
    connect to a Browser Window.
\****************************************************/
HRESULT CAddressEditBox::SetOwner(IUnknown* punkOwner)
{
    HRESULT hr = S_OK;

    if (m_pbs)
        _ConnectToBrwsrWnd(NULL);    // On-connect from Browser Window.

    if (m_hwnd && !punkOwner)
    {
        if (m_palSNS)
            m_palSNS->Save();
        if (m_palMRU)
            m_palMRU->Save();
    }

    IUnknown_Set(&m_punkParent, punkOwner);     // Needed to break ref count cycle.

    _ConnectToBrwsrWnd(punkOwner);    // On-connect from Browser Window.

    return hr;
}


/****************************************************\
    FUNCTION: SetCurrentDir

    DESCRIPTION:
        Set the Current Working directory so parsing
    will work correctly.
\****************************************************/
HRESULT CAddressEditBox::SetCurrentDir(LPCOLESTR pwzDir)
{
    HRESULT hr;
    SHSTR strWorkingDir;

    hr = strWorkingDir.SetStr(pwzDir);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl;

        hr = IECreateFromPath(strWorkingDir.GetStr(), &pidl);
        if (SUCCEEDED(hr))
        {
            hr = _CreateCShellUrl();
            ASSERT(SUCCEEDED(hr));
            if (SUCCEEDED(hr))
                hr = m_pshuUrl->SetCurrentWorkingDir(pidl);
            ILFree(pidl);
        }
    }
    return hr;
}


/****************************************************\
    FUNCTION: ParseNow

    PARAMETERS:
        dwFlags - Parse Flags

    DESCRIPTION:
        Parse the text that is currently in the EditBox.
\****************************************************/
HRESULT CAddressEditBox::ParseNow(DWORD dwFlags)
{
    HRESULT hr;

    TCHAR szBuffer[MAX_URL_STRING];
    ASSERT(m_hwnd);
    GetWindowText(m_hwnd, szBuffer, SIZECHARS(szBuffer));
    hr = _CreateCShellUrl();

    ASSERT(SUCCEEDED(hr));
    if (SUCCEEDED(hr))
    {
        if (m_fConnectedToBrowser && !SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("Use Path"), FALSE, FALSE))
        {
            dwFlags |= SHURL_FLAGS_NOPATHSEARCH;
        }

        if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("AutoCorrect"), FALSE, /*default*/TRUE))
        {
            dwFlags |= SHURL_FLAGS_AUTOCORRECT;
        }

        hr = m_pshuUrl->ParseFromOutsideSource(szBuffer, dwFlags);
    }

    return hr;
}


/****************************************************\
    FUNCTION: Execute

    PARAMETERS:
        dwExecFlags - Execute Flags

    DESCRIPTION:
        This function will execute the last parsed string.
    In most cases, the caller should call ::ParseNow()
    first.
\****************************************************/
HRESULT CAddressEditBox::Execute(DWORD dwExecFlags)
{
    HRESULT hr = E_FAIL;

    ASSERT(m_pshuUrl);
    TCHAR   szShortcutFilePath[MAX_PATH];
    LPITEMIDLIST pidl;

    hr = m_pshuUrl->GetPidlNoGenerate(&pidl);

    if (SUCCEEDED(hr))
    {
        hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szShortcutFilePath, SIZECHARS(szShortcutFilePath), NULL);
        ILFree(pidl);
    }

    // if this is a .url and we can navigate to it
    // then we need to do that now, otherwise
    // we'll end up with a shell exec happening
    // which will open the .url in whatever
    // browse window the system happens to like

    if (SUCCEEDED(hr))
    {
        ASSERT(m_punkParent != NULL);

        // try navigating in the current browser window
        // NavFrameWithFile will exit without doing
        // anything if we're not dealing with a .url
        hr = NavFrameWithFile(szShortcutFilePath, m_punkParent);
    }

    // it's not a .url or we can't nav to it for some reason
    // let the general handlers have a shot now

    if (FAILED(hr))
    {
        hr = m_pshuUrl->Execute(m_pbp, &m_fDidShellExec,dwExecFlags);
    }
    return hr;
}




//================================
// *** IAddressBand Interface ***

/****************************************************\
    FUNCTION: FileSysChange

    DESCRIPTION:
        This function will handle file system change
    notifications.
\****************************************************/
HRESULT CAddressEditBox::FileSysChange(DWORD dwEvent, LPCITEMIDLIST *ppidl)
{
    // m_hwnd == NULL means we don't need to do anything
    // however we will probably never get that event
    // if that is the case.

    if (m_palSNS)
        m_palSNS->FileSysChangeAL(dwEvent, ppidl);

    return S_OK;
}


/****************************************************\
    FUNCTION: Refresh

    PARAMETERS:
        pvarType - NULL for a refress of everything.
                   OLECMD_REFRESH_TOPMOST will only update the top most.

    DESCRIPTION:
        This function will force a refress of part
    or all of the AddressBand.
\****************************************************/
HRESULT CAddressEditBox::Refresh(VARIANT * pvarType)
{
    //
    // Refreshing does not automatically refresh the contents of the
    // edit window because a DISPID_DOCUMENTCOMPLETE or DISPID_NAVIGATECOMPLETE2
    // is not sent.  So we restore the contents ourselves.
    //
    if (m_hwndEdit && m_pszCurrentUrl && !IsErrorUrl(m_pszCurrentUrl))
    {
        TCHAR szTemp[MAX_URL_STRING];

        StringCchCopy(szTemp,  ARRAYSIZE(szTemp), m_pszCurrentUrl);
        SendMessage(m_hwndEdit, WM_SETTEXT, (WPARAM)0, (LPARAM)szTemp);
    }

    DWORD dwType = OLECMD_REFRESH_ENTIRELIST; // Default

    if (pvarType)
    {
        if (VT_I4 != pvarType->vt)
            return E_INVALIDARG;

        dwType = pvarType->lVal;
    }

    if (m_hwnd && m_palCurrent && m_pbs)
    {
        if (!m_pszCurrentUrl)
        {
            if (!m_pshuUrl)
            {
                _CreateCShellUrl();
            }

            LPITEMIDLIST pidl;
            if (SUCCEEDED(m_pbs->GetPidl(&pidl)))
            {
                if (SUCCEEDED(m_pshuUrl->SetPidl(pidl)) && m_pshuUrl)
                {
                    TCHAR szDisplayName[MAX_URL_STRING];
                    if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                    {
                        Str_SetPtr(&m_pszCurrentUrl, szDisplayName);
                    }
                }
                ILFree(pidl);
            }
        }

        if (m_pszCurrentUrl)
        {
            _UseNewList(PathIsURL(m_pszCurrentUrl) ? LT_TYPEIN_MRU : LT_SHELLNAMESPACE);
            if (m_palCurrent)
            {
                m_palCurrent->Connect(TRUE, m_hwnd, m_pbs, m_pbp, m_pac);
                m_palCurrent->Refresh(dwType);
            }
        }
    }

    return S_OK;
}


//================================
// *** Internal/Private Methods ***

//=================================================================
// General Band Functions
//=================================================================

/****************************************************\

    Address Band Constructor

\****************************************************/
CAddressEditBox::CAddressEditBox()
{
    DllAddRef();
    TraceMsg(TF_SHDLIFE, "ctor CAddressEditBox %x", this);
    m_cRef = 1;

    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!m_punkParent);
    ASSERT(!m_hwnd);
    ASSERT(!m_hwndEdit);
    ASSERT(!m_lpfnComboWndProc);

    ASSERT(!m_pbp);
    ASSERT(!m_pbs);
    ASSERT(!m_dwcpCookie);
    ASSERT(!m_pszCurrentUrl);
    ASSERT(!m_pszPendingURL);
    ASSERT(!m_pac);
    ASSERT(!m_pssACLISF);
    ASSERT(!m_palCurrent);
    ASSERT(!m_palSNS);
    ASSERT(!m_palMRU);
    ASSERT(!m_pmru);
    ASSERT(!m_pshuUrl);
    ASSERT(!m_fDidShellExec);
    ASSERT(!m_pszUserEnteredURL);
    ASSERT(!m_fConnectedToBrowser);
    ASSERT(!m_pAsyncNav);
    ASSERT(!m_fAsyncNavInProgress);

    ASSERT(AEB_INIT_DEFAULT == m_dwFlags);

    m_nOldSelection = -1;
    m_elt = LT_NONE;
    m_cbex.mask = 0;
    m_cbex.pszText = 0;
    m_cbex.cchTextMax = 0;

    if (!g_nAEB_AsyncNavigation)
        g_nAEB_AsyncNavigation = RegisterWindowMessage(TEXT("CAEBAsyncNavigation"));

}


/****************************************************\

    Address Band destructor

\****************************************************/
CAddressEditBox::~CAddressEditBox()
{
    _CancelNavigation();

    ATOMICRELEASE(m_punkParent);
    ATOMICRELEASE(m_pac);
    ATOMICRELEASE(m_pssACLISF);
    ATOMICRELEASE(m_palSNS);
    ATOMICRELEASE(m_palMRU);
    ATOMICRELEASE(m_palCurrent);
    ATOMICRELEASE(m_pbp);
    ATOMICRELEASE(m_pbs);
    ATOMICRELEASE(m_pmru);

    if (m_pshuUrl)
    {
        delete m_pshuUrl;
    }

    Str_SetPtr(&m_pszCurrentUrl, NULL);
    Str_SetPtr(&m_pszPendingURL, NULL);
    Str_SetPtr(&m_pszUserEnteredURL, NULL);
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);

    _RemoveHook();
    if (m_fAssociated)
    {
        m_al.Delete(GetCurrentThreadId());
    }

    Str_SetPtr(&m_cbex.pszText, NULL);

    TraceMsg(TF_SHDLIFE, "dtor CAddressEditBox %x", this);
    DllRelease();
}

/****************************************************\
    FUNCTION: CAddressEditBox_CreateInstance

    DESCRIPTION:
        This function will create an instance of the
    AddressBand COM object.
\****************************************************/
HRESULT CAddressEditBox_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi)
{
    // aggregation checking is handled in class factory

    *ppunk = NULL;
    CAddressEditBox * p = new CAddressEditBox();
    if (p)
    {
        *ppunk = SAFECAST(p, IAddressBand *);
        return NOERROR;
    }

    return E_OUTOFMEMORY;
}


/****************************************************\
    FUNCTION: _OnNotify

    DESCRIPTION:
        This function will handle WM_NOTIFY messages.
\****************************************************/
LRESULT CAddressEditBox::_OnNotify(LPNMHDR pnm)
{
    // HACKHACK: combobox (comctl32\comboex.c) will pass a LPNMHDR, but it's really
    // a PNMCOMBOBOXEX (which has a first element of LPNMHDR).  This function
    // can use this type cast iff it's guaranteed that this will only come from
    // a function that behaves in this perverse way.
    PNMCOMBOBOXEX pnmce = (PNMCOMBOBOXEX)pnm;

    ASSERT(pnm);
    switch (pnm->code)
    {
    case CBEN_BEGINEDIT:
        _OnBeginEdit(pnm);
        break;

    case CBEN_ENDEDITA:
        _OnEndEditA((LPNMCBEENDEDITA)pnm);
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_OnNotify(), pnm->code=CBEN_ENDEDITA");
        break;

    case CBEN_ENDEDITW:
        _OnEndEditW((LPNMCBEENDEDITW)pnm);
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_OnNotify(), pnm->code=CBEN_ENDEDITW");
        break;

    default:
        break;
    }

    return 0;
}


LRESULT CAddressEditBox::_OnBeginEdit(LPNMHDR pnm)
{
    if (m_punkParent)
        IUnknown_OnFocusChangeIS(m_punkParent, m_punkParent, TRUE);

    return 0;

}

/****************************************************\
    FUNCTION: _OnEndEditW

    DESCRIPTION:
        Thunk to _OnEndEditA.
\****************************************************/

LRESULT CAddressEditBox::_OnEndEditW(LPNMCBEENDEDITW pnmW)
{
    NMCBEENDEDITA nmA;

    nmA.hdr = pnmW->hdr;
    nmA.fChanged = pnmW->fChanged;
    nmA.iNewSelection = pnmW->iNewSelection;
    nmA.iWhy = pnmW->iWhy;

    // don't we lose unicode information on this transition?!
    // We don't use pnmw->szText so don't bother converting it
    // SHUnicodeToAnsi(pnmW->szText, nmA.szText, ARRAYSIZE(nmA.szText));
    nmA.szText[0] = 0;

    return _OnEndEditA(&nmA);
}




/****************************************************\
    FUNCTION: _OnEndEditA

    DESCRIPTION:
        Handle the WM_NOTIFY/CBEN_ENDEDITA message.
\****************************************************/
LRESULT CAddressEditBox::_OnEndEditA(LPNMCBEENDEDITA pnmA)
{
    BOOL fRestoreIcons = TRUE;
    ASSERT(pnmA);

    //
    // Navigate only if the user pressed enter in the edit control.
    //
    ASSERT(m_hwnd);
    switch (pnmA->iWhy)
    {
        case CBENF_RETURN:
            {
                if (g_dwProfileCAP & 0x00000002) {
                    StartCAP();
                }

                // Use szUrl and ignore pnmA->szText because it truncates to MAX_PATH (=256)
                TCHAR szUrl[MAX_URL_STRING];

                if (m_hwndEdit)
                {
                    // Allow the edit text to be updated
                    _ClearDirtyFlag();

                    GetWindowText(m_hwndEdit, szUrl, SIZECHARS(szUrl));
                    Str_SetPtr(&m_pszUserEnteredURL, szUrl);

                    // If edit box is empty, don't show icon
                    if (*szUrl == L'\0')
                    {
                        fRestoreIcons = FALSE;
                    }

#ifndef NO_ETW_TRACING
                    // Event trace for windows enable by shlwapi.
                    if (g_dwStopWatchMode & SPMODE_EVENTTRACE) {
                        EventTraceHandler(EVENT_TRACE_TYPE_BROWSE_ADDRESS,
                                          szUrl);
                    }
#endif
                    if (g_dwStopWatchMode & (SPMODE_BROWSER | SPMODE_JAVA))
                    {
                        DWORD dwTime = GetPerfTime();
                        if (g_dwStopWatchMode & SPMODE_BROWSER)  // Used to get browser total download time
                            StopWatch_StartTimed(SWID_BROWSER_FRAME, TEXT("Browser Frame Same"), SPMODE_BROWSER | SPMODE_DEBUGOUT, dwTime);
                        if (g_dwStopWatchMode & SPMODE_JAVA)  // Used to get java applet load time
                            StopWatch_StartTimed(SWID_JAVA_APP, TEXT("Java Applet Same"), SPMODE_JAVA | SPMODE_DEBUGOUT, dwTime);
                    }

                    // If the WindowText matches the last URL we navigated
                    // to, then we need to call Refresh() instead of _HandleUserAction().
                    // This is because IWebBrowser2::Navigate2() ignores any commands that
                    // point to the same URL that it's already navigated to.
                    if (m_pszCurrentUrl && m_hwnd && !m_fDidShellExec &&
                        m_fConnectedToBrowser && (-1 == pnmA->iNewSelection) &&
                        (0 == lstrcmp(m_pszCurrentUrl, szUrl)))
                    {
                        IUnknown *punk = NULL;

                        // Refresh Browser.
                        if (m_pbp)
                        {
                            m_pbp->GetBrowserWindow(&punk);
                        }
                        if (punk) {
                            IWebBrowser* pwb;
                            punk->QueryInterface(IID_IWebBrowser, (LPVOID*)&pwb);
                            if (pwb) {
                                VARIANT v = {0};
                                v.vt = VT_I4;
                                v.lVal = OLECMDIDF_REFRESH_RELOAD|OLECMDIDF_REFRESH_CLEARUSERINPUT;
                                Refresh(NULL);
                                pwb->Refresh2(&v);
                                pwb->Release();
                            }
                            punk->Release();
                        }
                    }
                    else
                    {
                        SendMessage(m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
                        _HandleUserAction(szUrl, pnmA->iNewSelection);
                    }
                    UEMFireEvent(&UEMIID_BROWSER, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_NAVIGATE, UIBL_NAVADDRESS);
                }
            }
            break;
        case CBENF_KILLFOCUS:
            fRestoreIcons = FALSE;
            break;

        case CBENF_ESCAPE:
            // Abort and clear the dirty flag
            _ClearDirtyFlag();
            if (m_hwndEdit && m_pszCurrentUrl && m_cbex.mask != 0)
            {
                SendMessage(m_hwnd, CBEM_SETITEM, (WPARAM)0, (LPARAM)(LPVOID)&m_cbex);
            }

            SendMessage(m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
            if (pnmA->iNewSelection != -1) {
                SendMessage(m_hwnd, CB_SETCURSEL, pnmA->iNewSelection, 0);
            }
            fRestoreIcons = FALSE;
            break;
    }

    if (fRestoreIcons)
    {
        SendMessage(m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, 0);
    }
    return 0;
}


/****************************************************\
    FUNCTION: _ConnectToBrwsrWnd

    DESCRIPTION:
        The IUnknown parameter needs to point to an
    object that supports the IBrowserService and
    IWebBrowserApp interfaces.
\****************************************************/
HRESULT CAddressEditBox::_ConnectToBrwsrWnd(IUnknown* punk)
{
    HRESULT hr = S_OK;

    if (m_pbs) {
        _ConnectToBrwsrConnectionPoint(FALSE, m_punkParent);
        ATOMICRELEASE(m_pbs);
    }

    if (punk)
    {
        IUnknown * punkHack;

        // HACK: We behave differently if we are hosted outside of a browser
        //       than we do if we are in a browser.  This call does nothing
        //       but identify our host.
        if (SUCCEEDED(IUnknown_QueryService(punk, SID_SShellDesktop, IID_IUnknown, (void**)&punkHack)))
            punkHack->Release();
        else
        {
            // No, we are not hosted on the desktop, so we can synch to the events of the browser.

            hr = IUnknown_QueryService(punk, SID_STopLevelBrowser, IID_IBrowserService, (void**)&m_pbs);
            if (SUCCEEDED(hr))
            {
                // We only want notifications if we are the AddressBar.
                _ConnectToBrwsrConnectionPoint(TRUE, punk);
            }
        }
    }

    // TODO: At some point we will need to implement IPropertyBag so
    //       the parent can specify if they want us to behave as though
    //       we are contected or not.  For now, we will use the fact
    //       that we are either have a IBrowserService pointer or not.
    m_fConnectedToBrowser = BOOLIFY(m_pbs);


    if (!m_pac)
    {
        // We need to wait to create the AutoComplete Lists until m_fConnectedToBrowser is set.
        if (m_hwndEdit)
            hr = SHUseDefaultAutoComplete(m_hwndEdit, NULL, &m_pac, &m_pssACLISF, m_fConnectedToBrowser);

        if (SUCCEEDED(hr))
        {
            _SetAutocompleteOptions();
        }
    }

    //
    // Subclass edit control of the combobox.  We do this here rather than when this
    // class is initialized so that we are first in the chain to receive messages.
    //
    if (!m_lpfnEditWndProc && m_hwndEdit && SetProp(m_hwndEdit, SZ_ADDRESSCOMBO_PROP, this))
    {
        m_lpfnEditWndProc = (WNDPROC)SetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _EditSubclassWndProc);
    }

    // This function will be called if: 1) we are becoming connected to a
    // browser, 2) switch from one browser to another, or 3) are
    // becoming unconnected from a browser.  In any case, we need to
    // update the ISF AutoComplete List so it can retrieve
    // the current location from the appropriate browser.
    if (m_pssACLISF)
        m_pssACLISF->SetOwner(m_pbs);

    return hr;
}


/****************************************************\
    FUNCTION: _ConnectToBrwsrConnectionPoint

    DESCRIPTION:
        Connect to Browser Window's ConnectionPoint
    that will provide events to let us keep up to date.
\****************************************************/
HRESULT CAddressEditBox::_ConnectToBrwsrConnectionPoint(BOOL fConnect, IUnknown * punk)
{
    HRESULT hr = S_OK;
    IConnectionPointContainer *pcpContainer;

    if (punk)
    {
        hr = IUnknown_QueryService(punk, SID_SWebBrowserApp, IID_IConnectionPointContainer, (void **)&pcpContainer);
        // Let's now have the Browser Window give us notification when something happens.
        if (SUCCEEDED(hr))
        {
            hr = ConnectToConnectionPoint(SAFECAST(this, IDispatch*), DIID_DWebBrowserEvents2, fConnect,
                                          pcpContainer, &m_dwcpCookie, NULL);
            pcpContainer->Release();
        }
    }

    return hr;
}


/****************************************************\
    FUNCTION: _OnCommand

    DESCRIPTION:
        Handle WM_COMMAND messages.
\****************************************************/
LRESULT CAddressEditBox::_OnCommand(WPARAM wParam, LPARAM lParam)
{
    UINT uCmd = GET_WM_COMMAND_CMD(wParam, lParam);

    switch (uCmd)
    {
        case CBN_EDITCHANGE:
        {
            HWND hwndFocus = GetFocus();
            if ((NULL != hwndFocus) && IsChild(m_hwnd, hwndFocus))
            {
                DWORD dwStyle = _IsDirty() ? CBES_EX_NOEDITIMAGE : 0;
                SendMessage(m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, dwStyle);
            }
            break;
        }

        case CBN_CLOSEUP:
            {
                //
                // Navigate to the selected string when the dropdown is not down.
                //
                int nSel = ComboBox_GetCurSel(m_hwnd);
                if ((m_nOldSelection != SEL_ESCAPE_PRESSED) &&
                    (m_nOldSelection != nSel) && (nSel > -1))
                {
                    _HandleUserAction(NULL, nSel);

                    // RedrawWindow eliminates annoying half-paint that
                    // occurs while navigating from one pidl to a smaller pidl.
                    RedrawWindow(m_hwnd, NULL, NULL, RDW_INTERNALPAINT | RDW_UPDATENOW);
                }
            }

            if (m_pac)
                m_pac->Enable(TRUE);
            break;

        case CBN_DROPDOWN:
            if (m_pac)
                m_pac->Enable(FALSE);
            break;
    }

    return 0;
}

/*******************************************************************
    FUNCTION: _CreateCShellUrl

    DESCRIPTION:
        Create the m_pshuUrl CShellUrl if needed.
********************************************************************/
HRESULT CAddressEditBox::_CreateCShellUrl(void)
{
    HRESULT hr = S_OK;
    // Do we need to create our Shell Url?
    if (!m_pshuUrl)
    {
        // Yes
        m_pshuUrl = new CShellUrl();
        if (!m_pshuUrl)
        {
            return E_FAIL;
        }
        else
        {
            m_pshuUrl->SetMessageBoxParent(m_hwndEdit);

            // We need to set the "Shell Path" which will allow
            // the user to enter Display Names of items in Shell
            // Folders that are frequently used.  We add "Desktop"
            // and "Desktop/My Computer" to the Shell Path because
            // that is what users use most often.
            SetDefaultShellPath(m_pshuUrl);
        }
    }
    return hr;
}



/*******************************************************************
    FUNCTION: _HandleUserAction

    PARAMETERS:
        pszUrl - string of URL to navigate to.
        iNewSelection - index of current selection in address bar combo box

    DESCRIPTION:
        Called when the user types in or selects a URL to navigate
    to through the address bar.
********************************************************************/
HRESULT CAddressEditBox::_HandleUserAction(LPCTSTR pszUrl, int iNewSelection)
{
    HRESULT hr = S_OK;
    TCHAR szDisplayName[MAX_URL_STRING];
    HCURSOR hCursorOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
    static DWORD dwParseFlags = 0xFFFFFFFF;

    Str_SetPtr(&m_pszPendingURL, NULL);  // Clear if one exists.
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);
    hr = _CreateCShellUrl();
    if (FAILED(hr))
        return hr;

    // Are we connected to a Browser Window?
    if (m_pbs)
    {
        // Yes, so let's set our current working directory to the current window.
        LPITEMIDLIST pidl;
        m_pbs->GetPidl(&pidl);

        DEBUG_CODE(TCHAR szDbgBuffer[MAX_PATH];)
        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_HandleUserAction(), Current Pidl in TravelLog. PIDL=%s;", Dbg_PidlStr(pidl, szDbgBuffer, SIZECHARS(szDbgBuffer)));

        if (pidl)
        {
            // m_pshuUrl will free pshuCurrWorkDir, so we can't.
            hr = m_pshuUrl->SetCurrentWorkingDir(pidl);
            ILFree(pidl);
        }
    }

    if (SUCCEEDED(hr))
    {
        // Cancel previous pending nav if any
        _CancelNavigation();

        // Did the user select the item from the drop down list?
        if (-1 != iNewSelection)
        {
            // Yes, so point our CShellUrl at the item. (Pidl or URL)
            if (m_palCurrent)
                m_palCurrent->SetToListIndex(iNewSelection, (LPVOID) m_pshuUrl);

            // if the index indicates this was a selection from the combo box,
            // remember which selection it was
            SendMessage(m_hwnd, CB_SETCURSEL, (WPARAM)iNewSelection, 0L);

            *szDisplayName = L'\0';
            GetWindowText(m_hwnd, szDisplayName, ARRAYSIZE(szDisplayName));
            Str_SetPtr(&m_pszUserEnteredURL, szDisplayName);
            pszUrl = NULL;
        }
        else
        {
            // No, the user hit return with some string.
            ASSERT(pszUrl); // must have valid URL

            if (0xFFFFFFFF == dwParseFlags)
            {
                dwParseFlags = SHURL_FLAGS_NONE;
                if (m_fConnectedToBrowser && !SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("Use Path"), FALSE, FALSE))
                    dwParseFlags = SHURL_FLAGS_NOPATHSEARCH;

                if (SHRegGetBoolUSValue(TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Band\\Address"), TEXT("AutoCorrect"), FALSE, /*default*/TRUE))
                    dwParseFlags |= SHURL_FLAGS_AUTOCORRECT;
            }
        }

        hr = E_FAIL;
        if (m_hwnd && m_pshuUrl)
        {
            if (!(m_dwFlags & AEB_INIT_NOASYNC))    // Is async navigate enabled?
            {
                // Create and initialize the AsyncNav object used to communicate with the thread
                m_pAsyncNav = new AsyncNav();
                if (m_pAsyncNav)
                {
                    if(m_punkParent)
                    {
                        // Get the globe spinning indicating our processing
                        hr = IUnknown_QueryServiceExec(m_punkParent, SID_SBrandBand, &CGID_BrandCmdGroup, CBRANDIDM_STARTGLOBEANIMATION, 0, NULL, NULL);
                    }

                    m_pAsyncNav->_dwParseFlags = dwParseFlags;
                    m_pAsyncNav->_hwnd = m_hwnd;
 
                    if (pszUrl)
                        Str_SetPtr(&(m_pAsyncNav->_pszUrl), pszUrl);
                    else
                        m_pAsyncNav->_fPidlCheckOnly = TRUE;

                
                    if (!pszUrl || (pszUrl && m_pAsyncNav->_pszUrl))
                    {
                        CShellUrl *pshu = new CShellUrl();

                        if (pshu)
                        {
                            hr = pshu->Clone(m_pshuUrl);
                            m_pAsyncNav->_pShellUrl = pshu;

                            // AddRef here to give it to the thread
                            m_pAsyncNav->AddRef();

                            // Create the thread that will do the PIDL creation
                            if (FAILED(hr) || !SHCreateThread(_AsyncNavigateThreadProc, (LPVOID)m_pAsyncNav, CTF_COINIT, NULL))
                            {
                                hr = E_FAIL;
                            }
                            else
                            {

                                hr = E_PENDING;
                            }
                        }
                    }
                }
            }

            if (FAILED(hr) && hr != E_PENDING)
            {
                // Cancel Async navigation leftovers
                _CancelNavigation();

                if (pszUrl)
                {
                    BOOL fWasCorrected = FALSE;
                    hr = m_pshuUrl->ParseFromOutsideSource(pszUrl, dwParseFlags, &fWasCorrected);

                    // If the URL was autocorrected, put the corrected url in the editbox
                    // so that an invalid url in not added to our MRU if navigation succeeds
                    if (SUCCEEDED(hr) && fWasCorrected)
                    {
                        if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                        {
                            SetWindowText(m_hwndEdit, szDisplayName);
                        }
                    }
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        _FinishNavigate();
    }

    SetCursor(hCursorOld);
    return hr;
}

HRESULT CAddressEditBox::_FinishNavigate()
{
    HRESULT hr;

    hr = Execute( (m_fConnectedToBrowser ? SHURL_EXECFLAGS_NONE : SHURL_EXECFLAGS_DONTFORCEIE));
    // if we managed to navigate by one means or another, then do all the
    // associated processing
    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[MAX_URL_STRING];
        hr = m_pshuUrl->GetDisplayName(szDisplayName, SIZECHARS(szDisplayName));
        ASSERT(SUCCEEDED(hr));

        Str_SetPtr(&m_pszPendingURL, szDisplayName);
        if (!m_fConnectedToBrowser || m_fDidShellExec)
        {
            // We aren't connected to a browser window
            // so we need to call _NavigationComplete() our selves
            // because it will not come from the Browser window
            // it self.

            // If m_fDidShellExec, we need to manually add this because
            // we won't receive a DISPID_NAVIGATECOMPLETE event, but
            // we pass NULL to indicate

            hr = _NavigationComplete(szDisplayName, !m_fDidShellExec, TRUE);
        }
    }
    return hr;
}


void CAddressEditBox::_JustifyAddressBarText( void )
{
    // Either of the following appear to work:
    //	(a) EM_SETSEL(0,0) followed by EM_SCROLLCARET(0,0)
    //		SendMessage( m_hwndEdit, EM_SETSEL, 0, 0 );
    //		SendMessage( m_hwndEdit, EM_SCROLLCARET, 0, 0 );
    //	(b) WM_KEYDOWN with VK_HOME
    //		SendMessage( m_hwndEdit, WM_KEYDOWN, VK_HOME, 0 );

    // Use the EM_SETSEL method to avoid user keyboard stroke interruption.
    SendMessage( m_hwndEdit, EM_SETSEL, 0, 0 );
    SendMessage( m_hwndEdit, EM_SCROLLCARET, 0, 0 );
}


HRESULT CAddressEditBox::_AsyncNavigate(AsyncNav *pAsyncNav)
{
    HRESULT hr;

    // we should only be called on one thread, but the interlocked can't hurt...
    if (InterlockedCompareExchange((LONG*)&m_fAsyncNavInProgress, TRUE, FALSE) == FALSE)
    {
        // this is the first call to _AsyncNavigate
        hr = pAsyncNav->_hr;

        if (SUCCEEDED(hr))
        {
            // Get the CShellUrl back after processing
            hr = m_pshuUrl->Clone(pAsyncNav->_pShellUrl);
        }

        // If the URL was autocorrected, put the corrected url in the editbox
        // so that an invalid url in not added to our MRU if navigation succeeds
        if (SUCCEEDED(hr) && pAsyncNav->_fWasCorrected)
        {
            TCHAR szDisplayName[MAX_URL_STRING];
            if (SUCCEEDED(m_pshuUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
            {
                SetWindowText(m_hwndEdit, szDisplayName);
            }
        }

        if (SUCCEEDED(hr))
            hr = _FinishNavigate();

        if (FAILED(hr) && pAsyncNav->_fPidlCheckOnly)
        {
            // Maybe the user needs to insert the media, format, or
            // reconnect to the disk before this will succeed.  Check for that
            // and prompt now.
            // This fixes the common case where the floppy or CD isn't inserted and
            // we want to display the user friendly dialog.

            LPITEMIDLIST pidl;

            hr = pAsyncNav->_pShellUrl->GetPidlNoGenerate(&pidl);

            // We need to resolve the URL into its path so SHPathPrepareForWrite works correctly
            if (SUCCEEDED(hr))
            {
                TCHAR szShortcutFilePath[MAX_PATH];
                hr = IEGetNameAndFlags(pidl, SHGDN_FORPARSING, szShortcutFilePath, SIZECHARS(szShortcutFilePath), NULL);

                if (SUCCEEDED(hr))
                {
                    HRESULT hrPrompt = SHPathPrepareForWrite(pAsyncNav->_hwnd, NULL, szShortcutFilePath, SHPPFW_DEFAULT);
                    if (SUCCEEDED(hrPrompt))
                    {
                        hr = _FinishNavigate();
                    }
                    else
                    {
                        // Propagate out the fact that the user clicked the cancel button.
                        hr = hrPrompt;
                    }
                }
            
                ILFree(pidl);
            }

            // Never display a err if the user cancelled the operation.
            if (FAILED(hr) && (HRESULT_FROM_WIN32(ERROR_CANCELLED) != hr))
            {
                TCHAR szDisplayName[MAX_URL_STRING];
                if (SUCCEEDED(pAsyncNav->_pShellUrl->GetUrl(szDisplayName, ARRAYSIZE(szDisplayName))))
                {
                    MLShellMessageBox(pAsyncNav->_hwnd, MAKEINTRESOURCE(IDS_ADDRBAND_DEVICE_NOTAVAILABLE),
                        MAKEINTRESOURCE(IDS_SHURL_ERR_TITLE),
                        (MB_OK | MB_ICONERROR), szDisplayName);
                }
            }
        }

        // Cleanup async navigation stuff
        _CancelNavigation();

        InterlockedExchange((LONG*)&m_fAsyncNavInProgress, FALSE);
    }
    else
    {
        // we can only do one async navigate at a time
        hr = E_FAIL;
    }

    return hr;
}

HRESULT CAddressEditBox::_CancelNavigation()
{
    if (m_pAsyncNav)
    {
        if(m_punkParent)
        {
            HRESULT hr = IUnknown_QueryServiceExec(m_punkParent, SID_SBrandBand, &CGID_BrandCmdGroup, CBRANDIDM_STOPGLOBEANIMATION, 0, NULL, NULL);
        }

        m_pAsyncNav->SetCanceledFlag();
        m_pAsyncNav->Release();
        m_pAsyncNav = NULL;
    }

    return S_OK;
}

DWORD CAddressEditBox::_AsyncNavigateThreadProc(LPVOID pvData)
{
    AsyncNav *pAsyncNav = (AsyncNav *)pvData;

    if (pAsyncNav->_hwnd && g_nAEB_AsyncNavigation)
    {
        if(pAsyncNav->_fPidlCheckOnly)
        {
            LPITEMIDLIST pidl;

            pAsyncNav->_hr = pAsyncNav->_pShellUrl->GetPidlNoGenerate(&pidl);
            if (SUCCEEDED(pAsyncNav->_hr))
            {
                DWORD dwAttrib = SFGAO_VALIDATE;
                pAsyncNav->_hr = IEGetNameAndFlags(pidl, 0, NULL, 0, &dwAttrib);
            }
            else
            {
                // Special case for keywords. We want to proceed if we don't have a pidl
                pAsyncNav->_hr = S_OK;
            }
        }
        else
        {
            pAsyncNav->_hr = pAsyncNav->_pShellUrl->ParseFromOutsideSource(pAsyncNav->_pszUrl, pAsyncNav->_dwParseFlags, &(pAsyncNav->_fWasCorrected), &(pAsyncNav->_fWasCanceled));
        }
        pAsyncNav->_fReady = TRUE;
        PostMessage(pAsyncNav->_hwnd, g_nAEB_AsyncNavigation, (WPARAM)pAsyncNav, NULL);
    }

    // We are done with this now.
    // If the navigation was canceled, then the object will destruct now, and the posted
    // message above will be ignored.
    pAsyncNav->Release();


    return 0;
}


BOOL CAddressEditBox::_IsShellUrl(void)
{
    // 1. Check if we need to change the List.
    BOOL fIsShellUrl = !m_pshuUrl->IsWebUrl();

    if (fIsShellUrl)
    {
        // BUG #50703: Users want MRU when about: url is displayed.
        TCHAR szUrl[MAX_URL_STRING];

        if (SUCCEEDED(m_pshuUrl->GetUrl(szUrl, ARRAYSIZE(szUrl))))
        {
            if (URL_SCHEME_ABOUT == GetUrlScheme(szUrl))
            {
                fIsShellUrl = FALSE;  // Make it use the MRU List.
            }
        }
    }

    return fIsShellUrl;
}


/*******************************************************************
    FUNCTION: _NavigationComplete

    PARAMETERS:
        pszUrl - String user entered.
        fChangeLists - Should we modify the Drop Down list?
        fAddToMRU - Should we add it to the MRU?

    DESCRIPTION:
        This function is called when either: 1) a naviation completes,
    or 2) the user entered text into the AddressEditBox that needs
    to be handled but will not cause a NAVIGATION_COMPLETE message.
    This function will change the AddressList being used and will
    add the item to the Type-in MRU.
********************************************************************/
HRESULT CAddressEditBox::_NavigationComplete(LPCTSTR pszUrl /* Optional */, BOOL fChangeLists, BOOL fAddToMRU)
{
    HRESULT hr = S_OK;

    // Are we controlling a ComboBoxEx?
    if (m_hwnd)
    {
        // Yes, so do ComboBoxEx Specific things...

        // If the list is dropped, undrop it so the contents of the editbox and list
        // are properly updated.
        if (m_hwnd  && m_hwndEdit && ComboBox_GetDroppedState(m_hwnd))
        {
            SendMessage(m_hwndEdit, WM_KEYDOWN, VK_ESCAPE, 0);
        }

        if (fChangeLists)
        {
            BOOL fIsShellUrl = _IsShellUrl();

            // 2. Do we need to change lists to MRU List?
            if (!fIsShellUrl && m_elt != LT_TYPEIN_MRU)
            {
                // We need to start using the LT_TYPEIN_MRU list
                // because that list is what is needed for Internet Urls.
                _UseNewList(LT_TYPEIN_MRU);
            }

            // We only want to switch to using the shell name space
            // if we are connected to a browser.
            if (fIsShellUrl && (m_elt != LT_SHELLNAMESPACE) && m_fConnectedToBrowser)
            {
                // We need to start using the LT_SHELLNAMESPACE list
                // because that list is what is needed for File Urls.
                _UseNewList(LT_SHELLNAMESPACE);
            }

            ASSERT(m_palCurrent);
            hr = m_palCurrent ? m_palCurrent->NavigationComplete((LPVOID) m_pshuUrl) : E_FAIL;
            if ( SUCCEEDED( hr ) )
            {
                // Insure that after the navigation completes, the Address Bar Text is left justified.
                _JustifyAddressBarText();
            }
        }

        // Don't display the url to internal error pages. All internal error
        // urls start with res:// and we don't want these in our MRU.
        // We also don't want to display error pages from the server.
        if ((pszUrl && (TEXT('r') == pszUrl[0]) && (TEXT('e') == pszUrl[1]) && IsErrorUrl(pszUrl)) ||
            (m_pszHttpErrorUrl && StrCmp(m_pszHttpErrorUrl, pszUrl) == 0))
        {
            // We don't want this in our MRU!
            fAddToMRU = FALSE;
        }

        // Do we have a Pending URL, meaning the user hand typed it in
        // and the navigation finished (wasn't cancelled or failed).
        //
        // REARCHITECT: Currently there are a few cases when the URL (m_pszPendingURL)
        //         is added to the MRU when it shouldn't.
        // 1. If the user enters an URL and then cancels the navigation, we
        //    don't clear m_pszPendingURL.  If the user then causes the browser
        //    to navigate by some other means (HREF Click, Favorites/QLink navigation
        //    , or Floating AddressBand), we will receive the NAVIGATION_COMPLETE
        //    message and think it was for the originally cancelled URL.

        if (fAddToMRU && m_pszPendingURL)
        {
            // Yes, so add it to the MRU.
            if (SUCCEEDED(hr))
            {
                if (!m_pmru && m_palMRU)
                    hr = m_palMRU->QueryInterface(IID_IMRU, (LPVOID *)&m_pmru);

                if (SUCCEEDED(hr))
                {
                    SHCleanupUrlForDisplay(m_pszPendingURL);
                    hr = m_pmru->AddEntry(m_pszPendingURL); // Add to MRU
                }
            }
        }
    }

    Str_SetPtr(&m_pszPendingURL, NULL);
    Str_SetPtr(&m_pszHttpErrorUrl, NULL);

    return hr;
}

//=================================================================
// AddressEditBox Modification Functions
//=================================================================

/****************************************************\
    _ComboSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.
\****************************************************/
LRESULT CALLBACK CAddressEditBox::_ComboSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    HWND hwndBand = GetParent(hwnd);
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBO_PROP);

    ASSERT(paeb);
    g_hWinStationAfter = GetProcessWindowStation();

    // In stress we see someone will stomp our property with -2.  We need to find out who it is.
    // Call ReinerF if this happens
    AssertMsg(((void *)-2 != paeb), TEXT("Someone corrupted our window property.  Call ReinerF"));
    if (!paeb)
    {
        return DefWindowProcWrap(hwnd, uMessage, wParam, lParam);
    }

    switch (uMessage)
    {
    case WM_SETCURSOR:
        {
            HWND hwndCursor = (HWND)wParam;
            int nHittest = LOWORD(lParam);
            if (hwndCursor == paeb->m_hwndEdit && nHittest == HTCLIENT)
            {
                //
                // If we don't have focus, we want to show an arrow because clicking will select
                // the contents of the edit box.  Otherwise show the I-beam.  Also, if the edit box
                // is empty we show the I-beam because there is nothing to select.
                //
                HWND hwndFocus = GetFocus();
                int cch = GetWindowTextLength(paeb->m_hwndEdit);

                LPCTSTR lpCursorName = (cch == 0 || hwndFocus == paeb->m_hwndEdit) ? IDC_IBEAM : IDC_ARROW;
                SetCursor(LoadCursor(NULL, lpCursorName));
                return TRUE;
            }
            break;
        }
    case WM_SETFOCUS:
        //
        // This is gross, but if the window was destroyed that had the
        // focus this would fail and we would not get this to the
        // combo box.
        //
        // This happens if you click on the combobox while
        // renaming a file in the defview.
        //
        if (wParam && !IsWindow((HWND)wParam))
            wParam = 0;
        break;

    case WM_DESTROY:
        // Unsubclass myself.
        if (!paeb->m_lpfnComboWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnComboWndProc);
        RemoveProp(hwnd, SZ_ADDRESSCOMBO_PROP);

        ASSERT(paeb->m_hwnd); // We don't want to be called twice
        paeb->m_hwnd = NULL;      // We have been destroyed.
        break;

    case WM_COMMAND:
        if (EN_UPDATE == GET_WM_COMMAND_CMD(wParam, lParam))
        {
            paeb->_InstallHookIfDirty();
        }
        break;
    case WM_KEYDOWN:
            switch (wParam)
            {
                //
                // Pressing escape results in the dropdown being hidden.  If
                // the mouse hot-tracks over a different selection than when the
                // combo was first dropped, we get a CBN_SELCHANGE event which
                // causes a false navigation.  We suppress this by setting
                // m_nOldSelection to a special value (-2).
                //
                case VK_ESCAPE:
                {
                    paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;

                    // Pass message on so that the content of the edit box is restored
                    SendMessage(paeb->m_hwndEdit, uMessage, wParam, lParam);
                    break;
                }
            }
            break;
    case WM_SYSKEYDOWN:
            switch (wParam)
            {
                case VK_DOWN:
                {
                    // Alt-down toggles the combobox dropdown.  We don't
                    // want a navigation if this key sequence closes the dropdown.
                    if (HIWORD(lParam) & KF_ALTDOWN)
                    {
                        paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;
                    }
                    break;
                }
            }
            break;
    case CB_SHOWDROPDOWN:
            // If dropdown is hidden, suppress navigation. See comment above for VK_ESCAPE.
            if (!wParam)
            {
                paeb->m_nOldSelection = SEL_ESCAPE_PRESSED;
            }
            break;

    case WM_WINDOWPOSCHANGING:
        {
            LPWINDOWPOS pwp = (LPWINDOWPOS)lParam;
            pwp->flags |= SWP_NOCOPYBITS;
        }
        break;

    case WM_GETOBJECT:
        if ((DWORD)lParam == OBJID_CLIENT)
        {
            CAddressEditAccessible *paea = new CAddressEditAccessible(hwnd, paeb->m_hwndEdit);

            if (NULL != paea)
            {
                LRESULT lres = LresultFromObject(IID_IAccessible, wParam, SAFECAST(paea, IAccessible *));
                paea->Release();

                return lres;
            }
        }
        break;


    default:
        // FEATURE: Do we need this?
        if (!(AEB_INIT_SUBCLASS & paeb->m_dwFlags))
        {
            paeb->OnWinEvent(paeb->m_hwnd, uMessage, wParam, lParam, NULL);
        }
        break;
    }

    return CallWindowProc(paeb->m_lpfnComboWndProc, hwnd, uMessage, wParam, lParam);
}

void CAddressEditBox::_SetAutocompleteOptions()
{
    if (m_pac)
    {
        // Set the autocomplete options
        DWORD dwOptions = ACO_SEARCH | ACO_FILTERPREFIXES | ACO_USETAB | ACO_UPDOWNKEYDROPSLIST;
        if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOAPPEND, FALSE, /*default:*/FALSE))
        {
            dwOptions |= ACO_AUTOAPPEND;
        }

        if (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE))
        {
            dwOptions |= ACO_AUTOSUGGEST;
        }

        m_pac->SetOptions(dwOptions);
    }
}

/****************************************************\

    FUNCTION: _NavigateToUrlCB

    PARAMETERS:
        lParam - The CAddressEditBox this pointer.
        lpUrl - The URL to navigate to.

    DESCRIPTION:
        This function is specifically for AutoComplete
        to call when it needs to navigate.
\****************************************************/

HRESULT CAddressEditBox::_NavigateToUrlCB(LPARAM lParam, LPTSTR lpUrl)
{
//  NOTE: We don't need to navigate because AutoComplete will
//  will send a message to the ComboBoxEx that will carry out
//  the navigation.
    return S_OK;
}


//=================================================================
// Functions to prevent clobbering the address contents while dirty
//=================================================================
#define TF_EDITBOX TF_BAND|TF_GENERAL
//#define TF_EDITBOX TF_ALWAYS

BOOL CAddressEditBox::_IsDirty()
{
    return m_hwndEdit && SendMessage(m_hwndEdit, EM_GETMODIFY, 0, 0L);
}

void CAddressEditBox::_ClearDirtyFlag()
{
    TraceMsg(TF_EDITBOX, "CAddressEditBox::_ClearDirtyFlag()");
    SendMessage(m_hwndEdit, EM_SETMODIFY, FALSE, 0);
    _RemoveHook();
}

void CAddressEditBox::_InstallHookIfDirty()
{
    //
    // We only need to install the hook if we are connected to a browser for update notifications
    //
    if (m_fConnectedToBrowser)
    {
        // Make sure we are associated with the current thread
        if (!m_fAssociated)
        {
            //
            // If a CAddressEditBox is already associated with this thread, remove that
            // association and remove any pending mouse hook.  This can happen if the
            // open dialog comes up and the address bar is visible.
            //
            DWORD dwThread = GetCurrentThreadId();
            CAddressEditBox* pAeb;
            if (SUCCEEDED(m_al.Find(dwThread, (LPVOID*)&pAeb)))
            {
                pAeb->_ClearDirtyFlag();
                pAeb->m_fAssociated = FALSE;
                m_al.Delete(dwThread);
            }

            // There should not be any other CAddressEditBox associated with this thread!
            ASSERT(FAILED(m_al.Find(dwThread, (LPVOID*)&pAeb)));

            //
            // Associate ourselves with the current thread id.  We need this because
            // windows hooks are global and have no data associated with them.
            // On the callback, we use our thread id as the key.
            //
            m_al.Add(dwThread, this);
            m_fAssociated = TRUE;
        }

        if (!m_hhook && _IsDirty())
        {
            // ML: HINST_THISDLL is valid in its use here
            m_hhook = SetWindowsHookEx(WH_MOUSE, _MsgHook, HINST_THISDLL, GetCurrentThreadId());
            TraceMsg(TF_EDITBOX, "CAddressEditBox::_InstallHookIfDirty(), Hook installed");

            //
            // Subclass edit control of the combobox.  We do this here rather than when this
            // class is initialized so that we are first in the chain to receive messages.
            //
            if (!m_lpfnEditWndProc && m_hwndEdit && SetProp(m_hwndEdit, SZ_ADDRESSCOMBO_PROP, this))
            {
                m_lpfnEditWndProc = (WNDPROC)SetWindowLongPtr(m_hwndEdit, GWLP_WNDPROC, (LONG_PTR) _EditSubclassWndProc);
            }

            // Clear and changes that we previously cached
            m_cbex.mask = 0;
        }
    }
}

void CAddressEditBox::_RemoveHook()
{
    if (m_hhook)
    {
        UnhookWindowsHookEx(m_hhook);
        m_hhook = FALSE;
        TraceMsg(TF_EDITBOX, "CAddressEditBox::_RemoveHook(), Hook removed");
    }
}

LRESULT CALLBACK CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, LPARAM lParam)
{
    //
    // Get the CAddressEditBox associated with this thread. We need this because
    // windows hooks are global and have no data associated with them.
    // On the callback, we use our thread id as the key
    //
    CAddressEditBox* pThis;
    if (SUCCEEDED(CAddressEditBox::m_al.Find(GetCurrentThreadId(), (LPVOID*)&pThis)))
    {
        return pThis->_MsgHook(nCode, wParam, (MOUSEHOOKSTRUCT*)lParam);
    }
    return 0;
}

LRESULT CAddressEditBox::_MsgHook(int nCode, WPARAM wParam, MOUSEHOOKSTRUCT *pmhs)
{
    ASSERT(NULL != pmhs);

    if (nCode >= 0)
    {
        if ((wParam == WM_LBUTTONDOWN) || (wParam == WM_RBUTTONDOWN))
        {
            // Ignore if the button was clicked in our combo box
            RECT rc;
            if (GetWindowRect(m_hwnd, &rc) && !PtInRect(&rc, pmhs->pt))
            {
                _ClearDirtyFlag();
                _RemoveHook();
            }
        }
    }

    return CallNextHookEx(m_hhook, nCode, wParam, (LPARAM)pmhs);
}

/****************************************************\
    _ComboExSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.

    Description:
        We subclass the outer combobox to prevent
        the contents from getting clobbered while
        and edit is in progress (ie dirty).

\****************************************************/
LRESULT CALLBACK CAddressEditBox::_ComboExSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBOEX_PROP);

    if (!paeb)
        return DefWindowProc(hwnd, uMessage, wParam, lParam);

    g_hWinStationAfterEx = GetProcessWindowStation();

    if (uMessage == g_nAEB_AsyncNavigation)
    {
        // If the navigation was not canceled before, then navigate now.
        if ((AsyncNav *)wParam == paeb->m_pAsyncNav && paeb->m_pAsyncNav->_fReady)
        {
            paeb->_AsyncNavigate((AsyncNav *)wParam);
        }
    }

    switch (uMessage)
    {
    case CBEM_SETITEM:
        {
            //
            // If we are still dirty, don't let anyone clobber our edit control contents!
            //
            const COMBOBOXEXITEM* pcCBItem = (const COMBOBOXEXITEM FAR *)lParam;
            if (paeb->_IsDirty() && pcCBItem->iItem == -1)
            {
                //
                // save this info so that if the user hits esc, we restore the right thing
                //
                if (IsFlagSet(pcCBItem->mask, CBEIF_TEXT))
                {
                    Str_SetPtr(&paeb->m_pszCurrentUrl, pcCBItem->pszText);
                }

                Str_SetPtr(&(paeb->m_cbex.pszText), NULL);      // Free the previous value
                paeb->m_cbex = *pcCBItem;
                paeb->m_cbex.pszText = NULL;
                Str_SetPtr(&(paeb->m_cbex.pszText), paeb->m_pszCurrentUrl);
                paeb->m_cbex.cchTextMax = lstrlen(paeb->m_cbex.pszText);
                return 0L;
            }
            else
            {
                // Make sure that the icon is visible
                SendMessage(paeb->m_hwnd, CBEM_SETEXTENDEDSTYLE, CBES_EX_NOEDITIMAGE, 0);
            }
        }
        break;

    case WM_DESTROY:
        // Release the lists now so that they don't try to use our
        // window after we're destroyed
        if (paeb->m_palCurrent)
        {
            paeb->m_palCurrent->Connect(FALSE, paeb->m_hwnd, NULL, NULL, NULL);
            ATOMICRELEASE(paeb->m_palCurrent);
        }
        ATOMICRELEASE(paeb->m_palSNS);
        ATOMICRELEASE(paeb->m_palMRU);

        //
        // Unsubclass myself.
        //
        RemoveProp(hwnd, SZ_ADDRESSCOMBOEX_PROP);
        if (!paeb->m_lpfnComboExWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnComboExWndProc);
        break;

    default:
        break;
    }

    return CallWindowProc(paeb->m_lpfnComboExWndProc, hwnd, uMessage, wParam, lParam);
}

/****************************************************\
    _EnumFindWindow

    Description:
        Called by EnumChildWindows to see is the window
        passed in lParam is a child of a given
        parent.

\****************************************************/
BOOL CALLBACK CAddressEditBox::_EnumFindWindow
(
    HWND hwnd,      // handle to child window
    LPARAM lParam   // application-defined value
)
{
    // Stop enumeration when match found
    return (hwnd != (HWND)lParam);
}

/****************************************************\
    _EditSubclassWndProc

    Input:
        Standard WndProc parameters

    Return:
        Standard WndProc return.

    Description:
        We subclass the edit control in the combobox
        so that we can keep it from losing focus under
        certain conditions.

\****************************************************/
LRESULT CALLBACK CAddressEditBox::_EditSubclassWndProc(HWND hwnd, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    CAddressEditBox * paeb = (CAddressEditBox*)GetProp(hwnd, SZ_ADDRESSCOMBO_PROP);

    if (!paeb)
        return DefWindowProc(hwnd, uMessage, wParam, lParam);

    switch (uMessage)
    {
    case WM_SETCURSOR:
        {
            HWND hwndCursor = (HWND)wParam;
            int nHittest = LOWORD(lParam);
            if (hwndCursor == hwnd && nHittest == HTCLIENT)
            {
                //
                // If we don't have focus, we want to show an arrow because clicking will select
                // the contents of the edit box.  Otherwise show the I-beam.  Also, if the edit box
                // is empty we show the I-beam because there is nothing to select.
                //
                int cch = GetWindowTextLength(paeb->m_hwndEdit);
                LPCTSTR lpCursorName = (cch == 0 || GetFocus() == hwnd) ? IDC_IBEAM : IDC_ARROW;
                SetCursor(LoadCursor(NULL, lpCursorName));
                return TRUE;
            }
            break;
        }
    case WM_KILLFOCUS:
        {
            //
            // If we lose focus with the mouse hook installed, the user probably did
            // not initiate the change so we try to grab it back.  The hook is removed
            // when the user clicks outside the edit box or presses a key to finish the edit
            // (tab, enter, or esc)
            //
            HWND hwndGetFocus = (HWND)wParam;

            if ((paeb->m_hhook) && hwndGetFocus && (hwnd != hwndGetFocus))
            {
                //
                // Make sure that this is not the drop-down portion of the combo.
                // Also, if we are in a dialog (open dialog) then we don't see the
                // tab key.  So if focus is going to a sibling we'll let it through.
                //
                HWND hwndGetFocusParent = GetParent(hwndGetFocus);
                HWND hwndSiblingParent = paeb->m_hwnd ? GetParent(paeb->m_hwnd) : GetParent(hwnd);
                if ((paeb->m_hwnd != hwndGetFocusParent) && (hwndGetFocusParent != hwndSiblingParent) &&
                     EnumChildWindows(hwndSiblingParent, _EnumFindWindow, (LPARAM)hwndGetFocus))
                {
                    // Get the top-level window of who's getting focus
                    HWND hwndFrame = hwndGetFocus;
                    HWND hwndParent;
                    while (hwndParent = GetParent(hwndFrame))
                        hwndFrame = hwndParent;

                    // If focus is going somewhere else in our browser window, grab focus back
                    if (hwndFrame == paeb->m_hwndBrowser)
                    {
                        DWORD dwStart, dwEnd;
                        SendMessage(paeb->m_hwndEdit, EM_GETSEL, (WPARAM)&dwStart, (LPARAM)&dwEnd);
                        SetFocus(paeb->m_hwndEdit);
                        SendMessage(paeb->m_hwndEdit, EM_SETSEL, dwStart, dwEnd);
                        TraceMsg(TF_BAND|TF_GENERAL, "CAddressEditBox::_EditSubclassWndProc, Restoring focus");
                        return 0L;
                    }
                }
            }

            //
            // Losing focus so allow others to change our contents
            //
            paeb->_ClearDirtyFlag();
        }
        break;

    case WM_KEYDOWN:
        {
            // If we are tabbing away, clear our dirty flag
            switch (wParam)
            {
                case VK_TAB:
                    paeb->_ClearDirtyFlag();
                    break;

                case VK_ESCAPE:
                {
                    if (paeb->m_hwnd && ComboBox_GetDroppedState(paeb->m_hwnd))
                    {
                        SendMessage(paeb->m_hwnd, CB_SHOWDROPDOWN, FALSE, 0);
                    }
                    else
                    {
                        IUnknown *punk = NULL;

                        if (paeb->m_pbp)
                        {
                            paeb->m_pbp->GetBrowserWindow(&punk);
                        }

                        if (punk)
                        {
                            IWebBrowser* pwb;
                            punk->QueryInterface(IID_IWebBrowser, (LPVOID*)&pwb);

                            if (pwb)
                            {
                                pwb->Stop();
                                pwb->Release();
                            }
                            punk->Release();
                        }

                        // Cancel pending navigation, if any
                        paeb->_CancelNavigation();
                    }

                    LRESULT lResult = CallWindowProc(paeb->m_lpfnEditWndProc, hwnd, uMessage, wParam, lParam);

                    // This bit of magic that restores the icon in the combobox.  Otherwise when we
                    // dismiss the dropwown with escape we get the icon last selected in the dropdown.
                    HWND hwndCombo = (HWND)SendMessage(paeb->m_hwnd, CBEM_GETCOMBOCONTROL, 0, 0);
                    SendMessage(hwndCombo, CB_SETCURSEL, -1, 0);
                    return lResult;
                }
            }

            break;
        }
    case WM_DESTROY:
        // Unsubclass myself.
        RemoveProp(hwnd, SZ_ADDRESSCOMBO_PROP);
        if (!paeb->m_lpfnEditWndProc)
            return 0;
        SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR) paeb->m_lpfnEditWndProc);
        ASSERT(paeb->m_hwndEdit);
        paeb->m_hwndEdit = NULL;
        break;
    default:
        break;
    }

    return CallWindowProc(paeb->m_lpfnEditWndProc, hwnd, uMessage, wParam, lParam);
}

BOOL GetLabelStringW(HWND hwnd, LPWSTR pwszBuf, DWORD cchBuf)
{
    HWND    hwndLabel;
    LONG    lStyle;
    LRESULT lResult;
    BOOL    result = FALSE;

    ASSERT(pwszBuf && cchBuf);

    *pwszBuf = 0;

    if (IsWindow(hwnd))
    {
        hwndLabel = hwnd;

        while (hwndLabel = GetWindow(hwndLabel, GW_HWNDPREV))
        {
            lStyle = GetWindowLong(hwndLabel, GWL_STYLE);

            //
            // Skip if invisible
            //
            if (!(lStyle & WS_VISIBLE))
                continue;

            //
            // Is this a static dude?
            //
            lResult = SendMessage(hwndLabel, WM_GETDLGCODE, 0, 0);
            if (lResult & DLGC_STATIC)
            {
                //
                // Great, we've found our label.
                //
                result = GetWindowTextWrapW(hwndLabel, pwszBuf, cchBuf);
            }

            //
            // Is this a tabstop or group?  If so, bail out now.
            //
            if (lStyle & (WS_GROUP | WS_TABSTOP))
                break;
        }
    }

    return result;
}


CAddressEditAccessible::CAddressEditAccessible(HWND hwndCombo, HWND hwndEdit)
{
    m_cRefCount = 1;
    m_hwndEdit = hwndEdit;

    WCHAR wszTitle[MAX_PATH];

    if (!GetLabelStringW(GetParent(hwndCombo), wszTitle, ARRAYSIZE(wszTitle)))
    {
        MLLoadStringW(IDS_BAND_ADDRESS, wszTitle, ARRAYSIZE(wszTitle));
    }

    Str_SetPtr(&m_pwszName, wszTitle);

    CreateStdAccessibleObject(hwndCombo, OBJID_CLIENT, IID_IAccessible, (void **)&m_pDelegateAccObj);
}

CAddressEditAccessible::~CAddressEditAccessible()
{
    Str_SetPtr(&m_pwszName, NULL);
}

// *** IUnknown ***
STDMETHODIMP_(ULONG) CAddressEditAccessible::AddRef()
{
    return InterlockedIncrement((LPLONG)&m_cRefCount);
}

STDMETHODIMP_(ULONG) CAddressEditAccessible::Release()
{
    ASSERT( 0 != m_cRefCount );
    ULONG cRef = InterlockedDecrement(&m_cRefCount);
    if ( 0 == cRef )
    {
        delete this;
    }
    return cRef;
}

STDMETHODIMP CAddressEditAccessible::QueryInterface(REFIID riid, LPVOID * ppvObj)
{
    return _DefQueryInterface(riid, ppvObj);
}

// *** IAccessible ***
STDMETHODIMP CAddressEditAccessible::get_accName(VARIANT varChild, BSTR  *pszName)
{
    *pszName = (m_pwszName != NULL) ? SysAllocString(m_pwszName) : NULL;
    return (*pszName != NULL) ? S_OK : S_FALSE;
}

STDMETHODIMP CAddressEditAccessible::get_accValue(VARIANT varChild, BSTR  *pszValue)
{
    WCHAR wszValue[MAX_URL_STRING];

    if (Edit_GetText(m_hwndEdit, wszValue, ARRAYSIZE(wszValue)))
    {
        *pszValue = SysAllocString(wszValue);
    }
    else
    {
        *pszValue = NULL;
    }

    return (*pszValue != NULL) ? S_OK : S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\apithk.c ===
#ifdef UNICODE
#error start menu won't run on win95 if this apithk.c is compiled unicode
#endif
//
//  APITHK.C
//
//  This file has API thunks that allow shdocvw to load and run on
//  multiple versions of NT or Win95.  Since this component needs
//  to load on the base-level NT 4.0 and Win95, any calls to system
//  APIs introduced in later OS versions must be done via GetProcAddress.
// 
//  Also, any code that may need to access data structures that are
//  post-4.0 specific can be added here.
//
//  NOTE:  this file does *not* use the standard precompiled header,
//         so it can set _WIN32_WINNT to a later version.
//


#include "priv.h"       // Don't use precompiled header here
#include "uxtheme.h"

HINSTANCE GetComctl32Hinst()
{
    static HINSTANCE s_hinst = NULL;
    if (!s_hinst)
        s_hinst = GetModuleHandle(TEXT("comctl32.dll"));
    return s_hinst;
}

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes)
{
    if (g_bRunOnNT5 || g_bRunOnMemphis)
    {
        HCURSOR hcur = LoadCursor(NULL, IDC_HAND);  // from USER, system supplied
        if (hcur)
            return hcur;
    }

    return LoadCursor(GetComctl32Hinst(), IDC_HAND_INTERNAL);
}

/*----------------------------------------------------------
Purpose: Use the Microsoft ActiveAccessiblity routines to 
        notify Accessibility programs of events
*/
typedef void (* PFNNOTIFYWINEVENT)(DWORD event, HWND hwnd, LONG idObject, LONG idChild);
#define DONOTHING_WINEVENT (PFNNOTIFYWINEVENT)1
void NT5_NotifyWinEvent(
    IN DWORD event,
    IN HWND hwnd,
    IN LONG idObject,
    IN LONG idChild)
{
    static PFNNOTIFYWINEVENT pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNNOTIFYWINEVENT)GetProcAddress(hmod, "NotifyWinEvent");
        
        if (!pfn)
            pfn = DONOTHING_WINEVENT;
    }

    if (pfn != DONOTHING_WINEVENT)
        pfn(event, hwnd, idObject, idChild);
}


// Use the Microsoft ActiveAccessiblity routines to  return an IAccessible object

typedef LRESULT (* PFNLRESULTFROMOBJECT)(REFIID riid, WPARAM wParam, IUnknown* punk);

LRESULT ACCESSIBLE_LresultFromObject(
    IN REFIID riid,
    IN WPARAM wParam,
    OUT IUnknown* punk)
{
    static PFNLRESULTFROMOBJECT pfn = NULL;
    static BOOL fLoadAttempted = FALSE;
    LRESULT lRet = (LRESULT)E_FAIL;

    if (NULL == pfn && !fLoadAttempted)
    {
        // LoadLibrary here because OLEAcc is not loaded in the process
        HMODULE hmod = LoadLibrary(TEXT("OLEACC"));
        
        if (hmod)
            pfn = (PFNLRESULTFROMOBJECT)GetProcAddress(hmod, "LresultFromObject");
        else
            fLoadAttempted = TRUE;
    }

    if (pfn)
        lRet = pfn(riid, wParam, punk);

    return lRet;
}

// wrapper for NT5/Millennium AllowSetForegroundWindow
typedef BOOL (* PFNALLOWSFW)(DWORD dwProcessId);

BOOL NT5_AllowSetForegroundWindow(IN DWORD dwProcessId )
{
    static PFNALLOWSFW pfn = (PFNALLOWSFW)-1;
    if (((PFNALLOWSFW)-1) == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        pfn = hmod ? (PFNALLOWSFW)GetProcAddress(hmod, "AllowSetForegroundWindow") : NULL;
    }

    return pfn ? pfn(dwProcessId) : FALSE;
}

typedef BOOL (* PFNANIMATEWINDOW)(HWND hwnd, DWORD dwTime, DWORD dwFlags);

// Thunk for NT 5's AnimateWindow.

BOOL NT5_AnimateWindow(IN HWND hwnd, IN DWORD dwTime, IN DWORD dwFlags)
{
    BOOL bRet = FALSE;
    static PFNANIMATEWINDOW pfn = NULL;

    ASSERT(g_bRunOnMemphis || g_bRunOnNT5);

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        
        if (hmod)
            pfn = (PFNANIMATEWINDOW)GetProcAddress(hmod, "AnimateWindow");
    }

    if (pfn)
        bRet = pfn(hwnd, dwTime, dwFlags);

    return bRet;    
}

// Position Menubands using NT5's AnimateWindow if available.

void SlideAnimate(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide)
{
    DWORD dwAnimateFlags = AW_CENTER;
    switch(uSide) 
    {
    case MENUBAR_LEFT:      dwAnimateFlags = AW_HOR_NEGATIVE;
        break;
    case MENUBAR_RIGHT:     dwAnimateFlags = AW_HOR_POSITIVE;
        break;
    case MENUBAR_TOP:       dwAnimateFlags = AW_VER_NEGATIVE;
        break;
    case MENUBAR_BOTTOM:    dwAnimateFlags = AW_VER_POSITIVE;
        break;
    }
    NT5_AnimateWindow(hwnd, 120, dwAnimateFlags | AW_SLIDE);
}

void AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate)
{
    if ((g_bRunOnMemphis || g_bRunOnNT5) && !fNoAnimate)
    {
        BOOL fAnimate = FALSE;
        SystemParametersInfo(SPI_GETMENUANIMATION, 0, &fAnimate, 0);
        if (fAnimate)
        {
            SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top,
                    RECTWIDTH(*prc), RECTHEIGHT(*prc), uFlags);
        
            fAnimate = FALSE;
#ifdef WINNT
            SystemParametersInfo(SPI_GETMENUFADE, 0, &fAnimate, 0);
#endif // WINNT
            if (fAnimate)
            {
                NT5_AnimateWindow(hwnd, 175, AW_BLEND);
            }
            else
            {
                SlideAnimate(hwnd, prc, uFlags, uSide);
            }
        }
        else
            goto UseSetWindowPos;
    }
    else
    {
UseSetWindowPos:
        // Enable the show window so that it gets displayed.
        uFlags |= SWP_SHOWWINDOW;

        SetWindowPos(hwnd, HWND_TOPMOST, prc->left, prc->top, RECTWIDTH(*prc), RECTHEIGHT(*prc), 
                     uFlags);
    }
}


/*----------------------------------------------------------
Purpose: Use the Microsoft ActiveAccessiblity routines to 
        return an IAccessible object
*/
typedef LRESULT (* PFNCREATESTDACCESSIBLEOBJECT)(HWND hwnd, LONG idObject, REFIID riid, void** ppvObj);


LRESULT ACCESSIBLE_CreateStdAccessibleObject(
    IN HWND hwnd,
    IN LONG idObject,
    IN REFIID riid,
    OUT void** ppvObj)
{
    static PFNCREATESTDACCESSIBLEOBJECT pfn = NULL;
    static BOOL fLoadAttempted = FALSE;
    LRESULT lRet = (LRESULT)E_FAIL;

    if (NULL == pfn && !fLoadAttempted)
    {
        // LoadLibrary here because OLEAcc is not loaded in the process
        HMODULE hmod = LoadLibrary(TEXT("OLEACC"));
        
        if (hmod)
            pfn = (PFNCREATESTDACCESSIBLEOBJECT)GetProcAddress(hmod, "CreateStdAccessibleObject");
        else
            fLoadAttempted = TRUE;
    }

    if (pfn)
        lRet = pfn(hwnd, idObject, riid, ppvObj);

    return lRet;
}

typedef BOOL (* PFNLOCKSETFOREGROUNDWINDOW)(UINT);

BOOL MyLockSetForegroundWindow(BOOL fLock)
{
    static PFNLOCKSETFOREGROUNDWINDOW pfn = (PFNLOCKSETFOREGROUNDWINDOW)-1;
    BOOL fRet = FALSE;

    if ((PFNLOCKSETFOREGROUNDWINDOW)-1 == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        if (hmod)
            pfn = (PFNLOCKSETFOREGROUNDWINDOW)GetProcAddress(hmod, "LockSetForegroundWindow");
        else
            pfn = NULL;
    }

    if (pfn)
        fRet = pfn(fLock ? LSFW_LOCK : LSFW_UNLOCK);

    return fRet;
}

typedef UINT (* PFNSHEXTRACTICONSW)(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

STDAPI_(UINT) MyExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags)
{
    UINT uiRet = 0;
    static PFNSHEXTRACTICONSW pfn = NULL;

    if (GetUIVersion() >= 5)
    {
        if (NULL == pfn)
        {
            HMODULE hmod = GetModuleHandle(TEXT("SHELL32"));
            if (hmod)
                pfn = (PFNSHEXTRACTICONSW)GetProcAddress(hmod, "SHExtractIconsW");
        }

        if (pfn)
            uiRet = pfn(wszFileName, nIconIndex, cxIcon, cyIcon, phicon, piconid, nIcons, flags);
    }

    return uiRet;    
}


typedef BOOL (* PFNUPDATELAYEREDWINDOW)
    (HWND hwnd, 
    HDC hdcDst,
    POINT *pptDst,
    SIZE *psize,
    HDC hdcSrc,
    POINT *pptSrc,
    COLORREF crKey,
    BLENDFUNCTION *pblend,
    DWORD dwFlags);

BOOL BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst)
{
    BOOL bRet = FALSE;
    static PFNUPDATELAYEREDWINDOW pfn = NULL;

    if (NULL == pfn)
    {
        HMODULE hmod = GetModuleHandle(TEXT("USER32"));
        if (hmod)
            pfn = (PFNUPDATELAYEREDWINDOW)GetProcAddress(hmod, "UpdateLayeredWindow");
    }

    if (pfn)
    {
        BLENDFUNCTION blend;
        blend.BlendOp = AC_SRC_OVER;
        blend.BlendFlags = 0;
        blend.AlphaFormat = 0;
        blend.SourceConstantAlpha = bBlendConst;

        bRet = pfn(hwnd, hdcDest, ppt, psize, hdc, pptSrc, 0, &blend, ULW_ALPHA);
    }

    return bRet;    
}

BOOL NT5_SetLayeredWindowAttributes(
    HWND hwnd,
    COLORREF crKey,
    BYTE bAlpha,
    DWORD dwFlags)
{
    static BOOL (*pfn)(HWND, COLORREF, BYTE, DWORD) = NULL;

    if (pfn == NULL)
    {
        HMODULE hMod = LoadLibrary(TEXT("user32.dll"));
        if (hMod)
        {
            pfn = (BOOL (*)(HWND, COLORREF, BYTE, DWORD))GetProcAddress(hMod, "SetLayeredWindowAttributes");
        }
    }

    if (pfn)
        return pfn(hwnd, crKey, bAlpha, dwFlags);
    return 0;
}

typedef HRESULT (* PFNSHPATHPREPAREFORWRITE)(HWND hwnd, IUnknown* punkModless, LPCWSTR pwzPath, DWORD dwFlags);
STDAPI NT5_SHPathPrepareForWrite(HWND hwnd, IUnknown* punkModless, LPCWSTR pwzPath, DWORD dwFlags)
{
    HRESULT hRet = E_FAIL;
    static PFNSHPATHPREPAREFORWRITE pfn = NULL;

    if (GetUIVersion() >= 5)
    {
        if (NULL == pfn)
        {
            HMODULE hmod = GetModuleHandle(TEXT("shell32.dll"));
            if (hmod)
            {
                pfn = (PFNSHPATHPREPAREFORWRITE)GetProcAddress(hmod, "SHPathPrepareForWriteW");
            }
        }

        if (pfn)
        {
            hRet = pfn(hwnd, punkModless, pwzPath, dwFlags);
        }
    }

    return hRet;    
}


void Comctl32_SetWindowTheme(HWND hwnd, LPWSTR psz)
{
    SendMessage(hwnd, CCM_SETWINDOWTHEME, 0, (LPARAM)psz);
}

void Comctl32_GetBandMargins(HWND hwnd, MARGINS* pmar)
{
    SendMessage(hwnd, RB_GETBANDMARGINS, 0, (LPARAM)pmar);
}

void Comctl32_FixAutoBreak(LPNMHDR pnm)
{
    LPNMREBARAUTOBREAK pnmab = (LPNMREBARAUTOBREAK) pnm;
    pnmab->fAutoBreak = !(pnmab->uMsg == RBAB_AUTOSIZE);
}

void Comctl32_SetDPIScale(HWND hwnd)
{
    SendMessage(hwnd, CCM_DPISCALE, TRUE, 0);    
}

// enable the marquee mode. note, this only works on comctl32 v6

STDAPI_(void) ProgressSetMarqueeMode(HWND hwndPrgress, BOOL bOn)
{
    if (IsOS(OS_WHISTLERORGREATER))
    {
        SendMessage(hwndPrgress, PBM_SETMARQUEE, bOn, 0);
        SHSetWindowBits(hwndPrgress, GWL_STYLE, PBS_MARQUEE, bOn ? PBS_MARQUEE : 0);
    }
}



// terminal server session notification:

static HMODULE s_hmodWTSApi = NULL; 

typedef BOOL (* PFNWTS_REGISTER_SESSION_NOTIFICATION)(HWND hwnd, DWORD dwFlags);
static PFNWTS_REGISTER_SESSION_NOTIFICATION s_pfnWTSRegisterSession = NULL;

typedef BOOL (* PFNWTS_UNREGISTER_SESSION_NOTIFICATION)(HWND hwnd);
static PFNWTS_UNREGISTER_SESSION_NOTIFICATION s_pfnWTSUnRegisterSession = NULL;

BOOL DL_WTSRegisterSessionNotification(HWND hwnd, DWORD dwFlags)
{
    if (s_pfnWTSRegisterSession == NULL)
    {
        if (s_hmodWTSApi == NULL)
        {
            s_hmodWTSApi = LoadLibrary(TEXT("wtsapi32"));
        }
        
        if (s_hmodWTSApi)
        {
            s_pfnWTSRegisterSession = (PFNWTS_REGISTER_SESSION_NOTIFICATION)GetProcAddress(s_hmodWTSApi, "WTSRegisterSessionNotification");
        }
    }

    if (s_pfnWTSRegisterSession != NULL)
    {
        return s_pfnWTSRegisterSession(hwnd, dwFlags);
    }
    return FALSE;
}



BOOL DL_WTSUnRegisterSessionNotification(HWND hwnd)
{
    if (s_pfnWTSUnRegisterSession == NULL)
    {
        if (s_hmodWTSApi == NULL)
        {
            s_hmodWTSApi = LoadLibrary(TEXT("wtsapi32"));
        }
        
        if (s_hmodWTSApi)
        {
            s_pfnWTSUnRegisterSession = (PFNWTS_UNREGISTER_SESSION_NOTIFICATION)GetProcAddress(s_hmodWTSApi, "WTSUnRegisterSessionNotification");
        }
    }

    if (s_pfnWTSUnRegisterSession != NULL)
    {
        BOOL fRet = s_pfnWTSUnRegisterSession(hwnd);
        FreeLibrary(s_hmodWTSApi);
        s_hmodWTSApi = NULL;
        s_pfnWTSRegisterSession = NULL;
        s_pfnWTSUnRegisterSession = NULL;
        return fRet;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\atl.h ===
STDAPI_(void) AtlInit(HINSTANCE hinst);
STDAPI_(void) AtlTerm();

STDAPI        AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
STDAPI_(LONG) AtlGetLockCount();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\apithk.h ===
//
//  APITHK.H
//


#ifndef _APITHK_H_
#define _APITHK_H_


#include "uxtheme.h"

#ifdef __cplusplus
extern "C" {
#endif

#define PrivateSPI_GETSELECTIONFADE 0x1014
#define PrivateWS_EX_LAYERED        0x00080000
#define PrivateWM_GETOBJECT         0x003D
#define PrivateTPM_HORPOSANIMATION  0x0400L
#define PrivateTPM_HORNEGANIMATION  0x0800L
#define PrivateTPM_VERPOSANIMATION  0x1000L
#define PrivateTPM_VERNEGANIMATION  0x2000L
#define PrivateTPM_NOANIMATION      0x4000L
#define PrivateWM_CHANGEUISTATE     0x0127
#define PrivateWM_UPDATEUISTATE     0x0128
#define PrivateWM_QUERYUISTATE      0x0129
#define PrivateUIS_SET              1
#define PrivateUIS_CLEAR            2
#define PrivateUIS_INITIALIZE       3
#define PrivateUISF_HIDEFOCUS       0x1
#define PrivateUISF_HIDEACCEL       0x2
#define PrivateSPI_GETKEYBOARDCUES  0x100A
#define PrivateWS_EX_LAYERED        0x00080000
#define PrivateSPI_GETCLEARTYPE     116
#define PrivateLWA_COLORKEY        0x00000001
#define PrivateLWA_ALPHA           0x00000002
#define PrivateSPI_GETFLATMENU                     0x1022
#define PrivateSPI_SETFLATMENU                     0x1023
#define PrivateCOLOR_MENUHILIGHT       29
#define PrivateCOLOR_MENUBAR           30
#define PrivateCS_DROPSHADOW           0x00020000
#define PrivateSPI_SETDROPSHADOW                   0x1025
#define PrivateTBSTYLE_EX_DOUBLEBUFFER  0x00000080
#define PrivateRBN_AUTOBREAK       (RBN_FIRST - 22)
#define PrivateRBAB_AUTOSIZE   0x0001
#define PrivateRBAB_ADDBAND    0x0002
#define PrivateRBSTR_CHANGERECT            0x0001
#define PrivateILC_PERITEMMIRROR    0x00008000


#define KEYBOARDCUES

#if (WINVER >= 0x0500)

// for files in nt5api and w5api dirs, use the definition in sdk include.
// And make sure our private define is in sync with winuser.h.

#if SPI_GETSELECTIONFADE != PrivateSPI_GETSELECTIONFADE
#error inconsistant SPI_GETSELECTIONFADE in winuser.h
#endif

#if WS_EX_LAYERED != PrivateWS_EX_LAYERED
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#if WM_GETOBJECT != PrivateWM_GETOBJECT
#error inconsistant WM_GETOBJECT in winuser.h
#endif

#if TPM_HORPOSANIMATION != PrivateTPM_HORPOSANIMATION
#error inconsistant TPM_HORPOSANIMATION in winuser.h
#endif

#if TPM_HORNEGANIMATION != PrivateTPM_HORNEGANIMATION
#error inconsistant TPM_HORNEGANIMATION in winuser.h
#endif

#if TPM_VERPOSANIMATION != PrivateTPM_VERPOSANIMATION
#error inconsistant TPM_VERPOSANIMATION in winuser.h
#endif

#if TPM_VERNEGANIMATION != PrivateTPM_VERNEGANIMATION
#error inconsistant WS_EX_LAYERED in winuser.h
#endif

#if TPM_NOANIMATION != PrivateTPM_NOANIMATION
#error inconsistant TPM_NOANIMATION in winuser.h
#endif

// We are checking this in at the same time that user is. This is to prevent
// sync problems.
#ifdef SPI_GETCLEARTYPE
    #if SPI_GETCLEARTYPE != PrivateSPI_GETCLEARTYPE
        #error inconsistant SPI_GETCLEARTYPE in winuser.h
    #endif
#else
    #define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#endif


#else

#define WS_EX_LAYERED           PrivateWS_EX_LAYERED
#define SPI_GETSELECTIONFADE    PrivateSPI_GETSELECTIONFADE
#define WM_GETOBJECT            PrivateWM_GETOBJECT
#define TPM_HORPOSANIMATION     PrivateTPM_HORPOSANIMATION
#define TPM_HORNEGANIMATION     PrivateTPM_HORNEGANIMATION
#define TPM_VERPOSANIMATION     PrivateTPM_VERPOSANIMATION
#define TPM_VERNEGANIMATION     PrivateTPM_VERNEGANIMATION
#define TPM_NOANIMATION         PrivateTPM_NOANIMATION
#define SPI_GETCLEARTYPE        PrivateSPI_GETCLEARTYPE
#define LWA_COLORKEY            PrivateLWA_COLORKEY
#define LWA_ALPHA               PrivateLWA_ALPHA   

#ifdef KEYBOARDCUES
#define WM_CHANGEUISTATE        PrivateWM_CHANGEUISTATE 
#define WM_UPDATEUISTATE        PrivateWM_UPDATEUISTATE 
#define WM_QUERYUISTATE         PrivateWM_QUERYUISTATE  
#define UIS_SET                 PrivateUIS_SET          
#define UIS_CLEAR               PrivateUIS_CLEAR        
#define UIS_INITIALIZE          PrivateUIS_INITIALIZE   
#define UISF_HIDEFOCUS          PrivateUISF_HIDEFOCUS
#define UISF_HIDEACCEL          PrivateUISF_HIDEACCEL   
#define SPI_GETKEYBOARDCUES     PrivateSPI_GETKEYBOARDCUES
#endif //KEYBOARDCUES

#define SPI_GETFLATMENU         PrivateSPI_GETFLATMENU  
#define SPI_SETFLATMENU         PrivateSPI_SETFLATMENU  
#define COLOR_MENUHILIGHT       PrivateCOLOR_MENUHILIGHT
#define COLOR_MENUBAR           PrivateCOLOR_MENUBAR    
#define CS_DROPSHADOW           PrivateCS_DROPSHADOW
#define SPI_SETDROPSHADOW       PrivateSPI_SETDROPSHADOW                   
#define TBSTYLE_EX_DOUBLEBUFFER PrivateTBSTYLE_EX_DOUBLEBUFFER
#define RBN_AUTOBREAK           PrivateRBN_AUTOBREAK
#define RBAB_AUTOSIZE           PrivateRBAB_AUTOSIZE
#define RBAB_ADDBAND            PrivateRBAB_ADDBAND 
#define RBSTR_CHANGERECT        PrivateRBSTR_CHANGERECT

#if 0
typedef struct _MARGINS
{
    int cxLeftWidth;      // width of left border that retains its size
    int cxRightWidth;     // width of right border that retains its size
    int cyTopHeight;      // height of top border that retains its size
    int cyBottomHeight;   // height of bottom border that retains its size
} MARGINS, *PMARGINS;

typedef HANDLE HTHEME;          // handle to a section of theme data for class

STDAPI_(HTHEME) OpenThemeData(HWND hwnd, LPCWSTR pszClassList);

STDAPI SetWindowTheme(HWND hwnd, LPCWSTR pszSubAppName, 
    LPCWSTR pszSubIdList);

STDAPI GetThemeTextExtent(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, LPCWSTR pszText, int iCharCount, 
    DWORD dwTextFlags, OPTIONAL const RECT *pBoundingRect, 
    OUT RECT *pExtentRect);

STDAPI DrawThemeBackground(HTHEME hTheme, HDC hdc, 
    int iPartId, int iStateId, const RECT *pRect, OPTIONAL const RECT *pClipRect);

STDAPI DrawThemeText(HTHEME hTheme, HDC hdc, int iPartId, 
    int iStateId, LPCWSTR pszText, int iCharCount, DWORD dwTextFlags, 
    DWORD dwTextFlags2, const RECT *pRect);
STDAPI CloseThemeData(HTHEME hTheme);
STDAPI_(BOOL) IsThemeActive();
STDAPI GetThemeMargins(HTHEME hTheme, int iPartId, 
    int iStateId, int iPropId, OUT MARGINS *pMargins);
#endif

#endif // WINVER >= 0x0500

STDAPI_(HCURSOR) LoadHandCursor(DWORD dwRes);

STDAPI_(LRESULT) ACCESSIBLE_LresultFromObject(
    IN REFIID riid,
    IN WPARAM wParam,
    OUT IUnknown* punk);

STDAPI ACCESSIBLE_CreateStdAccessibleObject(
    IN HWND hwnd,
    IN LONG idObject,
    IN REFIID riid,
    OUT void** ppvObj);

STDAPI_(void) NT5_NotifyWinEvent(
    IN DWORD event,
    IN HWND hwnd,
    IN LONG idObject,
    IN LONG idChild);

#ifdef NotifyWinEvent
#undef NotifyWinEvent
#endif

#ifdef LresultFromObject
#undef LresultFromObject
#endif

#ifdef CreateStdAccessibleObject
#undef CreateStdAccessibleObject
#endif

#ifdef SHPathPrepareForWrite
#undef SHPathPrepareForWrite
#endif

#define AllowSetForegroundWindow NT5_AllowSetForegroundWindow

STDAPI_(BOOL) NT5_AllowSetForegroundWindow( DWORD dwProcessId );
STDAPI_(BOOL) NT5_SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);
STDAPI_(HRESULT) NT5_SHPathPrepareForWrite(HWND hwnd, IUnknown *punkModless, LPCWSTR pwzPath, DWORD dwFlags);

void Comctl32_SetWindowTheme(HWND hwnd, LPWSTR psz);
void Comctl32_GetBandMargins(HWND hwnd, MARGINS* mBorders);
void Comctl32_FixAutoBreak(LPNMHDR pnm);
void Comctl32_SetDPIScale(HWND hwnd);

#define SetLayeredWindowAttributes NT5_SetLayeredWindowAttributes
#define NotifyWinEvent NT5_NotifyWinEvent
#define LresultFromObject ACCESSIBLE_LresultFromObject
#define CreateStdAccessibleObject ACCESSIBLE_CreateStdAccessibleObject
#define SHPathPrepareForWrite NT5_SHPathPrepareForWrite

STDAPI_(void) AnimateSetMenuPos(HWND hwnd, RECT* prc, UINT uFlags, UINT uSide, BOOL fNoAnimate);
STDAPI_(void) MyLockSetForegroundWindow(BOOL fLock);

STDAPI_(BOOL) BlendLayeredWindow(HWND hwnd, HDC hdcDest, POINT* ppt, SIZE* psize, HDC hdc, POINT* pptSrc, BYTE bBlendConst);

STDAPI_(UINT) MyExtractIconsW(LPCWSTR wszFileName, int nIconIndex, int cxIcon, int cyIcon, HICON *phicon, UINT *piconid, UINT nIcons, UINT flags);

// terminal server session notification:
#include "wtsapi32.h"
BOOL WINAPI DL_WTSRegisterSessionNotification(HWND hWnd, DWORD dwFlags);
BOOL WINAPI DL_WTSUnRegisterSessionNotification(HWND hWnd);

// current browseui build settings skip definition of this message in winuser.h, need to define "manually"
#ifndef WM_WTSSESSION_CHANGE
#define WM_WTSSESSION_CHANGE            0x02B1

/*
 * codes passed in WPARAM for WM_WTSSESSION_CHANGE
 */
#define WTS_CONSOLE_CONNECT                0x1
#define WTS_CONSOLE_DISCONNECT             0x2
#define WTS_REMOTE_CONNECT                 0x3
#define WTS_REMOTE_DISCONNECT              0x4
#define WTS_SESSION_LOGON                  0x5
#define WTS_SESSION_LOGOFF                 0x6
#define WTS_SESSION_LOCK                   0x7
#define WTS_SESSION_UNLOCK                 0x8

#endif

#define WTSRegisterSessionNotification      DL_WTSRegisterSessionNotification
#define WTSUnRegisterSessionNotification    DL_WTSUnRegisterSessionNotification

#ifdef __cplusplus
}
#endif

#endif // _APITHK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\apithk.inc ===
!IF 0

Copyright (c) 1989-1996 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


History:
    Common ccshell makefile and cleanup 15-Apr-96 Scott Hysom (scotth)
    Created 27-Sep-94 by Bob Day (bobday)
    from template created 12-Apr-1990 by Steve Wood (stevewo)

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

CCSHELL_DIR     = $(PROJECT_ROOT)

!include $(CCSHELL_DIR)\browseui\browseui.inc

NO_BROWSER_FILE = 1

SOURCES_USED    = $(SOURCES_USED) $(CCSHELL_DIR)\browseui\browseui.inc

TARGETNAME      = apithk
TARGETPATH      = obj
TARGETTYPE      = LIBRARY

SOURCES         = ..\apithk.c \
                  ..\nt5.cpp

# We don't use a precompiled header until there are enough files to
# merit it.
#PRECOMPILED_INCLUDE = ..\priv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\atl.cpp ===
#include "priv.h"
#include "atl.h"

//ATL support
CComModule _Module;         // ATL module object

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

STDAPI_(void) AtlInit(HINSTANCE hinst)
{
    _Module.Init(ObjectMap, hinst);
}

STDAPI_(void) AtlTerm()
{
    _Module.Term();
}

STDAPI AtlGetClassObject(REFCLSID rclsid, REFIID riid, void **ppv)
{
    *ppv = NULL;
    HRESULT hr = _Module.GetClassObject(rclsid, riid, ppv);

#ifdef DEBUG
    //this object gets freed on DLL_PROCESS_DETACH, which happens AFTER the
    // mem leak check happens on exit.
    if (SUCCEEDED(hr))
    {
        _ASSERTE(_Module.m_pObjMap != NULL);
        _ATL_OBJMAP_ENTRY* pEntry = _Module.m_pObjMap;

        while (pEntry->pclsid != NULL)
        {
            if (InlineIsEqualGUID(rclsid, *pEntry->pclsid))
            {
                ASSERT(pEntry->pCF);
                break;
            }
            pEntry++;
        }
    }
#endif

    return hr;
}

STDAPI_(LONG) AtlGetLockCount()
{
    return _Module.GetLockCount();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\browseui\autocomp.cpp ===
// Copyright 1996-98 Microsoft
#include "priv.h"
#include "sccls.h"
#include "autocomp.h"
#include "itbar.h"
#include "address.h"
#include "addrlist.h"
#include "resource.h"
#include "mluisupp.h"

#include "apithk.h"

extern HRESULT CACLMRU_CreateInstance(IUnknown *punkOuter, IUnknown **ppunk, LPCOBJECTINFO poi, LPCTSTR pszMRU);

#define WZ_REGKEY_QUICKCOMPLETE         L"Software\\Microsoft\\Internet Explorer\\Toolbar\\QuickComplete"
#define WZ_DEFAULTQUICKCOMPLETE         L"http://www.%s.com"


// Statics
const static TCHAR c_szAutoDefQuickComp[]   = TEXT("%s");
const static TCHAR c_szAutoCompleteProp[]   = TEXT("CAutoComplete_This");
const static TCHAR c_szParentWindowProp[]   = TEXT("CParentWindow_This");
const static TCHAR c_szAutoSuggest[]        = TEXT("AutoSuggest Drop-Down");
const static TCHAR c_szAutoSuggestTitle[]   = TEXT("Internet Explorer");

BOOL CAutoComplete::s_fNoActivate = FALSE;
HWND CAutoComplete::s_hwndDropDown = NULL;
HHOOK CAutoComplete::s_hhookMouse = NULL;


#define MAX_QUICK_COMPLETE_STRING   64
#define LISTVIEW_COLUMN_WIDTH   30000

//
// FLAGS for dwFlags
//
#define ACF_RESET               0x00000000
#define ACF_IGNOREUPDOWN        0x00000004

#define URL_SEPARATOR_CHAR      TEXT('/')

#define DIR_SEPARATOR_CHAR      TEXT('\\')
#define DIR_SEPARATOR_STRING    TEXT("\\")


/////////////////////////////////////////////////////////////////////////////
// Line Break Character Table
//
// This was swipped from mlang.  Special break characters added for URLs
// have an "IE:" in the comment.  Note that this table must be sorted!

const WCHAR g_szBreakChars[] = {
    0x0009, // TAB
    0x0020, // SPACE
    0x0021, // IE: !
    0x0022, // IE: "
    0x0023, // IE: #
    0x0024, // IE: $
    0x0025, // IE: %
    0x0026, // IE: &
    0x0027, // IE: '
    0x0028, // LEFT PARENTHESIS
    0x0029, // RIGHT PARENTHESIS
    0x002A, // IE: *
    0x002B, // IE: +
    0x002C, // IE: ,
    0x002D, // HYPHEN
    0x002E, // IE: .
    0x002F, // IE: /
    0x003A, // IE: :
    0x003B, // IE: ;
    0x003C, // IE: <
    0x003D, // IE: =
    0x003E, // IE: >
    0x003F, // IE: ?
    0x0040, // IE: @
    0x005B, // LEFT SQUARE BRACKET
    0x005C, // IE: '\'
    0x005D, // RIGHT SQUARE BRACKET
    0x005E, // IE: ^
    0x005F, // IE: _
    0x0060, // IE:`
    0x007B, // LEFT CURLY BRACKET
    0x007C, // IE: |
    0x007D, // RIGHT CURLY BRACKET
    0x007E, // IE: ~
    0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x00AD, // OPTIONAL HYPHEN
    0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
    0x02C7, // CARON
    0x02C9, // MODIFIER LETTER MACRON
    0x055D, // ARMENIAN COMMA
    0x060C, // ARABIC COMMA
    0x2002, // EN SPACE
    0x2003, // EM SPACE
    0x2004, // THREE-PER-EM SPACE
    0x2005, // FOUR-PER-EM SPACE
    0x2006, // SIX-PER-EM SPACE
    0x2007, // FIGURE SPACE
    0x2008, // PUNCTUATION SPACE
    0x2009, // THIN SPACE
    0x200A, // HAIR SPACE
    0x200B, // ZERO WIDTH SPACE
    0x2013, // EN DASH
    0x2014, // EM DASH
    0x2016, // DOUBLE VERTICAL LINE
    0x2018, // LEFT SINGLE QUOTATION MARK
    0x201C, // LEFT DOUBLE QUOTATION MARK
    0x201D, // RIGHT DOUBLE QUOTATION MARK
    0x2022, // BULLET
    0x2025, // TWO DOT LEADER
    0x2026, // HORIZONTAL ELLIPSIS
    0x2027, // HYPHENATION POINT
    0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
    0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
    0x2045, // LEFT SQUARE BRACKET WITH QUILL
    0x2046, // RIGHT SQUARE BRACKET WITH QUILL
    0x207D, // SUPERSCRIPT LEFT PARENTHESIS
    0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
    0x208D, // SUBSCRIPT LEFT PARENTHESIS
    0x208E, // SUBSCRIPT RIGHT PARENTHESIS
    0x226A, // MUCH LESS THAN
    0x226B, // MUCH GREATER THAN
    0x2574, // BOX DRAWINGS LIGHT LEFT
    0x3001, // IDEOGRAPHIC COMMA
    0x3002, // IDEOGRAPHIC FULL STOP
    0x3003, // DITTO MARK
    0x3005, // IDEOGRAPHIC ITERATION MARK
    0x3008, // LEFT ANGLE BRACKET
    0x3009, // RIGHT ANGLE BRACKET
    0x300A, // LEFT DOUBLE ANGLE BRACKET
    0x300B, // RIGHT DOUBLE ANGLE BRACKET
    0x300C, // LEFT CORNER BRACKET
    0x300D, // RIGHT CORNER BRACKET
    0x300E, // LEFT WHITE CORNER BRACKET
    0x300F, // RIGHT WHITE CORNER BRACKET
    0x3010, // LEFT BLACK LENTICULAR BRACKET
    0x3011, // RIGHT BLACK LENTICULAR BRACKET
    0x3014, // LEFT TORTOISE SHELL BRACKET
    0x3015, // RIGHT TORTOISE SHELL BRACKET
    0x3016, // LEFT WHITE LENTICULAR BRACKET
    0x3017, // RIGHT WHITE LENTICULAR BRACKET
    0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
    0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
    0x301A, // LEFT WHITE SQUARE BRACKET
    0x301B, // RIGHT WHITE SQUARE BRACKET
    0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
    0x301E, // DOUBLE PRIME QUOTATION MARK
    0x3041, // HIRAGANA LETTER SMALL A
    0x3043, // HIRAGANA LETTER SMALL I
    0x3045, // HIRAGANA LETTER SMALL U
    0x3047, // HIRAGANA LETTER SMALL E
    0x3049, // HIRAGANA LETTER SMALL O
    0x3063, // HIRAGANA LETTER SMALL TU
    0x3083, // HIRAGANA LETTER SMALL YA
    0x3085, // HIRAGANA LETTER SMALL YU
    0x3087, // HIRAGANA LETTER SMALL YO
    0x308E, // HIRAGANA LETTER SMALL WA
    0x309B, // KATAKANA-HIRAGANA VOICED SOUND MARK
    0x309C, // KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
    0x309D, // HIRAGANA ITERATION MARK
    0x309E, // HIRAGANA VOICED ITERATION MARK
    0x30A1, // KATAKANA LETTER SMALL A
    0x30A3, // KATAKANA LETTER SMALL I
    0x30A5, // KATAKANA LETTER SMALL U
    0x30A7, // KATAKANA LETTER SMALL E
    0x30A9, // KATAKANA LETTER SMALL O
    0x30C3, // KATAKANA LETTER SMALL TU
    0x30E3, // KATAKANA LETTER SMALL YA
    0x30E5, // KATAKANA LETTER SMALL YU
    0x30E7, // KATAKANA LETTER SMALL YO
    0x30EE, // KATAKANA LETTER SMALL WA
    0x30F5, // KATAKANA LETTER SMALL KA
    0x30F6, // KATAKANA LETTER SMALL KE
    0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0x30FD, // KATAKANA ITERATION MARK
    0x30FE, // KATAKANA VOICED ITERATION MARK
    0xFD3E, // ORNATE LEFT PARENTHESIS
    0xFD3F, // ORNATE RIGHT PARENTHESIS
    0xFE30, // VERTICAL TWO DOT LEADER
    0xFE31, // VERTICAL EM DASH
    0xFE33, // VERTICAL LOW LINE
    0xFE34, // VERTICAL WAVY LOW LINE
    0xFE35, // PRESENTATION FORM FOR VERTICAL LEFT PARENTHESIS
    0xFE36, // PRESENTATION FORM FOR VERTICAL RIGHT PARENTHESIS
    0xFE37, // PRESENTATION FORM FOR VERTICAL LEFT CURLY BRACKET
    0xFE38, // PRESENTATION FORM FOR VERTICAL RIGHT CURLY BRACKET
    0xFE39, // PRESENTATION FORM FOR VERTICAL LEFT TORTOISE SHELL BRACKET
    0xFE3A, // PRESENTATION FORM FOR VERTICAL RIGHT TORTOISE SHELL BRACKET
    0xFE3B, // PRESENTATION FORM FOR VERTICAL LEFT BLACK LENTICULAR BRACKET
    0xFE3C, // PRESENTATION FORM FOR VERTICAL RIGHT BLACK LENTICULAR BRACKET
    0xFE3D, // PRESENTATION FORM FOR VERTICAL LEFT DOUBLE ANGLE BRACKET
    0xFE3E, // PRESENTATION FORM FOR VERTICAL RIGHT DOUBLE ANGLE BRACKET
    0xFE3F, // PRESENTATION FORM FOR VERTICAL LEFT ANGLE BRACKET
    0xFE40, // PRESENTATION FORM FOR VERTICAL RIGHT ANGLE BRACKET
    0xFE41, // PRESENTATION FORM FOR VERTICAL LEFT CORNER BRACKET
    0xFE42, // PRESENTATION FORM FOR VERTICAL RIGHT CORNER BRACKET
    0xFE43, // PRESENTATION FORM FOR VERTICAL LEFT WHITE CORNER BRACKET
    0xFE44, // PRESENTATION FORM FOR VERTICAL RIGHT WHITE CORNER BRACKET
    0xFE4F, // WAVY LOW LINE
    0xFE50, // SMALL COMMA
    0xFE51, // SMALL IDEOGRAPHIC COMMA
    0xFE59, // SMALL LEFT PARENTHESIS
    0xFE5A, // SMALL RIGHT PARENTHESIS
    0xFE5B, // SMALL LEFT CURLY BRACKET
    0xFE5C, // SMALL RIGHT CURLY BRACKET
    0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
    0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
    0xFF08, // FULLWIDTH LEFT PARENTHESIS
    0xFF09, // FULLWIDTH RIGHT PARENTHESIS
    0xFF0C, // FULLWIDTH COMMA
    0xFF0E, // FULLWIDTH FULL STOP
    0xFF1C, // FULLWIDTH LESS-THAN SIGN
    0xFF1E, // FULLWIDTH GREATER-THAN SIGN
    0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
    0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
    0xFF40, // FULLWIDTH GRAVE ACCENT
    0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
    0xFF5C, // FULLWIDTH VERTICAL LINE
    0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
    0xFF5E, // FULLWIDTH TILDE
    0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
    0xFF62, // HALFWIDTH LEFT CORNER BRACKET
    0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
    0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA
    0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
    0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
    0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
    0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
    0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
    0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
    0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
    0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
    0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
    0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
    0xFF9E, // HALFWIDTH KATAKANA VOICED SOUND MARK
    0xFF9F, // HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
    0xFFE9, // HALFWIDTH LEFTWARDS ARROW
    0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
};

/*
//
// AutoComplete Common Functions / Structures
//
const struct {
    UINT    idMenu;
    UINT    idCmd;
} MenuToMessageId[] = {
    { IDM_AC_UNDO, WM_UNDO },
    { IDM_AC_CUT,  WM_CUT },
    { IDM_AC_COPY, WM_COPY },
    { IDM_AC_PASTE, WM_PASTE }
};
*/

//+-------------------------------------------------------------------------
// IUnknown methods
//--------------------------------------------------------------------------
HRESULT CAutoComplete::QueryInterface(REFIID riid, void **ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IAutoComplete) ||
        IsEqualIID(riid, IID_IAutoComplete2))
    {
        *ppvObj = SAFECAST(this, IAutoComplete2*);
    }
    else if (IsEqualIID(riid, IID_IAutoCompleteDropDown))
    {
        *ppvObj = SAFECAST(this, IAutoCompleteDropDown*);
    }
    else if (IsEqualIID(riid, IID_IEnumString))
    {
        *ppvObj = SAFECAST(this, IEnumString*);
    }
    else
    {
        return _DefQueryInterface(riid, ppvObj);
    }

    AddRef();
    return S_OK;
}

ULONG CAutoComplete::AddRef(void)
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CAutoComplete::Release(void)
{
    ASSERT( 0 != m_cRef );
    ULONG cRef = InterlockedDecrement(&m_cRef);
    if ( 0 == cRef )
    {
        delete this;
    }
    TraceMsg(AC_GENERAL, "CAutoComplete::Release() --- cRef = %i", cRef);
    return cRef;
}

/* IAutoComplete methods */
//+-------------------------------------------------------------------------
//  This object can be Inited in two ways.  This function will init it in
//  the first way, which works as follows:
//
//  1. The caller called CoInitialize or OleInitialize() and the corresponding
//     uninit will not be called until the control we are subclassing and
//     our selfs are long gone.
//  2. The caller calls us on their main thread and we create and destroy
//     the background thread as needed.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Init
(
    HWND hwndEdit,              // control to be subclassed
    IUnknown *punkACL,          // autocomplete list
    LPCOLESTR pwszRegKeyPath,   // reg location where ctrl-enter completion is stored stored
    LPCOLESTR pwszQuickComplete // default format string for ctrl-enter completion
)
{
    HRESULT hr = S_OK;

    TraceMsg(AC_GENERAL, "CAutoComplete::Init(hwndEdit=0x%x, punkACL = 0x%x, pwszRegKeyPath = 0x%x, pwszQuickComplete = 0x%x)",
        hwndEdit, punkACL, pwszRegKeyPath, pwszQuickComplete);

#ifdef DEBUG
    // Ensure that the Line Break Character Table is ordered
    WCHAR c = g_szBreakChars[0];
    for (int i = 1; i < ARRAYSIZE(g_szBreakChars); ++i)
    {
        ASSERT(c < g_szBreakChars[i]);
        c = g_szBreakChars[i];
    }
#endif

    if (m_hwndEdit != NULL)
    {
        // Can currently only be initialized once
        ASSERT(FALSE);
        return E_FAIL;
    }

    m_hwndEdit = hwndEdit;


    // Add our custom word-break callback so that we recognize URL delimitors when
    // ctrl-arrowing around.
    //
    // There is a bug with how USER handles WH_CALLWNDPROC global hooks in Win95 that
    // causes us to blow up if one is installed and a wordbreakproc is set.  Thus,
    // if an app is running that has one of these hooks installed (intellipoint 1.1 etc.) then
    // if we install our wordbreakproc the app will fault when the proc is called.  There
    // does not appear to be any way for us to work around it since USER's thunking code
    // trashes the stack so this API is disabled for Win95.
    //
    m_fEditControlUnicode = g_fRunningOnNT && IsWindowUnicode(m_hwndEdit);
    if (m_fEditControlUnicode)
    {
        m_oldEditWordBreakProc = (EDITWORDBREAKPROC)SendMessage(m_hwndEdit, EM_GETWORDBREAKPROC, 0, 0);
        SendMessage(m_hwndEdit, EM_SETWORDBREAKPROC, 0, (DWORD_PTR)EditWordBreakProcW);
    }

    //
    // bug 81414 : To avoid clashing with app messages used by the edit window, we
    // use registered messages.
    //
    m_uMsgSearchComplete  = RegisterWindowMessageA("AC_SearchComplete");
    m_uMsgItemActivate    = RegisterWindowMessageA("AC_ItemActivate");

    if (m_uMsgSearchComplete == 0)
    {
        m_uMsgSearchComplete = WM_APP + 300;
    }
    if (m_uMsgItemActivate == 0)
    {
        m_uMsgItemActivate   = WM_APP + 301;
    }

    _SetQuickCompleteStrings(pwszRegKeyPath, pwszQuickComplete);

    // IEnumString required
    ASSERT(m_pes == NULL);
    EVAL(SUCCEEDED(punkACL->QueryInterface(IID_IEnumString, (void **)&m_pes)));

    // IACList optional
    ASSERT(m_pacl == NULL);
    punkACL->QueryInterface(IID_IACList, (void **)&m_pacl);

    AddRef();       // Hold on to a ref for our Subclass.

    // Initial creation should have failed if the thread object was not allocated!
    ASSERT(m_pThread);
    m_pThread->Init(m_pes, m_pacl);

    // subclass the edit window
    SetWindowSubclass(m_hwndEdit, &s_EditWndProc, 0, (DWORD_PTR)this);

//#define TEST_SETFONT
#ifdef TEST_SETFONT
    HFONT h = CreateFont(20, 5, 0, 0, FW_BOLD, TRUE, FALSE, FALSE, ANSI_CHARSET,
                                 OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
                                 FF_ROMAN, NULL);
    SendMessage(m_hwndEdit, WM_SETFONT, (WPARAM)h, TRUE);
#endif

    // See what autocomplete features are enabled
    _SeeWhatsEnabled();


    // See if hwndEdit is part of a combobox
    HWND hwndParent = GetParent(m_hwndEdit);
    WCHAR szClass[30];
    int nLen = GetClassName(hwndParent, szClass, ARRAYSIZE(szClass));
    if (nLen != 0 &&
        (StrCmpI(szClass, L"combobox") == 0 || StrCmpI(szClass, L"comboboxex") == 0))
    {
        m_hwndCombo = hwndParent;
    }

    // If we've already got focus, then we need to call GotFocus...
    if (GetFocus() == hwndEdit)
    {
        m_pThread->GotFocus();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Checks to see if autoappend or autosuggest freatures are enabled
//--------------------------------------------------------------------------
void CAutoComplete::_SeeWhatsEnabled()
{
#ifdef ALLOW_ALWAYS_DROP_UP
    m_fAlwaysDropUp = SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE,
                            TEXT("AlwaysDropUp"), FALSE, /*default:*/FALSE);
#endif

    // If autosuggest was just enabled, create the dropdown window
    if (_IsAutoSuggestEnabled() && NULL == m_hwndDropDown)
    {
        // Create the dropdown Window
        WNDCLASS wc = {0};

        wc.lpfnWndProc      = s_DropDownWndProc;
        wc.cbWndExtra       = SIZEOF(CAutoComplete*);
        wc.hInstance        = HINST_THISDLL;
        wc.hCursor          = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground    = (HBRUSH)(COLOR_WINDOW+1);
        wc.lpszClassName    = c_szAutoSuggestClass;

        SHRegisterClass(&wc);

        DWORD dwExStyle =  WS_EX_TOPMOST | WS_EX_TOOLWINDOW | WS_EX_NOPARENTNOTIFY;
        if(_IsRTLReadingEnabled())
        {
            dwExStyle |= WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR;
        }
#ifdef AC_TRANSLUCENCY
        if (g_bRunOnNT5 && g_fIE)
        {
            dwExStyle |= WS_EX_LAYERED;
        }
#endif

        // The dropdown holds a ref on this object
        AddRef();
        m_hwndDropDown = CreateWindowEx(dwExStyle,
                                        c_szAutoSuggestClass,
                                        c_szAutoSuggestTitle,   // GPF dialog is picking up this name!
                                        WS_POPUP | WS_BORDER | WS_CLIPCHILDREN,
                                        0, 0, 100, 100,
                                        NULL, NULL, HINST_THISDLL, this);

        if (m_hwndDropDown)
        {
#ifdef AC_TRANSLUCENCY
            if (g_fIE)
            {
                SetLayeredWindowAttributes(m_hwndDropDown, 
                                           0,
                                           230, 
                                           LWA_ALPHA);
            }
#endif
            m_fDropDownResized = FALSE;
        }
        else
        {
            Release();
        }
    }
    else if (!_IsAutoSuggestEnabled() && NULL != m_hwndDropDown)
    {
        // We don't need the dropdown Window.
        if (m_hwndList)
        {
            DestroyWindow(m_hwndList);
        }
        DestroyWindow(m_hwndDropDown);
    }
}

//+-------------------------------------------------------------------------
// Returns TRUE if autocomplete is currently enabled
//--------------------------------------------------------------------------
BOOL CAutoComplete::IsEnabled()
{
    BOOL fRet;

    //
    // If we have not used the new IAutoComplete2 interface, we revert
    // to the old IE4 global registry setting
    //
    if (m_dwOptions & ACO_UNINITIALIZED)
    {
        fRet = SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE,
                            REGSTR_VAL_USEAUTOCOMPLETE, FALSE, TRUE);
    }
    else
    {
        fRet = (m_dwOptions & (ACO_AUTOAPPEND | ACO_AUTOSUGGEST));
    }
    return fRet;
}

//+-------------------------------------------------------------------------
// Enables/disables the up down arrow for autocomplete.  Used by comboboxes
// to disable arrow keys when the combo box is dropped. (This function is
// now redundent because we check to see of the combo is dropped.)
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Enable(BOOL fEnable)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::Enable(0x%x)", fEnable);

    HRESULT hr = (m_dwFlags & ACF_IGNOREUPDOWN) ? S_FALSE : S_OK;

    if (fEnable)
        m_dwFlags &= ~ACF_IGNOREUPDOWN;
    else
        m_dwFlags |= ACF_IGNOREUPDOWN;

    return hr;
}

/* IAutocomplete2 methods */
//+-------------------------------------------------------------------------
// Enables/disables various autocomplete features (see ACO_* flags)
//--------------------------------------------------------------------------
HRESULT CAutoComplete::SetOptions(DWORD dwOptions)
{
    m_dwOptions = dwOptions;
    _SeeWhatsEnabled();
    return S_OK;
}

//+-------------------------------------------------------------------------
// Returns the current option settings
//--------------------------------------------------------------------------
HRESULT CAutoComplete::GetOptions(DWORD* pdwOptions)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwOptions)
    {
        *pdwOptions = m_dwOptions;
        hr = S_OK;
    }

    return hr;
}

/* IAutocompleteDropDown methods */
//+-------------------------------------------------------------------------
// Returns the current dropdown status
//--------------------------------------------------------------------------
HRESULT CAutoComplete::GetDropDownStatus(DWORD *pdwFlags, LPWSTR *ppwszString)
{
    if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
    {
        if (pdwFlags)
        {
            *pdwFlags = ACDD_VISIBLE;
        }

        if (ppwszString)
        {
            *ppwszString=NULL;

            if (m_hwndList)
            {
                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (iCurSel != -1)
                {
                    WCHAR szBuf[MAX_URL_STRING];
                    _GetItem(iCurSel, szBuf, ARRAYSIZE(szBuf), FALSE);

                    *ppwszString = (LPWSTR) CoTaskMemAlloc((lstrlenW(szBuf)+1)*sizeof(WCHAR));
                    if (*ppwszString)
                    {
                        StringCchCopy(*ppwszString, lstrlenW(szBuf) + 1, szBuf);
                    }
                }
            }
        }
    }
    else
    {
        if (pdwFlags)
        {
            *pdwFlags = 0;
        }

        if (ppwszString)
        {
            *ppwszString = NULL;
        }
    }

    return S_OK;
}

HRESULT CAutoComplete::ResetEnumerator()
{
    _StopSearch();
    _ResetSearch();
    _FreeDPAPtrs(m_hdpa);
    m_hdpa = NULL;

    // If the dropdown is currently visible, re-search the IEnumString
    //  and show the dropdown. Otherwise wait for user input.
    if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
    {
        _StartCompletion(FALSE, TRUE);
    }

    return S_OK;
}

/* IEnumString methods */
//+-------------------------------------------------------------------------
// Resets the IEnumString functionality exposed for external users.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Reset()
{
    HRESULT hr = E_FAIL;

    if (!m_szEnumString)        // If we needed it once, we will most likely continue to need it.
        m_szEnumString = (LPTSTR) LocalAlloc(LPTR, MAX_URL_STRING * SIZEOF(TCHAR));

    if (!m_szEnumString)
        return E_OUTOFMEMORY;

    GetWindowText(m_hwndEdit, m_szEnumString, MAX_URL_STRING);
    if (m_pesExtern)
        hr = m_pesExtern->Reset();
    else
    {
        hr = m_pes->Clone(&m_pesExtern);
        if (SUCCEEDED(hr))
            hr = m_pesExtern->Reset();
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Returns the next BSTR from the autocomplete enumeration.
//
// For consistant results, the caller should not allow the AutoComplete text
// to change between one call to Next() and another call to Next().
// AutoComplete text should change only before Reset() is called.
//--------------------------------------------------------------------------
HRESULT CAutoComplete::Next
(
    ULONG celt,         // number items to fetch, needs to be 1
    LPOLESTR *rgelt,    // returned BSTR, caller must free
    ULONG *pceltFetched // number of items returned
)
{
    HRESULT hr = S_FALSE;
    LPOLESTR pwszUrl;
    ULONG cFetched;

    // Pre-init in case of error
    if (rgelt)
        *rgelt = NULL;
    if (pceltFetched)
        *pceltFetched = 0;

    if (!EVAL(rgelt) || (!EVAL(pceltFetched)) || (!EVAL(1 == celt)) || !EVAL(m_pesExtern))
        return E_INVALIDARG;

    while (S_OK == (hr = m_pesExtern->Next(1, &pwszUrl, &cFetched)))
    {
        if (!StrCmpNI(m_szEnumString, pwszUrl, lstrlen(m_szEnumString)))
        {
            TraceMsg(TF_BAND|TF_GENERAL, "CAutoComplete: Next(). AutoSearch Failed URL=%s.", pwszUrl);
            break;
        }
        else
        {
            // If the string can't be added to our list, we will free it.
            TraceMsg(TF_BAND|TF_GENERAL, "CAutoComplete: Next(). AutoSearch Match URL=%s.", pwszUrl);
            CoTaskMemFree(pwszUrl);
        }
    }

    if (S_OK == hr)
    {
        *rgelt = (LPOLESTR)pwszUrl;
        *pceltFetched = 1;  // We will always only fetch one.
    }

    return hr;
}

CAutoComplete::CAutoComplete() : m_cRef(1)
{
    DllAddRef();
    TraceMsg(AC_GENERAL, "CAutoComplete::CAutoComplete()");

    // This class requires that this COM object be allocated in Zero INITed
    // memory.  If the asserts below go off, then this was violated.
    ASSERT(!m_dwFlags);
    ASSERT(!m_hwndEdit);
    ASSERT(!m_pszCurrent);
    ASSERT(!m_iCurrent);
    ASSERT(!m_dwLastSearchFlags);
    ASSERT(!m_pes);
    ASSERT(!m_pacl);
    ASSERT(!m_pesExtern);
    ASSERT(!m_szEnumString);
    ASSERT(!m_pThread);

    m_dwOptions = ACO_UNINITIALIZED;
    m_hfontListView = NULL;
}

CAutoComplete::~CAutoComplete()
{
    TraceMsg(AC_GENERAL, "CAutoComplete::~CAutoComplete()");

    ASSERT(m_hwndDropDown == NULL)

    SAFERELEASE(m_pes);
    SAFERELEASE(m_pacl);
    SAFERELEASE(m_pesExtern);

    SetStr(&m_pszCurrent, NULL);

    if (m_szEnumString)
        LocalFree(m_szEnumString);

    if (m_hdpaSortIndex)
    {
        // Note that this list pointed to items in m_hdpa, so we don't need
        // to free the items pointed to by this list.
        DPA_Destroy(m_hdpaSortIndex);
        m_hdpaSortIndex = NULL;
    }

    _FreeDPAPtrs(m_hdpa);

    if (m_pThread)
    {
        m_pThread->SyncShutDownBGThread();
        SAFERELEASE(m_pThread);
    }

    DllRelease();
}

STDMETHODIMP CAutoComplete::get_accName(VARIANT varChild, BSTR  *pszName)
{
    HRESULT hr;

    if (varChild.vt == VT_I4)
    {
        if (varChild.lVal > 0)
        {
            WCHAR szBuf[MAX_URL_STRING];

            _GetItem(varChild.lVal - 1, szBuf, ARRAYSIZE(szBuf), TRUE);
            *pszName = SysAllocString(szBuf);
        }
        else
        {
            *pszName = NULL;
        }
        hr = S_OK;
    }
    else
    {
        hr = E_UNEXPECTED;
    }

    return hr;
}

//+-------------------------------------------------------------------------
// Private initialization
//--------------------------------------------------------------------------
BOOL CAutoComplete::_Init()
{
    m_pThread = new CACThread(*this);

    return (NULL != m_pThread);
}

//+-------------------------------------------------------------------------
// Creates and instance of CAutoComplete
//--------------------------------------------------------------------------
HRESULT CAutoComplete_CreateInstance(IUnknown* pUnkOuter, IUnknown** ppunk, LPCOBJECTINFO poi)
{
    // Note - Aggregation checking is handled in class factory

    *ppunk = NULL;
    CAutoComplete* p = new CAutoComplete();
    if (p)
    {
        if (p->_Init())
        {
            *ppunk = SAFECAST(p, IAutoComplete *);
            return S_OK;
        }

        delete p;
    }

    return E_OUTOFMEMORY;
}

//+-------------------------------------------------------------------------
// Helper function to add default autocomplete functionality to and edit
// window.
//--------------------------------------------------------------------------
HRESULT SHUseDefaultAutoComplete
(
    HWND hwndEdit,
    IBrowserService * pbs,          IN  OPTIONAL
    IAutoComplete2 ** ppac,         OUT OPTIONAL
    IShellService ** ppssACLISF,    OUT OPTIONAL
    BOOL fUseCMDMRU
)
{
    HRESULT hr;
    IUnknown * punkACLMulti;

    if (ppac)
        *ppac = NULL;
    if (ppssACLISF)
        *ppssACLISF = NULL;

    hr = CoCreateInstance(CLSID_ACLMulti, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLMulti);
    if (SUCCEEDED(hr))
    {

        IObjMgr * pomMulti;

        hr = punkACLMulti->QueryInterface(IID_IObjMgr, (LPVOID *)&pomMulti);
        if (SUCCEEDED(hr))
        {
            BOOL fReady = FALSE;   // Fail only if all we are not able to create at least one list.

            // ADD The MRU List
            IUnknown * punkACLMRU;

            //  MRU for run dialog no longer adds URL MRU automatically
            //   so we have to add it ourselves
            if (fUseCMDMRU)
            {
                hr = CACLMRU_CreateInstance(NULL, &punkACLMRU, NULL, SZ_REGKEY_TYPEDCMDMRU);
                if (SUCCEEDED(hr))
                {
                    pomMulti->Append(punkACLMRU);
                    punkACLMRU->Release();
                    fReady = TRUE;
                }
            }

            hr = CACLMRU_CreateInstance(NULL, &punkACLMRU, NULL, SZ_REGKEY_TYPEDURLMRU);
            if (SUCCEEDED(hr))
            {
                pomMulti->Append(punkACLMRU);
                punkACLMRU->Release();
                fReady = TRUE;
            }

            // ADD The History List
            IUnknown * punkACLHist;
            hr = CoCreateInstance(CLSID_ACLHistory, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLHist);
            if (SUCCEEDED(hr))
            {
                pomMulti->Append(punkACLHist);
                punkACLHist->Release();
                fReady = TRUE;
            }

            // ADD The ISF List
            IUnknown * punkACLISF;
            hr = CoCreateInstance(CLSID_ACListISF, NULL, CLSCTX_INPROC_SERVER, IID_IUnknown, (void **)&punkACLISF);
            if (SUCCEEDED(hr))
            {
                // We need to give the ISF AutoComplete List a pointer to the IBrowserService
                // so it can retrieve the current browser location to AutoComplete correctly.
                IShellService * pss;
                hr = punkACLISF->QueryInterface(IID_IShellService, (LPVOID *)&pss);
                if (SUCCEEDED(hr))
                {
                    if (pbs)
                        pss->SetOwner(pbs);

                    if (ppssACLISF)
                        *ppssACLISF = pss;
                    else
                        pss->Release();
                }

                //
                // Set options
                //
                IACList2* pacl;
                if (SUCCEEDED(punkACLISF->QueryInterface(IID_IACList2, (LPVOID *)&pacl)))
                {
                    // Specify directories to search
                    pacl->SetOptions(ACLO_CURRENTDIR | ACLO_FAVORITES | ACLO_MYCOMPUTER | ACLO_DESKTOP);
                    pacl->Release();
                }

                pomMulti->Append(punkACLISF);
                punkACLISF->Release();
                fReady = TRUE;
            }

            if (fReady)
            {
                IAutoComplete2 * pac;

                // Create the AutoComplete Object
                hr = CoCreateInstance(CLSID_AutoComplete, NULL, CLSCTX_INPROC_SERVER, IID_IAutoComplete2, (void **)&pac);
                if (SUCCEEDED(hr))
                {
                    // Load the quick complete string.
                    WCHAR szQuickComplete[50]; // US string is 17 characters, 50 should be plenty without blowing the stack

                    MLLoadString(IDS_QUICKCOMPLETE, szQuickComplete, ARRAYSIZE(szQuickComplete));

                    hr = pac->Init(hwndEdit, punkACLMulti, WZ_REGKEY_QUICKCOMPLETE, szQuickComplete);
                    if (ppac)
                        *ppac = pac;
                    else
                        pac->Release();
                }
            }

            pomMulti->Release();
        }
        punkACLMulti->Release();
    }

    return hr;
}

/* Private functions */

//+-------------------------------------------------------------------------
// Removes anything that we appended to the edit text
//--------------------------------------------------------------------------
void CAutoComplete::_RemoveCompletion()
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_RemoveCompletion()");
    if (m_fAppended)
    {
        // Remove any highlighted text that we displayed
        Edit_ReplaceSel(m_hwndEdit, TEXT(""));
        m_fAppended = FALSE;
    }
}

//+-------------------------------------------------------------------------
// Updates the text in the edit control
//--------------------------------------------------------------------------
void CAutoComplete::_SetEditText(LPCWSTR psz)
{
    //
    // We set a flag so that we can distinguish between us setting the text
    // and someone else doing it.  If someone else sets the text we hide our
    // dropdown.
    //
    m_fSettingText = TRUE;

    // Don't display our special wildcard search string
    if (psz[0] == CH_WILDCARD)
    {
        Edit_SetText(m_hwndEdit, L"");
    }
    else
    {
        Edit_SetText(m_hwndEdit, psz);
    }

    m_fSettingText = FALSE;
}

//+-------------------------------------------------------------------------
// Removed anything that we appended to the edit text and then updates
// m_pszCurrent with the current string.
//--------------------------------------------------------------------------
void CAutoComplete::_GetEditText(void)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_GetEditText()");

    _RemoveCompletion();  // remove anything we added

    int iCurrent = GetWindowTextLength(m_hwndEdit);

    //
    // If the current buffer is too small, delete it.
    //
    if (m_pszCurrent &&
         LocalSize(m_pszCurrent) <= (UINT)(iCurrent + 1) * sizeof(TCHAR))
    {
        SetStr(&m_pszCurrent, NULL);
    }

    //
    // If there is no current buffer, try to allocate one
    // with some room to grow.
    //
    if (!m_pszCurrent)
    {
        m_pszCurrent = (LPTSTR)LocalAlloc(LPTR, (iCurrent + (MAX_URL_STRING / 2)) * SIZEOF(TCHAR));
    }

    //
    // If we have a current buffer, get the text.
    //
    if (m_pszCurrent)
    {
        if (!GetWindowText(m_hwndEdit, m_pszCurrent, iCurrent + 1))
        {
            *m_pszCurrent = L'\0';
        }

        // On win9x GetWindowTextLength can return more than the # of characters
        m_iCurrent = lstrlen(m_pszCurrent);
    }
    else
    {
        m_iCurrent = 0;
    }
}

//+-------------------------------------------------------------------------
// Updates the text in the edit control
//--------------------------------------------------------------------------
void CAutoComplete::_UpdateText
(
    int iStartSel,      // start location for selected
    int iEndSel,        // end location of selected text
    LPCTSTR pszCurrent, // unselected text
    LPCTSTR pszNew      // autocompleted (selected) text
)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_UpdateText(iStart=%i;  iEndSel = %i,  pszCurrent=>%s<,  pszNew=>%s<)",
        iStartSel, iEndSel, (pszCurrent ? pszCurrent : TEXT("(null)")), (pszNew ? pszNew : TEXT("(null)")));

    //
    // Restore the old text.
    //
    _SetEditText(pszCurrent);

    //
    // Put the cursor at the insertion point.
    //
    Edit_SetSel(m_hwndEdit, iStartSel, iStartSel);

    //
    // Insert the new text.
    //
    Edit_ReplaceSel(m_hwndEdit, pszNew);

    //
    // Select the newly added text.
    //
    Edit_SetSel(m_hwndEdit, iStartSel, iEndSel);
}

//+-------------------------------------------------------------------------
// If pwszQuickComplete is NULL, we will use our internal default.
// pwszRegKeyValue can be NULL indicating that there is not a key.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_SetQuickCompleteStrings(LPCOLESTR pwszRegKeyPath, LPCOLESTR pwszQuickComplete)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_SetQuickCompleteStrings(pwszRegKeyPath=0x%x, pwszQuickComplete = 0x%x)",
        pwszRegKeyPath, pwszQuickComplete);

    if (pwszRegKeyPath)
    {
        StringCchCopy(m_szRegKeyPath, ARRAYSIZE(m_szRegKeyPath), pwszRegKeyPath);
    }
    else
    {
        // can be empty
        m_szRegKeyPath[0] = TEXT('\0');
    }

    if (pwszQuickComplete)
    {
        StringCchCopy(m_szQuickComplete, ARRAYSIZE(m_szQuickComplete), pwszQuickComplete);
    }
    else
    {
        // use default value
        StringCchCopy(m_szQuickComplete,  ARRAYSIZE(m_szQuickComplete), c_szAutoDefQuickComp);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
// Formats the current contents of the edit box with the appropriate prefix
// and endfix and returns the completed string.
//--------------------------------------------------------------------------
LPTSTR CAutoComplete::_QuickEnter()
{
    //
    // If they shift-enter, then do the favorite pre/post-fix.
    //
    TCHAR  szFormat[MAX_QUICK_COMPLETE_STRING];
    TCHAR  szNewText[MAX_URL_STRING];
    int    iLen;

    TraceMsg(AC_GENERAL, "CAutoComplete::_QuickEnter()");

    if (NULL == m_pszCurrent)
    {
        return NULL;
    }

    StringCchCopy(szFormat,  ARRAYSIZE(szFormat), m_szQuickComplete);
    DWORD cb = sizeof(szFormat);
    SHGetValue(HKEY_CURRENT_USER, m_szRegKeyPath, TEXT("QuickComplete"), NULL, &szFormat, &cb);

    //
    //  Remove preceeding and trailing white space
    //
    PathRemoveBlanks(m_pszCurrent);

    //
    // Make sure we don't GPF.
    //
    iLen = lstrlen(m_pszCurrent) + lstrlen(szFormat);
    if (iLen < ARRAYSIZE(szNewText))
    {
        // If the quick complete is already present, don't add it again
        LPWSTR pszInsertion = StrStrI(szFormat, L"%s");
        LPWSTR pszFormat = szFormat;
        if (pszInsertion)
        {
            // If prefix is already present, don't add it again.
            // (we could improve this to only add parts of the predfix that are missing)
            int iInsertion = (int)(pszInsertion - pszFormat);
            if (iInsertion == 0 || StrCmpNI(pszFormat, m_pszCurrent, iInsertion) == 0)
            {
                // Skip over prefix
                pszFormat = pszInsertion;
            }

            // If postfix is  already present, don't add it again.
            LPWSTR pszPostFix = pszInsertion + ARRAYSIZE(L"%s") - 1;
            int cchCurrent = lstrlen(m_pszCurrent);
            int cchPostFix = lstrlen(pszPostFix);
            if (cchPostFix > 0 && cchPostFix < cchCurrent &&
                StrCmpI(m_pszCurrent + (cchCurrent - cchPostFix), pszPostFix) == 0)
            {
                // Lop off postfix
                *pszPostFix = 0;
            }
        }

        StringCchPrintf(szNewText, ARRAYSIZE(szNewText), pszFormat, m_pszCurrent);

        SetStr(&m_pszCurrent, szNewText);
    }

    return m_pszCurrent;
}

BOOL CAutoComplete::_ResetSearch(void)
{
    TraceMsg(AC_GENERAL, "CAutoComplete::_ResetSearch()");

    m_dwFlags               = ACF_RESET;
    return TRUE;
}

//+-------------------------------------------------------------------------
// Returns TRUE if the char is a forward or backackwards slash
//--------------------------------------------------------------------------
BOOL CAutoComplete::_IsWhack(TCHAR ch)
{
    return (ch == TEXT('/')) || (ch == TEXT('\\'));
}


//+-------------------------------------------------------------------------
// Returns TRUE if the string points to a character used to separate words
//--------------------------------------------------------------------------
BOOL CAutoComplete::_IsBreakChar(WCHAR wch)
{
    // Do a binary search in our table of break characters
    int iMin = 0;
    int iMax = ARRAYSIZE(g_szBreakChars) - 1;

    while (iMax - iMin >= 2)
    {
        int iTry = (iMax + iMin + 1) / 2;
        if (wch < g_szBreakChars[iTry])
            iMax = iTry;
        else if  (wch > g_szBreakChars[iTry])
            iMin = iTry;
        else
            return TRUE;
    }

    return (wch == g_szBreakChars[iMin] || wch == g_szBreakChars[iMax]);
}

//+-------------------------------------------------------------------------
// Returns TRUE if we want to append to the current edit box contents
//--------------------------------------------------------------------------
BOOL CAutoComplete::_WantToAppendResults()
{
    //
    // Users get annoyed if we append real text after a
    // slash, because they type "c:\" and we complete
    // it to "c:\windows" when they aren't looking.
    //
    // Also, it's annoying to have "\" autocompleted to "\\"
    //
    return (m_pszCurrent &&
            (!(_IsWhack(m_pszCurrent[0]) && m_pszCurrent[1] == NULL) &&
             !_IsWhack(m_pszCurrent[lstrlen(m_pszCurrent)-1])));
}


//+-------------------------------------------------------------------------
// Callback routine used by the edit window to determine where to break
// words.  We install this custom callback dor the ctl arrow keys
// recognize our break characters.
//--------------------------------------------------------------------------
int CALLBACK CAutoComplete::EditWordBreakProcW
(
    LPWSTR pszEditText, // pointer to edit text
    int ichCurrent,     // index of starting point
    int cch,            // length in characters of edit text
    int code            // action to take
)
{
    LPWSTR psz = pszEditText + ichCurrent;
    int iIndex;
    BOOL fFoundNonDelimiter = FALSE;
    static BOOL fRight = FALSE;  // hack due to bug in USER

    switch (code)
    {
        case WB_ISDELIMITER:
            fRight = TRUE;
            // Simple case - is the current character a delimiter?
            iIndex = (int)_IsBreakChar(*psz);
            break;

        case WB_LEFT:
            // Move to the left to find the first delimiter.  If we are
            // currently at a delimiter, then skip delimiters until we
            // find the first non-delimiter, then start from there.
            //
            // Special case for fRight - if we are currently at a delimiter
            // then just return the current word!
            while ((psz = CharPrev(pszEditText, psz)) != pszEditText)
            {
                if (_IsBreakChar(*psz))
                {
                    if (fRight || fFoundNonDelimiter)
                        break;
                }
                else
                {
                    fFoundNonDelimiter = TRUE;
                    fRight = FALSE;
                }
            }
            iIndex = (int)(psz - pszEditText);

            // We are currently pointing at the delimiter, next character
            // is the beginning of the next word.
            if (iIndex > 0 && iIndex < cch)
                iIndex++;

            break;

        case WB_RIGHT:
            fRight = FALSE;

            // If we are not at a delimiter, then skip to the right until
            // we find the first delimiter.  If we started at a delimiter, or
            // we have just finished scanning to the first delimiter, then
            // skip all delimiters until we find the first non delimiter.
            //
            // Careful - the string passed in to us may not be NULL terminated!
            fFoundNonDelimiter = !_IsBreakChar(*psz);
            if (psz != (pszEditText + cch))
            {
                while ((psz = CharNext(psz)) != (pszEditText + cch))
                {
                    if (_IsBreakChar(*psz))
                    {
                        fFoundNonDelimiter = FALSE;
                    }
                    else
                    {
                        if (!fFoundNonDelimiter)
                            break;
                    }
                }
            }
            // We are currently pointing at the next word.
            iIndex = (int) (psz - pszEditText);
            break;

        default:
            iIndex = 0;
            break;
    }

    return iIndex;
}

//+-------------------------------------------------------------------------
// Returns the index of the next or previous break character in m_pszCurrent
//--------------------------------------------------------------------------
int CAutoComplete::_JumpToNextBreak
(
    int iLoc,       // current location
    DWORD dwFlags   // direction (WB_RIGHT or WB_LEFT)
)
{
    return EditWordBreakProcW(m_pszCurrent, iLoc, lstrlen(m_pszCurrent), dwFlags);
}

//+-------------------------------------------------------------------------
// Handles Horizontal cursor movement.  Returns TRUE if the message should
// passed on to the OS.  Note that we only call this on win9x.  On NT we
// use EM_SETWORDBREAKPROC to set a callback instead because it sets the
// caret correctly. This callback can crash on win9x.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_CursorMovement
(
    WPARAM wParam   // virtual key data from WM_KEYDOWN
)
{
    BOOL  fShift, fControl;
    DWORD dwKey = (DWORD)wParam;
    int iStart, iEnd;

    TraceMsg(AC_GENERAL, "CAutoComplete::_CursorMovement(wParam = 0x%x)",
        wParam);

    fShift   = (0 > GetKeyState(VK_SHIFT)) ;
    fControl = (0 > GetKeyState(VK_CONTROL));

    // We don't do anything special unless the CTRL
    // key is down so we don't want to mess up arrowing around
    // UNICODE character clusters. (INDIC o+d+j+d+k+w)
    if (!fControl)
        return TRUE;   // let OS handle because of UNICODE char clusters


    // get the current selection
    SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);

    // the user is editting the text, so this is now invalid.
    m_dwFlags = ACF_RESET;

    _GetEditText();
    if (!m_pszCurrent)
        return TRUE;    // we didn't handle it... let the default wndproc try

    //  Determine the previous selection direction
    int dwSelectionDirection;
    if (iStart == iEnd)
    {
        // Nothing previously selected, so use new direction
        dwSelectionDirection = dwKey;
    }
    else
    {
        // Base the selection direction on whether the caret is positioned
        // at the beginning or the end of the selection
        POINT pt;
        int cchCaret = iEnd;
        if (GetCaretPos(&pt))
        {
            cchCaret = (int)SendMessage(m_hwndEdit, EM_CHARFROMPOS, 0, (LPARAM)MAKELPARAM(pt.x, 0));
        }

        dwSelectionDirection = (cchCaret >= iEnd) ? VK_RIGHT : VK_LEFT;
    }


    if (fControl)
    {
        if (dwKey == VK_RIGHT)
        {
            // did we orginally go to the left?
            if (dwSelectionDirection == VK_LEFT)
            {
                // yes...unselect
                iStart = _JumpToNextBreak(iStart, WB_RIGHT);
 //               if (!iStart)
 //                   iStart = m_iCurrent;
            }
            else if (iEnd != m_iCurrent)
            {
                // select or "jump over" characters
                iEnd = _JumpToNextBreak(iEnd, WB_RIGHT);
 //               if (!iEnd)
 //                   iEnd = m_iCurrent;
            }
        }
        else // dwKey == VK_LEFT
        {
            // did we orginally go to the right?
            if (dwSelectionDirection == VK_RIGHT)
            {
                // yes...unselect
//                int iRemember = iEnd;
                iEnd = _JumpToNextBreak(iEnd, WB_LEFT);
            }
            else if (iStart)  // != 0
            {
                // select or "jump over" characters
                iStart = _JumpToNextBreak(iStart, WB_LEFT);
            }
        }
    }
    else // if !fControl
    {
        // This code is benign if the SHIFT key isn't down
        // because it has to do with modifying the selection.
        if (dwKey == VK_RIGHT)
        {
            if (dwSelectionDirection == VK_LEFT)
            {
                iStart++;
            }
            else
            {
                iEnd++;
            }
        }
        else // dwKey == VK_LEFT
        {
            LPTSTR pszPrev;
            if (dwSelectionDirection == VK_RIGHT)
            {
                pszPrev = CharPrev(m_pszCurrent, &m_pszCurrent[iEnd]);
                iEnd = (int)(pszPrev - m_pszCurrent);
            }
            else
            {
                pszPrev = CharPrev(m_pszCurrent, &m_pszCurrent[iStart]);
                iStart = (int)(pszPrev - m_pszCurrent);
            }
        }
    }

    // Are we selecting or moving?
    if (!fShift)
    {   // just moving...
        if (dwKey == VK_RIGHT)
        {
            iStart = iEnd;
        }
        else // pachi->dwSelectionDirection == VK_LEFT
        {
            iEnd = iStart;
        }
    }

    //
    // If we are selecting text to the left, we have to jump hoops
    // to get the caret on the left of the selection. Edit_SetSel
    // always places the caret on the right, and if we position the
    // caret ourselves the edit control still uses the old caret
    // position.  So we have to send VK_LEFT messages to the edit
    // control to get it to select things properly.
    //
    if (fShift && dwSelectionDirection == VK_LEFT && iStart < iEnd)
    {
        // Temporarily reset the control key (yuk!)
        BYTE keyState[256];
        BOOL fGetKeyboardState;

        if (fControl)
        {
            fGetKeyboardState = GetKeyboardState(keyState);

            if (fGetKeyboardState )
            {
                keyState[VK_CONTROL] &= 0x7f;
                SetKeyboardState(keyState);
            }
        }

        // Select the last character and select left
        // one character at a time.  Arrrggg.
        SendMessage(m_hwndEdit, WM_SETREDRAW, FALSE, 0);
        Edit_SetSel(m_hwndEdit, iEnd, iEnd);
        while (iEnd > iStart)
        {
            DefSubclassProc(m_hwndEdit, WM_KEYDOWN, VK_LEFT, 0);
            --iEnd;
        }
        SendMessage(m_hwndEdit, WM_SETREDRAW, TRUE, 0);
        InvalidateRect(m_hwndEdit, NULL, FALSE);
        UpdateWindow(m_hwndEdit);

        // Restore the control key
        if (fControl && fGetKeyboardState )
        {
            keyState[VK_CONTROL] |= 0x80;
            SetKeyboardState(keyState);
        }
    }
    else
    {
        Edit_SetSel(m_hwndEdit, iStart, iEnd);
    }

    return FALSE;   // we handled it
}

//+-------------------------------------------------------------------------
// Process WM_KEYDOWN message.  Returns TRUE if the message should be passed
// to the original wndproc.
//--------------------------------------------------------------------------
BOOL CAutoComplete::_OnKeyDown(WPARAM wParam)
{
    WPARAM wParamTranslated;

    TraceMsg(AC_GENERAL, "CAutoComplete::_OnKeyDown(wParam = 0x%x)",
        wParam);

    if (m_pThread->IsDisabled())
    {
        //
        // Let the original wndproc handle it.
        //
        return TRUE;
    }

    wParamTranslated = wParam;

    switch (wParamTranslated)
    {
    case VK_RETURN:
    {
        if (0 > GetKeyState(VK_CONTROL))
        {
            //
            // Ctrl-Enter does some quick formatting.
            //
            _GetEditText();
            _SetEditText(_QuickEnter());
        }
        else
        {
            //
            // Reset the search criteria.
            //
            _ResetSearch();

            //
            // Highlight entire text.
            //
            Edit_SetSel(m_hwndEdit, 0, (LPARAM)-1);
        }

        //
        // Stop any searches that are going on.
        //
        _StopSearch();

        //
        // For intelliforms, if the dropdown is visible and something
        // is selected in the dropdown, we simulate an activation event.
        //
        if (m_hwndList)
        {
            int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
            if ((iCurSel != -1) && m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                WCHAR szBuf[MAX_URL_STRING];
                _GetItem(iCurSel, szBuf, ARRAYSIZE(szBuf), FALSE);
                SendMessage(m_hwndEdit, m_uMsgItemActivate, 0, (LPARAM)szBuf);
            }
        }

        //
        // Hide the dropdown
        //
        _HideDropDown();

        // APPCOMPAT: For some reason, the original windproc is ignoring the return key.
        //         It should hide the dropdown!
        if (m_hwndCombo)
        {
            SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, FALSE, 0);
        }

        //
        // Let the original wndproc handle it.
        //
        break;
    }
    case VK_ESCAPE:
        _StopSearch();
        _HideDropDown();

        // APPCOMPAT: For some reason, the original windproc is ignoring the enter key.
        //         It should hide the dropdown!
        if (m_hwndCombo)
        {
            SendMessage(m_hwndCombo, CB_SHOWDROPDOWN, FALSE, 0);
        }
        break;

    case VK_LEFT:
    case VK_RIGHT:
        // We do our own cursor movement on win9x because EM_SETWORDBREAKPROC is broken.
        if (!g_fRunningOnNT)
        {
            return _CursorMovement(wParam);
        }
        break;

    case VK_PRIOR:
    case VK_UP:
        if (!(m_dwFlags & ACF_IGNOREUPDOWN) && !_IsComboboxDropped())
        {
            //
            // If the dropdown is visible, the up-down keys navigate our list
            //
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);

                if (iCurSel == 0)
                {
                    // If at top, move back up into the edit box
                    // Deselect the dropdown and select the edit box
                    ListView_SetItemState(m_hwndList, 0, 0, 0x000f);
                    if (m_pszCurrent)
                    {
                        // Restore original text if they arrow out of listview
                        _SetEditText(m_pszCurrent);
                    }
                    Edit_SetSel(m_hwndEdit, MAX_URL_STRING, MAX_URL_STRING);
                }
                else if (iCurSel != -1)
                {
                    // If in middle or at bottom, move up
                    SendMessage(m_hwndList, WM_KEYDOWN, wParam, 0);
                    SendMessage(m_hwndList, WM_KEYUP, wParam, 0);
                }
                else
                {
                    int iSelect = ListView_GetItemCount(m_hwndList)-1;

                    // If in edit box, move to bottom
                    ListView_SetItemState(m_hwndList, iSelect, LVIS_SELECTED|LVIS_FOCUSED, 0x000f);
                    ListView_EnsureVisible(m_hwndList, iSelect, FALSE);
                }
                return FALSE;
            }

            //
            // If Autosuggest drop-down enabled but not popped up then start a search
            // based on the current edit box contents.  If the edit box is empty,
            // search for everything.
            //
            else if ((m_dwOptions & ACO_UPDOWNKEYDROPSLIST) && _IsAutoSuggestEnabled())
            {
                // Ensure the background thread knows we have focus
                _GotFocus();
                _StartCompletion(FALSE, TRUE);
                return FALSE;
            }

            //
            // Otherwise we see if we should append the completions in place
            //
            else if (_IsAutoAppendEnabled())
            {
                if (_AppendPrevious(FALSE))
                {
                    return FALSE;
                }
            }
        }
        break;
    case VK_NEXT:
    case VK_DOWN:
        if (!(m_dwFlags & ACF_IGNOREUPDOWN) && !_IsComboboxDropped())
        {
            //
            // If the dropdown is visible, the up-down keys navigate our list
            //
            if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
            {
                ASSERT(m_hdpa);
                ASSERT(DPA_GetPtrCount(m_hdpa) != 0);
                ASSERT(m_iFirstMatch != -1);

                int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
                if (iCurSel == -1)
                {
                    // If no item selected, first down arrow selects first item
                    ListView_SetItemState(m_hwndList, 0, LVIS_SELECTED | LVIS_FOCUSED, 0x000f);
                    ListView_EnsureVisible(m_hwndList, 0, FALSE);
                }
                else if (iCurSel == ListView_GetItemCount(m_hwndList)-1)
                {
                    // If last item selected, down arrow goes into edit box
                    ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
                    if (m_pszCurrent)
                    {
                        // Restore original text if they arrow out of listview
                        _SetEditText(m_pszCurrent);
                    }
                    Edit_SetSel(m_hwndEdit, MAX_URL_STRING, MAX_URL_STRING);
                }
                else
                {
                    // If first or middle item selected, down arrow selects next item
                    SendMessage(m_hwndList, WM_KEYDOWN, wParam, 0);
                    SendMessage(m_hwndList, WM_KEYUP, wParam, 0);
                }
                return FALSE;
            }

            //
            // If Autosuggest drop-down enabled but not popped up then start a search
            // based on the current edit box contents.  If the edit box is empty,
            // search for everything.
            //
            else if ((m_dwOptions & ACO_UPDOWNKEYDROPSLIST) && _IsAutoSuggestEnabled())
            {
                // Ensure the background thread knows we have focus
                _GotFocus();
                _StartCompletion(FALSE, TRUE);
                return FALSE;
            }

            //
            // Otherwise we see if we should append the completions in place
            //
            else if (_IsAutoAppendEnabled())
            {
                if (_AppendNext(FALSE))
                {
                    return FALSE;
                }
            }
        }
        break;

    case VK_END:
    case VK_HOME:
        _ResetSearch();
        break;

    case VK_BACK:
        //
        // Indicate that selection doesn't match m_psrCurrentlyDisplayed.
        //

        if (0 > GetKeyState(VK_CONTROL))
        {
            //
            // Handle Ctrl-Backspace to delete word.
            //
            int iStart, iEnd;
            SendMessage(m_hwndEdit, EM_GETSEL, (WPARAM)&iStart, (LPARAM)&iEnd);

            //
            // Nothing else must be selected.
            //
            if (iStart == iEnd)
            {
                _GetEditText();
                if (!m_pszCurrent)
                {
                    //
                    // We didn't handle it, let the
                    // other wndprocs try.
                    //
                    return TRUE;
                }

                //
                // Erase the "word".
                //
                iStart = EditWordBreakProcW(m_pszCurrent, iStart, iStart+1, WB_LEFT);
                Edit_SetSel(m_hwndEdit, iStart, iEnd);
                Edit_ReplaceSel(m_hwndEdit, TEXT(""));
            }

            //
            // We handled it.
            //
            return FALSE;
        }
        break;
    }

    //
    // Let the original wndproc handle it.
    //
    return TRUE;
}

LRESULT CAutoComplete::_OnChar(WPARAM wParam, LPARAM lParam)
{
    LRESULT lres = 0;   // means nothing, but we handled the call
    TCHAR   cKey = (TCHAR) wParam;

    if (wParam == VK_TAB)
    {
        // Ignore tab characters
        return 0;
    }

    // Ensure the background thread knows we have focus
    _GotFocus();

    if (m_pThread->IsDisabled())
    {
        //
        // Just follow the chain.
        //
        return DefSubclassProc(m_hwndEdit, WM_CHAR, wParam, lParam);
    }

    if (cKey != 127 && cKey != VK_ESCAPE && cKey != VK_RETURN && cKey != 0x0a)    // control-backspace is ignored
    {
        // let the default edit wndproc do its thing first
        lres = DefSubclassProc(m_hwndEdit, WM_CHAR, wParam, lParam);

        // ctrl-c is generating a VK_CANCEL.  Don't bring up autosuggest in this case.
        if (cKey != VK_CANCEL)
        {
            BOOL fAppend = (cKey != VK_BACK);
            _StartCompletion(fAppend);
        }
    }
    else
    {
        _StopSearch();
        _HideDropDown();
    }

    return lres;
}

//+-------------------------------------------------------------------------
// Starts autocomplete based on the current editbox contents
//--------------------------------------------------------------------------
void CAutoComplete::_StartCompletion
(
    BOOL fAppend,       // Ok to append completion in edit box
    BOOL fEvenIfEmpty   // = FALSE, Completes to everything if edit box is empty
)
{
    // Get the text typed in
    WCHAR szCurrent[MAX_URL_STRING];
    int cchCurrent = GetWindowText(m_hwndEdit, szCurrent, ARRAYSIZE(szCurrent));

    // See if we want a wildcard search
    if (fEvenIfEmpty && cchCurrent == 0)
    {
        cchCurrent = 1;
        szCurrent[0] = CH_WILDCARD;
        szCurrent[1] = 0;
    }

    // If unchanged, we are done
    if (m_pszLastSearch && m_pszCurrent && StrCmpI(m_pszCurrent, szCurrent) == 0)
    {
        if (!(m_hwndDropDown && IsWindowVisible(m_hwndDropDown)) &&
            (-1 != m_iFirstMatch) && _IsAutoSuggestEnabled() &&

            // Don't show drop-down if only one exact match (IForms)
            (m_hdpa &&
             ((m_iLastMatch != m_iFirstMatch) || (((CACString*)DPA_GetPtr(m_hdpa, m_iFirstMatch))->StrCmpI(szCurrent) != 0))))
        {
            _ShowDropDown();
        }
        return;
    }

    // Save the current text
    if (szCurrent[0] == CH_WILDCARD)
    {
        SetStr(&m_pszCurrent, szCurrent);
    }
    else
    {
        _GetEditText();
    }

    //
    // Deselect the current selection in the dropdown
    //
    if (m_hwndList)
    {
        int iCurSel = ListView_GetNextItem(m_hwndList, -1, LVNI_SELECTED);
        if (iCurSel != -1)
        {
            ListView_SetItemState(m_hwndList, iCurSel, 0, 0x000f);
        }
    }

    //
    // If nothing typed in, stop any pending search
    //
    if (cchCurrent == 0)
    {
        if (m_pszCurrent)
        {
            _StopSearch();
            if (m_pszCurrent)
            {
                SetStr(&m_pszCurrent, NULL);
            }

            // Free last completion
            _HideDropDown();
        }
    }

    //
    // See if we need to generate a new list
    //
    else
    {
        int iCompleted = m_pszLastSearch ? lstrlen(m_pszLastSearch) : 0;
        int iScheme = URL_SCHEME_UNKNOWN;

        // Get length of common prefix (if any)
        int cchPrefix = IsFlagSet(m_dwOptions, ACO_FILTERPREFIXES) ?
                            CACThread::GetSpecialPrefixLen(szCurrent) : 0;

        if  (
             // If no previous completion, start a new search
             (0 == iCompleted) ||

             // If the list was truncated (reached limit), we need to refetch
             m_fNeedNewList ||

             // We purge matches to common prefixes ("www.", "http://" etc). If the
             // last search may have resulted in items being filtered out, and the
             // new string will not, then we need to refetch.
             (cchPrefix > 0 && cchPrefix < cchCurrent && CACThread::MatchesSpecialPrefix(m_pszLastSearch)) ||

             // If the portion we last completed to was altered, we need to refetch
             (StrCmpNI(m_pszLastSearch, szCurrent, iCompleted) != 0) ||

             // If we have entered a new folder, we need to refetch
             (StrChrI(szCurrent + iCompleted, DIR_SEPARATOR_CHAR) != NULL) ||

             // If we have entered a url folder, we need to refetch (ftp://shapitst/Bryanst/)
             ((StrChrI(szCurrent + iCompleted, URL_SEPARATOR_CHAR) != NULL) &&
              (URL_SCHEME_FTP == (iScheme = GetUrlScheme(szCurrent))))
            )
        {
            // If the last search was truncated, make sure we try the next search with more characters
            int cchMin = cchPrefix + 1;
            if (m_fNeedNewList)
            {
                cchMin = iCompleted + 1;
            }

            // Find the last '\\' (or '/' for ftp)
            int i = cchCurrent - 1;
            while ((szCurrent[i] != DIR_SEPARATOR_CHAR) &&
                    !((szCurrent[i] == URL_SEPARATOR_CHAR) && (iScheme == URL_SCHEME_FTP)) &&
                    (i >= cchMin))
            {
                --i;
            }

            // Start a new search
            szCurrent[i+1] = 0;
            if (_StartSearch(szCurrent))
                SetStr(&m_pszLastSearch, szCurrent);
        }

        // Otherwise we can simply update from our last completion list
        else
        {
            //
            if (m_hdpa)
            {
                _UpdateCompletion(szCurrent, -1, fAppend);
            }
            else
            {
                // Awaiting completion, cache new match...
            }
        }
    }
}

//+-------------------------------------------------------------------------
// Get the background thread to start a new search
//--------------------------------------------------------------------------
BOOL CAutoComplete::_StartSearch(LPCWSTR pszSeatch)
{
    // Empty the dropdown list.  To minimize flash, we don't hide it unless
    // the search comes up empty
    if (m_hwndList)
    {
        ListView_SetItemCountEx(m_hwndList, 0, 0);
    }

    return m_pThread->StartSearch(pszSeatch, m_dwOptions);
}

//+-------------------------------------------------------------------------
// Get the background thread to abort the last search
//--------------------------------------------------------------------------
void CAutoComplete::_StopSearch()
{
    SetStr(&m_pszLastSearch, NULL);
    m_pThread->StopSearch();
}

//+-------------------------------------------------------------------------
// Informs the background thread that we have focus.
//--------------------------------------------------------------------------
void CAutoComplete::_GotFocus()
{
    if (!m_pThread->HasFocus())
    {
        m_pThread->GotFocus();
    }
}

//+-------------------------------------------------------------------------
// Message from background thread indicating that the search was completed
//--------------------------------------------------------------------------
void CAutoComplete::_OnSearchComplete
(
    HDPA hdpa,           // New completion list
    DWORD dwSearchStatus // see SRCH_* flags
)
{
    _FreeDPAPtrs(m_hdpa);
    m_hdpa = hdpa;
    m_fNeedNewList = IsFlagSet(dwSearchStatus, SRCH_LIMITREACHED);

    if (IsFlagSet(dwSearchStatus, SRCH_USESORTINDEX))
    {
        if (NULL == m_hdpaSortIndex)
        {
            m_hdpaSortIndex = DPA_Create(AC_LIST_GROWTH_CONST);
        }
    }
    else if (m_hdpaSortIndex)
    {
        DPA_Destroy(m_hdpaSortIndex);
        m_hdpaSortIndex = NULL;
    }

    // Was it a wildcard search?
    BOOL fWildCard = m_pszLastSearch && (m_pszLastSearch[0] == CH_WILDCARD) && (m_pszLastSearch[1] == L'\0');

    //
    // See if we should add "Search for <stuff typed in>" to the end of
    // the list.
    //
    m_fSearchForAdded = FALSE;

    if (!fWildCard && (m_dwOptions & ACO_SEARCH))
    {
        // Add "Search for <stuff typed in>" to the end of the list

        // First make sure we have a dpa
        if (m_hdpa == NULL)
        {
            m_hdpa = DPA_Create(AC_LIST_GROWTH_CONST);
        }

        if (m_hdpa)
        {
            // Create a bogus entry and add to the end of the list. This place
            // holder makes sure the drop-down does not go away when there are no
            // matching entries.
            CACString* pStr = CreateACString(L"", 0, 0);

            if (pStr)
            {
                if (DPA_AppendPtr(m_hdpa, pStr) != -1)
                {
                    m_fSearchForAdded = TRUE;
                }
                else
                {
                    pStr->Release();
                }
            }
        }
    }

    // If no search results, hide our dropdown
    if (NULL == m_hdpa || 0 == DPA_GetPtrCount(m_hdpa))
    {
        _HideDropDown();
        if (m_hwndList)
        {
            ListView_SetItemCountEx(m_hwndList, 0, 0);
        }
        m_iFirstMatch = -1;
    }
    else
    {
        if (m_pszCurrent)
        {
            // If we are still waiting for a completion, then update the completion list
            if (m_pszLastSearch)
            {
                _UpdateCompletion(m_pszCurrent, -1, TRUE);
            }
        }

        if (m_hwndDropDown && IsWindowVisible(m_hwndDropDown))
        {
            _PositionDropDown();        // Resize based on number of hits
            _UpdateScrollbar();
        }
    }
}

//+-------------------------------------------------------